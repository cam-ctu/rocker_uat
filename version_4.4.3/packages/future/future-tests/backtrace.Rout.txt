
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:00:43.097] plan(): Setting new future strategy stack:
[11:00:43.098] List of future strategies:
[11:00:43.098] 1. sequential:
[11:00:43.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.098]    - tweaked: FALSE
[11:00:43.098]    - call: future::plan("sequential")
[11:00:43.111] plan(): nbrOfWorkers() = 1
> 
> message("*** backtrace( ) ...")
*** backtrace( ) ...
> 
> message("*** backtrace( ) - explicit future ...")
*** backtrace( ) - explicit future ...
> 
> f <- future({ 42L; stop("Woops") })
[11:00:43.127] getGlobalsAndPackages() ...
[11:00:43.127] Searching for globals...
[11:00:43.132] - globals found: [2] ‘{’, ‘stop’
[11:00:43.133] Searching for globals ... DONE
[11:00:43.133] Resolving globals: FALSE
[11:00:43.133] 
[11:00:43.133] 
[11:00:43.133] getGlobalsAndPackages() ... DONE
[11:00:43.134] run() for ‘Future’ ...
[11:00:43.134] - state: ‘created’
[11:00:43.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.135]   - Field: ‘label’
[11:00:43.135]   - Field: ‘local’
[11:00:43.135]   - Field: ‘owner’
[11:00:43.135]   - Field: ‘envir’
[11:00:43.135]   - Field: ‘packages’
[11:00:43.135]   - Field: ‘gc’
[11:00:43.135]   - Field: ‘conditions’
[11:00:43.135]   - Field: ‘expr’
[11:00:43.135]   - Field: ‘uuid’
[11:00:43.135]   - Field: ‘seed’
[11:00:43.135]   - Field: ‘version’
[11:00:43.136]   - Field: ‘result’
[11:00:43.136]   - Field: ‘asynchronous’
[11:00:43.136]   - Field: ‘calls’
[11:00:43.136]   - Field: ‘globals’
[11:00:43.136]   - Field: ‘stdout’
[11:00:43.136]   - Field: ‘earlySignal’
[11:00:43.136]   - Field: ‘lazy’
[11:00:43.136]   - Field: ‘state’
[11:00:43.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.136] - Launch lazy future ...
[11:00:43.137] Packages needed by the future expression (n = 0): <none>
[11:00:43.137] Packages needed by future strategies (n = 0): <none>
[11:00:43.138] {
[11:00:43.138]     {
[11:00:43.138]         {
[11:00:43.138]             ...future.startTime <- base::Sys.time()
[11:00:43.138]             {
[11:00:43.138]                 {
[11:00:43.138]                   {
[11:00:43.138]                     base::local({
[11:00:43.138]                       has_future <- base::requireNamespace("future", 
[11:00:43.138]                         quietly = TRUE)
[11:00:43.138]                       if (has_future) {
[11:00:43.138]                         ns <- base::getNamespace("future")
[11:00:43.138]                         version <- ns[[".package"]][["version"]]
[11:00:43.138]                         if (is.null(version)) 
[11:00:43.138]                           version <- utils::packageVersion("future")
[11:00:43.138]                       }
[11:00:43.138]                       else {
[11:00:43.138]                         version <- NULL
[11:00:43.138]                       }
[11:00:43.138]                       if (!has_future || version < "1.8.0") {
[11:00:43.138]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.138]                           "", base::R.version$version.string), 
[11:00:43.138]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.138]                             "release", "version")], collapse = " "), 
[11:00:43.138]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.138]                           info)
[11:00:43.138]                         info <- base::paste(info, collapse = "; ")
[11:00:43.138]                         if (!has_future) {
[11:00:43.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.138]                             info)
[11:00:43.138]                         }
[11:00:43.138]                         else {
[11:00:43.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.138]                             info, version)
[11:00:43.138]                         }
[11:00:43.138]                         base::stop(msg)
[11:00:43.138]                       }
[11:00:43.138]                     })
[11:00:43.138]                   }
[11:00:43.138]                   ...future.strategy.old <- future::plan("list")
[11:00:43.138]                   options(future.plan = NULL)
[11:00:43.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.138]                 }
[11:00:43.138]                 ...future.workdir <- getwd()
[11:00:43.138]             }
[11:00:43.138]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.138]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.138]         }
[11:00:43.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.138]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.138]             base::names(...future.oldOptions))
[11:00:43.138]     }
[11:00:43.138]     if (FALSE) {
[11:00:43.138]     }
[11:00:43.138]     else {
[11:00:43.138]         if (TRUE) {
[11:00:43.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.138]                 open = "w")
[11:00:43.138]         }
[11:00:43.138]         else {
[11:00:43.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.138]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.138]         }
[11:00:43.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.138]             base::sink(type = "output", split = FALSE)
[11:00:43.138]             base::close(...future.stdout)
[11:00:43.138]         }, add = TRUE)
[11:00:43.138]     }
[11:00:43.138]     ...future.frame <- base::sys.nframe()
[11:00:43.138]     ...future.conditions <- base::list()
[11:00:43.138]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.138]     if (FALSE) {
[11:00:43.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.138]     }
[11:00:43.138]     ...future.result <- base::tryCatch({
[11:00:43.138]         base::withCallingHandlers({
[11:00:43.138]             ...future.value <- base::withVisible(base::local({
[11:00:43.138]                 42L
[11:00:43.138]                 stop("Woops")
[11:00:43.138]             }))
[11:00:43.138]             future::FutureResult(value = ...future.value$value, 
[11:00:43.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.138]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.138]                     ...future.globalenv.names))
[11:00:43.138]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.138]         }, condition = base::local({
[11:00:43.138]             c <- base::c
[11:00:43.138]             inherits <- base::inherits
[11:00:43.138]             invokeRestart <- base::invokeRestart
[11:00:43.138]             length <- base::length
[11:00:43.138]             list <- base::list
[11:00:43.138]             seq.int <- base::seq.int
[11:00:43.138]             signalCondition <- base::signalCondition
[11:00:43.138]             sys.calls <- base::sys.calls
[11:00:43.138]             `[[` <- base::`[[`
[11:00:43.138]             `+` <- base::`+`
[11:00:43.138]             `<<-` <- base::`<<-`
[11:00:43.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.138]                   3L)]
[11:00:43.138]             }
[11:00:43.138]             function(cond) {
[11:00:43.138]                 is_error <- inherits(cond, "error")
[11:00:43.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.138]                   NULL)
[11:00:43.138]                 if (is_error) {
[11:00:43.138]                   sessionInformation <- function() {
[11:00:43.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.138]                       search = base::search(), system = base::Sys.info())
[11:00:43.138]                   }
[11:00:43.138]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.138]                     cond$call), session = sessionInformation(), 
[11:00:43.138]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.138]                   signalCondition(cond)
[11:00:43.138]                 }
[11:00:43.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.138]                 "immediateCondition"))) {
[11:00:43.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.138]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.138]                   if (TRUE && !signal) {
[11:00:43.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.138]                     {
[11:00:43.138]                       inherits <- base::inherits
[11:00:43.138]                       invokeRestart <- base::invokeRestart
[11:00:43.138]                       is.null <- base::is.null
[11:00:43.138]                       muffled <- FALSE
[11:00:43.138]                       if (inherits(cond, "message")) {
[11:00:43.138]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.138]                         if (muffled) 
[11:00:43.138]                           invokeRestart("muffleMessage")
[11:00:43.138]                       }
[11:00:43.138]                       else if (inherits(cond, "warning")) {
[11:00:43.138]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.138]                         if (muffled) 
[11:00:43.138]                           invokeRestart("muffleWarning")
[11:00:43.138]                       }
[11:00:43.138]                       else if (inherits(cond, "condition")) {
[11:00:43.138]                         if (!is.null(pattern)) {
[11:00:43.138]                           computeRestarts <- base::computeRestarts
[11:00:43.138]                           grepl <- base::grepl
[11:00:43.138]                           restarts <- computeRestarts(cond)
[11:00:43.138]                           for (restart in restarts) {
[11:00:43.138]                             name <- restart$name
[11:00:43.138]                             if (is.null(name)) 
[11:00:43.138]                               next
[11:00:43.138]                             if (!grepl(pattern, name)) 
[11:00:43.138]                               next
[11:00:43.138]                             invokeRestart(restart)
[11:00:43.138]                             muffled <- TRUE
[11:00:43.138]                             break
[11:00:43.138]                           }
[11:00:43.138]                         }
[11:00:43.138]                       }
[11:00:43.138]                       invisible(muffled)
[11:00:43.138]                     }
[11:00:43.138]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.138]                   }
[11:00:43.138]                 }
[11:00:43.138]                 else {
[11:00:43.138]                   if (TRUE) {
[11:00:43.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.138]                     {
[11:00:43.138]                       inherits <- base::inherits
[11:00:43.138]                       invokeRestart <- base::invokeRestart
[11:00:43.138]                       is.null <- base::is.null
[11:00:43.138]                       muffled <- FALSE
[11:00:43.138]                       if (inherits(cond, "message")) {
[11:00:43.138]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.138]                         if (muffled) 
[11:00:43.138]                           invokeRestart("muffleMessage")
[11:00:43.138]                       }
[11:00:43.138]                       else if (inherits(cond, "warning")) {
[11:00:43.138]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.138]                         if (muffled) 
[11:00:43.138]                           invokeRestart("muffleWarning")
[11:00:43.138]                       }
[11:00:43.138]                       else if (inherits(cond, "condition")) {
[11:00:43.138]                         if (!is.null(pattern)) {
[11:00:43.138]                           computeRestarts <- base::computeRestarts
[11:00:43.138]                           grepl <- base::grepl
[11:00:43.138]                           restarts <- computeRestarts(cond)
[11:00:43.138]                           for (restart in restarts) {
[11:00:43.138]                             name <- restart$name
[11:00:43.138]                             if (is.null(name)) 
[11:00:43.138]                               next
[11:00:43.138]                             if (!grepl(pattern, name)) 
[11:00:43.138]                               next
[11:00:43.138]                             invokeRestart(restart)
[11:00:43.138]                             muffled <- TRUE
[11:00:43.138]                             break
[11:00:43.138]                           }
[11:00:43.138]                         }
[11:00:43.138]                       }
[11:00:43.138]                       invisible(muffled)
[11:00:43.138]                     }
[11:00:43.138]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.138]                   }
[11:00:43.138]                 }
[11:00:43.138]             }
[11:00:43.138]         }))
[11:00:43.138]     }, error = function(ex) {
[11:00:43.138]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.138]                 ...future.rng), started = ...future.startTime, 
[11:00:43.138]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.138]             version = "1.8"), class = "FutureResult")
[11:00:43.138]     }, finally = {
[11:00:43.138]         if (!identical(...future.workdir, getwd())) 
[11:00:43.138]             setwd(...future.workdir)
[11:00:43.138]         {
[11:00:43.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.138]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.138]             }
[11:00:43.138]             base::options(...future.oldOptions)
[11:00:43.138]             if (.Platform$OS.type == "windows") {
[11:00:43.138]                 old_names <- names(...future.oldEnvVars)
[11:00:43.138]                 envs <- base::Sys.getenv()
[11:00:43.138]                 names <- names(envs)
[11:00:43.138]                 common <- intersect(names, old_names)
[11:00:43.138]                 added <- setdiff(names, old_names)
[11:00:43.138]                 removed <- setdiff(old_names, names)
[11:00:43.138]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.138]                   envs[common]]
[11:00:43.138]                 NAMES <- toupper(changed)
[11:00:43.138]                 args <- list()
[11:00:43.138]                 for (kk in seq_along(NAMES)) {
[11:00:43.138]                   name <- changed[[kk]]
[11:00:43.138]                   NAME <- NAMES[[kk]]
[11:00:43.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.138]                     next
[11:00:43.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.138]                 }
[11:00:43.138]                 NAMES <- toupper(added)
[11:00:43.138]                 for (kk in seq_along(NAMES)) {
[11:00:43.138]                   name <- added[[kk]]
[11:00:43.138]                   NAME <- NAMES[[kk]]
[11:00:43.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.138]                     next
[11:00:43.138]                   args[[name]] <- ""
[11:00:43.138]                 }
[11:00:43.138]                 NAMES <- toupper(removed)
[11:00:43.138]                 for (kk in seq_along(NAMES)) {
[11:00:43.138]                   name <- removed[[kk]]
[11:00:43.138]                   NAME <- NAMES[[kk]]
[11:00:43.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.138]                     next
[11:00:43.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.138]                 }
[11:00:43.138]                 if (length(args) > 0) 
[11:00:43.138]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.138]             }
[11:00:43.138]             else {
[11:00:43.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.138]             }
[11:00:43.138]             {
[11:00:43.138]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.138]                   0L) {
[11:00:43.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.138]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.138]                   base::options(opts)
[11:00:43.138]                 }
[11:00:43.138]                 {
[11:00:43.138]                   {
[11:00:43.138]                     NULL
[11:00:43.138]                     RNGkind("Mersenne-Twister")
[11:00:43.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.138]                       inherits = FALSE)
[11:00:43.138]                   }
[11:00:43.138]                   options(future.plan = NULL)
[11:00:43.138]                   if (is.na(NA_character_)) 
[11:00:43.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.138]                     .init = FALSE)
[11:00:43.138]                 }
[11:00:43.138]             }
[11:00:43.138]         }
[11:00:43.138]     })
[11:00:43.138]     if (TRUE) {
[11:00:43.138]         base::sink(type = "output", split = FALSE)
[11:00:43.138]         if (TRUE) {
[11:00:43.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.138]         }
[11:00:43.138]         else {
[11:00:43.138]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.138]         }
[11:00:43.138]         base::close(...future.stdout)
[11:00:43.138]         ...future.stdout <- NULL
[11:00:43.138]     }
[11:00:43.138]     ...future.result$conditions <- ...future.conditions
[11:00:43.138]     ...future.result$finished <- base::Sys.time()
[11:00:43.138]     ...future.result
[11:00:43.138] }
[11:00:43.140] plan(): Setting new future strategy stack:
[11:00:43.140] List of future strategies:
[11:00:43.140] 1. sequential:
[11:00:43.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.140]    - tweaked: FALSE
[11:00:43.140]    - call: NULL
[11:00:43.140] plan(): nbrOfWorkers() = 1
[11:00:43.141] plan(): Setting new future strategy stack:
[11:00:43.141] List of future strategies:
[11:00:43.141] 1. sequential:
[11:00:43.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.141]    - tweaked: FALSE
[11:00:43.141]    - call: future::plan("sequential")
[11:00:43.142] plan(): nbrOfWorkers() = 1
[11:00:43.142] SequentialFuture started (and completed)
[11:00:43.142] signalConditions() ...
[11:00:43.142]  - include = ‘immediateCondition’
[11:00:43.142]  - exclude = 
[11:00:43.142]  - resignal = FALSE
[11:00:43.142]  - Number of conditions: 1
[11:00:43.143] signalConditions() ... done
[11:00:43.143] - Launch lazy future ... done
[11:00:43.143] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[11:00:43.143] signalConditions() ...
[11:00:43.143]  - include = ‘immediateCondition’
[11:00:43.143]  - exclude = 
[11:00:43.143]  - resignal = FALSE
[11:00:43.143]  - Number of conditions: 1
[11:00:43.143] signalConditions() ... done
> print(v)
<simpleError in eval(quote({    42L    stop("Woops")}), new.env()): Woops>
> calls <- backtrace(f)
[11:00:43.144] resolved() for ‘SequentialFuture’ ...
[11:00:43.145] - state: ‘finished’
[11:00:43.145] - run: TRUE
[11:00:43.145] - result: ‘FutureResult’
[11:00:43.145] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - explicit future ... DONE")
*** backtrace( ) - explicit future ... DONE
> 
> 
> message("*** backtrace( ) - implicit future ...")
*** backtrace( ) - implicit future ...
> 
> v %<-% { 42L; stop("Woops") }
[11:00:43.145] getGlobalsAndPackages() ...
[11:00:43.146] Searching for globals...
[11:00:43.146] - globals found: [2] ‘{’, ‘stop’
[11:00:43.146] Searching for globals ... DONE
[11:00:43.147] Resolving globals: FALSE
[11:00:43.147] 
[11:00:43.147] 
[11:00:43.147] getGlobalsAndPackages() ... DONE
[11:00:43.147] run() for ‘Future’ ...
[11:00:43.147] - state: ‘created’
[11:00:43.147] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.148] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.148]   - Field: ‘label’
[11:00:43.148]   - Field: ‘local’
[11:00:43.148]   - Field: ‘owner’
[11:00:43.148]   - Field: ‘envir’
[11:00:43.148]   - Field: ‘packages’
[11:00:43.148]   - Field: ‘gc’
[11:00:43.148]   - Field: ‘conditions’
[11:00:43.149]   - Field: ‘expr’
[11:00:43.149]   - Field: ‘uuid’
[11:00:43.149]   - Field: ‘seed’
[11:00:43.149]   - Field: ‘version’
[11:00:43.149]   - Field: ‘result’
[11:00:43.149]   - Field: ‘asynchronous’
[11:00:43.149]   - Field: ‘calls’
[11:00:43.149]   - Field: ‘globals’
[11:00:43.149]   - Field: ‘stdout’
[11:00:43.149]   - Field: ‘earlySignal’
[11:00:43.149]   - Field: ‘lazy’
[11:00:43.149]   - Field: ‘state’
[11:00:43.150] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.150] - Launch lazy future ...
[11:00:43.150] Packages needed by the future expression (n = 0): <none>
[11:00:43.150] Packages needed by future strategies (n = 0): <none>
[11:00:43.150] {
[11:00:43.150]     {
[11:00:43.150]         {
[11:00:43.150]             ...future.startTime <- base::Sys.time()
[11:00:43.150]             {
[11:00:43.150]                 {
[11:00:43.150]                   {
[11:00:43.150]                     base::local({
[11:00:43.150]                       has_future <- base::requireNamespace("future", 
[11:00:43.150]                         quietly = TRUE)
[11:00:43.150]                       if (has_future) {
[11:00:43.150]                         ns <- base::getNamespace("future")
[11:00:43.150]                         version <- ns[[".package"]][["version"]]
[11:00:43.150]                         if (is.null(version)) 
[11:00:43.150]                           version <- utils::packageVersion("future")
[11:00:43.150]                       }
[11:00:43.150]                       else {
[11:00:43.150]                         version <- NULL
[11:00:43.150]                       }
[11:00:43.150]                       if (!has_future || version < "1.8.0") {
[11:00:43.150]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.150]                           "", base::R.version$version.string), 
[11:00:43.150]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.150]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.150]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.150]                             "release", "version")], collapse = " "), 
[11:00:43.150]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.150]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.150]                           info)
[11:00:43.150]                         info <- base::paste(info, collapse = "; ")
[11:00:43.150]                         if (!has_future) {
[11:00:43.150]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.150]                             info)
[11:00:43.150]                         }
[11:00:43.150]                         else {
[11:00:43.150]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.150]                             info, version)
[11:00:43.150]                         }
[11:00:43.150]                         base::stop(msg)
[11:00:43.150]                       }
[11:00:43.150]                     })
[11:00:43.150]                   }
[11:00:43.150]                   ...future.strategy.old <- future::plan("list")
[11:00:43.150]                   options(future.plan = NULL)
[11:00:43.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.150]                 }
[11:00:43.150]                 ...future.workdir <- getwd()
[11:00:43.150]             }
[11:00:43.150]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.150]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.150]         }
[11:00:43.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.150]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.150]             base::names(...future.oldOptions))
[11:00:43.150]     }
[11:00:43.150]     if (FALSE) {
[11:00:43.150]     }
[11:00:43.150]     else {
[11:00:43.150]         if (TRUE) {
[11:00:43.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.150]                 open = "w")
[11:00:43.150]         }
[11:00:43.150]         else {
[11:00:43.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.150]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.150]         }
[11:00:43.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.150]             base::sink(type = "output", split = FALSE)
[11:00:43.150]             base::close(...future.stdout)
[11:00:43.150]         }, add = TRUE)
[11:00:43.150]     }
[11:00:43.150]     ...future.frame <- base::sys.nframe()
[11:00:43.150]     ...future.conditions <- base::list()
[11:00:43.150]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.150]     if (FALSE) {
[11:00:43.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.150]     }
[11:00:43.150]     ...future.result <- base::tryCatch({
[11:00:43.150]         base::withCallingHandlers({
[11:00:43.150]             ...future.value <- base::withVisible(base::local({
[11:00:43.150]                 42L
[11:00:43.150]                 stop("Woops")
[11:00:43.150]             }))
[11:00:43.150]             future::FutureResult(value = ...future.value$value, 
[11:00:43.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.150]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.150]                     ...future.globalenv.names))
[11:00:43.150]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.150]         }, condition = base::local({
[11:00:43.150]             c <- base::c
[11:00:43.150]             inherits <- base::inherits
[11:00:43.150]             invokeRestart <- base::invokeRestart
[11:00:43.150]             length <- base::length
[11:00:43.150]             list <- base::list
[11:00:43.150]             seq.int <- base::seq.int
[11:00:43.150]             signalCondition <- base::signalCondition
[11:00:43.150]             sys.calls <- base::sys.calls
[11:00:43.150]             `[[` <- base::`[[`
[11:00:43.150]             `+` <- base::`+`
[11:00:43.150]             `<<-` <- base::`<<-`
[11:00:43.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.150]                   3L)]
[11:00:43.150]             }
[11:00:43.150]             function(cond) {
[11:00:43.150]                 is_error <- inherits(cond, "error")
[11:00:43.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.150]                   NULL)
[11:00:43.150]                 if (is_error) {
[11:00:43.150]                   sessionInformation <- function() {
[11:00:43.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.150]                       search = base::search(), system = base::Sys.info())
[11:00:43.150]                   }
[11:00:43.150]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.150]                     cond$call), session = sessionInformation(), 
[11:00:43.150]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.150]                   signalCondition(cond)
[11:00:43.150]                 }
[11:00:43.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.150]                 "immediateCondition"))) {
[11:00:43.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.150]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.150]                   if (TRUE && !signal) {
[11:00:43.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.150]                     {
[11:00:43.150]                       inherits <- base::inherits
[11:00:43.150]                       invokeRestart <- base::invokeRestart
[11:00:43.150]                       is.null <- base::is.null
[11:00:43.150]                       muffled <- FALSE
[11:00:43.150]                       if (inherits(cond, "message")) {
[11:00:43.150]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.150]                         if (muffled) 
[11:00:43.150]                           invokeRestart("muffleMessage")
[11:00:43.150]                       }
[11:00:43.150]                       else if (inherits(cond, "warning")) {
[11:00:43.150]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.150]                         if (muffled) 
[11:00:43.150]                           invokeRestart("muffleWarning")
[11:00:43.150]                       }
[11:00:43.150]                       else if (inherits(cond, "condition")) {
[11:00:43.150]                         if (!is.null(pattern)) {
[11:00:43.150]                           computeRestarts <- base::computeRestarts
[11:00:43.150]                           grepl <- base::grepl
[11:00:43.150]                           restarts <- computeRestarts(cond)
[11:00:43.150]                           for (restart in restarts) {
[11:00:43.150]                             name <- restart$name
[11:00:43.150]                             if (is.null(name)) 
[11:00:43.150]                               next
[11:00:43.150]                             if (!grepl(pattern, name)) 
[11:00:43.150]                               next
[11:00:43.150]                             invokeRestart(restart)
[11:00:43.150]                             muffled <- TRUE
[11:00:43.150]                             break
[11:00:43.150]                           }
[11:00:43.150]                         }
[11:00:43.150]                       }
[11:00:43.150]                       invisible(muffled)
[11:00:43.150]                     }
[11:00:43.150]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.150]                   }
[11:00:43.150]                 }
[11:00:43.150]                 else {
[11:00:43.150]                   if (TRUE) {
[11:00:43.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.150]                     {
[11:00:43.150]                       inherits <- base::inherits
[11:00:43.150]                       invokeRestart <- base::invokeRestart
[11:00:43.150]                       is.null <- base::is.null
[11:00:43.150]                       muffled <- FALSE
[11:00:43.150]                       if (inherits(cond, "message")) {
[11:00:43.150]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.150]                         if (muffled) 
[11:00:43.150]                           invokeRestart("muffleMessage")
[11:00:43.150]                       }
[11:00:43.150]                       else if (inherits(cond, "warning")) {
[11:00:43.150]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.150]                         if (muffled) 
[11:00:43.150]                           invokeRestart("muffleWarning")
[11:00:43.150]                       }
[11:00:43.150]                       else if (inherits(cond, "condition")) {
[11:00:43.150]                         if (!is.null(pattern)) {
[11:00:43.150]                           computeRestarts <- base::computeRestarts
[11:00:43.150]                           grepl <- base::grepl
[11:00:43.150]                           restarts <- computeRestarts(cond)
[11:00:43.150]                           for (restart in restarts) {
[11:00:43.150]                             name <- restart$name
[11:00:43.150]                             if (is.null(name)) 
[11:00:43.150]                               next
[11:00:43.150]                             if (!grepl(pattern, name)) 
[11:00:43.150]                               next
[11:00:43.150]                             invokeRestart(restart)
[11:00:43.150]                             muffled <- TRUE
[11:00:43.150]                             break
[11:00:43.150]                           }
[11:00:43.150]                         }
[11:00:43.150]                       }
[11:00:43.150]                       invisible(muffled)
[11:00:43.150]                     }
[11:00:43.150]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.150]                   }
[11:00:43.150]                 }
[11:00:43.150]             }
[11:00:43.150]         }))
[11:00:43.150]     }, error = function(ex) {
[11:00:43.150]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.150]                 ...future.rng), started = ...future.startTime, 
[11:00:43.150]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.150]             version = "1.8"), class = "FutureResult")
[11:00:43.150]     }, finally = {
[11:00:43.150]         if (!identical(...future.workdir, getwd())) 
[11:00:43.150]             setwd(...future.workdir)
[11:00:43.150]         {
[11:00:43.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.150]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.150]             }
[11:00:43.150]             base::options(...future.oldOptions)
[11:00:43.150]             if (.Platform$OS.type == "windows") {
[11:00:43.150]                 old_names <- names(...future.oldEnvVars)
[11:00:43.150]                 envs <- base::Sys.getenv()
[11:00:43.150]                 names <- names(envs)
[11:00:43.150]                 common <- intersect(names, old_names)
[11:00:43.150]                 added <- setdiff(names, old_names)
[11:00:43.150]                 removed <- setdiff(old_names, names)
[11:00:43.150]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.150]                   envs[common]]
[11:00:43.150]                 NAMES <- toupper(changed)
[11:00:43.150]                 args <- list()
[11:00:43.150]                 for (kk in seq_along(NAMES)) {
[11:00:43.150]                   name <- changed[[kk]]
[11:00:43.150]                   NAME <- NAMES[[kk]]
[11:00:43.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.150]                     next
[11:00:43.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.150]                 }
[11:00:43.150]                 NAMES <- toupper(added)
[11:00:43.150]                 for (kk in seq_along(NAMES)) {
[11:00:43.150]                   name <- added[[kk]]
[11:00:43.150]                   NAME <- NAMES[[kk]]
[11:00:43.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.150]                     next
[11:00:43.150]                   args[[name]] <- ""
[11:00:43.150]                 }
[11:00:43.150]                 NAMES <- toupper(removed)
[11:00:43.150]                 for (kk in seq_along(NAMES)) {
[11:00:43.150]                   name <- removed[[kk]]
[11:00:43.150]                   NAME <- NAMES[[kk]]
[11:00:43.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.150]                     next
[11:00:43.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.150]                 }
[11:00:43.150]                 if (length(args) > 0) 
[11:00:43.150]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.150]             }
[11:00:43.150]             else {
[11:00:43.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.150]             }
[11:00:43.150]             {
[11:00:43.150]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.150]                   0L) {
[11:00:43.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.150]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.150]                   base::options(opts)
[11:00:43.150]                 }
[11:00:43.150]                 {
[11:00:43.150]                   {
[11:00:43.150]                     NULL
[11:00:43.150]                     RNGkind("Mersenne-Twister")
[11:00:43.150]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.150]                       inherits = FALSE)
[11:00:43.150]                   }
[11:00:43.150]                   options(future.plan = NULL)
[11:00:43.150]                   if (is.na(NA_character_)) 
[11:00:43.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.150]                     .init = FALSE)
[11:00:43.150]                 }
[11:00:43.150]             }
[11:00:43.150]         }
[11:00:43.150]     })
[11:00:43.150]     if (TRUE) {
[11:00:43.150]         base::sink(type = "output", split = FALSE)
[11:00:43.150]         if (TRUE) {
[11:00:43.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.150]         }
[11:00:43.150]         else {
[11:00:43.150]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.150]         }
[11:00:43.150]         base::close(...future.stdout)
[11:00:43.150]         ...future.stdout <- NULL
[11:00:43.150]     }
[11:00:43.150]     ...future.result$conditions <- ...future.conditions
[11:00:43.150]     ...future.result$finished <- base::Sys.time()
[11:00:43.150]     ...future.result
[11:00:43.150] }
[11:00:43.152] plan(): Setting new future strategy stack:
[11:00:43.152] List of future strategies:
[11:00:43.152] 1. sequential:
[11:00:43.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.152]    - tweaked: FALSE
[11:00:43.152]    - call: NULL
[11:00:43.153] plan(): nbrOfWorkers() = 1
[11:00:43.154] plan(): Setting new future strategy stack:
[11:00:43.154] List of future strategies:
[11:00:43.154] 1. sequential:
[11:00:43.154]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.154]    - tweaked: FALSE
[11:00:43.154]    - call: future::plan("sequential")
[11:00:43.154] plan(): nbrOfWorkers() = 1
[11:00:43.154] SequentialFuture started (and completed)
[11:00:43.154] signalConditions() ...
[11:00:43.154]  - include = ‘immediateCondition’
[11:00:43.155]  - exclude = 
[11:00:43.155]  - resignal = FALSE
[11:00:43.155]  - Number of conditions: 1
[11:00:43.155] signalConditions() ... done
[11:00:43.155] - Launch lazy future ... done
[11:00:43.155] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(v)
[11:00:43.155] resolved() for ‘SequentialFuture’ ...
[11:00:43.155] - state: ‘finished’
[11:00:43.155] - run: TRUE
[11:00:43.156] - result: ‘FutureResult’
[11:00:43.156] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
v %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - implicit future ... DONE")
*** backtrace( ) - implicit future ... DONE
> 
> 
> message("*** backtrace( ) - subsetting ...")
*** backtrace( ) - subsetting ...
> 
> env <- new.env()
> env[["a"]] %<-% { 42L; stop("Woops") }
[11:00:43.158] getGlobalsAndPackages() ...
[11:00:43.159] Searching for globals...
[11:00:43.159] - globals found: [2] ‘{’, ‘stop’
[11:00:43.160] Searching for globals ... DONE
[11:00:43.160] Resolving globals: FALSE
[11:00:43.160] 
[11:00:43.160] 
[11:00:43.160] getGlobalsAndPackages() ... DONE
[11:00:43.160] run() for ‘Future’ ...
[11:00:43.160] - state: ‘created’
[11:00:43.161] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.161] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.161]   - Field: ‘label’
[11:00:43.161]   - Field: ‘local’
[11:00:43.161]   - Field: ‘owner’
[11:00:43.161]   - Field: ‘envir’
[11:00:43.161]   - Field: ‘packages’
[11:00:43.161]   - Field: ‘gc’
[11:00:43.161]   - Field: ‘conditions’
[11:00:43.162]   - Field: ‘expr’
[11:00:43.162]   - Field: ‘uuid’
[11:00:43.162]   - Field: ‘seed’
[11:00:43.162]   - Field: ‘version’
[11:00:43.162]   - Field: ‘result’
[11:00:43.162]   - Field: ‘asynchronous’
[11:00:43.162]   - Field: ‘calls’
[11:00:43.162]   - Field: ‘globals’
[11:00:43.162]   - Field: ‘stdout’
[11:00:43.162]   - Field: ‘earlySignal’
[11:00:43.162]   - Field: ‘lazy’
[11:00:43.162]   - Field: ‘state’
[11:00:43.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.163] - Launch lazy future ...
[11:00:43.163] Packages needed by the future expression (n = 0): <none>
[11:00:43.163] Packages needed by future strategies (n = 0): <none>
[11:00:43.163] {
[11:00:43.163]     {
[11:00:43.163]         {
[11:00:43.163]             ...future.startTime <- base::Sys.time()
[11:00:43.163]             {
[11:00:43.163]                 {
[11:00:43.163]                   {
[11:00:43.163]                     base::local({
[11:00:43.163]                       has_future <- base::requireNamespace("future", 
[11:00:43.163]                         quietly = TRUE)
[11:00:43.163]                       if (has_future) {
[11:00:43.163]                         ns <- base::getNamespace("future")
[11:00:43.163]                         version <- ns[[".package"]][["version"]]
[11:00:43.163]                         if (is.null(version)) 
[11:00:43.163]                           version <- utils::packageVersion("future")
[11:00:43.163]                       }
[11:00:43.163]                       else {
[11:00:43.163]                         version <- NULL
[11:00:43.163]                       }
[11:00:43.163]                       if (!has_future || version < "1.8.0") {
[11:00:43.163]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.163]                           "", base::R.version$version.string), 
[11:00:43.163]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.163]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.163]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.163]                             "release", "version")], collapse = " "), 
[11:00:43.163]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.163]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.163]                           info)
[11:00:43.163]                         info <- base::paste(info, collapse = "; ")
[11:00:43.163]                         if (!has_future) {
[11:00:43.163]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.163]                             info)
[11:00:43.163]                         }
[11:00:43.163]                         else {
[11:00:43.163]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.163]                             info, version)
[11:00:43.163]                         }
[11:00:43.163]                         base::stop(msg)
[11:00:43.163]                       }
[11:00:43.163]                     })
[11:00:43.163]                   }
[11:00:43.163]                   ...future.strategy.old <- future::plan("list")
[11:00:43.163]                   options(future.plan = NULL)
[11:00:43.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.163]                 }
[11:00:43.163]                 ...future.workdir <- getwd()
[11:00:43.163]             }
[11:00:43.163]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.163]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.163]         }
[11:00:43.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.163]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.163]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.163]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.163]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.163]             base::names(...future.oldOptions))
[11:00:43.163]     }
[11:00:43.163]     if (FALSE) {
[11:00:43.163]     }
[11:00:43.163]     else {
[11:00:43.163]         if (TRUE) {
[11:00:43.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.163]                 open = "w")
[11:00:43.163]         }
[11:00:43.163]         else {
[11:00:43.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.163]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.163]         }
[11:00:43.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.163]             base::sink(type = "output", split = FALSE)
[11:00:43.163]             base::close(...future.stdout)
[11:00:43.163]         }, add = TRUE)
[11:00:43.163]     }
[11:00:43.163]     ...future.frame <- base::sys.nframe()
[11:00:43.163]     ...future.conditions <- base::list()
[11:00:43.163]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.163]     if (FALSE) {
[11:00:43.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.163]     }
[11:00:43.163]     ...future.result <- base::tryCatch({
[11:00:43.163]         base::withCallingHandlers({
[11:00:43.163]             ...future.value <- base::withVisible(base::local({
[11:00:43.163]                 42L
[11:00:43.163]                 stop("Woops")
[11:00:43.163]             }))
[11:00:43.163]             future::FutureResult(value = ...future.value$value, 
[11:00:43.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.163]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.163]                     ...future.globalenv.names))
[11:00:43.163]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.163]         }, condition = base::local({
[11:00:43.163]             c <- base::c
[11:00:43.163]             inherits <- base::inherits
[11:00:43.163]             invokeRestart <- base::invokeRestart
[11:00:43.163]             length <- base::length
[11:00:43.163]             list <- base::list
[11:00:43.163]             seq.int <- base::seq.int
[11:00:43.163]             signalCondition <- base::signalCondition
[11:00:43.163]             sys.calls <- base::sys.calls
[11:00:43.163]             `[[` <- base::`[[`
[11:00:43.163]             `+` <- base::`+`
[11:00:43.163]             `<<-` <- base::`<<-`
[11:00:43.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.163]                   3L)]
[11:00:43.163]             }
[11:00:43.163]             function(cond) {
[11:00:43.163]                 is_error <- inherits(cond, "error")
[11:00:43.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.163]                   NULL)
[11:00:43.163]                 if (is_error) {
[11:00:43.163]                   sessionInformation <- function() {
[11:00:43.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.163]                       search = base::search(), system = base::Sys.info())
[11:00:43.163]                   }
[11:00:43.163]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.163]                     cond$call), session = sessionInformation(), 
[11:00:43.163]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.163]                   signalCondition(cond)
[11:00:43.163]                 }
[11:00:43.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.163]                 "immediateCondition"))) {
[11:00:43.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.163]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.163]                   if (TRUE && !signal) {
[11:00:43.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.163]                     {
[11:00:43.163]                       inherits <- base::inherits
[11:00:43.163]                       invokeRestart <- base::invokeRestart
[11:00:43.163]                       is.null <- base::is.null
[11:00:43.163]                       muffled <- FALSE
[11:00:43.163]                       if (inherits(cond, "message")) {
[11:00:43.163]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.163]                         if (muffled) 
[11:00:43.163]                           invokeRestart("muffleMessage")
[11:00:43.163]                       }
[11:00:43.163]                       else if (inherits(cond, "warning")) {
[11:00:43.163]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.163]                         if (muffled) 
[11:00:43.163]                           invokeRestart("muffleWarning")
[11:00:43.163]                       }
[11:00:43.163]                       else if (inherits(cond, "condition")) {
[11:00:43.163]                         if (!is.null(pattern)) {
[11:00:43.163]                           computeRestarts <- base::computeRestarts
[11:00:43.163]                           grepl <- base::grepl
[11:00:43.163]                           restarts <- computeRestarts(cond)
[11:00:43.163]                           for (restart in restarts) {
[11:00:43.163]                             name <- restart$name
[11:00:43.163]                             if (is.null(name)) 
[11:00:43.163]                               next
[11:00:43.163]                             if (!grepl(pattern, name)) 
[11:00:43.163]                               next
[11:00:43.163]                             invokeRestart(restart)
[11:00:43.163]                             muffled <- TRUE
[11:00:43.163]                             break
[11:00:43.163]                           }
[11:00:43.163]                         }
[11:00:43.163]                       }
[11:00:43.163]                       invisible(muffled)
[11:00:43.163]                     }
[11:00:43.163]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.163]                   }
[11:00:43.163]                 }
[11:00:43.163]                 else {
[11:00:43.163]                   if (TRUE) {
[11:00:43.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.163]                     {
[11:00:43.163]                       inherits <- base::inherits
[11:00:43.163]                       invokeRestart <- base::invokeRestart
[11:00:43.163]                       is.null <- base::is.null
[11:00:43.163]                       muffled <- FALSE
[11:00:43.163]                       if (inherits(cond, "message")) {
[11:00:43.163]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.163]                         if (muffled) 
[11:00:43.163]                           invokeRestart("muffleMessage")
[11:00:43.163]                       }
[11:00:43.163]                       else if (inherits(cond, "warning")) {
[11:00:43.163]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.163]                         if (muffled) 
[11:00:43.163]                           invokeRestart("muffleWarning")
[11:00:43.163]                       }
[11:00:43.163]                       else if (inherits(cond, "condition")) {
[11:00:43.163]                         if (!is.null(pattern)) {
[11:00:43.163]                           computeRestarts <- base::computeRestarts
[11:00:43.163]                           grepl <- base::grepl
[11:00:43.163]                           restarts <- computeRestarts(cond)
[11:00:43.163]                           for (restart in restarts) {
[11:00:43.163]                             name <- restart$name
[11:00:43.163]                             if (is.null(name)) 
[11:00:43.163]                               next
[11:00:43.163]                             if (!grepl(pattern, name)) 
[11:00:43.163]                               next
[11:00:43.163]                             invokeRestart(restart)
[11:00:43.163]                             muffled <- TRUE
[11:00:43.163]                             break
[11:00:43.163]                           }
[11:00:43.163]                         }
[11:00:43.163]                       }
[11:00:43.163]                       invisible(muffled)
[11:00:43.163]                     }
[11:00:43.163]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.163]                   }
[11:00:43.163]                 }
[11:00:43.163]             }
[11:00:43.163]         }))
[11:00:43.163]     }, error = function(ex) {
[11:00:43.163]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.163]                 ...future.rng), started = ...future.startTime, 
[11:00:43.163]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.163]             version = "1.8"), class = "FutureResult")
[11:00:43.163]     }, finally = {
[11:00:43.163]         if (!identical(...future.workdir, getwd())) 
[11:00:43.163]             setwd(...future.workdir)
[11:00:43.163]         {
[11:00:43.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.163]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.163]             }
[11:00:43.163]             base::options(...future.oldOptions)
[11:00:43.163]             if (.Platform$OS.type == "windows") {
[11:00:43.163]                 old_names <- names(...future.oldEnvVars)
[11:00:43.163]                 envs <- base::Sys.getenv()
[11:00:43.163]                 names <- names(envs)
[11:00:43.163]                 common <- intersect(names, old_names)
[11:00:43.163]                 added <- setdiff(names, old_names)
[11:00:43.163]                 removed <- setdiff(old_names, names)
[11:00:43.163]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.163]                   envs[common]]
[11:00:43.163]                 NAMES <- toupper(changed)
[11:00:43.163]                 args <- list()
[11:00:43.163]                 for (kk in seq_along(NAMES)) {
[11:00:43.163]                   name <- changed[[kk]]
[11:00:43.163]                   NAME <- NAMES[[kk]]
[11:00:43.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.163]                     next
[11:00:43.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.163]                 }
[11:00:43.163]                 NAMES <- toupper(added)
[11:00:43.163]                 for (kk in seq_along(NAMES)) {
[11:00:43.163]                   name <- added[[kk]]
[11:00:43.163]                   NAME <- NAMES[[kk]]
[11:00:43.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.163]                     next
[11:00:43.163]                   args[[name]] <- ""
[11:00:43.163]                 }
[11:00:43.163]                 NAMES <- toupper(removed)
[11:00:43.163]                 for (kk in seq_along(NAMES)) {
[11:00:43.163]                   name <- removed[[kk]]
[11:00:43.163]                   NAME <- NAMES[[kk]]
[11:00:43.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.163]                     next
[11:00:43.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.163]                 }
[11:00:43.163]                 if (length(args) > 0) 
[11:00:43.163]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.163]             }
[11:00:43.163]             else {
[11:00:43.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.163]             }
[11:00:43.163]             {
[11:00:43.163]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.163]                   0L) {
[11:00:43.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.163]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.163]                   base::options(opts)
[11:00:43.163]                 }
[11:00:43.163]                 {
[11:00:43.163]                   {
[11:00:43.163]                     NULL
[11:00:43.163]                     RNGkind("Mersenne-Twister")
[11:00:43.163]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.163]                       inherits = FALSE)
[11:00:43.163]                   }
[11:00:43.163]                   options(future.plan = NULL)
[11:00:43.163]                   if (is.na(NA_character_)) 
[11:00:43.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.163]                     .init = FALSE)
[11:00:43.163]                 }
[11:00:43.163]             }
[11:00:43.163]         }
[11:00:43.163]     })
[11:00:43.163]     if (TRUE) {
[11:00:43.163]         base::sink(type = "output", split = FALSE)
[11:00:43.163]         if (TRUE) {
[11:00:43.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.163]         }
[11:00:43.163]         else {
[11:00:43.163]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.163]         }
[11:00:43.163]         base::close(...future.stdout)
[11:00:43.163]         ...future.stdout <- NULL
[11:00:43.163]     }
[11:00:43.163]     ...future.result$conditions <- ...future.conditions
[11:00:43.163]     ...future.result$finished <- base::Sys.time()
[11:00:43.163]     ...future.result
[11:00:43.163] }
[11:00:43.165] plan(): Setting new future strategy stack:
[11:00:43.165] List of future strategies:
[11:00:43.165] 1. sequential:
[11:00:43.165]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.165]    - tweaked: FALSE
[11:00:43.165]    - call: NULL
[11:00:43.166] plan(): nbrOfWorkers() = 1
[11:00:43.166] plan(): Setting new future strategy stack:
[11:00:43.166] List of future strategies:
[11:00:43.166] 1. sequential:
[11:00:43.166]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.166]    - tweaked: FALSE
[11:00:43.166]    - call: future::plan("sequential")
[11:00:43.167] plan(): nbrOfWorkers() = 1
[11:00:43.167] SequentialFuture started (and completed)
[11:00:43.167] signalConditions() ...
[11:00:43.167]  - include = ‘immediateCondition’
[11:00:43.167]  - exclude = 
[11:00:43.167]  - resignal = FALSE
[11:00:43.167]  - Number of conditions: 1
[11:00:43.168] signalConditions() ... done
[11:00:43.168] - Launch lazy future ... done
[11:00:43.168] run() for ‘SequentialFuture’ ... done
> env[["b"]] %<-% { 42L; stop("Woops") }
[11:00:43.168] getGlobalsAndPackages() ...
[11:00:43.168] Searching for globals...
[11:00:43.169] - globals found: [2] ‘{’, ‘stop’
[11:00:43.169] Searching for globals ... DONE
[11:00:43.169] Resolving globals: FALSE
[11:00:43.169] 
[11:00:43.169] 
[11:00:43.170] getGlobalsAndPackages() ... DONE
[11:00:43.170] run() for ‘Future’ ...
[11:00:43.170] - state: ‘created’
[11:00:43.170] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.170] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.170]   - Field: ‘label’
[11:00:43.170]   - Field: ‘local’
[11:00:43.171]   - Field: ‘owner’
[11:00:43.171]   - Field: ‘envir’
[11:00:43.171]   - Field: ‘packages’
[11:00:43.171]   - Field: ‘gc’
[11:00:43.171]   - Field: ‘conditions’
[11:00:43.171]   - Field: ‘expr’
[11:00:43.171]   - Field: ‘uuid’
[11:00:43.171]   - Field: ‘seed’
[11:00:43.171]   - Field: ‘version’
[11:00:43.171]   - Field: ‘result’
[11:00:43.171]   - Field: ‘asynchronous’
[11:00:43.171]   - Field: ‘calls’
[11:00:43.171]   - Field: ‘globals’
[11:00:43.172]   - Field: ‘stdout’
[11:00:43.172]   - Field: ‘earlySignal’
[11:00:43.172]   - Field: ‘lazy’
[11:00:43.172]   - Field: ‘state’
[11:00:43.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.172] - Launch lazy future ...
[11:00:43.172] Packages needed by the future expression (n = 0): <none>
[11:00:43.172] Packages needed by future strategies (n = 0): <none>
[11:00:43.173] {
[11:00:43.173]     {
[11:00:43.173]         {
[11:00:43.173]             ...future.startTime <- base::Sys.time()
[11:00:43.173]             {
[11:00:43.173]                 {
[11:00:43.173]                   {
[11:00:43.173]                     base::local({
[11:00:43.173]                       has_future <- base::requireNamespace("future", 
[11:00:43.173]                         quietly = TRUE)
[11:00:43.173]                       if (has_future) {
[11:00:43.173]                         ns <- base::getNamespace("future")
[11:00:43.173]                         version <- ns[[".package"]][["version"]]
[11:00:43.173]                         if (is.null(version)) 
[11:00:43.173]                           version <- utils::packageVersion("future")
[11:00:43.173]                       }
[11:00:43.173]                       else {
[11:00:43.173]                         version <- NULL
[11:00:43.173]                       }
[11:00:43.173]                       if (!has_future || version < "1.8.0") {
[11:00:43.173]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.173]                           "", base::R.version$version.string), 
[11:00:43.173]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.173]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.173]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.173]                             "release", "version")], collapse = " "), 
[11:00:43.173]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.173]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.173]                           info)
[11:00:43.173]                         info <- base::paste(info, collapse = "; ")
[11:00:43.173]                         if (!has_future) {
[11:00:43.173]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.173]                             info)
[11:00:43.173]                         }
[11:00:43.173]                         else {
[11:00:43.173]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.173]                             info, version)
[11:00:43.173]                         }
[11:00:43.173]                         base::stop(msg)
[11:00:43.173]                       }
[11:00:43.173]                     })
[11:00:43.173]                   }
[11:00:43.173]                   ...future.strategy.old <- future::plan("list")
[11:00:43.173]                   options(future.plan = NULL)
[11:00:43.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.173]                 }
[11:00:43.173]                 ...future.workdir <- getwd()
[11:00:43.173]             }
[11:00:43.173]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.173]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.173]         }
[11:00:43.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.173]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.173]             base::names(...future.oldOptions))
[11:00:43.173]     }
[11:00:43.173]     if (FALSE) {
[11:00:43.173]     }
[11:00:43.173]     else {
[11:00:43.173]         if (TRUE) {
[11:00:43.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.173]                 open = "w")
[11:00:43.173]         }
[11:00:43.173]         else {
[11:00:43.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.173]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.173]         }
[11:00:43.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.173]             base::sink(type = "output", split = FALSE)
[11:00:43.173]             base::close(...future.stdout)
[11:00:43.173]         }, add = TRUE)
[11:00:43.173]     }
[11:00:43.173]     ...future.frame <- base::sys.nframe()
[11:00:43.173]     ...future.conditions <- base::list()
[11:00:43.173]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.173]     if (FALSE) {
[11:00:43.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.173]     }
[11:00:43.173]     ...future.result <- base::tryCatch({
[11:00:43.173]         base::withCallingHandlers({
[11:00:43.173]             ...future.value <- base::withVisible(base::local({
[11:00:43.173]                 42L
[11:00:43.173]                 stop("Woops")
[11:00:43.173]             }))
[11:00:43.173]             future::FutureResult(value = ...future.value$value, 
[11:00:43.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.173]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.173]                     ...future.globalenv.names))
[11:00:43.173]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.173]         }, condition = base::local({
[11:00:43.173]             c <- base::c
[11:00:43.173]             inherits <- base::inherits
[11:00:43.173]             invokeRestart <- base::invokeRestart
[11:00:43.173]             length <- base::length
[11:00:43.173]             list <- base::list
[11:00:43.173]             seq.int <- base::seq.int
[11:00:43.173]             signalCondition <- base::signalCondition
[11:00:43.173]             sys.calls <- base::sys.calls
[11:00:43.173]             `[[` <- base::`[[`
[11:00:43.173]             `+` <- base::`+`
[11:00:43.173]             `<<-` <- base::`<<-`
[11:00:43.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.173]                   3L)]
[11:00:43.173]             }
[11:00:43.173]             function(cond) {
[11:00:43.173]                 is_error <- inherits(cond, "error")
[11:00:43.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.173]                   NULL)
[11:00:43.173]                 if (is_error) {
[11:00:43.173]                   sessionInformation <- function() {
[11:00:43.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.173]                       search = base::search(), system = base::Sys.info())
[11:00:43.173]                   }
[11:00:43.173]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.173]                     cond$call), session = sessionInformation(), 
[11:00:43.173]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.173]                   signalCondition(cond)
[11:00:43.173]                 }
[11:00:43.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.173]                 "immediateCondition"))) {
[11:00:43.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.173]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.173]                   if (TRUE && !signal) {
[11:00:43.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.173]                     {
[11:00:43.173]                       inherits <- base::inherits
[11:00:43.173]                       invokeRestart <- base::invokeRestart
[11:00:43.173]                       is.null <- base::is.null
[11:00:43.173]                       muffled <- FALSE
[11:00:43.173]                       if (inherits(cond, "message")) {
[11:00:43.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.173]                         if (muffled) 
[11:00:43.173]                           invokeRestart("muffleMessage")
[11:00:43.173]                       }
[11:00:43.173]                       else if (inherits(cond, "warning")) {
[11:00:43.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.173]                         if (muffled) 
[11:00:43.173]                           invokeRestart("muffleWarning")
[11:00:43.173]                       }
[11:00:43.173]                       else if (inherits(cond, "condition")) {
[11:00:43.173]                         if (!is.null(pattern)) {
[11:00:43.173]                           computeRestarts <- base::computeRestarts
[11:00:43.173]                           grepl <- base::grepl
[11:00:43.173]                           restarts <- computeRestarts(cond)
[11:00:43.173]                           for (restart in restarts) {
[11:00:43.173]                             name <- restart$name
[11:00:43.173]                             if (is.null(name)) 
[11:00:43.173]                               next
[11:00:43.173]                             if (!grepl(pattern, name)) 
[11:00:43.173]                               next
[11:00:43.173]                             invokeRestart(restart)
[11:00:43.173]                             muffled <- TRUE
[11:00:43.173]                             break
[11:00:43.173]                           }
[11:00:43.173]                         }
[11:00:43.173]                       }
[11:00:43.173]                       invisible(muffled)
[11:00:43.173]                     }
[11:00:43.173]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.173]                   }
[11:00:43.173]                 }
[11:00:43.173]                 else {
[11:00:43.173]                   if (TRUE) {
[11:00:43.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.173]                     {
[11:00:43.173]                       inherits <- base::inherits
[11:00:43.173]                       invokeRestart <- base::invokeRestart
[11:00:43.173]                       is.null <- base::is.null
[11:00:43.173]                       muffled <- FALSE
[11:00:43.173]                       if (inherits(cond, "message")) {
[11:00:43.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.173]                         if (muffled) 
[11:00:43.173]                           invokeRestart("muffleMessage")
[11:00:43.173]                       }
[11:00:43.173]                       else if (inherits(cond, "warning")) {
[11:00:43.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.173]                         if (muffled) 
[11:00:43.173]                           invokeRestart("muffleWarning")
[11:00:43.173]                       }
[11:00:43.173]                       else if (inherits(cond, "condition")) {
[11:00:43.173]                         if (!is.null(pattern)) {
[11:00:43.173]                           computeRestarts <- base::computeRestarts
[11:00:43.173]                           grepl <- base::grepl
[11:00:43.173]                           restarts <- computeRestarts(cond)
[11:00:43.173]                           for (restart in restarts) {
[11:00:43.173]                             name <- restart$name
[11:00:43.173]                             if (is.null(name)) 
[11:00:43.173]                               next
[11:00:43.173]                             if (!grepl(pattern, name)) 
[11:00:43.173]                               next
[11:00:43.173]                             invokeRestart(restart)
[11:00:43.173]                             muffled <- TRUE
[11:00:43.173]                             break
[11:00:43.173]                           }
[11:00:43.173]                         }
[11:00:43.173]                       }
[11:00:43.173]                       invisible(muffled)
[11:00:43.173]                     }
[11:00:43.173]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.173]                   }
[11:00:43.173]                 }
[11:00:43.173]             }
[11:00:43.173]         }))
[11:00:43.173]     }, error = function(ex) {
[11:00:43.173]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.173]                 ...future.rng), started = ...future.startTime, 
[11:00:43.173]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.173]             version = "1.8"), class = "FutureResult")
[11:00:43.173]     }, finally = {
[11:00:43.173]         if (!identical(...future.workdir, getwd())) 
[11:00:43.173]             setwd(...future.workdir)
[11:00:43.173]         {
[11:00:43.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.173]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.173]             }
[11:00:43.173]             base::options(...future.oldOptions)
[11:00:43.173]             if (.Platform$OS.type == "windows") {
[11:00:43.173]                 old_names <- names(...future.oldEnvVars)
[11:00:43.173]                 envs <- base::Sys.getenv()
[11:00:43.173]                 names <- names(envs)
[11:00:43.173]                 common <- intersect(names, old_names)
[11:00:43.173]                 added <- setdiff(names, old_names)
[11:00:43.173]                 removed <- setdiff(old_names, names)
[11:00:43.173]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.173]                   envs[common]]
[11:00:43.173]                 NAMES <- toupper(changed)
[11:00:43.173]                 args <- list()
[11:00:43.173]                 for (kk in seq_along(NAMES)) {
[11:00:43.173]                   name <- changed[[kk]]
[11:00:43.173]                   NAME <- NAMES[[kk]]
[11:00:43.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.173]                     next
[11:00:43.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.173]                 }
[11:00:43.173]                 NAMES <- toupper(added)
[11:00:43.173]                 for (kk in seq_along(NAMES)) {
[11:00:43.173]                   name <- added[[kk]]
[11:00:43.173]                   NAME <- NAMES[[kk]]
[11:00:43.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.173]                     next
[11:00:43.173]                   args[[name]] <- ""
[11:00:43.173]                 }
[11:00:43.173]                 NAMES <- toupper(removed)
[11:00:43.173]                 for (kk in seq_along(NAMES)) {
[11:00:43.173]                   name <- removed[[kk]]
[11:00:43.173]                   NAME <- NAMES[[kk]]
[11:00:43.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.173]                     next
[11:00:43.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.173]                 }
[11:00:43.173]                 if (length(args) > 0) 
[11:00:43.173]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.173]             }
[11:00:43.173]             else {
[11:00:43.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.173]             }
[11:00:43.173]             {
[11:00:43.173]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.173]                   0L) {
[11:00:43.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.173]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.173]                   base::options(opts)
[11:00:43.173]                 }
[11:00:43.173]                 {
[11:00:43.173]                   {
[11:00:43.173]                     NULL
[11:00:43.173]                     RNGkind("Mersenne-Twister")
[11:00:43.173]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.173]                       inherits = FALSE)
[11:00:43.173]                   }
[11:00:43.173]                   options(future.plan = NULL)
[11:00:43.173]                   if (is.na(NA_character_)) 
[11:00:43.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.173]                     .init = FALSE)
[11:00:43.173]                 }
[11:00:43.173]             }
[11:00:43.173]         }
[11:00:43.173]     })
[11:00:43.173]     if (TRUE) {
[11:00:43.173]         base::sink(type = "output", split = FALSE)
[11:00:43.173]         if (TRUE) {
[11:00:43.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.173]         }
[11:00:43.173]         else {
[11:00:43.173]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.173]         }
[11:00:43.173]         base::close(...future.stdout)
[11:00:43.173]         ...future.stdout <- NULL
[11:00:43.173]     }
[11:00:43.173]     ...future.result$conditions <- ...future.conditions
[11:00:43.173]     ...future.result$finished <- base::Sys.time()
[11:00:43.173]     ...future.result
[11:00:43.173] }
[11:00:43.174] plan(): Setting new future strategy stack:
[11:00:43.174] List of future strategies:
[11:00:43.174] 1. sequential:
[11:00:43.174]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.174]    - tweaked: FALSE
[11:00:43.174]    - call: NULL
[11:00:43.175] plan(): nbrOfWorkers() = 1
[11:00:43.176] plan(): Setting new future strategy stack:
[11:00:43.176] List of future strategies:
[11:00:43.176] 1. sequential:
[11:00:43.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.176]    - tweaked: FALSE
[11:00:43.176]    - call: future::plan("sequential")
[11:00:43.176] plan(): nbrOfWorkers() = 1
[11:00:43.176] SequentialFuture started (and completed)
[11:00:43.176] signalConditions() ...
[11:00:43.176]  - include = ‘immediateCondition’
[11:00:43.176]  - exclude = 
[11:00:43.177]  - resignal = FALSE
[11:00:43.177]  - Number of conditions: 1
[11:00:43.177] signalConditions() ... done
[11:00:43.177] - Launch lazy future ... done
[11:00:43.177] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(env[["b"]])
[11:00:43.177] resolved() for ‘SequentialFuture’ ...
[11:00:43.177] - state: ‘finished’
[11:00:43.177] - run: TRUE
[11:00:43.177] - result: ‘FutureResult’
[11:00:43.177] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
env[["b"]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> lenv <- listenv::listenv()
> lenv[[1]] %<-% { 42L; stop("Woops") }
[11:00:43.178] getGlobalsAndPackages() ...
[11:00:43.178] Searching for globals...
[11:00:43.179] - globals found: [2] ‘{’, ‘stop’
[11:00:43.179] Searching for globals ... DONE
[11:00:43.179] Resolving globals: FALSE
[11:00:43.180] 
[11:00:43.180] 
[11:00:43.180] getGlobalsAndPackages() ... DONE
[11:00:43.180] run() for ‘Future’ ...
[11:00:43.180] - state: ‘created’
[11:00:43.180] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.181] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.181]   - Field: ‘label’
[11:00:43.181]   - Field: ‘local’
[11:00:43.181]   - Field: ‘owner’
[11:00:43.181]   - Field: ‘envir’
[11:00:43.181]   - Field: ‘packages’
[11:00:43.181]   - Field: ‘gc’
[11:00:43.181]   - Field: ‘conditions’
[11:00:43.181]   - Field: ‘expr’
[11:00:43.181]   - Field: ‘uuid’
[11:00:43.181]   - Field: ‘seed’
[11:00:43.182]   - Field: ‘version’
[11:00:43.182]   - Field: ‘result’
[11:00:43.182]   - Field: ‘asynchronous’
[11:00:43.182]   - Field: ‘calls’
[11:00:43.182]   - Field: ‘globals’
[11:00:43.182]   - Field: ‘stdout’
[11:00:43.182]   - Field: ‘earlySignal’
[11:00:43.182]   - Field: ‘lazy’
[11:00:43.182]   - Field: ‘state’
[11:00:43.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.182] - Launch lazy future ...
[11:00:43.183] Packages needed by the future expression (n = 0): <none>
[11:00:43.183] Packages needed by future strategies (n = 0): <none>
[11:00:43.183] {
[11:00:43.183]     {
[11:00:43.183]         {
[11:00:43.183]             ...future.startTime <- base::Sys.time()
[11:00:43.183]             {
[11:00:43.183]                 {
[11:00:43.183]                   {
[11:00:43.183]                     base::local({
[11:00:43.183]                       has_future <- base::requireNamespace("future", 
[11:00:43.183]                         quietly = TRUE)
[11:00:43.183]                       if (has_future) {
[11:00:43.183]                         ns <- base::getNamespace("future")
[11:00:43.183]                         version <- ns[[".package"]][["version"]]
[11:00:43.183]                         if (is.null(version)) 
[11:00:43.183]                           version <- utils::packageVersion("future")
[11:00:43.183]                       }
[11:00:43.183]                       else {
[11:00:43.183]                         version <- NULL
[11:00:43.183]                       }
[11:00:43.183]                       if (!has_future || version < "1.8.0") {
[11:00:43.183]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.183]                           "", base::R.version$version.string), 
[11:00:43.183]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.183]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.183]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.183]                             "release", "version")], collapse = " "), 
[11:00:43.183]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.183]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.183]                           info)
[11:00:43.183]                         info <- base::paste(info, collapse = "; ")
[11:00:43.183]                         if (!has_future) {
[11:00:43.183]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.183]                             info)
[11:00:43.183]                         }
[11:00:43.183]                         else {
[11:00:43.183]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.183]                             info, version)
[11:00:43.183]                         }
[11:00:43.183]                         base::stop(msg)
[11:00:43.183]                       }
[11:00:43.183]                     })
[11:00:43.183]                   }
[11:00:43.183]                   ...future.strategy.old <- future::plan("list")
[11:00:43.183]                   options(future.plan = NULL)
[11:00:43.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.183]                 }
[11:00:43.183]                 ...future.workdir <- getwd()
[11:00:43.183]             }
[11:00:43.183]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.183]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.183]         }
[11:00:43.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.183]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.183]             base::names(...future.oldOptions))
[11:00:43.183]     }
[11:00:43.183]     if (FALSE) {
[11:00:43.183]     }
[11:00:43.183]     else {
[11:00:43.183]         if (TRUE) {
[11:00:43.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.183]                 open = "w")
[11:00:43.183]         }
[11:00:43.183]         else {
[11:00:43.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.183]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.183]         }
[11:00:43.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.183]             base::sink(type = "output", split = FALSE)
[11:00:43.183]             base::close(...future.stdout)
[11:00:43.183]         }, add = TRUE)
[11:00:43.183]     }
[11:00:43.183]     ...future.frame <- base::sys.nframe()
[11:00:43.183]     ...future.conditions <- base::list()
[11:00:43.183]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.183]     if (FALSE) {
[11:00:43.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.183]     }
[11:00:43.183]     ...future.result <- base::tryCatch({
[11:00:43.183]         base::withCallingHandlers({
[11:00:43.183]             ...future.value <- base::withVisible(base::local({
[11:00:43.183]                 42L
[11:00:43.183]                 stop("Woops")
[11:00:43.183]             }))
[11:00:43.183]             future::FutureResult(value = ...future.value$value, 
[11:00:43.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.183]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.183]                     ...future.globalenv.names))
[11:00:43.183]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.183]         }, condition = base::local({
[11:00:43.183]             c <- base::c
[11:00:43.183]             inherits <- base::inherits
[11:00:43.183]             invokeRestart <- base::invokeRestart
[11:00:43.183]             length <- base::length
[11:00:43.183]             list <- base::list
[11:00:43.183]             seq.int <- base::seq.int
[11:00:43.183]             signalCondition <- base::signalCondition
[11:00:43.183]             sys.calls <- base::sys.calls
[11:00:43.183]             `[[` <- base::`[[`
[11:00:43.183]             `+` <- base::`+`
[11:00:43.183]             `<<-` <- base::`<<-`
[11:00:43.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.183]                   3L)]
[11:00:43.183]             }
[11:00:43.183]             function(cond) {
[11:00:43.183]                 is_error <- inherits(cond, "error")
[11:00:43.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.183]                   NULL)
[11:00:43.183]                 if (is_error) {
[11:00:43.183]                   sessionInformation <- function() {
[11:00:43.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.183]                       search = base::search(), system = base::Sys.info())
[11:00:43.183]                   }
[11:00:43.183]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.183]                     cond$call), session = sessionInformation(), 
[11:00:43.183]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.183]                   signalCondition(cond)
[11:00:43.183]                 }
[11:00:43.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.183]                 "immediateCondition"))) {
[11:00:43.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.183]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.183]                   if (TRUE && !signal) {
[11:00:43.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.183]                     {
[11:00:43.183]                       inherits <- base::inherits
[11:00:43.183]                       invokeRestart <- base::invokeRestart
[11:00:43.183]                       is.null <- base::is.null
[11:00:43.183]                       muffled <- FALSE
[11:00:43.183]                       if (inherits(cond, "message")) {
[11:00:43.183]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.183]                         if (muffled) 
[11:00:43.183]                           invokeRestart("muffleMessage")
[11:00:43.183]                       }
[11:00:43.183]                       else if (inherits(cond, "warning")) {
[11:00:43.183]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.183]                         if (muffled) 
[11:00:43.183]                           invokeRestart("muffleWarning")
[11:00:43.183]                       }
[11:00:43.183]                       else if (inherits(cond, "condition")) {
[11:00:43.183]                         if (!is.null(pattern)) {
[11:00:43.183]                           computeRestarts <- base::computeRestarts
[11:00:43.183]                           grepl <- base::grepl
[11:00:43.183]                           restarts <- computeRestarts(cond)
[11:00:43.183]                           for (restart in restarts) {
[11:00:43.183]                             name <- restart$name
[11:00:43.183]                             if (is.null(name)) 
[11:00:43.183]                               next
[11:00:43.183]                             if (!grepl(pattern, name)) 
[11:00:43.183]                               next
[11:00:43.183]                             invokeRestart(restart)
[11:00:43.183]                             muffled <- TRUE
[11:00:43.183]                             break
[11:00:43.183]                           }
[11:00:43.183]                         }
[11:00:43.183]                       }
[11:00:43.183]                       invisible(muffled)
[11:00:43.183]                     }
[11:00:43.183]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.183]                   }
[11:00:43.183]                 }
[11:00:43.183]                 else {
[11:00:43.183]                   if (TRUE) {
[11:00:43.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.183]                     {
[11:00:43.183]                       inherits <- base::inherits
[11:00:43.183]                       invokeRestart <- base::invokeRestart
[11:00:43.183]                       is.null <- base::is.null
[11:00:43.183]                       muffled <- FALSE
[11:00:43.183]                       if (inherits(cond, "message")) {
[11:00:43.183]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.183]                         if (muffled) 
[11:00:43.183]                           invokeRestart("muffleMessage")
[11:00:43.183]                       }
[11:00:43.183]                       else if (inherits(cond, "warning")) {
[11:00:43.183]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.183]                         if (muffled) 
[11:00:43.183]                           invokeRestart("muffleWarning")
[11:00:43.183]                       }
[11:00:43.183]                       else if (inherits(cond, "condition")) {
[11:00:43.183]                         if (!is.null(pattern)) {
[11:00:43.183]                           computeRestarts <- base::computeRestarts
[11:00:43.183]                           grepl <- base::grepl
[11:00:43.183]                           restarts <- computeRestarts(cond)
[11:00:43.183]                           for (restart in restarts) {
[11:00:43.183]                             name <- restart$name
[11:00:43.183]                             if (is.null(name)) 
[11:00:43.183]                               next
[11:00:43.183]                             if (!grepl(pattern, name)) 
[11:00:43.183]                               next
[11:00:43.183]                             invokeRestart(restart)
[11:00:43.183]                             muffled <- TRUE
[11:00:43.183]                             break
[11:00:43.183]                           }
[11:00:43.183]                         }
[11:00:43.183]                       }
[11:00:43.183]                       invisible(muffled)
[11:00:43.183]                     }
[11:00:43.183]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.183]                   }
[11:00:43.183]                 }
[11:00:43.183]             }
[11:00:43.183]         }))
[11:00:43.183]     }, error = function(ex) {
[11:00:43.183]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.183]                 ...future.rng), started = ...future.startTime, 
[11:00:43.183]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.183]             version = "1.8"), class = "FutureResult")
[11:00:43.183]     }, finally = {
[11:00:43.183]         if (!identical(...future.workdir, getwd())) 
[11:00:43.183]             setwd(...future.workdir)
[11:00:43.183]         {
[11:00:43.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.183]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.183]             }
[11:00:43.183]             base::options(...future.oldOptions)
[11:00:43.183]             if (.Platform$OS.type == "windows") {
[11:00:43.183]                 old_names <- names(...future.oldEnvVars)
[11:00:43.183]                 envs <- base::Sys.getenv()
[11:00:43.183]                 names <- names(envs)
[11:00:43.183]                 common <- intersect(names, old_names)
[11:00:43.183]                 added <- setdiff(names, old_names)
[11:00:43.183]                 removed <- setdiff(old_names, names)
[11:00:43.183]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.183]                   envs[common]]
[11:00:43.183]                 NAMES <- toupper(changed)
[11:00:43.183]                 args <- list()
[11:00:43.183]                 for (kk in seq_along(NAMES)) {
[11:00:43.183]                   name <- changed[[kk]]
[11:00:43.183]                   NAME <- NAMES[[kk]]
[11:00:43.183]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.183]                     next
[11:00:43.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.183]                 }
[11:00:43.183]                 NAMES <- toupper(added)
[11:00:43.183]                 for (kk in seq_along(NAMES)) {
[11:00:43.183]                   name <- added[[kk]]
[11:00:43.183]                   NAME <- NAMES[[kk]]
[11:00:43.183]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.183]                     next
[11:00:43.183]                   args[[name]] <- ""
[11:00:43.183]                 }
[11:00:43.183]                 NAMES <- toupper(removed)
[11:00:43.183]                 for (kk in seq_along(NAMES)) {
[11:00:43.183]                   name <- removed[[kk]]
[11:00:43.183]                   NAME <- NAMES[[kk]]
[11:00:43.183]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.183]                     next
[11:00:43.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.183]                 }
[11:00:43.183]                 if (length(args) > 0) 
[11:00:43.183]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.183]             }
[11:00:43.183]             else {
[11:00:43.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.183]             }
[11:00:43.183]             {
[11:00:43.183]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.183]                   0L) {
[11:00:43.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.183]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.183]                   base::options(opts)
[11:00:43.183]                 }
[11:00:43.183]                 {
[11:00:43.183]                   {
[11:00:43.183]                     NULL
[11:00:43.183]                     RNGkind("Mersenne-Twister")
[11:00:43.183]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.183]                       inherits = FALSE)
[11:00:43.183]                   }
[11:00:43.183]                   options(future.plan = NULL)
[11:00:43.183]                   if (is.na(NA_character_)) 
[11:00:43.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.183]                     .init = FALSE)
[11:00:43.183]                 }
[11:00:43.183]             }
[11:00:43.183]         }
[11:00:43.183]     })
[11:00:43.183]     if (TRUE) {
[11:00:43.183]         base::sink(type = "output", split = FALSE)
[11:00:43.183]         if (TRUE) {
[11:00:43.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.183]         }
[11:00:43.183]         else {
[11:00:43.183]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.183]         }
[11:00:43.183]         base::close(...future.stdout)
[11:00:43.183]         ...future.stdout <- NULL
[11:00:43.183]     }
[11:00:43.183]     ...future.result$conditions <- ...future.conditions
[11:00:43.183]     ...future.result$finished <- base::Sys.time()
[11:00:43.183]     ...future.result
[11:00:43.183] }
[11:00:43.185] plan(): Setting new future strategy stack:
[11:00:43.185] List of future strategies:
[11:00:43.185] 1. sequential:
[11:00:43.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.185]    - tweaked: FALSE
[11:00:43.185]    - call: NULL
[11:00:43.185] plan(): nbrOfWorkers() = 1
[11:00:43.186] plan(): Setting new future strategy stack:
[11:00:43.186] List of future strategies:
[11:00:43.186] 1. sequential:
[11:00:43.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.186]    - tweaked: FALSE
[11:00:43.186]    - call: future::plan("sequential")
[11:00:43.187] plan(): nbrOfWorkers() = 1
[11:00:43.187] SequentialFuture started (and completed)
[11:00:43.187] signalConditions() ...
[11:00:43.187]  - include = ‘immediateCondition’
[11:00:43.187]  - exclude = 
[11:00:43.187]  - resignal = FALSE
[11:00:43.187]  - Number of conditions: 1
[11:00:43.187] signalConditions() ... done
[11:00:43.187] - Launch lazy future ... done
[11:00:43.187] run() for ‘SequentialFuture’ ... done
> lenv[[2]] %<-% { 42L; stop("Woops") }
[11:00:43.188] getGlobalsAndPackages() ...
[11:00:43.188] Searching for globals...
[11:00:43.190] - globals found: [2] ‘{’, ‘stop’
[11:00:43.190] Searching for globals ... DONE
[11:00:43.190] Resolving globals: FALSE
[11:00:43.190] 
[11:00:43.190] 
[11:00:43.190] getGlobalsAndPackages() ... DONE
[11:00:43.191] run() for ‘Future’ ...
[11:00:43.191] - state: ‘created’
[11:00:43.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.191] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.191]   - Field: ‘label’
[11:00:43.191]   - Field: ‘local’
[11:00:43.191]   - Field: ‘owner’
[11:00:43.191]   - Field: ‘envir’
[11:00:43.192]   - Field: ‘packages’
[11:00:43.192]   - Field: ‘gc’
[11:00:43.192]   - Field: ‘conditions’
[11:00:43.192]   - Field: ‘expr’
[11:00:43.192]   - Field: ‘uuid’
[11:00:43.192]   - Field: ‘seed’
[11:00:43.192]   - Field: ‘version’
[11:00:43.192]   - Field: ‘result’
[11:00:43.192]   - Field: ‘asynchronous’
[11:00:43.192]   - Field: ‘calls’
[11:00:43.192]   - Field: ‘globals’
[11:00:43.192]   - Field: ‘stdout’
[11:00:43.192]   - Field: ‘earlySignal’
[11:00:43.193]   - Field: ‘lazy’
[11:00:43.193]   - Field: ‘state’
[11:00:43.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.193] - Launch lazy future ...
[11:00:43.193] Packages needed by the future expression (n = 0): <none>
[11:00:43.193] Packages needed by future strategies (n = 0): <none>
[11:00:43.193] {
[11:00:43.193]     {
[11:00:43.193]         {
[11:00:43.193]             ...future.startTime <- base::Sys.time()
[11:00:43.193]             {
[11:00:43.193]                 {
[11:00:43.193]                   {
[11:00:43.193]                     base::local({
[11:00:43.193]                       has_future <- base::requireNamespace("future", 
[11:00:43.193]                         quietly = TRUE)
[11:00:43.193]                       if (has_future) {
[11:00:43.193]                         ns <- base::getNamespace("future")
[11:00:43.193]                         version <- ns[[".package"]][["version"]]
[11:00:43.193]                         if (is.null(version)) 
[11:00:43.193]                           version <- utils::packageVersion("future")
[11:00:43.193]                       }
[11:00:43.193]                       else {
[11:00:43.193]                         version <- NULL
[11:00:43.193]                       }
[11:00:43.193]                       if (!has_future || version < "1.8.0") {
[11:00:43.193]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.193]                           "", base::R.version$version.string), 
[11:00:43.193]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.193]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.193]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.193]                             "release", "version")], collapse = " "), 
[11:00:43.193]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.193]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.193]                           info)
[11:00:43.193]                         info <- base::paste(info, collapse = "; ")
[11:00:43.193]                         if (!has_future) {
[11:00:43.193]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.193]                             info)
[11:00:43.193]                         }
[11:00:43.193]                         else {
[11:00:43.193]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.193]                             info, version)
[11:00:43.193]                         }
[11:00:43.193]                         base::stop(msg)
[11:00:43.193]                       }
[11:00:43.193]                     })
[11:00:43.193]                   }
[11:00:43.193]                   ...future.strategy.old <- future::plan("list")
[11:00:43.193]                   options(future.plan = NULL)
[11:00:43.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.193]                 }
[11:00:43.193]                 ...future.workdir <- getwd()
[11:00:43.193]             }
[11:00:43.193]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.193]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.193]         }
[11:00:43.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.193]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.193]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.193]             base::names(...future.oldOptions))
[11:00:43.193]     }
[11:00:43.193]     if (FALSE) {
[11:00:43.193]     }
[11:00:43.193]     else {
[11:00:43.193]         if (TRUE) {
[11:00:43.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.193]                 open = "w")
[11:00:43.193]         }
[11:00:43.193]         else {
[11:00:43.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.193]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.193]         }
[11:00:43.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.193]             base::sink(type = "output", split = FALSE)
[11:00:43.193]             base::close(...future.stdout)
[11:00:43.193]         }, add = TRUE)
[11:00:43.193]     }
[11:00:43.193]     ...future.frame <- base::sys.nframe()
[11:00:43.193]     ...future.conditions <- base::list()
[11:00:43.193]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.193]     if (FALSE) {
[11:00:43.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.193]     }
[11:00:43.193]     ...future.result <- base::tryCatch({
[11:00:43.193]         base::withCallingHandlers({
[11:00:43.193]             ...future.value <- base::withVisible(base::local({
[11:00:43.193]                 42L
[11:00:43.193]                 stop("Woops")
[11:00:43.193]             }))
[11:00:43.193]             future::FutureResult(value = ...future.value$value, 
[11:00:43.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.193]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.193]                     ...future.globalenv.names))
[11:00:43.193]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.193]         }, condition = base::local({
[11:00:43.193]             c <- base::c
[11:00:43.193]             inherits <- base::inherits
[11:00:43.193]             invokeRestart <- base::invokeRestart
[11:00:43.193]             length <- base::length
[11:00:43.193]             list <- base::list
[11:00:43.193]             seq.int <- base::seq.int
[11:00:43.193]             signalCondition <- base::signalCondition
[11:00:43.193]             sys.calls <- base::sys.calls
[11:00:43.193]             `[[` <- base::`[[`
[11:00:43.193]             `+` <- base::`+`
[11:00:43.193]             `<<-` <- base::`<<-`
[11:00:43.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.193]                   3L)]
[11:00:43.193]             }
[11:00:43.193]             function(cond) {
[11:00:43.193]                 is_error <- inherits(cond, "error")
[11:00:43.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.193]                   NULL)
[11:00:43.193]                 if (is_error) {
[11:00:43.193]                   sessionInformation <- function() {
[11:00:43.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.193]                       search = base::search(), system = base::Sys.info())
[11:00:43.193]                   }
[11:00:43.193]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.193]                     cond$call), session = sessionInformation(), 
[11:00:43.193]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.193]                   signalCondition(cond)
[11:00:43.193]                 }
[11:00:43.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.193]                 "immediateCondition"))) {
[11:00:43.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.193]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.193]                   if (TRUE && !signal) {
[11:00:43.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.193]                     {
[11:00:43.193]                       inherits <- base::inherits
[11:00:43.193]                       invokeRestart <- base::invokeRestart
[11:00:43.193]                       is.null <- base::is.null
[11:00:43.193]                       muffled <- FALSE
[11:00:43.193]                       if (inherits(cond, "message")) {
[11:00:43.193]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.193]                         if (muffled) 
[11:00:43.193]                           invokeRestart("muffleMessage")
[11:00:43.193]                       }
[11:00:43.193]                       else if (inherits(cond, "warning")) {
[11:00:43.193]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.193]                         if (muffled) 
[11:00:43.193]                           invokeRestart("muffleWarning")
[11:00:43.193]                       }
[11:00:43.193]                       else if (inherits(cond, "condition")) {
[11:00:43.193]                         if (!is.null(pattern)) {
[11:00:43.193]                           computeRestarts <- base::computeRestarts
[11:00:43.193]                           grepl <- base::grepl
[11:00:43.193]                           restarts <- computeRestarts(cond)
[11:00:43.193]                           for (restart in restarts) {
[11:00:43.193]                             name <- restart$name
[11:00:43.193]                             if (is.null(name)) 
[11:00:43.193]                               next
[11:00:43.193]                             if (!grepl(pattern, name)) 
[11:00:43.193]                               next
[11:00:43.193]                             invokeRestart(restart)
[11:00:43.193]                             muffled <- TRUE
[11:00:43.193]                             break
[11:00:43.193]                           }
[11:00:43.193]                         }
[11:00:43.193]                       }
[11:00:43.193]                       invisible(muffled)
[11:00:43.193]                     }
[11:00:43.193]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.193]                   }
[11:00:43.193]                 }
[11:00:43.193]                 else {
[11:00:43.193]                   if (TRUE) {
[11:00:43.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.193]                     {
[11:00:43.193]                       inherits <- base::inherits
[11:00:43.193]                       invokeRestart <- base::invokeRestart
[11:00:43.193]                       is.null <- base::is.null
[11:00:43.193]                       muffled <- FALSE
[11:00:43.193]                       if (inherits(cond, "message")) {
[11:00:43.193]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.193]                         if (muffled) 
[11:00:43.193]                           invokeRestart("muffleMessage")
[11:00:43.193]                       }
[11:00:43.193]                       else if (inherits(cond, "warning")) {
[11:00:43.193]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.193]                         if (muffled) 
[11:00:43.193]                           invokeRestart("muffleWarning")
[11:00:43.193]                       }
[11:00:43.193]                       else if (inherits(cond, "condition")) {
[11:00:43.193]                         if (!is.null(pattern)) {
[11:00:43.193]                           computeRestarts <- base::computeRestarts
[11:00:43.193]                           grepl <- base::grepl
[11:00:43.193]                           restarts <- computeRestarts(cond)
[11:00:43.193]                           for (restart in restarts) {
[11:00:43.193]                             name <- restart$name
[11:00:43.193]                             if (is.null(name)) 
[11:00:43.193]                               next
[11:00:43.193]                             if (!grepl(pattern, name)) 
[11:00:43.193]                               next
[11:00:43.193]                             invokeRestart(restart)
[11:00:43.193]                             muffled <- TRUE
[11:00:43.193]                             break
[11:00:43.193]                           }
[11:00:43.193]                         }
[11:00:43.193]                       }
[11:00:43.193]                       invisible(muffled)
[11:00:43.193]                     }
[11:00:43.193]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.193]                   }
[11:00:43.193]                 }
[11:00:43.193]             }
[11:00:43.193]         }))
[11:00:43.193]     }, error = function(ex) {
[11:00:43.193]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.193]                 ...future.rng), started = ...future.startTime, 
[11:00:43.193]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.193]             version = "1.8"), class = "FutureResult")
[11:00:43.193]     }, finally = {
[11:00:43.193]         if (!identical(...future.workdir, getwd())) 
[11:00:43.193]             setwd(...future.workdir)
[11:00:43.193]         {
[11:00:43.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.193]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.193]             }
[11:00:43.193]             base::options(...future.oldOptions)
[11:00:43.193]             if (.Platform$OS.type == "windows") {
[11:00:43.193]                 old_names <- names(...future.oldEnvVars)
[11:00:43.193]                 envs <- base::Sys.getenv()
[11:00:43.193]                 names <- names(envs)
[11:00:43.193]                 common <- intersect(names, old_names)
[11:00:43.193]                 added <- setdiff(names, old_names)
[11:00:43.193]                 removed <- setdiff(old_names, names)
[11:00:43.193]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.193]                   envs[common]]
[11:00:43.193]                 NAMES <- toupper(changed)
[11:00:43.193]                 args <- list()
[11:00:43.193]                 for (kk in seq_along(NAMES)) {
[11:00:43.193]                   name <- changed[[kk]]
[11:00:43.193]                   NAME <- NAMES[[kk]]
[11:00:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.193]                     next
[11:00:43.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.193]                 }
[11:00:43.193]                 NAMES <- toupper(added)
[11:00:43.193]                 for (kk in seq_along(NAMES)) {
[11:00:43.193]                   name <- added[[kk]]
[11:00:43.193]                   NAME <- NAMES[[kk]]
[11:00:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.193]                     next
[11:00:43.193]                   args[[name]] <- ""
[11:00:43.193]                 }
[11:00:43.193]                 NAMES <- toupper(removed)
[11:00:43.193]                 for (kk in seq_along(NAMES)) {
[11:00:43.193]                   name <- removed[[kk]]
[11:00:43.193]                   NAME <- NAMES[[kk]]
[11:00:43.193]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.193]                     next
[11:00:43.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.193]                 }
[11:00:43.193]                 if (length(args) > 0) 
[11:00:43.193]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.193]             }
[11:00:43.193]             else {
[11:00:43.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.193]             }
[11:00:43.193]             {
[11:00:43.193]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.193]                   0L) {
[11:00:43.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.193]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.193]                   base::options(opts)
[11:00:43.193]                 }
[11:00:43.193]                 {
[11:00:43.193]                   {
[11:00:43.193]                     NULL
[11:00:43.193]                     RNGkind("Mersenne-Twister")
[11:00:43.193]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.193]                       inherits = FALSE)
[11:00:43.193]                   }
[11:00:43.193]                   options(future.plan = NULL)
[11:00:43.193]                   if (is.na(NA_character_)) 
[11:00:43.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.193]                     .init = FALSE)
[11:00:43.193]                 }
[11:00:43.193]             }
[11:00:43.193]         }
[11:00:43.193]     })
[11:00:43.193]     if (TRUE) {
[11:00:43.193]         base::sink(type = "output", split = FALSE)
[11:00:43.193]         if (TRUE) {
[11:00:43.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.193]         }
[11:00:43.193]         else {
[11:00:43.193]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.193]         }
[11:00:43.193]         base::close(...future.stdout)
[11:00:43.193]         ...future.stdout <- NULL
[11:00:43.193]     }
[11:00:43.193]     ...future.result$conditions <- ...future.conditions
[11:00:43.193]     ...future.result$finished <- base::Sys.time()
[11:00:43.193]     ...future.result
[11:00:43.193] }
[11:00:43.195] plan(): Setting new future strategy stack:
[11:00:43.195] List of future strategies:
[11:00:43.195] 1. sequential:
[11:00:43.195]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.195]    - tweaked: FALSE
[11:00:43.195]    - call: NULL
[11:00:43.196] plan(): nbrOfWorkers() = 1
[11:00:43.196] plan(): Setting new future strategy stack:
[11:00:43.197] List of future strategies:
[11:00:43.197] 1. sequential:
[11:00:43.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.197]    - tweaked: FALSE
[11:00:43.197]    - call: future::plan("sequential")
[11:00:43.197] plan(): nbrOfWorkers() = 1
[11:00:43.197] SequentialFuture started (and completed)
[11:00:43.197] signalConditions() ...
[11:00:43.197]  - include = ‘immediateCondition’
[11:00:43.197]  - exclude = 
[11:00:43.197]  - resignal = FALSE
[11:00:43.198]  - Number of conditions: 1
[11:00:43.198] signalConditions() ... done
[11:00:43.198] - Launch lazy future ... done
[11:00:43.198] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(lenv[[2]])
[11:00:43.198] resolved() for ‘SequentialFuture’ ...
[11:00:43.198] - state: ‘finished’
[11:00:43.198] - run: TRUE
[11:00:43.198] - result: ‘FutureResult’
[11:00:43.198] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
lenv[[2]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> ll <- list()
> ll[[1]] <- future({ 42L; stop("Woops") })
[11:00:43.199] getGlobalsAndPackages() ...
[11:00:43.199] Searching for globals...
[11:00:43.200] - globals found: [2] ‘{’, ‘stop’
[11:00:43.200] Searching for globals ... DONE
[11:00:43.200] Resolving globals: FALSE
[11:00:43.200] 
[11:00:43.200] 
[11:00:43.200] getGlobalsAndPackages() ... DONE
[11:00:43.201] run() for ‘Future’ ...
[11:00:43.201] - state: ‘created’
[11:00:43.201] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.201]   - Field: ‘label’
[11:00:43.201]   - Field: ‘local’
[11:00:43.201]   - Field: ‘owner’
[11:00:43.201]   - Field: ‘envir’
[11:00:43.201]   - Field: ‘packages’
[11:00:43.202]   - Field: ‘gc’
[11:00:43.202]   - Field: ‘conditions’
[11:00:43.202]   - Field: ‘expr’
[11:00:43.202]   - Field: ‘uuid’
[11:00:43.202]   - Field: ‘seed’
[11:00:43.202]   - Field: ‘version’
[11:00:43.202]   - Field: ‘result’
[11:00:43.202]   - Field: ‘asynchronous’
[11:00:43.202]   - Field: ‘calls’
[11:00:43.202]   - Field: ‘globals’
[11:00:43.202]   - Field: ‘stdout’
[11:00:43.202]   - Field: ‘earlySignal’
[11:00:43.202]   - Field: ‘lazy’
[11:00:43.203]   - Field: ‘state’
[11:00:43.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.203] - Launch lazy future ...
[11:00:43.203] Packages needed by the future expression (n = 0): <none>
[11:00:43.203] Packages needed by future strategies (n = 0): <none>
[11:00:43.203] {
[11:00:43.203]     {
[11:00:43.203]         {
[11:00:43.203]             ...future.startTime <- base::Sys.time()
[11:00:43.203]             {
[11:00:43.203]                 {
[11:00:43.203]                   {
[11:00:43.203]                     base::local({
[11:00:43.203]                       has_future <- base::requireNamespace("future", 
[11:00:43.203]                         quietly = TRUE)
[11:00:43.203]                       if (has_future) {
[11:00:43.203]                         ns <- base::getNamespace("future")
[11:00:43.203]                         version <- ns[[".package"]][["version"]]
[11:00:43.203]                         if (is.null(version)) 
[11:00:43.203]                           version <- utils::packageVersion("future")
[11:00:43.203]                       }
[11:00:43.203]                       else {
[11:00:43.203]                         version <- NULL
[11:00:43.203]                       }
[11:00:43.203]                       if (!has_future || version < "1.8.0") {
[11:00:43.203]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.203]                           "", base::R.version$version.string), 
[11:00:43.203]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.203]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.203]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.203]                             "release", "version")], collapse = " "), 
[11:00:43.203]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.203]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.203]                           info)
[11:00:43.203]                         info <- base::paste(info, collapse = "; ")
[11:00:43.203]                         if (!has_future) {
[11:00:43.203]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.203]                             info)
[11:00:43.203]                         }
[11:00:43.203]                         else {
[11:00:43.203]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.203]                             info, version)
[11:00:43.203]                         }
[11:00:43.203]                         base::stop(msg)
[11:00:43.203]                       }
[11:00:43.203]                     })
[11:00:43.203]                   }
[11:00:43.203]                   ...future.strategy.old <- future::plan("list")
[11:00:43.203]                   options(future.plan = NULL)
[11:00:43.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.203]                 }
[11:00:43.203]                 ...future.workdir <- getwd()
[11:00:43.203]             }
[11:00:43.203]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.203]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.203]         }
[11:00:43.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.203]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.203]             base::names(...future.oldOptions))
[11:00:43.203]     }
[11:00:43.203]     if (FALSE) {
[11:00:43.203]     }
[11:00:43.203]     else {
[11:00:43.203]         if (TRUE) {
[11:00:43.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.203]                 open = "w")
[11:00:43.203]         }
[11:00:43.203]         else {
[11:00:43.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.203]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.203]         }
[11:00:43.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.203]             base::sink(type = "output", split = FALSE)
[11:00:43.203]             base::close(...future.stdout)
[11:00:43.203]         }, add = TRUE)
[11:00:43.203]     }
[11:00:43.203]     ...future.frame <- base::sys.nframe()
[11:00:43.203]     ...future.conditions <- base::list()
[11:00:43.203]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.203]     if (FALSE) {
[11:00:43.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.203]     }
[11:00:43.203]     ...future.result <- base::tryCatch({
[11:00:43.203]         base::withCallingHandlers({
[11:00:43.203]             ...future.value <- base::withVisible(base::local({
[11:00:43.203]                 42L
[11:00:43.203]                 stop("Woops")
[11:00:43.203]             }))
[11:00:43.203]             future::FutureResult(value = ...future.value$value, 
[11:00:43.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.203]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.203]                     ...future.globalenv.names))
[11:00:43.203]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.203]         }, condition = base::local({
[11:00:43.203]             c <- base::c
[11:00:43.203]             inherits <- base::inherits
[11:00:43.203]             invokeRestart <- base::invokeRestart
[11:00:43.203]             length <- base::length
[11:00:43.203]             list <- base::list
[11:00:43.203]             seq.int <- base::seq.int
[11:00:43.203]             signalCondition <- base::signalCondition
[11:00:43.203]             sys.calls <- base::sys.calls
[11:00:43.203]             `[[` <- base::`[[`
[11:00:43.203]             `+` <- base::`+`
[11:00:43.203]             `<<-` <- base::`<<-`
[11:00:43.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.203]                   3L)]
[11:00:43.203]             }
[11:00:43.203]             function(cond) {
[11:00:43.203]                 is_error <- inherits(cond, "error")
[11:00:43.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.203]                   NULL)
[11:00:43.203]                 if (is_error) {
[11:00:43.203]                   sessionInformation <- function() {
[11:00:43.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.203]                       search = base::search(), system = base::Sys.info())
[11:00:43.203]                   }
[11:00:43.203]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.203]                     cond$call), session = sessionInformation(), 
[11:00:43.203]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.203]                   signalCondition(cond)
[11:00:43.203]                 }
[11:00:43.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.203]                 "immediateCondition"))) {
[11:00:43.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.203]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.203]                   if (TRUE && !signal) {
[11:00:43.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.203]                     {
[11:00:43.203]                       inherits <- base::inherits
[11:00:43.203]                       invokeRestart <- base::invokeRestart
[11:00:43.203]                       is.null <- base::is.null
[11:00:43.203]                       muffled <- FALSE
[11:00:43.203]                       if (inherits(cond, "message")) {
[11:00:43.203]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.203]                         if (muffled) 
[11:00:43.203]                           invokeRestart("muffleMessage")
[11:00:43.203]                       }
[11:00:43.203]                       else if (inherits(cond, "warning")) {
[11:00:43.203]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.203]                         if (muffled) 
[11:00:43.203]                           invokeRestart("muffleWarning")
[11:00:43.203]                       }
[11:00:43.203]                       else if (inherits(cond, "condition")) {
[11:00:43.203]                         if (!is.null(pattern)) {
[11:00:43.203]                           computeRestarts <- base::computeRestarts
[11:00:43.203]                           grepl <- base::grepl
[11:00:43.203]                           restarts <- computeRestarts(cond)
[11:00:43.203]                           for (restart in restarts) {
[11:00:43.203]                             name <- restart$name
[11:00:43.203]                             if (is.null(name)) 
[11:00:43.203]                               next
[11:00:43.203]                             if (!grepl(pattern, name)) 
[11:00:43.203]                               next
[11:00:43.203]                             invokeRestart(restart)
[11:00:43.203]                             muffled <- TRUE
[11:00:43.203]                             break
[11:00:43.203]                           }
[11:00:43.203]                         }
[11:00:43.203]                       }
[11:00:43.203]                       invisible(muffled)
[11:00:43.203]                     }
[11:00:43.203]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.203]                   }
[11:00:43.203]                 }
[11:00:43.203]                 else {
[11:00:43.203]                   if (TRUE) {
[11:00:43.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.203]                     {
[11:00:43.203]                       inherits <- base::inherits
[11:00:43.203]                       invokeRestart <- base::invokeRestart
[11:00:43.203]                       is.null <- base::is.null
[11:00:43.203]                       muffled <- FALSE
[11:00:43.203]                       if (inherits(cond, "message")) {
[11:00:43.203]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.203]                         if (muffled) 
[11:00:43.203]                           invokeRestart("muffleMessage")
[11:00:43.203]                       }
[11:00:43.203]                       else if (inherits(cond, "warning")) {
[11:00:43.203]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.203]                         if (muffled) 
[11:00:43.203]                           invokeRestart("muffleWarning")
[11:00:43.203]                       }
[11:00:43.203]                       else if (inherits(cond, "condition")) {
[11:00:43.203]                         if (!is.null(pattern)) {
[11:00:43.203]                           computeRestarts <- base::computeRestarts
[11:00:43.203]                           grepl <- base::grepl
[11:00:43.203]                           restarts <- computeRestarts(cond)
[11:00:43.203]                           for (restart in restarts) {
[11:00:43.203]                             name <- restart$name
[11:00:43.203]                             if (is.null(name)) 
[11:00:43.203]                               next
[11:00:43.203]                             if (!grepl(pattern, name)) 
[11:00:43.203]                               next
[11:00:43.203]                             invokeRestart(restart)
[11:00:43.203]                             muffled <- TRUE
[11:00:43.203]                             break
[11:00:43.203]                           }
[11:00:43.203]                         }
[11:00:43.203]                       }
[11:00:43.203]                       invisible(muffled)
[11:00:43.203]                     }
[11:00:43.203]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.203]                   }
[11:00:43.203]                 }
[11:00:43.203]             }
[11:00:43.203]         }))
[11:00:43.203]     }, error = function(ex) {
[11:00:43.203]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.203]                 ...future.rng), started = ...future.startTime, 
[11:00:43.203]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.203]             version = "1.8"), class = "FutureResult")
[11:00:43.203]     }, finally = {
[11:00:43.203]         if (!identical(...future.workdir, getwd())) 
[11:00:43.203]             setwd(...future.workdir)
[11:00:43.203]         {
[11:00:43.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.203]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.203]             }
[11:00:43.203]             base::options(...future.oldOptions)
[11:00:43.203]             if (.Platform$OS.type == "windows") {
[11:00:43.203]                 old_names <- names(...future.oldEnvVars)
[11:00:43.203]                 envs <- base::Sys.getenv()
[11:00:43.203]                 names <- names(envs)
[11:00:43.203]                 common <- intersect(names, old_names)
[11:00:43.203]                 added <- setdiff(names, old_names)
[11:00:43.203]                 removed <- setdiff(old_names, names)
[11:00:43.203]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.203]                   envs[common]]
[11:00:43.203]                 NAMES <- toupper(changed)
[11:00:43.203]                 args <- list()
[11:00:43.203]                 for (kk in seq_along(NAMES)) {
[11:00:43.203]                   name <- changed[[kk]]
[11:00:43.203]                   NAME <- NAMES[[kk]]
[11:00:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.203]                     next
[11:00:43.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.203]                 }
[11:00:43.203]                 NAMES <- toupper(added)
[11:00:43.203]                 for (kk in seq_along(NAMES)) {
[11:00:43.203]                   name <- added[[kk]]
[11:00:43.203]                   NAME <- NAMES[[kk]]
[11:00:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.203]                     next
[11:00:43.203]                   args[[name]] <- ""
[11:00:43.203]                 }
[11:00:43.203]                 NAMES <- toupper(removed)
[11:00:43.203]                 for (kk in seq_along(NAMES)) {
[11:00:43.203]                   name <- removed[[kk]]
[11:00:43.203]                   NAME <- NAMES[[kk]]
[11:00:43.203]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.203]                     next
[11:00:43.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.203]                 }
[11:00:43.203]                 if (length(args) > 0) 
[11:00:43.203]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.203]             }
[11:00:43.203]             else {
[11:00:43.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.203]             }
[11:00:43.203]             {
[11:00:43.203]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.203]                   0L) {
[11:00:43.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.203]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.203]                   base::options(opts)
[11:00:43.203]                 }
[11:00:43.203]                 {
[11:00:43.203]                   {
[11:00:43.203]                     NULL
[11:00:43.203]                     RNGkind("Mersenne-Twister")
[11:00:43.203]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.203]                       inherits = FALSE)
[11:00:43.203]                   }
[11:00:43.203]                   options(future.plan = NULL)
[11:00:43.203]                   if (is.na(NA_character_)) 
[11:00:43.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.203]                     .init = FALSE)
[11:00:43.203]                 }
[11:00:43.203]             }
[11:00:43.203]         }
[11:00:43.203]     })
[11:00:43.203]     if (TRUE) {
[11:00:43.203]         base::sink(type = "output", split = FALSE)
[11:00:43.203]         if (TRUE) {
[11:00:43.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.203]         }
[11:00:43.203]         else {
[11:00:43.203]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.203]         }
[11:00:43.203]         base::close(...future.stdout)
[11:00:43.203]         ...future.stdout <- NULL
[11:00:43.203]     }
[11:00:43.203]     ...future.result$conditions <- ...future.conditions
[11:00:43.203]     ...future.result$finished <- base::Sys.time()
[11:00:43.203]     ...future.result
[11:00:43.203] }
[11:00:43.205] plan(): Setting new future strategy stack:
[11:00:43.205] List of future strategies:
[11:00:43.205] 1. sequential:
[11:00:43.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.205]    - tweaked: FALSE
[11:00:43.205]    - call: NULL
[11:00:43.206] plan(): nbrOfWorkers() = 1
[11:00:43.206] plan(): Setting new future strategy stack:
[11:00:43.206] List of future strategies:
[11:00:43.206] 1. sequential:
[11:00:43.206]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.206]    - tweaked: FALSE
[11:00:43.206]    - call: future::plan("sequential")
[11:00:43.207] plan(): nbrOfWorkers() = 1
[11:00:43.207] SequentialFuture started (and completed)
[11:00:43.207] signalConditions() ...
[11:00:43.207]  - include = ‘immediateCondition’
[11:00:43.207]  - exclude = 
[11:00:43.207]  - resignal = FALSE
[11:00:43.207]  - Number of conditions: 1
[11:00:43.207] signalConditions() ... done
[11:00:43.208] - Launch lazy future ... done
[11:00:43.208] run() for ‘SequentialFuture’ ... done
> ll[[2]] <- future({ 42L; stop("Woops") })
[11:00:43.208] getGlobalsAndPackages() ...
[11:00:43.208] Searching for globals...
[11:00:43.209] - globals found: [2] ‘{’, ‘stop’
[11:00:43.209] Searching for globals ... DONE
[11:00:43.209] Resolving globals: FALSE
[11:00:43.209] 
[11:00:43.209] 
[11:00:43.209] getGlobalsAndPackages() ... DONE
[11:00:43.209] run() for ‘Future’ ...
[11:00:43.210] - state: ‘created’
[11:00:43.210] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.210] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.210] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.210]   - Field: ‘label’
[11:00:43.210]   - Field: ‘local’
[11:00:43.210]   - Field: ‘owner’
[11:00:43.210]   - Field: ‘envir’
[11:00:43.210]   - Field: ‘packages’
[11:00:43.210]   - Field: ‘gc’
[11:00:43.211]   - Field: ‘conditions’
[11:00:43.211]   - Field: ‘expr’
[11:00:43.211]   - Field: ‘uuid’
[11:00:43.211]   - Field: ‘seed’
[11:00:43.211]   - Field: ‘version’
[11:00:43.211]   - Field: ‘result’
[11:00:43.211]   - Field: ‘asynchronous’
[11:00:43.211]   - Field: ‘calls’
[11:00:43.211]   - Field: ‘globals’
[11:00:43.211]   - Field: ‘stdout’
[11:00:43.211]   - Field: ‘earlySignal’
[11:00:43.211]   - Field: ‘lazy’
[11:00:43.212]   - Field: ‘state’
[11:00:43.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.212] - Launch lazy future ...
[11:00:43.212] Packages needed by the future expression (n = 0): <none>
[11:00:43.212] Packages needed by future strategies (n = 0): <none>
[11:00:43.212] {
[11:00:43.212]     {
[11:00:43.212]         {
[11:00:43.212]             ...future.startTime <- base::Sys.time()
[11:00:43.212]             {
[11:00:43.212]                 {
[11:00:43.212]                   {
[11:00:43.212]                     base::local({
[11:00:43.212]                       has_future <- base::requireNamespace("future", 
[11:00:43.212]                         quietly = TRUE)
[11:00:43.212]                       if (has_future) {
[11:00:43.212]                         ns <- base::getNamespace("future")
[11:00:43.212]                         version <- ns[[".package"]][["version"]]
[11:00:43.212]                         if (is.null(version)) 
[11:00:43.212]                           version <- utils::packageVersion("future")
[11:00:43.212]                       }
[11:00:43.212]                       else {
[11:00:43.212]                         version <- NULL
[11:00:43.212]                       }
[11:00:43.212]                       if (!has_future || version < "1.8.0") {
[11:00:43.212]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.212]                           "", base::R.version$version.string), 
[11:00:43.212]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.212]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.212]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.212]                             "release", "version")], collapse = " "), 
[11:00:43.212]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.212]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.212]                           info)
[11:00:43.212]                         info <- base::paste(info, collapse = "; ")
[11:00:43.212]                         if (!has_future) {
[11:00:43.212]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.212]                             info)
[11:00:43.212]                         }
[11:00:43.212]                         else {
[11:00:43.212]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.212]                             info, version)
[11:00:43.212]                         }
[11:00:43.212]                         base::stop(msg)
[11:00:43.212]                       }
[11:00:43.212]                     })
[11:00:43.212]                   }
[11:00:43.212]                   ...future.strategy.old <- future::plan("list")
[11:00:43.212]                   options(future.plan = NULL)
[11:00:43.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.212]                 }
[11:00:43.212]                 ...future.workdir <- getwd()
[11:00:43.212]             }
[11:00:43.212]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.212]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.212]         }
[11:00:43.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.212]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.212]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.212]             base::names(...future.oldOptions))
[11:00:43.212]     }
[11:00:43.212]     if (FALSE) {
[11:00:43.212]     }
[11:00:43.212]     else {
[11:00:43.212]         if (TRUE) {
[11:00:43.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.212]                 open = "w")
[11:00:43.212]         }
[11:00:43.212]         else {
[11:00:43.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.212]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.212]         }
[11:00:43.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.212]             base::sink(type = "output", split = FALSE)
[11:00:43.212]             base::close(...future.stdout)
[11:00:43.212]         }, add = TRUE)
[11:00:43.212]     }
[11:00:43.212]     ...future.frame <- base::sys.nframe()
[11:00:43.212]     ...future.conditions <- base::list()
[11:00:43.212]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.212]     if (FALSE) {
[11:00:43.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.212]     }
[11:00:43.212]     ...future.result <- base::tryCatch({
[11:00:43.212]         base::withCallingHandlers({
[11:00:43.212]             ...future.value <- base::withVisible(base::local({
[11:00:43.212]                 42L
[11:00:43.212]                 stop("Woops")
[11:00:43.212]             }))
[11:00:43.212]             future::FutureResult(value = ...future.value$value, 
[11:00:43.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.212]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.212]                     ...future.globalenv.names))
[11:00:43.212]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.212]         }, condition = base::local({
[11:00:43.212]             c <- base::c
[11:00:43.212]             inherits <- base::inherits
[11:00:43.212]             invokeRestart <- base::invokeRestart
[11:00:43.212]             length <- base::length
[11:00:43.212]             list <- base::list
[11:00:43.212]             seq.int <- base::seq.int
[11:00:43.212]             signalCondition <- base::signalCondition
[11:00:43.212]             sys.calls <- base::sys.calls
[11:00:43.212]             `[[` <- base::`[[`
[11:00:43.212]             `+` <- base::`+`
[11:00:43.212]             `<<-` <- base::`<<-`
[11:00:43.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.212]                   3L)]
[11:00:43.212]             }
[11:00:43.212]             function(cond) {
[11:00:43.212]                 is_error <- inherits(cond, "error")
[11:00:43.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.212]                   NULL)
[11:00:43.212]                 if (is_error) {
[11:00:43.212]                   sessionInformation <- function() {
[11:00:43.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.212]                       search = base::search(), system = base::Sys.info())
[11:00:43.212]                   }
[11:00:43.212]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.212]                     cond$call), session = sessionInformation(), 
[11:00:43.212]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.212]                   signalCondition(cond)
[11:00:43.212]                 }
[11:00:43.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.212]                 "immediateCondition"))) {
[11:00:43.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.212]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.212]                   if (TRUE && !signal) {
[11:00:43.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.212]                     {
[11:00:43.212]                       inherits <- base::inherits
[11:00:43.212]                       invokeRestart <- base::invokeRestart
[11:00:43.212]                       is.null <- base::is.null
[11:00:43.212]                       muffled <- FALSE
[11:00:43.212]                       if (inherits(cond, "message")) {
[11:00:43.212]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.212]                         if (muffled) 
[11:00:43.212]                           invokeRestart("muffleMessage")
[11:00:43.212]                       }
[11:00:43.212]                       else if (inherits(cond, "warning")) {
[11:00:43.212]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.212]                         if (muffled) 
[11:00:43.212]                           invokeRestart("muffleWarning")
[11:00:43.212]                       }
[11:00:43.212]                       else if (inherits(cond, "condition")) {
[11:00:43.212]                         if (!is.null(pattern)) {
[11:00:43.212]                           computeRestarts <- base::computeRestarts
[11:00:43.212]                           grepl <- base::grepl
[11:00:43.212]                           restarts <- computeRestarts(cond)
[11:00:43.212]                           for (restart in restarts) {
[11:00:43.212]                             name <- restart$name
[11:00:43.212]                             if (is.null(name)) 
[11:00:43.212]                               next
[11:00:43.212]                             if (!grepl(pattern, name)) 
[11:00:43.212]                               next
[11:00:43.212]                             invokeRestart(restart)
[11:00:43.212]                             muffled <- TRUE
[11:00:43.212]                             break
[11:00:43.212]                           }
[11:00:43.212]                         }
[11:00:43.212]                       }
[11:00:43.212]                       invisible(muffled)
[11:00:43.212]                     }
[11:00:43.212]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.212]                   }
[11:00:43.212]                 }
[11:00:43.212]                 else {
[11:00:43.212]                   if (TRUE) {
[11:00:43.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.212]                     {
[11:00:43.212]                       inherits <- base::inherits
[11:00:43.212]                       invokeRestart <- base::invokeRestart
[11:00:43.212]                       is.null <- base::is.null
[11:00:43.212]                       muffled <- FALSE
[11:00:43.212]                       if (inherits(cond, "message")) {
[11:00:43.212]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.212]                         if (muffled) 
[11:00:43.212]                           invokeRestart("muffleMessage")
[11:00:43.212]                       }
[11:00:43.212]                       else if (inherits(cond, "warning")) {
[11:00:43.212]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.212]                         if (muffled) 
[11:00:43.212]                           invokeRestart("muffleWarning")
[11:00:43.212]                       }
[11:00:43.212]                       else if (inherits(cond, "condition")) {
[11:00:43.212]                         if (!is.null(pattern)) {
[11:00:43.212]                           computeRestarts <- base::computeRestarts
[11:00:43.212]                           grepl <- base::grepl
[11:00:43.212]                           restarts <- computeRestarts(cond)
[11:00:43.212]                           for (restart in restarts) {
[11:00:43.212]                             name <- restart$name
[11:00:43.212]                             if (is.null(name)) 
[11:00:43.212]                               next
[11:00:43.212]                             if (!grepl(pattern, name)) 
[11:00:43.212]                               next
[11:00:43.212]                             invokeRestart(restart)
[11:00:43.212]                             muffled <- TRUE
[11:00:43.212]                             break
[11:00:43.212]                           }
[11:00:43.212]                         }
[11:00:43.212]                       }
[11:00:43.212]                       invisible(muffled)
[11:00:43.212]                     }
[11:00:43.212]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.212]                   }
[11:00:43.212]                 }
[11:00:43.212]             }
[11:00:43.212]         }))
[11:00:43.212]     }, error = function(ex) {
[11:00:43.212]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.212]                 ...future.rng), started = ...future.startTime, 
[11:00:43.212]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.212]             version = "1.8"), class = "FutureResult")
[11:00:43.212]     }, finally = {
[11:00:43.212]         if (!identical(...future.workdir, getwd())) 
[11:00:43.212]             setwd(...future.workdir)
[11:00:43.212]         {
[11:00:43.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.212]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.212]             }
[11:00:43.212]             base::options(...future.oldOptions)
[11:00:43.212]             if (.Platform$OS.type == "windows") {
[11:00:43.212]                 old_names <- names(...future.oldEnvVars)
[11:00:43.212]                 envs <- base::Sys.getenv()
[11:00:43.212]                 names <- names(envs)
[11:00:43.212]                 common <- intersect(names, old_names)
[11:00:43.212]                 added <- setdiff(names, old_names)
[11:00:43.212]                 removed <- setdiff(old_names, names)
[11:00:43.212]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.212]                   envs[common]]
[11:00:43.212]                 NAMES <- toupper(changed)
[11:00:43.212]                 args <- list()
[11:00:43.212]                 for (kk in seq_along(NAMES)) {
[11:00:43.212]                   name <- changed[[kk]]
[11:00:43.212]                   NAME <- NAMES[[kk]]
[11:00:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.212]                     next
[11:00:43.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.212]                 }
[11:00:43.212]                 NAMES <- toupper(added)
[11:00:43.212]                 for (kk in seq_along(NAMES)) {
[11:00:43.212]                   name <- added[[kk]]
[11:00:43.212]                   NAME <- NAMES[[kk]]
[11:00:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.212]                     next
[11:00:43.212]                   args[[name]] <- ""
[11:00:43.212]                 }
[11:00:43.212]                 NAMES <- toupper(removed)
[11:00:43.212]                 for (kk in seq_along(NAMES)) {
[11:00:43.212]                   name <- removed[[kk]]
[11:00:43.212]                   NAME <- NAMES[[kk]]
[11:00:43.212]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.212]                     next
[11:00:43.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.212]                 }
[11:00:43.212]                 if (length(args) > 0) 
[11:00:43.212]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.212]             }
[11:00:43.212]             else {
[11:00:43.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.212]             }
[11:00:43.212]             {
[11:00:43.212]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.212]                   0L) {
[11:00:43.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.212]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.212]                   base::options(opts)
[11:00:43.212]                 }
[11:00:43.212]                 {
[11:00:43.212]                   {
[11:00:43.212]                     NULL
[11:00:43.212]                     RNGkind("Mersenne-Twister")
[11:00:43.212]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.212]                       inherits = FALSE)
[11:00:43.212]                   }
[11:00:43.212]                   options(future.plan = NULL)
[11:00:43.212]                   if (is.na(NA_character_)) 
[11:00:43.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.212]                     .init = FALSE)
[11:00:43.212]                 }
[11:00:43.212]             }
[11:00:43.212]         }
[11:00:43.212]     })
[11:00:43.212]     if (TRUE) {
[11:00:43.212]         base::sink(type = "output", split = FALSE)
[11:00:43.212]         if (TRUE) {
[11:00:43.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.212]         }
[11:00:43.212]         else {
[11:00:43.212]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.212]         }
[11:00:43.212]         base::close(...future.stdout)
[11:00:43.212]         ...future.stdout <- NULL
[11:00:43.212]     }
[11:00:43.212]     ...future.result$conditions <- ...future.conditions
[11:00:43.212]     ...future.result$finished <- base::Sys.time()
[11:00:43.212]     ...future.result
[11:00:43.212] }
[11:00:43.214] plan(): Setting new future strategy stack:
[11:00:43.214] List of future strategies:
[11:00:43.214] 1. sequential:
[11:00:43.214]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.214]    - tweaked: FALSE
[11:00:43.214]    - call: NULL
[11:00:43.215] plan(): nbrOfWorkers() = 1
[11:00:43.215] plan(): Setting new future strategy stack:
[11:00:43.215] List of future strategies:
[11:00:43.215] 1. sequential:
[11:00:43.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.215]    - tweaked: FALSE
[11:00:43.215]    - call: future::plan("sequential")
[11:00:43.216] plan(): nbrOfWorkers() = 1
[11:00:43.216] SequentialFuture started (and completed)
[11:00:43.216] signalConditions() ...
[11:00:43.216]  - include = ‘immediateCondition’
[11:00:43.216]  - exclude = 
[11:00:43.216]  - resignal = FALSE
[11:00:43.216]  - Number of conditions: 1
[11:00:43.216] signalConditions() ... done
[11:00:43.217] - Launch lazy future ... done
[11:00:43.217] run() for ‘SequentialFuture’ ... done
> vs <- value(ll, signal = FALSE)
[11:00:43.217] resolve() on list ...
[11:00:43.217]  recursive: 0
[11:00:43.217]  length: 2
[11:00:43.217] 
[11:00:43.217] resolved() for ‘SequentialFuture’ ...
[11:00:43.218] - state: ‘finished’
[11:00:43.218] - run: TRUE
[11:00:43.218] - result: ‘FutureResult’
[11:00:43.218] resolved() for ‘SequentialFuture’ ... done
[11:00:43.218] Future #1
[11:00:43.218] signalConditions() ...
[11:00:43.218]  - include = ‘immediateCondition’
[11:00:43.219]  - exclude = 
[11:00:43.219]  - resignal = FALSE
[11:00:43.219]  - Number of conditions: 1
[11:00:43.220] signalConditions() ... done
[11:00:43.220] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:43.220] - nx: 2
[11:00:43.220] - relay: TRUE
[11:00:43.220] - stdout: TRUE
[11:00:43.220] - signal: FALSE
[11:00:43.220] - resignal: FALSE
[11:00:43.220] - force: TRUE
[11:00:43.220] - relayed: [n=2] FALSE, FALSE
[11:00:43.220] - queued futures: [n=2] FALSE, FALSE
[11:00:43.220]  - until=1
[11:00:43.220]  - relaying element #1
[11:00:43.221] signalConditions() ...
[11:00:43.221]  - include = ‘immediateCondition’
[11:00:43.221]  - exclude = 
[11:00:43.221]  - resignal = FALSE
[11:00:43.221]  - Number of conditions: 1
[11:00:43.221] signalConditions() ... done
[11:00:43.221] - relayed: [n=2] TRUE, FALSE
[11:00:43.221] - queued futures: [n=2] TRUE, FALSE
[11:00:43.221] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:43.221]  length: 1 (resolved future 1)
[11:00:43.222] resolved() for ‘SequentialFuture’ ...
[11:00:43.222] - state: ‘finished’
[11:00:43.222] - run: TRUE
[11:00:43.222] - result: ‘FutureResult’
[11:00:43.222] resolved() for ‘SequentialFuture’ ... done
[11:00:43.222] Future #2
[11:00:43.222] signalConditions() ...
[11:00:43.222]  - include = ‘immediateCondition’
[11:00:43.222]  - exclude = 
[11:00:43.222]  - resignal = FALSE
[11:00:43.222]  - Number of conditions: 1
[11:00:43.222] signalConditions() ... done
[11:00:43.223] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:00:43.223] - nx: 2
[11:00:43.223] - relay: TRUE
[11:00:43.223] - stdout: TRUE
[11:00:43.223] - signal: FALSE
[11:00:43.223] - resignal: FALSE
[11:00:43.223] - force: TRUE
[11:00:43.223] - relayed: [n=2] TRUE, FALSE
[11:00:43.223] - queued futures: [n=2] TRUE, FALSE
[11:00:43.223]  - until=2
[11:00:43.223]  - relaying element #2
[11:00:43.223] signalConditions() ...
[11:00:43.223]  - include = ‘immediateCondition’
[11:00:43.224]  - exclude = 
[11:00:43.224]  - resignal = FALSE
[11:00:43.224]  - Number of conditions: 1
[11:00:43.224] signalConditions() ... done
[11:00:43.224] - relayed: [n=2] TRUE, TRUE
[11:00:43.224] - queued futures: [n=2] TRUE, TRUE
[11:00:43.224] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:00:43.224]  length: 0 (resolved future 2)
[11:00:43.224] Relaying remaining futures
[11:00:43.224] signalConditionsASAP(NULL, pos=0) ...
[11:00:43.224] - nx: 2
[11:00:43.224] - relay: TRUE
[11:00:43.224] - stdout: TRUE
[11:00:43.225] - signal: FALSE
[11:00:43.225] - resignal: FALSE
[11:00:43.225] - force: TRUE
[11:00:43.225] - relayed: [n=2] TRUE, TRUE
[11:00:43.225] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:43.225] - relayed: [n=2] TRUE, TRUE
[11:00:43.225] - queued futures: [n=2] TRUE, TRUE
[11:00:43.225] signalConditionsASAP(NULL, pos=0) ... done
[11:00:43.225] resolve() on list ... DONE
[11:00:43.225] signalConditions() ...
[11:00:43.225]  - include = ‘immediateCondition’
[11:00:43.225]  - exclude = 
[11:00:43.225]  - resignal = FALSE
[11:00:43.226]  - Number of conditions: 1
[11:00:43.226] signalConditions() ... done
[11:00:43.226] signalConditions() ...
[11:00:43.226]  - include = ‘immediateCondition’
[11:00:43.226]  - exclude = 
[11:00:43.226]  - resignal = FALSE
[11:00:43.226]  - Number of conditions: 1
[11:00:43.226] signalConditions() ... done
> calls <- backtrace(ll[[2]])
[11:00:43.226] resolved() for ‘SequentialFuture’ ...
[11:00:43.227] - state: ‘finished’
[11:00:43.227] - run: TRUE
[11:00:43.227] - result: ‘FutureResult’
[11:00:43.227] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> message("*** backtrace( ) - subsetting ... DONE")
*** backtrace( ) - subsetting ... DONE
> 
> 
> message("*** backtrace( ) - exceptions ...")
*** backtrace( ) - exceptions ...
> 
> message("- No condition ...")
- No condition ...
> f <- future(42L)
[11:00:43.227] getGlobalsAndPackages() ...
[11:00:43.227] Searching for globals...
[11:00:43.228] 
[11:00:43.228] Searching for globals ... DONE
[11:00:43.228] - globals: [0] <none>
[11:00:43.228] getGlobalsAndPackages() ... DONE
[11:00:43.228] run() for ‘Future’ ...
[11:00:43.228] - state: ‘created’
[11:00:43.228] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.229] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.229]   - Field: ‘label’
[11:00:43.229]   - Field: ‘local’
[11:00:43.229]   - Field: ‘owner’
[11:00:43.229]   - Field: ‘envir’
[11:00:43.229]   - Field: ‘packages’
[11:00:43.229]   - Field: ‘gc’
[11:00:43.229]   - Field: ‘conditions’
[11:00:43.229]   - Field: ‘expr’
[11:00:43.229]   - Field: ‘uuid’
[11:00:43.229]   - Field: ‘seed’
[11:00:43.230]   - Field: ‘version’
[11:00:43.230]   - Field: ‘result’
[11:00:43.230]   - Field: ‘asynchronous’
[11:00:43.230]   - Field: ‘calls’
[11:00:43.230]   - Field: ‘globals’
[11:00:43.230]   - Field: ‘stdout’
[11:00:43.230]   - Field: ‘earlySignal’
[11:00:43.230]   - Field: ‘lazy’
[11:00:43.230]   - Field: ‘state’
[11:00:43.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.230] - Launch lazy future ...
[11:00:43.230] Packages needed by the future expression (n = 0): <none>
[11:00:43.231] Packages needed by future strategies (n = 0): <none>
[11:00:43.231] {
[11:00:43.231]     {
[11:00:43.231]         {
[11:00:43.231]             ...future.startTime <- base::Sys.time()
[11:00:43.231]             {
[11:00:43.231]                 {
[11:00:43.231]                   {
[11:00:43.231]                     base::local({
[11:00:43.231]                       has_future <- base::requireNamespace("future", 
[11:00:43.231]                         quietly = TRUE)
[11:00:43.231]                       if (has_future) {
[11:00:43.231]                         ns <- base::getNamespace("future")
[11:00:43.231]                         version <- ns[[".package"]][["version"]]
[11:00:43.231]                         if (is.null(version)) 
[11:00:43.231]                           version <- utils::packageVersion("future")
[11:00:43.231]                       }
[11:00:43.231]                       else {
[11:00:43.231]                         version <- NULL
[11:00:43.231]                       }
[11:00:43.231]                       if (!has_future || version < "1.8.0") {
[11:00:43.231]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.231]                           "", base::R.version$version.string), 
[11:00:43.231]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.231]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.231]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.231]                             "release", "version")], collapse = " "), 
[11:00:43.231]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.231]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.231]                           info)
[11:00:43.231]                         info <- base::paste(info, collapse = "; ")
[11:00:43.231]                         if (!has_future) {
[11:00:43.231]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.231]                             info)
[11:00:43.231]                         }
[11:00:43.231]                         else {
[11:00:43.231]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.231]                             info, version)
[11:00:43.231]                         }
[11:00:43.231]                         base::stop(msg)
[11:00:43.231]                       }
[11:00:43.231]                     })
[11:00:43.231]                   }
[11:00:43.231]                   ...future.strategy.old <- future::plan("list")
[11:00:43.231]                   options(future.plan = NULL)
[11:00:43.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.231]                 }
[11:00:43.231]                 ...future.workdir <- getwd()
[11:00:43.231]             }
[11:00:43.231]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.231]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.231]         }
[11:00:43.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.231]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.231]             base::names(...future.oldOptions))
[11:00:43.231]     }
[11:00:43.231]     if (FALSE) {
[11:00:43.231]     }
[11:00:43.231]     else {
[11:00:43.231]         if (TRUE) {
[11:00:43.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.231]                 open = "w")
[11:00:43.231]         }
[11:00:43.231]         else {
[11:00:43.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.231]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.231]         }
[11:00:43.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.231]             base::sink(type = "output", split = FALSE)
[11:00:43.231]             base::close(...future.stdout)
[11:00:43.231]         }, add = TRUE)
[11:00:43.231]     }
[11:00:43.231]     ...future.frame <- base::sys.nframe()
[11:00:43.231]     ...future.conditions <- base::list()
[11:00:43.231]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.231]     if (FALSE) {
[11:00:43.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.231]     }
[11:00:43.231]     ...future.result <- base::tryCatch({
[11:00:43.231]         base::withCallingHandlers({
[11:00:43.231]             ...future.value <- base::withVisible(base::local(42L))
[11:00:43.231]             future::FutureResult(value = ...future.value$value, 
[11:00:43.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.231]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.231]                     ...future.globalenv.names))
[11:00:43.231]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.231]         }, condition = base::local({
[11:00:43.231]             c <- base::c
[11:00:43.231]             inherits <- base::inherits
[11:00:43.231]             invokeRestart <- base::invokeRestart
[11:00:43.231]             length <- base::length
[11:00:43.231]             list <- base::list
[11:00:43.231]             seq.int <- base::seq.int
[11:00:43.231]             signalCondition <- base::signalCondition
[11:00:43.231]             sys.calls <- base::sys.calls
[11:00:43.231]             `[[` <- base::`[[`
[11:00:43.231]             `+` <- base::`+`
[11:00:43.231]             `<<-` <- base::`<<-`
[11:00:43.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.231]                   3L)]
[11:00:43.231]             }
[11:00:43.231]             function(cond) {
[11:00:43.231]                 is_error <- inherits(cond, "error")
[11:00:43.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.231]                   NULL)
[11:00:43.231]                 if (is_error) {
[11:00:43.231]                   sessionInformation <- function() {
[11:00:43.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.231]                       search = base::search(), system = base::Sys.info())
[11:00:43.231]                   }
[11:00:43.231]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.231]                     cond$call), session = sessionInformation(), 
[11:00:43.231]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.231]                   signalCondition(cond)
[11:00:43.231]                 }
[11:00:43.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.231]                 "immediateCondition"))) {
[11:00:43.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.231]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.231]                   if (TRUE && !signal) {
[11:00:43.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.231]                     {
[11:00:43.231]                       inherits <- base::inherits
[11:00:43.231]                       invokeRestart <- base::invokeRestart
[11:00:43.231]                       is.null <- base::is.null
[11:00:43.231]                       muffled <- FALSE
[11:00:43.231]                       if (inherits(cond, "message")) {
[11:00:43.231]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.231]                         if (muffled) 
[11:00:43.231]                           invokeRestart("muffleMessage")
[11:00:43.231]                       }
[11:00:43.231]                       else if (inherits(cond, "warning")) {
[11:00:43.231]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.231]                         if (muffled) 
[11:00:43.231]                           invokeRestart("muffleWarning")
[11:00:43.231]                       }
[11:00:43.231]                       else if (inherits(cond, "condition")) {
[11:00:43.231]                         if (!is.null(pattern)) {
[11:00:43.231]                           computeRestarts <- base::computeRestarts
[11:00:43.231]                           grepl <- base::grepl
[11:00:43.231]                           restarts <- computeRestarts(cond)
[11:00:43.231]                           for (restart in restarts) {
[11:00:43.231]                             name <- restart$name
[11:00:43.231]                             if (is.null(name)) 
[11:00:43.231]                               next
[11:00:43.231]                             if (!grepl(pattern, name)) 
[11:00:43.231]                               next
[11:00:43.231]                             invokeRestart(restart)
[11:00:43.231]                             muffled <- TRUE
[11:00:43.231]                             break
[11:00:43.231]                           }
[11:00:43.231]                         }
[11:00:43.231]                       }
[11:00:43.231]                       invisible(muffled)
[11:00:43.231]                     }
[11:00:43.231]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.231]                   }
[11:00:43.231]                 }
[11:00:43.231]                 else {
[11:00:43.231]                   if (TRUE) {
[11:00:43.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.231]                     {
[11:00:43.231]                       inherits <- base::inherits
[11:00:43.231]                       invokeRestart <- base::invokeRestart
[11:00:43.231]                       is.null <- base::is.null
[11:00:43.231]                       muffled <- FALSE
[11:00:43.231]                       if (inherits(cond, "message")) {
[11:00:43.231]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.231]                         if (muffled) 
[11:00:43.231]                           invokeRestart("muffleMessage")
[11:00:43.231]                       }
[11:00:43.231]                       else if (inherits(cond, "warning")) {
[11:00:43.231]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.231]                         if (muffled) 
[11:00:43.231]                           invokeRestart("muffleWarning")
[11:00:43.231]                       }
[11:00:43.231]                       else if (inherits(cond, "condition")) {
[11:00:43.231]                         if (!is.null(pattern)) {
[11:00:43.231]                           computeRestarts <- base::computeRestarts
[11:00:43.231]                           grepl <- base::grepl
[11:00:43.231]                           restarts <- computeRestarts(cond)
[11:00:43.231]                           for (restart in restarts) {
[11:00:43.231]                             name <- restart$name
[11:00:43.231]                             if (is.null(name)) 
[11:00:43.231]                               next
[11:00:43.231]                             if (!grepl(pattern, name)) 
[11:00:43.231]                               next
[11:00:43.231]                             invokeRestart(restart)
[11:00:43.231]                             muffled <- TRUE
[11:00:43.231]                             break
[11:00:43.231]                           }
[11:00:43.231]                         }
[11:00:43.231]                       }
[11:00:43.231]                       invisible(muffled)
[11:00:43.231]                     }
[11:00:43.231]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.231]                   }
[11:00:43.231]                 }
[11:00:43.231]             }
[11:00:43.231]         }))
[11:00:43.231]     }, error = function(ex) {
[11:00:43.231]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.231]                 ...future.rng), started = ...future.startTime, 
[11:00:43.231]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.231]             version = "1.8"), class = "FutureResult")
[11:00:43.231]     }, finally = {
[11:00:43.231]         if (!identical(...future.workdir, getwd())) 
[11:00:43.231]             setwd(...future.workdir)
[11:00:43.231]         {
[11:00:43.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.231]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.231]             }
[11:00:43.231]             base::options(...future.oldOptions)
[11:00:43.231]             if (.Platform$OS.type == "windows") {
[11:00:43.231]                 old_names <- names(...future.oldEnvVars)
[11:00:43.231]                 envs <- base::Sys.getenv()
[11:00:43.231]                 names <- names(envs)
[11:00:43.231]                 common <- intersect(names, old_names)
[11:00:43.231]                 added <- setdiff(names, old_names)
[11:00:43.231]                 removed <- setdiff(old_names, names)
[11:00:43.231]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.231]                   envs[common]]
[11:00:43.231]                 NAMES <- toupper(changed)
[11:00:43.231]                 args <- list()
[11:00:43.231]                 for (kk in seq_along(NAMES)) {
[11:00:43.231]                   name <- changed[[kk]]
[11:00:43.231]                   NAME <- NAMES[[kk]]
[11:00:43.231]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.231]                     next
[11:00:43.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.231]                 }
[11:00:43.231]                 NAMES <- toupper(added)
[11:00:43.231]                 for (kk in seq_along(NAMES)) {
[11:00:43.231]                   name <- added[[kk]]
[11:00:43.231]                   NAME <- NAMES[[kk]]
[11:00:43.231]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.231]                     next
[11:00:43.231]                   args[[name]] <- ""
[11:00:43.231]                 }
[11:00:43.231]                 NAMES <- toupper(removed)
[11:00:43.231]                 for (kk in seq_along(NAMES)) {
[11:00:43.231]                   name <- removed[[kk]]
[11:00:43.231]                   NAME <- NAMES[[kk]]
[11:00:43.231]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.231]                     next
[11:00:43.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.231]                 }
[11:00:43.231]                 if (length(args) > 0) 
[11:00:43.231]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.231]             }
[11:00:43.231]             else {
[11:00:43.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.231]             }
[11:00:43.231]             {
[11:00:43.231]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.231]                   0L) {
[11:00:43.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.231]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.231]                   base::options(opts)
[11:00:43.231]                 }
[11:00:43.231]                 {
[11:00:43.231]                   {
[11:00:43.231]                     NULL
[11:00:43.231]                     RNGkind("Mersenne-Twister")
[11:00:43.231]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.231]                       inherits = FALSE)
[11:00:43.231]                   }
[11:00:43.231]                   options(future.plan = NULL)
[11:00:43.231]                   if (is.na(NA_character_)) 
[11:00:43.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.231]                     .init = FALSE)
[11:00:43.231]                 }
[11:00:43.231]             }
[11:00:43.231]         }
[11:00:43.231]     })
[11:00:43.231]     if (TRUE) {
[11:00:43.231]         base::sink(type = "output", split = FALSE)
[11:00:43.231]         if (TRUE) {
[11:00:43.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.231]         }
[11:00:43.231]         else {
[11:00:43.231]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.231]         }
[11:00:43.231]         base::close(...future.stdout)
[11:00:43.231]         ...future.stdout <- NULL
[11:00:43.231]     }
[11:00:43.231]     ...future.result$conditions <- ...future.conditions
[11:00:43.231]     ...future.result$finished <- base::Sys.time()
[11:00:43.231]     ...future.result
[11:00:43.231] }
[11:00:43.233] plan(): Setting new future strategy stack:
[11:00:43.233] List of future strategies:
[11:00:43.233] 1. sequential:
[11:00:43.233]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.233]    - tweaked: FALSE
[11:00:43.233]    - call: NULL
[11:00:43.233] plan(): nbrOfWorkers() = 1
[11:00:43.234] plan(): Setting new future strategy stack:
[11:00:43.234] List of future strategies:
[11:00:43.234] 1. sequential:
[11:00:43.234]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.234]    - tweaked: FALSE
[11:00:43.234]    - call: future::plan("sequential")
[11:00:43.235] plan(): nbrOfWorkers() = 1
[11:00:43.235] SequentialFuture started (and completed)
[11:00:43.235] - Launch lazy future ... done
[11:00:43.235] run() for ‘SequentialFuture’ ... done
> res <- tryCatch(backtrace(f), error = identity)
[11:00:43.235] resolved() for ‘SequentialFuture’ ...
[11:00:43.235] - state: ‘finished’
[11:00:43.235] - run: TRUE
[11:00:43.236] - result: ‘FutureResult’
[11:00:43.236] resolved() for ‘SequentialFuture’ ... done
> print(res)
<simpleError: No error was caught for this future: ‘f’>
> stopifnot(inherits(res, "error"))
> 
> message("- No call stack ...")
- No call stack ...
> f <- future({ 42L; stop("Woops") })
[11:00:43.236] getGlobalsAndPackages() ...
[11:00:43.236] Searching for globals...
[11:00:43.237] - globals found: [2] ‘{’, ‘stop’
[11:00:43.237] Searching for globals ... DONE
[11:00:43.237] Resolving globals: FALSE
[11:00:43.237] 
[11:00:43.237] 
[11:00:43.237] getGlobalsAndPackages() ... DONE
[11:00:43.238] run() for ‘Future’ ...
[11:00:43.238] - state: ‘created’
[11:00:43.238] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:43.238] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:43.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:43.238]   - Field: ‘label’
[11:00:43.238]   - Field: ‘local’
[11:00:43.238]   - Field: ‘owner’
[11:00:43.239]   - Field: ‘envir’
[11:00:43.239]   - Field: ‘packages’
[11:00:43.239]   - Field: ‘gc’
[11:00:43.239]   - Field: ‘conditions’
[11:00:43.239]   - Field: ‘expr’
[11:00:43.239]   - Field: ‘uuid’
[11:00:43.239]   - Field: ‘seed’
[11:00:43.239]   - Field: ‘version’
[11:00:43.239]   - Field: ‘result’
[11:00:43.239]   - Field: ‘asynchronous’
[11:00:43.239]   - Field: ‘calls’
[11:00:43.239]   - Field: ‘globals’
[11:00:43.240]   - Field: ‘stdout’
[11:00:43.240]   - Field: ‘earlySignal’
[11:00:43.240]   - Field: ‘lazy’
[11:00:43.240]   - Field: ‘state’
[11:00:43.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:43.240] - Launch lazy future ...
[11:00:43.240] Packages needed by the future expression (n = 0): <none>
[11:00:43.240] Packages needed by future strategies (n = 0): <none>
[11:00:43.241] {
[11:00:43.241]     {
[11:00:43.241]         {
[11:00:43.241]             ...future.startTime <- base::Sys.time()
[11:00:43.241]             {
[11:00:43.241]                 {
[11:00:43.241]                   {
[11:00:43.241]                     base::local({
[11:00:43.241]                       has_future <- base::requireNamespace("future", 
[11:00:43.241]                         quietly = TRUE)
[11:00:43.241]                       if (has_future) {
[11:00:43.241]                         ns <- base::getNamespace("future")
[11:00:43.241]                         version <- ns[[".package"]][["version"]]
[11:00:43.241]                         if (is.null(version)) 
[11:00:43.241]                           version <- utils::packageVersion("future")
[11:00:43.241]                       }
[11:00:43.241]                       else {
[11:00:43.241]                         version <- NULL
[11:00:43.241]                       }
[11:00:43.241]                       if (!has_future || version < "1.8.0") {
[11:00:43.241]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.241]                           "", base::R.version$version.string), 
[11:00:43.241]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:43.241]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.241]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.241]                             "release", "version")], collapse = " "), 
[11:00:43.241]                           hostname = base::Sys.info()[["nodename"]])
[11:00:43.241]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.241]                           info)
[11:00:43.241]                         info <- base::paste(info, collapse = "; ")
[11:00:43.241]                         if (!has_future) {
[11:00:43.241]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.241]                             info)
[11:00:43.241]                         }
[11:00:43.241]                         else {
[11:00:43.241]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.241]                             info, version)
[11:00:43.241]                         }
[11:00:43.241]                         base::stop(msg)
[11:00:43.241]                       }
[11:00:43.241]                     })
[11:00:43.241]                   }
[11:00:43.241]                   ...future.strategy.old <- future::plan("list")
[11:00:43.241]                   options(future.plan = NULL)
[11:00:43.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.241]                 }
[11:00:43.241]                 ...future.workdir <- getwd()
[11:00:43.241]             }
[11:00:43.241]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.241]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.241]         }
[11:00:43.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.241]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.241]             base::names(...future.oldOptions))
[11:00:43.241]     }
[11:00:43.241]     if (FALSE) {
[11:00:43.241]     }
[11:00:43.241]     else {
[11:00:43.241]         if (TRUE) {
[11:00:43.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.241]                 open = "w")
[11:00:43.241]         }
[11:00:43.241]         else {
[11:00:43.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.241]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.241]         }
[11:00:43.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.241]             base::sink(type = "output", split = FALSE)
[11:00:43.241]             base::close(...future.stdout)
[11:00:43.241]         }, add = TRUE)
[11:00:43.241]     }
[11:00:43.241]     ...future.frame <- base::sys.nframe()
[11:00:43.241]     ...future.conditions <- base::list()
[11:00:43.241]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.241]     if (FALSE) {
[11:00:43.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.241]     }
[11:00:43.241]     ...future.result <- base::tryCatch({
[11:00:43.241]         base::withCallingHandlers({
[11:00:43.241]             ...future.value <- base::withVisible(base::local({
[11:00:43.241]                 42L
[11:00:43.241]                 stop("Woops")
[11:00:43.241]             }))
[11:00:43.241]             future::FutureResult(value = ...future.value$value, 
[11:00:43.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.241]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.241]                     ...future.globalenv.names))
[11:00:43.241]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.241]         }, condition = base::local({
[11:00:43.241]             c <- base::c
[11:00:43.241]             inherits <- base::inherits
[11:00:43.241]             invokeRestart <- base::invokeRestart
[11:00:43.241]             length <- base::length
[11:00:43.241]             list <- base::list
[11:00:43.241]             seq.int <- base::seq.int
[11:00:43.241]             signalCondition <- base::signalCondition
[11:00:43.241]             sys.calls <- base::sys.calls
[11:00:43.241]             `[[` <- base::`[[`
[11:00:43.241]             `+` <- base::`+`
[11:00:43.241]             `<<-` <- base::`<<-`
[11:00:43.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.241]                   3L)]
[11:00:43.241]             }
[11:00:43.241]             function(cond) {
[11:00:43.241]                 is_error <- inherits(cond, "error")
[11:00:43.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.241]                   NULL)
[11:00:43.241]                 if (is_error) {
[11:00:43.241]                   sessionInformation <- function() {
[11:00:43.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.241]                       search = base::search(), system = base::Sys.info())
[11:00:43.241]                   }
[11:00:43.241]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.241]                     cond$call), session = sessionInformation(), 
[11:00:43.241]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.241]                   signalCondition(cond)
[11:00:43.241]                 }
[11:00:43.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.241]                 "immediateCondition"))) {
[11:00:43.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.241]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.241]                   if (TRUE && !signal) {
[11:00:43.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.241]                     {
[11:00:43.241]                       inherits <- base::inherits
[11:00:43.241]                       invokeRestart <- base::invokeRestart
[11:00:43.241]                       is.null <- base::is.null
[11:00:43.241]                       muffled <- FALSE
[11:00:43.241]                       if (inherits(cond, "message")) {
[11:00:43.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.241]                         if (muffled) 
[11:00:43.241]                           invokeRestart("muffleMessage")
[11:00:43.241]                       }
[11:00:43.241]                       else if (inherits(cond, "warning")) {
[11:00:43.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.241]                         if (muffled) 
[11:00:43.241]                           invokeRestart("muffleWarning")
[11:00:43.241]                       }
[11:00:43.241]                       else if (inherits(cond, "condition")) {
[11:00:43.241]                         if (!is.null(pattern)) {
[11:00:43.241]                           computeRestarts <- base::computeRestarts
[11:00:43.241]                           grepl <- base::grepl
[11:00:43.241]                           restarts <- computeRestarts(cond)
[11:00:43.241]                           for (restart in restarts) {
[11:00:43.241]                             name <- restart$name
[11:00:43.241]                             if (is.null(name)) 
[11:00:43.241]                               next
[11:00:43.241]                             if (!grepl(pattern, name)) 
[11:00:43.241]                               next
[11:00:43.241]                             invokeRestart(restart)
[11:00:43.241]                             muffled <- TRUE
[11:00:43.241]                             break
[11:00:43.241]                           }
[11:00:43.241]                         }
[11:00:43.241]                       }
[11:00:43.241]                       invisible(muffled)
[11:00:43.241]                     }
[11:00:43.241]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.241]                   }
[11:00:43.241]                 }
[11:00:43.241]                 else {
[11:00:43.241]                   if (TRUE) {
[11:00:43.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.241]                     {
[11:00:43.241]                       inherits <- base::inherits
[11:00:43.241]                       invokeRestart <- base::invokeRestart
[11:00:43.241]                       is.null <- base::is.null
[11:00:43.241]                       muffled <- FALSE
[11:00:43.241]                       if (inherits(cond, "message")) {
[11:00:43.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.241]                         if (muffled) 
[11:00:43.241]                           invokeRestart("muffleMessage")
[11:00:43.241]                       }
[11:00:43.241]                       else if (inherits(cond, "warning")) {
[11:00:43.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.241]                         if (muffled) 
[11:00:43.241]                           invokeRestart("muffleWarning")
[11:00:43.241]                       }
[11:00:43.241]                       else if (inherits(cond, "condition")) {
[11:00:43.241]                         if (!is.null(pattern)) {
[11:00:43.241]                           computeRestarts <- base::computeRestarts
[11:00:43.241]                           grepl <- base::grepl
[11:00:43.241]                           restarts <- computeRestarts(cond)
[11:00:43.241]                           for (restart in restarts) {
[11:00:43.241]                             name <- restart$name
[11:00:43.241]                             if (is.null(name)) 
[11:00:43.241]                               next
[11:00:43.241]                             if (!grepl(pattern, name)) 
[11:00:43.241]                               next
[11:00:43.241]                             invokeRestart(restart)
[11:00:43.241]                             muffled <- TRUE
[11:00:43.241]                             break
[11:00:43.241]                           }
[11:00:43.241]                         }
[11:00:43.241]                       }
[11:00:43.241]                       invisible(muffled)
[11:00:43.241]                     }
[11:00:43.241]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.241]                   }
[11:00:43.241]                 }
[11:00:43.241]             }
[11:00:43.241]         }))
[11:00:43.241]     }, error = function(ex) {
[11:00:43.241]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.241]                 ...future.rng), started = ...future.startTime, 
[11:00:43.241]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.241]             version = "1.8"), class = "FutureResult")
[11:00:43.241]     }, finally = {
[11:00:43.241]         if (!identical(...future.workdir, getwd())) 
[11:00:43.241]             setwd(...future.workdir)
[11:00:43.241]         {
[11:00:43.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.241]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.241]             }
[11:00:43.241]             base::options(...future.oldOptions)
[11:00:43.241]             if (.Platform$OS.type == "windows") {
[11:00:43.241]                 old_names <- names(...future.oldEnvVars)
[11:00:43.241]                 envs <- base::Sys.getenv()
[11:00:43.241]                 names <- names(envs)
[11:00:43.241]                 common <- intersect(names, old_names)
[11:00:43.241]                 added <- setdiff(names, old_names)
[11:00:43.241]                 removed <- setdiff(old_names, names)
[11:00:43.241]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.241]                   envs[common]]
[11:00:43.241]                 NAMES <- toupper(changed)
[11:00:43.241]                 args <- list()
[11:00:43.241]                 for (kk in seq_along(NAMES)) {
[11:00:43.241]                   name <- changed[[kk]]
[11:00:43.241]                   NAME <- NAMES[[kk]]
[11:00:43.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.241]                     next
[11:00:43.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.241]                 }
[11:00:43.241]                 NAMES <- toupper(added)
[11:00:43.241]                 for (kk in seq_along(NAMES)) {
[11:00:43.241]                   name <- added[[kk]]
[11:00:43.241]                   NAME <- NAMES[[kk]]
[11:00:43.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.241]                     next
[11:00:43.241]                   args[[name]] <- ""
[11:00:43.241]                 }
[11:00:43.241]                 NAMES <- toupper(removed)
[11:00:43.241]                 for (kk in seq_along(NAMES)) {
[11:00:43.241]                   name <- removed[[kk]]
[11:00:43.241]                   NAME <- NAMES[[kk]]
[11:00:43.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.241]                     next
[11:00:43.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.241]                 }
[11:00:43.241]                 if (length(args) > 0) 
[11:00:43.241]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.241]             }
[11:00:43.241]             else {
[11:00:43.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.241]             }
[11:00:43.241]             {
[11:00:43.241]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.241]                   0L) {
[11:00:43.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.241]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.241]                   base::options(opts)
[11:00:43.241]                 }
[11:00:43.241]                 {
[11:00:43.241]                   {
[11:00:43.241]                     NULL
[11:00:43.241]                     RNGkind("Mersenne-Twister")
[11:00:43.241]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:43.241]                       inherits = FALSE)
[11:00:43.241]                   }
[11:00:43.241]                   options(future.plan = NULL)
[11:00:43.241]                   if (is.na(NA_character_)) 
[11:00:43.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.241]                     .init = FALSE)
[11:00:43.241]                 }
[11:00:43.241]             }
[11:00:43.241]         }
[11:00:43.241]     })
[11:00:43.241]     if (TRUE) {
[11:00:43.241]         base::sink(type = "output", split = FALSE)
[11:00:43.241]         if (TRUE) {
[11:00:43.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.241]         }
[11:00:43.241]         else {
[11:00:43.241]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.241]         }
[11:00:43.241]         base::close(...future.stdout)
[11:00:43.241]         ...future.stdout <- NULL
[11:00:43.241]     }
[11:00:43.241]     ...future.result$conditions <- ...future.conditions
[11:00:43.241]     ...future.result$finished <- base::Sys.time()
[11:00:43.241]     ...future.result
[11:00:43.241] }
[11:00:43.242] plan(): Setting new future strategy stack:
[11:00:43.242] List of future strategies:
[11:00:43.242] 1. sequential:
[11:00:43.242]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.242]    - tweaked: FALSE
[11:00:43.242]    - call: NULL
[11:00:43.243] plan(): nbrOfWorkers() = 1
[11:00:43.244] plan(): Setting new future strategy stack:
[11:00:43.244] List of future strategies:
[11:00:43.244] 1. sequential:
[11:00:43.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:43.244]    - tweaked: FALSE
[11:00:43.244]    - call: future::plan("sequential")
[11:00:43.244] plan(): nbrOfWorkers() = 1
[11:00:43.244] SequentialFuture started (and completed)
[11:00:43.244] signalConditions() ...
[11:00:43.244]  - include = ‘immediateCondition’
[11:00:43.244]  - exclude = 
[11:00:43.245]  - resignal = FALSE
[11:00:43.245]  - Number of conditions: 1
[11:00:43.245] signalConditions() ... done
[11:00:43.245] - Launch lazy future ... done
[11:00:43.245] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[11:00:43.245] signalConditions() ...
[11:00:43.245]  - include = ‘immediateCondition’
[11:00:43.245]  - exclude = 
[11:00:43.245]  - resignal = FALSE
[11:00:43.245]  - Number of conditions: 1
[11:00:43.245] signalConditions() ... done
> 
> if (availableCores() >= 2L) {
+   message("- Non-resolved future ...")
+   plan(multisession, workers = 2L)
+   f <- future({ Sys.sleep(3); 42L; stop("Woops") })
+   res <- tryCatch(backtrace(f), error = identity)
+   print(res)
+   stopifnot(inherits(res, "error"))
+   
+   ## If we don't resolve the future, the cluster of workers will not
+   ## be able to shut down naturally. They will eventually time out,
+   ## but that will happen long after 'R CMD check' terminates. Because
+   ## of this, 'R CMD check --as-cran' will report on "detritus in the
+   ## temp directory" when running on MS Windows.  This happens because
+   ## MS Windows doesn't shut down child processes as Linux and macOS
+   ## does when the main R session terminates.
+   resolve(f)
+ }
- Non-resolved future ...
[11:00:43.250] plan(): Setting new future strategy stack:
[11:00:43.250] List of future strategies:
[11:00:43.250] 1. multisession:
[11:00:43.250]    - args: function (..., workers = 2L, envir = parent.frame())
[11:00:43.250]    - tweaked: TRUE
[11:00:43.250]    - call: plan(multisession, workers = 2L)
[11:00:43.261] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:00:43.261] multisession:
[11:00:43.261] - args: function (..., workers = 2L, envir = parent.frame())
[11:00:43.261] - tweaked: TRUE
[11:00:43.261] - call: plan(multisession, workers = 2L)
[11:00:43.261] getGlobalsAndPackages() ...
[11:00:43.261] Not searching for globals
[11:00:43.262] - globals: [0] <none>
[11:00:43.262] getGlobalsAndPackages() ... DONE
[11:00:43.726] Packages needed by the future expression (n = 0): <none>
[11:00:43.726] Packages needed by future strategies (n = 0): <none>
[11:00:43.726] {
[11:00:43.726]     {
[11:00:43.726]         {
[11:00:43.726]             ...future.startTime <- base::Sys.time()
[11:00:43.726]             {
[11:00:43.726]                 {
[11:00:43.726]                   {
[11:00:43.726]                     {
[11:00:43.726]                       base::local({
[11:00:43.726]                         has_future <- base::requireNamespace("future", 
[11:00:43.726]                           quietly = TRUE)
[11:00:43.726]                         if (has_future) {
[11:00:43.726]                           ns <- base::getNamespace("future")
[11:00:43.726]                           version <- ns[[".package"]][["version"]]
[11:00:43.726]                           if (is.null(version)) 
[11:00:43.726]                             version <- utils::packageVersion("future")
[11:00:43.726]                         }
[11:00:43.726]                         else {
[11:00:43.726]                           version <- NULL
[11:00:43.726]                         }
[11:00:43.726]                         if (!has_future || version < "1.8.0") {
[11:00:43.726]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.726]                             "", base::R.version$version.string), 
[11:00:43.726]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:43.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.726]                               "release", "version")], collapse = " "), 
[11:00:43.726]                             hostname = base::Sys.info()[["nodename"]])
[11:00:43.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.726]                             info)
[11:00:43.726]                           info <- base::paste(info, collapse = "; ")
[11:00:43.726]                           if (!has_future) {
[11:00:43.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.726]                               info)
[11:00:43.726]                           }
[11:00:43.726]                           else {
[11:00:43.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.726]                               info, version)
[11:00:43.726]                           }
[11:00:43.726]                           base::stop(msg)
[11:00:43.726]                         }
[11:00:43.726]                       })
[11:00:43.726]                     }
[11:00:43.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:43.726]                     base::options(mc.cores = 1L)
[11:00:43.726]                   }
[11:00:43.726]                   ...future.strategy.old <- future::plan("list")
[11:00:43.726]                   options(future.plan = NULL)
[11:00:43.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.726]                 }
[11:00:43.726]                 ...future.workdir <- getwd()
[11:00:43.726]             }
[11:00:43.726]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.726]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.726]         }
[11:00:43.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.726]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.726]             base::names(...future.oldOptions))
[11:00:43.726]     }
[11:00:43.726]     if (FALSE) {
[11:00:43.726]     }
[11:00:43.726]     else {
[11:00:43.726]         if (TRUE) {
[11:00:43.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.726]                 open = "w")
[11:00:43.726]         }
[11:00:43.726]         else {
[11:00:43.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.726]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.726]         }
[11:00:43.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.726]             base::sink(type = "output", split = FALSE)
[11:00:43.726]             base::close(...future.stdout)
[11:00:43.726]         }, add = TRUE)
[11:00:43.726]     }
[11:00:43.726]     ...future.frame <- base::sys.nframe()
[11:00:43.726]     ...future.conditions <- base::list()
[11:00:43.726]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.726]     if (FALSE) {
[11:00:43.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.726]     }
[11:00:43.726]     ...future.result <- base::tryCatch({
[11:00:43.726]         base::withCallingHandlers({
[11:00:43.726]             ...future.value <- base::withVisible(base::local({
[11:00:43.726]                 ...future.makeSendCondition <- base::local({
[11:00:43.726]                   sendCondition <- NULL
[11:00:43.726]                   function(frame = 1L) {
[11:00:43.726]                     if (is.function(sendCondition)) 
[11:00:43.726]                       return(sendCondition)
[11:00:43.726]                     ns <- getNamespace("parallel")
[11:00:43.726]                     if (exists("sendData", mode = "function", 
[11:00:43.726]                       envir = ns)) {
[11:00:43.726]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:43.726]                         envir = ns)
[11:00:43.726]                       envir <- sys.frame(frame)
[11:00:43.726]                       master <- NULL
[11:00:43.726]                       while (!identical(envir, .GlobalEnv) && 
[11:00:43.726]                         !identical(envir, emptyenv())) {
[11:00:43.726]                         if (exists("master", mode = "list", envir = envir, 
[11:00:43.726]                           inherits = FALSE)) {
[11:00:43.726]                           master <- get("master", mode = "list", 
[11:00:43.726]                             envir = envir, inherits = FALSE)
[11:00:43.726]                           if (inherits(master, c("SOCKnode", 
[11:00:43.726]                             "SOCK0node"))) {
[11:00:43.726]                             sendCondition <<- function(cond) {
[11:00:43.726]                               data <- list(type = "VALUE", value = cond, 
[11:00:43.726]                                 success = TRUE)
[11:00:43.726]                               parallel_sendData(master, data)
[11:00:43.726]                             }
[11:00:43.726]                             return(sendCondition)
[11:00:43.726]                           }
[11:00:43.726]                         }
[11:00:43.726]                         frame <- frame + 1L
[11:00:43.726]                         envir <- sys.frame(frame)
[11:00:43.726]                       }
[11:00:43.726]                     }
[11:00:43.726]                     sendCondition <<- function(cond) NULL
[11:00:43.726]                   }
[11:00:43.726]                 })
[11:00:43.726]                 withCallingHandlers({
[11:00:43.726]                   NA
[11:00:43.726]                 }, immediateCondition = function(cond) {
[11:00:43.726]                   sendCondition <- ...future.makeSendCondition()
[11:00:43.726]                   sendCondition(cond)
[11:00:43.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.726]                   {
[11:00:43.726]                     inherits <- base::inherits
[11:00:43.726]                     invokeRestart <- base::invokeRestart
[11:00:43.726]                     is.null <- base::is.null
[11:00:43.726]                     muffled <- FALSE
[11:00:43.726]                     if (inherits(cond, "message")) {
[11:00:43.726]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:43.726]                       if (muffled) 
[11:00:43.726]                         invokeRestart("muffleMessage")
[11:00:43.726]                     }
[11:00:43.726]                     else if (inherits(cond, "warning")) {
[11:00:43.726]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:43.726]                       if (muffled) 
[11:00:43.726]                         invokeRestart("muffleWarning")
[11:00:43.726]                     }
[11:00:43.726]                     else if (inherits(cond, "condition")) {
[11:00:43.726]                       if (!is.null(pattern)) {
[11:00:43.726]                         computeRestarts <- base::computeRestarts
[11:00:43.726]                         grepl <- base::grepl
[11:00:43.726]                         restarts <- computeRestarts(cond)
[11:00:43.726]                         for (restart in restarts) {
[11:00:43.726]                           name <- restart$name
[11:00:43.726]                           if (is.null(name)) 
[11:00:43.726]                             next
[11:00:43.726]                           if (!grepl(pattern, name)) 
[11:00:43.726]                             next
[11:00:43.726]                           invokeRestart(restart)
[11:00:43.726]                           muffled <- TRUE
[11:00:43.726]                           break
[11:00:43.726]                         }
[11:00:43.726]                       }
[11:00:43.726]                     }
[11:00:43.726]                     invisible(muffled)
[11:00:43.726]                   }
[11:00:43.726]                   muffleCondition(cond)
[11:00:43.726]                 })
[11:00:43.726]             }))
[11:00:43.726]             future::FutureResult(value = ...future.value$value, 
[11:00:43.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.726]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.726]                     ...future.globalenv.names))
[11:00:43.726]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.726]         }, condition = base::local({
[11:00:43.726]             c <- base::c
[11:00:43.726]             inherits <- base::inherits
[11:00:43.726]             invokeRestart <- base::invokeRestart
[11:00:43.726]             length <- base::length
[11:00:43.726]             list <- base::list
[11:00:43.726]             seq.int <- base::seq.int
[11:00:43.726]             signalCondition <- base::signalCondition
[11:00:43.726]             sys.calls <- base::sys.calls
[11:00:43.726]             `[[` <- base::`[[`
[11:00:43.726]             `+` <- base::`+`
[11:00:43.726]             `<<-` <- base::`<<-`
[11:00:43.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.726]                   3L)]
[11:00:43.726]             }
[11:00:43.726]             function(cond) {
[11:00:43.726]                 is_error <- inherits(cond, "error")
[11:00:43.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.726]                   NULL)
[11:00:43.726]                 if (is_error) {
[11:00:43.726]                   sessionInformation <- function() {
[11:00:43.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.726]                       search = base::search(), system = base::Sys.info())
[11:00:43.726]                   }
[11:00:43.726]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.726]                     cond$call), session = sessionInformation(), 
[11:00:43.726]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.726]                   signalCondition(cond)
[11:00:43.726]                 }
[11:00:43.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.726]                 "immediateCondition"))) {
[11:00:43.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.726]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.726]                   if (TRUE && !signal) {
[11:00:43.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.726]                     {
[11:00:43.726]                       inherits <- base::inherits
[11:00:43.726]                       invokeRestart <- base::invokeRestart
[11:00:43.726]                       is.null <- base::is.null
[11:00:43.726]                       muffled <- FALSE
[11:00:43.726]                       if (inherits(cond, "message")) {
[11:00:43.726]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.726]                         if (muffled) 
[11:00:43.726]                           invokeRestart("muffleMessage")
[11:00:43.726]                       }
[11:00:43.726]                       else if (inherits(cond, "warning")) {
[11:00:43.726]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.726]                         if (muffled) 
[11:00:43.726]                           invokeRestart("muffleWarning")
[11:00:43.726]                       }
[11:00:43.726]                       else if (inherits(cond, "condition")) {
[11:00:43.726]                         if (!is.null(pattern)) {
[11:00:43.726]                           computeRestarts <- base::computeRestarts
[11:00:43.726]                           grepl <- base::grepl
[11:00:43.726]                           restarts <- computeRestarts(cond)
[11:00:43.726]                           for (restart in restarts) {
[11:00:43.726]                             name <- restart$name
[11:00:43.726]                             if (is.null(name)) 
[11:00:43.726]                               next
[11:00:43.726]                             if (!grepl(pattern, name)) 
[11:00:43.726]                               next
[11:00:43.726]                             invokeRestart(restart)
[11:00:43.726]                             muffled <- TRUE
[11:00:43.726]                             break
[11:00:43.726]                           }
[11:00:43.726]                         }
[11:00:43.726]                       }
[11:00:43.726]                       invisible(muffled)
[11:00:43.726]                     }
[11:00:43.726]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.726]                   }
[11:00:43.726]                 }
[11:00:43.726]                 else {
[11:00:43.726]                   if (TRUE) {
[11:00:43.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.726]                     {
[11:00:43.726]                       inherits <- base::inherits
[11:00:43.726]                       invokeRestart <- base::invokeRestart
[11:00:43.726]                       is.null <- base::is.null
[11:00:43.726]                       muffled <- FALSE
[11:00:43.726]                       if (inherits(cond, "message")) {
[11:00:43.726]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.726]                         if (muffled) 
[11:00:43.726]                           invokeRestart("muffleMessage")
[11:00:43.726]                       }
[11:00:43.726]                       else if (inherits(cond, "warning")) {
[11:00:43.726]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.726]                         if (muffled) 
[11:00:43.726]                           invokeRestart("muffleWarning")
[11:00:43.726]                       }
[11:00:43.726]                       else if (inherits(cond, "condition")) {
[11:00:43.726]                         if (!is.null(pattern)) {
[11:00:43.726]                           computeRestarts <- base::computeRestarts
[11:00:43.726]                           grepl <- base::grepl
[11:00:43.726]                           restarts <- computeRestarts(cond)
[11:00:43.726]                           for (restart in restarts) {
[11:00:43.726]                             name <- restart$name
[11:00:43.726]                             if (is.null(name)) 
[11:00:43.726]                               next
[11:00:43.726]                             if (!grepl(pattern, name)) 
[11:00:43.726]                               next
[11:00:43.726]                             invokeRestart(restart)
[11:00:43.726]                             muffled <- TRUE
[11:00:43.726]                             break
[11:00:43.726]                           }
[11:00:43.726]                         }
[11:00:43.726]                       }
[11:00:43.726]                       invisible(muffled)
[11:00:43.726]                     }
[11:00:43.726]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.726]                   }
[11:00:43.726]                 }
[11:00:43.726]             }
[11:00:43.726]         }))
[11:00:43.726]     }, error = function(ex) {
[11:00:43.726]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.726]                 ...future.rng), started = ...future.startTime, 
[11:00:43.726]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.726]             version = "1.8"), class = "FutureResult")
[11:00:43.726]     }, finally = {
[11:00:43.726]         if (!identical(...future.workdir, getwd())) 
[11:00:43.726]             setwd(...future.workdir)
[11:00:43.726]         {
[11:00:43.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.726]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.726]             }
[11:00:43.726]             base::options(...future.oldOptions)
[11:00:43.726]             if (.Platform$OS.type == "windows") {
[11:00:43.726]                 old_names <- names(...future.oldEnvVars)
[11:00:43.726]                 envs <- base::Sys.getenv()
[11:00:43.726]                 names <- names(envs)
[11:00:43.726]                 common <- intersect(names, old_names)
[11:00:43.726]                 added <- setdiff(names, old_names)
[11:00:43.726]                 removed <- setdiff(old_names, names)
[11:00:43.726]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.726]                   envs[common]]
[11:00:43.726]                 NAMES <- toupper(changed)
[11:00:43.726]                 args <- list()
[11:00:43.726]                 for (kk in seq_along(NAMES)) {
[11:00:43.726]                   name <- changed[[kk]]
[11:00:43.726]                   NAME <- NAMES[[kk]]
[11:00:43.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.726]                     next
[11:00:43.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.726]                 }
[11:00:43.726]                 NAMES <- toupper(added)
[11:00:43.726]                 for (kk in seq_along(NAMES)) {
[11:00:43.726]                   name <- added[[kk]]
[11:00:43.726]                   NAME <- NAMES[[kk]]
[11:00:43.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.726]                     next
[11:00:43.726]                   args[[name]] <- ""
[11:00:43.726]                 }
[11:00:43.726]                 NAMES <- toupper(removed)
[11:00:43.726]                 for (kk in seq_along(NAMES)) {
[11:00:43.726]                   name <- removed[[kk]]
[11:00:43.726]                   NAME <- NAMES[[kk]]
[11:00:43.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.726]                     next
[11:00:43.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.726]                 }
[11:00:43.726]                 if (length(args) > 0) 
[11:00:43.726]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.726]             }
[11:00:43.726]             else {
[11:00:43.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.726]             }
[11:00:43.726]             {
[11:00:43.726]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.726]                   0L) {
[11:00:43.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.726]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.726]                   base::options(opts)
[11:00:43.726]                 }
[11:00:43.726]                 {
[11:00:43.726]                   {
[11:00:43.726]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:43.726]                     NULL
[11:00:43.726]                   }
[11:00:43.726]                   options(future.plan = NULL)
[11:00:43.726]                   if (is.na(NA_character_)) 
[11:00:43.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.726]                     .init = FALSE)
[11:00:43.726]                 }
[11:00:43.726]             }
[11:00:43.726]         }
[11:00:43.726]     })
[11:00:43.726]     if (TRUE) {
[11:00:43.726]         base::sink(type = "output", split = FALSE)
[11:00:43.726]         if (TRUE) {
[11:00:43.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.726]         }
[11:00:43.726]         else {
[11:00:43.726]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.726]         }
[11:00:43.726]         base::close(...future.stdout)
[11:00:43.726]         ...future.stdout <- NULL
[11:00:43.726]     }
[11:00:43.726]     ...future.result$conditions <- ...future.conditions
[11:00:43.726]     ...future.result$finished <- base::Sys.time()
[11:00:43.726]     ...future.result
[11:00:43.726] }
[11:00:43.777] MultisessionFuture started
[11:00:43.777] result() for ClusterFuture ...
[11:00:43.778] receiveMessageFromWorker() for ClusterFuture ...
[11:00:43.778] - Validating connection of MultisessionFuture
[11:00:43.808] - received message: FutureResult
[11:00:43.808] - Received FutureResult
[11:00:43.810] - Erased future from FutureRegistry
[11:00:43.810] result() for ClusterFuture ...
[11:00:43.811] - result already collected: FutureResult
[11:00:43.811] result() for ClusterFuture ... done
[11:00:43.811] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:43.811] result() for ClusterFuture ... done
[11:00:43.811] result() for ClusterFuture ...
[11:00:43.811] - result already collected: FutureResult
[11:00:43.811] result() for ClusterFuture ... done
[11:00:43.811] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:00:43.811] plan(): nbrOfWorkers() = 2
[11:00:43.812] getGlobalsAndPackages() ...
[11:00:43.812] Searching for globals...
[11:00:43.813] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘stop’
[11:00:43.813] Searching for globals ... DONE
[11:00:43.813] Resolving globals: FALSE
[11:00:43.813] 
[11:00:43.814] 
[11:00:43.814] getGlobalsAndPackages() ... DONE
[11:00:43.814] run() for ‘Future’ ...
[11:00:43.814] - state: ‘created’
[11:00:43.814] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:43.827] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:43.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:43.827]   - Field: ‘node’
[11:00:43.827]   - Field: ‘label’
[11:00:43.827]   - Field: ‘local’
[11:00:43.827]   - Field: ‘owner’
[11:00:43.827]   - Field: ‘envir’
[11:00:43.827]   - Field: ‘workers’
[11:00:43.827]   - Field: ‘packages’
[11:00:43.827]   - Field: ‘gc’
[11:00:43.828]   - Field: ‘conditions’
[11:00:43.828]   - Field: ‘persistent’
[11:00:43.828]   - Field: ‘expr’
[11:00:43.828]   - Field: ‘uuid’
[11:00:43.828]   - Field: ‘seed’
[11:00:43.828]   - Field: ‘version’
[11:00:43.828]   - Field: ‘result’
[11:00:43.828]   - Field: ‘asynchronous’
[11:00:43.828]   - Field: ‘calls’
[11:00:43.828]   - Field: ‘globals’
[11:00:43.828]   - Field: ‘stdout’
[11:00:43.828]   - Field: ‘earlySignal’
[11:00:43.829]   - Field: ‘lazy’
[11:00:43.829]   - Field: ‘state’
[11:00:43.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:43.829] - Launch lazy future ...
[11:00:43.829] Packages needed by the future expression (n = 0): <none>
[11:00:43.829] Packages needed by future strategies (n = 0): <none>
[11:00:43.830] {
[11:00:43.830]     {
[11:00:43.830]         {
[11:00:43.830]             ...future.startTime <- base::Sys.time()
[11:00:43.830]             {
[11:00:43.830]                 {
[11:00:43.830]                   {
[11:00:43.830]                     {
[11:00:43.830]                       base::local({
[11:00:43.830]                         has_future <- base::requireNamespace("future", 
[11:00:43.830]                           quietly = TRUE)
[11:00:43.830]                         if (has_future) {
[11:00:43.830]                           ns <- base::getNamespace("future")
[11:00:43.830]                           version <- ns[[".package"]][["version"]]
[11:00:43.830]                           if (is.null(version)) 
[11:00:43.830]                             version <- utils::packageVersion("future")
[11:00:43.830]                         }
[11:00:43.830]                         else {
[11:00:43.830]                           version <- NULL
[11:00:43.830]                         }
[11:00:43.830]                         if (!has_future || version < "1.8.0") {
[11:00:43.830]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:43.830]                             "", base::R.version$version.string), 
[11:00:43.830]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:43.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:43.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:43.830]                               "release", "version")], collapse = " "), 
[11:00:43.830]                             hostname = base::Sys.info()[["nodename"]])
[11:00:43.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:43.830]                             info)
[11:00:43.830]                           info <- base::paste(info, collapse = "; ")
[11:00:43.830]                           if (!has_future) {
[11:00:43.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:43.830]                               info)
[11:00:43.830]                           }
[11:00:43.830]                           else {
[11:00:43.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:43.830]                               info, version)
[11:00:43.830]                           }
[11:00:43.830]                           base::stop(msg)
[11:00:43.830]                         }
[11:00:43.830]                       })
[11:00:43.830]                     }
[11:00:43.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:43.830]                     base::options(mc.cores = 1L)
[11:00:43.830]                   }
[11:00:43.830]                   ...future.strategy.old <- future::plan("list")
[11:00:43.830]                   options(future.plan = NULL)
[11:00:43.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:43.830]                 }
[11:00:43.830]                 ...future.workdir <- getwd()
[11:00:43.830]             }
[11:00:43.830]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:43.830]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:43.830]         }
[11:00:43.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:43.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:43.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:43.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:43.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:43.830]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:43.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:43.830]             base::names(...future.oldOptions))
[11:00:43.830]     }
[11:00:43.830]     if (FALSE) {
[11:00:43.830]     }
[11:00:43.830]     else {
[11:00:43.830]         if (TRUE) {
[11:00:43.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:43.830]                 open = "w")
[11:00:43.830]         }
[11:00:43.830]         else {
[11:00:43.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:43.830]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:43.830]         }
[11:00:43.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:43.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:43.830]             base::sink(type = "output", split = FALSE)
[11:00:43.830]             base::close(...future.stdout)
[11:00:43.830]         }, add = TRUE)
[11:00:43.830]     }
[11:00:43.830]     ...future.frame <- base::sys.nframe()
[11:00:43.830]     ...future.conditions <- base::list()
[11:00:43.830]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:43.830]     if (FALSE) {
[11:00:43.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:43.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:43.830]     }
[11:00:43.830]     ...future.result <- base::tryCatch({
[11:00:43.830]         base::withCallingHandlers({
[11:00:43.830]             ...future.value <- base::withVisible(base::local({
[11:00:43.830]                 ...future.makeSendCondition <- base::local({
[11:00:43.830]                   sendCondition <- NULL
[11:00:43.830]                   function(frame = 1L) {
[11:00:43.830]                     if (is.function(sendCondition)) 
[11:00:43.830]                       return(sendCondition)
[11:00:43.830]                     ns <- getNamespace("parallel")
[11:00:43.830]                     if (exists("sendData", mode = "function", 
[11:00:43.830]                       envir = ns)) {
[11:00:43.830]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:43.830]                         envir = ns)
[11:00:43.830]                       envir <- sys.frame(frame)
[11:00:43.830]                       master <- NULL
[11:00:43.830]                       while (!identical(envir, .GlobalEnv) && 
[11:00:43.830]                         !identical(envir, emptyenv())) {
[11:00:43.830]                         if (exists("master", mode = "list", envir = envir, 
[11:00:43.830]                           inherits = FALSE)) {
[11:00:43.830]                           master <- get("master", mode = "list", 
[11:00:43.830]                             envir = envir, inherits = FALSE)
[11:00:43.830]                           if (inherits(master, c("SOCKnode", 
[11:00:43.830]                             "SOCK0node"))) {
[11:00:43.830]                             sendCondition <<- function(cond) {
[11:00:43.830]                               data <- list(type = "VALUE", value = cond, 
[11:00:43.830]                                 success = TRUE)
[11:00:43.830]                               parallel_sendData(master, data)
[11:00:43.830]                             }
[11:00:43.830]                             return(sendCondition)
[11:00:43.830]                           }
[11:00:43.830]                         }
[11:00:43.830]                         frame <- frame + 1L
[11:00:43.830]                         envir <- sys.frame(frame)
[11:00:43.830]                       }
[11:00:43.830]                     }
[11:00:43.830]                     sendCondition <<- function(cond) NULL
[11:00:43.830]                   }
[11:00:43.830]                 })
[11:00:43.830]                 withCallingHandlers({
[11:00:43.830]                   {
[11:00:43.830]                     Sys.sleep(3)
[11:00:43.830]                     42L
[11:00:43.830]                     stop("Woops")
[11:00:43.830]                   }
[11:00:43.830]                 }, immediateCondition = function(cond) {
[11:00:43.830]                   sendCondition <- ...future.makeSendCondition()
[11:00:43.830]                   sendCondition(cond)
[11:00:43.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.830]                   {
[11:00:43.830]                     inherits <- base::inherits
[11:00:43.830]                     invokeRestart <- base::invokeRestart
[11:00:43.830]                     is.null <- base::is.null
[11:00:43.830]                     muffled <- FALSE
[11:00:43.830]                     if (inherits(cond, "message")) {
[11:00:43.830]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:43.830]                       if (muffled) 
[11:00:43.830]                         invokeRestart("muffleMessage")
[11:00:43.830]                     }
[11:00:43.830]                     else if (inherits(cond, "warning")) {
[11:00:43.830]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:43.830]                       if (muffled) 
[11:00:43.830]                         invokeRestart("muffleWarning")
[11:00:43.830]                     }
[11:00:43.830]                     else if (inherits(cond, "condition")) {
[11:00:43.830]                       if (!is.null(pattern)) {
[11:00:43.830]                         computeRestarts <- base::computeRestarts
[11:00:43.830]                         grepl <- base::grepl
[11:00:43.830]                         restarts <- computeRestarts(cond)
[11:00:43.830]                         for (restart in restarts) {
[11:00:43.830]                           name <- restart$name
[11:00:43.830]                           if (is.null(name)) 
[11:00:43.830]                             next
[11:00:43.830]                           if (!grepl(pattern, name)) 
[11:00:43.830]                             next
[11:00:43.830]                           invokeRestart(restart)
[11:00:43.830]                           muffled <- TRUE
[11:00:43.830]                           break
[11:00:43.830]                         }
[11:00:43.830]                       }
[11:00:43.830]                     }
[11:00:43.830]                     invisible(muffled)
[11:00:43.830]                   }
[11:00:43.830]                   muffleCondition(cond)
[11:00:43.830]                 })
[11:00:43.830]             }))
[11:00:43.830]             future::FutureResult(value = ...future.value$value, 
[11:00:43.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.830]                   ...future.rng), globalenv = if (FALSE) 
[11:00:43.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:43.830]                     ...future.globalenv.names))
[11:00:43.830]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:43.830]         }, condition = base::local({
[11:00:43.830]             c <- base::c
[11:00:43.830]             inherits <- base::inherits
[11:00:43.830]             invokeRestart <- base::invokeRestart
[11:00:43.830]             length <- base::length
[11:00:43.830]             list <- base::list
[11:00:43.830]             seq.int <- base::seq.int
[11:00:43.830]             signalCondition <- base::signalCondition
[11:00:43.830]             sys.calls <- base::sys.calls
[11:00:43.830]             `[[` <- base::`[[`
[11:00:43.830]             `+` <- base::`+`
[11:00:43.830]             `<<-` <- base::`<<-`
[11:00:43.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:43.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:43.830]                   3L)]
[11:00:43.830]             }
[11:00:43.830]             function(cond) {
[11:00:43.830]                 is_error <- inherits(cond, "error")
[11:00:43.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:43.830]                   NULL)
[11:00:43.830]                 if (is_error) {
[11:00:43.830]                   sessionInformation <- function() {
[11:00:43.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:43.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:43.830]                       search = base::search(), system = base::Sys.info())
[11:00:43.830]                   }
[11:00:43.830]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:43.830]                     cond$call), session = sessionInformation(), 
[11:00:43.830]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:43.830]                   signalCondition(cond)
[11:00:43.830]                 }
[11:00:43.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:43.830]                 "immediateCondition"))) {
[11:00:43.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:43.830]                   ...future.conditions[[length(...future.conditions) + 
[11:00:43.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:43.830]                   if (TRUE && !signal) {
[11:00:43.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.830]                     {
[11:00:43.830]                       inherits <- base::inherits
[11:00:43.830]                       invokeRestart <- base::invokeRestart
[11:00:43.830]                       is.null <- base::is.null
[11:00:43.830]                       muffled <- FALSE
[11:00:43.830]                       if (inherits(cond, "message")) {
[11:00:43.830]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.830]                         if (muffled) 
[11:00:43.830]                           invokeRestart("muffleMessage")
[11:00:43.830]                       }
[11:00:43.830]                       else if (inherits(cond, "warning")) {
[11:00:43.830]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.830]                         if (muffled) 
[11:00:43.830]                           invokeRestart("muffleWarning")
[11:00:43.830]                       }
[11:00:43.830]                       else if (inherits(cond, "condition")) {
[11:00:43.830]                         if (!is.null(pattern)) {
[11:00:43.830]                           computeRestarts <- base::computeRestarts
[11:00:43.830]                           grepl <- base::grepl
[11:00:43.830]                           restarts <- computeRestarts(cond)
[11:00:43.830]                           for (restart in restarts) {
[11:00:43.830]                             name <- restart$name
[11:00:43.830]                             if (is.null(name)) 
[11:00:43.830]                               next
[11:00:43.830]                             if (!grepl(pattern, name)) 
[11:00:43.830]                               next
[11:00:43.830]                             invokeRestart(restart)
[11:00:43.830]                             muffled <- TRUE
[11:00:43.830]                             break
[11:00:43.830]                           }
[11:00:43.830]                         }
[11:00:43.830]                       }
[11:00:43.830]                       invisible(muffled)
[11:00:43.830]                     }
[11:00:43.830]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.830]                   }
[11:00:43.830]                 }
[11:00:43.830]                 else {
[11:00:43.830]                   if (TRUE) {
[11:00:43.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:43.830]                     {
[11:00:43.830]                       inherits <- base::inherits
[11:00:43.830]                       invokeRestart <- base::invokeRestart
[11:00:43.830]                       is.null <- base::is.null
[11:00:43.830]                       muffled <- FALSE
[11:00:43.830]                       if (inherits(cond, "message")) {
[11:00:43.830]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:43.830]                         if (muffled) 
[11:00:43.830]                           invokeRestart("muffleMessage")
[11:00:43.830]                       }
[11:00:43.830]                       else if (inherits(cond, "warning")) {
[11:00:43.830]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:43.830]                         if (muffled) 
[11:00:43.830]                           invokeRestart("muffleWarning")
[11:00:43.830]                       }
[11:00:43.830]                       else if (inherits(cond, "condition")) {
[11:00:43.830]                         if (!is.null(pattern)) {
[11:00:43.830]                           computeRestarts <- base::computeRestarts
[11:00:43.830]                           grepl <- base::grepl
[11:00:43.830]                           restarts <- computeRestarts(cond)
[11:00:43.830]                           for (restart in restarts) {
[11:00:43.830]                             name <- restart$name
[11:00:43.830]                             if (is.null(name)) 
[11:00:43.830]                               next
[11:00:43.830]                             if (!grepl(pattern, name)) 
[11:00:43.830]                               next
[11:00:43.830]                             invokeRestart(restart)
[11:00:43.830]                             muffled <- TRUE
[11:00:43.830]                             break
[11:00:43.830]                           }
[11:00:43.830]                         }
[11:00:43.830]                       }
[11:00:43.830]                       invisible(muffled)
[11:00:43.830]                     }
[11:00:43.830]                     muffleCondition(cond, pattern = "^muffle")
[11:00:43.830]                   }
[11:00:43.830]                 }
[11:00:43.830]             }
[11:00:43.830]         }))
[11:00:43.830]     }, error = function(ex) {
[11:00:43.830]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:43.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:43.830]                 ...future.rng), started = ...future.startTime, 
[11:00:43.830]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:43.830]             version = "1.8"), class = "FutureResult")
[11:00:43.830]     }, finally = {
[11:00:43.830]         if (!identical(...future.workdir, getwd())) 
[11:00:43.830]             setwd(...future.workdir)
[11:00:43.830]         {
[11:00:43.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:43.830]                 ...future.oldOptions$nwarnings <- NULL
[11:00:43.830]             }
[11:00:43.830]             base::options(...future.oldOptions)
[11:00:43.830]             if (.Platform$OS.type == "windows") {
[11:00:43.830]                 old_names <- names(...future.oldEnvVars)
[11:00:43.830]                 envs <- base::Sys.getenv()
[11:00:43.830]                 names <- names(envs)
[11:00:43.830]                 common <- intersect(names, old_names)
[11:00:43.830]                 added <- setdiff(names, old_names)
[11:00:43.830]                 removed <- setdiff(old_names, names)
[11:00:43.830]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:43.830]                   envs[common]]
[11:00:43.830]                 NAMES <- toupper(changed)
[11:00:43.830]                 args <- list()
[11:00:43.830]                 for (kk in seq_along(NAMES)) {
[11:00:43.830]                   name <- changed[[kk]]
[11:00:43.830]                   NAME <- NAMES[[kk]]
[11:00:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.830]                     next
[11:00:43.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.830]                 }
[11:00:43.830]                 NAMES <- toupper(added)
[11:00:43.830]                 for (kk in seq_along(NAMES)) {
[11:00:43.830]                   name <- added[[kk]]
[11:00:43.830]                   NAME <- NAMES[[kk]]
[11:00:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.830]                     next
[11:00:43.830]                   args[[name]] <- ""
[11:00:43.830]                 }
[11:00:43.830]                 NAMES <- toupper(removed)
[11:00:43.830]                 for (kk in seq_along(NAMES)) {
[11:00:43.830]                   name <- removed[[kk]]
[11:00:43.830]                   NAME <- NAMES[[kk]]
[11:00:43.830]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:43.830]                     next
[11:00:43.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:43.830]                 }
[11:00:43.830]                 if (length(args) > 0) 
[11:00:43.830]                   base::do.call(base::Sys.setenv, args = args)
[11:00:43.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:43.830]             }
[11:00:43.830]             else {
[11:00:43.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:43.830]             }
[11:00:43.830]             {
[11:00:43.830]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:43.830]                   0L) {
[11:00:43.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:43.830]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:43.830]                   base::options(opts)
[11:00:43.830]                 }
[11:00:43.830]                 {
[11:00:43.830]                   {
[11:00:43.830]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:43.830]                     NULL
[11:00:43.830]                   }
[11:00:43.830]                   options(future.plan = NULL)
[11:00:43.830]                   if (is.na(NA_character_)) 
[11:00:43.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:43.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:43.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:43.830]                     .init = FALSE)
[11:00:43.830]                 }
[11:00:43.830]             }
[11:00:43.830]         }
[11:00:43.830]     })
[11:00:43.830]     if (TRUE) {
[11:00:43.830]         base::sink(type = "output", split = FALSE)
[11:00:43.830]         if (TRUE) {
[11:00:43.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:43.830]         }
[11:00:43.830]         else {
[11:00:43.830]             ...future.result["stdout"] <- base::list(NULL)
[11:00:43.830]         }
[11:00:43.830]         base::close(...future.stdout)
[11:00:43.830]         ...future.stdout <- NULL
[11:00:43.830]     }
[11:00:43.830]     ...future.result$conditions <- ...future.conditions
[11:00:43.830]     ...future.result$finished <- base::Sys.time()
[11:00:43.830]     ...future.result
[11:00:43.830] }
[11:00:43.833] MultisessionFuture started
[11:00:43.833] - Launch lazy future ... done
[11:00:43.833] run() for ‘MultisessionFuture’ ... done
<simpleError: No error has been caught because the future is unresolved: ‘f’>
[11:00:46.891] receiveMessageFromWorker() for ClusterFuture ...
[11:00:46.891] - Validating connection of MultisessionFuture
[11:00:46.892] - received message: FutureResult
[11:00:46.892] - Received FutureResult
[11:00:46.892] - Erased future from FutureRegistry
[11:00:46.892] result() for ClusterFuture ...
[11:00:46.892] - result already collected: FutureResult
[11:00:46.892] result() for ClusterFuture ... done
[11:00:46.892] signalConditions() ...
[11:00:46.892]  - include = ‘immediateCondition’
[11:00:46.893]  - exclude = 
[11:00:46.893]  - resignal = FALSE
[11:00:46.893]  - Number of conditions: 1
[11:00:46.893] signalConditions() ... done
[11:00:46.893] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:46.893] A MultisessionFuture was resolved (result was not collected)
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    Sys.sleep(3)
    42L
    stop("Woops")
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 9ac25677-015e-0991-5bd8-178942918a8a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
> 
> message("*** backtrace( ) - exceptions ... DONE")
*** backtrace( ) - exceptions ... DONE
> 
> 
> message("*** backtrace( ) ... DONE")
*** backtrace( ) ... DONE
> 
> source("incl/end.R")
[11:00:46.895] plan(): Setting new future strategy stack:
[11:00:46.895] List of future strategies:
[11:00:46.895] 1. FutureStrategy:
[11:00:46.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:46.895]    - tweaked: FALSE
[11:00:46.895]    - call: future::plan(oplan)
[11:00:46.896] plan(): nbrOfWorkers() = 1
> 
