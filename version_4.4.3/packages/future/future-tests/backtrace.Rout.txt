
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:20:33.107] plan(): Setting new future strategy stack:
[10:20:33.107] List of future strategies:
[10:20:33.107] 1. sequential:
[10:20:33.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.107]    - tweaked: FALSE
[10:20:33.107]    - call: future::plan("sequential")
[10:20:33.122] plan(): nbrOfWorkers() = 1
> 
> message("*** backtrace( ) ...")
*** backtrace( ) ...
> 
> message("*** backtrace( ) - explicit future ...")
*** backtrace( ) - explicit future ...
> 
> f <- future({ 42L; stop("Woops") })
[10:20:33.137] getGlobalsAndPackages() ...
[10:20:33.137] Searching for globals...
[10:20:33.143] - globals found: [2] ‘{’, ‘stop’
[10:20:33.143] Searching for globals ... DONE
[10:20:33.143] Resolving globals: FALSE
[10:20:33.144] 
[10:20:33.144] 
[10:20:33.144] getGlobalsAndPackages() ... DONE
[10:20:33.145] run() for ‘Future’ ...
[10:20:33.145] - state: ‘created’
[10:20:33.145] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.145] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.145]   - Field: ‘label’
[10:20:33.146]   - Field: ‘local’
[10:20:33.146]   - Field: ‘owner’
[10:20:33.146]   - Field: ‘envir’
[10:20:33.146]   - Field: ‘packages’
[10:20:33.146]   - Field: ‘gc’
[10:20:33.146]   - Field: ‘conditions’
[10:20:33.146]   - Field: ‘expr’
[10:20:33.146]   - Field: ‘uuid’
[10:20:33.146]   - Field: ‘seed’
[10:20:33.146]   - Field: ‘version’
[10:20:33.146]   - Field: ‘result’
[10:20:33.146]   - Field: ‘asynchronous’
[10:20:33.147]   - Field: ‘calls’
[10:20:33.147]   - Field: ‘globals’
[10:20:33.147]   - Field: ‘stdout’
[10:20:33.147]   - Field: ‘earlySignal’
[10:20:33.147]   - Field: ‘lazy’
[10:20:33.147]   - Field: ‘state’
[10:20:33.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.147] - Launch lazy future ...
[10:20:33.148] Packages needed by the future expression (n = 0): <none>
[10:20:33.148] Packages needed by future strategies (n = 0): <none>
[10:20:33.149] {
[10:20:33.149]     {
[10:20:33.149]         {
[10:20:33.149]             ...future.startTime <- base::Sys.time()
[10:20:33.149]             {
[10:20:33.149]                 {
[10:20:33.149]                   {
[10:20:33.149]                     base::local({
[10:20:33.149]                       has_future <- base::requireNamespace("future", 
[10:20:33.149]                         quietly = TRUE)
[10:20:33.149]                       if (has_future) {
[10:20:33.149]                         ns <- base::getNamespace("future")
[10:20:33.149]                         version <- ns[[".package"]][["version"]]
[10:20:33.149]                         if (is.null(version)) 
[10:20:33.149]                           version <- utils::packageVersion("future")
[10:20:33.149]                       }
[10:20:33.149]                       else {
[10:20:33.149]                         version <- NULL
[10:20:33.149]                       }
[10:20:33.149]                       if (!has_future || version < "1.8.0") {
[10:20:33.149]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.149]                           "", base::R.version$version.string), 
[10:20:33.149]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.149]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.149]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.149]                             "release", "version")], collapse = " "), 
[10:20:33.149]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.149]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.149]                           info)
[10:20:33.149]                         info <- base::paste(info, collapse = "; ")
[10:20:33.149]                         if (!has_future) {
[10:20:33.149]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.149]                             info)
[10:20:33.149]                         }
[10:20:33.149]                         else {
[10:20:33.149]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.149]                             info, version)
[10:20:33.149]                         }
[10:20:33.149]                         base::stop(msg)
[10:20:33.149]                       }
[10:20:33.149]                     })
[10:20:33.149]                   }
[10:20:33.149]                   ...future.strategy.old <- future::plan("list")
[10:20:33.149]                   options(future.plan = NULL)
[10:20:33.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.149]                 }
[10:20:33.149]                 ...future.workdir <- getwd()
[10:20:33.149]             }
[10:20:33.149]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.149]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.149]         }
[10:20:33.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.149]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.149]             base::names(...future.oldOptions))
[10:20:33.149]     }
[10:20:33.149]     if (FALSE) {
[10:20:33.149]     }
[10:20:33.149]     else {
[10:20:33.149]         if (TRUE) {
[10:20:33.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.149]                 open = "w")
[10:20:33.149]         }
[10:20:33.149]         else {
[10:20:33.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.149]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.149]         }
[10:20:33.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.149]             base::sink(type = "output", split = FALSE)
[10:20:33.149]             base::close(...future.stdout)
[10:20:33.149]         }, add = TRUE)
[10:20:33.149]     }
[10:20:33.149]     ...future.frame <- base::sys.nframe()
[10:20:33.149]     ...future.conditions <- base::list()
[10:20:33.149]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.149]     if (FALSE) {
[10:20:33.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.149]     }
[10:20:33.149]     ...future.result <- base::tryCatch({
[10:20:33.149]         base::withCallingHandlers({
[10:20:33.149]             ...future.value <- base::withVisible(base::local({
[10:20:33.149]                 42L
[10:20:33.149]                 stop("Woops")
[10:20:33.149]             }))
[10:20:33.149]             future::FutureResult(value = ...future.value$value, 
[10:20:33.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.149]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.149]                     ...future.globalenv.names))
[10:20:33.149]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.149]         }, condition = base::local({
[10:20:33.149]             c <- base::c
[10:20:33.149]             inherits <- base::inherits
[10:20:33.149]             invokeRestart <- base::invokeRestart
[10:20:33.149]             length <- base::length
[10:20:33.149]             list <- base::list
[10:20:33.149]             seq.int <- base::seq.int
[10:20:33.149]             signalCondition <- base::signalCondition
[10:20:33.149]             sys.calls <- base::sys.calls
[10:20:33.149]             `[[` <- base::`[[`
[10:20:33.149]             `+` <- base::`+`
[10:20:33.149]             `<<-` <- base::`<<-`
[10:20:33.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.149]                   3L)]
[10:20:33.149]             }
[10:20:33.149]             function(cond) {
[10:20:33.149]                 is_error <- inherits(cond, "error")
[10:20:33.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.149]                   NULL)
[10:20:33.149]                 if (is_error) {
[10:20:33.149]                   sessionInformation <- function() {
[10:20:33.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.149]                       search = base::search(), system = base::Sys.info())
[10:20:33.149]                   }
[10:20:33.149]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.149]                     cond$call), session = sessionInformation(), 
[10:20:33.149]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.149]                   signalCondition(cond)
[10:20:33.149]                 }
[10:20:33.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.149]                 "immediateCondition"))) {
[10:20:33.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.149]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.149]                   if (TRUE && !signal) {
[10:20:33.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.149]                     {
[10:20:33.149]                       inherits <- base::inherits
[10:20:33.149]                       invokeRestart <- base::invokeRestart
[10:20:33.149]                       is.null <- base::is.null
[10:20:33.149]                       muffled <- FALSE
[10:20:33.149]                       if (inherits(cond, "message")) {
[10:20:33.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.149]                         if (muffled) 
[10:20:33.149]                           invokeRestart("muffleMessage")
[10:20:33.149]                       }
[10:20:33.149]                       else if (inherits(cond, "warning")) {
[10:20:33.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.149]                         if (muffled) 
[10:20:33.149]                           invokeRestart("muffleWarning")
[10:20:33.149]                       }
[10:20:33.149]                       else if (inherits(cond, "condition")) {
[10:20:33.149]                         if (!is.null(pattern)) {
[10:20:33.149]                           computeRestarts <- base::computeRestarts
[10:20:33.149]                           grepl <- base::grepl
[10:20:33.149]                           restarts <- computeRestarts(cond)
[10:20:33.149]                           for (restart in restarts) {
[10:20:33.149]                             name <- restart$name
[10:20:33.149]                             if (is.null(name)) 
[10:20:33.149]                               next
[10:20:33.149]                             if (!grepl(pattern, name)) 
[10:20:33.149]                               next
[10:20:33.149]                             invokeRestart(restart)
[10:20:33.149]                             muffled <- TRUE
[10:20:33.149]                             break
[10:20:33.149]                           }
[10:20:33.149]                         }
[10:20:33.149]                       }
[10:20:33.149]                       invisible(muffled)
[10:20:33.149]                     }
[10:20:33.149]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.149]                   }
[10:20:33.149]                 }
[10:20:33.149]                 else {
[10:20:33.149]                   if (TRUE) {
[10:20:33.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.149]                     {
[10:20:33.149]                       inherits <- base::inherits
[10:20:33.149]                       invokeRestart <- base::invokeRestart
[10:20:33.149]                       is.null <- base::is.null
[10:20:33.149]                       muffled <- FALSE
[10:20:33.149]                       if (inherits(cond, "message")) {
[10:20:33.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.149]                         if (muffled) 
[10:20:33.149]                           invokeRestart("muffleMessage")
[10:20:33.149]                       }
[10:20:33.149]                       else if (inherits(cond, "warning")) {
[10:20:33.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.149]                         if (muffled) 
[10:20:33.149]                           invokeRestart("muffleWarning")
[10:20:33.149]                       }
[10:20:33.149]                       else if (inherits(cond, "condition")) {
[10:20:33.149]                         if (!is.null(pattern)) {
[10:20:33.149]                           computeRestarts <- base::computeRestarts
[10:20:33.149]                           grepl <- base::grepl
[10:20:33.149]                           restarts <- computeRestarts(cond)
[10:20:33.149]                           for (restart in restarts) {
[10:20:33.149]                             name <- restart$name
[10:20:33.149]                             if (is.null(name)) 
[10:20:33.149]                               next
[10:20:33.149]                             if (!grepl(pattern, name)) 
[10:20:33.149]                               next
[10:20:33.149]                             invokeRestart(restart)
[10:20:33.149]                             muffled <- TRUE
[10:20:33.149]                             break
[10:20:33.149]                           }
[10:20:33.149]                         }
[10:20:33.149]                       }
[10:20:33.149]                       invisible(muffled)
[10:20:33.149]                     }
[10:20:33.149]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.149]                   }
[10:20:33.149]                 }
[10:20:33.149]             }
[10:20:33.149]         }))
[10:20:33.149]     }, error = function(ex) {
[10:20:33.149]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.149]                 ...future.rng), started = ...future.startTime, 
[10:20:33.149]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.149]             version = "1.8"), class = "FutureResult")
[10:20:33.149]     }, finally = {
[10:20:33.149]         if (!identical(...future.workdir, getwd())) 
[10:20:33.149]             setwd(...future.workdir)
[10:20:33.149]         {
[10:20:33.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.149]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.149]             }
[10:20:33.149]             base::options(...future.oldOptions)
[10:20:33.149]             if (.Platform$OS.type == "windows") {
[10:20:33.149]                 old_names <- names(...future.oldEnvVars)
[10:20:33.149]                 envs <- base::Sys.getenv()
[10:20:33.149]                 names <- names(envs)
[10:20:33.149]                 common <- intersect(names, old_names)
[10:20:33.149]                 added <- setdiff(names, old_names)
[10:20:33.149]                 removed <- setdiff(old_names, names)
[10:20:33.149]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.149]                   envs[common]]
[10:20:33.149]                 NAMES <- toupper(changed)
[10:20:33.149]                 args <- list()
[10:20:33.149]                 for (kk in seq_along(NAMES)) {
[10:20:33.149]                   name <- changed[[kk]]
[10:20:33.149]                   NAME <- NAMES[[kk]]
[10:20:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.149]                     next
[10:20:33.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.149]                 }
[10:20:33.149]                 NAMES <- toupper(added)
[10:20:33.149]                 for (kk in seq_along(NAMES)) {
[10:20:33.149]                   name <- added[[kk]]
[10:20:33.149]                   NAME <- NAMES[[kk]]
[10:20:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.149]                     next
[10:20:33.149]                   args[[name]] <- ""
[10:20:33.149]                 }
[10:20:33.149]                 NAMES <- toupper(removed)
[10:20:33.149]                 for (kk in seq_along(NAMES)) {
[10:20:33.149]                   name <- removed[[kk]]
[10:20:33.149]                   NAME <- NAMES[[kk]]
[10:20:33.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.149]                     next
[10:20:33.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.149]                 }
[10:20:33.149]                 if (length(args) > 0) 
[10:20:33.149]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.149]             }
[10:20:33.149]             else {
[10:20:33.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.149]             }
[10:20:33.149]             {
[10:20:33.149]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.149]                   0L) {
[10:20:33.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.149]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.149]                   base::options(opts)
[10:20:33.149]                 }
[10:20:33.149]                 {
[10:20:33.149]                   {
[10:20:33.149]                     NULL
[10:20:33.149]                     RNGkind("Mersenne-Twister")
[10:20:33.149]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.149]                       inherits = FALSE)
[10:20:33.149]                   }
[10:20:33.149]                   options(future.plan = NULL)
[10:20:33.149]                   if (is.na(NA_character_)) 
[10:20:33.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.149]                     .init = FALSE)
[10:20:33.149]                 }
[10:20:33.149]             }
[10:20:33.149]         }
[10:20:33.149]     })
[10:20:33.149]     if (TRUE) {
[10:20:33.149]         base::sink(type = "output", split = FALSE)
[10:20:33.149]         if (TRUE) {
[10:20:33.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.149]         }
[10:20:33.149]         else {
[10:20:33.149]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.149]         }
[10:20:33.149]         base::close(...future.stdout)
[10:20:33.149]         ...future.stdout <- NULL
[10:20:33.149]     }
[10:20:33.149]     ...future.result$conditions <- ...future.conditions
[10:20:33.149]     ...future.result$finished <- base::Sys.time()
[10:20:33.149]     ...future.result
[10:20:33.149] }
[10:20:33.151] plan(): Setting new future strategy stack:
[10:20:33.151] List of future strategies:
[10:20:33.151] 1. sequential:
[10:20:33.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.151]    - tweaked: FALSE
[10:20:33.151]    - call: NULL
[10:20:33.151] plan(): nbrOfWorkers() = 1
[10:20:33.152] plan(): Setting new future strategy stack:
[10:20:33.152] List of future strategies:
[10:20:33.152] 1. sequential:
[10:20:33.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.152]    - tweaked: FALSE
[10:20:33.152]    - call: future::plan("sequential")
[10:20:33.153] plan(): nbrOfWorkers() = 1
[10:20:33.153] SequentialFuture started (and completed)
[10:20:33.153] signalConditions() ...
[10:20:33.153]  - include = ‘immediateCondition’
[10:20:33.153]  - exclude = 
[10:20:33.153]  - resignal = FALSE
[10:20:33.153]  - Number of conditions: 1
[10:20:33.154] signalConditions() ... done
[10:20:33.154] - Launch lazy future ... done
[10:20:33.154] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[10:20:33.154] signalConditions() ...
[10:20:33.154]  - include = ‘immediateCondition’
[10:20:33.154]  - exclude = 
[10:20:33.154]  - resignal = FALSE
[10:20:33.154]  - Number of conditions: 1
[10:20:33.155] signalConditions() ... done
> print(v)
<simpleError in eval(quote({    42L    stop("Woops")}), new.env()): Woops>
> calls <- backtrace(f)
[10:20:33.155] resolved() for ‘SequentialFuture’ ...
[10:20:33.156] - state: ‘finished’
[10:20:33.156] - run: TRUE
[10:20:33.156] - result: ‘FutureResult’
[10:20:33.156] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - explicit future ... DONE")
*** backtrace( ) - explicit future ... DONE
> 
> 
> message("*** backtrace( ) - implicit future ...")
*** backtrace( ) - implicit future ...
> 
> v %<-% { 42L; stop("Woops") }
[10:20:33.156] getGlobalsAndPackages() ...
[10:20:33.157] Searching for globals...
[10:20:33.157] - globals found: [2] ‘{’, ‘stop’
[10:20:33.158] Searching for globals ... DONE
[10:20:33.158] Resolving globals: FALSE
[10:20:33.158] 
[10:20:33.158] 
[10:20:33.158] getGlobalsAndPackages() ... DONE
[10:20:33.158] run() for ‘Future’ ...
[10:20:33.158] - state: ‘created’
[10:20:33.159] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.159] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.159]   - Field: ‘label’
[10:20:33.159]   - Field: ‘local’
[10:20:33.159]   - Field: ‘owner’
[10:20:33.159]   - Field: ‘envir’
[10:20:33.159]   - Field: ‘packages’
[10:20:33.159]   - Field: ‘gc’
[10:20:33.160]   - Field: ‘conditions’
[10:20:33.160]   - Field: ‘expr’
[10:20:33.160]   - Field: ‘uuid’
[10:20:33.160]   - Field: ‘seed’
[10:20:33.160]   - Field: ‘version’
[10:20:33.160]   - Field: ‘result’
[10:20:33.160]   - Field: ‘asynchronous’
[10:20:33.160]   - Field: ‘calls’
[10:20:33.160]   - Field: ‘globals’
[10:20:33.160]   - Field: ‘stdout’
[10:20:33.160]   - Field: ‘earlySignal’
[10:20:33.161]   - Field: ‘lazy’
[10:20:33.161]   - Field: ‘state’
[10:20:33.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.161] - Launch lazy future ...
[10:20:33.161] Packages needed by the future expression (n = 0): <none>
[10:20:33.161] Packages needed by future strategies (n = 0): <none>
[10:20:33.161] {
[10:20:33.161]     {
[10:20:33.161]         {
[10:20:33.161]             ...future.startTime <- base::Sys.time()
[10:20:33.161]             {
[10:20:33.161]                 {
[10:20:33.161]                   {
[10:20:33.161]                     base::local({
[10:20:33.161]                       has_future <- base::requireNamespace("future", 
[10:20:33.161]                         quietly = TRUE)
[10:20:33.161]                       if (has_future) {
[10:20:33.161]                         ns <- base::getNamespace("future")
[10:20:33.161]                         version <- ns[[".package"]][["version"]]
[10:20:33.161]                         if (is.null(version)) 
[10:20:33.161]                           version <- utils::packageVersion("future")
[10:20:33.161]                       }
[10:20:33.161]                       else {
[10:20:33.161]                         version <- NULL
[10:20:33.161]                       }
[10:20:33.161]                       if (!has_future || version < "1.8.0") {
[10:20:33.161]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.161]                           "", base::R.version$version.string), 
[10:20:33.161]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.161]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.161]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.161]                             "release", "version")], collapse = " "), 
[10:20:33.161]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.161]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.161]                           info)
[10:20:33.161]                         info <- base::paste(info, collapse = "; ")
[10:20:33.161]                         if (!has_future) {
[10:20:33.161]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.161]                             info)
[10:20:33.161]                         }
[10:20:33.161]                         else {
[10:20:33.161]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.161]                             info, version)
[10:20:33.161]                         }
[10:20:33.161]                         base::stop(msg)
[10:20:33.161]                       }
[10:20:33.161]                     })
[10:20:33.161]                   }
[10:20:33.161]                   ...future.strategy.old <- future::plan("list")
[10:20:33.161]                   options(future.plan = NULL)
[10:20:33.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.161]                 }
[10:20:33.161]                 ...future.workdir <- getwd()
[10:20:33.161]             }
[10:20:33.161]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.161]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.161]         }
[10:20:33.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.161]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.161]             base::names(...future.oldOptions))
[10:20:33.161]     }
[10:20:33.161]     if (FALSE) {
[10:20:33.161]     }
[10:20:33.161]     else {
[10:20:33.161]         if (TRUE) {
[10:20:33.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.161]                 open = "w")
[10:20:33.161]         }
[10:20:33.161]         else {
[10:20:33.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.161]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.161]         }
[10:20:33.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.161]             base::sink(type = "output", split = FALSE)
[10:20:33.161]             base::close(...future.stdout)
[10:20:33.161]         }, add = TRUE)
[10:20:33.161]     }
[10:20:33.161]     ...future.frame <- base::sys.nframe()
[10:20:33.161]     ...future.conditions <- base::list()
[10:20:33.161]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.161]     if (FALSE) {
[10:20:33.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.161]     }
[10:20:33.161]     ...future.result <- base::tryCatch({
[10:20:33.161]         base::withCallingHandlers({
[10:20:33.161]             ...future.value <- base::withVisible(base::local({
[10:20:33.161]                 42L
[10:20:33.161]                 stop("Woops")
[10:20:33.161]             }))
[10:20:33.161]             future::FutureResult(value = ...future.value$value, 
[10:20:33.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.161]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.161]                     ...future.globalenv.names))
[10:20:33.161]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.161]         }, condition = base::local({
[10:20:33.161]             c <- base::c
[10:20:33.161]             inherits <- base::inherits
[10:20:33.161]             invokeRestart <- base::invokeRestart
[10:20:33.161]             length <- base::length
[10:20:33.161]             list <- base::list
[10:20:33.161]             seq.int <- base::seq.int
[10:20:33.161]             signalCondition <- base::signalCondition
[10:20:33.161]             sys.calls <- base::sys.calls
[10:20:33.161]             `[[` <- base::`[[`
[10:20:33.161]             `+` <- base::`+`
[10:20:33.161]             `<<-` <- base::`<<-`
[10:20:33.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.161]                   3L)]
[10:20:33.161]             }
[10:20:33.161]             function(cond) {
[10:20:33.161]                 is_error <- inherits(cond, "error")
[10:20:33.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.161]                   NULL)
[10:20:33.161]                 if (is_error) {
[10:20:33.161]                   sessionInformation <- function() {
[10:20:33.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.161]                       search = base::search(), system = base::Sys.info())
[10:20:33.161]                   }
[10:20:33.161]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.161]                     cond$call), session = sessionInformation(), 
[10:20:33.161]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.161]                   signalCondition(cond)
[10:20:33.161]                 }
[10:20:33.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.161]                 "immediateCondition"))) {
[10:20:33.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.161]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.161]                   if (TRUE && !signal) {
[10:20:33.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.161]                     {
[10:20:33.161]                       inherits <- base::inherits
[10:20:33.161]                       invokeRestart <- base::invokeRestart
[10:20:33.161]                       is.null <- base::is.null
[10:20:33.161]                       muffled <- FALSE
[10:20:33.161]                       if (inherits(cond, "message")) {
[10:20:33.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.161]                         if (muffled) 
[10:20:33.161]                           invokeRestart("muffleMessage")
[10:20:33.161]                       }
[10:20:33.161]                       else if (inherits(cond, "warning")) {
[10:20:33.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.161]                         if (muffled) 
[10:20:33.161]                           invokeRestart("muffleWarning")
[10:20:33.161]                       }
[10:20:33.161]                       else if (inherits(cond, "condition")) {
[10:20:33.161]                         if (!is.null(pattern)) {
[10:20:33.161]                           computeRestarts <- base::computeRestarts
[10:20:33.161]                           grepl <- base::grepl
[10:20:33.161]                           restarts <- computeRestarts(cond)
[10:20:33.161]                           for (restart in restarts) {
[10:20:33.161]                             name <- restart$name
[10:20:33.161]                             if (is.null(name)) 
[10:20:33.161]                               next
[10:20:33.161]                             if (!grepl(pattern, name)) 
[10:20:33.161]                               next
[10:20:33.161]                             invokeRestart(restart)
[10:20:33.161]                             muffled <- TRUE
[10:20:33.161]                             break
[10:20:33.161]                           }
[10:20:33.161]                         }
[10:20:33.161]                       }
[10:20:33.161]                       invisible(muffled)
[10:20:33.161]                     }
[10:20:33.161]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.161]                   }
[10:20:33.161]                 }
[10:20:33.161]                 else {
[10:20:33.161]                   if (TRUE) {
[10:20:33.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.161]                     {
[10:20:33.161]                       inherits <- base::inherits
[10:20:33.161]                       invokeRestart <- base::invokeRestart
[10:20:33.161]                       is.null <- base::is.null
[10:20:33.161]                       muffled <- FALSE
[10:20:33.161]                       if (inherits(cond, "message")) {
[10:20:33.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.161]                         if (muffled) 
[10:20:33.161]                           invokeRestart("muffleMessage")
[10:20:33.161]                       }
[10:20:33.161]                       else if (inherits(cond, "warning")) {
[10:20:33.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.161]                         if (muffled) 
[10:20:33.161]                           invokeRestart("muffleWarning")
[10:20:33.161]                       }
[10:20:33.161]                       else if (inherits(cond, "condition")) {
[10:20:33.161]                         if (!is.null(pattern)) {
[10:20:33.161]                           computeRestarts <- base::computeRestarts
[10:20:33.161]                           grepl <- base::grepl
[10:20:33.161]                           restarts <- computeRestarts(cond)
[10:20:33.161]                           for (restart in restarts) {
[10:20:33.161]                             name <- restart$name
[10:20:33.161]                             if (is.null(name)) 
[10:20:33.161]                               next
[10:20:33.161]                             if (!grepl(pattern, name)) 
[10:20:33.161]                               next
[10:20:33.161]                             invokeRestart(restart)
[10:20:33.161]                             muffled <- TRUE
[10:20:33.161]                             break
[10:20:33.161]                           }
[10:20:33.161]                         }
[10:20:33.161]                       }
[10:20:33.161]                       invisible(muffled)
[10:20:33.161]                     }
[10:20:33.161]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.161]                   }
[10:20:33.161]                 }
[10:20:33.161]             }
[10:20:33.161]         }))
[10:20:33.161]     }, error = function(ex) {
[10:20:33.161]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.161]                 ...future.rng), started = ...future.startTime, 
[10:20:33.161]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.161]             version = "1.8"), class = "FutureResult")
[10:20:33.161]     }, finally = {
[10:20:33.161]         if (!identical(...future.workdir, getwd())) 
[10:20:33.161]             setwd(...future.workdir)
[10:20:33.161]         {
[10:20:33.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.161]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.161]             }
[10:20:33.161]             base::options(...future.oldOptions)
[10:20:33.161]             if (.Platform$OS.type == "windows") {
[10:20:33.161]                 old_names <- names(...future.oldEnvVars)
[10:20:33.161]                 envs <- base::Sys.getenv()
[10:20:33.161]                 names <- names(envs)
[10:20:33.161]                 common <- intersect(names, old_names)
[10:20:33.161]                 added <- setdiff(names, old_names)
[10:20:33.161]                 removed <- setdiff(old_names, names)
[10:20:33.161]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.161]                   envs[common]]
[10:20:33.161]                 NAMES <- toupper(changed)
[10:20:33.161]                 args <- list()
[10:20:33.161]                 for (kk in seq_along(NAMES)) {
[10:20:33.161]                   name <- changed[[kk]]
[10:20:33.161]                   NAME <- NAMES[[kk]]
[10:20:33.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.161]                     next
[10:20:33.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.161]                 }
[10:20:33.161]                 NAMES <- toupper(added)
[10:20:33.161]                 for (kk in seq_along(NAMES)) {
[10:20:33.161]                   name <- added[[kk]]
[10:20:33.161]                   NAME <- NAMES[[kk]]
[10:20:33.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.161]                     next
[10:20:33.161]                   args[[name]] <- ""
[10:20:33.161]                 }
[10:20:33.161]                 NAMES <- toupper(removed)
[10:20:33.161]                 for (kk in seq_along(NAMES)) {
[10:20:33.161]                   name <- removed[[kk]]
[10:20:33.161]                   NAME <- NAMES[[kk]]
[10:20:33.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.161]                     next
[10:20:33.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.161]                 }
[10:20:33.161]                 if (length(args) > 0) 
[10:20:33.161]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.161]             }
[10:20:33.161]             else {
[10:20:33.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.161]             }
[10:20:33.161]             {
[10:20:33.161]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.161]                   0L) {
[10:20:33.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.161]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.161]                   base::options(opts)
[10:20:33.161]                 }
[10:20:33.161]                 {
[10:20:33.161]                   {
[10:20:33.161]                     NULL
[10:20:33.161]                     RNGkind("Mersenne-Twister")
[10:20:33.161]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.161]                       inherits = FALSE)
[10:20:33.161]                   }
[10:20:33.161]                   options(future.plan = NULL)
[10:20:33.161]                   if (is.na(NA_character_)) 
[10:20:33.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.161]                     .init = FALSE)
[10:20:33.161]                 }
[10:20:33.161]             }
[10:20:33.161]         }
[10:20:33.161]     })
[10:20:33.161]     if (TRUE) {
[10:20:33.161]         base::sink(type = "output", split = FALSE)
[10:20:33.161]         if (TRUE) {
[10:20:33.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.161]         }
[10:20:33.161]         else {
[10:20:33.161]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.161]         }
[10:20:33.161]         base::close(...future.stdout)
[10:20:33.161]         ...future.stdout <- NULL
[10:20:33.161]     }
[10:20:33.161]     ...future.result$conditions <- ...future.conditions
[10:20:33.161]     ...future.result$finished <- base::Sys.time()
[10:20:33.161]     ...future.result
[10:20:33.161] }
[10:20:33.163] plan(): Setting new future strategy stack:
[10:20:33.163] List of future strategies:
[10:20:33.163] 1. sequential:
[10:20:33.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.163]    - tweaked: FALSE
[10:20:33.163]    - call: NULL
[10:20:33.164] plan(): nbrOfWorkers() = 1
[10:20:33.165] plan(): Setting new future strategy stack:
[10:20:33.165] List of future strategies:
[10:20:33.165] 1. sequential:
[10:20:33.165]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.165]    - tweaked: FALSE
[10:20:33.165]    - call: future::plan("sequential")
[10:20:33.165] plan(): nbrOfWorkers() = 1
[10:20:33.165] SequentialFuture started (and completed)
[10:20:33.166] signalConditions() ...
[10:20:33.166]  - include = ‘immediateCondition’
[10:20:33.166]  - exclude = 
[10:20:33.166]  - resignal = FALSE
[10:20:33.166]  - Number of conditions: 1
[10:20:33.166] signalConditions() ... done
[10:20:33.166] - Launch lazy future ... done
[10:20:33.166] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(v)
[10:20:33.167] resolved() for ‘SequentialFuture’ ...
[10:20:33.167] - state: ‘finished’
[10:20:33.167] - run: TRUE
[10:20:33.167] - result: ‘FutureResult’
[10:20:33.167] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
v %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - implicit future ... DONE")
*** backtrace( ) - implicit future ... DONE
> 
> 
> message("*** backtrace( ) - subsetting ...")
*** backtrace( ) - subsetting ...
> 
> env <- new.env()
> env[["a"]] %<-% { 42L; stop("Woops") }
[10:20:33.170] getGlobalsAndPackages() ...
[10:20:33.170] Searching for globals...
[10:20:33.171] - globals found: [2] ‘{’, ‘stop’
[10:20:33.171] Searching for globals ... DONE
[10:20:33.171] Resolving globals: FALSE
[10:20:33.172] 
[10:20:33.172] 
[10:20:33.172] getGlobalsAndPackages() ... DONE
[10:20:33.172] run() for ‘Future’ ...
[10:20:33.172] - state: ‘created’
[10:20:33.172] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.172] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.173]   - Field: ‘label’
[10:20:33.173]   - Field: ‘local’
[10:20:33.173]   - Field: ‘owner’
[10:20:33.173]   - Field: ‘envir’
[10:20:33.173]   - Field: ‘packages’
[10:20:33.173]   - Field: ‘gc’
[10:20:33.173]   - Field: ‘conditions’
[10:20:33.173]   - Field: ‘expr’
[10:20:33.173]   - Field: ‘uuid’
[10:20:33.173]   - Field: ‘seed’
[10:20:33.173]   - Field: ‘version’
[10:20:33.173]   - Field: ‘result’
[10:20:33.174]   - Field: ‘asynchronous’
[10:20:33.174]   - Field: ‘calls’
[10:20:33.174]   - Field: ‘globals’
[10:20:33.174]   - Field: ‘stdout’
[10:20:33.174]   - Field: ‘earlySignal’
[10:20:33.174]   - Field: ‘lazy’
[10:20:33.174]   - Field: ‘state’
[10:20:33.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.174] - Launch lazy future ...
[10:20:33.174] Packages needed by the future expression (n = 0): <none>
[10:20:33.175] Packages needed by future strategies (n = 0): <none>
[10:20:33.175] {
[10:20:33.175]     {
[10:20:33.175]         {
[10:20:33.175]             ...future.startTime <- base::Sys.time()
[10:20:33.175]             {
[10:20:33.175]                 {
[10:20:33.175]                   {
[10:20:33.175]                     base::local({
[10:20:33.175]                       has_future <- base::requireNamespace("future", 
[10:20:33.175]                         quietly = TRUE)
[10:20:33.175]                       if (has_future) {
[10:20:33.175]                         ns <- base::getNamespace("future")
[10:20:33.175]                         version <- ns[[".package"]][["version"]]
[10:20:33.175]                         if (is.null(version)) 
[10:20:33.175]                           version <- utils::packageVersion("future")
[10:20:33.175]                       }
[10:20:33.175]                       else {
[10:20:33.175]                         version <- NULL
[10:20:33.175]                       }
[10:20:33.175]                       if (!has_future || version < "1.8.0") {
[10:20:33.175]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.175]                           "", base::R.version$version.string), 
[10:20:33.175]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.175]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.175]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.175]                             "release", "version")], collapse = " "), 
[10:20:33.175]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.175]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.175]                           info)
[10:20:33.175]                         info <- base::paste(info, collapse = "; ")
[10:20:33.175]                         if (!has_future) {
[10:20:33.175]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.175]                             info)
[10:20:33.175]                         }
[10:20:33.175]                         else {
[10:20:33.175]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.175]                             info, version)
[10:20:33.175]                         }
[10:20:33.175]                         base::stop(msg)
[10:20:33.175]                       }
[10:20:33.175]                     })
[10:20:33.175]                   }
[10:20:33.175]                   ...future.strategy.old <- future::plan("list")
[10:20:33.175]                   options(future.plan = NULL)
[10:20:33.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.175]                 }
[10:20:33.175]                 ...future.workdir <- getwd()
[10:20:33.175]             }
[10:20:33.175]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.175]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.175]         }
[10:20:33.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.175]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.175]             base::names(...future.oldOptions))
[10:20:33.175]     }
[10:20:33.175]     if (FALSE) {
[10:20:33.175]     }
[10:20:33.175]     else {
[10:20:33.175]         if (TRUE) {
[10:20:33.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.175]                 open = "w")
[10:20:33.175]         }
[10:20:33.175]         else {
[10:20:33.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.175]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.175]         }
[10:20:33.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.175]             base::sink(type = "output", split = FALSE)
[10:20:33.175]             base::close(...future.stdout)
[10:20:33.175]         }, add = TRUE)
[10:20:33.175]     }
[10:20:33.175]     ...future.frame <- base::sys.nframe()
[10:20:33.175]     ...future.conditions <- base::list()
[10:20:33.175]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.175]     if (FALSE) {
[10:20:33.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.175]     }
[10:20:33.175]     ...future.result <- base::tryCatch({
[10:20:33.175]         base::withCallingHandlers({
[10:20:33.175]             ...future.value <- base::withVisible(base::local({
[10:20:33.175]                 42L
[10:20:33.175]                 stop("Woops")
[10:20:33.175]             }))
[10:20:33.175]             future::FutureResult(value = ...future.value$value, 
[10:20:33.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.175]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.175]                     ...future.globalenv.names))
[10:20:33.175]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.175]         }, condition = base::local({
[10:20:33.175]             c <- base::c
[10:20:33.175]             inherits <- base::inherits
[10:20:33.175]             invokeRestart <- base::invokeRestart
[10:20:33.175]             length <- base::length
[10:20:33.175]             list <- base::list
[10:20:33.175]             seq.int <- base::seq.int
[10:20:33.175]             signalCondition <- base::signalCondition
[10:20:33.175]             sys.calls <- base::sys.calls
[10:20:33.175]             `[[` <- base::`[[`
[10:20:33.175]             `+` <- base::`+`
[10:20:33.175]             `<<-` <- base::`<<-`
[10:20:33.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.175]                   3L)]
[10:20:33.175]             }
[10:20:33.175]             function(cond) {
[10:20:33.175]                 is_error <- inherits(cond, "error")
[10:20:33.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.175]                   NULL)
[10:20:33.175]                 if (is_error) {
[10:20:33.175]                   sessionInformation <- function() {
[10:20:33.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.175]                       search = base::search(), system = base::Sys.info())
[10:20:33.175]                   }
[10:20:33.175]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.175]                     cond$call), session = sessionInformation(), 
[10:20:33.175]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.175]                   signalCondition(cond)
[10:20:33.175]                 }
[10:20:33.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.175]                 "immediateCondition"))) {
[10:20:33.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.175]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.175]                   if (TRUE && !signal) {
[10:20:33.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.175]                     {
[10:20:33.175]                       inherits <- base::inherits
[10:20:33.175]                       invokeRestart <- base::invokeRestart
[10:20:33.175]                       is.null <- base::is.null
[10:20:33.175]                       muffled <- FALSE
[10:20:33.175]                       if (inherits(cond, "message")) {
[10:20:33.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.175]                         if (muffled) 
[10:20:33.175]                           invokeRestart("muffleMessage")
[10:20:33.175]                       }
[10:20:33.175]                       else if (inherits(cond, "warning")) {
[10:20:33.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.175]                         if (muffled) 
[10:20:33.175]                           invokeRestart("muffleWarning")
[10:20:33.175]                       }
[10:20:33.175]                       else if (inherits(cond, "condition")) {
[10:20:33.175]                         if (!is.null(pattern)) {
[10:20:33.175]                           computeRestarts <- base::computeRestarts
[10:20:33.175]                           grepl <- base::grepl
[10:20:33.175]                           restarts <- computeRestarts(cond)
[10:20:33.175]                           for (restart in restarts) {
[10:20:33.175]                             name <- restart$name
[10:20:33.175]                             if (is.null(name)) 
[10:20:33.175]                               next
[10:20:33.175]                             if (!grepl(pattern, name)) 
[10:20:33.175]                               next
[10:20:33.175]                             invokeRestart(restart)
[10:20:33.175]                             muffled <- TRUE
[10:20:33.175]                             break
[10:20:33.175]                           }
[10:20:33.175]                         }
[10:20:33.175]                       }
[10:20:33.175]                       invisible(muffled)
[10:20:33.175]                     }
[10:20:33.175]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.175]                   }
[10:20:33.175]                 }
[10:20:33.175]                 else {
[10:20:33.175]                   if (TRUE) {
[10:20:33.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.175]                     {
[10:20:33.175]                       inherits <- base::inherits
[10:20:33.175]                       invokeRestart <- base::invokeRestart
[10:20:33.175]                       is.null <- base::is.null
[10:20:33.175]                       muffled <- FALSE
[10:20:33.175]                       if (inherits(cond, "message")) {
[10:20:33.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.175]                         if (muffled) 
[10:20:33.175]                           invokeRestart("muffleMessage")
[10:20:33.175]                       }
[10:20:33.175]                       else if (inherits(cond, "warning")) {
[10:20:33.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.175]                         if (muffled) 
[10:20:33.175]                           invokeRestart("muffleWarning")
[10:20:33.175]                       }
[10:20:33.175]                       else if (inherits(cond, "condition")) {
[10:20:33.175]                         if (!is.null(pattern)) {
[10:20:33.175]                           computeRestarts <- base::computeRestarts
[10:20:33.175]                           grepl <- base::grepl
[10:20:33.175]                           restarts <- computeRestarts(cond)
[10:20:33.175]                           for (restart in restarts) {
[10:20:33.175]                             name <- restart$name
[10:20:33.175]                             if (is.null(name)) 
[10:20:33.175]                               next
[10:20:33.175]                             if (!grepl(pattern, name)) 
[10:20:33.175]                               next
[10:20:33.175]                             invokeRestart(restart)
[10:20:33.175]                             muffled <- TRUE
[10:20:33.175]                             break
[10:20:33.175]                           }
[10:20:33.175]                         }
[10:20:33.175]                       }
[10:20:33.175]                       invisible(muffled)
[10:20:33.175]                     }
[10:20:33.175]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.175]                   }
[10:20:33.175]                 }
[10:20:33.175]             }
[10:20:33.175]         }))
[10:20:33.175]     }, error = function(ex) {
[10:20:33.175]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.175]                 ...future.rng), started = ...future.startTime, 
[10:20:33.175]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.175]             version = "1.8"), class = "FutureResult")
[10:20:33.175]     }, finally = {
[10:20:33.175]         if (!identical(...future.workdir, getwd())) 
[10:20:33.175]             setwd(...future.workdir)
[10:20:33.175]         {
[10:20:33.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.175]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.175]             }
[10:20:33.175]             base::options(...future.oldOptions)
[10:20:33.175]             if (.Platform$OS.type == "windows") {
[10:20:33.175]                 old_names <- names(...future.oldEnvVars)
[10:20:33.175]                 envs <- base::Sys.getenv()
[10:20:33.175]                 names <- names(envs)
[10:20:33.175]                 common <- intersect(names, old_names)
[10:20:33.175]                 added <- setdiff(names, old_names)
[10:20:33.175]                 removed <- setdiff(old_names, names)
[10:20:33.175]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.175]                   envs[common]]
[10:20:33.175]                 NAMES <- toupper(changed)
[10:20:33.175]                 args <- list()
[10:20:33.175]                 for (kk in seq_along(NAMES)) {
[10:20:33.175]                   name <- changed[[kk]]
[10:20:33.175]                   NAME <- NAMES[[kk]]
[10:20:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.175]                     next
[10:20:33.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.175]                 }
[10:20:33.175]                 NAMES <- toupper(added)
[10:20:33.175]                 for (kk in seq_along(NAMES)) {
[10:20:33.175]                   name <- added[[kk]]
[10:20:33.175]                   NAME <- NAMES[[kk]]
[10:20:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.175]                     next
[10:20:33.175]                   args[[name]] <- ""
[10:20:33.175]                 }
[10:20:33.175]                 NAMES <- toupper(removed)
[10:20:33.175]                 for (kk in seq_along(NAMES)) {
[10:20:33.175]                   name <- removed[[kk]]
[10:20:33.175]                   NAME <- NAMES[[kk]]
[10:20:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.175]                     next
[10:20:33.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.175]                 }
[10:20:33.175]                 if (length(args) > 0) 
[10:20:33.175]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.175]             }
[10:20:33.175]             else {
[10:20:33.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.175]             }
[10:20:33.175]             {
[10:20:33.175]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.175]                   0L) {
[10:20:33.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.175]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.175]                   base::options(opts)
[10:20:33.175]                 }
[10:20:33.175]                 {
[10:20:33.175]                   {
[10:20:33.175]                     NULL
[10:20:33.175]                     RNGkind("Mersenne-Twister")
[10:20:33.175]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.175]                       inherits = FALSE)
[10:20:33.175]                   }
[10:20:33.175]                   options(future.plan = NULL)
[10:20:33.175]                   if (is.na(NA_character_)) 
[10:20:33.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.175]                     .init = FALSE)
[10:20:33.175]                 }
[10:20:33.175]             }
[10:20:33.175]         }
[10:20:33.175]     })
[10:20:33.175]     if (TRUE) {
[10:20:33.175]         base::sink(type = "output", split = FALSE)
[10:20:33.175]         if (TRUE) {
[10:20:33.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.175]         }
[10:20:33.175]         else {
[10:20:33.175]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.175]         }
[10:20:33.175]         base::close(...future.stdout)
[10:20:33.175]         ...future.stdout <- NULL
[10:20:33.175]     }
[10:20:33.175]     ...future.result$conditions <- ...future.conditions
[10:20:33.175]     ...future.result$finished <- base::Sys.time()
[10:20:33.175]     ...future.result
[10:20:33.175] }
[10:20:33.177] plan(): Setting new future strategy stack:
[10:20:33.177] List of future strategies:
[10:20:33.177] 1. sequential:
[10:20:33.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.177]    - tweaked: FALSE
[10:20:33.177]    - call: NULL
[10:20:33.177] plan(): nbrOfWorkers() = 1
[10:20:33.178] plan(): Setting new future strategy stack:
[10:20:33.178] List of future strategies:
[10:20:33.178] 1. sequential:
[10:20:33.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.178]    - tweaked: FALSE
[10:20:33.178]    - call: future::plan("sequential")
[10:20:33.178] plan(): nbrOfWorkers() = 1
[10:20:33.179] SequentialFuture started (and completed)
[10:20:33.179] signalConditions() ...
[10:20:33.179]  - include = ‘immediateCondition’
[10:20:33.179]  - exclude = 
[10:20:33.179]  - resignal = FALSE
[10:20:33.179]  - Number of conditions: 1
[10:20:33.179] signalConditions() ... done
[10:20:33.179] - Launch lazy future ... done
[10:20:33.179] run() for ‘SequentialFuture’ ... done
> env[["b"]] %<-% { 42L; stop("Woops") }
[10:20:33.180] getGlobalsAndPackages() ...
[10:20:33.180] Searching for globals...
[10:20:33.181] - globals found: [2] ‘{’, ‘stop’
[10:20:33.181] Searching for globals ... DONE
[10:20:33.181] Resolving globals: FALSE
[10:20:33.181] 
[10:20:33.181] 
[10:20:33.181] getGlobalsAndPackages() ... DONE
[10:20:33.181] run() for ‘Future’ ...
[10:20:33.181] - state: ‘created’
[10:20:33.182] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.182] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.182]   - Field: ‘label’
[10:20:33.182]   - Field: ‘local’
[10:20:33.182]   - Field: ‘owner’
[10:20:33.182]   - Field: ‘envir’
[10:20:33.182]   - Field: ‘packages’
[10:20:33.182]   - Field: ‘gc’
[10:20:33.183]   - Field: ‘conditions’
[10:20:33.183]   - Field: ‘expr’
[10:20:33.183]   - Field: ‘uuid’
[10:20:33.183]   - Field: ‘seed’
[10:20:33.183]   - Field: ‘version’
[10:20:33.183]   - Field: ‘result’
[10:20:33.183]   - Field: ‘asynchronous’
[10:20:33.183]   - Field: ‘calls’
[10:20:33.183]   - Field: ‘globals’
[10:20:33.183]   - Field: ‘stdout’
[10:20:33.183]   - Field: ‘earlySignal’
[10:20:33.183]   - Field: ‘lazy’
[10:20:33.184]   - Field: ‘state’
[10:20:33.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.184] - Launch lazy future ...
[10:20:33.184] Packages needed by the future expression (n = 0): <none>
[10:20:33.184] Packages needed by future strategies (n = 0): <none>
[10:20:33.184] {
[10:20:33.184]     {
[10:20:33.184]         {
[10:20:33.184]             ...future.startTime <- base::Sys.time()
[10:20:33.184]             {
[10:20:33.184]                 {
[10:20:33.184]                   {
[10:20:33.184]                     base::local({
[10:20:33.184]                       has_future <- base::requireNamespace("future", 
[10:20:33.184]                         quietly = TRUE)
[10:20:33.184]                       if (has_future) {
[10:20:33.184]                         ns <- base::getNamespace("future")
[10:20:33.184]                         version <- ns[[".package"]][["version"]]
[10:20:33.184]                         if (is.null(version)) 
[10:20:33.184]                           version <- utils::packageVersion("future")
[10:20:33.184]                       }
[10:20:33.184]                       else {
[10:20:33.184]                         version <- NULL
[10:20:33.184]                       }
[10:20:33.184]                       if (!has_future || version < "1.8.0") {
[10:20:33.184]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.184]                           "", base::R.version$version.string), 
[10:20:33.184]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.184]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.184]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.184]                             "release", "version")], collapse = " "), 
[10:20:33.184]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.184]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.184]                           info)
[10:20:33.184]                         info <- base::paste(info, collapse = "; ")
[10:20:33.184]                         if (!has_future) {
[10:20:33.184]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.184]                             info)
[10:20:33.184]                         }
[10:20:33.184]                         else {
[10:20:33.184]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.184]                             info, version)
[10:20:33.184]                         }
[10:20:33.184]                         base::stop(msg)
[10:20:33.184]                       }
[10:20:33.184]                     })
[10:20:33.184]                   }
[10:20:33.184]                   ...future.strategy.old <- future::plan("list")
[10:20:33.184]                   options(future.plan = NULL)
[10:20:33.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.184]                 }
[10:20:33.184]                 ...future.workdir <- getwd()
[10:20:33.184]             }
[10:20:33.184]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.184]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.184]         }
[10:20:33.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.184]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.184]             base::names(...future.oldOptions))
[10:20:33.184]     }
[10:20:33.184]     if (FALSE) {
[10:20:33.184]     }
[10:20:33.184]     else {
[10:20:33.184]         if (TRUE) {
[10:20:33.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.184]                 open = "w")
[10:20:33.184]         }
[10:20:33.184]         else {
[10:20:33.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.184]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.184]         }
[10:20:33.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.184]             base::sink(type = "output", split = FALSE)
[10:20:33.184]             base::close(...future.stdout)
[10:20:33.184]         }, add = TRUE)
[10:20:33.184]     }
[10:20:33.184]     ...future.frame <- base::sys.nframe()
[10:20:33.184]     ...future.conditions <- base::list()
[10:20:33.184]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.184]     if (FALSE) {
[10:20:33.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.184]     }
[10:20:33.184]     ...future.result <- base::tryCatch({
[10:20:33.184]         base::withCallingHandlers({
[10:20:33.184]             ...future.value <- base::withVisible(base::local({
[10:20:33.184]                 42L
[10:20:33.184]                 stop("Woops")
[10:20:33.184]             }))
[10:20:33.184]             future::FutureResult(value = ...future.value$value, 
[10:20:33.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.184]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.184]                     ...future.globalenv.names))
[10:20:33.184]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.184]         }, condition = base::local({
[10:20:33.184]             c <- base::c
[10:20:33.184]             inherits <- base::inherits
[10:20:33.184]             invokeRestart <- base::invokeRestart
[10:20:33.184]             length <- base::length
[10:20:33.184]             list <- base::list
[10:20:33.184]             seq.int <- base::seq.int
[10:20:33.184]             signalCondition <- base::signalCondition
[10:20:33.184]             sys.calls <- base::sys.calls
[10:20:33.184]             `[[` <- base::`[[`
[10:20:33.184]             `+` <- base::`+`
[10:20:33.184]             `<<-` <- base::`<<-`
[10:20:33.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.184]                   3L)]
[10:20:33.184]             }
[10:20:33.184]             function(cond) {
[10:20:33.184]                 is_error <- inherits(cond, "error")
[10:20:33.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.184]                   NULL)
[10:20:33.184]                 if (is_error) {
[10:20:33.184]                   sessionInformation <- function() {
[10:20:33.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.184]                       search = base::search(), system = base::Sys.info())
[10:20:33.184]                   }
[10:20:33.184]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.184]                     cond$call), session = sessionInformation(), 
[10:20:33.184]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.184]                   signalCondition(cond)
[10:20:33.184]                 }
[10:20:33.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.184]                 "immediateCondition"))) {
[10:20:33.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.184]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.184]                   if (TRUE && !signal) {
[10:20:33.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.184]                     {
[10:20:33.184]                       inherits <- base::inherits
[10:20:33.184]                       invokeRestart <- base::invokeRestart
[10:20:33.184]                       is.null <- base::is.null
[10:20:33.184]                       muffled <- FALSE
[10:20:33.184]                       if (inherits(cond, "message")) {
[10:20:33.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.184]                         if (muffled) 
[10:20:33.184]                           invokeRestart("muffleMessage")
[10:20:33.184]                       }
[10:20:33.184]                       else if (inherits(cond, "warning")) {
[10:20:33.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.184]                         if (muffled) 
[10:20:33.184]                           invokeRestart("muffleWarning")
[10:20:33.184]                       }
[10:20:33.184]                       else if (inherits(cond, "condition")) {
[10:20:33.184]                         if (!is.null(pattern)) {
[10:20:33.184]                           computeRestarts <- base::computeRestarts
[10:20:33.184]                           grepl <- base::grepl
[10:20:33.184]                           restarts <- computeRestarts(cond)
[10:20:33.184]                           for (restart in restarts) {
[10:20:33.184]                             name <- restart$name
[10:20:33.184]                             if (is.null(name)) 
[10:20:33.184]                               next
[10:20:33.184]                             if (!grepl(pattern, name)) 
[10:20:33.184]                               next
[10:20:33.184]                             invokeRestart(restart)
[10:20:33.184]                             muffled <- TRUE
[10:20:33.184]                             break
[10:20:33.184]                           }
[10:20:33.184]                         }
[10:20:33.184]                       }
[10:20:33.184]                       invisible(muffled)
[10:20:33.184]                     }
[10:20:33.184]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.184]                   }
[10:20:33.184]                 }
[10:20:33.184]                 else {
[10:20:33.184]                   if (TRUE) {
[10:20:33.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.184]                     {
[10:20:33.184]                       inherits <- base::inherits
[10:20:33.184]                       invokeRestart <- base::invokeRestart
[10:20:33.184]                       is.null <- base::is.null
[10:20:33.184]                       muffled <- FALSE
[10:20:33.184]                       if (inherits(cond, "message")) {
[10:20:33.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.184]                         if (muffled) 
[10:20:33.184]                           invokeRestart("muffleMessage")
[10:20:33.184]                       }
[10:20:33.184]                       else if (inherits(cond, "warning")) {
[10:20:33.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.184]                         if (muffled) 
[10:20:33.184]                           invokeRestart("muffleWarning")
[10:20:33.184]                       }
[10:20:33.184]                       else if (inherits(cond, "condition")) {
[10:20:33.184]                         if (!is.null(pattern)) {
[10:20:33.184]                           computeRestarts <- base::computeRestarts
[10:20:33.184]                           grepl <- base::grepl
[10:20:33.184]                           restarts <- computeRestarts(cond)
[10:20:33.184]                           for (restart in restarts) {
[10:20:33.184]                             name <- restart$name
[10:20:33.184]                             if (is.null(name)) 
[10:20:33.184]                               next
[10:20:33.184]                             if (!grepl(pattern, name)) 
[10:20:33.184]                               next
[10:20:33.184]                             invokeRestart(restart)
[10:20:33.184]                             muffled <- TRUE
[10:20:33.184]                             break
[10:20:33.184]                           }
[10:20:33.184]                         }
[10:20:33.184]                       }
[10:20:33.184]                       invisible(muffled)
[10:20:33.184]                     }
[10:20:33.184]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.184]                   }
[10:20:33.184]                 }
[10:20:33.184]             }
[10:20:33.184]         }))
[10:20:33.184]     }, error = function(ex) {
[10:20:33.184]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.184]                 ...future.rng), started = ...future.startTime, 
[10:20:33.184]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.184]             version = "1.8"), class = "FutureResult")
[10:20:33.184]     }, finally = {
[10:20:33.184]         if (!identical(...future.workdir, getwd())) 
[10:20:33.184]             setwd(...future.workdir)
[10:20:33.184]         {
[10:20:33.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.184]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.184]             }
[10:20:33.184]             base::options(...future.oldOptions)
[10:20:33.184]             if (.Platform$OS.type == "windows") {
[10:20:33.184]                 old_names <- names(...future.oldEnvVars)
[10:20:33.184]                 envs <- base::Sys.getenv()
[10:20:33.184]                 names <- names(envs)
[10:20:33.184]                 common <- intersect(names, old_names)
[10:20:33.184]                 added <- setdiff(names, old_names)
[10:20:33.184]                 removed <- setdiff(old_names, names)
[10:20:33.184]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.184]                   envs[common]]
[10:20:33.184]                 NAMES <- toupper(changed)
[10:20:33.184]                 args <- list()
[10:20:33.184]                 for (kk in seq_along(NAMES)) {
[10:20:33.184]                   name <- changed[[kk]]
[10:20:33.184]                   NAME <- NAMES[[kk]]
[10:20:33.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.184]                     next
[10:20:33.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.184]                 }
[10:20:33.184]                 NAMES <- toupper(added)
[10:20:33.184]                 for (kk in seq_along(NAMES)) {
[10:20:33.184]                   name <- added[[kk]]
[10:20:33.184]                   NAME <- NAMES[[kk]]
[10:20:33.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.184]                     next
[10:20:33.184]                   args[[name]] <- ""
[10:20:33.184]                 }
[10:20:33.184]                 NAMES <- toupper(removed)
[10:20:33.184]                 for (kk in seq_along(NAMES)) {
[10:20:33.184]                   name <- removed[[kk]]
[10:20:33.184]                   NAME <- NAMES[[kk]]
[10:20:33.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.184]                     next
[10:20:33.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.184]                 }
[10:20:33.184]                 if (length(args) > 0) 
[10:20:33.184]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.184]             }
[10:20:33.184]             else {
[10:20:33.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.184]             }
[10:20:33.184]             {
[10:20:33.184]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.184]                   0L) {
[10:20:33.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.184]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.184]                   base::options(opts)
[10:20:33.184]                 }
[10:20:33.184]                 {
[10:20:33.184]                   {
[10:20:33.184]                     NULL
[10:20:33.184]                     RNGkind("Mersenne-Twister")
[10:20:33.184]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.184]                       inherits = FALSE)
[10:20:33.184]                   }
[10:20:33.184]                   options(future.plan = NULL)
[10:20:33.184]                   if (is.na(NA_character_)) 
[10:20:33.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.184]                     .init = FALSE)
[10:20:33.184]                 }
[10:20:33.184]             }
[10:20:33.184]         }
[10:20:33.184]     })
[10:20:33.184]     if (TRUE) {
[10:20:33.184]         base::sink(type = "output", split = FALSE)
[10:20:33.184]         if (TRUE) {
[10:20:33.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.184]         }
[10:20:33.184]         else {
[10:20:33.184]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.184]         }
[10:20:33.184]         base::close(...future.stdout)
[10:20:33.184]         ...future.stdout <- NULL
[10:20:33.184]     }
[10:20:33.184]     ...future.result$conditions <- ...future.conditions
[10:20:33.184]     ...future.result$finished <- base::Sys.time()
[10:20:33.184]     ...future.result
[10:20:33.184] }
[10:20:33.186] plan(): Setting new future strategy stack:
[10:20:33.186] List of future strategies:
[10:20:33.186] 1. sequential:
[10:20:33.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.186]    - tweaked: FALSE
[10:20:33.186]    - call: NULL
[10:20:33.187] plan(): nbrOfWorkers() = 1
[10:20:33.187] plan(): Setting new future strategy stack:
[10:20:33.187] List of future strategies:
[10:20:33.187] 1. sequential:
[10:20:33.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.187]    - tweaked: FALSE
[10:20:33.187]    - call: future::plan("sequential")
[10:20:33.188] plan(): nbrOfWorkers() = 1
[10:20:33.188] SequentialFuture started (and completed)
[10:20:33.188] signalConditions() ...
[10:20:33.188]  - include = ‘immediateCondition’
[10:20:33.188]  - exclude = 
[10:20:33.188]  - resignal = FALSE
[10:20:33.189]  - Number of conditions: 1
[10:20:33.189] signalConditions() ... done
[10:20:33.189] - Launch lazy future ... done
[10:20:33.189] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(env[["b"]])
[10:20:33.189] resolved() for ‘SequentialFuture’ ...
[10:20:33.189] - state: ‘finished’
[10:20:33.189] - run: TRUE
[10:20:33.189] - result: ‘FutureResult’
[10:20:33.189] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
env[["b"]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> lenv <- listenv::listenv()
> lenv[[1]] %<-% { 42L; stop("Woops") }
[10:20:33.190] getGlobalsAndPackages() ...
[10:20:33.190] Searching for globals...
[10:20:33.191] - globals found: [2] ‘{’, ‘stop’
[10:20:33.191] Searching for globals ... DONE
[10:20:33.191] Resolving globals: FALSE
[10:20:33.192] 
[10:20:33.192] 
[10:20:33.192] getGlobalsAndPackages() ... DONE
[10:20:33.192] run() for ‘Future’ ...
[10:20:33.192] - state: ‘created’
[10:20:33.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.193] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.193]   - Field: ‘label’
[10:20:33.193]   - Field: ‘local’
[10:20:33.193]   - Field: ‘owner’
[10:20:33.193]   - Field: ‘envir’
[10:20:33.193]   - Field: ‘packages’
[10:20:33.193]   - Field: ‘gc’
[10:20:33.193]   - Field: ‘conditions’
[10:20:33.193]   - Field: ‘expr’
[10:20:33.193]   - Field: ‘uuid’
[10:20:33.193]   - Field: ‘seed’
[10:20:33.194]   - Field: ‘version’
[10:20:33.194]   - Field: ‘result’
[10:20:33.194]   - Field: ‘asynchronous’
[10:20:33.194]   - Field: ‘calls’
[10:20:33.194]   - Field: ‘globals’
[10:20:33.194]   - Field: ‘stdout’
[10:20:33.194]   - Field: ‘earlySignal’
[10:20:33.194]   - Field: ‘lazy’
[10:20:33.194]   - Field: ‘state’
[10:20:33.194] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.194] - Launch lazy future ...
[10:20:33.195] Packages needed by the future expression (n = 0): <none>
[10:20:33.195] Packages needed by future strategies (n = 0): <none>
[10:20:33.195] {
[10:20:33.195]     {
[10:20:33.195]         {
[10:20:33.195]             ...future.startTime <- base::Sys.time()
[10:20:33.195]             {
[10:20:33.195]                 {
[10:20:33.195]                   {
[10:20:33.195]                     base::local({
[10:20:33.195]                       has_future <- base::requireNamespace("future", 
[10:20:33.195]                         quietly = TRUE)
[10:20:33.195]                       if (has_future) {
[10:20:33.195]                         ns <- base::getNamespace("future")
[10:20:33.195]                         version <- ns[[".package"]][["version"]]
[10:20:33.195]                         if (is.null(version)) 
[10:20:33.195]                           version <- utils::packageVersion("future")
[10:20:33.195]                       }
[10:20:33.195]                       else {
[10:20:33.195]                         version <- NULL
[10:20:33.195]                       }
[10:20:33.195]                       if (!has_future || version < "1.8.0") {
[10:20:33.195]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.195]                           "", base::R.version$version.string), 
[10:20:33.195]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.195]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.195]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.195]                             "release", "version")], collapse = " "), 
[10:20:33.195]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.195]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.195]                           info)
[10:20:33.195]                         info <- base::paste(info, collapse = "; ")
[10:20:33.195]                         if (!has_future) {
[10:20:33.195]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.195]                             info)
[10:20:33.195]                         }
[10:20:33.195]                         else {
[10:20:33.195]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.195]                             info, version)
[10:20:33.195]                         }
[10:20:33.195]                         base::stop(msg)
[10:20:33.195]                       }
[10:20:33.195]                     })
[10:20:33.195]                   }
[10:20:33.195]                   ...future.strategy.old <- future::plan("list")
[10:20:33.195]                   options(future.plan = NULL)
[10:20:33.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.195]                 }
[10:20:33.195]                 ...future.workdir <- getwd()
[10:20:33.195]             }
[10:20:33.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.195]         }
[10:20:33.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.195]             base::names(...future.oldOptions))
[10:20:33.195]     }
[10:20:33.195]     if (FALSE) {
[10:20:33.195]     }
[10:20:33.195]     else {
[10:20:33.195]         if (TRUE) {
[10:20:33.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.195]                 open = "w")
[10:20:33.195]         }
[10:20:33.195]         else {
[10:20:33.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.195]         }
[10:20:33.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.195]             base::sink(type = "output", split = FALSE)
[10:20:33.195]             base::close(...future.stdout)
[10:20:33.195]         }, add = TRUE)
[10:20:33.195]     }
[10:20:33.195]     ...future.frame <- base::sys.nframe()
[10:20:33.195]     ...future.conditions <- base::list()
[10:20:33.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.195]     if (FALSE) {
[10:20:33.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.195]     }
[10:20:33.195]     ...future.result <- base::tryCatch({
[10:20:33.195]         base::withCallingHandlers({
[10:20:33.195]             ...future.value <- base::withVisible(base::local({
[10:20:33.195]                 42L
[10:20:33.195]                 stop("Woops")
[10:20:33.195]             }))
[10:20:33.195]             future::FutureResult(value = ...future.value$value, 
[10:20:33.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.195]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.195]                     ...future.globalenv.names))
[10:20:33.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.195]         }, condition = base::local({
[10:20:33.195]             c <- base::c
[10:20:33.195]             inherits <- base::inherits
[10:20:33.195]             invokeRestart <- base::invokeRestart
[10:20:33.195]             length <- base::length
[10:20:33.195]             list <- base::list
[10:20:33.195]             seq.int <- base::seq.int
[10:20:33.195]             signalCondition <- base::signalCondition
[10:20:33.195]             sys.calls <- base::sys.calls
[10:20:33.195]             `[[` <- base::`[[`
[10:20:33.195]             `+` <- base::`+`
[10:20:33.195]             `<<-` <- base::`<<-`
[10:20:33.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.195]                   3L)]
[10:20:33.195]             }
[10:20:33.195]             function(cond) {
[10:20:33.195]                 is_error <- inherits(cond, "error")
[10:20:33.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.195]                   NULL)
[10:20:33.195]                 if (is_error) {
[10:20:33.195]                   sessionInformation <- function() {
[10:20:33.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.195]                       search = base::search(), system = base::Sys.info())
[10:20:33.195]                   }
[10:20:33.195]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.195]                     cond$call), session = sessionInformation(), 
[10:20:33.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.195]                   signalCondition(cond)
[10:20:33.195]                 }
[10:20:33.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.195]                 "immediateCondition"))) {
[10:20:33.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.195]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.195]                   if (TRUE && !signal) {
[10:20:33.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.195]                     {
[10:20:33.195]                       inherits <- base::inherits
[10:20:33.195]                       invokeRestart <- base::invokeRestart
[10:20:33.195]                       is.null <- base::is.null
[10:20:33.195]                       muffled <- FALSE
[10:20:33.195]                       if (inherits(cond, "message")) {
[10:20:33.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.195]                         if (muffled) 
[10:20:33.195]                           invokeRestart("muffleMessage")
[10:20:33.195]                       }
[10:20:33.195]                       else if (inherits(cond, "warning")) {
[10:20:33.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.195]                         if (muffled) 
[10:20:33.195]                           invokeRestart("muffleWarning")
[10:20:33.195]                       }
[10:20:33.195]                       else if (inherits(cond, "condition")) {
[10:20:33.195]                         if (!is.null(pattern)) {
[10:20:33.195]                           computeRestarts <- base::computeRestarts
[10:20:33.195]                           grepl <- base::grepl
[10:20:33.195]                           restarts <- computeRestarts(cond)
[10:20:33.195]                           for (restart in restarts) {
[10:20:33.195]                             name <- restart$name
[10:20:33.195]                             if (is.null(name)) 
[10:20:33.195]                               next
[10:20:33.195]                             if (!grepl(pattern, name)) 
[10:20:33.195]                               next
[10:20:33.195]                             invokeRestart(restart)
[10:20:33.195]                             muffled <- TRUE
[10:20:33.195]                             break
[10:20:33.195]                           }
[10:20:33.195]                         }
[10:20:33.195]                       }
[10:20:33.195]                       invisible(muffled)
[10:20:33.195]                     }
[10:20:33.195]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.195]                   }
[10:20:33.195]                 }
[10:20:33.195]                 else {
[10:20:33.195]                   if (TRUE) {
[10:20:33.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.195]                     {
[10:20:33.195]                       inherits <- base::inherits
[10:20:33.195]                       invokeRestart <- base::invokeRestart
[10:20:33.195]                       is.null <- base::is.null
[10:20:33.195]                       muffled <- FALSE
[10:20:33.195]                       if (inherits(cond, "message")) {
[10:20:33.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.195]                         if (muffled) 
[10:20:33.195]                           invokeRestart("muffleMessage")
[10:20:33.195]                       }
[10:20:33.195]                       else if (inherits(cond, "warning")) {
[10:20:33.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.195]                         if (muffled) 
[10:20:33.195]                           invokeRestart("muffleWarning")
[10:20:33.195]                       }
[10:20:33.195]                       else if (inherits(cond, "condition")) {
[10:20:33.195]                         if (!is.null(pattern)) {
[10:20:33.195]                           computeRestarts <- base::computeRestarts
[10:20:33.195]                           grepl <- base::grepl
[10:20:33.195]                           restarts <- computeRestarts(cond)
[10:20:33.195]                           for (restart in restarts) {
[10:20:33.195]                             name <- restart$name
[10:20:33.195]                             if (is.null(name)) 
[10:20:33.195]                               next
[10:20:33.195]                             if (!grepl(pattern, name)) 
[10:20:33.195]                               next
[10:20:33.195]                             invokeRestart(restart)
[10:20:33.195]                             muffled <- TRUE
[10:20:33.195]                             break
[10:20:33.195]                           }
[10:20:33.195]                         }
[10:20:33.195]                       }
[10:20:33.195]                       invisible(muffled)
[10:20:33.195]                     }
[10:20:33.195]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.195]                   }
[10:20:33.195]                 }
[10:20:33.195]             }
[10:20:33.195]         }))
[10:20:33.195]     }, error = function(ex) {
[10:20:33.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.195]                 ...future.rng), started = ...future.startTime, 
[10:20:33.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.195]             version = "1.8"), class = "FutureResult")
[10:20:33.195]     }, finally = {
[10:20:33.195]         if (!identical(...future.workdir, getwd())) 
[10:20:33.195]             setwd(...future.workdir)
[10:20:33.195]         {
[10:20:33.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.195]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.195]             }
[10:20:33.195]             base::options(...future.oldOptions)
[10:20:33.195]             if (.Platform$OS.type == "windows") {
[10:20:33.195]                 old_names <- names(...future.oldEnvVars)
[10:20:33.195]                 envs <- base::Sys.getenv()
[10:20:33.195]                 names <- names(envs)
[10:20:33.195]                 common <- intersect(names, old_names)
[10:20:33.195]                 added <- setdiff(names, old_names)
[10:20:33.195]                 removed <- setdiff(old_names, names)
[10:20:33.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.195]                   envs[common]]
[10:20:33.195]                 NAMES <- toupper(changed)
[10:20:33.195]                 args <- list()
[10:20:33.195]                 for (kk in seq_along(NAMES)) {
[10:20:33.195]                   name <- changed[[kk]]
[10:20:33.195]                   NAME <- NAMES[[kk]]
[10:20:33.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.195]                     next
[10:20:33.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.195]                 }
[10:20:33.195]                 NAMES <- toupper(added)
[10:20:33.195]                 for (kk in seq_along(NAMES)) {
[10:20:33.195]                   name <- added[[kk]]
[10:20:33.195]                   NAME <- NAMES[[kk]]
[10:20:33.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.195]                     next
[10:20:33.195]                   args[[name]] <- ""
[10:20:33.195]                 }
[10:20:33.195]                 NAMES <- toupper(removed)
[10:20:33.195]                 for (kk in seq_along(NAMES)) {
[10:20:33.195]                   name <- removed[[kk]]
[10:20:33.195]                   NAME <- NAMES[[kk]]
[10:20:33.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.195]                     next
[10:20:33.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.195]                 }
[10:20:33.195]                 if (length(args) > 0) 
[10:20:33.195]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.195]             }
[10:20:33.195]             else {
[10:20:33.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.195]             }
[10:20:33.195]             {
[10:20:33.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.195]                   0L) {
[10:20:33.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.195]                   base::options(opts)
[10:20:33.195]                 }
[10:20:33.195]                 {
[10:20:33.195]                   {
[10:20:33.195]                     NULL
[10:20:33.195]                     RNGkind("Mersenne-Twister")
[10:20:33.195]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.195]                       inherits = FALSE)
[10:20:33.195]                   }
[10:20:33.195]                   options(future.plan = NULL)
[10:20:33.195]                   if (is.na(NA_character_)) 
[10:20:33.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.195]                     .init = FALSE)
[10:20:33.195]                 }
[10:20:33.195]             }
[10:20:33.195]         }
[10:20:33.195]     })
[10:20:33.195]     if (TRUE) {
[10:20:33.195]         base::sink(type = "output", split = FALSE)
[10:20:33.195]         if (TRUE) {
[10:20:33.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.195]         }
[10:20:33.195]         else {
[10:20:33.195]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.195]         }
[10:20:33.195]         base::close(...future.stdout)
[10:20:33.195]         ...future.stdout <- NULL
[10:20:33.195]     }
[10:20:33.195]     ...future.result$conditions <- ...future.conditions
[10:20:33.195]     ...future.result$finished <- base::Sys.time()
[10:20:33.195]     ...future.result
[10:20:33.195] }
[10:20:33.197] plan(): Setting new future strategy stack:
[10:20:33.197] List of future strategies:
[10:20:33.197] 1. sequential:
[10:20:33.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.197]    - tweaked: FALSE
[10:20:33.197]    - call: NULL
[10:20:33.197] plan(): nbrOfWorkers() = 1
[10:20:33.198] plan(): Setting new future strategy stack:
[10:20:33.198] List of future strategies:
[10:20:33.198] 1. sequential:
[10:20:33.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.198]    - tweaked: FALSE
[10:20:33.198]    - call: future::plan("sequential")
[10:20:33.199] plan(): nbrOfWorkers() = 1
[10:20:33.199] SequentialFuture started (and completed)
[10:20:33.199] signalConditions() ...
[10:20:33.199]  - include = ‘immediateCondition’
[10:20:33.199]  - exclude = 
[10:20:33.199]  - resignal = FALSE
[10:20:33.199]  - Number of conditions: 1
[10:20:33.199] signalConditions() ... done
[10:20:33.199] - Launch lazy future ... done
[10:20:33.199] run() for ‘SequentialFuture’ ... done
> lenv[[2]] %<-% { 42L; stop("Woops") }
[10:20:33.200] getGlobalsAndPackages() ...
[10:20:33.200] Searching for globals...
[10:20:33.202] - globals found: [2] ‘{’, ‘stop’
[10:20:33.202] Searching for globals ... DONE
[10:20:33.202] Resolving globals: FALSE
[10:20:33.203] 
[10:20:33.203] 
[10:20:33.203] getGlobalsAndPackages() ... DONE
[10:20:33.203] run() for ‘Future’ ...
[10:20:33.203] - state: ‘created’
[10:20:33.203] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.204]   - Field: ‘label’
[10:20:33.204]   - Field: ‘local’
[10:20:33.204]   - Field: ‘owner’
[10:20:33.204]   - Field: ‘envir’
[10:20:33.204]   - Field: ‘packages’
[10:20:33.204]   - Field: ‘gc’
[10:20:33.204]   - Field: ‘conditions’
[10:20:33.204]   - Field: ‘expr’
[10:20:33.204]   - Field: ‘uuid’
[10:20:33.204]   - Field: ‘seed’
[10:20:33.204]   - Field: ‘version’
[10:20:33.205]   - Field: ‘result’
[10:20:33.205]   - Field: ‘asynchronous’
[10:20:33.205]   - Field: ‘calls’
[10:20:33.205]   - Field: ‘globals’
[10:20:33.205]   - Field: ‘stdout’
[10:20:33.205]   - Field: ‘earlySignal’
[10:20:33.205]   - Field: ‘lazy’
[10:20:33.205]   - Field: ‘state’
[10:20:33.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.205] - Launch lazy future ...
[10:20:33.206] Packages needed by the future expression (n = 0): <none>
[10:20:33.206] Packages needed by future strategies (n = 0): <none>
[10:20:33.206] {
[10:20:33.206]     {
[10:20:33.206]         {
[10:20:33.206]             ...future.startTime <- base::Sys.time()
[10:20:33.206]             {
[10:20:33.206]                 {
[10:20:33.206]                   {
[10:20:33.206]                     base::local({
[10:20:33.206]                       has_future <- base::requireNamespace("future", 
[10:20:33.206]                         quietly = TRUE)
[10:20:33.206]                       if (has_future) {
[10:20:33.206]                         ns <- base::getNamespace("future")
[10:20:33.206]                         version <- ns[[".package"]][["version"]]
[10:20:33.206]                         if (is.null(version)) 
[10:20:33.206]                           version <- utils::packageVersion("future")
[10:20:33.206]                       }
[10:20:33.206]                       else {
[10:20:33.206]                         version <- NULL
[10:20:33.206]                       }
[10:20:33.206]                       if (!has_future || version < "1.8.0") {
[10:20:33.206]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.206]                           "", base::R.version$version.string), 
[10:20:33.206]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.206]                             "release", "version")], collapse = " "), 
[10:20:33.206]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.206]                           info)
[10:20:33.206]                         info <- base::paste(info, collapse = "; ")
[10:20:33.206]                         if (!has_future) {
[10:20:33.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.206]                             info)
[10:20:33.206]                         }
[10:20:33.206]                         else {
[10:20:33.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.206]                             info, version)
[10:20:33.206]                         }
[10:20:33.206]                         base::stop(msg)
[10:20:33.206]                       }
[10:20:33.206]                     })
[10:20:33.206]                   }
[10:20:33.206]                   ...future.strategy.old <- future::plan("list")
[10:20:33.206]                   options(future.plan = NULL)
[10:20:33.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.206]                 }
[10:20:33.206]                 ...future.workdir <- getwd()
[10:20:33.206]             }
[10:20:33.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.206]         }
[10:20:33.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.206]             base::names(...future.oldOptions))
[10:20:33.206]     }
[10:20:33.206]     if (FALSE) {
[10:20:33.206]     }
[10:20:33.206]     else {
[10:20:33.206]         if (TRUE) {
[10:20:33.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.206]                 open = "w")
[10:20:33.206]         }
[10:20:33.206]         else {
[10:20:33.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.206]         }
[10:20:33.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.206]             base::sink(type = "output", split = FALSE)
[10:20:33.206]             base::close(...future.stdout)
[10:20:33.206]         }, add = TRUE)
[10:20:33.206]     }
[10:20:33.206]     ...future.frame <- base::sys.nframe()
[10:20:33.206]     ...future.conditions <- base::list()
[10:20:33.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.206]     if (FALSE) {
[10:20:33.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.206]     }
[10:20:33.206]     ...future.result <- base::tryCatch({
[10:20:33.206]         base::withCallingHandlers({
[10:20:33.206]             ...future.value <- base::withVisible(base::local({
[10:20:33.206]                 42L
[10:20:33.206]                 stop("Woops")
[10:20:33.206]             }))
[10:20:33.206]             future::FutureResult(value = ...future.value$value, 
[10:20:33.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.206]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.206]                     ...future.globalenv.names))
[10:20:33.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.206]         }, condition = base::local({
[10:20:33.206]             c <- base::c
[10:20:33.206]             inherits <- base::inherits
[10:20:33.206]             invokeRestart <- base::invokeRestart
[10:20:33.206]             length <- base::length
[10:20:33.206]             list <- base::list
[10:20:33.206]             seq.int <- base::seq.int
[10:20:33.206]             signalCondition <- base::signalCondition
[10:20:33.206]             sys.calls <- base::sys.calls
[10:20:33.206]             `[[` <- base::`[[`
[10:20:33.206]             `+` <- base::`+`
[10:20:33.206]             `<<-` <- base::`<<-`
[10:20:33.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.206]                   3L)]
[10:20:33.206]             }
[10:20:33.206]             function(cond) {
[10:20:33.206]                 is_error <- inherits(cond, "error")
[10:20:33.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.206]                   NULL)
[10:20:33.206]                 if (is_error) {
[10:20:33.206]                   sessionInformation <- function() {
[10:20:33.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.206]                       search = base::search(), system = base::Sys.info())
[10:20:33.206]                   }
[10:20:33.206]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.206]                     cond$call), session = sessionInformation(), 
[10:20:33.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.206]                   signalCondition(cond)
[10:20:33.206]                 }
[10:20:33.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.206]                 "immediateCondition"))) {
[10:20:33.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.206]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.206]                   if (TRUE && !signal) {
[10:20:33.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.206]                     {
[10:20:33.206]                       inherits <- base::inherits
[10:20:33.206]                       invokeRestart <- base::invokeRestart
[10:20:33.206]                       is.null <- base::is.null
[10:20:33.206]                       muffled <- FALSE
[10:20:33.206]                       if (inherits(cond, "message")) {
[10:20:33.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.206]                         if (muffled) 
[10:20:33.206]                           invokeRestart("muffleMessage")
[10:20:33.206]                       }
[10:20:33.206]                       else if (inherits(cond, "warning")) {
[10:20:33.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.206]                         if (muffled) 
[10:20:33.206]                           invokeRestart("muffleWarning")
[10:20:33.206]                       }
[10:20:33.206]                       else if (inherits(cond, "condition")) {
[10:20:33.206]                         if (!is.null(pattern)) {
[10:20:33.206]                           computeRestarts <- base::computeRestarts
[10:20:33.206]                           grepl <- base::grepl
[10:20:33.206]                           restarts <- computeRestarts(cond)
[10:20:33.206]                           for (restart in restarts) {
[10:20:33.206]                             name <- restart$name
[10:20:33.206]                             if (is.null(name)) 
[10:20:33.206]                               next
[10:20:33.206]                             if (!grepl(pattern, name)) 
[10:20:33.206]                               next
[10:20:33.206]                             invokeRestart(restart)
[10:20:33.206]                             muffled <- TRUE
[10:20:33.206]                             break
[10:20:33.206]                           }
[10:20:33.206]                         }
[10:20:33.206]                       }
[10:20:33.206]                       invisible(muffled)
[10:20:33.206]                     }
[10:20:33.206]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.206]                   }
[10:20:33.206]                 }
[10:20:33.206]                 else {
[10:20:33.206]                   if (TRUE) {
[10:20:33.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.206]                     {
[10:20:33.206]                       inherits <- base::inherits
[10:20:33.206]                       invokeRestart <- base::invokeRestart
[10:20:33.206]                       is.null <- base::is.null
[10:20:33.206]                       muffled <- FALSE
[10:20:33.206]                       if (inherits(cond, "message")) {
[10:20:33.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.206]                         if (muffled) 
[10:20:33.206]                           invokeRestart("muffleMessage")
[10:20:33.206]                       }
[10:20:33.206]                       else if (inherits(cond, "warning")) {
[10:20:33.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.206]                         if (muffled) 
[10:20:33.206]                           invokeRestart("muffleWarning")
[10:20:33.206]                       }
[10:20:33.206]                       else if (inherits(cond, "condition")) {
[10:20:33.206]                         if (!is.null(pattern)) {
[10:20:33.206]                           computeRestarts <- base::computeRestarts
[10:20:33.206]                           grepl <- base::grepl
[10:20:33.206]                           restarts <- computeRestarts(cond)
[10:20:33.206]                           for (restart in restarts) {
[10:20:33.206]                             name <- restart$name
[10:20:33.206]                             if (is.null(name)) 
[10:20:33.206]                               next
[10:20:33.206]                             if (!grepl(pattern, name)) 
[10:20:33.206]                               next
[10:20:33.206]                             invokeRestart(restart)
[10:20:33.206]                             muffled <- TRUE
[10:20:33.206]                             break
[10:20:33.206]                           }
[10:20:33.206]                         }
[10:20:33.206]                       }
[10:20:33.206]                       invisible(muffled)
[10:20:33.206]                     }
[10:20:33.206]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.206]                   }
[10:20:33.206]                 }
[10:20:33.206]             }
[10:20:33.206]         }))
[10:20:33.206]     }, error = function(ex) {
[10:20:33.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.206]                 ...future.rng), started = ...future.startTime, 
[10:20:33.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.206]             version = "1.8"), class = "FutureResult")
[10:20:33.206]     }, finally = {
[10:20:33.206]         if (!identical(...future.workdir, getwd())) 
[10:20:33.206]             setwd(...future.workdir)
[10:20:33.206]         {
[10:20:33.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.206]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.206]             }
[10:20:33.206]             base::options(...future.oldOptions)
[10:20:33.206]             if (.Platform$OS.type == "windows") {
[10:20:33.206]                 old_names <- names(...future.oldEnvVars)
[10:20:33.206]                 envs <- base::Sys.getenv()
[10:20:33.206]                 names <- names(envs)
[10:20:33.206]                 common <- intersect(names, old_names)
[10:20:33.206]                 added <- setdiff(names, old_names)
[10:20:33.206]                 removed <- setdiff(old_names, names)
[10:20:33.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.206]                   envs[common]]
[10:20:33.206]                 NAMES <- toupper(changed)
[10:20:33.206]                 args <- list()
[10:20:33.206]                 for (kk in seq_along(NAMES)) {
[10:20:33.206]                   name <- changed[[kk]]
[10:20:33.206]                   NAME <- NAMES[[kk]]
[10:20:33.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.206]                     next
[10:20:33.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.206]                 }
[10:20:33.206]                 NAMES <- toupper(added)
[10:20:33.206]                 for (kk in seq_along(NAMES)) {
[10:20:33.206]                   name <- added[[kk]]
[10:20:33.206]                   NAME <- NAMES[[kk]]
[10:20:33.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.206]                     next
[10:20:33.206]                   args[[name]] <- ""
[10:20:33.206]                 }
[10:20:33.206]                 NAMES <- toupper(removed)
[10:20:33.206]                 for (kk in seq_along(NAMES)) {
[10:20:33.206]                   name <- removed[[kk]]
[10:20:33.206]                   NAME <- NAMES[[kk]]
[10:20:33.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.206]                     next
[10:20:33.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.206]                 }
[10:20:33.206]                 if (length(args) > 0) 
[10:20:33.206]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.206]             }
[10:20:33.206]             else {
[10:20:33.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.206]             }
[10:20:33.206]             {
[10:20:33.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.206]                   0L) {
[10:20:33.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.206]                   base::options(opts)
[10:20:33.206]                 }
[10:20:33.206]                 {
[10:20:33.206]                   {
[10:20:33.206]                     NULL
[10:20:33.206]                     RNGkind("Mersenne-Twister")
[10:20:33.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.206]                       inherits = FALSE)
[10:20:33.206]                   }
[10:20:33.206]                   options(future.plan = NULL)
[10:20:33.206]                   if (is.na(NA_character_)) 
[10:20:33.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.206]                     .init = FALSE)
[10:20:33.206]                 }
[10:20:33.206]             }
[10:20:33.206]         }
[10:20:33.206]     })
[10:20:33.206]     if (TRUE) {
[10:20:33.206]         base::sink(type = "output", split = FALSE)
[10:20:33.206]         if (TRUE) {
[10:20:33.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.206]         }
[10:20:33.206]         else {
[10:20:33.206]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.206]         }
[10:20:33.206]         base::close(...future.stdout)
[10:20:33.206]         ...future.stdout <- NULL
[10:20:33.206]     }
[10:20:33.206]     ...future.result$conditions <- ...future.conditions
[10:20:33.206]     ...future.result$finished <- base::Sys.time()
[10:20:33.206]     ...future.result
[10:20:33.206] }
[10:20:33.208] plan(): Setting new future strategy stack:
[10:20:33.208] List of future strategies:
[10:20:33.208] 1. sequential:
[10:20:33.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.208]    - tweaked: FALSE
[10:20:33.208]    - call: NULL
[10:20:33.208] plan(): nbrOfWorkers() = 1
[10:20:33.209] plan(): Setting new future strategy stack:
[10:20:33.209] List of future strategies:
[10:20:33.209] 1. sequential:
[10:20:33.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.209]    - tweaked: FALSE
[10:20:33.209]    - call: future::plan("sequential")
[10:20:33.210] plan(): nbrOfWorkers() = 1
[10:20:33.210] SequentialFuture started (and completed)
[10:20:33.210] signalConditions() ...
[10:20:33.210]  - include = ‘immediateCondition’
[10:20:33.211]  - exclude = 
[10:20:33.211]  - resignal = FALSE
[10:20:33.211]  - Number of conditions: 1
[10:20:33.211] signalConditions() ... done
[10:20:33.211] - Launch lazy future ... done
[10:20:33.211] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(lenv[[2]])
[10:20:33.212] resolved() for ‘SequentialFuture’ ...
[10:20:33.212] - state: ‘finished’
[10:20:33.212] - run: TRUE
[10:20:33.212] - result: ‘FutureResult’
[10:20:33.212] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
lenv[[2]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> ll <- list()
> ll[[1]] <- future({ 42L; stop("Woops") })
[10:20:33.212] getGlobalsAndPackages() ...
[10:20:33.212] Searching for globals...
[10:20:33.213] - globals found: [2] ‘{’, ‘stop’
[10:20:33.213] Searching for globals ... DONE
[10:20:33.214] Resolving globals: FALSE
[10:20:33.214] 
[10:20:33.214] 
[10:20:33.214] getGlobalsAndPackages() ... DONE
[10:20:33.214] run() for ‘Future’ ...
[10:20:33.214] - state: ‘created’
[10:20:33.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.215] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.215]   - Field: ‘label’
[10:20:33.215]   - Field: ‘local’
[10:20:33.215]   - Field: ‘owner’
[10:20:33.215]   - Field: ‘envir’
[10:20:33.215]   - Field: ‘packages’
[10:20:33.215]   - Field: ‘gc’
[10:20:33.215]   - Field: ‘conditions’
[10:20:33.215]   - Field: ‘expr’
[10:20:33.216]   - Field: ‘uuid’
[10:20:33.216]   - Field: ‘seed’
[10:20:33.216]   - Field: ‘version’
[10:20:33.216]   - Field: ‘result’
[10:20:33.216]   - Field: ‘asynchronous’
[10:20:33.216]   - Field: ‘calls’
[10:20:33.216]   - Field: ‘globals’
[10:20:33.216]   - Field: ‘stdout’
[10:20:33.216]   - Field: ‘earlySignal’
[10:20:33.216]   - Field: ‘lazy’
[10:20:33.216]   - Field: ‘state’
[10:20:33.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.217] - Launch lazy future ...
[10:20:33.217] Packages needed by the future expression (n = 0): <none>
[10:20:33.217] Packages needed by future strategies (n = 0): <none>
[10:20:33.217] {
[10:20:33.217]     {
[10:20:33.217]         {
[10:20:33.217]             ...future.startTime <- base::Sys.time()
[10:20:33.217]             {
[10:20:33.217]                 {
[10:20:33.217]                   {
[10:20:33.217]                     base::local({
[10:20:33.217]                       has_future <- base::requireNamespace("future", 
[10:20:33.217]                         quietly = TRUE)
[10:20:33.217]                       if (has_future) {
[10:20:33.217]                         ns <- base::getNamespace("future")
[10:20:33.217]                         version <- ns[[".package"]][["version"]]
[10:20:33.217]                         if (is.null(version)) 
[10:20:33.217]                           version <- utils::packageVersion("future")
[10:20:33.217]                       }
[10:20:33.217]                       else {
[10:20:33.217]                         version <- NULL
[10:20:33.217]                       }
[10:20:33.217]                       if (!has_future || version < "1.8.0") {
[10:20:33.217]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.217]                           "", base::R.version$version.string), 
[10:20:33.217]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.217]                             "release", "version")], collapse = " "), 
[10:20:33.217]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.217]                           info)
[10:20:33.217]                         info <- base::paste(info, collapse = "; ")
[10:20:33.217]                         if (!has_future) {
[10:20:33.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.217]                             info)
[10:20:33.217]                         }
[10:20:33.217]                         else {
[10:20:33.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.217]                             info, version)
[10:20:33.217]                         }
[10:20:33.217]                         base::stop(msg)
[10:20:33.217]                       }
[10:20:33.217]                     })
[10:20:33.217]                   }
[10:20:33.217]                   ...future.strategy.old <- future::plan("list")
[10:20:33.217]                   options(future.plan = NULL)
[10:20:33.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.217]                 }
[10:20:33.217]                 ...future.workdir <- getwd()
[10:20:33.217]             }
[10:20:33.217]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.217]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.217]         }
[10:20:33.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.217]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.217]             base::names(...future.oldOptions))
[10:20:33.217]     }
[10:20:33.217]     if (FALSE) {
[10:20:33.217]     }
[10:20:33.217]     else {
[10:20:33.217]         if (TRUE) {
[10:20:33.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.217]                 open = "w")
[10:20:33.217]         }
[10:20:33.217]         else {
[10:20:33.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.217]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.217]         }
[10:20:33.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.217]             base::sink(type = "output", split = FALSE)
[10:20:33.217]             base::close(...future.stdout)
[10:20:33.217]         }, add = TRUE)
[10:20:33.217]     }
[10:20:33.217]     ...future.frame <- base::sys.nframe()
[10:20:33.217]     ...future.conditions <- base::list()
[10:20:33.217]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.217]     if (FALSE) {
[10:20:33.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.217]     }
[10:20:33.217]     ...future.result <- base::tryCatch({
[10:20:33.217]         base::withCallingHandlers({
[10:20:33.217]             ...future.value <- base::withVisible(base::local({
[10:20:33.217]                 42L
[10:20:33.217]                 stop("Woops")
[10:20:33.217]             }))
[10:20:33.217]             future::FutureResult(value = ...future.value$value, 
[10:20:33.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.217]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.217]                     ...future.globalenv.names))
[10:20:33.217]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.217]         }, condition = base::local({
[10:20:33.217]             c <- base::c
[10:20:33.217]             inherits <- base::inherits
[10:20:33.217]             invokeRestart <- base::invokeRestart
[10:20:33.217]             length <- base::length
[10:20:33.217]             list <- base::list
[10:20:33.217]             seq.int <- base::seq.int
[10:20:33.217]             signalCondition <- base::signalCondition
[10:20:33.217]             sys.calls <- base::sys.calls
[10:20:33.217]             `[[` <- base::`[[`
[10:20:33.217]             `+` <- base::`+`
[10:20:33.217]             `<<-` <- base::`<<-`
[10:20:33.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.217]                   3L)]
[10:20:33.217]             }
[10:20:33.217]             function(cond) {
[10:20:33.217]                 is_error <- inherits(cond, "error")
[10:20:33.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.217]                   NULL)
[10:20:33.217]                 if (is_error) {
[10:20:33.217]                   sessionInformation <- function() {
[10:20:33.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.217]                       search = base::search(), system = base::Sys.info())
[10:20:33.217]                   }
[10:20:33.217]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.217]                     cond$call), session = sessionInformation(), 
[10:20:33.217]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.217]                   signalCondition(cond)
[10:20:33.217]                 }
[10:20:33.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.217]                 "immediateCondition"))) {
[10:20:33.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.217]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.217]                   if (TRUE && !signal) {
[10:20:33.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.217]                     {
[10:20:33.217]                       inherits <- base::inherits
[10:20:33.217]                       invokeRestart <- base::invokeRestart
[10:20:33.217]                       is.null <- base::is.null
[10:20:33.217]                       muffled <- FALSE
[10:20:33.217]                       if (inherits(cond, "message")) {
[10:20:33.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.217]                         if (muffled) 
[10:20:33.217]                           invokeRestart("muffleMessage")
[10:20:33.217]                       }
[10:20:33.217]                       else if (inherits(cond, "warning")) {
[10:20:33.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.217]                         if (muffled) 
[10:20:33.217]                           invokeRestart("muffleWarning")
[10:20:33.217]                       }
[10:20:33.217]                       else if (inherits(cond, "condition")) {
[10:20:33.217]                         if (!is.null(pattern)) {
[10:20:33.217]                           computeRestarts <- base::computeRestarts
[10:20:33.217]                           grepl <- base::grepl
[10:20:33.217]                           restarts <- computeRestarts(cond)
[10:20:33.217]                           for (restart in restarts) {
[10:20:33.217]                             name <- restart$name
[10:20:33.217]                             if (is.null(name)) 
[10:20:33.217]                               next
[10:20:33.217]                             if (!grepl(pattern, name)) 
[10:20:33.217]                               next
[10:20:33.217]                             invokeRestart(restart)
[10:20:33.217]                             muffled <- TRUE
[10:20:33.217]                             break
[10:20:33.217]                           }
[10:20:33.217]                         }
[10:20:33.217]                       }
[10:20:33.217]                       invisible(muffled)
[10:20:33.217]                     }
[10:20:33.217]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.217]                   }
[10:20:33.217]                 }
[10:20:33.217]                 else {
[10:20:33.217]                   if (TRUE) {
[10:20:33.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.217]                     {
[10:20:33.217]                       inherits <- base::inherits
[10:20:33.217]                       invokeRestart <- base::invokeRestart
[10:20:33.217]                       is.null <- base::is.null
[10:20:33.217]                       muffled <- FALSE
[10:20:33.217]                       if (inherits(cond, "message")) {
[10:20:33.217]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.217]                         if (muffled) 
[10:20:33.217]                           invokeRestart("muffleMessage")
[10:20:33.217]                       }
[10:20:33.217]                       else if (inherits(cond, "warning")) {
[10:20:33.217]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.217]                         if (muffled) 
[10:20:33.217]                           invokeRestart("muffleWarning")
[10:20:33.217]                       }
[10:20:33.217]                       else if (inherits(cond, "condition")) {
[10:20:33.217]                         if (!is.null(pattern)) {
[10:20:33.217]                           computeRestarts <- base::computeRestarts
[10:20:33.217]                           grepl <- base::grepl
[10:20:33.217]                           restarts <- computeRestarts(cond)
[10:20:33.217]                           for (restart in restarts) {
[10:20:33.217]                             name <- restart$name
[10:20:33.217]                             if (is.null(name)) 
[10:20:33.217]                               next
[10:20:33.217]                             if (!grepl(pattern, name)) 
[10:20:33.217]                               next
[10:20:33.217]                             invokeRestart(restart)
[10:20:33.217]                             muffled <- TRUE
[10:20:33.217]                             break
[10:20:33.217]                           }
[10:20:33.217]                         }
[10:20:33.217]                       }
[10:20:33.217]                       invisible(muffled)
[10:20:33.217]                     }
[10:20:33.217]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.217]                   }
[10:20:33.217]                 }
[10:20:33.217]             }
[10:20:33.217]         }))
[10:20:33.217]     }, error = function(ex) {
[10:20:33.217]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.217]                 ...future.rng), started = ...future.startTime, 
[10:20:33.217]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.217]             version = "1.8"), class = "FutureResult")
[10:20:33.217]     }, finally = {
[10:20:33.217]         if (!identical(...future.workdir, getwd())) 
[10:20:33.217]             setwd(...future.workdir)
[10:20:33.217]         {
[10:20:33.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.217]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.217]             }
[10:20:33.217]             base::options(...future.oldOptions)
[10:20:33.217]             if (.Platform$OS.type == "windows") {
[10:20:33.217]                 old_names <- names(...future.oldEnvVars)
[10:20:33.217]                 envs <- base::Sys.getenv()
[10:20:33.217]                 names <- names(envs)
[10:20:33.217]                 common <- intersect(names, old_names)
[10:20:33.217]                 added <- setdiff(names, old_names)
[10:20:33.217]                 removed <- setdiff(old_names, names)
[10:20:33.217]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.217]                   envs[common]]
[10:20:33.217]                 NAMES <- toupper(changed)
[10:20:33.217]                 args <- list()
[10:20:33.217]                 for (kk in seq_along(NAMES)) {
[10:20:33.217]                   name <- changed[[kk]]
[10:20:33.217]                   NAME <- NAMES[[kk]]
[10:20:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.217]                     next
[10:20:33.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.217]                 }
[10:20:33.217]                 NAMES <- toupper(added)
[10:20:33.217]                 for (kk in seq_along(NAMES)) {
[10:20:33.217]                   name <- added[[kk]]
[10:20:33.217]                   NAME <- NAMES[[kk]]
[10:20:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.217]                     next
[10:20:33.217]                   args[[name]] <- ""
[10:20:33.217]                 }
[10:20:33.217]                 NAMES <- toupper(removed)
[10:20:33.217]                 for (kk in seq_along(NAMES)) {
[10:20:33.217]                   name <- removed[[kk]]
[10:20:33.217]                   NAME <- NAMES[[kk]]
[10:20:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.217]                     next
[10:20:33.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.217]                 }
[10:20:33.217]                 if (length(args) > 0) 
[10:20:33.217]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.217]             }
[10:20:33.217]             else {
[10:20:33.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.217]             }
[10:20:33.217]             {
[10:20:33.217]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.217]                   0L) {
[10:20:33.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.217]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.217]                   base::options(opts)
[10:20:33.217]                 }
[10:20:33.217]                 {
[10:20:33.217]                   {
[10:20:33.217]                     NULL
[10:20:33.217]                     RNGkind("Mersenne-Twister")
[10:20:33.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.217]                       inherits = FALSE)
[10:20:33.217]                   }
[10:20:33.217]                   options(future.plan = NULL)
[10:20:33.217]                   if (is.na(NA_character_)) 
[10:20:33.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.217]                     .init = FALSE)
[10:20:33.217]                 }
[10:20:33.217]             }
[10:20:33.217]         }
[10:20:33.217]     })
[10:20:33.217]     if (TRUE) {
[10:20:33.217]         base::sink(type = "output", split = FALSE)
[10:20:33.217]         if (TRUE) {
[10:20:33.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.217]         }
[10:20:33.217]         else {
[10:20:33.217]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.217]         }
[10:20:33.217]         base::close(...future.stdout)
[10:20:33.217]         ...future.stdout <- NULL
[10:20:33.217]     }
[10:20:33.217]     ...future.result$conditions <- ...future.conditions
[10:20:33.217]     ...future.result$finished <- base::Sys.time()
[10:20:33.217]     ...future.result
[10:20:33.217] }
[10:20:33.219] plan(): Setting new future strategy stack:
[10:20:33.219] List of future strategies:
[10:20:33.219] 1. sequential:
[10:20:33.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.219]    - tweaked: FALSE
[10:20:33.219]    - call: NULL
[10:20:33.219] plan(): nbrOfWorkers() = 1
[10:20:33.220] plan(): Setting new future strategy stack:
[10:20:33.220] List of future strategies:
[10:20:33.220] 1. sequential:
[10:20:33.220]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.220]    - tweaked: FALSE
[10:20:33.220]    - call: future::plan("sequential")
[10:20:33.221] plan(): nbrOfWorkers() = 1
[10:20:33.221] SequentialFuture started (and completed)
[10:20:33.221] signalConditions() ...
[10:20:33.221]  - include = ‘immediateCondition’
[10:20:33.221]  - exclude = 
[10:20:33.221]  - resignal = FALSE
[10:20:33.221]  - Number of conditions: 1
[10:20:33.221] signalConditions() ... done
[10:20:33.221] - Launch lazy future ... done
[10:20:33.222] run() for ‘SequentialFuture’ ... done
> ll[[2]] <- future({ 42L; stop("Woops") })
[10:20:33.222] getGlobalsAndPackages() ...
[10:20:33.222] Searching for globals...
[10:20:33.223] - globals found: [2] ‘{’, ‘stop’
[10:20:33.223] Searching for globals ... DONE
[10:20:33.223] Resolving globals: FALSE
[10:20:33.223] 
[10:20:33.223] 
[10:20:33.223] getGlobalsAndPackages() ... DONE
[10:20:33.223] run() for ‘Future’ ...
[10:20:33.224] - state: ‘created’
[10:20:33.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.224]   - Field: ‘label’
[10:20:33.224]   - Field: ‘local’
[10:20:33.224]   - Field: ‘owner’
[10:20:33.224]   - Field: ‘envir’
[10:20:33.224]   - Field: ‘packages’
[10:20:33.225]   - Field: ‘gc’
[10:20:33.225]   - Field: ‘conditions’
[10:20:33.225]   - Field: ‘expr’
[10:20:33.225]   - Field: ‘uuid’
[10:20:33.225]   - Field: ‘seed’
[10:20:33.225]   - Field: ‘version’
[10:20:33.225]   - Field: ‘result’
[10:20:33.225]   - Field: ‘asynchronous’
[10:20:33.225]   - Field: ‘calls’
[10:20:33.225]   - Field: ‘globals’
[10:20:33.225]   - Field: ‘stdout’
[10:20:33.225]   - Field: ‘earlySignal’
[10:20:33.226]   - Field: ‘lazy’
[10:20:33.226]   - Field: ‘state’
[10:20:33.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.226] - Launch lazy future ...
[10:20:33.226] Packages needed by the future expression (n = 0): <none>
[10:20:33.226] Packages needed by future strategies (n = 0): <none>
[10:20:33.226] {
[10:20:33.226]     {
[10:20:33.226]         {
[10:20:33.226]             ...future.startTime <- base::Sys.time()
[10:20:33.226]             {
[10:20:33.226]                 {
[10:20:33.226]                   {
[10:20:33.226]                     base::local({
[10:20:33.226]                       has_future <- base::requireNamespace("future", 
[10:20:33.226]                         quietly = TRUE)
[10:20:33.226]                       if (has_future) {
[10:20:33.226]                         ns <- base::getNamespace("future")
[10:20:33.226]                         version <- ns[[".package"]][["version"]]
[10:20:33.226]                         if (is.null(version)) 
[10:20:33.226]                           version <- utils::packageVersion("future")
[10:20:33.226]                       }
[10:20:33.226]                       else {
[10:20:33.226]                         version <- NULL
[10:20:33.226]                       }
[10:20:33.226]                       if (!has_future || version < "1.8.0") {
[10:20:33.226]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.226]                           "", base::R.version$version.string), 
[10:20:33.226]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.226]                             "release", "version")], collapse = " "), 
[10:20:33.226]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.226]                           info)
[10:20:33.226]                         info <- base::paste(info, collapse = "; ")
[10:20:33.226]                         if (!has_future) {
[10:20:33.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.226]                             info)
[10:20:33.226]                         }
[10:20:33.226]                         else {
[10:20:33.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.226]                             info, version)
[10:20:33.226]                         }
[10:20:33.226]                         base::stop(msg)
[10:20:33.226]                       }
[10:20:33.226]                     })
[10:20:33.226]                   }
[10:20:33.226]                   ...future.strategy.old <- future::plan("list")
[10:20:33.226]                   options(future.plan = NULL)
[10:20:33.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.226]                 }
[10:20:33.226]                 ...future.workdir <- getwd()
[10:20:33.226]             }
[10:20:33.226]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.226]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.226]         }
[10:20:33.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.226]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.226]             base::names(...future.oldOptions))
[10:20:33.226]     }
[10:20:33.226]     if (FALSE) {
[10:20:33.226]     }
[10:20:33.226]     else {
[10:20:33.226]         if (TRUE) {
[10:20:33.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.226]                 open = "w")
[10:20:33.226]         }
[10:20:33.226]         else {
[10:20:33.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.226]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.226]         }
[10:20:33.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.226]             base::sink(type = "output", split = FALSE)
[10:20:33.226]             base::close(...future.stdout)
[10:20:33.226]         }, add = TRUE)
[10:20:33.226]     }
[10:20:33.226]     ...future.frame <- base::sys.nframe()
[10:20:33.226]     ...future.conditions <- base::list()
[10:20:33.226]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.226]     if (FALSE) {
[10:20:33.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.226]     }
[10:20:33.226]     ...future.result <- base::tryCatch({
[10:20:33.226]         base::withCallingHandlers({
[10:20:33.226]             ...future.value <- base::withVisible(base::local({
[10:20:33.226]                 42L
[10:20:33.226]                 stop("Woops")
[10:20:33.226]             }))
[10:20:33.226]             future::FutureResult(value = ...future.value$value, 
[10:20:33.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.226]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.226]                     ...future.globalenv.names))
[10:20:33.226]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.226]         }, condition = base::local({
[10:20:33.226]             c <- base::c
[10:20:33.226]             inherits <- base::inherits
[10:20:33.226]             invokeRestart <- base::invokeRestart
[10:20:33.226]             length <- base::length
[10:20:33.226]             list <- base::list
[10:20:33.226]             seq.int <- base::seq.int
[10:20:33.226]             signalCondition <- base::signalCondition
[10:20:33.226]             sys.calls <- base::sys.calls
[10:20:33.226]             `[[` <- base::`[[`
[10:20:33.226]             `+` <- base::`+`
[10:20:33.226]             `<<-` <- base::`<<-`
[10:20:33.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.226]                   3L)]
[10:20:33.226]             }
[10:20:33.226]             function(cond) {
[10:20:33.226]                 is_error <- inherits(cond, "error")
[10:20:33.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.226]                   NULL)
[10:20:33.226]                 if (is_error) {
[10:20:33.226]                   sessionInformation <- function() {
[10:20:33.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.226]                       search = base::search(), system = base::Sys.info())
[10:20:33.226]                   }
[10:20:33.226]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.226]                     cond$call), session = sessionInformation(), 
[10:20:33.226]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.226]                   signalCondition(cond)
[10:20:33.226]                 }
[10:20:33.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.226]                 "immediateCondition"))) {
[10:20:33.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.226]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.226]                   if (TRUE && !signal) {
[10:20:33.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.226]                     {
[10:20:33.226]                       inherits <- base::inherits
[10:20:33.226]                       invokeRestart <- base::invokeRestart
[10:20:33.226]                       is.null <- base::is.null
[10:20:33.226]                       muffled <- FALSE
[10:20:33.226]                       if (inherits(cond, "message")) {
[10:20:33.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.226]                         if (muffled) 
[10:20:33.226]                           invokeRestart("muffleMessage")
[10:20:33.226]                       }
[10:20:33.226]                       else if (inherits(cond, "warning")) {
[10:20:33.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.226]                         if (muffled) 
[10:20:33.226]                           invokeRestart("muffleWarning")
[10:20:33.226]                       }
[10:20:33.226]                       else if (inherits(cond, "condition")) {
[10:20:33.226]                         if (!is.null(pattern)) {
[10:20:33.226]                           computeRestarts <- base::computeRestarts
[10:20:33.226]                           grepl <- base::grepl
[10:20:33.226]                           restarts <- computeRestarts(cond)
[10:20:33.226]                           for (restart in restarts) {
[10:20:33.226]                             name <- restart$name
[10:20:33.226]                             if (is.null(name)) 
[10:20:33.226]                               next
[10:20:33.226]                             if (!grepl(pattern, name)) 
[10:20:33.226]                               next
[10:20:33.226]                             invokeRestart(restart)
[10:20:33.226]                             muffled <- TRUE
[10:20:33.226]                             break
[10:20:33.226]                           }
[10:20:33.226]                         }
[10:20:33.226]                       }
[10:20:33.226]                       invisible(muffled)
[10:20:33.226]                     }
[10:20:33.226]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.226]                   }
[10:20:33.226]                 }
[10:20:33.226]                 else {
[10:20:33.226]                   if (TRUE) {
[10:20:33.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.226]                     {
[10:20:33.226]                       inherits <- base::inherits
[10:20:33.226]                       invokeRestart <- base::invokeRestart
[10:20:33.226]                       is.null <- base::is.null
[10:20:33.226]                       muffled <- FALSE
[10:20:33.226]                       if (inherits(cond, "message")) {
[10:20:33.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.226]                         if (muffled) 
[10:20:33.226]                           invokeRestart("muffleMessage")
[10:20:33.226]                       }
[10:20:33.226]                       else if (inherits(cond, "warning")) {
[10:20:33.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.226]                         if (muffled) 
[10:20:33.226]                           invokeRestart("muffleWarning")
[10:20:33.226]                       }
[10:20:33.226]                       else if (inherits(cond, "condition")) {
[10:20:33.226]                         if (!is.null(pattern)) {
[10:20:33.226]                           computeRestarts <- base::computeRestarts
[10:20:33.226]                           grepl <- base::grepl
[10:20:33.226]                           restarts <- computeRestarts(cond)
[10:20:33.226]                           for (restart in restarts) {
[10:20:33.226]                             name <- restart$name
[10:20:33.226]                             if (is.null(name)) 
[10:20:33.226]                               next
[10:20:33.226]                             if (!grepl(pattern, name)) 
[10:20:33.226]                               next
[10:20:33.226]                             invokeRestart(restart)
[10:20:33.226]                             muffled <- TRUE
[10:20:33.226]                             break
[10:20:33.226]                           }
[10:20:33.226]                         }
[10:20:33.226]                       }
[10:20:33.226]                       invisible(muffled)
[10:20:33.226]                     }
[10:20:33.226]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.226]                   }
[10:20:33.226]                 }
[10:20:33.226]             }
[10:20:33.226]         }))
[10:20:33.226]     }, error = function(ex) {
[10:20:33.226]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.226]                 ...future.rng), started = ...future.startTime, 
[10:20:33.226]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.226]             version = "1.8"), class = "FutureResult")
[10:20:33.226]     }, finally = {
[10:20:33.226]         if (!identical(...future.workdir, getwd())) 
[10:20:33.226]             setwd(...future.workdir)
[10:20:33.226]         {
[10:20:33.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.226]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.226]             }
[10:20:33.226]             base::options(...future.oldOptions)
[10:20:33.226]             if (.Platform$OS.type == "windows") {
[10:20:33.226]                 old_names <- names(...future.oldEnvVars)
[10:20:33.226]                 envs <- base::Sys.getenv()
[10:20:33.226]                 names <- names(envs)
[10:20:33.226]                 common <- intersect(names, old_names)
[10:20:33.226]                 added <- setdiff(names, old_names)
[10:20:33.226]                 removed <- setdiff(old_names, names)
[10:20:33.226]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.226]                   envs[common]]
[10:20:33.226]                 NAMES <- toupper(changed)
[10:20:33.226]                 args <- list()
[10:20:33.226]                 for (kk in seq_along(NAMES)) {
[10:20:33.226]                   name <- changed[[kk]]
[10:20:33.226]                   NAME <- NAMES[[kk]]
[10:20:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.226]                     next
[10:20:33.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.226]                 }
[10:20:33.226]                 NAMES <- toupper(added)
[10:20:33.226]                 for (kk in seq_along(NAMES)) {
[10:20:33.226]                   name <- added[[kk]]
[10:20:33.226]                   NAME <- NAMES[[kk]]
[10:20:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.226]                     next
[10:20:33.226]                   args[[name]] <- ""
[10:20:33.226]                 }
[10:20:33.226]                 NAMES <- toupper(removed)
[10:20:33.226]                 for (kk in seq_along(NAMES)) {
[10:20:33.226]                   name <- removed[[kk]]
[10:20:33.226]                   NAME <- NAMES[[kk]]
[10:20:33.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.226]                     next
[10:20:33.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.226]                 }
[10:20:33.226]                 if (length(args) > 0) 
[10:20:33.226]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.226]             }
[10:20:33.226]             else {
[10:20:33.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.226]             }
[10:20:33.226]             {
[10:20:33.226]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.226]                   0L) {
[10:20:33.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.226]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.226]                   base::options(opts)
[10:20:33.226]                 }
[10:20:33.226]                 {
[10:20:33.226]                   {
[10:20:33.226]                     NULL
[10:20:33.226]                     RNGkind("Mersenne-Twister")
[10:20:33.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.226]                       inherits = FALSE)
[10:20:33.226]                   }
[10:20:33.226]                   options(future.plan = NULL)
[10:20:33.226]                   if (is.na(NA_character_)) 
[10:20:33.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.226]                     .init = FALSE)
[10:20:33.226]                 }
[10:20:33.226]             }
[10:20:33.226]         }
[10:20:33.226]     })
[10:20:33.226]     if (TRUE) {
[10:20:33.226]         base::sink(type = "output", split = FALSE)
[10:20:33.226]         if (TRUE) {
[10:20:33.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.226]         }
[10:20:33.226]         else {
[10:20:33.226]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.226]         }
[10:20:33.226]         base::close(...future.stdout)
[10:20:33.226]         ...future.stdout <- NULL
[10:20:33.226]     }
[10:20:33.226]     ...future.result$conditions <- ...future.conditions
[10:20:33.226]     ...future.result$finished <- base::Sys.time()
[10:20:33.226]     ...future.result
[10:20:33.226] }
[10:20:33.228] plan(): Setting new future strategy stack:
[10:20:33.228] List of future strategies:
[10:20:33.228] 1. sequential:
[10:20:33.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.228]    - tweaked: FALSE
[10:20:33.228]    - call: NULL
[10:20:33.229] plan(): nbrOfWorkers() = 1
[10:20:33.229] plan(): Setting new future strategy stack:
[10:20:33.230] List of future strategies:
[10:20:33.230] 1. sequential:
[10:20:33.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.230]    - tweaked: FALSE
[10:20:33.230]    - call: future::plan("sequential")
[10:20:33.230] plan(): nbrOfWorkers() = 1
[10:20:33.230] SequentialFuture started (and completed)
[10:20:33.230] signalConditions() ...
[10:20:33.230]  - include = ‘immediateCondition’
[10:20:33.230]  - exclude = 
[10:20:33.231]  - resignal = FALSE
[10:20:33.231]  - Number of conditions: 1
[10:20:33.231] signalConditions() ... done
[10:20:33.231] - Launch lazy future ... done
[10:20:33.231] run() for ‘SequentialFuture’ ... done
> vs <- value(ll, signal = FALSE)
[10:20:33.231] resolve() on list ...
[10:20:33.231]  recursive: 0
[10:20:33.232]  length: 2
[10:20:33.232] 
[10:20:33.232] resolved() for ‘SequentialFuture’ ...
[10:20:33.232] - state: ‘finished’
[10:20:33.232] - run: TRUE
[10:20:33.232] - result: ‘FutureResult’
[10:20:33.232] resolved() for ‘SequentialFuture’ ... done
[10:20:33.232] Future #1
[10:20:33.232] signalConditions() ...
[10:20:33.232]  - include = ‘immediateCondition’
[10:20:33.234]  - exclude = 
[10:20:33.234]  - resignal = FALSE
[10:20:33.234]  - Number of conditions: 1
[10:20:33.234] signalConditions() ... done
[10:20:33.234] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:33.234] - nx: 2
[10:20:33.234] - relay: TRUE
[10:20:33.234] - stdout: TRUE
[10:20:33.235] - signal: FALSE
[10:20:33.235] - resignal: FALSE
[10:20:33.235] - force: TRUE
[10:20:33.235] - relayed: [n=2] FALSE, FALSE
[10:20:33.235] - queued futures: [n=2] FALSE, FALSE
[10:20:33.235]  - until=1
[10:20:33.235]  - relaying element #1
[10:20:33.235] signalConditions() ...
[10:20:33.235]  - include = ‘immediateCondition’
[10:20:33.235]  - exclude = 
[10:20:33.235]  - resignal = FALSE
[10:20:33.235]  - Number of conditions: 1
[10:20:33.236] signalConditions() ... done
[10:20:33.236] - relayed: [n=2] TRUE, FALSE
[10:20:33.236] - queued futures: [n=2] TRUE, FALSE
[10:20:33.236] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:33.236]  length: 1 (resolved future 1)
[10:20:33.236] resolved() for ‘SequentialFuture’ ...
[10:20:33.236] - state: ‘finished’
[10:20:33.236] - run: TRUE
[10:20:33.236] - result: ‘FutureResult’
[10:20:33.236] resolved() for ‘SequentialFuture’ ... done
[10:20:33.237] Future #2
[10:20:33.237] signalConditions() ...
[10:20:33.237]  - include = ‘immediateCondition’
[10:20:33.237]  - exclude = 
[10:20:33.237]  - resignal = FALSE
[10:20:33.237]  - Number of conditions: 1
[10:20:33.237] signalConditions() ... done
[10:20:33.237] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:20:33.237] - nx: 2
[10:20:33.237] - relay: TRUE
[10:20:33.237] - stdout: TRUE
[10:20:33.237] - signal: FALSE
[10:20:33.238] - resignal: FALSE
[10:20:33.238] - force: TRUE
[10:20:33.238] - relayed: [n=2] TRUE, FALSE
[10:20:33.238] - queued futures: [n=2] TRUE, FALSE
[10:20:33.238]  - until=2
[10:20:33.238]  - relaying element #2
[10:20:33.238] signalConditions() ...
[10:20:33.238]  - include = ‘immediateCondition’
[10:20:33.238]  - exclude = 
[10:20:33.238]  - resignal = FALSE
[10:20:33.238]  - Number of conditions: 1
[10:20:33.238] signalConditions() ... done
[10:20:33.239] - relayed: [n=2] TRUE, TRUE
[10:20:33.239] - queued futures: [n=2] TRUE, TRUE
[10:20:33.239] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:20:33.239]  length: 0 (resolved future 2)
[10:20:33.239] Relaying remaining futures
[10:20:33.239] signalConditionsASAP(NULL, pos=0) ...
[10:20:33.239] - nx: 2
[10:20:33.239] - relay: TRUE
[10:20:33.239] - stdout: TRUE
[10:20:33.239] - signal: FALSE
[10:20:33.239] - resignal: FALSE
[10:20:33.239] - force: TRUE
[10:20:33.240] - relayed: [n=2] TRUE, TRUE
[10:20:33.240] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:33.240] - relayed: [n=2] TRUE, TRUE
[10:20:33.240] - queued futures: [n=2] TRUE, TRUE
[10:20:33.240] signalConditionsASAP(NULL, pos=0) ... done
[10:20:33.240] resolve() on list ... DONE
[10:20:33.240] signalConditions() ...
[10:20:33.240]  - include = ‘immediateCondition’
[10:20:33.240]  - exclude = 
[10:20:33.240]  - resignal = FALSE
[10:20:33.240]  - Number of conditions: 1
[10:20:33.240] signalConditions() ... done
[10:20:33.241] signalConditions() ...
[10:20:33.241]  - include = ‘immediateCondition’
[10:20:33.241]  - exclude = 
[10:20:33.241]  - resignal = FALSE
[10:20:33.241]  - Number of conditions: 1
[10:20:33.241] signalConditions() ... done
> calls <- backtrace(ll[[2]])
[10:20:33.241] resolved() for ‘SequentialFuture’ ...
[10:20:33.241] - state: ‘finished’
[10:20:33.241] - run: TRUE
[10:20:33.242] - result: ‘FutureResult’
[10:20:33.242] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> message("*** backtrace( ) - subsetting ... DONE")
*** backtrace( ) - subsetting ... DONE
> 
> 
> message("*** backtrace( ) - exceptions ...")
*** backtrace( ) - exceptions ...
> 
> message("- No condition ...")
- No condition ...
> f <- future(42L)
[10:20:33.242] getGlobalsAndPackages() ...
[10:20:33.242] Searching for globals...
[10:20:33.242] 
[10:20:33.243] Searching for globals ... DONE
[10:20:33.243] - globals: [0] <none>
[10:20:33.243] getGlobalsAndPackages() ... DONE
[10:20:33.243] run() for ‘Future’ ...
[10:20:33.243] - state: ‘created’
[10:20:33.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.244]   - Field: ‘label’
[10:20:33.244]   - Field: ‘local’
[10:20:33.244]   - Field: ‘owner’
[10:20:33.244]   - Field: ‘envir’
[10:20:33.244]   - Field: ‘packages’
[10:20:33.244]   - Field: ‘gc’
[10:20:33.244]   - Field: ‘conditions’
[10:20:33.244]   - Field: ‘expr’
[10:20:33.244]   - Field: ‘uuid’
[10:20:33.244]   - Field: ‘seed’
[10:20:33.244]   - Field: ‘version’
[10:20:33.244]   - Field: ‘result’
[10:20:33.245]   - Field: ‘asynchronous’
[10:20:33.245]   - Field: ‘calls’
[10:20:33.245]   - Field: ‘globals’
[10:20:33.245]   - Field: ‘stdout’
[10:20:33.245]   - Field: ‘earlySignal’
[10:20:33.245]   - Field: ‘lazy’
[10:20:33.245]   - Field: ‘state’
[10:20:33.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.245] - Launch lazy future ...
[10:20:33.245] Packages needed by the future expression (n = 0): <none>
[10:20:33.245] Packages needed by future strategies (n = 0): <none>
[10:20:33.246] {
[10:20:33.246]     {
[10:20:33.246]         {
[10:20:33.246]             ...future.startTime <- base::Sys.time()
[10:20:33.246]             {
[10:20:33.246]                 {
[10:20:33.246]                   {
[10:20:33.246]                     base::local({
[10:20:33.246]                       has_future <- base::requireNamespace("future", 
[10:20:33.246]                         quietly = TRUE)
[10:20:33.246]                       if (has_future) {
[10:20:33.246]                         ns <- base::getNamespace("future")
[10:20:33.246]                         version <- ns[[".package"]][["version"]]
[10:20:33.246]                         if (is.null(version)) 
[10:20:33.246]                           version <- utils::packageVersion("future")
[10:20:33.246]                       }
[10:20:33.246]                       else {
[10:20:33.246]                         version <- NULL
[10:20:33.246]                       }
[10:20:33.246]                       if (!has_future || version < "1.8.0") {
[10:20:33.246]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.246]                           "", base::R.version$version.string), 
[10:20:33.246]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.246]                             "release", "version")], collapse = " "), 
[10:20:33.246]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.246]                           info)
[10:20:33.246]                         info <- base::paste(info, collapse = "; ")
[10:20:33.246]                         if (!has_future) {
[10:20:33.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.246]                             info)
[10:20:33.246]                         }
[10:20:33.246]                         else {
[10:20:33.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.246]                             info, version)
[10:20:33.246]                         }
[10:20:33.246]                         base::stop(msg)
[10:20:33.246]                       }
[10:20:33.246]                     })
[10:20:33.246]                   }
[10:20:33.246]                   ...future.strategy.old <- future::plan("list")
[10:20:33.246]                   options(future.plan = NULL)
[10:20:33.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.246]                 }
[10:20:33.246]                 ...future.workdir <- getwd()
[10:20:33.246]             }
[10:20:33.246]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.246]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.246]         }
[10:20:33.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.246]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.246]             base::names(...future.oldOptions))
[10:20:33.246]     }
[10:20:33.246]     if (FALSE) {
[10:20:33.246]     }
[10:20:33.246]     else {
[10:20:33.246]         if (TRUE) {
[10:20:33.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.246]                 open = "w")
[10:20:33.246]         }
[10:20:33.246]         else {
[10:20:33.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.246]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.246]         }
[10:20:33.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.246]             base::sink(type = "output", split = FALSE)
[10:20:33.246]             base::close(...future.stdout)
[10:20:33.246]         }, add = TRUE)
[10:20:33.246]     }
[10:20:33.246]     ...future.frame <- base::sys.nframe()
[10:20:33.246]     ...future.conditions <- base::list()
[10:20:33.246]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.246]     if (FALSE) {
[10:20:33.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.246]     }
[10:20:33.246]     ...future.result <- base::tryCatch({
[10:20:33.246]         base::withCallingHandlers({
[10:20:33.246]             ...future.value <- base::withVisible(base::local(42L))
[10:20:33.246]             future::FutureResult(value = ...future.value$value, 
[10:20:33.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.246]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.246]                     ...future.globalenv.names))
[10:20:33.246]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.246]         }, condition = base::local({
[10:20:33.246]             c <- base::c
[10:20:33.246]             inherits <- base::inherits
[10:20:33.246]             invokeRestart <- base::invokeRestart
[10:20:33.246]             length <- base::length
[10:20:33.246]             list <- base::list
[10:20:33.246]             seq.int <- base::seq.int
[10:20:33.246]             signalCondition <- base::signalCondition
[10:20:33.246]             sys.calls <- base::sys.calls
[10:20:33.246]             `[[` <- base::`[[`
[10:20:33.246]             `+` <- base::`+`
[10:20:33.246]             `<<-` <- base::`<<-`
[10:20:33.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.246]                   3L)]
[10:20:33.246]             }
[10:20:33.246]             function(cond) {
[10:20:33.246]                 is_error <- inherits(cond, "error")
[10:20:33.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.246]                   NULL)
[10:20:33.246]                 if (is_error) {
[10:20:33.246]                   sessionInformation <- function() {
[10:20:33.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.246]                       search = base::search(), system = base::Sys.info())
[10:20:33.246]                   }
[10:20:33.246]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.246]                     cond$call), session = sessionInformation(), 
[10:20:33.246]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.246]                   signalCondition(cond)
[10:20:33.246]                 }
[10:20:33.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.246]                 "immediateCondition"))) {
[10:20:33.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.246]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.246]                   if (TRUE && !signal) {
[10:20:33.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.246]                     {
[10:20:33.246]                       inherits <- base::inherits
[10:20:33.246]                       invokeRestart <- base::invokeRestart
[10:20:33.246]                       is.null <- base::is.null
[10:20:33.246]                       muffled <- FALSE
[10:20:33.246]                       if (inherits(cond, "message")) {
[10:20:33.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.246]                         if (muffled) 
[10:20:33.246]                           invokeRestart("muffleMessage")
[10:20:33.246]                       }
[10:20:33.246]                       else if (inherits(cond, "warning")) {
[10:20:33.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.246]                         if (muffled) 
[10:20:33.246]                           invokeRestart("muffleWarning")
[10:20:33.246]                       }
[10:20:33.246]                       else if (inherits(cond, "condition")) {
[10:20:33.246]                         if (!is.null(pattern)) {
[10:20:33.246]                           computeRestarts <- base::computeRestarts
[10:20:33.246]                           grepl <- base::grepl
[10:20:33.246]                           restarts <- computeRestarts(cond)
[10:20:33.246]                           for (restart in restarts) {
[10:20:33.246]                             name <- restart$name
[10:20:33.246]                             if (is.null(name)) 
[10:20:33.246]                               next
[10:20:33.246]                             if (!grepl(pattern, name)) 
[10:20:33.246]                               next
[10:20:33.246]                             invokeRestart(restart)
[10:20:33.246]                             muffled <- TRUE
[10:20:33.246]                             break
[10:20:33.246]                           }
[10:20:33.246]                         }
[10:20:33.246]                       }
[10:20:33.246]                       invisible(muffled)
[10:20:33.246]                     }
[10:20:33.246]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.246]                   }
[10:20:33.246]                 }
[10:20:33.246]                 else {
[10:20:33.246]                   if (TRUE) {
[10:20:33.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.246]                     {
[10:20:33.246]                       inherits <- base::inherits
[10:20:33.246]                       invokeRestart <- base::invokeRestart
[10:20:33.246]                       is.null <- base::is.null
[10:20:33.246]                       muffled <- FALSE
[10:20:33.246]                       if (inherits(cond, "message")) {
[10:20:33.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.246]                         if (muffled) 
[10:20:33.246]                           invokeRestart("muffleMessage")
[10:20:33.246]                       }
[10:20:33.246]                       else if (inherits(cond, "warning")) {
[10:20:33.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.246]                         if (muffled) 
[10:20:33.246]                           invokeRestart("muffleWarning")
[10:20:33.246]                       }
[10:20:33.246]                       else if (inherits(cond, "condition")) {
[10:20:33.246]                         if (!is.null(pattern)) {
[10:20:33.246]                           computeRestarts <- base::computeRestarts
[10:20:33.246]                           grepl <- base::grepl
[10:20:33.246]                           restarts <- computeRestarts(cond)
[10:20:33.246]                           for (restart in restarts) {
[10:20:33.246]                             name <- restart$name
[10:20:33.246]                             if (is.null(name)) 
[10:20:33.246]                               next
[10:20:33.246]                             if (!grepl(pattern, name)) 
[10:20:33.246]                               next
[10:20:33.246]                             invokeRestart(restart)
[10:20:33.246]                             muffled <- TRUE
[10:20:33.246]                             break
[10:20:33.246]                           }
[10:20:33.246]                         }
[10:20:33.246]                       }
[10:20:33.246]                       invisible(muffled)
[10:20:33.246]                     }
[10:20:33.246]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.246]                   }
[10:20:33.246]                 }
[10:20:33.246]             }
[10:20:33.246]         }))
[10:20:33.246]     }, error = function(ex) {
[10:20:33.246]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.246]                 ...future.rng), started = ...future.startTime, 
[10:20:33.246]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.246]             version = "1.8"), class = "FutureResult")
[10:20:33.246]     }, finally = {
[10:20:33.246]         if (!identical(...future.workdir, getwd())) 
[10:20:33.246]             setwd(...future.workdir)
[10:20:33.246]         {
[10:20:33.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.246]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.246]             }
[10:20:33.246]             base::options(...future.oldOptions)
[10:20:33.246]             if (.Platform$OS.type == "windows") {
[10:20:33.246]                 old_names <- names(...future.oldEnvVars)
[10:20:33.246]                 envs <- base::Sys.getenv()
[10:20:33.246]                 names <- names(envs)
[10:20:33.246]                 common <- intersect(names, old_names)
[10:20:33.246]                 added <- setdiff(names, old_names)
[10:20:33.246]                 removed <- setdiff(old_names, names)
[10:20:33.246]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.246]                   envs[common]]
[10:20:33.246]                 NAMES <- toupper(changed)
[10:20:33.246]                 args <- list()
[10:20:33.246]                 for (kk in seq_along(NAMES)) {
[10:20:33.246]                   name <- changed[[kk]]
[10:20:33.246]                   NAME <- NAMES[[kk]]
[10:20:33.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.246]                     next
[10:20:33.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.246]                 }
[10:20:33.246]                 NAMES <- toupper(added)
[10:20:33.246]                 for (kk in seq_along(NAMES)) {
[10:20:33.246]                   name <- added[[kk]]
[10:20:33.246]                   NAME <- NAMES[[kk]]
[10:20:33.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.246]                     next
[10:20:33.246]                   args[[name]] <- ""
[10:20:33.246]                 }
[10:20:33.246]                 NAMES <- toupper(removed)
[10:20:33.246]                 for (kk in seq_along(NAMES)) {
[10:20:33.246]                   name <- removed[[kk]]
[10:20:33.246]                   NAME <- NAMES[[kk]]
[10:20:33.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.246]                     next
[10:20:33.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.246]                 }
[10:20:33.246]                 if (length(args) > 0) 
[10:20:33.246]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.246]             }
[10:20:33.246]             else {
[10:20:33.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.246]             }
[10:20:33.246]             {
[10:20:33.246]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.246]                   0L) {
[10:20:33.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.246]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.246]                   base::options(opts)
[10:20:33.246]                 }
[10:20:33.246]                 {
[10:20:33.246]                   {
[10:20:33.246]                     NULL
[10:20:33.246]                     RNGkind("Mersenne-Twister")
[10:20:33.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.246]                       inherits = FALSE)
[10:20:33.246]                   }
[10:20:33.246]                   options(future.plan = NULL)
[10:20:33.246]                   if (is.na(NA_character_)) 
[10:20:33.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.246]                     .init = FALSE)
[10:20:33.246]                 }
[10:20:33.246]             }
[10:20:33.246]         }
[10:20:33.246]     })
[10:20:33.246]     if (TRUE) {
[10:20:33.246]         base::sink(type = "output", split = FALSE)
[10:20:33.246]         if (TRUE) {
[10:20:33.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.246]         }
[10:20:33.246]         else {
[10:20:33.246]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.246]         }
[10:20:33.246]         base::close(...future.stdout)
[10:20:33.246]         ...future.stdout <- NULL
[10:20:33.246]     }
[10:20:33.246]     ...future.result$conditions <- ...future.conditions
[10:20:33.246]     ...future.result$finished <- base::Sys.time()
[10:20:33.246]     ...future.result
[10:20:33.246] }
[10:20:33.248] plan(): Setting new future strategy stack:
[10:20:33.248] List of future strategies:
[10:20:33.248] 1. sequential:
[10:20:33.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.248]    - tweaked: FALSE
[10:20:33.248]    - call: NULL
[10:20:33.248] plan(): nbrOfWorkers() = 1
[10:20:33.249] plan(): Setting new future strategy stack:
[10:20:33.249] List of future strategies:
[10:20:33.249] 1. sequential:
[10:20:33.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.249]    - tweaked: FALSE
[10:20:33.249]    - call: future::plan("sequential")
[10:20:33.250] plan(): nbrOfWorkers() = 1
[10:20:33.250] SequentialFuture started (and completed)
[10:20:33.250] - Launch lazy future ... done
[10:20:33.250] run() for ‘SequentialFuture’ ... done
> res <- tryCatch(backtrace(f), error = identity)
[10:20:33.250] resolved() for ‘SequentialFuture’ ...
[10:20:33.250] - state: ‘finished’
[10:20:33.250] - run: TRUE
[10:20:33.250] - result: ‘FutureResult’
[10:20:33.251] resolved() for ‘SequentialFuture’ ... done
> print(res)
<simpleError: No error was caught for this future: ‘f’>
> stopifnot(inherits(res, "error"))
> 
> message("- No call stack ...")
- No call stack ...
> f <- future({ 42L; stop("Woops") })
[10:20:33.251] getGlobalsAndPackages() ...
[10:20:33.251] Searching for globals...
[10:20:33.252] - globals found: [2] ‘{’, ‘stop’
[10:20:33.252] Searching for globals ... DONE
[10:20:33.252] Resolving globals: FALSE
[10:20:33.252] 
[10:20:33.252] 
[10:20:33.252] getGlobalsAndPackages() ... DONE
[10:20:33.253] run() for ‘Future’ ...
[10:20:33.253] - state: ‘created’
[10:20:33.253] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:33.253] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:33.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:33.253]   - Field: ‘label’
[10:20:33.253]   - Field: ‘local’
[10:20:33.253]   - Field: ‘owner’
[10:20:33.254]   - Field: ‘envir’
[10:20:33.254]   - Field: ‘packages’
[10:20:33.254]   - Field: ‘gc’
[10:20:33.254]   - Field: ‘conditions’
[10:20:33.254]   - Field: ‘expr’
[10:20:33.254]   - Field: ‘uuid’
[10:20:33.254]   - Field: ‘seed’
[10:20:33.254]   - Field: ‘version’
[10:20:33.254]   - Field: ‘result’
[10:20:33.254]   - Field: ‘asynchronous’
[10:20:33.254]   - Field: ‘calls’
[10:20:33.254]   - Field: ‘globals’
[10:20:33.255]   - Field: ‘stdout’
[10:20:33.255]   - Field: ‘earlySignal’
[10:20:33.255]   - Field: ‘lazy’
[10:20:33.255]   - Field: ‘state’
[10:20:33.255] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:33.255] - Launch lazy future ...
[10:20:33.255] Packages needed by the future expression (n = 0): <none>
[10:20:33.255] Packages needed by future strategies (n = 0): <none>
[10:20:33.256] {
[10:20:33.256]     {
[10:20:33.256]         {
[10:20:33.256]             ...future.startTime <- base::Sys.time()
[10:20:33.256]             {
[10:20:33.256]                 {
[10:20:33.256]                   {
[10:20:33.256]                     base::local({
[10:20:33.256]                       has_future <- base::requireNamespace("future", 
[10:20:33.256]                         quietly = TRUE)
[10:20:33.256]                       if (has_future) {
[10:20:33.256]                         ns <- base::getNamespace("future")
[10:20:33.256]                         version <- ns[[".package"]][["version"]]
[10:20:33.256]                         if (is.null(version)) 
[10:20:33.256]                           version <- utils::packageVersion("future")
[10:20:33.256]                       }
[10:20:33.256]                       else {
[10:20:33.256]                         version <- NULL
[10:20:33.256]                       }
[10:20:33.256]                       if (!has_future || version < "1.8.0") {
[10:20:33.256]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.256]                           "", base::R.version$version.string), 
[10:20:33.256]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:33.256]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.256]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.256]                             "release", "version")], collapse = " "), 
[10:20:33.256]                           hostname = base::Sys.info()[["nodename"]])
[10:20:33.256]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.256]                           info)
[10:20:33.256]                         info <- base::paste(info, collapse = "; ")
[10:20:33.256]                         if (!has_future) {
[10:20:33.256]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.256]                             info)
[10:20:33.256]                         }
[10:20:33.256]                         else {
[10:20:33.256]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.256]                             info, version)
[10:20:33.256]                         }
[10:20:33.256]                         base::stop(msg)
[10:20:33.256]                       }
[10:20:33.256]                     })
[10:20:33.256]                   }
[10:20:33.256]                   ...future.strategy.old <- future::plan("list")
[10:20:33.256]                   options(future.plan = NULL)
[10:20:33.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.256]                 }
[10:20:33.256]                 ...future.workdir <- getwd()
[10:20:33.256]             }
[10:20:33.256]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.256]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.256]         }
[10:20:33.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.256]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.256]             base::names(...future.oldOptions))
[10:20:33.256]     }
[10:20:33.256]     if (FALSE) {
[10:20:33.256]     }
[10:20:33.256]     else {
[10:20:33.256]         if (TRUE) {
[10:20:33.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.256]                 open = "w")
[10:20:33.256]         }
[10:20:33.256]         else {
[10:20:33.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.256]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.256]         }
[10:20:33.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.256]             base::sink(type = "output", split = FALSE)
[10:20:33.256]             base::close(...future.stdout)
[10:20:33.256]         }, add = TRUE)
[10:20:33.256]     }
[10:20:33.256]     ...future.frame <- base::sys.nframe()
[10:20:33.256]     ...future.conditions <- base::list()
[10:20:33.256]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.256]     if (FALSE) {
[10:20:33.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.256]     }
[10:20:33.256]     ...future.result <- base::tryCatch({
[10:20:33.256]         base::withCallingHandlers({
[10:20:33.256]             ...future.value <- base::withVisible(base::local({
[10:20:33.256]                 42L
[10:20:33.256]                 stop("Woops")
[10:20:33.256]             }))
[10:20:33.256]             future::FutureResult(value = ...future.value$value, 
[10:20:33.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.256]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.256]                     ...future.globalenv.names))
[10:20:33.256]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.256]         }, condition = base::local({
[10:20:33.256]             c <- base::c
[10:20:33.256]             inherits <- base::inherits
[10:20:33.256]             invokeRestart <- base::invokeRestart
[10:20:33.256]             length <- base::length
[10:20:33.256]             list <- base::list
[10:20:33.256]             seq.int <- base::seq.int
[10:20:33.256]             signalCondition <- base::signalCondition
[10:20:33.256]             sys.calls <- base::sys.calls
[10:20:33.256]             `[[` <- base::`[[`
[10:20:33.256]             `+` <- base::`+`
[10:20:33.256]             `<<-` <- base::`<<-`
[10:20:33.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.256]                   3L)]
[10:20:33.256]             }
[10:20:33.256]             function(cond) {
[10:20:33.256]                 is_error <- inherits(cond, "error")
[10:20:33.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.256]                   NULL)
[10:20:33.256]                 if (is_error) {
[10:20:33.256]                   sessionInformation <- function() {
[10:20:33.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.256]                       search = base::search(), system = base::Sys.info())
[10:20:33.256]                   }
[10:20:33.256]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.256]                     cond$call), session = sessionInformation(), 
[10:20:33.256]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.256]                   signalCondition(cond)
[10:20:33.256]                 }
[10:20:33.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.256]                 "immediateCondition"))) {
[10:20:33.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.256]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.256]                   if (TRUE && !signal) {
[10:20:33.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.256]                     {
[10:20:33.256]                       inherits <- base::inherits
[10:20:33.256]                       invokeRestart <- base::invokeRestart
[10:20:33.256]                       is.null <- base::is.null
[10:20:33.256]                       muffled <- FALSE
[10:20:33.256]                       if (inherits(cond, "message")) {
[10:20:33.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.256]                         if (muffled) 
[10:20:33.256]                           invokeRestart("muffleMessage")
[10:20:33.256]                       }
[10:20:33.256]                       else if (inherits(cond, "warning")) {
[10:20:33.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.256]                         if (muffled) 
[10:20:33.256]                           invokeRestart("muffleWarning")
[10:20:33.256]                       }
[10:20:33.256]                       else if (inherits(cond, "condition")) {
[10:20:33.256]                         if (!is.null(pattern)) {
[10:20:33.256]                           computeRestarts <- base::computeRestarts
[10:20:33.256]                           grepl <- base::grepl
[10:20:33.256]                           restarts <- computeRestarts(cond)
[10:20:33.256]                           for (restart in restarts) {
[10:20:33.256]                             name <- restart$name
[10:20:33.256]                             if (is.null(name)) 
[10:20:33.256]                               next
[10:20:33.256]                             if (!grepl(pattern, name)) 
[10:20:33.256]                               next
[10:20:33.256]                             invokeRestart(restart)
[10:20:33.256]                             muffled <- TRUE
[10:20:33.256]                             break
[10:20:33.256]                           }
[10:20:33.256]                         }
[10:20:33.256]                       }
[10:20:33.256]                       invisible(muffled)
[10:20:33.256]                     }
[10:20:33.256]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.256]                   }
[10:20:33.256]                 }
[10:20:33.256]                 else {
[10:20:33.256]                   if (TRUE) {
[10:20:33.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.256]                     {
[10:20:33.256]                       inherits <- base::inherits
[10:20:33.256]                       invokeRestart <- base::invokeRestart
[10:20:33.256]                       is.null <- base::is.null
[10:20:33.256]                       muffled <- FALSE
[10:20:33.256]                       if (inherits(cond, "message")) {
[10:20:33.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.256]                         if (muffled) 
[10:20:33.256]                           invokeRestart("muffleMessage")
[10:20:33.256]                       }
[10:20:33.256]                       else if (inherits(cond, "warning")) {
[10:20:33.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.256]                         if (muffled) 
[10:20:33.256]                           invokeRestart("muffleWarning")
[10:20:33.256]                       }
[10:20:33.256]                       else if (inherits(cond, "condition")) {
[10:20:33.256]                         if (!is.null(pattern)) {
[10:20:33.256]                           computeRestarts <- base::computeRestarts
[10:20:33.256]                           grepl <- base::grepl
[10:20:33.256]                           restarts <- computeRestarts(cond)
[10:20:33.256]                           for (restart in restarts) {
[10:20:33.256]                             name <- restart$name
[10:20:33.256]                             if (is.null(name)) 
[10:20:33.256]                               next
[10:20:33.256]                             if (!grepl(pattern, name)) 
[10:20:33.256]                               next
[10:20:33.256]                             invokeRestart(restart)
[10:20:33.256]                             muffled <- TRUE
[10:20:33.256]                             break
[10:20:33.256]                           }
[10:20:33.256]                         }
[10:20:33.256]                       }
[10:20:33.256]                       invisible(muffled)
[10:20:33.256]                     }
[10:20:33.256]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.256]                   }
[10:20:33.256]                 }
[10:20:33.256]             }
[10:20:33.256]         }))
[10:20:33.256]     }, error = function(ex) {
[10:20:33.256]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.256]                 ...future.rng), started = ...future.startTime, 
[10:20:33.256]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.256]             version = "1.8"), class = "FutureResult")
[10:20:33.256]     }, finally = {
[10:20:33.256]         if (!identical(...future.workdir, getwd())) 
[10:20:33.256]             setwd(...future.workdir)
[10:20:33.256]         {
[10:20:33.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.256]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.256]             }
[10:20:33.256]             base::options(...future.oldOptions)
[10:20:33.256]             if (.Platform$OS.type == "windows") {
[10:20:33.256]                 old_names <- names(...future.oldEnvVars)
[10:20:33.256]                 envs <- base::Sys.getenv()
[10:20:33.256]                 names <- names(envs)
[10:20:33.256]                 common <- intersect(names, old_names)
[10:20:33.256]                 added <- setdiff(names, old_names)
[10:20:33.256]                 removed <- setdiff(old_names, names)
[10:20:33.256]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.256]                   envs[common]]
[10:20:33.256]                 NAMES <- toupper(changed)
[10:20:33.256]                 args <- list()
[10:20:33.256]                 for (kk in seq_along(NAMES)) {
[10:20:33.256]                   name <- changed[[kk]]
[10:20:33.256]                   NAME <- NAMES[[kk]]
[10:20:33.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.256]                     next
[10:20:33.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.256]                 }
[10:20:33.256]                 NAMES <- toupper(added)
[10:20:33.256]                 for (kk in seq_along(NAMES)) {
[10:20:33.256]                   name <- added[[kk]]
[10:20:33.256]                   NAME <- NAMES[[kk]]
[10:20:33.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.256]                     next
[10:20:33.256]                   args[[name]] <- ""
[10:20:33.256]                 }
[10:20:33.256]                 NAMES <- toupper(removed)
[10:20:33.256]                 for (kk in seq_along(NAMES)) {
[10:20:33.256]                   name <- removed[[kk]]
[10:20:33.256]                   NAME <- NAMES[[kk]]
[10:20:33.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.256]                     next
[10:20:33.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.256]                 }
[10:20:33.256]                 if (length(args) > 0) 
[10:20:33.256]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.256]             }
[10:20:33.256]             else {
[10:20:33.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.256]             }
[10:20:33.256]             {
[10:20:33.256]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.256]                   0L) {
[10:20:33.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.256]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.256]                   base::options(opts)
[10:20:33.256]                 }
[10:20:33.256]                 {
[10:20:33.256]                   {
[10:20:33.256]                     NULL
[10:20:33.256]                     RNGkind("Mersenne-Twister")
[10:20:33.256]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:33.256]                       inherits = FALSE)
[10:20:33.256]                   }
[10:20:33.256]                   options(future.plan = NULL)
[10:20:33.256]                   if (is.na(NA_character_)) 
[10:20:33.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.256]                     .init = FALSE)
[10:20:33.256]                 }
[10:20:33.256]             }
[10:20:33.256]         }
[10:20:33.256]     })
[10:20:33.256]     if (TRUE) {
[10:20:33.256]         base::sink(type = "output", split = FALSE)
[10:20:33.256]         if (TRUE) {
[10:20:33.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.256]         }
[10:20:33.256]         else {
[10:20:33.256]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.256]         }
[10:20:33.256]         base::close(...future.stdout)
[10:20:33.256]         ...future.stdout <- NULL
[10:20:33.256]     }
[10:20:33.256]     ...future.result$conditions <- ...future.conditions
[10:20:33.256]     ...future.result$finished <- base::Sys.time()
[10:20:33.256]     ...future.result
[10:20:33.256] }
[10:20:33.257] plan(): Setting new future strategy stack:
[10:20:33.257] List of future strategies:
[10:20:33.257] 1. sequential:
[10:20:33.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.257]    - tweaked: FALSE
[10:20:33.257]    - call: NULL
[10:20:33.258] plan(): nbrOfWorkers() = 1
[10:20:33.259] plan(): Setting new future strategy stack:
[10:20:33.259] List of future strategies:
[10:20:33.259] 1. sequential:
[10:20:33.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:33.259]    - tweaked: FALSE
[10:20:33.259]    - call: future::plan("sequential")
[10:20:33.259] plan(): nbrOfWorkers() = 1
[10:20:33.259] SequentialFuture started (and completed)
[10:20:33.259] signalConditions() ...
[10:20:33.259]  - include = ‘immediateCondition’
[10:20:33.260]  - exclude = 
[10:20:33.260]  - resignal = FALSE
[10:20:33.260]  - Number of conditions: 1
[10:20:33.260] signalConditions() ... done
[10:20:33.260] - Launch lazy future ... done
[10:20:33.260] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[10:20:33.260] signalConditions() ...
[10:20:33.260]  - include = ‘immediateCondition’
[10:20:33.260]  - exclude = 
[10:20:33.260]  - resignal = FALSE
[10:20:33.260]  - Number of conditions: 1
[10:20:33.260] signalConditions() ... done
> 
> if (availableCores() >= 2L) {
+   message("- Non-resolved future ...")
+   plan(multisession, workers = 2L)
+   f <- future({ Sys.sleep(3); 42L; stop("Woops") })
+   res <- tryCatch(backtrace(f), error = identity)
+   print(res)
+   stopifnot(inherits(res, "error"))
+   
+   ## If we don't resolve the future, the cluster of workers will not
+   ## be able to shut down naturally. They will eventually time out,
+   ## but that will happen long after 'R CMD check' terminates. Because
+   ## of this, 'R CMD check --as-cran' will report on "detritus in the
+   ## temp directory" when running on MS Windows.  This happens because
+   ## MS Windows doesn't shut down child processes as Linux and macOS
+   ## does when the main R session terminates.
+   resolve(f)
+ }
- Non-resolved future ...
[10:20:33.265] plan(): Setting new future strategy stack:
[10:20:33.265] List of future strategies:
[10:20:33.265] 1. multisession:
[10:20:33.265]    - args: function (..., workers = 2L, envir = parent.frame())
[10:20:33.265]    - tweaked: TRUE
[10:20:33.265]    - call: plan(multisession, workers = 2L)
[10:20:33.276] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:20:33.276] multisession:
[10:20:33.276] - args: function (..., workers = 2L, envir = parent.frame())
[10:20:33.276] - tweaked: TRUE
[10:20:33.276] - call: plan(multisession, workers = 2L)
[10:20:33.277] getGlobalsAndPackages() ...
[10:20:33.277] Not searching for globals
[10:20:33.277] - globals: [0] <none>
[10:20:33.277] getGlobalsAndPackages() ... DONE
[10:20:33.755] Packages needed by the future expression (n = 0): <none>
[10:20:33.756] Packages needed by future strategies (n = 0): <none>
[10:20:33.756] {
[10:20:33.756]     {
[10:20:33.756]         {
[10:20:33.756]             ...future.startTime <- base::Sys.time()
[10:20:33.756]             {
[10:20:33.756]                 {
[10:20:33.756]                   {
[10:20:33.756]                     {
[10:20:33.756]                       base::local({
[10:20:33.756]                         has_future <- base::requireNamespace("future", 
[10:20:33.756]                           quietly = TRUE)
[10:20:33.756]                         if (has_future) {
[10:20:33.756]                           ns <- base::getNamespace("future")
[10:20:33.756]                           version <- ns[[".package"]][["version"]]
[10:20:33.756]                           if (is.null(version)) 
[10:20:33.756]                             version <- utils::packageVersion("future")
[10:20:33.756]                         }
[10:20:33.756]                         else {
[10:20:33.756]                           version <- NULL
[10:20:33.756]                         }
[10:20:33.756]                         if (!has_future || version < "1.8.0") {
[10:20:33.756]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.756]                             "", base::R.version$version.string), 
[10:20:33.756]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:33.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.756]                               "release", "version")], collapse = " "), 
[10:20:33.756]                             hostname = base::Sys.info()[["nodename"]])
[10:20:33.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.756]                             info)
[10:20:33.756]                           info <- base::paste(info, collapse = "; ")
[10:20:33.756]                           if (!has_future) {
[10:20:33.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.756]                               info)
[10:20:33.756]                           }
[10:20:33.756]                           else {
[10:20:33.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.756]                               info, version)
[10:20:33.756]                           }
[10:20:33.756]                           base::stop(msg)
[10:20:33.756]                         }
[10:20:33.756]                       })
[10:20:33.756]                     }
[10:20:33.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:33.756]                     base::options(mc.cores = 1L)
[10:20:33.756]                   }
[10:20:33.756]                   ...future.strategy.old <- future::plan("list")
[10:20:33.756]                   options(future.plan = NULL)
[10:20:33.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.756]                 }
[10:20:33.756]                 ...future.workdir <- getwd()
[10:20:33.756]             }
[10:20:33.756]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.756]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.756]         }
[10:20:33.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.756]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.756]             base::names(...future.oldOptions))
[10:20:33.756]     }
[10:20:33.756]     if (FALSE) {
[10:20:33.756]     }
[10:20:33.756]     else {
[10:20:33.756]         if (TRUE) {
[10:20:33.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.756]                 open = "w")
[10:20:33.756]         }
[10:20:33.756]         else {
[10:20:33.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.756]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.756]         }
[10:20:33.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.756]             base::sink(type = "output", split = FALSE)
[10:20:33.756]             base::close(...future.stdout)
[10:20:33.756]         }, add = TRUE)
[10:20:33.756]     }
[10:20:33.756]     ...future.frame <- base::sys.nframe()
[10:20:33.756]     ...future.conditions <- base::list()
[10:20:33.756]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.756]     if (FALSE) {
[10:20:33.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.756]     }
[10:20:33.756]     ...future.result <- base::tryCatch({
[10:20:33.756]         base::withCallingHandlers({
[10:20:33.756]             ...future.value <- base::withVisible(base::local({
[10:20:33.756]                 ...future.makeSendCondition <- base::local({
[10:20:33.756]                   sendCondition <- NULL
[10:20:33.756]                   function(frame = 1L) {
[10:20:33.756]                     if (is.function(sendCondition)) 
[10:20:33.756]                       return(sendCondition)
[10:20:33.756]                     ns <- getNamespace("parallel")
[10:20:33.756]                     if (exists("sendData", mode = "function", 
[10:20:33.756]                       envir = ns)) {
[10:20:33.756]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:33.756]                         envir = ns)
[10:20:33.756]                       envir <- sys.frame(frame)
[10:20:33.756]                       master <- NULL
[10:20:33.756]                       while (!identical(envir, .GlobalEnv) && 
[10:20:33.756]                         !identical(envir, emptyenv())) {
[10:20:33.756]                         if (exists("master", mode = "list", envir = envir, 
[10:20:33.756]                           inherits = FALSE)) {
[10:20:33.756]                           master <- get("master", mode = "list", 
[10:20:33.756]                             envir = envir, inherits = FALSE)
[10:20:33.756]                           if (inherits(master, c("SOCKnode", 
[10:20:33.756]                             "SOCK0node"))) {
[10:20:33.756]                             sendCondition <<- function(cond) {
[10:20:33.756]                               data <- list(type = "VALUE", value = cond, 
[10:20:33.756]                                 success = TRUE)
[10:20:33.756]                               parallel_sendData(master, data)
[10:20:33.756]                             }
[10:20:33.756]                             return(sendCondition)
[10:20:33.756]                           }
[10:20:33.756]                         }
[10:20:33.756]                         frame <- frame + 1L
[10:20:33.756]                         envir <- sys.frame(frame)
[10:20:33.756]                       }
[10:20:33.756]                     }
[10:20:33.756]                     sendCondition <<- function(cond) NULL
[10:20:33.756]                   }
[10:20:33.756]                 })
[10:20:33.756]                 withCallingHandlers({
[10:20:33.756]                   NA
[10:20:33.756]                 }, immediateCondition = function(cond) {
[10:20:33.756]                   sendCondition <- ...future.makeSendCondition()
[10:20:33.756]                   sendCondition(cond)
[10:20:33.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.756]                   {
[10:20:33.756]                     inherits <- base::inherits
[10:20:33.756]                     invokeRestart <- base::invokeRestart
[10:20:33.756]                     is.null <- base::is.null
[10:20:33.756]                     muffled <- FALSE
[10:20:33.756]                     if (inherits(cond, "message")) {
[10:20:33.756]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:33.756]                       if (muffled) 
[10:20:33.756]                         invokeRestart("muffleMessage")
[10:20:33.756]                     }
[10:20:33.756]                     else if (inherits(cond, "warning")) {
[10:20:33.756]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:33.756]                       if (muffled) 
[10:20:33.756]                         invokeRestart("muffleWarning")
[10:20:33.756]                     }
[10:20:33.756]                     else if (inherits(cond, "condition")) {
[10:20:33.756]                       if (!is.null(pattern)) {
[10:20:33.756]                         computeRestarts <- base::computeRestarts
[10:20:33.756]                         grepl <- base::grepl
[10:20:33.756]                         restarts <- computeRestarts(cond)
[10:20:33.756]                         for (restart in restarts) {
[10:20:33.756]                           name <- restart$name
[10:20:33.756]                           if (is.null(name)) 
[10:20:33.756]                             next
[10:20:33.756]                           if (!grepl(pattern, name)) 
[10:20:33.756]                             next
[10:20:33.756]                           invokeRestart(restart)
[10:20:33.756]                           muffled <- TRUE
[10:20:33.756]                           break
[10:20:33.756]                         }
[10:20:33.756]                       }
[10:20:33.756]                     }
[10:20:33.756]                     invisible(muffled)
[10:20:33.756]                   }
[10:20:33.756]                   muffleCondition(cond)
[10:20:33.756]                 })
[10:20:33.756]             }))
[10:20:33.756]             future::FutureResult(value = ...future.value$value, 
[10:20:33.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.756]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.756]                     ...future.globalenv.names))
[10:20:33.756]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.756]         }, condition = base::local({
[10:20:33.756]             c <- base::c
[10:20:33.756]             inherits <- base::inherits
[10:20:33.756]             invokeRestart <- base::invokeRestart
[10:20:33.756]             length <- base::length
[10:20:33.756]             list <- base::list
[10:20:33.756]             seq.int <- base::seq.int
[10:20:33.756]             signalCondition <- base::signalCondition
[10:20:33.756]             sys.calls <- base::sys.calls
[10:20:33.756]             `[[` <- base::`[[`
[10:20:33.756]             `+` <- base::`+`
[10:20:33.756]             `<<-` <- base::`<<-`
[10:20:33.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.756]                   3L)]
[10:20:33.756]             }
[10:20:33.756]             function(cond) {
[10:20:33.756]                 is_error <- inherits(cond, "error")
[10:20:33.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.756]                   NULL)
[10:20:33.756]                 if (is_error) {
[10:20:33.756]                   sessionInformation <- function() {
[10:20:33.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.756]                       search = base::search(), system = base::Sys.info())
[10:20:33.756]                   }
[10:20:33.756]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.756]                     cond$call), session = sessionInformation(), 
[10:20:33.756]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.756]                   signalCondition(cond)
[10:20:33.756]                 }
[10:20:33.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.756]                 "immediateCondition"))) {
[10:20:33.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.756]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.756]                   if (TRUE && !signal) {
[10:20:33.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.756]                     {
[10:20:33.756]                       inherits <- base::inherits
[10:20:33.756]                       invokeRestart <- base::invokeRestart
[10:20:33.756]                       is.null <- base::is.null
[10:20:33.756]                       muffled <- FALSE
[10:20:33.756]                       if (inherits(cond, "message")) {
[10:20:33.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.756]                         if (muffled) 
[10:20:33.756]                           invokeRestart("muffleMessage")
[10:20:33.756]                       }
[10:20:33.756]                       else if (inherits(cond, "warning")) {
[10:20:33.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.756]                         if (muffled) 
[10:20:33.756]                           invokeRestart("muffleWarning")
[10:20:33.756]                       }
[10:20:33.756]                       else if (inherits(cond, "condition")) {
[10:20:33.756]                         if (!is.null(pattern)) {
[10:20:33.756]                           computeRestarts <- base::computeRestarts
[10:20:33.756]                           grepl <- base::grepl
[10:20:33.756]                           restarts <- computeRestarts(cond)
[10:20:33.756]                           for (restart in restarts) {
[10:20:33.756]                             name <- restart$name
[10:20:33.756]                             if (is.null(name)) 
[10:20:33.756]                               next
[10:20:33.756]                             if (!grepl(pattern, name)) 
[10:20:33.756]                               next
[10:20:33.756]                             invokeRestart(restart)
[10:20:33.756]                             muffled <- TRUE
[10:20:33.756]                             break
[10:20:33.756]                           }
[10:20:33.756]                         }
[10:20:33.756]                       }
[10:20:33.756]                       invisible(muffled)
[10:20:33.756]                     }
[10:20:33.756]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.756]                   }
[10:20:33.756]                 }
[10:20:33.756]                 else {
[10:20:33.756]                   if (TRUE) {
[10:20:33.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.756]                     {
[10:20:33.756]                       inherits <- base::inherits
[10:20:33.756]                       invokeRestart <- base::invokeRestart
[10:20:33.756]                       is.null <- base::is.null
[10:20:33.756]                       muffled <- FALSE
[10:20:33.756]                       if (inherits(cond, "message")) {
[10:20:33.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.756]                         if (muffled) 
[10:20:33.756]                           invokeRestart("muffleMessage")
[10:20:33.756]                       }
[10:20:33.756]                       else if (inherits(cond, "warning")) {
[10:20:33.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.756]                         if (muffled) 
[10:20:33.756]                           invokeRestart("muffleWarning")
[10:20:33.756]                       }
[10:20:33.756]                       else if (inherits(cond, "condition")) {
[10:20:33.756]                         if (!is.null(pattern)) {
[10:20:33.756]                           computeRestarts <- base::computeRestarts
[10:20:33.756]                           grepl <- base::grepl
[10:20:33.756]                           restarts <- computeRestarts(cond)
[10:20:33.756]                           for (restart in restarts) {
[10:20:33.756]                             name <- restart$name
[10:20:33.756]                             if (is.null(name)) 
[10:20:33.756]                               next
[10:20:33.756]                             if (!grepl(pattern, name)) 
[10:20:33.756]                               next
[10:20:33.756]                             invokeRestart(restart)
[10:20:33.756]                             muffled <- TRUE
[10:20:33.756]                             break
[10:20:33.756]                           }
[10:20:33.756]                         }
[10:20:33.756]                       }
[10:20:33.756]                       invisible(muffled)
[10:20:33.756]                     }
[10:20:33.756]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.756]                   }
[10:20:33.756]                 }
[10:20:33.756]             }
[10:20:33.756]         }))
[10:20:33.756]     }, error = function(ex) {
[10:20:33.756]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.756]                 ...future.rng), started = ...future.startTime, 
[10:20:33.756]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.756]             version = "1.8"), class = "FutureResult")
[10:20:33.756]     }, finally = {
[10:20:33.756]         if (!identical(...future.workdir, getwd())) 
[10:20:33.756]             setwd(...future.workdir)
[10:20:33.756]         {
[10:20:33.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.756]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.756]             }
[10:20:33.756]             base::options(...future.oldOptions)
[10:20:33.756]             if (.Platform$OS.type == "windows") {
[10:20:33.756]                 old_names <- names(...future.oldEnvVars)
[10:20:33.756]                 envs <- base::Sys.getenv()
[10:20:33.756]                 names <- names(envs)
[10:20:33.756]                 common <- intersect(names, old_names)
[10:20:33.756]                 added <- setdiff(names, old_names)
[10:20:33.756]                 removed <- setdiff(old_names, names)
[10:20:33.756]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.756]                   envs[common]]
[10:20:33.756]                 NAMES <- toupper(changed)
[10:20:33.756]                 args <- list()
[10:20:33.756]                 for (kk in seq_along(NAMES)) {
[10:20:33.756]                   name <- changed[[kk]]
[10:20:33.756]                   NAME <- NAMES[[kk]]
[10:20:33.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.756]                     next
[10:20:33.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.756]                 }
[10:20:33.756]                 NAMES <- toupper(added)
[10:20:33.756]                 for (kk in seq_along(NAMES)) {
[10:20:33.756]                   name <- added[[kk]]
[10:20:33.756]                   NAME <- NAMES[[kk]]
[10:20:33.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.756]                     next
[10:20:33.756]                   args[[name]] <- ""
[10:20:33.756]                 }
[10:20:33.756]                 NAMES <- toupper(removed)
[10:20:33.756]                 for (kk in seq_along(NAMES)) {
[10:20:33.756]                   name <- removed[[kk]]
[10:20:33.756]                   NAME <- NAMES[[kk]]
[10:20:33.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.756]                     next
[10:20:33.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.756]                 }
[10:20:33.756]                 if (length(args) > 0) 
[10:20:33.756]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.756]             }
[10:20:33.756]             else {
[10:20:33.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.756]             }
[10:20:33.756]             {
[10:20:33.756]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.756]                   0L) {
[10:20:33.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.756]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.756]                   base::options(opts)
[10:20:33.756]                 }
[10:20:33.756]                 {
[10:20:33.756]                   {
[10:20:33.756]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:33.756]                     NULL
[10:20:33.756]                   }
[10:20:33.756]                   options(future.plan = NULL)
[10:20:33.756]                   if (is.na(NA_character_)) 
[10:20:33.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.756]                     .init = FALSE)
[10:20:33.756]                 }
[10:20:33.756]             }
[10:20:33.756]         }
[10:20:33.756]     })
[10:20:33.756]     if (TRUE) {
[10:20:33.756]         base::sink(type = "output", split = FALSE)
[10:20:33.756]         if (TRUE) {
[10:20:33.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.756]         }
[10:20:33.756]         else {
[10:20:33.756]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.756]         }
[10:20:33.756]         base::close(...future.stdout)
[10:20:33.756]         ...future.stdout <- NULL
[10:20:33.756]     }
[10:20:33.756]     ...future.result$conditions <- ...future.conditions
[10:20:33.756]     ...future.result$finished <- base::Sys.time()
[10:20:33.756]     ...future.result
[10:20:33.756] }
[10:20:33.809] MultisessionFuture started
[10:20:33.809] result() for ClusterFuture ...
[10:20:33.810] receiveMessageFromWorker() for ClusterFuture ...
[10:20:33.810] - Validating connection of MultisessionFuture
[10:20:33.841] - received message: FutureResult
[10:20:33.841] - Received FutureResult
[10:20:33.843] - Erased future from FutureRegistry
[10:20:33.844] result() for ClusterFuture ...
[10:20:33.844] - result already collected: FutureResult
[10:20:33.844] result() for ClusterFuture ... done
[10:20:33.844] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:33.844] result() for ClusterFuture ... done
[10:20:33.844] result() for ClusterFuture ...
[10:20:33.844] - result already collected: FutureResult
[10:20:33.844] result() for ClusterFuture ... done
[10:20:33.844] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:20:33.845] plan(): nbrOfWorkers() = 2
[10:20:33.845] getGlobalsAndPackages() ...
[10:20:33.845] Searching for globals...
[10:20:33.846] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘stop’
[10:20:33.846] Searching for globals ... DONE
[10:20:33.846] Resolving globals: FALSE
[10:20:33.847] 
[10:20:33.847] 
[10:20:33.847] getGlobalsAndPackages() ... DONE
[10:20:33.847] run() for ‘Future’ ...
[10:20:33.847] - state: ‘created’
[10:20:33.847] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:33.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:33.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:33.860]   - Field: ‘node’
[10:20:33.860]   - Field: ‘label’
[10:20:33.860]   - Field: ‘local’
[10:20:33.861]   - Field: ‘owner’
[10:20:33.861]   - Field: ‘envir’
[10:20:33.861]   - Field: ‘workers’
[10:20:33.861]   - Field: ‘packages’
[10:20:33.861]   - Field: ‘gc’
[10:20:33.861]   - Field: ‘conditions’
[10:20:33.861]   - Field: ‘persistent’
[10:20:33.861]   - Field: ‘expr’
[10:20:33.861]   - Field: ‘uuid’
[10:20:33.861]   - Field: ‘seed’
[10:20:33.861]   - Field: ‘version’
[10:20:33.861]   - Field: ‘result’
[10:20:33.862]   - Field: ‘asynchronous’
[10:20:33.862]   - Field: ‘calls’
[10:20:33.862]   - Field: ‘globals’
[10:20:33.862]   - Field: ‘stdout’
[10:20:33.862]   - Field: ‘earlySignal’
[10:20:33.862]   - Field: ‘lazy’
[10:20:33.862]   - Field: ‘state’
[10:20:33.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:33.862] - Launch lazy future ...
[10:20:33.862] Packages needed by the future expression (n = 0): <none>
[10:20:33.863] Packages needed by future strategies (n = 0): <none>
[10:20:33.863] {
[10:20:33.863]     {
[10:20:33.863]         {
[10:20:33.863]             ...future.startTime <- base::Sys.time()
[10:20:33.863]             {
[10:20:33.863]                 {
[10:20:33.863]                   {
[10:20:33.863]                     {
[10:20:33.863]                       base::local({
[10:20:33.863]                         has_future <- base::requireNamespace("future", 
[10:20:33.863]                           quietly = TRUE)
[10:20:33.863]                         if (has_future) {
[10:20:33.863]                           ns <- base::getNamespace("future")
[10:20:33.863]                           version <- ns[[".package"]][["version"]]
[10:20:33.863]                           if (is.null(version)) 
[10:20:33.863]                             version <- utils::packageVersion("future")
[10:20:33.863]                         }
[10:20:33.863]                         else {
[10:20:33.863]                           version <- NULL
[10:20:33.863]                         }
[10:20:33.863]                         if (!has_future || version < "1.8.0") {
[10:20:33.863]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:33.863]                             "", base::R.version$version.string), 
[10:20:33.863]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:33.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:33.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:33.863]                               "release", "version")], collapse = " "), 
[10:20:33.863]                             hostname = base::Sys.info()[["nodename"]])
[10:20:33.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:33.863]                             info)
[10:20:33.863]                           info <- base::paste(info, collapse = "; ")
[10:20:33.863]                           if (!has_future) {
[10:20:33.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:33.863]                               info)
[10:20:33.863]                           }
[10:20:33.863]                           else {
[10:20:33.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:33.863]                               info, version)
[10:20:33.863]                           }
[10:20:33.863]                           base::stop(msg)
[10:20:33.863]                         }
[10:20:33.863]                       })
[10:20:33.863]                     }
[10:20:33.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:33.863]                     base::options(mc.cores = 1L)
[10:20:33.863]                   }
[10:20:33.863]                   ...future.strategy.old <- future::plan("list")
[10:20:33.863]                   options(future.plan = NULL)
[10:20:33.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:33.863]                 }
[10:20:33.863]                 ...future.workdir <- getwd()
[10:20:33.863]             }
[10:20:33.863]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:33.863]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:33.863]         }
[10:20:33.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:33.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:33.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:33.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:33.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:33.863]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:33.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:33.863]             base::names(...future.oldOptions))
[10:20:33.863]     }
[10:20:33.863]     if (FALSE) {
[10:20:33.863]     }
[10:20:33.863]     else {
[10:20:33.863]         if (TRUE) {
[10:20:33.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:33.863]                 open = "w")
[10:20:33.863]         }
[10:20:33.863]         else {
[10:20:33.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:33.863]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:33.863]         }
[10:20:33.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:33.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:33.863]             base::sink(type = "output", split = FALSE)
[10:20:33.863]             base::close(...future.stdout)
[10:20:33.863]         }, add = TRUE)
[10:20:33.863]     }
[10:20:33.863]     ...future.frame <- base::sys.nframe()
[10:20:33.863]     ...future.conditions <- base::list()
[10:20:33.863]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:33.863]     if (FALSE) {
[10:20:33.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:33.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:33.863]     }
[10:20:33.863]     ...future.result <- base::tryCatch({
[10:20:33.863]         base::withCallingHandlers({
[10:20:33.863]             ...future.value <- base::withVisible(base::local({
[10:20:33.863]                 ...future.makeSendCondition <- base::local({
[10:20:33.863]                   sendCondition <- NULL
[10:20:33.863]                   function(frame = 1L) {
[10:20:33.863]                     if (is.function(sendCondition)) 
[10:20:33.863]                       return(sendCondition)
[10:20:33.863]                     ns <- getNamespace("parallel")
[10:20:33.863]                     if (exists("sendData", mode = "function", 
[10:20:33.863]                       envir = ns)) {
[10:20:33.863]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:33.863]                         envir = ns)
[10:20:33.863]                       envir <- sys.frame(frame)
[10:20:33.863]                       master <- NULL
[10:20:33.863]                       while (!identical(envir, .GlobalEnv) && 
[10:20:33.863]                         !identical(envir, emptyenv())) {
[10:20:33.863]                         if (exists("master", mode = "list", envir = envir, 
[10:20:33.863]                           inherits = FALSE)) {
[10:20:33.863]                           master <- get("master", mode = "list", 
[10:20:33.863]                             envir = envir, inherits = FALSE)
[10:20:33.863]                           if (inherits(master, c("SOCKnode", 
[10:20:33.863]                             "SOCK0node"))) {
[10:20:33.863]                             sendCondition <<- function(cond) {
[10:20:33.863]                               data <- list(type = "VALUE", value = cond, 
[10:20:33.863]                                 success = TRUE)
[10:20:33.863]                               parallel_sendData(master, data)
[10:20:33.863]                             }
[10:20:33.863]                             return(sendCondition)
[10:20:33.863]                           }
[10:20:33.863]                         }
[10:20:33.863]                         frame <- frame + 1L
[10:20:33.863]                         envir <- sys.frame(frame)
[10:20:33.863]                       }
[10:20:33.863]                     }
[10:20:33.863]                     sendCondition <<- function(cond) NULL
[10:20:33.863]                   }
[10:20:33.863]                 })
[10:20:33.863]                 withCallingHandlers({
[10:20:33.863]                   {
[10:20:33.863]                     Sys.sleep(3)
[10:20:33.863]                     42L
[10:20:33.863]                     stop("Woops")
[10:20:33.863]                   }
[10:20:33.863]                 }, immediateCondition = function(cond) {
[10:20:33.863]                   sendCondition <- ...future.makeSendCondition()
[10:20:33.863]                   sendCondition(cond)
[10:20:33.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.863]                   {
[10:20:33.863]                     inherits <- base::inherits
[10:20:33.863]                     invokeRestart <- base::invokeRestart
[10:20:33.863]                     is.null <- base::is.null
[10:20:33.863]                     muffled <- FALSE
[10:20:33.863]                     if (inherits(cond, "message")) {
[10:20:33.863]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:33.863]                       if (muffled) 
[10:20:33.863]                         invokeRestart("muffleMessage")
[10:20:33.863]                     }
[10:20:33.863]                     else if (inherits(cond, "warning")) {
[10:20:33.863]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:33.863]                       if (muffled) 
[10:20:33.863]                         invokeRestart("muffleWarning")
[10:20:33.863]                     }
[10:20:33.863]                     else if (inherits(cond, "condition")) {
[10:20:33.863]                       if (!is.null(pattern)) {
[10:20:33.863]                         computeRestarts <- base::computeRestarts
[10:20:33.863]                         grepl <- base::grepl
[10:20:33.863]                         restarts <- computeRestarts(cond)
[10:20:33.863]                         for (restart in restarts) {
[10:20:33.863]                           name <- restart$name
[10:20:33.863]                           if (is.null(name)) 
[10:20:33.863]                             next
[10:20:33.863]                           if (!grepl(pattern, name)) 
[10:20:33.863]                             next
[10:20:33.863]                           invokeRestart(restart)
[10:20:33.863]                           muffled <- TRUE
[10:20:33.863]                           break
[10:20:33.863]                         }
[10:20:33.863]                       }
[10:20:33.863]                     }
[10:20:33.863]                     invisible(muffled)
[10:20:33.863]                   }
[10:20:33.863]                   muffleCondition(cond)
[10:20:33.863]                 })
[10:20:33.863]             }))
[10:20:33.863]             future::FutureResult(value = ...future.value$value, 
[10:20:33.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.863]                   ...future.rng), globalenv = if (FALSE) 
[10:20:33.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:33.863]                     ...future.globalenv.names))
[10:20:33.863]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:33.863]         }, condition = base::local({
[10:20:33.863]             c <- base::c
[10:20:33.863]             inherits <- base::inherits
[10:20:33.863]             invokeRestart <- base::invokeRestart
[10:20:33.863]             length <- base::length
[10:20:33.863]             list <- base::list
[10:20:33.863]             seq.int <- base::seq.int
[10:20:33.863]             signalCondition <- base::signalCondition
[10:20:33.863]             sys.calls <- base::sys.calls
[10:20:33.863]             `[[` <- base::`[[`
[10:20:33.863]             `+` <- base::`+`
[10:20:33.863]             `<<-` <- base::`<<-`
[10:20:33.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:33.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:33.863]                   3L)]
[10:20:33.863]             }
[10:20:33.863]             function(cond) {
[10:20:33.863]                 is_error <- inherits(cond, "error")
[10:20:33.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:33.863]                   NULL)
[10:20:33.863]                 if (is_error) {
[10:20:33.863]                   sessionInformation <- function() {
[10:20:33.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:33.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:33.863]                       search = base::search(), system = base::Sys.info())
[10:20:33.863]                   }
[10:20:33.863]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:33.863]                     cond$call), session = sessionInformation(), 
[10:20:33.863]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:33.863]                   signalCondition(cond)
[10:20:33.863]                 }
[10:20:33.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:33.863]                 "immediateCondition"))) {
[10:20:33.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:33.863]                   ...future.conditions[[length(...future.conditions) + 
[10:20:33.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:33.863]                   if (TRUE && !signal) {
[10:20:33.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.863]                     {
[10:20:33.863]                       inherits <- base::inherits
[10:20:33.863]                       invokeRestart <- base::invokeRestart
[10:20:33.863]                       is.null <- base::is.null
[10:20:33.863]                       muffled <- FALSE
[10:20:33.863]                       if (inherits(cond, "message")) {
[10:20:33.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.863]                         if (muffled) 
[10:20:33.863]                           invokeRestart("muffleMessage")
[10:20:33.863]                       }
[10:20:33.863]                       else if (inherits(cond, "warning")) {
[10:20:33.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.863]                         if (muffled) 
[10:20:33.863]                           invokeRestart("muffleWarning")
[10:20:33.863]                       }
[10:20:33.863]                       else if (inherits(cond, "condition")) {
[10:20:33.863]                         if (!is.null(pattern)) {
[10:20:33.863]                           computeRestarts <- base::computeRestarts
[10:20:33.863]                           grepl <- base::grepl
[10:20:33.863]                           restarts <- computeRestarts(cond)
[10:20:33.863]                           for (restart in restarts) {
[10:20:33.863]                             name <- restart$name
[10:20:33.863]                             if (is.null(name)) 
[10:20:33.863]                               next
[10:20:33.863]                             if (!grepl(pattern, name)) 
[10:20:33.863]                               next
[10:20:33.863]                             invokeRestart(restart)
[10:20:33.863]                             muffled <- TRUE
[10:20:33.863]                             break
[10:20:33.863]                           }
[10:20:33.863]                         }
[10:20:33.863]                       }
[10:20:33.863]                       invisible(muffled)
[10:20:33.863]                     }
[10:20:33.863]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.863]                   }
[10:20:33.863]                 }
[10:20:33.863]                 else {
[10:20:33.863]                   if (TRUE) {
[10:20:33.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:33.863]                     {
[10:20:33.863]                       inherits <- base::inherits
[10:20:33.863]                       invokeRestart <- base::invokeRestart
[10:20:33.863]                       is.null <- base::is.null
[10:20:33.863]                       muffled <- FALSE
[10:20:33.863]                       if (inherits(cond, "message")) {
[10:20:33.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:33.863]                         if (muffled) 
[10:20:33.863]                           invokeRestart("muffleMessage")
[10:20:33.863]                       }
[10:20:33.863]                       else if (inherits(cond, "warning")) {
[10:20:33.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:33.863]                         if (muffled) 
[10:20:33.863]                           invokeRestart("muffleWarning")
[10:20:33.863]                       }
[10:20:33.863]                       else if (inherits(cond, "condition")) {
[10:20:33.863]                         if (!is.null(pattern)) {
[10:20:33.863]                           computeRestarts <- base::computeRestarts
[10:20:33.863]                           grepl <- base::grepl
[10:20:33.863]                           restarts <- computeRestarts(cond)
[10:20:33.863]                           for (restart in restarts) {
[10:20:33.863]                             name <- restart$name
[10:20:33.863]                             if (is.null(name)) 
[10:20:33.863]                               next
[10:20:33.863]                             if (!grepl(pattern, name)) 
[10:20:33.863]                               next
[10:20:33.863]                             invokeRestart(restart)
[10:20:33.863]                             muffled <- TRUE
[10:20:33.863]                             break
[10:20:33.863]                           }
[10:20:33.863]                         }
[10:20:33.863]                       }
[10:20:33.863]                       invisible(muffled)
[10:20:33.863]                     }
[10:20:33.863]                     muffleCondition(cond, pattern = "^muffle")
[10:20:33.863]                   }
[10:20:33.863]                 }
[10:20:33.863]             }
[10:20:33.863]         }))
[10:20:33.863]     }, error = function(ex) {
[10:20:33.863]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:33.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:33.863]                 ...future.rng), started = ...future.startTime, 
[10:20:33.863]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:33.863]             version = "1.8"), class = "FutureResult")
[10:20:33.863]     }, finally = {
[10:20:33.863]         if (!identical(...future.workdir, getwd())) 
[10:20:33.863]             setwd(...future.workdir)
[10:20:33.863]         {
[10:20:33.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:33.863]                 ...future.oldOptions$nwarnings <- NULL
[10:20:33.863]             }
[10:20:33.863]             base::options(...future.oldOptions)
[10:20:33.863]             if (.Platform$OS.type == "windows") {
[10:20:33.863]                 old_names <- names(...future.oldEnvVars)
[10:20:33.863]                 envs <- base::Sys.getenv()
[10:20:33.863]                 names <- names(envs)
[10:20:33.863]                 common <- intersect(names, old_names)
[10:20:33.863]                 added <- setdiff(names, old_names)
[10:20:33.863]                 removed <- setdiff(old_names, names)
[10:20:33.863]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:33.863]                   envs[common]]
[10:20:33.863]                 NAMES <- toupper(changed)
[10:20:33.863]                 args <- list()
[10:20:33.863]                 for (kk in seq_along(NAMES)) {
[10:20:33.863]                   name <- changed[[kk]]
[10:20:33.863]                   NAME <- NAMES[[kk]]
[10:20:33.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.863]                     next
[10:20:33.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.863]                 }
[10:20:33.863]                 NAMES <- toupper(added)
[10:20:33.863]                 for (kk in seq_along(NAMES)) {
[10:20:33.863]                   name <- added[[kk]]
[10:20:33.863]                   NAME <- NAMES[[kk]]
[10:20:33.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.863]                     next
[10:20:33.863]                   args[[name]] <- ""
[10:20:33.863]                 }
[10:20:33.863]                 NAMES <- toupper(removed)
[10:20:33.863]                 for (kk in seq_along(NAMES)) {
[10:20:33.863]                   name <- removed[[kk]]
[10:20:33.863]                   NAME <- NAMES[[kk]]
[10:20:33.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:33.863]                     next
[10:20:33.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:33.863]                 }
[10:20:33.863]                 if (length(args) > 0) 
[10:20:33.863]                   base::do.call(base::Sys.setenv, args = args)
[10:20:33.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:33.863]             }
[10:20:33.863]             else {
[10:20:33.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:33.863]             }
[10:20:33.863]             {
[10:20:33.863]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:33.863]                   0L) {
[10:20:33.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:33.863]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:33.863]                   base::options(opts)
[10:20:33.863]                 }
[10:20:33.863]                 {
[10:20:33.863]                   {
[10:20:33.863]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:33.863]                     NULL
[10:20:33.863]                   }
[10:20:33.863]                   options(future.plan = NULL)
[10:20:33.863]                   if (is.na(NA_character_)) 
[10:20:33.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:33.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:33.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:33.863]                     .init = FALSE)
[10:20:33.863]                 }
[10:20:33.863]             }
[10:20:33.863]         }
[10:20:33.863]     })
[10:20:33.863]     if (TRUE) {
[10:20:33.863]         base::sink(type = "output", split = FALSE)
[10:20:33.863]         if (TRUE) {
[10:20:33.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:33.863]         }
[10:20:33.863]         else {
[10:20:33.863]             ...future.result["stdout"] <- base::list(NULL)
[10:20:33.863]         }
[10:20:33.863]         base::close(...future.stdout)
[10:20:33.863]         ...future.stdout <- NULL
[10:20:33.863]     }
[10:20:33.863]     ...future.result$conditions <- ...future.conditions
[10:20:33.863]     ...future.result$finished <- base::Sys.time()
[10:20:33.863]     ...future.result
[10:20:33.863] }
[10:20:33.866] MultisessionFuture started
[10:20:33.866] - Launch lazy future ... done
[10:20:33.866] run() for ‘MultisessionFuture’ ... done
<simpleError: No error has been caught because the future is unresolved: ‘f’>
[10:20:36.923] receiveMessageFromWorker() for ClusterFuture ...
[10:20:36.924] - Validating connection of MultisessionFuture
[10:20:36.924] - received message: FutureResult
[10:20:36.924] - Received FutureResult
[10:20:36.924] - Erased future from FutureRegistry
[10:20:36.924] result() for ClusterFuture ...
[10:20:36.925] - result already collected: FutureResult
[10:20:36.925] result() for ClusterFuture ... done
[10:20:36.925] signalConditions() ...
[10:20:36.925]  - include = ‘immediateCondition’
[10:20:36.925]  - exclude = 
[10:20:36.925]  - resignal = FALSE
[10:20:36.925]  - Number of conditions: 1
[10:20:36.925] signalConditions() ... done
[10:20:36.925] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:36.926] A MultisessionFuture was resolved (result was not collected)
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    Sys.sleep(3)
    42L
    stop("Woops")
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: ccb6dfcf-a342-46b0-ad4b-610b2e7a29b1
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
> 
> message("*** backtrace( ) - exceptions ... DONE")
*** backtrace( ) - exceptions ... DONE
> 
> 
> message("*** backtrace( ) ... DONE")
*** backtrace( ) ... DONE
> 
> source("incl/end.R")
[10:20:36.927] plan(): Setting new future strategy stack:
[10:20:36.928] List of future strategies:
[10:20:36.928] 1. FutureStrategy:
[10:20:36.928]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:36.928]    - tweaked: FALSE
[10:20:36.928]    - call: future::plan(oplan)
[10:20:36.929] plan(): nbrOfWorkers() = 1
> 
