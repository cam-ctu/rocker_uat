
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:02.889] plan(): Setting new future strategy stack:
[08:27:02.890] List of future strategies:
[08:27:02.890] 1. sequential:
[08:27:02.890]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.890]    - tweaked: FALSE
[08:27:02.890]    - call: future::plan("sequential")
[08:27:02.905] plan(): nbrOfWorkers() = 1
> 
> message("*** backtrace( ) ...")
*** backtrace( ) ...
> 
> message("*** backtrace( ) - explicit future ...")
*** backtrace( ) - explicit future ...
> 
> f <- future({ 42L; stop("Woops") })
[08:27:02.922] getGlobalsAndPackages() ...
[08:27:02.922] Searching for globals...
[08:27:02.928] - globals found: [2] ‘{’, ‘stop’
[08:27:02.928] Searching for globals ... DONE
[08:27:02.928] Resolving globals: FALSE
[08:27:02.929] 
[08:27:02.929] 
[08:27:02.929] getGlobalsAndPackages() ... DONE
[08:27:02.930] run() for ‘Future’ ...
[08:27:02.930] - state: ‘created’
[08:27:02.930] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.930] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.930]   - Field: ‘label’
[08:27:02.931]   - Field: ‘local’
[08:27:02.931]   - Field: ‘owner’
[08:27:02.931]   - Field: ‘envir’
[08:27:02.931]   - Field: ‘packages’
[08:27:02.931]   - Field: ‘gc’
[08:27:02.931]   - Field: ‘conditions’
[08:27:02.931]   - Field: ‘expr’
[08:27:02.931]   - Field: ‘uuid’
[08:27:02.931]   - Field: ‘seed’
[08:27:02.931]   - Field: ‘version’
[08:27:02.931]   - Field: ‘result’
[08:27:02.932]   - Field: ‘asynchronous’
[08:27:02.932]   - Field: ‘calls’
[08:27:02.932]   - Field: ‘globals’
[08:27:02.932]   - Field: ‘stdout’
[08:27:02.932]   - Field: ‘earlySignal’
[08:27:02.932]   - Field: ‘lazy’
[08:27:02.932]   - Field: ‘state’
[08:27:02.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.932] - Launch lazy future ...
[08:27:02.933] Packages needed by the future expression (n = 0): <none>
[08:27:02.933] Packages needed by future strategies (n = 0): <none>
[08:27:02.934] {
[08:27:02.934]     {
[08:27:02.934]         {
[08:27:02.934]             ...future.startTime <- base::Sys.time()
[08:27:02.934]             {
[08:27:02.934]                 {
[08:27:02.934]                   {
[08:27:02.934]                     base::local({
[08:27:02.934]                       has_future <- base::requireNamespace("future", 
[08:27:02.934]                         quietly = TRUE)
[08:27:02.934]                       if (has_future) {
[08:27:02.934]                         ns <- base::getNamespace("future")
[08:27:02.934]                         version <- ns[[".package"]][["version"]]
[08:27:02.934]                         if (is.null(version)) 
[08:27:02.934]                           version <- utils::packageVersion("future")
[08:27:02.934]                       }
[08:27:02.934]                       else {
[08:27:02.934]                         version <- NULL
[08:27:02.934]                       }
[08:27:02.934]                       if (!has_future || version < "1.8.0") {
[08:27:02.934]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.934]                           "", base::R.version$version.string), 
[08:27:02.934]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.934]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.934]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.934]                             "release", "version")], collapse = " "), 
[08:27:02.934]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.934]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.934]                           info)
[08:27:02.934]                         info <- base::paste(info, collapse = "; ")
[08:27:02.934]                         if (!has_future) {
[08:27:02.934]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.934]                             info)
[08:27:02.934]                         }
[08:27:02.934]                         else {
[08:27:02.934]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.934]                             info, version)
[08:27:02.934]                         }
[08:27:02.934]                         base::stop(msg)
[08:27:02.934]                       }
[08:27:02.934]                     })
[08:27:02.934]                   }
[08:27:02.934]                   ...future.strategy.old <- future::plan("list")
[08:27:02.934]                   options(future.plan = NULL)
[08:27:02.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.934]                 }
[08:27:02.934]                 ...future.workdir <- getwd()
[08:27:02.934]             }
[08:27:02.934]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.934]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.934]         }
[08:27:02.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.934]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.934]             base::names(...future.oldOptions))
[08:27:02.934]     }
[08:27:02.934]     if (FALSE) {
[08:27:02.934]     }
[08:27:02.934]     else {
[08:27:02.934]         if (TRUE) {
[08:27:02.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.934]                 open = "w")
[08:27:02.934]         }
[08:27:02.934]         else {
[08:27:02.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.934]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.934]         }
[08:27:02.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.934]             base::sink(type = "output", split = FALSE)
[08:27:02.934]             base::close(...future.stdout)
[08:27:02.934]         }, add = TRUE)
[08:27:02.934]     }
[08:27:02.934]     ...future.frame <- base::sys.nframe()
[08:27:02.934]     ...future.conditions <- base::list()
[08:27:02.934]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.934]     if (FALSE) {
[08:27:02.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.934]     }
[08:27:02.934]     ...future.result <- base::tryCatch({
[08:27:02.934]         base::withCallingHandlers({
[08:27:02.934]             ...future.value <- base::withVisible(base::local({
[08:27:02.934]                 42L
[08:27:02.934]                 stop("Woops")
[08:27:02.934]             }))
[08:27:02.934]             future::FutureResult(value = ...future.value$value, 
[08:27:02.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.934]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.934]                     ...future.globalenv.names))
[08:27:02.934]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.934]         }, condition = base::local({
[08:27:02.934]             c <- base::c
[08:27:02.934]             inherits <- base::inherits
[08:27:02.934]             invokeRestart <- base::invokeRestart
[08:27:02.934]             length <- base::length
[08:27:02.934]             list <- base::list
[08:27:02.934]             seq.int <- base::seq.int
[08:27:02.934]             signalCondition <- base::signalCondition
[08:27:02.934]             sys.calls <- base::sys.calls
[08:27:02.934]             `[[` <- base::`[[`
[08:27:02.934]             `+` <- base::`+`
[08:27:02.934]             `<<-` <- base::`<<-`
[08:27:02.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.934]                   3L)]
[08:27:02.934]             }
[08:27:02.934]             function(cond) {
[08:27:02.934]                 is_error <- inherits(cond, "error")
[08:27:02.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.934]                   NULL)
[08:27:02.934]                 if (is_error) {
[08:27:02.934]                   sessionInformation <- function() {
[08:27:02.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.934]                       search = base::search(), system = base::Sys.info())
[08:27:02.934]                   }
[08:27:02.934]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.934]                     cond$call), session = sessionInformation(), 
[08:27:02.934]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.934]                   signalCondition(cond)
[08:27:02.934]                 }
[08:27:02.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.934]                 "immediateCondition"))) {
[08:27:02.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.934]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.934]                   if (TRUE && !signal) {
[08:27:02.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.934]                     {
[08:27:02.934]                       inherits <- base::inherits
[08:27:02.934]                       invokeRestart <- base::invokeRestart
[08:27:02.934]                       is.null <- base::is.null
[08:27:02.934]                       muffled <- FALSE
[08:27:02.934]                       if (inherits(cond, "message")) {
[08:27:02.934]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.934]                         if (muffled) 
[08:27:02.934]                           invokeRestart("muffleMessage")
[08:27:02.934]                       }
[08:27:02.934]                       else if (inherits(cond, "warning")) {
[08:27:02.934]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.934]                         if (muffled) 
[08:27:02.934]                           invokeRestart("muffleWarning")
[08:27:02.934]                       }
[08:27:02.934]                       else if (inherits(cond, "condition")) {
[08:27:02.934]                         if (!is.null(pattern)) {
[08:27:02.934]                           computeRestarts <- base::computeRestarts
[08:27:02.934]                           grepl <- base::grepl
[08:27:02.934]                           restarts <- computeRestarts(cond)
[08:27:02.934]                           for (restart in restarts) {
[08:27:02.934]                             name <- restart$name
[08:27:02.934]                             if (is.null(name)) 
[08:27:02.934]                               next
[08:27:02.934]                             if (!grepl(pattern, name)) 
[08:27:02.934]                               next
[08:27:02.934]                             invokeRestart(restart)
[08:27:02.934]                             muffled <- TRUE
[08:27:02.934]                             break
[08:27:02.934]                           }
[08:27:02.934]                         }
[08:27:02.934]                       }
[08:27:02.934]                       invisible(muffled)
[08:27:02.934]                     }
[08:27:02.934]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.934]                   }
[08:27:02.934]                 }
[08:27:02.934]                 else {
[08:27:02.934]                   if (TRUE) {
[08:27:02.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.934]                     {
[08:27:02.934]                       inherits <- base::inherits
[08:27:02.934]                       invokeRestart <- base::invokeRestart
[08:27:02.934]                       is.null <- base::is.null
[08:27:02.934]                       muffled <- FALSE
[08:27:02.934]                       if (inherits(cond, "message")) {
[08:27:02.934]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.934]                         if (muffled) 
[08:27:02.934]                           invokeRestart("muffleMessage")
[08:27:02.934]                       }
[08:27:02.934]                       else if (inherits(cond, "warning")) {
[08:27:02.934]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.934]                         if (muffled) 
[08:27:02.934]                           invokeRestart("muffleWarning")
[08:27:02.934]                       }
[08:27:02.934]                       else if (inherits(cond, "condition")) {
[08:27:02.934]                         if (!is.null(pattern)) {
[08:27:02.934]                           computeRestarts <- base::computeRestarts
[08:27:02.934]                           grepl <- base::grepl
[08:27:02.934]                           restarts <- computeRestarts(cond)
[08:27:02.934]                           for (restart in restarts) {
[08:27:02.934]                             name <- restart$name
[08:27:02.934]                             if (is.null(name)) 
[08:27:02.934]                               next
[08:27:02.934]                             if (!grepl(pattern, name)) 
[08:27:02.934]                               next
[08:27:02.934]                             invokeRestart(restart)
[08:27:02.934]                             muffled <- TRUE
[08:27:02.934]                             break
[08:27:02.934]                           }
[08:27:02.934]                         }
[08:27:02.934]                       }
[08:27:02.934]                       invisible(muffled)
[08:27:02.934]                     }
[08:27:02.934]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.934]                   }
[08:27:02.934]                 }
[08:27:02.934]             }
[08:27:02.934]         }))
[08:27:02.934]     }, error = function(ex) {
[08:27:02.934]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.934]                 ...future.rng), started = ...future.startTime, 
[08:27:02.934]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.934]             version = "1.8"), class = "FutureResult")
[08:27:02.934]     }, finally = {
[08:27:02.934]         if (!identical(...future.workdir, getwd())) 
[08:27:02.934]             setwd(...future.workdir)
[08:27:02.934]         {
[08:27:02.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.934]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.934]             }
[08:27:02.934]             base::options(...future.oldOptions)
[08:27:02.934]             if (.Platform$OS.type == "windows") {
[08:27:02.934]                 old_names <- names(...future.oldEnvVars)
[08:27:02.934]                 envs <- base::Sys.getenv()
[08:27:02.934]                 names <- names(envs)
[08:27:02.934]                 common <- intersect(names, old_names)
[08:27:02.934]                 added <- setdiff(names, old_names)
[08:27:02.934]                 removed <- setdiff(old_names, names)
[08:27:02.934]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.934]                   envs[common]]
[08:27:02.934]                 NAMES <- toupper(changed)
[08:27:02.934]                 args <- list()
[08:27:02.934]                 for (kk in seq_along(NAMES)) {
[08:27:02.934]                   name <- changed[[kk]]
[08:27:02.934]                   NAME <- NAMES[[kk]]
[08:27:02.934]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.934]                     next
[08:27:02.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.934]                 }
[08:27:02.934]                 NAMES <- toupper(added)
[08:27:02.934]                 for (kk in seq_along(NAMES)) {
[08:27:02.934]                   name <- added[[kk]]
[08:27:02.934]                   NAME <- NAMES[[kk]]
[08:27:02.934]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.934]                     next
[08:27:02.934]                   args[[name]] <- ""
[08:27:02.934]                 }
[08:27:02.934]                 NAMES <- toupper(removed)
[08:27:02.934]                 for (kk in seq_along(NAMES)) {
[08:27:02.934]                   name <- removed[[kk]]
[08:27:02.934]                   NAME <- NAMES[[kk]]
[08:27:02.934]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.934]                     next
[08:27:02.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.934]                 }
[08:27:02.934]                 if (length(args) > 0) 
[08:27:02.934]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.934]             }
[08:27:02.934]             else {
[08:27:02.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.934]             }
[08:27:02.934]             {
[08:27:02.934]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.934]                   0L) {
[08:27:02.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.934]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.934]                   base::options(opts)
[08:27:02.934]                 }
[08:27:02.934]                 {
[08:27:02.934]                   {
[08:27:02.934]                     NULL
[08:27:02.934]                     RNGkind("Mersenne-Twister")
[08:27:02.934]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.934]                       inherits = FALSE)
[08:27:02.934]                   }
[08:27:02.934]                   options(future.plan = NULL)
[08:27:02.934]                   if (is.na(NA_character_)) 
[08:27:02.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.934]                     .init = FALSE)
[08:27:02.934]                 }
[08:27:02.934]             }
[08:27:02.934]         }
[08:27:02.934]     })
[08:27:02.934]     if (TRUE) {
[08:27:02.934]         base::sink(type = "output", split = FALSE)
[08:27:02.934]         if (TRUE) {
[08:27:02.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.934]         }
[08:27:02.934]         else {
[08:27:02.934]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.934]         }
[08:27:02.934]         base::close(...future.stdout)
[08:27:02.934]         ...future.stdout <- NULL
[08:27:02.934]     }
[08:27:02.934]     ...future.result$conditions <- ...future.conditions
[08:27:02.934]     ...future.result$finished <- base::Sys.time()
[08:27:02.934]     ...future.result
[08:27:02.934] }
[08:27:02.936] plan(): Setting new future strategy stack:
[08:27:02.936] List of future strategies:
[08:27:02.936] 1. sequential:
[08:27:02.936]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.936]    - tweaked: FALSE
[08:27:02.936]    - call: NULL
[08:27:02.936] plan(): nbrOfWorkers() = 1
[08:27:02.938] plan(): Setting new future strategy stack:
[08:27:02.938] List of future strategies:
[08:27:02.938] 1. sequential:
[08:27:02.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.938]    - tweaked: FALSE
[08:27:02.938]    - call: future::plan("sequential")
[08:27:02.938] plan(): nbrOfWorkers() = 1
[08:27:02.938] SequentialFuture started (and completed)
[08:27:02.939] signalConditions() ...
[08:27:02.939]  - include = ‘immediateCondition’
[08:27:02.939]  - exclude = 
[08:27:02.939]  - resignal = FALSE
[08:27:02.939]  - Number of conditions: 1
[08:27:02.939] signalConditions() ... done
[08:27:02.939] - Launch lazy future ... done
[08:27:02.939] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[08:27:02.940] signalConditions() ...
[08:27:02.940]  - include = ‘immediateCondition’
[08:27:02.940]  - exclude = 
[08:27:02.940]  - resignal = FALSE
[08:27:02.940]  - Number of conditions: 1
[08:27:02.940] signalConditions() ... done
> print(v)
<simpleError in eval(quote({    42L    stop("Woops")}), new.env()): Woops>
> calls <- backtrace(f)
[08:27:02.941] resolved() for ‘SequentialFuture’ ...
[08:27:02.941] - state: ‘finished’
[08:27:02.941] - run: TRUE
[08:27:02.942] - result: ‘FutureResult’
[08:27:02.942] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - explicit future ... DONE")
*** backtrace( ) - explicit future ... DONE
> 
> 
> message("*** backtrace( ) - implicit future ...")
*** backtrace( ) - implicit future ...
> 
> v %<-% { 42L; stop("Woops") }
[08:27:02.942] getGlobalsAndPackages() ...
[08:27:02.942] Searching for globals...
[08:27:02.943] - globals found: [2] ‘{’, ‘stop’
[08:27:02.943] Searching for globals ... DONE
[08:27:02.944] Resolving globals: FALSE
[08:27:02.944] 
[08:27:02.944] 
[08:27:02.944] getGlobalsAndPackages() ... DONE
[08:27:02.944] run() for ‘Future’ ...
[08:27:02.944] - state: ‘created’
[08:27:02.945] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.945] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.945]   - Field: ‘label’
[08:27:02.945]   - Field: ‘local’
[08:27:02.945]   - Field: ‘owner’
[08:27:02.945]   - Field: ‘envir’
[08:27:02.945]   - Field: ‘packages’
[08:27:02.946]   - Field: ‘gc’
[08:27:02.946]   - Field: ‘conditions’
[08:27:02.946]   - Field: ‘expr’
[08:27:02.946]   - Field: ‘uuid’
[08:27:02.946]   - Field: ‘seed’
[08:27:02.946]   - Field: ‘version’
[08:27:02.946]   - Field: ‘result’
[08:27:02.946]   - Field: ‘asynchronous’
[08:27:02.946]   - Field: ‘calls’
[08:27:02.946]   - Field: ‘globals’
[08:27:02.947]   - Field: ‘stdout’
[08:27:02.947]   - Field: ‘earlySignal’
[08:27:02.947]   - Field: ‘lazy’
[08:27:02.947]   - Field: ‘state’
[08:27:02.947] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.947] - Launch lazy future ...
[08:27:02.947] Packages needed by the future expression (n = 0): <none>
[08:27:02.947] Packages needed by future strategies (n = 0): <none>
[08:27:02.948] {
[08:27:02.948]     {
[08:27:02.948]         {
[08:27:02.948]             ...future.startTime <- base::Sys.time()
[08:27:02.948]             {
[08:27:02.948]                 {
[08:27:02.948]                   {
[08:27:02.948]                     base::local({
[08:27:02.948]                       has_future <- base::requireNamespace("future", 
[08:27:02.948]                         quietly = TRUE)
[08:27:02.948]                       if (has_future) {
[08:27:02.948]                         ns <- base::getNamespace("future")
[08:27:02.948]                         version <- ns[[".package"]][["version"]]
[08:27:02.948]                         if (is.null(version)) 
[08:27:02.948]                           version <- utils::packageVersion("future")
[08:27:02.948]                       }
[08:27:02.948]                       else {
[08:27:02.948]                         version <- NULL
[08:27:02.948]                       }
[08:27:02.948]                       if (!has_future || version < "1.8.0") {
[08:27:02.948]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.948]                           "", base::R.version$version.string), 
[08:27:02.948]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.948]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.948]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.948]                             "release", "version")], collapse = " "), 
[08:27:02.948]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.948]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.948]                           info)
[08:27:02.948]                         info <- base::paste(info, collapse = "; ")
[08:27:02.948]                         if (!has_future) {
[08:27:02.948]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.948]                             info)
[08:27:02.948]                         }
[08:27:02.948]                         else {
[08:27:02.948]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.948]                             info, version)
[08:27:02.948]                         }
[08:27:02.948]                         base::stop(msg)
[08:27:02.948]                       }
[08:27:02.948]                     })
[08:27:02.948]                   }
[08:27:02.948]                   ...future.strategy.old <- future::plan("list")
[08:27:02.948]                   options(future.plan = NULL)
[08:27:02.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.948]                 }
[08:27:02.948]                 ...future.workdir <- getwd()
[08:27:02.948]             }
[08:27:02.948]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.948]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.948]         }
[08:27:02.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.948]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.948]             base::names(...future.oldOptions))
[08:27:02.948]     }
[08:27:02.948]     if (FALSE) {
[08:27:02.948]     }
[08:27:02.948]     else {
[08:27:02.948]         if (TRUE) {
[08:27:02.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.948]                 open = "w")
[08:27:02.948]         }
[08:27:02.948]         else {
[08:27:02.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.948]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.948]         }
[08:27:02.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.948]             base::sink(type = "output", split = FALSE)
[08:27:02.948]             base::close(...future.stdout)
[08:27:02.948]         }, add = TRUE)
[08:27:02.948]     }
[08:27:02.948]     ...future.frame <- base::sys.nframe()
[08:27:02.948]     ...future.conditions <- base::list()
[08:27:02.948]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.948]     if (FALSE) {
[08:27:02.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.948]     }
[08:27:02.948]     ...future.result <- base::tryCatch({
[08:27:02.948]         base::withCallingHandlers({
[08:27:02.948]             ...future.value <- base::withVisible(base::local({
[08:27:02.948]                 42L
[08:27:02.948]                 stop("Woops")
[08:27:02.948]             }))
[08:27:02.948]             future::FutureResult(value = ...future.value$value, 
[08:27:02.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.948]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.948]                     ...future.globalenv.names))
[08:27:02.948]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.948]         }, condition = base::local({
[08:27:02.948]             c <- base::c
[08:27:02.948]             inherits <- base::inherits
[08:27:02.948]             invokeRestart <- base::invokeRestart
[08:27:02.948]             length <- base::length
[08:27:02.948]             list <- base::list
[08:27:02.948]             seq.int <- base::seq.int
[08:27:02.948]             signalCondition <- base::signalCondition
[08:27:02.948]             sys.calls <- base::sys.calls
[08:27:02.948]             `[[` <- base::`[[`
[08:27:02.948]             `+` <- base::`+`
[08:27:02.948]             `<<-` <- base::`<<-`
[08:27:02.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.948]                   3L)]
[08:27:02.948]             }
[08:27:02.948]             function(cond) {
[08:27:02.948]                 is_error <- inherits(cond, "error")
[08:27:02.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.948]                   NULL)
[08:27:02.948]                 if (is_error) {
[08:27:02.948]                   sessionInformation <- function() {
[08:27:02.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.948]                       search = base::search(), system = base::Sys.info())
[08:27:02.948]                   }
[08:27:02.948]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.948]                     cond$call), session = sessionInformation(), 
[08:27:02.948]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.948]                   signalCondition(cond)
[08:27:02.948]                 }
[08:27:02.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.948]                 "immediateCondition"))) {
[08:27:02.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.948]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.948]                   if (TRUE && !signal) {
[08:27:02.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.948]                     {
[08:27:02.948]                       inherits <- base::inherits
[08:27:02.948]                       invokeRestart <- base::invokeRestart
[08:27:02.948]                       is.null <- base::is.null
[08:27:02.948]                       muffled <- FALSE
[08:27:02.948]                       if (inherits(cond, "message")) {
[08:27:02.948]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.948]                         if (muffled) 
[08:27:02.948]                           invokeRestart("muffleMessage")
[08:27:02.948]                       }
[08:27:02.948]                       else if (inherits(cond, "warning")) {
[08:27:02.948]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.948]                         if (muffled) 
[08:27:02.948]                           invokeRestart("muffleWarning")
[08:27:02.948]                       }
[08:27:02.948]                       else if (inherits(cond, "condition")) {
[08:27:02.948]                         if (!is.null(pattern)) {
[08:27:02.948]                           computeRestarts <- base::computeRestarts
[08:27:02.948]                           grepl <- base::grepl
[08:27:02.948]                           restarts <- computeRestarts(cond)
[08:27:02.948]                           for (restart in restarts) {
[08:27:02.948]                             name <- restart$name
[08:27:02.948]                             if (is.null(name)) 
[08:27:02.948]                               next
[08:27:02.948]                             if (!grepl(pattern, name)) 
[08:27:02.948]                               next
[08:27:02.948]                             invokeRestart(restart)
[08:27:02.948]                             muffled <- TRUE
[08:27:02.948]                             break
[08:27:02.948]                           }
[08:27:02.948]                         }
[08:27:02.948]                       }
[08:27:02.948]                       invisible(muffled)
[08:27:02.948]                     }
[08:27:02.948]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.948]                   }
[08:27:02.948]                 }
[08:27:02.948]                 else {
[08:27:02.948]                   if (TRUE) {
[08:27:02.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.948]                     {
[08:27:02.948]                       inherits <- base::inherits
[08:27:02.948]                       invokeRestart <- base::invokeRestart
[08:27:02.948]                       is.null <- base::is.null
[08:27:02.948]                       muffled <- FALSE
[08:27:02.948]                       if (inherits(cond, "message")) {
[08:27:02.948]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.948]                         if (muffled) 
[08:27:02.948]                           invokeRestart("muffleMessage")
[08:27:02.948]                       }
[08:27:02.948]                       else if (inherits(cond, "warning")) {
[08:27:02.948]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.948]                         if (muffled) 
[08:27:02.948]                           invokeRestart("muffleWarning")
[08:27:02.948]                       }
[08:27:02.948]                       else if (inherits(cond, "condition")) {
[08:27:02.948]                         if (!is.null(pattern)) {
[08:27:02.948]                           computeRestarts <- base::computeRestarts
[08:27:02.948]                           grepl <- base::grepl
[08:27:02.948]                           restarts <- computeRestarts(cond)
[08:27:02.948]                           for (restart in restarts) {
[08:27:02.948]                             name <- restart$name
[08:27:02.948]                             if (is.null(name)) 
[08:27:02.948]                               next
[08:27:02.948]                             if (!grepl(pattern, name)) 
[08:27:02.948]                               next
[08:27:02.948]                             invokeRestart(restart)
[08:27:02.948]                             muffled <- TRUE
[08:27:02.948]                             break
[08:27:02.948]                           }
[08:27:02.948]                         }
[08:27:02.948]                       }
[08:27:02.948]                       invisible(muffled)
[08:27:02.948]                     }
[08:27:02.948]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.948]                   }
[08:27:02.948]                 }
[08:27:02.948]             }
[08:27:02.948]         }))
[08:27:02.948]     }, error = function(ex) {
[08:27:02.948]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.948]                 ...future.rng), started = ...future.startTime, 
[08:27:02.948]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.948]             version = "1.8"), class = "FutureResult")
[08:27:02.948]     }, finally = {
[08:27:02.948]         if (!identical(...future.workdir, getwd())) 
[08:27:02.948]             setwd(...future.workdir)
[08:27:02.948]         {
[08:27:02.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.948]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.948]             }
[08:27:02.948]             base::options(...future.oldOptions)
[08:27:02.948]             if (.Platform$OS.type == "windows") {
[08:27:02.948]                 old_names <- names(...future.oldEnvVars)
[08:27:02.948]                 envs <- base::Sys.getenv()
[08:27:02.948]                 names <- names(envs)
[08:27:02.948]                 common <- intersect(names, old_names)
[08:27:02.948]                 added <- setdiff(names, old_names)
[08:27:02.948]                 removed <- setdiff(old_names, names)
[08:27:02.948]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.948]                   envs[common]]
[08:27:02.948]                 NAMES <- toupper(changed)
[08:27:02.948]                 args <- list()
[08:27:02.948]                 for (kk in seq_along(NAMES)) {
[08:27:02.948]                   name <- changed[[kk]]
[08:27:02.948]                   NAME <- NAMES[[kk]]
[08:27:02.948]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.948]                     next
[08:27:02.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.948]                 }
[08:27:02.948]                 NAMES <- toupper(added)
[08:27:02.948]                 for (kk in seq_along(NAMES)) {
[08:27:02.948]                   name <- added[[kk]]
[08:27:02.948]                   NAME <- NAMES[[kk]]
[08:27:02.948]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.948]                     next
[08:27:02.948]                   args[[name]] <- ""
[08:27:02.948]                 }
[08:27:02.948]                 NAMES <- toupper(removed)
[08:27:02.948]                 for (kk in seq_along(NAMES)) {
[08:27:02.948]                   name <- removed[[kk]]
[08:27:02.948]                   NAME <- NAMES[[kk]]
[08:27:02.948]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.948]                     next
[08:27:02.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.948]                 }
[08:27:02.948]                 if (length(args) > 0) 
[08:27:02.948]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.948]             }
[08:27:02.948]             else {
[08:27:02.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.948]             }
[08:27:02.948]             {
[08:27:02.948]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.948]                   0L) {
[08:27:02.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.948]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.948]                   base::options(opts)
[08:27:02.948]                 }
[08:27:02.948]                 {
[08:27:02.948]                   {
[08:27:02.948]                     NULL
[08:27:02.948]                     RNGkind("Mersenne-Twister")
[08:27:02.948]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.948]                       inherits = FALSE)
[08:27:02.948]                   }
[08:27:02.948]                   options(future.plan = NULL)
[08:27:02.948]                   if (is.na(NA_character_)) 
[08:27:02.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.948]                     .init = FALSE)
[08:27:02.948]                 }
[08:27:02.948]             }
[08:27:02.948]         }
[08:27:02.948]     })
[08:27:02.948]     if (TRUE) {
[08:27:02.948]         base::sink(type = "output", split = FALSE)
[08:27:02.948]         if (TRUE) {
[08:27:02.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.948]         }
[08:27:02.948]         else {
[08:27:02.948]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.948]         }
[08:27:02.948]         base::close(...future.stdout)
[08:27:02.948]         ...future.stdout <- NULL
[08:27:02.948]     }
[08:27:02.948]     ...future.result$conditions <- ...future.conditions
[08:27:02.948]     ...future.result$finished <- base::Sys.time()
[08:27:02.948]     ...future.result
[08:27:02.948] }
[08:27:02.950] plan(): Setting new future strategy stack:
[08:27:02.950] List of future strategies:
[08:27:02.950] 1. sequential:
[08:27:02.950]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.950]    - tweaked: FALSE
[08:27:02.950]    - call: NULL
[08:27:02.950] plan(): nbrOfWorkers() = 1
[08:27:02.951] plan(): Setting new future strategy stack:
[08:27:02.951] List of future strategies:
[08:27:02.951] 1. sequential:
[08:27:02.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.951]    - tweaked: FALSE
[08:27:02.951]    - call: future::plan("sequential")
[08:27:02.952] plan(): nbrOfWorkers() = 1
[08:27:02.952] SequentialFuture started (and completed)
[08:27:02.952] signalConditions() ...
[08:27:02.952]  - include = ‘immediateCondition’
[08:27:02.952]  - exclude = 
[08:27:02.953]  - resignal = FALSE
[08:27:02.953]  - Number of conditions: 1
[08:27:02.953] signalConditions() ... done
[08:27:02.953] - Launch lazy future ... done
[08:27:02.953] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(v)
[08:27:02.953] resolved() for ‘SequentialFuture’ ...
[08:27:02.953] - state: ‘finished’
[08:27:02.953] - run: TRUE
[08:27:02.954] - result: ‘FutureResult’
[08:27:02.954] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
v %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> 
> message("*** backtrace( ) - implicit future ... DONE")
*** backtrace( ) - implicit future ... DONE
> 
> 
> message("*** backtrace( ) - subsetting ...")
*** backtrace( ) - subsetting ...
> 
> env <- new.env()
> env[["a"]] %<-% { 42L; stop("Woops") }
[08:27:02.958] getGlobalsAndPackages() ...
[08:27:02.958] Searching for globals...
[08:27:02.959] - globals found: [2] ‘{’, ‘stop’
[08:27:02.959] Searching for globals ... DONE
[08:27:02.959] Resolving globals: FALSE
[08:27:02.959] 
[08:27:02.959] 
[08:27:02.960] getGlobalsAndPackages() ... DONE
[08:27:02.960] run() for ‘Future’ ...
[08:27:02.960] - state: ‘created’
[08:27:02.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.960]   - Field: ‘label’
[08:27:02.961]   - Field: ‘local’
[08:27:02.961]   - Field: ‘owner’
[08:27:02.961]   - Field: ‘envir’
[08:27:02.961]   - Field: ‘packages’
[08:27:02.961]   - Field: ‘gc’
[08:27:02.961]   - Field: ‘conditions’
[08:27:02.961]   - Field: ‘expr’
[08:27:02.961]   - Field: ‘uuid’
[08:27:02.961]   - Field: ‘seed’
[08:27:02.961]   - Field: ‘version’
[08:27:02.961]   - Field: ‘result’
[08:27:02.962]   - Field: ‘asynchronous’
[08:27:02.962]   - Field: ‘calls’
[08:27:02.962]   - Field: ‘globals’
[08:27:02.962]   - Field: ‘stdout’
[08:27:02.962]   - Field: ‘earlySignal’
[08:27:02.962]   - Field: ‘lazy’
[08:27:02.962]   - Field: ‘state’
[08:27:02.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.962] - Launch lazy future ...
[08:27:02.962] Packages needed by the future expression (n = 0): <none>
[08:27:02.963] Packages needed by future strategies (n = 0): <none>
[08:27:02.963] {
[08:27:02.963]     {
[08:27:02.963]         {
[08:27:02.963]             ...future.startTime <- base::Sys.time()
[08:27:02.963]             {
[08:27:02.963]                 {
[08:27:02.963]                   {
[08:27:02.963]                     base::local({
[08:27:02.963]                       has_future <- base::requireNamespace("future", 
[08:27:02.963]                         quietly = TRUE)
[08:27:02.963]                       if (has_future) {
[08:27:02.963]                         ns <- base::getNamespace("future")
[08:27:02.963]                         version <- ns[[".package"]][["version"]]
[08:27:02.963]                         if (is.null(version)) 
[08:27:02.963]                           version <- utils::packageVersion("future")
[08:27:02.963]                       }
[08:27:02.963]                       else {
[08:27:02.963]                         version <- NULL
[08:27:02.963]                       }
[08:27:02.963]                       if (!has_future || version < "1.8.0") {
[08:27:02.963]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.963]                           "", base::R.version$version.string), 
[08:27:02.963]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.963]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.963]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.963]                             "release", "version")], collapse = " "), 
[08:27:02.963]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.963]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.963]                           info)
[08:27:02.963]                         info <- base::paste(info, collapse = "; ")
[08:27:02.963]                         if (!has_future) {
[08:27:02.963]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.963]                             info)
[08:27:02.963]                         }
[08:27:02.963]                         else {
[08:27:02.963]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.963]                             info, version)
[08:27:02.963]                         }
[08:27:02.963]                         base::stop(msg)
[08:27:02.963]                       }
[08:27:02.963]                     })
[08:27:02.963]                   }
[08:27:02.963]                   ...future.strategy.old <- future::plan("list")
[08:27:02.963]                   options(future.plan = NULL)
[08:27:02.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.963]                 }
[08:27:02.963]                 ...future.workdir <- getwd()
[08:27:02.963]             }
[08:27:02.963]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.963]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.963]         }
[08:27:02.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.963]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.963]             base::names(...future.oldOptions))
[08:27:02.963]     }
[08:27:02.963]     if (FALSE) {
[08:27:02.963]     }
[08:27:02.963]     else {
[08:27:02.963]         if (TRUE) {
[08:27:02.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.963]                 open = "w")
[08:27:02.963]         }
[08:27:02.963]         else {
[08:27:02.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.963]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.963]         }
[08:27:02.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.963]             base::sink(type = "output", split = FALSE)
[08:27:02.963]             base::close(...future.stdout)
[08:27:02.963]         }, add = TRUE)
[08:27:02.963]     }
[08:27:02.963]     ...future.frame <- base::sys.nframe()
[08:27:02.963]     ...future.conditions <- base::list()
[08:27:02.963]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.963]     if (FALSE) {
[08:27:02.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.963]     }
[08:27:02.963]     ...future.result <- base::tryCatch({
[08:27:02.963]         base::withCallingHandlers({
[08:27:02.963]             ...future.value <- base::withVisible(base::local({
[08:27:02.963]                 42L
[08:27:02.963]                 stop("Woops")
[08:27:02.963]             }))
[08:27:02.963]             future::FutureResult(value = ...future.value$value, 
[08:27:02.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.963]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.963]                     ...future.globalenv.names))
[08:27:02.963]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.963]         }, condition = base::local({
[08:27:02.963]             c <- base::c
[08:27:02.963]             inherits <- base::inherits
[08:27:02.963]             invokeRestart <- base::invokeRestart
[08:27:02.963]             length <- base::length
[08:27:02.963]             list <- base::list
[08:27:02.963]             seq.int <- base::seq.int
[08:27:02.963]             signalCondition <- base::signalCondition
[08:27:02.963]             sys.calls <- base::sys.calls
[08:27:02.963]             `[[` <- base::`[[`
[08:27:02.963]             `+` <- base::`+`
[08:27:02.963]             `<<-` <- base::`<<-`
[08:27:02.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.963]                   3L)]
[08:27:02.963]             }
[08:27:02.963]             function(cond) {
[08:27:02.963]                 is_error <- inherits(cond, "error")
[08:27:02.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.963]                   NULL)
[08:27:02.963]                 if (is_error) {
[08:27:02.963]                   sessionInformation <- function() {
[08:27:02.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.963]                       search = base::search(), system = base::Sys.info())
[08:27:02.963]                   }
[08:27:02.963]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.963]                     cond$call), session = sessionInformation(), 
[08:27:02.963]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.963]                   signalCondition(cond)
[08:27:02.963]                 }
[08:27:02.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.963]                 "immediateCondition"))) {
[08:27:02.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.963]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.963]                   if (TRUE && !signal) {
[08:27:02.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.963]                     {
[08:27:02.963]                       inherits <- base::inherits
[08:27:02.963]                       invokeRestart <- base::invokeRestart
[08:27:02.963]                       is.null <- base::is.null
[08:27:02.963]                       muffled <- FALSE
[08:27:02.963]                       if (inherits(cond, "message")) {
[08:27:02.963]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.963]                         if (muffled) 
[08:27:02.963]                           invokeRestart("muffleMessage")
[08:27:02.963]                       }
[08:27:02.963]                       else if (inherits(cond, "warning")) {
[08:27:02.963]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.963]                         if (muffled) 
[08:27:02.963]                           invokeRestart("muffleWarning")
[08:27:02.963]                       }
[08:27:02.963]                       else if (inherits(cond, "condition")) {
[08:27:02.963]                         if (!is.null(pattern)) {
[08:27:02.963]                           computeRestarts <- base::computeRestarts
[08:27:02.963]                           grepl <- base::grepl
[08:27:02.963]                           restarts <- computeRestarts(cond)
[08:27:02.963]                           for (restart in restarts) {
[08:27:02.963]                             name <- restart$name
[08:27:02.963]                             if (is.null(name)) 
[08:27:02.963]                               next
[08:27:02.963]                             if (!grepl(pattern, name)) 
[08:27:02.963]                               next
[08:27:02.963]                             invokeRestart(restart)
[08:27:02.963]                             muffled <- TRUE
[08:27:02.963]                             break
[08:27:02.963]                           }
[08:27:02.963]                         }
[08:27:02.963]                       }
[08:27:02.963]                       invisible(muffled)
[08:27:02.963]                     }
[08:27:02.963]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.963]                   }
[08:27:02.963]                 }
[08:27:02.963]                 else {
[08:27:02.963]                   if (TRUE) {
[08:27:02.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.963]                     {
[08:27:02.963]                       inherits <- base::inherits
[08:27:02.963]                       invokeRestart <- base::invokeRestart
[08:27:02.963]                       is.null <- base::is.null
[08:27:02.963]                       muffled <- FALSE
[08:27:02.963]                       if (inherits(cond, "message")) {
[08:27:02.963]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.963]                         if (muffled) 
[08:27:02.963]                           invokeRestart("muffleMessage")
[08:27:02.963]                       }
[08:27:02.963]                       else if (inherits(cond, "warning")) {
[08:27:02.963]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.963]                         if (muffled) 
[08:27:02.963]                           invokeRestart("muffleWarning")
[08:27:02.963]                       }
[08:27:02.963]                       else if (inherits(cond, "condition")) {
[08:27:02.963]                         if (!is.null(pattern)) {
[08:27:02.963]                           computeRestarts <- base::computeRestarts
[08:27:02.963]                           grepl <- base::grepl
[08:27:02.963]                           restarts <- computeRestarts(cond)
[08:27:02.963]                           for (restart in restarts) {
[08:27:02.963]                             name <- restart$name
[08:27:02.963]                             if (is.null(name)) 
[08:27:02.963]                               next
[08:27:02.963]                             if (!grepl(pattern, name)) 
[08:27:02.963]                               next
[08:27:02.963]                             invokeRestart(restart)
[08:27:02.963]                             muffled <- TRUE
[08:27:02.963]                             break
[08:27:02.963]                           }
[08:27:02.963]                         }
[08:27:02.963]                       }
[08:27:02.963]                       invisible(muffled)
[08:27:02.963]                     }
[08:27:02.963]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.963]                   }
[08:27:02.963]                 }
[08:27:02.963]             }
[08:27:02.963]         }))
[08:27:02.963]     }, error = function(ex) {
[08:27:02.963]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.963]                 ...future.rng), started = ...future.startTime, 
[08:27:02.963]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.963]             version = "1.8"), class = "FutureResult")
[08:27:02.963]     }, finally = {
[08:27:02.963]         if (!identical(...future.workdir, getwd())) 
[08:27:02.963]             setwd(...future.workdir)
[08:27:02.963]         {
[08:27:02.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.963]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.963]             }
[08:27:02.963]             base::options(...future.oldOptions)
[08:27:02.963]             if (.Platform$OS.type == "windows") {
[08:27:02.963]                 old_names <- names(...future.oldEnvVars)
[08:27:02.963]                 envs <- base::Sys.getenv()
[08:27:02.963]                 names <- names(envs)
[08:27:02.963]                 common <- intersect(names, old_names)
[08:27:02.963]                 added <- setdiff(names, old_names)
[08:27:02.963]                 removed <- setdiff(old_names, names)
[08:27:02.963]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.963]                   envs[common]]
[08:27:02.963]                 NAMES <- toupper(changed)
[08:27:02.963]                 args <- list()
[08:27:02.963]                 for (kk in seq_along(NAMES)) {
[08:27:02.963]                   name <- changed[[kk]]
[08:27:02.963]                   NAME <- NAMES[[kk]]
[08:27:02.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.963]                     next
[08:27:02.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.963]                 }
[08:27:02.963]                 NAMES <- toupper(added)
[08:27:02.963]                 for (kk in seq_along(NAMES)) {
[08:27:02.963]                   name <- added[[kk]]
[08:27:02.963]                   NAME <- NAMES[[kk]]
[08:27:02.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.963]                     next
[08:27:02.963]                   args[[name]] <- ""
[08:27:02.963]                 }
[08:27:02.963]                 NAMES <- toupper(removed)
[08:27:02.963]                 for (kk in seq_along(NAMES)) {
[08:27:02.963]                   name <- removed[[kk]]
[08:27:02.963]                   NAME <- NAMES[[kk]]
[08:27:02.963]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.963]                     next
[08:27:02.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.963]                 }
[08:27:02.963]                 if (length(args) > 0) 
[08:27:02.963]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.963]             }
[08:27:02.963]             else {
[08:27:02.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.963]             }
[08:27:02.963]             {
[08:27:02.963]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.963]                   0L) {
[08:27:02.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.963]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.963]                   base::options(opts)
[08:27:02.963]                 }
[08:27:02.963]                 {
[08:27:02.963]                   {
[08:27:02.963]                     NULL
[08:27:02.963]                     RNGkind("Mersenne-Twister")
[08:27:02.963]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.963]                       inherits = FALSE)
[08:27:02.963]                   }
[08:27:02.963]                   options(future.plan = NULL)
[08:27:02.963]                   if (is.na(NA_character_)) 
[08:27:02.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.963]                     .init = FALSE)
[08:27:02.963]                 }
[08:27:02.963]             }
[08:27:02.963]         }
[08:27:02.963]     })
[08:27:02.963]     if (TRUE) {
[08:27:02.963]         base::sink(type = "output", split = FALSE)
[08:27:02.963]         if (TRUE) {
[08:27:02.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.963]         }
[08:27:02.963]         else {
[08:27:02.963]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.963]         }
[08:27:02.963]         base::close(...future.stdout)
[08:27:02.963]         ...future.stdout <- NULL
[08:27:02.963]     }
[08:27:02.963]     ...future.result$conditions <- ...future.conditions
[08:27:02.963]     ...future.result$finished <- base::Sys.time()
[08:27:02.963]     ...future.result
[08:27:02.963] }
[08:27:02.965] plan(): Setting new future strategy stack:
[08:27:02.965] List of future strategies:
[08:27:02.965] 1. sequential:
[08:27:02.965]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.965]    - tweaked: FALSE
[08:27:02.965]    - call: NULL
[08:27:02.966] plan(): nbrOfWorkers() = 1
[08:27:02.967] plan(): Setting new future strategy stack:
[08:27:02.967] List of future strategies:
[08:27:02.967] 1. sequential:
[08:27:02.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.967]    - tweaked: FALSE
[08:27:02.967]    - call: future::plan("sequential")
[08:27:02.967] plan(): nbrOfWorkers() = 1
[08:27:02.967] SequentialFuture started (and completed)
[08:27:02.967] signalConditions() ...
[08:27:02.968]  - include = ‘immediateCondition’
[08:27:02.968]  - exclude = 
[08:27:02.968]  - resignal = FALSE
[08:27:02.968]  - Number of conditions: 1
[08:27:02.968] signalConditions() ... done
[08:27:02.968] - Launch lazy future ... done
[08:27:02.968] run() for ‘SequentialFuture’ ... done
> env[["b"]] %<-% { 42L; stop("Woops") }
[08:27:02.968] getGlobalsAndPackages() ...
[08:27:02.969] Searching for globals...
[08:27:02.970] - globals found: [2] ‘{’, ‘stop’
[08:27:02.970] Searching for globals ... DONE
[08:27:02.970] Resolving globals: FALSE
[08:27:02.970] 
[08:27:02.970] 
[08:27:02.970] getGlobalsAndPackages() ... DONE
[08:27:02.971] run() for ‘Future’ ...
[08:27:02.971] - state: ‘created’
[08:27:02.971] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.971] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.971]   - Field: ‘label’
[08:27:02.971]   - Field: ‘local’
[08:27:02.971]   - Field: ‘owner’
[08:27:02.971]   - Field: ‘envir’
[08:27:02.972]   - Field: ‘packages’
[08:27:02.972]   - Field: ‘gc’
[08:27:02.972]   - Field: ‘conditions’
[08:27:02.972]   - Field: ‘expr’
[08:27:02.972]   - Field: ‘uuid’
[08:27:02.972]   - Field: ‘seed’
[08:27:02.972]   - Field: ‘version’
[08:27:02.972]   - Field: ‘result’
[08:27:02.972]   - Field: ‘asynchronous’
[08:27:02.972]   - Field: ‘calls’
[08:27:02.972]   - Field: ‘globals’
[08:27:02.973]   - Field: ‘stdout’
[08:27:02.973]   - Field: ‘earlySignal’
[08:27:02.973]   - Field: ‘lazy’
[08:27:02.973]   - Field: ‘state’
[08:27:02.973] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.973] - Launch lazy future ...
[08:27:02.973] Packages needed by the future expression (n = 0): <none>
[08:27:02.973] Packages needed by future strategies (n = 0): <none>
[08:27:02.974] {
[08:27:02.974]     {
[08:27:02.974]         {
[08:27:02.974]             ...future.startTime <- base::Sys.time()
[08:27:02.974]             {
[08:27:02.974]                 {
[08:27:02.974]                   {
[08:27:02.974]                     base::local({
[08:27:02.974]                       has_future <- base::requireNamespace("future", 
[08:27:02.974]                         quietly = TRUE)
[08:27:02.974]                       if (has_future) {
[08:27:02.974]                         ns <- base::getNamespace("future")
[08:27:02.974]                         version <- ns[[".package"]][["version"]]
[08:27:02.974]                         if (is.null(version)) 
[08:27:02.974]                           version <- utils::packageVersion("future")
[08:27:02.974]                       }
[08:27:02.974]                       else {
[08:27:02.974]                         version <- NULL
[08:27:02.974]                       }
[08:27:02.974]                       if (!has_future || version < "1.8.0") {
[08:27:02.974]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.974]                           "", base::R.version$version.string), 
[08:27:02.974]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.974]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.974]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.974]                             "release", "version")], collapse = " "), 
[08:27:02.974]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.974]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.974]                           info)
[08:27:02.974]                         info <- base::paste(info, collapse = "; ")
[08:27:02.974]                         if (!has_future) {
[08:27:02.974]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.974]                             info)
[08:27:02.974]                         }
[08:27:02.974]                         else {
[08:27:02.974]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.974]                             info, version)
[08:27:02.974]                         }
[08:27:02.974]                         base::stop(msg)
[08:27:02.974]                       }
[08:27:02.974]                     })
[08:27:02.974]                   }
[08:27:02.974]                   ...future.strategy.old <- future::plan("list")
[08:27:02.974]                   options(future.plan = NULL)
[08:27:02.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.974]                 }
[08:27:02.974]                 ...future.workdir <- getwd()
[08:27:02.974]             }
[08:27:02.974]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.974]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.974]         }
[08:27:02.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.974]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.974]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.974]             base::names(...future.oldOptions))
[08:27:02.974]     }
[08:27:02.974]     if (FALSE) {
[08:27:02.974]     }
[08:27:02.974]     else {
[08:27:02.974]         if (TRUE) {
[08:27:02.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.974]                 open = "w")
[08:27:02.974]         }
[08:27:02.974]         else {
[08:27:02.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.974]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.974]         }
[08:27:02.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.974]             base::sink(type = "output", split = FALSE)
[08:27:02.974]             base::close(...future.stdout)
[08:27:02.974]         }, add = TRUE)
[08:27:02.974]     }
[08:27:02.974]     ...future.frame <- base::sys.nframe()
[08:27:02.974]     ...future.conditions <- base::list()
[08:27:02.974]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.974]     if (FALSE) {
[08:27:02.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.974]     }
[08:27:02.974]     ...future.result <- base::tryCatch({
[08:27:02.974]         base::withCallingHandlers({
[08:27:02.974]             ...future.value <- base::withVisible(base::local({
[08:27:02.974]                 42L
[08:27:02.974]                 stop("Woops")
[08:27:02.974]             }))
[08:27:02.974]             future::FutureResult(value = ...future.value$value, 
[08:27:02.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.974]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.974]                     ...future.globalenv.names))
[08:27:02.974]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.974]         }, condition = base::local({
[08:27:02.974]             c <- base::c
[08:27:02.974]             inherits <- base::inherits
[08:27:02.974]             invokeRestart <- base::invokeRestart
[08:27:02.974]             length <- base::length
[08:27:02.974]             list <- base::list
[08:27:02.974]             seq.int <- base::seq.int
[08:27:02.974]             signalCondition <- base::signalCondition
[08:27:02.974]             sys.calls <- base::sys.calls
[08:27:02.974]             `[[` <- base::`[[`
[08:27:02.974]             `+` <- base::`+`
[08:27:02.974]             `<<-` <- base::`<<-`
[08:27:02.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.974]                   3L)]
[08:27:02.974]             }
[08:27:02.974]             function(cond) {
[08:27:02.974]                 is_error <- inherits(cond, "error")
[08:27:02.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.974]                   NULL)
[08:27:02.974]                 if (is_error) {
[08:27:02.974]                   sessionInformation <- function() {
[08:27:02.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.974]                       search = base::search(), system = base::Sys.info())
[08:27:02.974]                   }
[08:27:02.974]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.974]                     cond$call), session = sessionInformation(), 
[08:27:02.974]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.974]                   signalCondition(cond)
[08:27:02.974]                 }
[08:27:02.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.974]                 "immediateCondition"))) {
[08:27:02.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.974]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.974]                   if (TRUE && !signal) {
[08:27:02.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.974]                     {
[08:27:02.974]                       inherits <- base::inherits
[08:27:02.974]                       invokeRestart <- base::invokeRestart
[08:27:02.974]                       is.null <- base::is.null
[08:27:02.974]                       muffled <- FALSE
[08:27:02.974]                       if (inherits(cond, "message")) {
[08:27:02.974]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.974]                         if (muffled) 
[08:27:02.974]                           invokeRestart("muffleMessage")
[08:27:02.974]                       }
[08:27:02.974]                       else if (inherits(cond, "warning")) {
[08:27:02.974]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.974]                         if (muffled) 
[08:27:02.974]                           invokeRestart("muffleWarning")
[08:27:02.974]                       }
[08:27:02.974]                       else if (inherits(cond, "condition")) {
[08:27:02.974]                         if (!is.null(pattern)) {
[08:27:02.974]                           computeRestarts <- base::computeRestarts
[08:27:02.974]                           grepl <- base::grepl
[08:27:02.974]                           restarts <- computeRestarts(cond)
[08:27:02.974]                           for (restart in restarts) {
[08:27:02.974]                             name <- restart$name
[08:27:02.974]                             if (is.null(name)) 
[08:27:02.974]                               next
[08:27:02.974]                             if (!grepl(pattern, name)) 
[08:27:02.974]                               next
[08:27:02.974]                             invokeRestart(restart)
[08:27:02.974]                             muffled <- TRUE
[08:27:02.974]                             break
[08:27:02.974]                           }
[08:27:02.974]                         }
[08:27:02.974]                       }
[08:27:02.974]                       invisible(muffled)
[08:27:02.974]                     }
[08:27:02.974]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.974]                   }
[08:27:02.974]                 }
[08:27:02.974]                 else {
[08:27:02.974]                   if (TRUE) {
[08:27:02.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.974]                     {
[08:27:02.974]                       inherits <- base::inherits
[08:27:02.974]                       invokeRestart <- base::invokeRestart
[08:27:02.974]                       is.null <- base::is.null
[08:27:02.974]                       muffled <- FALSE
[08:27:02.974]                       if (inherits(cond, "message")) {
[08:27:02.974]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.974]                         if (muffled) 
[08:27:02.974]                           invokeRestart("muffleMessage")
[08:27:02.974]                       }
[08:27:02.974]                       else if (inherits(cond, "warning")) {
[08:27:02.974]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.974]                         if (muffled) 
[08:27:02.974]                           invokeRestart("muffleWarning")
[08:27:02.974]                       }
[08:27:02.974]                       else if (inherits(cond, "condition")) {
[08:27:02.974]                         if (!is.null(pattern)) {
[08:27:02.974]                           computeRestarts <- base::computeRestarts
[08:27:02.974]                           grepl <- base::grepl
[08:27:02.974]                           restarts <- computeRestarts(cond)
[08:27:02.974]                           for (restart in restarts) {
[08:27:02.974]                             name <- restart$name
[08:27:02.974]                             if (is.null(name)) 
[08:27:02.974]                               next
[08:27:02.974]                             if (!grepl(pattern, name)) 
[08:27:02.974]                               next
[08:27:02.974]                             invokeRestart(restart)
[08:27:02.974]                             muffled <- TRUE
[08:27:02.974]                             break
[08:27:02.974]                           }
[08:27:02.974]                         }
[08:27:02.974]                       }
[08:27:02.974]                       invisible(muffled)
[08:27:02.974]                     }
[08:27:02.974]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.974]                   }
[08:27:02.974]                 }
[08:27:02.974]             }
[08:27:02.974]         }))
[08:27:02.974]     }, error = function(ex) {
[08:27:02.974]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.974]                 ...future.rng), started = ...future.startTime, 
[08:27:02.974]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.974]             version = "1.8"), class = "FutureResult")
[08:27:02.974]     }, finally = {
[08:27:02.974]         if (!identical(...future.workdir, getwd())) 
[08:27:02.974]             setwd(...future.workdir)
[08:27:02.974]         {
[08:27:02.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.974]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.974]             }
[08:27:02.974]             base::options(...future.oldOptions)
[08:27:02.974]             if (.Platform$OS.type == "windows") {
[08:27:02.974]                 old_names <- names(...future.oldEnvVars)
[08:27:02.974]                 envs <- base::Sys.getenv()
[08:27:02.974]                 names <- names(envs)
[08:27:02.974]                 common <- intersect(names, old_names)
[08:27:02.974]                 added <- setdiff(names, old_names)
[08:27:02.974]                 removed <- setdiff(old_names, names)
[08:27:02.974]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.974]                   envs[common]]
[08:27:02.974]                 NAMES <- toupper(changed)
[08:27:02.974]                 args <- list()
[08:27:02.974]                 for (kk in seq_along(NAMES)) {
[08:27:02.974]                   name <- changed[[kk]]
[08:27:02.974]                   NAME <- NAMES[[kk]]
[08:27:02.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.974]                     next
[08:27:02.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.974]                 }
[08:27:02.974]                 NAMES <- toupper(added)
[08:27:02.974]                 for (kk in seq_along(NAMES)) {
[08:27:02.974]                   name <- added[[kk]]
[08:27:02.974]                   NAME <- NAMES[[kk]]
[08:27:02.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.974]                     next
[08:27:02.974]                   args[[name]] <- ""
[08:27:02.974]                 }
[08:27:02.974]                 NAMES <- toupper(removed)
[08:27:02.974]                 for (kk in seq_along(NAMES)) {
[08:27:02.974]                   name <- removed[[kk]]
[08:27:02.974]                   NAME <- NAMES[[kk]]
[08:27:02.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.974]                     next
[08:27:02.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.974]                 }
[08:27:02.974]                 if (length(args) > 0) 
[08:27:02.974]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.974]             }
[08:27:02.974]             else {
[08:27:02.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.974]             }
[08:27:02.974]             {
[08:27:02.974]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.974]                   0L) {
[08:27:02.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.974]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.974]                   base::options(opts)
[08:27:02.974]                 }
[08:27:02.974]                 {
[08:27:02.974]                   {
[08:27:02.974]                     NULL
[08:27:02.974]                     RNGkind("Mersenne-Twister")
[08:27:02.974]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.974]                       inherits = FALSE)
[08:27:02.974]                   }
[08:27:02.974]                   options(future.plan = NULL)
[08:27:02.974]                   if (is.na(NA_character_)) 
[08:27:02.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.974]                     .init = FALSE)
[08:27:02.974]                 }
[08:27:02.974]             }
[08:27:02.974]         }
[08:27:02.974]     })
[08:27:02.974]     if (TRUE) {
[08:27:02.974]         base::sink(type = "output", split = FALSE)
[08:27:02.974]         if (TRUE) {
[08:27:02.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.974]         }
[08:27:02.974]         else {
[08:27:02.974]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.974]         }
[08:27:02.974]         base::close(...future.stdout)
[08:27:02.974]         ...future.stdout <- NULL
[08:27:02.974]     }
[08:27:02.974]     ...future.result$conditions <- ...future.conditions
[08:27:02.974]     ...future.result$finished <- base::Sys.time()
[08:27:02.974]     ...future.result
[08:27:02.974] }
[08:27:02.976] plan(): Setting new future strategy stack:
[08:27:02.976] List of future strategies:
[08:27:02.976] 1. sequential:
[08:27:02.976]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.976]    - tweaked: FALSE
[08:27:02.976]    - call: NULL
[08:27:02.976] plan(): nbrOfWorkers() = 1
[08:27:02.977] plan(): Setting new future strategy stack:
[08:27:02.977] List of future strategies:
[08:27:02.977] 1. sequential:
[08:27:02.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.977]    - tweaked: FALSE
[08:27:02.977]    - call: future::plan("sequential")
[08:27:02.978] plan(): nbrOfWorkers() = 1
[08:27:02.978] SequentialFuture started (and completed)
[08:27:02.978] signalConditions() ...
[08:27:02.978]  - include = ‘immediateCondition’
[08:27:02.978]  - exclude = 
[08:27:02.978]  - resignal = FALSE
[08:27:02.978]  - Number of conditions: 1
[08:27:02.978] signalConditions() ... done
[08:27:02.978] - Launch lazy future ... done
[08:27:02.979] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(env[["b"]])
[08:27:02.979] resolved() for ‘SequentialFuture’ ...
[08:27:02.979] - state: ‘finished’
[08:27:02.979] - run: TRUE
[08:27:02.979] - result: ‘FutureResult’
[08:27:02.979] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
env[["b"]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> lenv <- listenv::listenv()
> lenv[[1]] %<-% { 42L; stop("Woops") }
[08:27:02.980] getGlobalsAndPackages() ...
[08:27:02.980] Searching for globals...
[08:27:02.981] - globals found: [2] ‘{’, ‘stop’
[08:27:02.982] Searching for globals ... DONE
[08:27:02.982] Resolving globals: FALSE
[08:27:02.982] 
[08:27:02.982] 
[08:27:02.982] getGlobalsAndPackages() ... DONE
[08:27:02.982] run() for ‘Future’ ...
[08:27:02.983] - state: ‘created’
[08:27:02.983] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.983] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.983]   - Field: ‘label’
[08:27:02.983]   - Field: ‘local’
[08:27:02.983]   - Field: ‘owner’
[08:27:02.983]   - Field: ‘envir’
[08:27:02.984]   - Field: ‘packages’
[08:27:02.984]   - Field: ‘gc’
[08:27:02.984]   - Field: ‘conditions’
[08:27:02.984]   - Field: ‘expr’
[08:27:02.984]   - Field: ‘uuid’
[08:27:02.984]   - Field: ‘seed’
[08:27:02.984]   - Field: ‘version’
[08:27:02.984]   - Field: ‘result’
[08:27:02.984]   - Field: ‘asynchronous’
[08:27:02.984]   - Field: ‘calls’
[08:27:02.984]   - Field: ‘globals’
[08:27:02.985]   - Field: ‘stdout’
[08:27:02.985]   - Field: ‘earlySignal’
[08:27:02.985]   - Field: ‘lazy’
[08:27:02.985]   - Field: ‘state’
[08:27:02.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.985] - Launch lazy future ...
[08:27:02.985] Packages needed by the future expression (n = 0): <none>
[08:27:02.985] Packages needed by future strategies (n = 0): <none>
[08:27:02.986] {
[08:27:02.986]     {
[08:27:02.986]         {
[08:27:02.986]             ...future.startTime <- base::Sys.time()
[08:27:02.986]             {
[08:27:02.986]                 {
[08:27:02.986]                   {
[08:27:02.986]                     base::local({
[08:27:02.986]                       has_future <- base::requireNamespace("future", 
[08:27:02.986]                         quietly = TRUE)
[08:27:02.986]                       if (has_future) {
[08:27:02.986]                         ns <- base::getNamespace("future")
[08:27:02.986]                         version <- ns[[".package"]][["version"]]
[08:27:02.986]                         if (is.null(version)) 
[08:27:02.986]                           version <- utils::packageVersion("future")
[08:27:02.986]                       }
[08:27:02.986]                       else {
[08:27:02.986]                         version <- NULL
[08:27:02.986]                       }
[08:27:02.986]                       if (!has_future || version < "1.8.0") {
[08:27:02.986]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.986]                           "", base::R.version$version.string), 
[08:27:02.986]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.986]                             "release", "version")], collapse = " "), 
[08:27:02.986]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.986]                           info)
[08:27:02.986]                         info <- base::paste(info, collapse = "; ")
[08:27:02.986]                         if (!has_future) {
[08:27:02.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.986]                             info)
[08:27:02.986]                         }
[08:27:02.986]                         else {
[08:27:02.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.986]                             info, version)
[08:27:02.986]                         }
[08:27:02.986]                         base::stop(msg)
[08:27:02.986]                       }
[08:27:02.986]                     })
[08:27:02.986]                   }
[08:27:02.986]                   ...future.strategy.old <- future::plan("list")
[08:27:02.986]                   options(future.plan = NULL)
[08:27:02.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.986]                 }
[08:27:02.986]                 ...future.workdir <- getwd()
[08:27:02.986]             }
[08:27:02.986]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.986]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.986]         }
[08:27:02.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.986]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.986]             base::names(...future.oldOptions))
[08:27:02.986]     }
[08:27:02.986]     if (FALSE) {
[08:27:02.986]     }
[08:27:02.986]     else {
[08:27:02.986]         if (TRUE) {
[08:27:02.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.986]                 open = "w")
[08:27:02.986]         }
[08:27:02.986]         else {
[08:27:02.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.986]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.986]         }
[08:27:02.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.986]             base::sink(type = "output", split = FALSE)
[08:27:02.986]             base::close(...future.stdout)
[08:27:02.986]         }, add = TRUE)
[08:27:02.986]     }
[08:27:02.986]     ...future.frame <- base::sys.nframe()
[08:27:02.986]     ...future.conditions <- base::list()
[08:27:02.986]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.986]     if (FALSE) {
[08:27:02.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.986]     }
[08:27:02.986]     ...future.result <- base::tryCatch({
[08:27:02.986]         base::withCallingHandlers({
[08:27:02.986]             ...future.value <- base::withVisible(base::local({
[08:27:02.986]                 42L
[08:27:02.986]                 stop("Woops")
[08:27:02.986]             }))
[08:27:02.986]             future::FutureResult(value = ...future.value$value, 
[08:27:02.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.986]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.986]                     ...future.globalenv.names))
[08:27:02.986]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.986]         }, condition = base::local({
[08:27:02.986]             c <- base::c
[08:27:02.986]             inherits <- base::inherits
[08:27:02.986]             invokeRestart <- base::invokeRestart
[08:27:02.986]             length <- base::length
[08:27:02.986]             list <- base::list
[08:27:02.986]             seq.int <- base::seq.int
[08:27:02.986]             signalCondition <- base::signalCondition
[08:27:02.986]             sys.calls <- base::sys.calls
[08:27:02.986]             `[[` <- base::`[[`
[08:27:02.986]             `+` <- base::`+`
[08:27:02.986]             `<<-` <- base::`<<-`
[08:27:02.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.986]                   3L)]
[08:27:02.986]             }
[08:27:02.986]             function(cond) {
[08:27:02.986]                 is_error <- inherits(cond, "error")
[08:27:02.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.986]                   NULL)
[08:27:02.986]                 if (is_error) {
[08:27:02.986]                   sessionInformation <- function() {
[08:27:02.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.986]                       search = base::search(), system = base::Sys.info())
[08:27:02.986]                   }
[08:27:02.986]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.986]                     cond$call), session = sessionInformation(), 
[08:27:02.986]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.986]                   signalCondition(cond)
[08:27:02.986]                 }
[08:27:02.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.986]                 "immediateCondition"))) {
[08:27:02.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.986]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.986]                   if (TRUE && !signal) {
[08:27:02.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.986]                     {
[08:27:02.986]                       inherits <- base::inherits
[08:27:02.986]                       invokeRestart <- base::invokeRestart
[08:27:02.986]                       is.null <- base::is.null
[08:27:02.986]                       muffled <- FALSE
[08:27:02.986]                       if (inherits(cond, "message")) {
[08:27:02.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.986]                         if (muffled) 
[08:27:02.986]                           invokeRestart("muffleMessage")
[08:27:02.986]                       }
[08:27:02.986]                       else if (inherits(cond, "warning")) {
[08:27:02.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.986]                         if (muffled) 
[08:27:02.986]                           invokeRestart("muffleWarning")
[08:27:02.986]                       }
[08:27:02.986]                       else if (inherits(cond, "condition")) {
[08:27:02.986]                         if (!is.null(pattern)) {
[08:27:02.986]                           computeRestarts <- base::computeRestarts
[08:27:02.986]                           grepl <- base::grepl
[08:27:02.986]                           restarts <- computeRestarts(cond)
[08:27:02.986]                           for (restart in restarts) {
[08:27:02.986]                             name <- restart$name
[08:27:02.986]                             if (is.null(name)) 
[08:27:02.986]                               next
[08:27:02.986]                             if (!grepl(pattern, name)) 
[08:27:02.986]                               next
[08:27:02.986]                             invokeRestart(restart)
[08:27:02.986]                             muffled <- TRUE
[08:27:02.986]                             break
[08:27:02.986]                           }
[08:27:02.986]                         }
[08:27:02.986]                       }
[08:27:02.986]                       invisible(muffled)
[08:27:02.986]                     }
[08:27:02.986]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.986]                   }
[08:27:02.986]                 }
[08:27:02.986]                 else {
[08:27:02.986]                   if (TRUE) {
[08:27:02.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.986]                     {
[08:27:02.986]                       inherits <- base::inherits
[08:27:02.986]                       invokeRestart <- base::invokeRestart
[08:27:02.986]                       is.null <- base::is.null
[08:27:02.986]                       muffled <- FALSE
[08:27:02.986]                       if (inherits(cond, "message")) {
[08:27:02.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.986]                         if (muffled) 
[08:27:02.986]                           invokeRestart("muffleMessage")
[08:27:02.986]                       }
[08:27:02.986]                       else if (inherits(cond, "warning")) {
[08:27:02.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.986]                         if (muffled) 
[08:27:02.986]                           invokeRestart("muffleWarning")
[08:27:02.986]                       }
[08:27:02.986]                       else if (inherits(cond, "condition")) {
[08:27:02.986]                         if (!is.null(pattern)) {
[08:27:02.986]                           computeRestarts <- base::computeRestarts
[08:27:02.986]                           grepl <- base::grepl
[08:27:02.986]                           restarts <- computeRestarts(cond)
[08:27:02.986]                           for (restart in restarts) {
[08:27:02.986]                             name <- restart$name
[08:27:02.986]                             if (is.null(name)) 
[08:27:02.986]                               next
[08:27:02.986]                             if (!grepl(pattern, name)) 
[08:27:02.986]                               next
[08:27:02.986]                             invokeRestart(restart)
[08:27:02.986]                             muffled <- TRUE
[08:27:02.986]                             break
[08:27:02.986]                           }
[08:27:02.986]                         }
[08:27:02.986]                       }
[08:27:02.986]                       invisible(muffled)
[08:27:02.986]                     }
[08:27:02.986]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.986]                   }
[08:27:02.986]                 }
[08:27:02.986]             }
[08:27:02.986]         }))
[08:27:02.986]     }, error = function(ex) {
[08:27:02.986]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.986]                 ...future.rng), started = ...future.startTime, 
[08:27:02.986]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.986]             version = "1.8"), class = "FutureResult")
[08:27:02.986]     }, finally = {
[08:27:02.986]         if (!identical(...future.workdir, getwd())) 
[08:27:02.986]             setwd(...future.workdir)
[08:27:02.986]         {
[08:27:02.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.986]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.986]             }
[08:27:02.986]             base::options(...future.oldOptions)
[08:27:02.986]             if (.Platform$OS.type == "windows") {
[08:27:02.986]                 old_names <- names(...future.oldEnvVars)
[08:27:02.986]                 envs <- base::Sys.getenv()
[08:27:02.986]                 names <- names(envs)
[08:27:02.986]                 common <- intersect(names, old_names)
[08:27:02.986]                 added <- setdiff(names, old_names)
[08:27:02.986]                 removed <- setdiff(old_names, names)
[08:27:02.986]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.986]                   envs[common]]
[08:27:02.986]                 NAMES <- toupper(changed)
[08:27:02.986]                 args <- list()
[08:27:02.986]                 for (kk in seq_along(NAMES)) {
[08:27:02.986]                   name <- changed[[kk]]
[08:27:02.986]                   NAME <- NAMES[[kk]]
[08:27:02.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.986]                     next
[08:27:02.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.986]                 }
[08:27:02.986]                 NAMES <- toupper(added)
[08:27:02.986]                 for (kk in seq_along(NAMES)) {
[08:27:02.986]                   name <- added[[kk]]
[08:27:02.986]                   NAME <- NAMES[[kk]]
[08:27:02.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.986]                     next
[08:27:02.986]                   args[[name]] <- ""
[08:27:02.986]                 }
[08:27:02.986]                 NAMES <- toupper(removed)
[08:27:02.986]                 for (kk in seq_along(NAMES)) {
[08:27:02.986]                   name <- removed[[kk]]
[08:27:02.986]                   NAME <- NAMES[[kk]]
[08:27:02.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.986]                     next
[08:27:02.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.986]                 }
[08:27:02.986]                 if (length(args) > 0) 
[08:27:02.986]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.986]             }
[08:27:02.986]             else {
[08:27:02.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.986]             }
[08:27:02.986]             {
[08:27:02.986]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.986]                   0L) {
[08:27:02.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.986]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.986]                   base::options(opts)
[08:27:02.986]                 }
[08:27:02.986]                 {
[08:27:02.986]                   {
[08:27:02.986]                     NULL
[08:27:02.986]                     RNGkind("Mersenne-Twister")
[08:27:02.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.986]                       inherits = FALSE)
[08:27:02.986]                   }
[08:27:02.986]                   options(future.plan = NULL)
[08:27:02.986]                   if (is.na(NA_character_)) 
[08:27:02.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.986]                     .init = FALSE)
[08:27:02.986]                 }
[08:27:02.986]             }
[08:27:02.986]         }
[08:27:02.986]     })
[08:27:02.986]     if (TRUE) {
[08:27:02.986]         base::sink(type = "output", split = FALSE)
[08:27:02.986]         if (TRUE) {
[08:27:02.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.986]         }
[08:27:02.986]         else {
[08:27:02.986]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.986]         }
[08:27:02.986]         base::close(...future.stdout)
[08:27:02.986]         ...future.stdout <- NULL
[08:27:02.986]     }
[08:27:02.986]     ...future.result$conditions <- ...future.conditions
[08:27:02.986]     ...future.result$finished <- base::Sys.time()
[08:27:02.986]     ...future.result
[08:27:02.986] }
[08:27:02.988] plan(): Setting new future strategy stack:
[08:27:02.988] List of future strategies:
[08:27:02.988] 1. sequential:
[08:27:02.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.988]    - tweaked: FALSE
[08:27:02.988]    - call: NULL
[08:27:02.988] plan(): nbrOfWorkers() = 1
[08:27:02.989] plan(): Setting new future strategy stack:
[08:27:02.989] List of future strategies:
[08:27:02.989] 1. sequential:
[08:27:02.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:02.989]    - tweaked: FALSE
[08:27:02.989]    - call: future::plan("sequential")
[08:27:02.990] plan(): nbrOfWorkers() = 1
[08:27:02.990] SequentialFuture started (and completed)
[08:27:02.990] signalConditions() ...
[08:27:02.990]  - include = ‘immediateCondition’
[08:27:02.990]  - exclude = 
[08:27:02.990]  - resignal = FALSE
[08:27:02.990]  - Number of conditions: 1
[08:27:02.990] signalConditions() ... done
[08:27:02.990] - Launch lazy future ... done
[08:27:02.991] run() for ‘SequentialFuture’ ... done
> lenv[[2]] %<-% { 42L; stop("Woops") }
[08:27:02.991] getGlobalsAndPackages() ...
[08:27:02.991] Searching for globals...
[08:27:02.994] - globals found: [2] ‘{’, ‘stop’
[08:27:02.994] Searching for globals ... DONE
[08:27:02.994] Resolving globals: FALSE
[08:27:02.994] 
[08:27:02.995] 
[08:27:02.995] getGlobalsAndPackages() ... DONE
[08:27:02.995] run() for ‘Future’ ...
[08:27:02.995] - state: ‘created’
[08:27:02.995] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:02.995] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:02.995] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:02.996]   - Field: ‘label’
[08:27:02.996]   - Field: ‘local’
[08:27:02.996]   - Field: ‘owner’
[08:27:02.996]   - Field: ‘envir’
[08:27:02.996]   - Field: ‘packages’
[08:27:02.996]   - Field: ‘gc’
[08:27:02.996]   - Field: ‘conditions’
[08:27:02.996]   - Field: ‘expr’
[08:27:02.996]   - Field: ‘uuid’
[08:27:02.996]   - Field: ‘seed’
[08:27:02.996]   - Field: ‘version’
[08:27:02.997]   - Field: ‘result’
[08:27:02.997]   - Field: ‘asynchronous’
[08:27:02.997]   - Field: ‘calls’
[08:27:02.997]   - Field: ‘globals’
[08:27:02.997]   - Field: ‘stdout’
[08:27:02.997]   - Field: ‘earlySignal’
[08:27:02.997]   - Field: ‘lazy’
[08:27:02.997]   - Field: ‘state’
[08:27:02.997] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:02.997] - Launch lazy future ...
[08:27:02.998] Packages needed by the future expression (n = 0): <none>
[08:27:02.998] Packages needed by future strategies (n = 0): <none>
[08:27:02.998] {
[08:27:02.998]     {
[08:27:02.998]         {
[08:27:02.998]             ...future.startTime <- base::Sys.time()
[08:27:02.998]             {
[08:27:02.998]                 {
[08:27:02.998]                   {
[08:27:02.998]                     base::local({
[08:27:02.998]                       has_future <- base::requireNamespace("future", 
[08:27:02.998]                         quietly = TRUE)
[08:27:02.998]                       if (has_future) {
[08:27:02.998]                         ns <- base::getNamespace("future")
[08:27:02.998]                         version <- ns[[".package"]][["version"]]
[08:27:02.998]                         if (is.null(version)) 
[08:27:02.998]                           version <- utils::packageVersion("future")
[08:27:02.998]                       }
[08:27:02.998]                       else {
[08:27:02.998]                         version <- NULL
[08:27:02.998]                       }
[08:27:02.998]                       if (!has_future || version < "1.8.0") {
[08:27:02.998]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:02.998]                           "", base::R.version$version.string), 
[08:27:02.998]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:02.998]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:02.998]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:02.998]                             "release", "version")], collapse = " "), 
[08:27:02.998]                           hostname = base::Sys.info()[["nodename"]])
[08:27:02.998]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:02.998]                           info)
[08:27:02.998]                         info <- base::paste(info, collapse = "; ")
[08:27:02.998]                         if (!has_future) {
[08:27:02.998]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:02.998]                             info)
[08:27:02.998]                         }
[08:27:02.998]                         else {
[08:27:02.998]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:02.998]                             info, version)
[08:27:02.998]                         }
[08:27:02.998]                         base::stop(msg)
[08:27:02.998]                       }
[08:27:02.998]                     })
[08:27:02.998]                   }
[08:27:02.998]                   ...future.strategy.old <- future::plan("list")
[08:27:02.998]                   options(future.plan = NULL)
[08:27:02.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:02.998]                 }
[08:27:02.998]                 ...future.workdir <- getwd()
[08:27:02.998]             }
[08:27:02.998]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:02.998]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:02.998]         }
[08:27:02.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:02.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:02.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:02.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:02.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:02.998]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:02.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:02.998]             base::names(...future.oldOptions))
[08:27:02.998]     }
[08:27:02.998]     if (FALSE) {
[08:27:02.998]     }
[08:27:02.998]     else {
[08:27:02.998]         if (TRUE) {
[08:27:02.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:02.998]                 open = "w")
[08:27:02.998]         }
[08:27:02.998]         else {
[08:27:02.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:02.998]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:02.998]         }
[08:27:02.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:02.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:02.998]             base::sink(type = "output", split = FALSE)
[08:27:02.998]             base::close(...future.stdout)
[08:27:02.998]         }, add = TRUE)
[08:27:02.998]     }
[08:27:02.998]     ...future.frame <- base::sys.nframe()
[08:27:02.998]     ...future.conditions <- base::list()
[08:27:02.998]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:02.998]     if (FALSE) {
[08:27:02.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:02.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:02.998]     }
[08:27:02.998]     ...future.result <- base::tryCatch({
[08:27:02.998]         base::withCallingHandlers({
[08:27:02.998]             ...future.value <- base::withVisible(base::local({
[08:27:02.998]                 42L
[08:27:02.998]                 stop("Woops")
[08:27:02.998]             }))
[08:27:02.998]             future::FutureResult(value = ...future.value$value, 
[08:27:02.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.998]                   ...future.rng), globalenv = if (FALSE) 
[08:27:02.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:02.998]                     ...future.globalenv.names))
[08:27:02.998]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:02.998]         }, condition = base::local({
[08:27:02.998]             c <- base::c
[08:27:02.998]             inherits <- base::inherits
[08:27:02.998]             invokeRestart <- base::invokeRestart
[08:27:02.998]             length <- base::length
[08:27:02.998]             list <- base::list
[08:27:02.998]             seq.int <- base::seq.int
[08:27:02.998]             signalCondition <- base::signalCondition
[08:27:02.998]             sys.calls <- base::sys.calls
[08:27:02.998]             `[[` <- base::`[[`
[08:27:02.998]             `+` <- base::`+`
[08:27:02.998]             `<<-` <- base::`<<-`
[08:27:02.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:02.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:02.998]                   3L)]
[08:27:02.998]             }
[08:27:02.998]             function(cond) {
[08:27:02.998]                 is_error <- inherits(cond, "error")
[08:27:02.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:02.998]                   NULL)
[08:27:02.998]                 if (is_error) {
[08:27:02.998]                   sessionInformation <- function() {
[08:27:02.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:02.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:02.998]                       search = base::search(), system = base::Sys.info())
[08:27:02.998]                   }
[08:27:02.998]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:02.998]                     cond$call), session = sessionInformation(), 
[08:27:02.998]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:02.998]                   signalCondition(cond)
[08:27:02.998]                 }
[08:27:02.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:02.998]                 "immediateCondition"))) {
[08:27:02.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:02.998]                   ...future.conditions[[length(...future.conditions) + 
[08:27:02.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:02.998]                   if (TRUE && !signal) {
[08:27:02.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.998]                     {
[08:27:02.998]                       inherits <- base::inherits
[08:27:02.998]                       invokeRestart <- base::invokeRestart
[08:27:02.998]                       is.null <- base::is.null
[08:27:02.998]                       muffled <- FALSE
[08:27:02.998]                       if (inherits(cond, "message")) {
[08:27:02.998]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.998]                         if (muffled) 
[08:27:02.998]                           invokeRestart("muffleMessage")
[08:27:02.998]                       }
[08:27:02.998]                       else if (inherits(cond, "warning")) {
[08:27:02.998]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.998]                         if (muffled) 
[08:27:02.998]                           invokeRestart("muffleWarning")
[08:27:02.998]                       }
[08:27:02.998]                       else if (inherits(cond, "condition")) {
[08:27:02.998]                         if (!is.null(pattern)) {
[08:27:02.998]                           computeRestarts <- base::computeRestarts
[08:27:02.998]                           grepl <- base::grepl
[08:27:02.998]                           restarts <- computeRestarts(cond)
[08:27:02.998]                           for (restart in restarts) {
[08:27:02.998]                             name <- restart$name
[08:27:02.998]                             if (is.null(name)) 
[08:27:02.998]                               next
[08:27:02.998]                             if (!grepl(pattern, name)) 
[08:27:02.998]                               next
[08:27:02.998]                             invokeRestart(restart)
[08:27:02.998]                             muffled <- TRUE
[08:27:02.998]                             break
[08:27:02.998]                           }
[08:27:02.998]                         }
[08:27:02.998]                       }
[08:27:02.998]                       invisible(muffled)
[08:27:02.998]                     }
[08:27:02.998]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.998]                   }
[08:27:02.998]                 }
[08:27:02.998]                 else {
[08:27:02.998]                   if (TRUE) {
[08:27:02.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:02.998]                     {
[08:27:02.998]                       inherits <- base::inherits
[08:27:02.998]                       invokeRestart <- base::invokeRestart
[08:27:02.998]                       is.null <- base::is.null
[08:27:02.998]                       muffled <- FALSE
[08:27:02.998]                       if (inherits(cond, "message")) {
[08:27:02.998]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:02.998]                         if (muffled) 
[08:27:02.998]                           invokeRestart("muffleMessage")
[08:27:02.998]                       }
[08:27:02.998]                       else if (inherits(cond, "warning")) {
[08:27:02.998]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:02.998]                         if (muffled) 
[08:27:02.998]                           invokeRestart("muffleWarning")
[08:27:02.998]                       }
[08:27:02.998]                       else if (inherits(cond, "condition")) {
[08:27:02.998]                         if (!is.null(pattern)) {
[08:27:02.998]                           computeRestarts <- base::computeRestarts
[08:27:02.998]                           grepl <- base::grepl
[08:27:02.998]                           restarts <- computeRestarts(cond)
[08:27:02.998]                           for (restart in restarts) {
[08:27:02.998]                             name <- restart$name
[08:27:02.998]                             if (is.null(name)) 
[08:27:02.998]                               next
[08:27:02.998]                             if (!grepl(pattern, name)) 
[08:27:02.998]                               next
[08:27:02.998]                             invokeRestart(restart)
[08:27:02.998]                             muffled <- TRUE
[08:27:02.998]                             break
[08:27:02.998]                           }
[08:27:02.998]                         }
[08:27:02.998]                       }
[08:27:02.998]                       invisible(muffled)
[08:27:02.998]                     }
[08:27:02.998]                     muffleCondition(cond, pattern = "^muffle")
[08:27:02.998]                   }
[08:27:02.998]                 }
[08:27:02.998]             }
[08:27:02.998]         }))
[08:27:02.998]     }, error = function(ex) {
[08:27:02.998]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:02.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:02.998]                 ...future.rng), started = ...future.startTime, 
[08:27:02.998]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:02.998]             version = "1.8"), class = "FutureResult")
[08:27:02.998]     }, finally = {
[08:27:02.998]         if (!identical(...future.workdir, getwd())) 
[08:27:02.998]             setwd(...future.workdir)
[08:27:02.998]         {
[08:27:02.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:02.998]                 ...future.oldOptions$nwarnings <- NULL
[08:27:02.998]             }
[08:27:02.998]             base::options(...future.oldOptions)
[08:27:02.998]             if (.Platform$OS.type == "windows") {
[08:27:02.998]                 old_names <- names(...future.oldEnvVars)
[08:27:02.998]                 envs <- base::Sys.getenv()
[08:27:02.998]                 names <- names(envs)
[08:27:02.998]                 common <- intersect(names, old_names)
[08:27:02.998]                 added <- setdiff(names, old_names)
[08:27:02.998]                 removed <- setdiff(old_names, names)
[08:27:02.998]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:02.998]                   envs[common]]
[08:27:02.998]                 NAMES <- toupper(changed)
[08:27:02.998]                 args <- list()
[08:27:02.998]                 for (kk in seq_along(NAMES)) {
[08:27:02.998]                   name <- changed[[kk]]
[08:27:02.998]                   NAME <- NAMES[[kk]]
[08:27:02.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.998]                     next
[08:27:02.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.998]                 }
[08:27:02.998]                 NAMES <- toupper(added)
[08:27:02.998]                 for (kk in seq_along(NAMES)) {
[08:27:02.998]                   name <- added[[kk]]
[08:27:02.998]                   NAME <- NAMES[[kk]]
[08:27:02.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.998]                     next
[08:27:02.998]                   args[[name]] <- ""
[08:27:02.998]                 }
[08:27:02.998]                 NAMES <- toupper(removed)
[08:27:02.998]                 for (kk in seq_along(NAMES)) {
[08:27:02.998]                   name <- removed[[kk]]
[08:27:02.998]                   NAME <- NAMES[[kk]]
[08:27:02.998]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:02.998]                     next
[08:27:02.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:02.998]                 }
[08:27:02.998]                 if (length(args) > 0) 
[08:27:02.998]                   base::do.call(base::Sys.setenv, args = args)
[08:27:02.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:02.998]             }
[08:27:02.998]             else {
[08:27:02.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:02.998]             }
[08:27:02.998]             {
[08:27:02.998]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:02.998]                   0L) {
[08:27:02.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:02.998]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:02.998]                   base::options(opts)
[08:27:02.998]                 }
[08:27:02.998]                 {
[08:27:02.998]                   {
[08:27:02.998]                     NULL
[08:27:02.998]                     RNGkind("Mersenne-Twister")
[08:27:02.998]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:02.998]                       inherits = FALSE)
[08:27:02.998]                   }
[08:27:02.998]                   options(future.plan = NULL)
[08:27:02.998]                   if (is.na(NA_character_)) 
[08:27:02.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:02.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:02.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:02.998]                     .init = FALSE)
[08:27:02.998]                 }
[08:27:02.998]             }
[08:27:02.998]         }
[08:27:02.998]     })
[08:27:02.998]     if (TRUE) {
[08:27:02.998]         base::sink(type = "output", split = FALSE)
[08:27:02.998]         if (TRUE) {
[08:27:02.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:02.998]         }
[08:27:02.998]         else {
[08:27:02.998]             ...future.result["stdout"] <- base::list(NULL)
[08:27:02.998]         }
[08:27:02.998]         base::close(...future.stdout)
[08:27:02.998]         ...future.stdout <- NULL
[08:27:02.998]     }
[08:27:02.998]     ...future.result$conditions <- ...future.conditions
[08:27:02.998]     ...future.result$finished <- base::Sys.time()
[08:27:02.998]     ...future.result
[08:27:02.998] }
[08:27:03.000] plan(): Setting new future strategy stack:
[08:27:03.000] List of future strategies:
[08:27:03.000] 1. sequential:
[08:27:03.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.000]    - tweaked: FALSE
[08:27:03.000]    - call: NULL
[08:27:03.000] plan(): nbrOfWorkers() = 1
[08:27:03.001] plan(): Setting new future strategy stack:
[08:27:03.001] List of future strategies:
[08:27:03.001] 1. sequential:
[08:27:03.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.001]    - tweaked: FALSE
[08:27:03.001]    - call: future::plan("sequential")
[08:27:03.002] plan(): nbrOfWorkers() = 1
[08:27:03.002] SequentialFuture started (and completed)
[08:27:03.002] signalConditions() ...
[08:27:03.002]  - include = ‘immediateCondition’
[08:27:03.002]  - exclude = 
[08:27:03.002]  - resignal = FALSE
[08:27:03.002]  - Number of conditions: 1
[08:27:03.003] signalConditions() ... done
[08:27:03.003] - Launch lazy future ... done
[08:27:03.003] run() for ‘SequentialFuture’ ... done
> calls <- backtrace(lenv[[2]])
[08:27:03.003] resolved() for ‘SequentialFuture’ ...
[08:27:03.003] - state: ‘finished’
[08:27:03.003] - run: TRUE
[08:27:03.003] - result: ‘FutureResult’
[08:27:03.003] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
lenv[[2]] %<-% {
    42L
    stop("Woops")
}

[[2]]
futureAssignInternal(target, expr, envir = envir, substitute = FALSE)

[[3]]
futureAssign(name, expr, envir = envir, assign.env = assign.env, 
    substitute = FALSE)

[[4]]
do.call(future::future, args = future.args, envir = assign.env)

[[5]]
(function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE, 
    seed = FALSE, globals = TRUE, packages = NULL, stdout = TRUE, 
    conditions = "condition", earlySignal = FALSE, label = NULL, 
    gc = FALSE, ...) 
{
    if (substitute) 
        expr <- substitute(expr)
    t_start <- Sys.time()
    gp <- getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression, 
        globals = globals)
    expr <- gp$expr
    globals <- gp$globals
    if (length(packages) > 0 || length(gp$packages) > 0) {
        packages <- unique(c(gp$packages, packages))
    }
    gp <- NULL
    attr(globals, "already-done") <- TRUE
    future <- Future(expr, substitute = FALSE, envir = envir, 
        lazy = TRUE, seed = seed, globals = globals, packages = packages, 
        stdout = stdout, conditions = conditions, earlySignal = earlySignal, 
        label = label, gc = gc, ...)
    future$.defaultLocal <- !is.element("local", names(list(...)))
    if (getOption("future.journal", FALSE)) {
        future <- makeFutureJournal(future, event = "create", 
            category = "overhead", start = t_start)
    }
    if (!lazy) {
        future <- run(future)
        future$lazy <- FALSE
        stop_if_not(inherits(future, "Future"), !future$lazy)
    }
    future
})({
    42L
    stop("Woops")
}, envir = <environment>, lazy = FALSE, seed = FALSE, globals = TRUE, 
    packages = NULL, stdout = TRUE, conditions = "condition", 
    earlySignal = FALSE, label = NULL, gc = FALSE)

[[6]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[7]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[8]]
stop("Woops")

[[9]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> ll <- list()
> ll[[1]] <- future({ 42L; stop("Woops") })
[08:27:03.004] getGlobalsAndPackages() ...
[08:27:03.004] Searching for globals...
[08:27:03.005] - globals found: [2] ‘{’, ‘stop’
[08:27:03.005] Searching for globals ... DONE
[08:27:03.005] Resolving globals: FALSE
[08:27:03.005] 
[08:27:03.006] 
[08:27:03.006] getGlobalsAndPackages() ... DONE
[08:27:03.006] run() for ‘Future’ ...
[08:27:03.006] - state: ‘created’
[08:27:03.006] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:03.006] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:03.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:03.007]   - Field: ‘label’
[08:27:03.007]   - Field: ‘local’
[08:27:03.007]   - Field: ‘owner’
[08:27:03.007]   - Field: ‘envir’
[08:27:03.007]   - Field: ‘packages’
[08:27:03.007]   - Field: ‘gc’
[08:27:03.007]   - Field: ‘conditions’
[08:27:03.007]   - Field: ‘expr’
[08:27:03.007]   - Field: ‘uuid’
[08:27:03.007]   - Field: ‘seed’
[08:27:03.008]   - Field: ‘version’
[08:27:03.008]   - Field: ‘result’
[08:27:03.008]   - Field: ‘asynchronous’
[08:27:03.008]   - Field: ‘calls’
[08:27:03.008]   - Field: ‘globals’
[08:27:03.008]   - Field: ‘stdout’
[08:27:03.008]   - Field: ‘earlySignal’
[08:27:03.008]   - Field: ‘lazy’
[08:27:03.008]   - Field: ‘state’
[08:27:03.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:03.008] - Launch lazy future ...
[08:27:03.009] Packages needed by the future expression (n = 0): <none>
[08:27:03.009] Packages needed by future strategies (n = 0): <none>
[08:27:03.009] {
[08:27:03.009]     {
[08:27:03.009]         {
[08:27:03.009]             ...future.startTime <- base::Sys.time()
[08:27:03.009]             {
[08:27:03.009]                 {
[08:27:03.009]                   {
[08:27:03.009]                     base::local({
[08:27:03.009]                       has_future <- base::requireNamespace("future", 
[08:27:03.009]                         quietly = TRUE)
[08:27:03.009]                       if (has_future) {
[08:27:03.009]                         ns <- base::getNamespace("future")
[08:27:03.009]                         version <- ns[[".package"]][["version"]]
[08:27:03.009]                         if (is.null(version)) 
[08:27:03.009]                           version <- utils::packageVersion("future")
[08:27:03.009]                       }
[08:27:03.009]                       else {
[08:27:03.009]                         version <- NULL
[08:27:03.009]                       }
[08:27:03.009]                       if (!has_future || version < "1.8.0") {
[08:27:03.009]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.009]                           "", base::R.version$version.string), 
[08:27:03.009]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:03.009]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.009]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.009]                             "release", "version")], collapse = " "), 
[08:27:03.009]                           hostname = base::Sys.info()[["nodename"]])
[08:27:03.009]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.009]                           info)
[08:27:03.009]                         info <- base::paste(info, collapse = "; ")
[08:27:03.009]                         if (!has_future) {
[08:27:03.009]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.009]                             info)
[08:27:03.009]                         }
[08:27:03.009]                         else {
[08:27:03.009]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.009]                             info, version)
[08:27:03.009]                         }
[08:27:03.009]                         base::stop(msg)
[08:27:03.009]                       }
[08:27:03.009]                     })
[08:27:03.009]                   }
[08:27:03.009]                   ...future.strategy.old <- future::plan("list")
[08:27:03.009]                   options(future.plan = NULL)
[08:27:03.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.009]                 }
[08:27:03.009]                 ...future.workdir <- getwd()
[08:27:03.009]             }
[08:27:03.009]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.009]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.009]         }
[08:27:03.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.009]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.009]             base::names(...future.oldOptions))
[08:27:03.009]     }
[08:27:03.009]     if (FALSE) {
[08:27:03.009]     }
[08:27:03.009]     else {
[08:27:03.009]         if (TRUE) {
[08:27:03.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.009]                 open = "w")
[08:27:03.009]         }
[08:27:03.009]         else {
[08:27:03.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.009]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.009]         }
[08:27:03.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.009]             base::sink(type = "output", split = FALSE)
[08:27:03.009]             base::close(...future.stdout)
[08:27:03.009]         }, add = TRUE)
[08:27:03.009]     }
[08:27:03.009]     ...future.frame <- base::sys.nframe()
[08:27:03.009]     ...future.conditions <- base::list()
[08:27:03.009]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.009]     if (FALSE) {
[08:27:03.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.009]     }
[08:27:03.009]     ...future.result <- base::tryCatch({
[08:27:03.009]         base::withCallingHandlers({
[08:27:03.009]             ...future.value <- base::withVisible(base::local({
[08:27:03.009]                 42L
[08:27:03.009]                 stop("Woops")
[08:27:03.009]             }))
[08:27:03.009]             future::FutureResult(value = ...future.value$value, 
[08:27:03.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.009]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.009]                     ...future.globalenv.names))
[08:27:03.009]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.009]         }, condition = base::local({
[08:27:03.009]             c <- base::c
[08:27:03.009]             inherits <- base::inherits
[08:27:03.009]             invokeRestart <- base::invokeRestart
[08:27:03.009]             length <- base::length
[08:27:03.009]             list <- base::list
[08:27:03.009]             seq.int <- base::seq.int
[08:27:03.009]             signalCondition <- base::signalCondition
[08:27:03.009]             sys.calls <- base::sys.calls
[08:27:03.009]             `[[` <- base::`[[`
[08:27:03.009]             `+` <- base::`+`
[08:27:03.009]             `<<-` <- base::`<<-`
[08:27:03.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.009]                   3L)]
[08:27:03.009]             }
[08:27:03.009]             function(cond) {
[08:27:03.009]                 is_error <- inherits(cond, "error")
[08:27:03.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.009]                   NULL)
[08:27:03.009]                 if (is_error) {
[08:27:03.009]                   sessionInformation <- function() {
[08:27:03.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.009]                       search = base::search(), system = base::Sys.info())
[08:27:03.009]                   }
[08:27:03.009]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.009]                     cond$call), session = sessionInformation(), 
[08:27:03.009]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.009]                   signalCondition(cond)
[08:27:03.009]                 }
[08:27:03.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.009]                 "immediateCondition"))) {
[08:27:03.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.009]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.009]                   if (TRUE && !signal) {
[08:27:03.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.009]                     {
[08:27:03.009]                       inherits <- base::inherits
[08:27:03.009]                       invokeRestart <- base::invokeRestart
[08:27:03.009]                       is.null <- base::is.null
[08:27:03.009]                       muffled <- FALSE
[08:27:03.009]                       if (inherits(cond, "message")) {
[08:27:03.009]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.009]                         if (muffled) 
[08:27:03.009]                           invokeRestart("muffleMessage")
[08:27:03.009]                       }
[08:27:03.009]                       else if (inherits(cond, "warning")) {
[08:27:03.009]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.009]                         if (muffled) 
[08:27:03.009]                           invokeRestart("muffleWarning")
[08:27:03.009]                       }
[08:27:03.009]                       else if (inherits(cond, "condition")) {
[08:27:03.009]                         if (!is.null(pattern)) {
[08:27:03.009]                           computeRestarts <- base::computeRestarts
[08:27:03.009]                           grepl <- base::grepl
[08:27:03.009]                           restarts <- computeRestarts(cond)
[08:27:03.009]                           for (restart in restarts) {
[08:27:03.009]                             name <- restart$name
[08:27:03.009]                             if (is.null(name)) 
[08:27:03.009]                               next
[08:27:03.009]                             if (!grepl(pattern, name)) 
[08:27:03.009]                               next
[08:27:03.009]                             invokeRestart(restart)
[08:27:03.009]                             muffled <- TRUE
[08:27:03.009]                             break
[08:27:03.009]                           }
[08:27:03.009]                         }
[08:27:03.009]                       }
[08:27:03.009]                       invisible(muffled)
[08:27:03.009]                     }
[08:27:03.009]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.009]                   }
[08:27:03.009]                 }
[08:27:03.009]                 else {
[08:27:03.009]                   if (TRUE) {
[08:27:03.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.009]                     {
[08:27:03.009]                       inherits <- base::inherits
[08:27:03.009]                       invokeRestart <- base::invokeRestart
[08:27:03.009]                       is.null <- base::is.null
[08:27:03.009]                       muffled <- FALSE
[08:27:03.009]                       if (inherits(cond, "message")) {
[08:27:03.009]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.009]                         if (muffled) 
[08:27:03.009]                           invokeRestart("muffleMessage")
[08:27:03.009]                       }
[08:27:03.009]                       else if (inherits(cond, "warning")) {
[08:27:03.009]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.009]                         if (muffled) 
[08:27:03.009]                           invokeRestart("muffleWarning")
[08:27:03.009]                       }
[08:27:03.009]                       else if (inherits(cond, "condition")) {
[08:27:03.009]                         if (!is.null(pattern)) {
[08:27:03.009]                           computeRestarts <- base::computeRestarts
[08:27:03.009]                           grepl <- base::grepl
[08:27:03.009]                           restarts <- computeRestarts(cond)
[08:27:03.009]                           for (restart in restarts) {
[08:27:03.009]                             name <- restart$name
[08:27:03.009]                             if (is.null(name)) 
[08:27:03.009]                               next
[08:27:03.009]                             if (!grepl(pattern, name)) 
[08:27:03.009]                               next
[08:27:03.009]                             invokeRestart(restart)
[08:27:03.009]                             muffled <- TRUE
[08:27:03.009]                             break
[08:27:03.009]                           }
[08:27:03.009]                         }
[08:27:03.009]                       }
[08:27:03.009]                       invisible(muffled)
[08:27:03.009]                     }
[08:27:03.009]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.009]                   }
[08:27:03.009]                 }
[08:27:03.009]             }
[08:27:03.009]         }))
[08:27:03.009]     }, error = function(ex) {
[08:27:03.009]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.009]                 ...future.rng), started = ...future.startTime, 
[08:27:03.009]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.009]             version = "1.8"), class = "FutureResult")
[08:27:03.009]     }, finally = {
[08:27:03.009]         if (!identical(...future.workdir, getwd())) 
[08:27:03.009]             setwd(...future.workdir)
[08:27:03.009]         {
[08:27:03.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.009]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.009]             }
[08:27:03.009]             base::options(...future.oldOptions)
[08:27:03.009]             if (.Platform$OS.type == "windows") {
[08:27:03.009]                 old_names <- names(...future.oldEnvVars)
[08:27:03.009]                 envs <- base::Sys.getenv()
[08:27:03.009]                 names <- names(envs)
[08:27:03.009]                 common <- intersect(names, old_names)
[08:27:03.009]                 added <- setdiff(names, old_names)
[08:27:03.009]                 removed <- setdiff(old_names, names)
[08:27:03.009]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.009]                   envs[common]]
[08:27:03.009]                 NAMES <- toupper(changed)
[08:27:03.009]                 args <- list()
[08:27:03.009]                 for (kk in seq_along(NAMES)) {
[08:27:03.009]                   name <- changed[[kk]]
[08:27:03.009]                   NAME <- NAMES[[kk]]
[08:27:03.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.009]                     next
[08:27:03.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.009]                 }
[08:27:03.009]                 NAMES <- toupper(added)
[08:27:03.009]                 for (kk in seq_along(NAMES)) {
[08:27:03.009]                   name <- added[[kk]]
[08:27:03.009]                   NAME <- NAMES[[kk]]
[08:27:03.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.009]                     next
[08:27:03.009]                   args[[name]] <- ""
[08:27:03.009]                 }
[08:27:03.009]                 NAMES <- toupper(removed)
[08:27:03.009]                 for (kk in seq_along(NAMES)) {
[08:27:03.009]                   name <- removed[[kk]]
[08:27:03.009]                   NAME <- NAMES[[kk]]
[08:27:03.009]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.009]                     next
[08:27:03.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.009]                 }
[08:27:03.009]                 if (length(args) > 0) 
[08:27:03.009]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.009]             }
[08:27:03.009]             else {
[08:27:03.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.009]             }
[08:27:03.009]             {
[08:27:03.009]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.009]                   0L) {
[08:27:03.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.009]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.009]                   base::options(opts)
[08:27:03.009]                 }
[08:27:03.009]                 {
[08:27:03.009]                   {
[08:27:03.009]                     NULL
[08:27:03.009]                     RNGkind("Mersenne-Twister")
[08:27:03.009]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:03.009]                       inherits = FALSE)
[08:27:03.009]                   }
[08:27:03.009]                   options(future.plan = NULL)
[08:27:03.009]                   if (is.na(NA_character_)) 
[08:27:03.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.009]                     .init = FALSE)
[08:27:03.009]                 }
[08:27:03.009]             }
[08:27:03.009]         }
[08:27:03.009]     })
[08:27:03.009]     if (TRUE) {
[08:27:03.009]         base::sink(type = "output", split = FALSE)
[08:27:03.009]         if (TRUE) {
[08:27:03.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.009]         }
[08:27:03.009]         else {
[08:27:03.009]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.009]         }
[08:27:03.009]         base::close(...future.stdout)
[08:27:03.009]         ...future.stdout <- NULL
[08:27:03.009]     }
[08:27:03.009]     ...future.result$conditions <- ...future.conditions
[08:27:03.009]     ...future.result$finished <- base::Sys.time()
[08:27:03.009]     ...future.result
[08:27:03.009] }
[08:27:03.011] plan(): Setting new future strategy stack:
[08:27:03.011] List of future strategies:
[08:27:03.011] 1. sequential:
[08:27:03.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.011]    - tweaked: FALSE
[08:27:03.011]    - call: NULL
[08:27:03.012] plan(): nbrOfWorkers() = 1
[08:27:03.013] plan(): Setting new future strategy stack:
[08:27:03.013] List of future strategies:
[08:27:03.013] 1. sequential:
[08:27:03.013]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.013]    - tweaked: FALSE
[08:27:03.013]    - call: future::plan("sequential")
[08:27:03.013] plan(): nbrOfWorkers() = 1
[08:27:03.013] SequentialFuture started (and completed)
[08:27:03.014] signalConditions() ...
[08:27:03.014]  - include = ‘immediateCondition’
[08:27:03.014]  - exclude = 
[08:27:03.014]  - resignal = FALSE
[08:27:03.014]  - Number of conditions: 1
[08:27:03.014] signalConditions() ... done
[08:27:03.014] - Launch lazy future ... done
[08:27:03.014] run() for ‘SequentialFuture’ ... done
> ll[[2]] <- future({ 42L; stop("Woops") })
[08:27:03.014] getGlobalsAndPackages() ...
[08:27:03.014] Searching for globals...
[08:27:03.015] - globals found: [2] ‘{’, ‘stop’
[08:27:03.016] Searching for globals ... DONE
[08:27:03.016] Resolving globals: FALSE
[08:27:03.016] 
[08:27:03.016] 
[08:27:03.016] getGlobalsAndPackages() ... DONE
[08:27:03.016] run() for ‘Future’ ...
[08:27:03.017] - state: ‘created’
[08:27:03.017] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:03.017] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:03.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:03.017]   - Field: ‘label’
[08:27:03.017]   - Field: ‘local’
[08:27:03.017]   - Field: ‘owner’
[08:27:03.017]   - Field: ‘envir’
[08:27:03.017]   - Field: ‘packages’
[08:27:03.018]   - Field: ‘gc’
[08:27:03.018]   - Field: ‘conditions’
[08:27:03.018]   - Field: ‘expr’
[08:27:03.018]   - Field: ‘uuid’
[08:27:03.018]   - Field: ‘seed’
[08:27:03.018]   - Field: ‘version’
[08:27:03.018]   - Field: ‘result’
[08:27:03.018]   - Field: ‘asynchronous’
[08:27:03.018]   - Field: ‘calls’
[08:27:03.018]   - Field: ‘globals’
[08:27:03.018]   - Field: ‘stdout’
[08:27:03.019]   - Field: ‘earlySignal’
[08:27:03.019]   - Field: ‘lazy’
[08:27:03.019]   - Field: ‘state’
[08:27:03.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:03.019] - Launch lazy future ...
[08:27:03.019] Packages needed by the future expression (n = 0): <none>
[08:27:03.019] Packages needed by future strategies (n = 0): <none>
[08:27:03.020] {
[08:27:03.020]     {
[08:27:03.020]         {
[08:27:03.020]             ...future.startTime <- base::Sys.time()
[08:27:03.020]             {
[08:27:03.020]                 {
[08:27:03.020]                   {
[08:27:03.020]                     base::local({
[08:27:03.020]                       has_future <- base::requireNamespace("future", 
[08:27:03.020]                         quietly = TRUE)
[08:27:03.020]                       if (has_future) {
[08:27:03.020]                         ns <- base::getNamespace("future")
[08:27:03.020]                         version <- ns[[".package"]][["version"]]
[08:27:03.020]                         if (is.null(version)) 
[08:27:03.020]                           version <- utils::packageVersion("future")
[08:27:03.020]                       }
[08:27:03.020]                       else {
[08:27:03.020]                         version <- NULL
[08:27:03.020]                       }
[08:27:03.020]                       if (!has_future || version < "1.8.0") {
[08:27:03.020]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.020]                           "", base::R.version$version.string), 
[08:27:03.020]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:03.020]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.020]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.020]                             "release", "version")], collapse = " "), 
[08:27:03.020]                           hostname = base::Sys.info()[["nodename"]])
[08:27:03.020]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.020]                           info)
[08:27:03.020]                         info <- base::paste(info, collapse = "; ")
[08:27:03.020]                         if (!has_future) {
[08:27:03.020]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.020]                             info)
[08:27:03.020]                         }
[08:27:03.020]                         else {
[08:27:03.020]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.020]                             info, version)
[08:27:03.020]                         }
[08:27:03.020]                         base::stop(msg)
[08:27:03.020]                       }
[08:27:03.020]                     })
[08:27:03.020]                   }
[08:27:03.020]                   ...future.strategy.old <- future::plan("list")
[08:27:03.020]                   options(future.plan = NULL)
[08:27:03.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.020]                 }
[08:27:03.020]                 ...future.workdir <- getwd()
[08:27:03.020]             }
[08:27:03.020]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.020]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.020]         }
[08:27:03.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.020]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.020]             base::names(...future.oldOptions))
[08:27:03.020]     }
[08:27:03.020]     if (FALSE) {
[08:27:03.020]     }
[08:27:03.020]     else {
[08:27:03.020]         if (TRUE) {
[08:27:03.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.020]                 open = "w")
[08:27:03.020]         }
[08:27:03.020]         else {
[08:27:03.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.020]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.020]         }
[08:27:03.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.020]             base::sink(type = "output", split = FALSE)
[08:27:03.020]             base::close(...future.stdout)
[08:27:03.020]         }, add = TRUE)
[08:27:03.020]     }
[08:27:03.020]     ...future.frame <- base::sys.nframe()
[08:27:03.020]     ...future.conditions <- base::list()
[08:27:03.020]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.020]     if (FALSE) {
[08:27:03.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.020]     }
[08:27:03.020]     ...future.result <- base::tryCatch({
[08:27:03.020]         base::withCallingHandlers({
[08:27:03.020]             ...future.value <- base::withVisible(base::local({
[08:27:03.020]                 42L
[08:27:03.020]                 stop("Woops")
[08:27:03.020]             }))
[08:27:03.020]             future::FutureResult(value = ...future.value$value, 
[08:27:03.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.020]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.020]                     ...future.globalenv.names))
[08:27:03.020]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.020]         }, condition = base::local({
[08:27:03.020]             c <- base::c
[08:27:03.020]             inherits <- base::inherits
[08:27:03.020]             invokeRestart <- base::invokeRestart
[08:27:03.020]             length <- base::length
[08:27:03.020]             list <- base::list
[08:27:03.020]             seq.int <- base::seq.int
[08:27:03.020]             signalCondition <- base::signalCondition
[08:27:03.020]             sys.calls <- base::sys.calls
[08:27:03.020]             `[[` <- base::`[[`
[08:27:03.020]             `+` <- base::`+`
[08:27:03.020]             `<<-` <- base::`<<-`
[08:27:03.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.020]                   3L)]
[08:27:03.020]             }
[08:27:03.020]             function(cond) {
[08:27:03.020]                 is_error <- inherits(cond, "error")
[08:27:03.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.020]                   NULL)
[08:27:03.020]                 if (is_error) {
[08:27:03.020]                   sessionInformation <- function() {
[08:27:03.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.020]                       search = base::search(), system = base::Sys.info())
[08:27:03.020]                   }
[08:27:03.020]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.020]                     cond$call), session = sessionInformation(), 
[08:27:03.020]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.020]                   signalCondition(cond)
[08:27:03.020]                 }
[08:27:03.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.020]                 "immediateCondition"))) {
[08:27:03.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.020]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.020]                   if (TRUE && !signal) {
[08:27:03.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.020]                     {
[08:27:03.020]                       inherits <- base::inherits
[08:27:03.020]                       invokeRestart <- base::invokeRestart
[08:27:03.020]                       is.null <- base::is.null
[08:27:03.020]                       muffled <- FALSE
[08:27:03.020]                       if (inherits(cond, "message")) {
[08:27:03.020]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.020]                         if (muffled) 
[08:27:03.020]                           invokeRestart("muffleMessage")
[08:27:03.020]                       }
[08:27:03.020]                       else if (inherits(cond, "warning")) {
[08:27:03.020]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.020]                         if (muffled) 
[08:27:03.020]                           invokeRestart("muffleWarning")
[08:27:03.020]                       }
[08:27:03.020]                       else if (inherits(cond, "condition")) {
[08:27:03.020]                         if (!is.null(pattern)) {
[08:27:03.020]                           computeRestarts <- base::computeRestarts
[08:27:03.020]                           grepl <- base::grepl
[08:27:03.020]                           restarts <- computeRestarts(cond)
[08:27:03.020]                           for (restart in restarts) {
[08:27:03.020]                             name <- restart$name
[08:27:03.020]                             if (is.null(name)) 
[08:27:03.020]                               next
[08:27:03.020]                             if (!grepl(pattern, name)) 
[08:27:03.020]                               next
[08:27:03.020]                             invokeRestart(restart)
[08:27:03.020]                             muffled <- TRUE
[08:27:03.020]                             break
[08:27:03.020]                           }
[08:27:03.020]                         }
[08:27:03.020]                       }
[08:27:03.020]                       invisible(muffled)
[08:27:03.020]                     }
[08:27:03.020]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.020]                   }
[08:27:03.020]                 }
[08:27:03.020]                 else {
[08:27:03.020]                   if (TRUE) {
[08:27:03.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.020]                     {
[08:27:03.020]                       inherits <- base::inherits
[08:27:03.020]                       invokeRestart <- base::invokeRestart
[08:27:03.020]                       is.null <- base::is.null
[08:27:03.020]                       muffled <- FALSE
[08:27:03.020]                       if (inherits(cond, "message")) {
[08:27:03.020]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.020]                         if (muffled) 
[08:27:03.020]                           invokeRestart("muffleMessage")
[08:27:03.020]                       }
[08:27:03.020]                       else if (inherits(cond, "warning")) {
[08:27:03.020]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.020]                         if (muffled) 
[08:27:03.020]                           invokeRestart("muffleWarning")
[08:27:03.020]                       }
[08:27:03.020]                       else if (inherits(cond, "condition")) {
[08:27:03.020]                         if (!is.null(pattern)) {
[08:27:03.020]                           computeRestarts <- base::computeRestarts
[08:27:03.020]                           grepl <- base::grepl
[08:27:03.020]                           restarts <- computeRestarts(cond)
[08:27:03.020]                           for (restart in restarts) {
[08:27:03.020]                             name <- restart$name
[08:27:03.020]                             if (is.null(name)) 
[08:27:03.020]                               next
[08:27:03.020]                             if (!grepl(pattern, name)) 
[08:27:03.020]                               next
[08:27:03.020]                             invokeRestart(restart)
[08:27:03.020]                             muffled <- TRUE
[08:27:03.020]                             break
[08:27:03.020]                           }
[08:27:03.020]                         }
[08:27:03.020]                       }
[08:27:03.020]                       invisible(muffled)
[08:27:03.020]                     }
[08:27:03.020]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.020]                   }
[08:27:03.020]                 }
[08:27:03.020]             }
[08:27:03.020]         }))
[08:27:03.020]     }, error = function(ex) {
[08:27:03.020]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.020]                 ...future.rng), started = ...future.startTime, 
[08:27:03.020]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.020]             version = "1.8"), class = "FutureResult")
[08:27:03.020]     }, finally = {
[08:27:03.020]         if (!identical(...future.workdir, getwd())) 
[08:27:03.020]             setwd(...future.workdir)
[08:27:03.020]         {
[08:27:03.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.020]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.020]             }
[08:27:03.020]             base::options(...future.oldOptions)
[08:27:03.020]             if (.Platform$OS.type == "windows") {
[08:27:03.020]                 old_names <- names(...future.oldEnvVars)
[08:27:03.020]                 envs <- base::Sys.getenv()
[08:27:03.020]                 names <- names(envs)
[08:27:03.020]                 common <- intersect(names, old_names)
[08:27:03.020]                 added <- setdiff(names, old_names)
[08:27:03.020]                 removed <- setdiff(old_names, names)
[08:27:03.020]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.020]                   envs[common]]
[08:27:03.020]                 NAMES <- toupper(changed)
[08:27:03.020]                 args <- list()
[08:27:03.020]                 for (kk in seq_along(NAMES)) {
[08:27:03.020]                   name <- changed[[kk]]
[08:27:03.020]                   NAME <- NAMES[[kk]]
[08:27:03.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.020]                     next
[08:27:03.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.020]                 }
[08:27:03.020]                 NAMES <- toupper(added)
[08:27:03.020]                 for (kk in seq_along(NAMES)) {
[08:27:03.020]                   name <- added[[kk]]
[08:27:03.020]                   NAME <- NAMES[[kk]]
[08:27:03.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.020]                     next
[08:27:03.020]                   args[[name]] <- ""
[08:27:03.020]                 }
[08:27:03.020]                 NAMES <- toupper(removed)
[08:27:03.020]                 for (kk in seq_along(NAMES)) {
[08:27:03.020]                   name <- removed[[kk]]
[08:27:03.020]                   NAME <- NAMES[[kk]]
[08:27:03.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.020]                     next
[08:27:03.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.020]                 }
[08:27:03.020]                 if (length(args) > 0) 
[08:27:03.020]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.020]             }
[08:27:03.020]             else {
[08:27:03.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.020]             }
[08:27:03.020]             {
[08:27:03.020]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.020]                   0L) {
[08:27:03.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.020]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.020]                   base::options(opts)
[08:27:03.020]                 }
[08:27:03.020]                 {
[08:27:03.020]                   {
[08:27:03.020]                     NULL
[08:27:03.020]                     RNGkind("Mersenne-Twister")
[08:27:03.020]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:03.020]                       inherits = FALSE)
[08:27:03.020]                   }
[08:27:03.020]                   options(future.plan = NULL)
[08:27:03.020]                   if (is.na(NA_character_)) 
[08:27:03.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.020]                     .init = FALSE)
[08:27:03.020]                 }
[08:27:03.020]             }
[08:27:03.020]         }
[08:27:03.020]     })
[08:27:03.020]     if (TRUE) {
[08:27:03.020]         base::sink(type = "output", split = FALSE)
[08:27:03.020]         if (TRUE) {
[08:27:03.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.020]         }
[08:27:03.020]         else {
[08:27:03.020]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.020]         }
[08:27:03.020]         base::close(...future.stdout)
[08:27:03.020]         ...future.stdout <- NULL
[08:27:03.020]     }
[08:27:03.020]     ...future.result$conditions <- ...future.conditions
[08:27:03.020]     ...future.result$finished <- base::Sys.time()
[08:27:03.020]     ...future.result
[08:27:03.020] }
[08:27:03.021] plan(): Setting new future strategy stack:
[08:27:03.022] List of future strategies:
[08:27:03.022] 1. sequential:
[08:27:03.022]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.022]    - tweaked: FALSE
[08:27:03.022]    - call: NULL
[08:27:03.022] plan(): nbrOfWorkers() = 1
[08:27:03.023] plan(): Setting new future strategy stack:
[08:27:03.023] List of future strategies:
[08:27:03.023] 1. sequential:
[08:27:03.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.023]    - tweaked: FALSE
[08:27:03.023]    - call: future::plan("sequential")
[08:27:03.023] plan(): nbrOfWorkers() = 1
[08:27:03.024] SequentialFuture started (and completed)
[08:27:03.024] signalConditions() ...
[08:27:03.024]  - include = ‘immediateCondition’
[08:27:03.024]  - exclude = 
[08:27:03.024]  - resignal = FALSE
[08:27:03.024]  - Number of conditions: 1
[08:27:03.024] signalConditions() ... done
[08:27:03.024] - Launch lazy future ... done
[08:27:03.024] run() for ‘SequentialFuture’ ... done
> vs <- value(ll, signal = FALSE)
[08:27:03.025] resolve() on list ...
[08:27:03.025]  recursive: 0
[08:27:03.025]  length: 2
[08:27:03.025] 
[08:27:03.025] resolved() for ‘SequentialFuture’ ...
[08:27:03.025] - state: ‘finished’
[08:27:03.025] - run: TRUE
[08:27:03.026] - result: ‘FutureResult’
[08:27:03.026] resolved() for ‘SequentialFuture’ ... done
[08:27:03.026] Future #1
[08:27:03.026] signalConditions() ...
[08:27:03.026]  - include = ‘immediateCondition’
[08:27:03.028]  - exclude = 
[08:27:03.028]  - resignal = FALSE
[08:27:03.028]  - Number of conditions: 1
[08:27:03.028] signalConditions() ... done
[08:27:03.028] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:27:03.028] - nx: 2
[08:27:03.028] - relay: TRUE
[08:27:03.028] - stdout: TRUE
[08:27:03.029] - signal: FALSE
[08:27:03.029] - resignal: FALSE
[08:27:03.029] - force: TRUE
[08:27:03.029] - relayed: [n=2] FALSE, FALSE
[08:27:03.029] - queued futures: [n=2] FALSE, FALSE
[08:27:03.029]  - until=1
[08:27:03.029]  - relaying element #1
[08:27:03.029] signalConditions() ...
[08:27:03.029]  - include = ‘immediateCondition’
[08:27:03.029]  - exclude = 
[08:27:03.029]  - resignal = FALSE
[08:27:03.029]  - Number of conditions: 1
[08:27:03.030] signalConditions() ... done
[08:27:03.030] - relayed: [n=2] TRUE, FALSE
[08:27:03.030] - queued futures: [n=2] TRUE, FALSE
[08:27:03.030] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:27:03.030]  length: 1 (resolved future 1)
[08:27:03.030] resolved() for ‘SequentialFuture’ ...
[08:27:03.030] - state: ‘finished’
[08:27:03.030] - run: TRUE
[08:27:03.030] - result: ‘FutureResult’
[08:27:03.031] resolved() for ‘SequentialFuture’ ... done
[08:27:03.031] Future #2
[08:27:03.031] signalConditions() ...
[08:27:03.031]  - include = ‘immediateCondition’
[08:27:03.031]  - exclude = 
[08:27:03.031]  - resignal = FALSE
[08:27:03.031]  - Number of conditions: 1
[08:27:03.031] signalConditions() ... done
[08:27:03.031] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:03.031] - nx: 2
[08:27:03.031] - relay: TRUE
[08:27:03.032] - stdout: TRUE
[08:27:03.032] - signal: FALSE
[08:27:03.032] - resignal: FALSE
[08:27:03.032] - force: TRUE
[08:27:03.032] - relayed: [n=2] TRUE, FALSE
[08:27:03.032] - queued futures: [n=2] TRUE, FALSE
[08:27:03.032]  - until=2
[08:27:03.032]  - relaying element #2
[08:27:03.032] signalConditions() ...
[08:27:03.032]  - include = ‘immediateCondition’
[08:27:03.032]  - exclude = 
[08:27:03.032]  - resignal = FALSE
[08:27:03.032]  - Number of conditions: 1
[08:27:03.033] signalConditions() ... done
[08:27:03.033] - relayed: [n=2] TRUE, TRUE
[08:27:03.033] - queued futures: [n=2] TRUE, TRUE
[08:27:03.033] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:03.033]  length: 0 (resolved future 2)
[08:27:03.033] Relaying remaining futures
[08:27:03.033] signalConditionsASAP(NULL, pos=0) ...
[08:27:03.033] - nx: 2
[08:27:03.033] - relay: TRUE
[08:27:03.033] - stdout: TRUE
[08:27:03.033] - signal: FALSE
[08:27:03.034] - resignal: FALSE
[08:27:03.034] - force: TRUE
[08:27:03.034] - relayed: [n=2] TRUE, TRUE
[08:27:03.034] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:27:03.034] - relayed: [n=2] TRUE, TRUE
[08:27:03.034] - queued futures: [n=2] TRUE, TRUE
[08:27:03.034] signalConditionsASAP(NULL, pos=0) ... done
[08:27:03.034] resolve() on list ... DONE
[08:27:03.034] signalConditions() ...
[08:27:03.034]  - include = ‘immediateCondition’
[08:27:03.034]  - exclude = 
[08:27:03.034]  - resignal = FALSE
[08:27:03.035]  - Number of conditions: 1
[08:27:03.035] signalConditions() ... done
[08:27:03.035] signalConditions() ...
[08:27:03.035]  - include = ‘immediateCondition’
[08:27:03.035]  - exclude = 
[08:27:03.035]  - resignal = FALSE
[08:27:03.035]  - Number of conditions: 1
[08:27:03.035] signalConditions() ... done
> calls <- backtrace(ll[[2]])
[08:27:03.036] resolved() for ‘SequentialFuture’ ...
[08:27:03.036] - state: ‘finished’
[08:27:03.036] - run: TRUE
[08:27:03.036] - result: ‘FutureResult’
[08:27:03.036] resolved() for ‘SequentialFuture’ ... done
> print(calls)
[[1]]
future({
    42L
    stop("Woops")
})

[[2]]
Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, 
    seed = seed, globals = globals, packages = packages, stdout = stdout, 
    conditions = conditions, earlySignal = earlySignal, label = label, 
    gc = gc, ...)

[[3]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

[[4]]
stop("Woops")

[[5]]
eval(quote({
    42L
    stop("Woops")
}), new.env())

> stopifnot(is.list(calls))
> 
> message("*** backtrace( ) - subsetting ... DONE")
*** backtrace( ) - subsetting ... DONE
> 
> 
> message("*** backtrace( ) - exceptions ...")
*** backtrace( ) - exceptions ...
> 
> message("- No condition ...")
- No condition ...
> f <- future(42L)
[08:27:03.036] getGlobalsAndPackages() ...
[08:27:03.036] Searching for globals...
[08:27:03.037] 
[08:27:03.037] Searching for globals ... DONE
[08:27:03.037] - globals: [0] <none>
[08:27:03.037] getGlobalsAndPackages() ... DONE
[08:27:03.037] run() for ‘Future’ ...
[08:27:03.037] - state: ‘created’
[08:27:03.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:03.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:03.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:03.038]   - Field: ‘label’
[08:27:03.038]   - Field: ‘local’
[08:27:03.038]   - Field: ‘owner’
[08:27:03.038]   - Field: ‘envir’
[08:27:03.038]   - Field: ‘packages’
[08:27:03.038]   - Field: ‘gc’
[08:27:03.038]   - Field: ‘conditions’
[08:27:03.039]   - Field: ‘expr’
[08:27:03.039]   - Field: ‘uuid’
[08:27:03.039]   - Field: ‘seed’
[08:27:03.039]   - Field: ‘version’
[08:27:03.039]   - Field: ‘result’
[08:27:03.039]   - Field: ‘asynchronous’
[08:27:03.039]   - Field: ‘calls’
[08:27:03.039]   - Field: ‘globals’
[08:27:03.039]   - Field: ‘stdout’
[08:27:03.039]   - Field: ‘earlySignal’
[08:27:03.039]   - Field: ‘lazy’
[08:27:03.040]   - Field: ‘state’
[08:27:03.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:03.040] - Launch lazy future ...
[08:27:03.040] Packages needed by the future expression (n = 0): <none>
[08:27:03.040] Packages needed by future strategies (n = 0): <none>
[08:27:03.040] {
[08:27:03.040]     {
[08:27:03.040]         {
[08:27:03.040]             ...future.startTime <- base::Sys.time()
[08:27:03.040]             {
[08:27:03.040]                 {
[08:27:03.040]                   {
[08:27:03.040]                     base::local({
[08:27:03.040]                       has_future <- base::requireNamespace("future", 
[08:27:03.040]                         quietly = TRUE)
[08:27:03.040]                       if (has_future) {
[08:27:03.040]                         ns <- base::getNamespace("future")
[08:27:03.040]                         version <- ns[[".package"]][["version"]]
[08:27:03.040]                         if (is.null(version)) 
[08:27:03.040]                           version <- utils::packageVersion("future")
[08:27:03.040]                       }
[08:27:03.040]                       else {
[08:27:03.040]                         version <- NULL
[08:27:03.040]                       }
[08:27:03.040]                       if (!has_future || version < "1.8.0") {
[08:27:03.040]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.040]                           "", base::R.version$version.string), 
[08:27:03.040]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:03.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.040]                             "release", "version")], collapse = " "), 
[08:27:03.040]                           hostname = base::Sys.info()[["nodename"]])
[08:27:03.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.040]                           info)
[08:27:03.040]                         info <- base::paste(info, collapse = "; ")
[08:27:03.040]                         if (!has_future) {
[08:27:03.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.040]                             info)
[08:27:03.040]                         }
[08:27:03.040]                         else {
[08:27:03.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.040]                             info, version)
[08:27:03.040]                         }
[08:27:03.040]                         base::stop(msg)
[08:27:03.040]                       }
[08:27:03.040]                     })
[08:27:03.040]                   }
[08:27:03.040]                   ...future.strategy.old <- future::plan("list")
[08:27:03.040]                   options(future.plan = NULL)
[08:27:03.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.040]                 }
[08:27:03.040]                 ...future.workdir <- getwd()
[08:27:03.040]             }
[08:27:03.040]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.040]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.040]         }
[08:27:03.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.040]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.040]             base::names(...future.oldOptions))
[08:27:03.040]     }
[08:27:03.040]     if (FALSE) {
[08:27:03.040]     }
[08:27:03.040]     else {
[08:27:03.040]         if (TRUE) {
[08:27:03.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.040]                 open = "w")
[08:27:03.040]         }
[08:27:03.040]         else {
[08:27:03.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.040]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.040]         }
[08:27:03.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.040]             base::sink(type = "output", split = FALSE)
[08:27:03.040]             base::close(...future.stdout)
[08:27:03.040]         }, add = TRUE)
[08:27:03.040]     }
[08:27:03.040]     ...future.frame <- base::sys.nframe()
[08:27:03.040]     ...future.conditions <- base::list()
[08:27:03.040]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.040]     if (FALSE) {
[08:27:03.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.040]     }
[08:27:03.040]     ...future.result <- base::tryCatch({
[08:27:03.040]         base::withCallingHandlers({
[08:27:03.040]             ...future.value <- base::withVisible(base::local(42L))
[08:27:03.040]             future::FutureResult(value = ...future.value$value, 
[08:27:03.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.040]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.040]                     ...future.globalenv.names))
[08:27:03.040]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.040]         }, condition = base::local({
[08:27:03.040]             c <- base::c
[08:27:03.040]             inherits <- base::inherits
[08:27:03.040]             invokeRestart <- base::invokeRestart
[08:27:03.040]             length <- base::length
[08:27:03.040]             list <- base::list
[08:27:03.040]             seq.int <- base::seq.int
[08:27:03.040]             signalCondition <- base::signalCondition
[08:27:03.040]             sys.calls <- base::sys.calls
[08:27:03.040]             `[[` <- base::`[[`
[08:27:03.040]             `+` <- base::`+`
[08:27:03.040]             `<<-` <- base::`<<-`
[08:27:03.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.040]                   3L)]
[08:27:03.040]             }
[08:27:03.040]             function(cond) {
[08:27:03.040]                 is_error <- inherits(cond, "error")
[08:27:03.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.040]                   NULL)
[08:27:03.040]                 if (is_error) {
[08:27:03.040]                   sessionInformation <- function() {
[08:27:03.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.040]                       search = base::search(), system = base::Sys.info())
[08:27:03.040]                   }
[08:27:03.040]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.040]                     cond$call), session = sessionInformation(), 
[08:27:03.040]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.040]                   signalCondition(cond)
[08:27:03.040]                 }
[08:27:03.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.040]                 "immediateCondition"))) {
[08:27:03.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.040]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.040]                   if (TRUE && !signal) {
[08:27:03.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.040]                     {
[08:27:03.040]                       inherits <- base::inherits
[08:27:03.040]                       invokeRestart <- base::invokeRestart
[08:27:03.040]                       is.null <- base::is.null
[08:27:03.040]                       muffled <- FALSE
[08:27:03.040]                       if (inherits(cond, "message")) {
[08:27:03.040]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.040]                         if (muffled) 
[08:27:03.040]                           invokeRestart("muffleMessage")
[08:27:03.040]                       }
[08:27:03.040]                       else if (inherits(cond, "warning")) {
[08:27:03.040]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.040]                         if (muffled) 
[08:27:03.040]                           invokeRestart("muffleWarning")
[08:27:03.040]                       }
[08:27:03.040]                       else if (inherits(cond, "condition")) {
[08:27:03.040]                         if (!is.null(pattern)) {
[08:27:03.040]                           computeRestarts <- base::computeRestarts
[08:27:03.040]                           grepl <- base::grepl
[08:27:03.040]                           restarts <- computeRestarts(cond)
[08:27:03.040]                           for (restart in restarts) {
[08:27:03.040]                             name <- restart$name
[08:27:03.040]                             if (is.null(name)) 
[08:27:03.040]                               next
[08:27:03.040]                             if (!grepl(pattern, name)) 
[08:27:03.040]                               next
[08:27:03.040]                             invokeRestart(restart)
[08:27:03.040]                             muffled <- TRUE
[08:27:03.040]                             break
[08:27:03.040]                           }
[08:27:03.040]                         }
[08:27:03.040]                       }
[08:27:03.040]                       invisible(muffled)
[08:27:03.040]                     }
[08:27:03.040]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.040]                   }
[08:27:03.040]                 }
[08:27:03.040]                 else {
[08:27:03.040]                   if (TRUE) {
[08:27:03.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.040]                     {
[08:27:03.040]                       inherits <- base::inherits
[08:27:03.040]                       invokeRestart <- base::invokeRestart
[08:27:03.040]                       is.null <- base::is.null
[08:27:03.040]                       muffled <- FALSE
[08:27:03.040]                       if (inherits(cond, "message")) {
[08:27:03.040]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.040]                         if (muffled) 
[08:27:03.040]                           invokeRestart("muffleMessage")
[08:27:03.040]                       }
[08:27:03.040]                       else if (inherits(cond, "warning")) {
[08:27:03.040]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.040]                         if (muffled) 
[08:27:03.040]                           invokeRestart("muffleWarning")
[08:27:03.040]                       }
[08:27:03.040]                       else if (inherits(cond, "condition")) {
[08:27:03.040]                         if (!is.null(pattern)) {
[08:27:03.040]                           computeRestarts <- base::computeRestarts
[08:27:03.040]                           grepl <- base::grepl
[08:27:03.040]                           restarts <- computeRestarts(cond)
[08:27:03.040]                           for (restart in restarts) {
[08:27:03.040]                             name <- restart$name
[08:27:03.040]                             if (is.null(name)) 
[08:27:03.040]                               next
[08:27:03.040]                             if (!grepl(pattern, name)) 
[08:27:03.040]                               next
[08:27:03.040]                             invokeRestart(restart)
[08:27:03.040]                             muffled <- TRUE
[08:27:03.040]                             break
[08:27:03.040]                           }
[08:27:03.040]                         }
[08:27:03.040]                       }
[08:27:03.040]                       invisible(muffled)
[08:27:03.040]                     }
[08:27:03.040]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.040]                   }
[08:27:03.040]                 }
[08:27:03.040]             }
[08:27:03.040]         }))
[08:27:03.040]     }, error = function(ex) {
[08:27:03.040]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.040]                 ...future.rng), started = ...future.startTime, 
[08:27:03.040]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.040]             version = "1.8"), class = "FutureResult")
[08:27:03.040]     }, finally = {
[08:27:03.040]         if (!identical(...future.workdir, getwd())) 
[08:27:03.040]             setwd(...future.workdir)
[08:27:03.040]         {
[08:27:03.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.040]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.040]             }
[08:27:03.040]             base::options(...future.oldOptions)
[08:27:03.040]             if (.Platform$OS.type == "windows") {
[08:27:03.040]                 old_names <- names(...future.oldEnvVars)
[08:27:03.040]                 envs <- base::Sys.getenv()
[08:27:03.040]                 names <- names(envs)
[08:27:03.040]                 common <- intersect(names, old_names)
[08:27:03.040]                 added <- setdiff(names, old_names)
[08:27:03.040]                 removed <- setdiff(old_names, names)
[08:27:03.040]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.040]                   envs[common]]
[08:27:03.040]                 NAMES <- toupper(changed)
[08:27:03.040]                 args <- list()
[08:27:03.040]                 for (kk in seq_along(NAMES)) {
[08:27:03.040]                   name <- changed[[kk]]
[08:27:03.040]                   NAME <- NAMES[[kk]]
[08:27:03.040]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.040]                     next
[08:27:03.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.040]                 }
[08:27:03.040]                 NAMES <- toupper(added)
[08:27:03.040]                 for (kk in seq_along(NAMES)) {
[08:27:03.040]                   name <- added[[kk]]
[08:27:03.040]                   NAME <- NAMES[[kk]]
[08:27:03.040]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.040]                     next
[08:27:03.040]                   args[[name]] <- ""
[08:27:03.040]                 }
[08:27:03.040]                 NAMES <- toupper(removed)
[08:27:03.040]                 for (kk in seq_along(NAMES)) {
[08:27:03.040]                   name <- removed[[kk]]
[08:27:03.040]                   NAME <- NAMES[[kk]]
[08:27:03.040]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.040]                     next
[08:27:03.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.040]                 }
[08:27:03.040]                 if (length(args) > 0) 
[08:27:03.040]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.040]             }
[08:27:03.040]             else {
[08:27:03.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.040]             }
[08:27:03.040]             {
[08:27:03.040]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.040]                   0L) {
[08:27:03.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.040]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.040]                   base::options(opts)
[08:27:03.040]                 }
[08:27:03.040]                 {
[08:27:03.040]                   {
[08:27:03.040]                     NULL
[08:27:03.040]                     RNGkind("Mersenne-Twister")
[08:27:03.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:03.040]                       inherits = FALSE)
[08:27:03.040]                   }
[08:27:03.040]                   options(future.plan = NULL)
[08:27:03.040]                   if (is.na(NA_character_)) 
[08:27:03.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.040]                     .init = FALSE)
[08:27:03.040]                 }
[08:27:03.040]             }
[08:27:03.040]         }
[08:27:03.040]     })
[08:27:03.040]     if (TRUE) {
[08:27:03.040]         base::sink(type = "output", split = FALSE)
[08:27:03.040]         if (TRUE) {
[08:27:03.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.040]         }
[08:27:03.040]         else {
[08:27:03.040]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.040]         }
[08:27:03.040]         base::close(...future.stdout)
[08:27:03.040]         ...future.stdout <- NULL
[08:27:03.040]     }
[08:27:03.040]     ...future.result$conditions <- ...future.conditions
[08:27:03.040]     ...future.result$finished <- base::Sys.time()
[08:27:03.040]     ...future.result
[08:27:03.040] }
[08:27:03.042] plan(): Setting new future strategy stack:
[08:27:03.042] List of future strategies:
[08:27:03.042] 1. sequential:
[08:27:03.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.042]    - tweaked: FALSE
[08:27:03.042]    - call: NULL
[08:27:03.043] plan(): nbrOfWorkers() = 1
[08:27:03.044] plan(): Setting new future strategy stack:
[08:27:03.044] List of future strategies:
[08:27:03.044] 1. sequential:
[08:27:03.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.044]    - tweaked: FALSE
[08:27:03.044]    - call: future::plan("sequential")
[08:27:03.044] plan(): nbrOfWorkers() = 1
[08:27:03.045] SequentialFuture started (and completed)
[08:27:03.045] - Launch lazy future ... done
[08:27:03.045] run() for ‘SequentialFuture’ ... done
> res <- tryCatch(backtrace(f), error = identity)
[08:27:03.045] resolved() for ‘SequentialFuture’ ...
[08:27:03.045] - state: ‘finished’
[08:27:03.045] - run: TRUE
[08:27:03.045] - result: ‘FutureResult’
[08:27:03.045] resolved() for ‘SequentialFuture’ ... done
> print(res)
<simpleError: No error was caught for this future: ‘f’>
> stopifnot(inherits(res, "error"))
> 
> message("- No call stack ...")
- No call stack ...
> f <- future({ 42L; stop("Woops") })
[08:27:03.046] getGlobalsAndPackages() ...
[08:27:03.046] Searching for globals...
[08:27:03.047] - globals found: [2] ‘{’, ‘stop’
[08:27:03.047] Searching for globals ... DONE
[08:27:03.047] Resolving globals: FALSE
[08:27:03.047] 
[08:27:03.047] 
[08:27:03.048] getGlobalsAndPackages() ... DONE
[08:27:03.048] run() for ‘Future’ ...
[08:27:03.048] - state: ‘created’
[08:27:03.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:03.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:03.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:03.048]   - Field: ‘label’
[08:27:03.049]   - Field: ‘local’
[08:27:03.049]   - Field: ‘owner’
[08:27:03.049]   - Field: ‘envir’
[08:27:03.049]   - Field: ‘packages’
[08:27:03.049]   - Field: ‘gc’
[08:27:03.049]   - Field: ‘conditions’
[08:27:03.049]   - Field: ‘expr’
[08:27:03.049]   - Field: ‘uuid’
[08:27:03.049]   - Field: ‘seed’
[08:27:03.049]   - Field: ‘version’
[08:27:03.049]   - Field: ‘result’
[08:27:03.049]   - Field: ‘asynchronous’
[08:27:03.050]   - Field: ‘calls’
[08:27:03.050]   - Field: ‘globals’
[08:27:03.050]   - Field: ‘stdout’
[08:27:03.050]   - Field: ‘earlySignal’
[08:27:03.050]   - Field: ‘lazy’
[08:27:03.050]   - Field: ‘state’
[08:27:03.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:03.050] - Launch lazy future ...
[08:27:03.050] Packages needed by the future expression (n = 0): <none>
[08:27:03.050] Packages needed by future strategies (n = 0): <none>
[08:27:03.051] {
[08:27:03.051]     {
[08:27:03.051]         {
[08:27:03.051]             ...future.startTime <- base::Sys.time()
[08:27:03.051]             {
[08:27:03.051]                 {
[08:27:03.051]                   {
[08:27:03.051]                     base::local({
[08:27:03.051]                       has_future <- base::requireNamespace("future", 
[08:27:03.051]                         quietly = TRUE)
[08:27:03.051]                       if (has_future) {
[08:27:03.051]                         ns <- base::getNamespace("future")
[08:27:03.051]                         version <- ns[[".package"]][["version"]]
[08:27:03.051]                         if (is.null(version)) 
[08:27:03.051]                           version <- utils::packageVersion("future")
[08:27:03.051]                       }
[08:27:03.051]                       else {
[08:27:03.051]                         version <- NULL
[08:27:03.051]                       }
[08:27:03.051]                       if (!has_future || version < "1.8.0") {
[08:27:03.051]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.051]                           "", base::R.version$version.string), 
[08:27:03.051]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:03.051]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.051]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.051]                             "release", "version")], collapse = " "), 
[08:27:03.051]                           hostname = base::Sys.info()[["nodename"]])
[08:27:03.051]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.051]                           info)
[08:27:03.051]                         info <- base::paste(info, collapse = "; ")
[08:27:03.051]                         if (!has_future) {
[08:27:03.051]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.051]                             info)
[08:27:03.051]                         }
[08:27:03.051]                         else {
[08:27:03.051]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.051]                             info, version)
[08:27:03.051]                         }
[08:27:03.051]                         base::stop(msg)
[08:27:03.051]                       }
[08:27:03.051]                     })
[08:27:03.051]                   }
[08:27:03.051]                   ...future.strategy.old <- future::plan("list")
[08:27:03.051]                   options(future.plan = NULL)
[08:27:03.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.051]                 }
[08:27:03.051]                 ...future.workdir <- getwd()
[08:27:03.051]             }
[08:27:03.051]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.051]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.051]         }
[08:27:03.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.051]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.051]             base::names(...future.oldOptions))
[08:27:03.051]     }
[08:27:03.051]     if (FALSE) {
[08:27:03.051]     }
[08:27:03.051]     else {
[08:27:03.051]         if (TRUE) {
[08:27:03.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.051]                 open = "w")
[08:27:03.051]         }
[08:27:03.051]         else {
[08:27:03.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.051]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.051]         }
[08:27:03.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.051]             base::sink(type = "output", split = FALSE)
[08:27:03.051]             base::close(...future.stdout)
[08:27:03.051]         }, add = TRUE)
[08:27:03.051]     }
[08:27:03.051]     ...future.frame <- base::sys.nframe()
[08:27:03.051]     ...future.conditions <- base::list()
[08:27:03.051]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.051]     if (FALSE) {
[08:27:03.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.051]     }
[08:27:03.051]     ...future.result <- base::tryCatch({
[08:27:03.051]         base::withCallingHandlers({
[08:27:03.051]             ...future.value <- base::withVisible(base::local({
[08:27:03.051]                 42L
[08:27:03.051]                 stop("Woops")
[08:27:03.051]             }))
[08:27:03.051]             future::FutureResult(value = ...future.value$value, 
[08:27:03.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.051]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.051]                     ...future.globalenv.names))
[08:27:03.051]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.051]         }, condition = base::local({
[08:27:03.051]             c <- base::c
[08:27:03.051]             inherits <- base::inherits
[08:27:03.051]             invokeRestart <- base::invokeRestart
[08:27:03.051]             length <- base::length
[08:27:03.051]             list <- base::list
[08:27:03.051]             seq.int <- base::seq.int
[08:27:03.051]             signalCondition <- base::signalCondition
[08:27:03.051]             sys.calls <- base::sys.calls
[08:27:03.051]             `[[` <- base::`[[`
[08:27:03.051]             `+` <- base::`+`
[08:27:03.051]             `<<-` <- base::`<<-`
[08:27:03.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.051]                   3L)]
[08:27:03.051]             }
[08:27:03.051]             function(cond) {
[08:27:03.051]                 is_error <- inherits(cond, "error")
[08:27:03.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.051]                   NULL)
[08:27:03.051]                 if (is_error) {
[08:27:03.051]                   sessionInformation <- function() {
[08:27:03.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.051]                       search = base::search(), system = base::Sys.info())
[08:27:03.051]                   }
[08:27:03.051]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.051]                     cond$call), session = sessionInformation(), 
[08:27:03.051]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.051]                   signalCondition(cond)
[08:27:03.051]                 }
[08:27:03.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.051]                 "immediateCondition"))) {
[08:27:03.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.051]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.051]                   if (TRUE && !signal) {
[08:27:03.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.051]                     {
[08:27:03.051]                       inherits <- base::inherits
[08:27:03.051]                       invokeRestart <- base::invokeRestart
[08:27:03.051]                       is.null <- base::is.null
[08:27:03.051]                       muffled <- FALSE
[08:27:03.051]                       if (inherits(cond, "message")) {
[08:27:03.051]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.051]                         if (muffled) 
[08:27:03.051]                           invokeRestart("muffleMessage")
[08:27:03.051]                       }
[08:27:03.051]                       else if (inherits(cond, "warning")) {
[08:27:03.051]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.051]                         if (muffled) 
[08:27:03.051]                           invokeRestart("muffleWarning")
[08:27:03.051]                       }
[08:27:03.051]                       else if (inherits(cond, "condition")) {
[08:27:03.051]                         if (!is.null(pattern)) {
[08:27:03.051]                           computeRestarts <- base::computeRestarts
[08:27:03.051]                           grepl <- base::grepl
[08:27:03.051]                           restarts <- computeRestarts(cond)
[08:27:03.051]                           for (restart in restarts) {
[08:27:03.051]                             name <- restart$name
[08:27:03.051]                             if (is.null(name)) 
[08:27:03.051]                               next
[08:27:03.051]                             if (!grepl(pattern, name)) 
[08:27:03.051]                               next
[08:27:03.051]                             invokeRestart(restart)
[08:27:03.051]                             muffled <- TRUE
[08:27:03.051]                             break
[08:27:03.051]                           }
[08:27:03.051]                         }
[08:27:03.051]                       }
[08:27:03.051]                       invisible(muffled)
[08:27:03.051]                     }
[08:27:03.051]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.051]                   }
[08:27:03.051]                 }
[08:27:03.051]                 else {
[08:27:03.051]                   if (TRUE) {
[08:27:03.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.051]                     {
[08:27:03.051]                       inherits <- base::inherits
[08:27:03.051]                       invokeRestart <- base::invokeRestart
[08:27:03.051]                       is.null <- base::is.null
[08:27:03.051]                       muffled <- FALSE
[08:27:03.051]                       if (inherits(cond, "message")) {
[08:27:03.051]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.051]                         if (muffled) 
[08:27:03.051]                           invokeRestart("muffleMessage")
[08:27:03.051]                       }
[08:27:03.051]                       else if (inherits(cond, "warning")) {
[08:27:03.051]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.051]                         if (muffled) 
[08:27:03.051]                           invokeRestart("muffleWarning")
[08:27:03.051]                       }
[08:27:03.051]                       else if (inherits(cond, "condition")) {
[08:27:03.051]                         if (!is.null(pattern)) {
[08:27:03.051]                           computeRestarts <- base::computeRestarts
[08:27:03.051]                           grepl <- base::grepl
[08:27:03.051]                           restarts <- computeRestarts(cond)
[08:27:03.051]                           for (restart in restarts) {
[08:27:03.051]                             name <- restart$name
[08:27:03.051]                             if (is.null(name)) 
[08:27:03.051]                               next
[08:27:03.051]                             if (!grepl(pattern, name)) 
[08:27:03.051]                               next
[08:27:03.051]                             invokeRestart(restart)
[08:27:03.051]                             muffled <- TRUE
[08:27:03.051]                             break
[08:27:03.051]                           }
[08:27:03.051]                         }
[08:27:03.051]                       }
[08:27:03.051]                       invisible(muffled)
[08:27:03.051]                     }
[08:27:03.051]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.051]                   }
[08:27:03.051]                 }
[08:27:03.051]             }
[08:27:03.051]         }))
[08:27:03.051]     }, error = function(ex) {
[08:27:03.051]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.051]                 ...future.rng), started = ...future.startTime, 
[08:27:03.051]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.051]             version = "1.8"), class = "FutureResult")
[08:27:03.051]     }, finally = {
[08:27:03.051]         if (!identical(...future.workdir, getwd())) 
[08:27:03.051]             setwd(...future.workdir)
[08:27:03.051]         {
[08:27:03.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.051]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.051]             }
[08:27:03.051]             base::options(...future.oldOptions)
[08:27:03.051]             if (.Platform$OS.type == "windows") {
[08:27:03.051]                 old_names <- names(...future.oldEnvVars)
[08:27:03.051]                 envs <- base::Sys.getenv()
[08:27:03.051]                 names <- names(envs)
[08:27:03.051]                 common <- intersect(names, old_names)
[08:27:03.051]                 added <- setdiff(names, old_names)
[08:27:03.051]                 removed <- setdiff(old_names, names)
[08:27:03.051]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.051]                   envs[common]]
[08:27:03.051]                 NAMES <- toupper(changed)
[08:27:03.051]                 args <- list()
[08:27:03.051]                 for (kk in seq_along(NAMES)) {
[08:27:03.051]                   name <- changed[[kk]]
[08:27:03.051]                   NAME <- NAMES[[kk]]
[08:27:03.051]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.051]                     next
[08:27:03.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.051]                 }
[08:27:03.051]                 NAMES <- toupper(added)
[08:27:03.051]                 for (kk in seq_along(NAMES)) {
[08:27:03.051]                   name <- added[[kk]]
[08:27:03.051]                   NAME <- NAMES[[kk]]
[08:27:03.051]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.051]                     next
[08:27:03.051]                   args[[name]] <- ""
[08:27:03.051]                 }
[08:27:03.051]                 NAMES <- toupper(removed)
[08:27:03.051]                 for (kk in seq_along(NAMES)) {
[08:27:03.051]                   name <- removed[[kk]]
[08:27:03.051]                   NAME <- NAMES[[kk]]
[08:27:03.051]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.051]                     next
[08:27:03.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.051]                 }
[08:27:03.051]                 if (length(args) > 0) 
[08:27:03.051]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.051]             }
[08:27:03.051]             else {
[08:27:03.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.051]             }
[08:27:03.051]             {
[08:27:03.051]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.051]                   0L) {
[08:27:03.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.051]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.051]                   base::options(opts)
[08:27:03.051]                 }
[08:27:03.051]                 {
[08:27:03.051]                   {
[08:27:03.051]                     NULL
[08:27:03.051]                     RNGkind("Mersenne-Twister")
[08:27:03.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:03.051]                       inherits = FALSE)
[08:27:03.051]                   }
[08:27:03.051]                   options(future.plan = NULL)
[08:27:03.051]                   if (is.na(NA_character_)) 
[08:27:03.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.051]                     .init = FALSE)
[08:27:03.051]                 }
[08:27:03.051]             }
[08:27:03.051]         }
[08:27:03.051]     })
[08:27:03.051]     if (TRUE) {
[08:27:03.051]         base::sink(type = "output", split = FALSE)
[08:27:03.051]         if (TRUE) {
[08:27:03.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.051]         }
[08:27:03.051]         else {
[08:27:03.051]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.051]         }
[08:27:03.051]         base::close(...future.stdout)
[08:27:03.051]         ...future.stdout <- NULL
[08:27:03.051]     }
[08:27:03.051]     ...future.result$conditions <- ...future.conditions
[08:27:03.051]     ...future.result$finished <- base::Sys.time()
[08:27:03.051]     ...future.result
[08:27:03.051] }
[08:27:03.053] plan(): Setting new future strategy stack:
[08:27:03.053] List of future strategies:
[08:27:03.053] 1. sequential:
[08:27:03.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.053]    - tweaked: FALSE
[08:27:03.053]    - call: NULL
[08:27:03.053] plan(): nbrOfWorkers() = 1
[08:27:03.054] plan(): Setting new future strategy stack:
[08:27:03.054] List of future strategies:
[08:27:03.054] 1. sequential:
[08:27:03.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:03.054]    - tweaked: FALSE
[08:27:03.054]    - call: future::plan("sequential")
[08:27:03.055] plan(): nbrOfWorkers() = 1
[08:27:03.055] SequentialFuture started (and completed)
[08:27:03.055] signalConditions() ...
[08:27:03.055]  - include = ‘immediateCondition’
[08:27:03.055]  - exclude = 
[08:27:03.055]  - resignal = FALSE
[08:27:03.055]  - Number of conditions: 1
[08:27:03.055] signalConditions() ... done
[08:27:03.055] - Launch lazy future ... done
[08:27:03.055] run() for ‘SequentialFuture’ ... done
> v <- value(f, signal = FALSE)
[08:27:03.056] signalConditions() ...
[08:27:03.056]  - include = ‘immediateCondition’
[08:27:03.056]  - exclude = 
[08:27:03.056]  - resignal = FALSE
[08:27:03.056]  - Number of conditions: 1
[08:27:03.056] signalConditions() ... done
> 
> if (availableCores() >= 2L) {
+   message("- Non-resolved future ...")
+   plan(multisession, workers = 2L)
+   f <- future({ Sys.sleep(3); 42L; stop("Woops") })
+   res <- tryCatch(backtrace(f), error = identity)
+   print(res)
+   stopifnot(inherits(res, "error"))
+   
+   ## If we don't resolve the future, the cluster of workers will not
+   ## be able to shut down naturally. They will eventually time out,
+   ## but that will happen long after 'R CMD check' terminates. Because
+   ## of this, 'R CMD check --as-cran' will report on "detritus in the
+   ## temp directory" when running on MS Windows.  This happens because
+   ## MS Windows doesn't shut down child processes as Linux and macOS
+   ## does when the main R session terminates.
+   resolve(f)
+ }
- Non-resolved future ...
[08:27:03.062] plan(): Setting new future strategy stack:
[08:27:03.062] List of future strategies:
[08:27:03.062] 1. multisession:
[08:27:03.062]    - args: function (..., workers = 2L, envir = parent.frame())
[08:27:03.062]    - tweaked: TRUE
[08:27:03.062]    - call: plan(multisession, workers = 2L)
[08:27:03.073] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:03.073] multisession:
[08:27:03.073] - args: function (..., workers = 2L, envir = parent.frame())
[08:27:03.073] - tweaked: TRUE
[08:27:03.073] - call: plan(multisession, workers = 2L)
[08:27:03.074] getGlobalsAndPackages() ...
[08:27:03.074] Not searching for globals
[08:27:03.074] - globals: [0] <none>
[08:27:03.074] getGlobalsAndPackages() ... DONE
[08:27:03.568] Packages needed by the future expression (n = 0): <none>
[08:27:03.568] Packages needed by future strategies (n = 0): <none>
[08:27:03.569] {
[08:27:03.569]     {
[08:27:03.569]         {
[08:27:03.569]             ...future.startTime <- base::Sys.time()
[08:27:03.569]             {
[08:27:03.569]                 {
[08:27:03.569]                   {
[08:27:03.569]                     {
[08:27:03.569]                       base::local({
[08:27:03.569]                         has_future <- base::requireNamespace("future", 
[08:27:03.569]                           quietly = TRUE)
[08:27:03.569]                         if (has_future) {
[08:27:03.569]                           ns <- base::getNamespace("future")
[08:27:03.569]                           version <- ns[[".package"]][["version"]]
[08:27:03.569]                           if (is.null(version)) 
[08:27:03.569]                             version <- utils::packageVersion("future")
[08:27:03.569]                         }
[08:27:03.569]                         else {
[08:27:03.569]                           version <- NULL
[08:27:03.569]                         }
[08:27:03.569]                         if (!has_future || version < "1.8.0") {
[08:27:03.569]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.569]                             "", base::R.version$version.string), 
[08:27:03.569]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:03.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.569]                               "release", "version")], collapse = " "), 
[08:27:03.569]                             hostname = base::Sys.info()[["nodename"]])
[08:27:03.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.569]                             info)
[08:27:03.569]                           info <- base::paste(info, collapse = "; ")
[08:27:03.569]                           if (!has_future) {
[08:27:03.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.569]                               info)
[08:27:03.569]                           }
[08:27:03.569]                           else {
[08:27:03.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.569]                               info, version)
[08:27:03.569]                           }
[08:27:03.569]                           base::stop(msg)
[08:27:03.569]                         }
[08:27:03.569]                       })
[08:27:03.569]                     }
[08:27:03.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:03.569]                     base::options(mc.cores = 1L)
[08:27:03.569]                   }
[08:27:03.569]                   ...future.strategy.old <- future::plan("list")
[08:27:03.569]                   options(future.plan = NULL)
[08:27:03.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.569]                 }
[08:27:03.569]                 ...future.workdir <- getwd()
[08:27:03.569]             }
[08:27:03.569]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.569]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.569]         }
[08:27:03.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.569]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.569]             base::names(...future.oldOptions))
[08:27:03.569]     }
[08:27:03.569]     if (FALSE) {
[08:27:03.569]     }
[08:27:03.569]     else {
[08:27:03.569]         if (TRUE) {
[08:27:03.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.569]                 open = "w")
[08:27:03.569]         }
[08:27:03.569]         else {
[08:27:03.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.569]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.569]         }
[08:27:03.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.569]             base::sink(type = "output", split = FALSE)
[08:27:03.569]             base::close(...future.stdout)
[08:27:03.569]         }, add = TRUE)
[08:27:03.569]     }
[08:27:03.569]     ...future.frame <- base::sys.nframe()
[08:27:03.569]     ...future.conditions <- base::list()
[08:27:03.569]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.569]     if (FALSE) {
[08:27:03.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.569]     }
[08:27:03.569]     ...future.result <- base::tryCatch({
[08:27:03.569]         base::withCallingHandlers({
[08:27:03.569]             ...future.value <- base::withVisible(base::local({
[08:27:03.569]                 ...future.makeSendCondition <- base::local({
[08:27:03.569]                   sendCondition <- NULL
[08:27:03.569]                   function(frame = 1L) {
[08:27:03.569]                     if (is.function(sendCondition)) 
[08:27:03.569]                       return(sendCondition)
[08:27:03.569]                     ns <- getNamespace("parallel")
[08:27:03.569]                     if (exists("sendData", mode = "function", 
[08:27:03.569]                       envir = ns)) {
[08:27:03.569]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:03.569]                         envir = ns)
[08:27:03.569]                       envir <- sys.frame(frame)
[08:27:03.569]                       master <- NULL
[08:27:03.569]                       while (!identical(envir, .GlobalEnv) && 
[08:27:03.569]                         !identical(envir, emptyenv())) {
[08:27:03.569]                         if (exists("master", mode = "list", envir = envir, 
[08:27:03.569]                           inherits = FALSE)) {
[08:27:03.569]                           master <- get("master", mode = "list", 
[08:27:03.569]                             envir = envir, inherits = FALSE)
[08:27:03.569]                           if (inherits(master, c("SOCKnode", 
[08:27:03.569]                             "SOCK0node"))) {
[08:27:03.569]                             sendCondition <<- function(cond) {
[08:27:03.569]                               data <- list(type = "VALUE", value = cond, 
[08:27:03.569]                                 success = TRUE)
[08:27:03.569]                               parallel_sendData(master, data)
[08:27:03.569]                             }
[08:27:03.569]                             return(sendCondition)
[08:27:03.569]                           }
[08:27:03.569]                         }
[08:27:03.569]                         frame <- frame + 1L
[08:27:03.569]                         envir <- sys.frame(frame)
[08:27:03.569]                       }
[08:27:03.569]                     }
[08:27:03.569]                     sendCondition <<- function(cond) NULL
[08:27:03.569]                   }
[08:27:03.569]                 })
[08:27:03.569]                 withCallingHandlers({
[08:27:03.569]                   NA
[08:27:03.569]                 }, immediateCondition = function(cond) {
[08:27:03.569]                   sendCondition <- ...future.makeSendCondition()
[08:27:03.569]                   sendCondition(cond)
[08:27:03.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.569]                   {
[08:27:03.569]                     inherits <- base::inherits
[08:27:03.569]                     invokeRestart <- base::invokeRestart
[08:27:03.569]                     is.null <- base::is.null
[08:27:03.569]                     muffled <- FALSE
[08:27:03.569]                     if (inherits(cond, "message")) {
[08:27:03.569]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:03.569]                       if (muffled) 
[08:27:03.569]                         invokeRestart("muffleMessage")
[08:27:03.569]                     }
[08:27:03.569]                     else if (inherits(cond, "warning")) {
[08:27:03.569]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:03.569]                       if (muffled) 
[08:27:03.569]                         invokeRestart("muffleWarning")
[08:27:03.569]                     }
[08:27:03.569]                     else if (inherits(cond, "condition")) {
[08:27:03.569]                       if (!is.null(pattern)) {
[08:27:03.569]                         computeRestarts <- base::computeRestarts
[08:27:03.569]                         grepl <- base::grepl
[08:27:03.569]                         restarts <- computeRestarts(cond)
[08:27:03.569]                         for (restart in restarts) {
[08:27:03.569]                           name <- restart$name
[08:27:03.569]                           if (is.null(name)) 
[08:27:03.569]                             next
[08:27:03.569]                           if (!grepl(pattern, name)) 
[08:27:03.569]                             next
[08:27:03.569]                           invokeRestart(restart)
[08:27:03.569]                           muffled <- TRUE
[08:27:03.569]                           break
[08:27:03.569]                         }
[08:27:03.569]                       }
[08:27:03.569]                     }
[08:27:03.569]                     invisible(muffled)
[08:27:03.569]                   }
[08:27:03.569]                   muffleCondition(cond)
[08:27:03.569]                 })
[08:27:03.569]             }))
[08:27:03.569]             future::FutureResult(value = ...future.value$value, 
[08:27:03.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.569]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.569]                     ...future.globalenv.names))
[08:27:03.569]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.569]         }, condition = base::local({
[08:27:03.569]             c <- base::c
[08:27:03.569]             inherits <- base::inherits
[08:27:03.569]             invokeRestart <- base::invokeRestart
[08:27:03.569]             length <- base::length
[08:27:03.569]             list <- base::list
[08:27:03.569]             seq.int <- base::seq.int
[08:27:03.569]             signalCondition <- base::signalCondition
[08:27:03.569]             sys.calls <- base::sys.calls
[08:27:03.569]             `[[` <- base::`[[`
[08:27:03.569]             `+` <- base::`+`
[08:27:03.569]             `<<-` <- base::`<<-`
[08:27:03.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.569]                   3L)]
[08:27:03.569]             }
[08:27:03.569]             function(cond) {
[08:27:03.569]                 is_error <- inherits(cond, "error")
[08:27:03.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.569]                   NULL)
[08:27:03.569]                 if (is_error) {
[08:27:03.569]                   sessionInformation <- function() {
[08:27:03.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.569]                       search = base::search(), system = base::Sys.info())
[08:27:03.569]                   }
[08:27:03.569]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.569]                     cond$call), session = sessionInformation(), 
[08:27:03.569]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.569]                   signalCondition(cond)
[08:27:03.569]                 }
[08:27:03.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.569]                 "immediateCondition"))) {
[08:27:03.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.569]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.569]                   if (TRUE && !signal) {
[08:27:03.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.569]                     {
[08:27:03.569]                       inherits <- base::inherits
[08:27:03.569]                       invokeRestart <- base::invokeRestart
[08:27:03.569]                       is.null <- base::is.null
[08:27:03.569]                       muffled <- FALSE
[08:27:03.569]                       if (inherits(cond, "message")) {
[08:27:03.569]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.569]                         if (muffled) 
[08:27:03.569]                           invokeRestart("muffleMessage")
[08:27:03.569]                       }
[08:27:03.569]                       else if (inherits(cond, "warning")) {
[08:27:03.569]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.569]                         if (muffled) 
[08:27:03.569]                           invokeRestart("muffleWarning")
[08:27:03.569]                       }
[08:27:03.569]                       else if (inherits(cond, "condition")) {
[08:27:03.569]                         if (!is.null(pattern)) {
[08:27:03.569]                           computeRestarts <- base::computeRestarts
[08:27:03.569]                           grepl <- base::grepl
[08:27:03.569]                           restarts <- computeRestarts(cond)
[08:27:03.569]                           for (restart in restarts) {
[08:27:03.569]                             name <- restart$name
[08:27:03.569]                             if (is.null(name)) 
[08:27:03.569]                               next
[08:27:03.569]                             if (!grepl(pattern, name)) 
[08:27:03.569]                               next
[08:27:03.569]                             invokeRestart(restart)
[08:27:03.569]                             muffled <- TRUE
[08:27:03.569]                             break
[08:27:03.569]                           }
[08:27:03.569]                         }
[08:27:03.569]                       }
[08:27:03.569]                       invisible(muffled)
[08:27:03.569]                     }
[08:27:03.569]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.569]                   }
[08:27:03.569]                 }
[08:27:03.569]                 else {
[08:27:03.569]                   if (TRUE) {
[08:27:03.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.569]                     {
[08:27:03.569]                       inherits <- base::inherits
[08:27:03.569]                       invokeRestart <- base::invokeRestart
[08:27:03.569]                       is.null <- base::is.null
[08:27:03.569]                       muffled <- FALSE
[08:27:03.569]                       if (inherits(cond, "message")) {
[08:27:03.569]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.569]                         if (muffled) 
[08:27:03.569]                           invokeRestart("muffleMessage")
[08:27:03.569]                       }
[08:27:03.569]                       else if (inherits(cond, "warning")) {
[08:27:03.569]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.569]                         if (muffled) 
[08:27:03.569]                           invokeRestart("muffleWarning")
[08:27:03.569]                       }
[08:27:03.569]                       else if (inherits(cond, "condition")) {
[08:27:03.569]                         if (!is.null(pattern)) {
[08:27:03.569]                           computeRestarts <- base::computeRestarts
[08:27:03.569]                           grepl <- base::grepl
[08:27:03.569]                           restarts <- computeRestarts(cond)
[08:27:03.569]                           for (restart in restarts) {
[08:27:03.569]                             name <- restart$name
[08:27:03.569]                             if (is.null(name)) 
[08:27:03.569]                               next
[08:27:03.569]                             if (!grepl(pattern, name)) 
[08:27:03.569]                               next
[08:27:03.569]                             invokeRestart(restart)
[08:27:03.569]                             muffled <- TRUE
[08:27:03.569]                             break
[08:27:03.569]                           }
[08:27:03.569]                         }
[08:27:03.569]                       }
[08:27:03.569]                       invisible(muffled)
[08:27:03.569]                     }
[08:27:03.569]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.569]                   }
[08:27:03.569]                 }
[08:27:03.569]             }
[08:27:03.569]         }))
[08:27:03.569]     }, error = function(ex) {
[08:27:03.569]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.569]                 ...future.rng), started = ...future.startTime, 
[08:27:03.569]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.569]             version = "1.8"), class = "FutureResult")
[08:27:03.569]     }, finally = {
[08:27:03.569]         if (!identical(...future.workdir, getwd())) 
[08:27:03.569]             setwd(...future.workdir)
[08:27:03.569]         {
[08:27:03.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.569]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.569]             }
[08:27:03.569]             base::options(...future.oldOptions)
[08:27:03.569]             if (.Platform$OS.type == "windows") {
[08:27:03.569]                 old_names <- names(...future.oldEnvVars)
[08:27:03.569]                 envs <- base::Sys.getenv()
[08:27:03.569]                 names <- names(envs)
[08:27:03.569]                 common <- intersect(names, old_names)
[08:27:03.569]                 added <- setdiff(names, old_names)
[08:27:03.569]                 removed <- setdiff(old_names, names)
[08:27:03.569]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.569]                   envs[common]]
[08:27:03.569]                 NAMES <- toupper(changed)
[08:27:03.569]                 args <- list()
[08:27:03.569]                 for (kk in seq_along(NAMES)) {
[08:27:03.569]                   name <- changed[[kk]]
[08:27:03.569]                   NAME <- NAMES[[kk]]
[08:27:03.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.569]                     next
[08:27:03.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.569]                 }
[08:27:03.569]                 NAMES <- toupper(added)
[08:27:03.569]                 for (kk in seq_along(NAMES)) {
[08:27:03.569]                   name <- added[[kk]]
[08:27:03.569]                   NAME <- NAMES[[kk]]
[08:27:03.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.569]                     next
[08:27:03.569]                   args[[name]] <- ""
[08:27:03.569]                 }
[08:27:03.569]                 NAMES <- toupper(removed)
[08:27:03.569]                 for (kk in seq_along(NAMES)) {
[08:27:03.569]                   name <- removed[[kk]]
[08:27:03.569]                   NAME <- NAMES[[kk]]
[08:27:03.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.569]                     next
[08:27:03.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.569]                 }
[08:27:03.569]                 if (length(args) > 0) 
[08:27:03.569]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.569]             }
[08:27:03.569]             else {
[08:27:03.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.569]             }
[08:27:03.569]             {
[08:27:03.569]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.569]                   0L) {
[08:27:03.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.569]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.569]                   base::options(opts)
[08:27:03.569]                 }
[08:27:03.569]                 {
[08:27:03.569]                   {
[08:27:03.569]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:03.569]                     NULL
[08:27:03.569]                   }
[08:27:03.569]                   options(future.plan = NULL)
[08:27:03.569]                   if (is.na(NA_character_)) 
[08:27:03.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.569]                     .init = FALSE)
[08:27:03.569]                 }
[08:27:03.569]             }
[08:27:03.569]         }
[08:27:03.569]     })
[08:27:03.569]     if (TRUE) {
[08:27:03.569]         base::sink(type = "output", split = FALSE)
[08:27:03.569]         if (TRUE) {
[08:27:03.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.569]         }
[08:27:03.569]         else {
[08:27:03.569]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.569]         }
[08:27:03.569]         base::close(...future.stdout)
[08:27:03.569]         ...future.stdout <- NULL
[08:27:03.569]     }
[08:27:03.569]     ...future.result$conditions <- ...future.conditions
[08:27:03.569]     ...future.result$finished <- base::Sys.time()
[08:27:03.569]     ...future.result
[08:27:03.569] }
[08:27:03.623] MultisessionFuture started
[08:27:03.623] result() for ClusterFuture ...
[08:27:03.624] receiveMessageFromWorker() for ClusterFuture ...
[08:27:03.624] - Validating connection of MultisessionFuture
[08:27:03.655] - received message: FutureResult
[08:27:03.655] - Received FutureResult
[08:27:03.658] - Erased future from FutureRegistry
[08:27:03.658] result() for ClusterFuture ...
[08:27:03.658] - result already collected: FutureResult
[08:27:03.658] result() for ClusterFuture ... done
[08:27:03.658] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:03.658] result() for ClusterFuture ... done
[08:27:03.658] result() for ClusterFuture ...
[08:27:03.659] - result already collected: FutureResult
[08:27:03.659] result() for ClusterFuture ... done
[08:27:03.659] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:03.659] plan(): nbrOfWorkers() = 2
[08:27:03.659] getGlobalsAndPackages() ...
[08:27:03.659] Searching for globals...
[08:27:03.661] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘stop’
[08:27:03.661] Searching for globals ... DONE
[08:27:03.661] Resolving globals: FALSE
[08:27:03.661] 
[08:27:03.661] 
[08:27:03.661] getGlobalsAndPackages() ... DONE
[08:27:03.662] run() for ‘Future’ ...
[08:27:03.662] - state: ‘created’
[08:27:03.662] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:03.674] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:03.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:03.675]   - Field: ‘node’
[08:27:03.675]   - Field: ‘label’
[08:27:03.675]   - Field: ‘local’
[08:27:03.675]   - Field: ‘owner’
[08:27:03.675]   - Field: ‘envir’
[08:27:03.675]   - Field: ‘workers’
[08:27:03.675]   - Field: ‘packages’
[08:27:03.675]   - Field: ‘gc’
[08:27:03.675]   - Field: ‘conditions’
[08:27:03.675]   - Field: ‘persistent’
[08:27:03.675]   - Field: ‘expr’
[08:27:03.676]   - Field: ‘uuid’
[08:27:03.676]   - Field: ‘seed’
[08:27:03.676]   - Field: ‘version’
[08:27:03.676]   - Field: ‘result’
[08:27:03.676]   - Field: ‘asynchronous’
[08:27:03.676]   - Field: ‘calls’
[08:27:03.676]   - Field: ‘globals’
[08:27:03.676]   - Field: ‘stdout’
[08:27:03.676]   - Field: ‘earlySignal’
[08:27:03.676]   - Field: ‘lazy’
[08:27:03.676]   - Field: ‘state’
[08:27:03.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:03.677] - Launch lazy future ...
[08:27:03.677] Packages needed by the future expression (n = 0): <none>
[08:27:03.677] Packages needed by future strategies (n = 0): <none>
[08:27:03.677] {
[08:27:03.677]     {
[08:27:03.677]         {
[08:27:03.677]             ...future.startTime <- base::Sys.time()
[08:27:03.677]             {
[08:27:03.677]                 {
[08:27:03.677]                   {
[08:27:03.677]                     {
[08:27:03.677]                       base::local({
[08:27:03.677]                         has_future <- base::requireNamespace("future", 
[08:27:03.677]                           quietly = TRUE)
[08:27:03.677]                         if (has_future) {
[08:27:03.677]                           ns <- base::getNamespace("future")
[08:27:03.677]                           version <- ns[[".package"]][["version"]]
[08:27:03.677]                           if (is.null(version)) 
[08:27:03.677]                             version <- utils::packageVersion("future")
[08:27:03.677]                         }
[08:27:03.677]                         else {
[08:27:03.677]                           version <- NULL
[08:27:03.677]                         }
[08:27:03.677]                         if (!has_future || version < "1.8.0") {
[08:27:03.677]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:03.677]                             "", base::R.version$version.string), 
[08:27:03.677]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:03.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:03.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:03.677]                               "release", "version")], collapse = " "), 
[08:27:03.677]                             hostname = base::Sys.info()[["nodename"]])
[08:27:03.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:03.677]                             info)
[08:27:03.677]                           info <- base::paste(info, collapse = "; ")
[08:27:03.677]                           if (!has_future) {
[08:27:03.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:03.677]                               info)
[08:27:03.677]                           }
[08:27:03.677]                           else {
[08:27:03.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:03.677]                               info, version)
[08:27:03.677]                           }
[08:27:03.677]                           base::stop(msg)
[08:27:03.677]                         }
[08:27:03.677]                       })
[08:27:03.677]                     }
[08:27:03.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:03.677]                     base::options(mc.cores = 1L)
[08:27:03.677]                   }
[08:27:03.677]                   ...future.strategy.old <- future::plan("list")
[08:27:03.677]                   options(future.plan = NULL)
[08:27:03.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:03.677]                 }
[08:27:03.677]                 ...future.workdir <- getwd()
[08:27:03.677]             }
[08:27:03.677]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:03.677]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:03.677]         }
[08:27:03.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:03.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:03.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:03.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:03.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:03.677]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:03.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:03.677]             base::names(...future.oldOptions))
[08:27:03.677]     }
[08:27:03.677]     if (FALSE) {
[08:27:03.677]     }
[08:27:03.677]     else {
[08:27:03.677]         if (TRUE) {
[08:27:03.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:03.677]                 open = "w")
[08:27:03.677]         }
[08:27:03.677]         else {
[08:27:03.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:03.677]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:03.677]         }
[08:27:03.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:03.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:03.677]             base::sink(type = "output", split = FALSE)
[08:27:03.677]             base::close(...future.stdout)
[08:27:03.677]         }, add = TRUE)
[08:27:03.677]     }
[08:27:03.677]     ...future.frame <- base::sys.nframe()
[08:27:03.677]     ...future.conditions <- base::list()
[08:27:03.677]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:03.677]     if (FALSE) {
[08:27:03.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:03.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:03.677]     }
[08:27:03.677]     ...future.result <- base::tryCatch({
[08:27:03.677]         base::withCallingHandlers({
[08:27:03.677]             ...future.value <- base::withVisible(base::local({
[08:27:03.677]                 ...future.makeSendCondition <- base::local({
[08:27:03.677]                   sendCondition <- NULL
[08:27:03.677]                   function(frame = 1L) {
[08:27:03.677]                     if (is.function(sendCondition)) 
[08:27:03.677]                       return(sendCondition)
[08:27:03.677]                     ns <- getNamespace("parallel")
[08:27:03.677]                     if (exists("sendData", mode = "function", 
[08:27:03.677]                       envir = ns)) {
[08:27:03.677]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:03.677]                         envir = ns)
[08:27:03.677]                       envir <- sys.frame(frame)
[08:27:03.677]                       master <- NULL
[08:27:03.677]                       while (!identical(envir, .GlobalEnv) && 
[08:27:03.677]                         !identical(envir, emptyenv())) {
[08:27:03.677]                         if (exists("master", mode = "list", envir = envir, 
[08:27:03.677]                           inherits = FALSE)) {
[08:27:03.677]                           master <- get("master", mode = "list", 
[08:27:03.677]                             envir = envir, inherits = FALSE)
[08:27:03.677]                           if (inherits(master, c("SOCKnode", 
[08:27:03.677]                             "SOCK0node"))) {
[08:27:03.677]                             sendCondition <<- function(cond) {
[08:27:03.677]                               data <- list(type = "VALUE", value = cond, 
[08:27:03.677]                                 success = TRUE)
[08:27:03.677]                               parallel_sendData(master, data)
[08:27:03.677]                             }
[08:27:03.677]                             return(sendCondition)
[08:27:03.677]                           }
[08:27:03.677]                         }
[08:27:03.677]                         frame <- frame + 1L
[08:27:03.677]                         envir <- sys.frame(frame)
[08:27:03.677]                       }
[08:27:03.677]                     }
[08:27:03.677]                     sendCondition <<- function(cond) NULL
[08:27:03.677]                   }
[08:27:03.677]                 })
[08:27:03.677]                 withCallingHandlers({
[08:27:03.677]                   {
[08:27:03.677]                     Sys.sleep(3)
[08:27:03.677]                     42L
[08:27:03.677]                     stop("Woops")
[08:27:03.677]                   }
[08:27:03.677]                 }, immediateCondition = function(cond) {
[08:27:03.677]                   sendCondition <- ...future.makeSendCondition()
[08:27:03.677]                   sendCondition(cond)
[08:27:03.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.677]                   {
[08:27:03.677]                     inherits <- base::inherits
[08:27:03.677]                     invokeRestart <- base::invokeRestart
[08:27:03.677]                     is.null <- base::is.null
[08:27:03.677]                     muffled <- FALSE
[08:27:03.677]                     if (inherits(cond, "message")) {
[08:27:03.677]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:03.677]                       if (muffled) 
[08:27:03.677]                         invokeRestart("muffleMessage")
[08:27:03.677]                     }
[08:27:03.677]                     else if (inherits(cond, "warning")) {
[08:27:03.677]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:03.677]                       if (muffled) 
[08:27:03.677]                         invokeRestart("muffleWarning")
[08:27:03.677]                     }
[08:27:03.677]                     else if (inherits(cond, "condition")) {
[08:27:03.677]                       if (!is.null(pattern)) {
[08:27:03.677]                         computeRestarts <- base::computeRestarts
[08:27:03.677]                         grepl <- base::grepl
[08:27:03.677]                         restarts <- computeRestarts(cond)
[08:27:03.677]                         for (restart in restarts) {
[08:27:03.677]                           name <- restart$name
[08:27:03.677]                           if (is.null(name)) 
[08:27:03.677]                             next
[08:27:03.677]                           if (!grepl(pattern, name)) 
[08:27:03.677]                             next
[08:27:03.677]                           invokeRestart(restart)
[08:27:03.677]                           muffled <- TRUE
[08:27:03.677]                           break
[08:27:03.677]                         }
[08:27:03.677]                       }
[08:27:03.677]                     }
[08:27:03.677]                     invisible(muffled)
[08:27:03.677]                   }
[08:27:03.677]                   muffleCondition(cond)
[08:27:03.677]                 })
[08:27:03.677]             }))
[08:27:03.677]             future::FutureResult(value = ...future.value$value, 
[08:27:03.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.677]                   ...future.rng), globalenv = if (FALSE) 
[08:27:03.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:03.677]                     ...future.globalenv.names))
[08:27:03.677]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:03.677]         }, condition = base::local({
[08:27:03.677]             c <- base::c
[08:27:03.677]             inherits <- base::inherits
[08:27:03.677]             invokeRestart <- base::invokeRestart
[08:27:03.677]             length <- base::length
[08:27:03.677]             list <- base::list
[08:27:03.677]             seq.int <- base::seq.int
[08:27:03.677]             signalCondition <- base::signalCondition
[08:27:03.677]             sys.calls <- base::sys.calls
[08:27:03.677]             `[[` <- base::`[[`
[08:27:03.677]             `+` <- base::`+`
[08:27:03.677]             `<<-` <- base::`<<-`
[08:27:03.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:03.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:03.677]                   3L)]
[08:27:03.677]             }
[08:27:03.677]             function(cond) {
[08:27:03.677]                 is_error <- inherits(cond, "error")
[08:27:03.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:03.677]                   NULL)
[08:27:03.677]                 if (is_error) {
[08:27:03.677]                   sessionInformation <- function() {
[08:27:03.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:03.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:03.677]                       search = base::search(), system = base::Sys.info())
[08:27:03.677]                   }
[08:27:03.677]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:03.677]                     cond$call), session = sessionInformation(), 
[08:27:03.677]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:03.677]                   signalCondition(cond)
[08:27:03.677]                 }
[08:27:03.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:03.677]                 "immediateCondition"))) {
[08:27:03.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:03.677]                   ...future.conditions[[length(...future.conditions) + 
[08:27:03.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:03.677]                   if (TRUE && !signal) {
[08:27:03.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.677]                     {
[08:27:03.677]                       inherits <- base::inherits
[08:27:03.677]                       invokeRestart <- base::invokeRestart
[08:27:03.677]                       is.null <- base::is.null
[08:27:03.677]                       muffled <- FALSE
[08:27:03.677]                       if (inherits(cond, "message")) {
[08:27:03.677]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.677]                         if (muffled) 
[08:27:03.677]                           invokeRestart("muffleMessage")
[08:27:03.677]                       }
[08:27:03.677]                       else if (inherits(cond, "warning")) {
[08:27:03.677]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.677]                         if (muffled) 
[08:27:03.677]                           invokeRestart("muffleWarning")
[08:27:03.677]                       }
[08:27:03.677]                       else if (inherits(cond, "condition")) {
[08:27:03.677]                         if (!is.null(pattern)) {
[08:27:03.677]                           computeRestarts <- base::computeRestarts
[08:27:03.677]                           grepl <- base::grepl
[08:27:03.677]                           restarts <- computeRestarts(cond)
[08:27:03.677]                           for (restart in restarts) {
[08:27:03.677]                             name <- restart$name
[08:27:03.677]                             if (is.null(name)) 
[08:27:03.677]                               next
[08:27:03.677]                             if (!grepl(pattern, name)) 
[08:27:03.677]                               next
[08:27:03.677]                             invokeRestart(restart)
[08:27:03.677]                             muffled <- TRUE
[08:27:03.677]                             break
[08:27:03.677]                           }
[08:27:03.677]                         }
[08:27:03.677]                       }
[08:27:03.677]                       invisible(muffled)
[08:27:03.677]                     }
[08:27:03.677]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.677]                   }
[08:27:03.677]                 }
[08:27:03.677]                 else {
[08:27:03.677]                   if (TRUE) {
[08:27:03.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:03.677]                     {
[08:27:03.677]                       inherits <- base::inherits
[08:27:03.677]                       invokeRestart <- base::invokeRestart
[08:27:03.677]                       is.null <- base::is.null
[08:27:03.677]                       muffled <- FALSE
[08:27:03.677]                       if (inherits(cond, "message")) {
[08:27:03.677]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:03.677]                         if (muffled) 
[08:27:03.677]                           invokeRestart("muffleMessage")
[08:27:03.677]                       }
[08:27:03.677]                       else if (inherits(cond, "warning")) {
[08:27:03.677]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:03.677]                         if (muffled) 
[08:27:03.677]                           invokeRestart("muffleWarning")
[08:27:03.677]                       }
[08:27:03.677]                       else if (inherits(cond, "condition")) {
[08:27:03.677]                         if (!is.null(pattern)) {
[08:27:03.677]                           computeRestarts <- base::computeRestarts
[08:27:03.677]                           grepl <- base::grepl
[08:27:03.677]                           restarts <- computeRestarts(cond)
[08:27:03.677]                           for (restart in restarts) {
[08:27:03.677]                             name <- restart$name
[08:27:03.677]                             if (is.null(name)) 
[08:27:03.677]                               next
[08:27:03.677]                             if (!grepl(pattern, name)) 
[08:27:03.677]                               next
[08:27:03.677]                             invokeRestart(restart)
[08:27:03.677]                             muffled <- TRUE
[08:27:03.677]                             break
[08:27:03.677]                           }
[08:27:03.677]                         }
[08:27:03.677]                       }
[08:27:03.677]                       invisible(muffled)
[08:27:03.677]                     }
[08:27:03.677]                     muffleCondition(cond, pattern = "^muffle")
[08:27:03.677]                   }
[08:27:03.677]                 }
[08:27:03.677]             }
[08:27:03.677]         }))
[08:27:03.677]     }, error = function(ex) {
[08:27:03.677]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:03.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:03.677]                 ...future.rng), started = ...future.startTime, 
[08:27:03.677]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:03.677]             version = "1.8"), class = "FutureResult")
[08:27:03.677]     }, finally = {
[08:27:03.677]         if (!identical(...future.workdir, getwd())) 
[08:27:03.677]             setwd(...future.workdir)
[08:27:03.677]         {
[08:27:03.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:03.677]                 ...future.oldOptions$nwarnings <- NULL
[08:27:03.677]             }
[08:27:03.677]             base::options(...future.oldOptions)
[08:27:03.677]             if (.Platform$OS.type == "windows") {
[08:27:03.677]                 old_names <- names(...future.oldEnvVars)
[08:27:03.677]                 envs <- base::Sys.getenv()
[08:27:03.677]                 names <- names(envs)
[08:27:03.677]                 common <- intersect(names, old_names)
[08:27:03.677]                 added <- setdiff(names, old_names)
[08:27:03.677]                 removed <- setdiff(old_names, names)
[08:27:03.677]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:03.677]                   envs[common]]
[08:27:03.677]                 NAMES <- toupper(changed)
[08:27:03.677]                 args <- list()
[08:27:03.677]                 for (kk in seq_along(NAMES)) {
[08:27:03.677]                   name <- changed[[kk]]
[08:27:03.677]                   NAME <- NAMES[[kk]]
[08:27:03.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.677]                     next
[08:27:03.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.677]                 }
[08:27:03.677]                 NAMES <- toupper(added)
[08:27:03.677]                 for (kk in seq_along(NAMES)) {
[08:27:03.677]                   name <- added[[kk]]
[08:27:03.677]                   NAME <- NAMES[[kk]]
[08:27:03.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.677]                     next
[08:27:03.677]                   args[[name]] <- ""
[08:27:03.677]                 }
[08:27:03.677]                 NAMES <- toupper(removed)
[08:27:03.677]                 for (kk in seq_along(NAMES)) {
[08:27:03.677]                   name <- removed[[kk]]
[08:27:03.677]                   NAME <- NAMES[[kk]]
[08:27:03.677]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:03.677]                     next
[08:27:03.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:03.677]                 }
[08:27:03.677]                 if (length(args) > 0) 
[08:27:03.677]                   base::do.call(base::Sys.setenv, args = args)
[08:27:03.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:03.677]             }
[08:27:03.677]             else {
[08:27:03.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:03.677]             }
[08:27:03.677]             {
[08:27:03.677]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:03.677]                   0L) {
[08:27:03.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:03.677]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:03.677]                   base::options(opts)
[08:27:03.677]                 }
[08:27:03.677]                 {
[08:27:03.677]                   {
[08:27:03.677]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:03.677]                     NULL
[08:27:03.677]                   }
[08:27:03.677]                   options(future.plan = NULL)
[08:27:03.677]                   if (is.na(NA_character_)) 
[08:27:03.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:03.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:03.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:03.677]                     .init = FALSE)
[08:27:03.677]                 }
[08:27:03.677]             }
[08:27:03.677]         }
[08:27:03.677]     })
[08:27:03.677]     if (TRUE) {
[08:27:03.677]         base::sink(type = "output", split = FALSE)
[08:27:03.677]         if (TRUE) {
[08:27:03.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:03.677]         }
[08:27:03.677]         else {
[08:27:03.677]             ...future.result["stdout"] <- base::list(NULL)
[08:27:03.677]         }
[08:27:03.677]         base::close(...future.stdout)
[08:27:03.677]         ...future.stdout <- NULL
[08:27:03.677]     }
[08:27:03.677]     ...future.result$conditions <- ...future.conditions
[08:27:03.677]     ...future.result$finished <- base::Sys.time()
[08:27:03.677]     ...future.result
[08:27:03.677] }
[08:27:03.681] MultisessionFuture started
[08:27:03.681] - Launch lazy future ... done
[08:27:03.681] run() for ‘MultisessionFuture’ ... done
<simpleError: No error has been caught because the future is unresolved: ‘f’>
[08:27:06.731] receiveMessageFromWorker() for ClusterFuture ...
[08:27:06.732] - Validating connection of MultisessionFuture
[08:27:06.732] - received message: FutureResult
[08:27:06.733] - Received FutureResult
[08:27:06.733] - Erased future from FutureRegistry
[08:27:06.733] result() for ClusterFuture ...
[08:27:06.733] - result already collected: FutureResult
[08:27:06.733] result() for ClusterFuture ... done
[08:27:06.733] signalConditions() ...
[08:27:06.733]  - include = ‘immediateCondition’
[08:27:06.733]  - exclude = 
[08:27:06.734]  - resignal = FALSE
[08:27:06.734]  - Number of conditions: 1
[08:27:06.734] signalConditions() ... done
[08:27:06.734] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:06.734] A MultisessionFuture was resolved (result was not collected)
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    Sys.sleep(3)
    42L
    stop("Woops")
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 27 bytes of class ‘NULL’
Conditions captured: [n=1] ‘simpleError’
Early signaling: FALSE
Owner process: 8e67ddfa-c8a3-d4fb-d547-dd0cd95d9aee
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
> 
> message("*** backtrace( ) - exceptions ... DONE")
*** backtrace( ) - exceptions ... DONE
> 
> 
> message("*** backtrace( ) ... DONE")
*** backtrace( ) ... DONE
> 
> source("incl/end.R")
[08:27:06.736] plan(): Setting new future strategy stack:
[08:27:06.736] List of future strategies:
[08:27:06.736] 1. FutureStrategy:
[08:27:06.736]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:06.736]    - tweaked: FALSE
[08:27:06.736]    - call: future::plan(oplan)
[08:27:06.737] plan(): nbrOfWorkers() = 1
> 
