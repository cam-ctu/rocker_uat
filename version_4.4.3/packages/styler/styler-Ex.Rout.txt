
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "styler"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('styler')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("alignment_drop_last_expr")
> ### * alignment_drop_last_expr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alignment_drop_last_expr
> ### Title: Remove last expression
> ### Aliases: alignment_drop_last_expr
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (FALSE) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ call(
+   x = 12,
+   y =  3,
+ )
+ 
+ function(a = 33,
+          qq = 4) {
+   # we don't care about this part for alignment detection
+ }
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("cache_make_key")
> ### * cache_make_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_make_key
> ### Title: Make a key for 'R.cache'
> ### Aliases: cache_make_key
> ### Keywords: internal
> 
> ### ** Examples
> 
> add <- function(x, y) {
+   x + y
+ }
> add1 <- purrr::partial(add, x = 1)
> add2 <- purrr::partial(add, x = 1)
> identical(add1, add2)
[1] TRUE
> identical(digest::digest(add1), digest::digest(add2))
[1] TRUE
> identical(digest::digest(styler::tidyverse_style()), digest::digest(styler::tidyverse_style()))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("compute_indent_indices")
> ### * compute_indent_indices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute_indent_indices
> ### Title: Compute the indices that need indention
> ### Aliases: compute_indent_indices
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::parse_text("a[1]")
a[1]
> styler:::parse_text("a[[1\n]]")
a[[1]]
> 
> 
> 
> cleanEx()
> nameEx("compute_parse_data_nested")
> ### * compute_parse_data_nested
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compute_parse_data_nested
> ### Title: Obtain a nested parse table from a character vector
> ### Aliases: compute_parse_data_nested
> 
> ### ** Examples
> 
> code <- "
+ ab     <- 1L # some comment
+ abcdef <- 2L
+ "
> writeLines(code)

ab     <- 1L # some comment
abcdef <- 2L

> compute_parse_data_nested(code)
  id pos_id line1 col1 line2 col2 parent   token terminal           text short
1 10      1     2    1     2   12      0    expr    FALSE   ab     <- 1L ab   
2  8      7     2   14     2   27    -10 COMMENT     TRUE # some comment # som
3 19      8     3    1     3   12      0    expr    FALSE   abcdef <- 2L abcde
  token_before token_after stylerignore block is_cached internal
1         <NA>        <NA>        FALSE     1     FALSE     TRUE
2    NUM_CONST      SYMBOL        FALSE     1     FALSE     TRUE
3         <NA>        <NA>        FALSE     1     FALSE     TRUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                             child
1                          5, 4, 7, 3, 4, 6, 2, 2, 2, 1, 8, 11, 2, 2, 2, 2, 9, 12, 10, 10, 10, expr, LEFT_ASSIGN, expr, FALSE, TRUE, FALSE, ab, <-, 1L, ab, <-, 1L, NA, SYMBOL, NA, NA, NUM_CONST, NA, FALSE, FALSE, FALSE, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 2, 3, 2, 1, 2, 2, 5, SYMBOL, TRUE, ab, ab, , LEFT_ASSIGN, FALSE, NA, FALSE, FALSE, 5, 6, 2, 11, 2, 12, 7, NUM_CONST, TRUE, 1L, 1L, LEFT_ASSIGN, COMMENT, FALSE, NA, FALSE, FALSE
2                                                                                                                                                                                                                                                                                                                                                                                                                                                             NULL
3 15, 14, 17, 10, 11, 13, 3, 3, 3, 1, 8, 11, 3, 3, 3, 6, 9, 12, 19, 19, 19, expr, LEFT_ASSIGN, expr, FALSE, TRUE, FALSE, abcdef, <-, 2L, abcde, <-, 2L, NA, SYMBOL, NA, NA, NUM_CONST, NA, FALSE, FALSE, FALSE, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 9, 13, 3, 1, 3, 6, 15, SYMBOL, TRUE, abcdef, abcde, COMMENT, LEFT_ASSIGN, FALSE, NA, FALSE, FALSE, 12, 16, 3, 11, 3, 12, 17, NUM_CONST, TRUE, 2L, 2L, LEFT_ASSIGN, , FALSE, NA, FALSE, FALSE
> 
> 
> 
> cleanEx()
> nameEx("construct_out")
> ### * construct_out
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: construct_out
> ### Title: Construct *-out.R from a *-in.R
> ### Aliases: construct_out
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::construct_out(c(
+   "path/to/file/first-in.R",
+   "path/to/file/first-extended-in.R"
+ ))
[1] "path/to/file/first-out.R"          "path/to/file/first-extended-out.R"
> 
> 
> 
> cleanEx()
> nameEx("convert_newlines_to_linebreaks")
> ### * convert_newlines_to_linebreaks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convert_newlines_to_linebreaks
> ### Title: Replace the newline character with a line break
> ### Aliases: convert_newlines_to_linebreaks
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::convert_newlines_to_linebreaks("x\n2")
[1] "x" "2"
> # a simple strsplit approach does not cover both cases
> unlist(strsplit("x\n\n2", "\n", fixed = TRUE))
[1] "x" ""  "2"
> unlist(strsplit(c("x", "", "2"), "\n", fixed = TRUE))
[1] "x" "2"
> styler:::convert_newlines_to_linebreaks(c("x", "2"))
[1] "x" "2"
> 
> 
> 
> cleanEx()
> nameEx("create_node_from_nested_root")
> ### * create_node_from_nested_root
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create_node_from_nested_root
> ### Title: Convert a nested data frame into a node tree
> ### Aliases: create_node_from_nested_root
> ### Keywords: internal
> 
> ### ** Examples
> 
> if (rlang::is_installed("data.tree")) {
+   withr::with_options(
+     list(styler.cache_name = NULL), # temporarily deactivate cache
+     {
+       code <- "a <- function(x) { if(x > 1) { 1+1 } else {x} }"
+       nested_pd <- compute_parse_data_nested(code)
+       initialized <- styler:::pre_visit_one(
+         nested_pd, default_style_guide_attributes
+       )
+       styler:::create_node_from_nested_root(initialized,
+         structure_only = FALSE
+       )
+     }
+   )
+ }
                                                 levelName
1  ROOT (token: short_text [lag_newlines/spaces] {pos_id})
2   °--expr: a <-  [0/0] {1}                              
3       ¦--expr: a [0/1] {3}                              
4       ¦   °--SYMBOL: a [0/0] {2}                        
5       ¦--LEFT_ASSIGN: <- [0/1] {4}                      
6       °--expr: funct [0/0] {5}                          
7           ¦--FUNCTION: funct [0/0] {6}                  
8           ¦--'(': ( [0/0] {7}                           
9           ¦--SYMBOL_FORMALS: x [0/0] {8}                
10          ¦--')': ) [0/1] {9}                           
11          °--expr: { if( [0/0] {10}                     
12              ¦--'{': { [0/1] {11}                      
13              ¦--expr: if(x  [0/1] {12}                 
14              ¦   ¦--IF: if [0/0] {13}                  
15              ¦   ¦--'(': ( [0/0] {14}                  
16              ¦   ¦--expr: x > 1 [0/0] {15}             
17              ¦   ¦   ¦--expr: x [0/1] {17}             
18              ¦   ¦   ¦   °--SYMBOL: x [0/0] {16}       
19              ¦   ¦   ¦--GT: > [0/1] {18}               
20              ¦   ¦   °--expr: 1 [0/0] {20}             
21              ¦   ¦       °--NUM_CONST: 1 [0/0] {19}    
22              ¦   ¦--')': ) [0/1] {21}                  
23              ¦   ¦--expr: { 1+1 [0/1] {22}             
24              ¦   ¦   ¦--'{': { [0/1] {23}              
25              ¦   ¦   ¦--expr: 1+1 [0/1] {24}           
26              ¦   ¦   ¦   ¦--expr: 1 [0/0] {26}         
27              ¦   ¦   ¦   ¦   °--NUM_CONST: 1 [0/0] {25}
28              ¦   ¦   ¦   ¦--'+': + [0/0] {27}          
29              ¦   ¦   ¦   °--expr: 1 [0/0] {29}         
30              ¦   ¦   ¦       °--NUM_CONST: 1 [0/0] {28}
31              ¦   ¦   °--'}': } [0/0] {30}              
32              ¦   ¦--ELSE: else [0/1] {31}              
33              ¦   °--expr: {x} [0/0] {32}               
34              ¦       ¦--'{': { [0/0] {33}              
35              ¦       ¦--expr: x [0/0] {35}             
36              ¦       ¦   °--SYMBOL: x [0/0] {34}       
37              ¦       °--'}': } [0/0] {36}              
38              °--'}': } [0/0] {37}                      
> 
> 
> 
> cleanEx()
> nameEx("create_style_guide")
> ### * create_style_guide
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create_style_guide
> ### Title: Create a style guide
> ### Aliases: create_style_guide
> 
> ### ** Examples
> 
> set_line_break_before_curly_opening <- function(pd_flat) {
+   op <- pd_flat$token %in% "'{'"
+   pd_flat$lag_newlines[op] <- 1L
+   pd_flat
+ }
> set_line_break_before_curly_opening_style <- function() {
+   create_style_guide(
+     line_break = list(set_line_break_before_curly_opening),
+     style_guide_name = "some-style-guide",
+     style_guide_version = "some-version"
+   )
+ }
> style_text(
+   "a <- function(x) { x }",
+   style = set_line_break_before_curly_opening_style
+ )
a <- function(x)
{ x }
> 
> 
> 
> cleanEx()
> nameEx("default_style_guide_attributes")
> ### * default_style_guide_attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: default_style_guide_attributes
> ### Title: Initialize default style guide attributes
> ### Aliases: default_style_guide_attributes
> ### Keywords: internal
> 
> ### ** Examples
> 
> withr::with_options(
+   list(styler.cache_name = NULL), # temporarily deactivate cache
+   {
+     string_to_format <- "call( 3)"
+     pd <- compute_parse_data_nested(string_to_format)
+     styler:::pre_visit_one(pd, default_style_guide_attributes)
+   }
+ )
  pos_id token terminal     text short token_before token_after stylerignore
1      1  expr    FALSE call( 3) call(         <NA>        <NA>        FALSE
  block is_cached internal
1     1     FALSE     TRUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   child
1 3, 4, 6, 7, expr, '(', expr, ')', FALSE, TRUE, FALSE, TRUE, call, (, 3, ), call, (, 3, ), NA, SYMBOL_FUNCTION_CALL, NA, NUM_CONST, NA, NUM_CONST, NA, , FALSE, FALSE, FALSE, FALSE, NA, NA, NA, NA, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 2, SYMBOL_FUNCTION_CALL, TRUE, call, call, , '(', FALSE, NA, FALSE, FALSE, 0, 0, 0, 0, NA, 0, 5, NUM_CONST, TRUE, 3, 3, '(', ')', FALSE, NA, FALSE, FALSE, 0, 0, 0, 0, NA, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, NA, 0, NA, 0, NA, NA, NA, NA, 0, 0, 0, 0
  newlines lag_newlines spaces multi_line indention_ref_pos_id indent
1        0            0      0         NA                   NA      0
> 
> 
> 
> cleanEx()
> nameEx("dir_without_.")
> ### * dir_without_.
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dir_without_.
> ### Title: 'dir()', but without dot-prefix and different defaults
> ### Aliases: dir_without_.
> ### Keywords: internal
> 
> ### ** Examples
> 
> setdiff("./file.R", "file.R") # you want to standardize first.
[1] "./file.R"
> 
> 
> 
> cleanEx()
> nameEx("ensure_last_n_empty")
> ### * ensure_last_n_empty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ensure_last_n_empty
> ### Title: Ensure there is one (and only one) blank line at the end of a
> ###   vector
> ### Aliases: ensure_last_n_empty
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::ensure_last_n_empty("")
[1] ""
> styler:::ensure_last_n_empty(letters)
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z" "" 
> styler:::ensure_last_n_empty(c(letters, "", "", ""))
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z" "" 
> 
> 
> 
> cleanEx()
> nameEx("find_pos_id_to_keep")
> ### * find_pos_id_to_keep
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: find_pos_id_to_keep
> ### Title: Find the pos ids to keep
> ### Aliases: find_pos_id_to_keep
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::get_parse_data(c("#", "1"))
  line1 col1 line2 col2 id parent     token terminal text pos_id short
1     1    1     1    1  1     -5   COMMENT     TRUE    #      1     #
2     2    1     2    1  4      5 NUM_CONST     TRUE    1      2     1
3     2    1     2    1  5      0      expr    FALSE    1      3     1
> styler:::get_parse_data(c("c(#", "1)"))
  line1 col1 line2 col2 id parent                token terminal    text pos_id
1     1    1     2    2 12      0                 expr    FALSE c(#\n1)      1
2     1    1     1    1  1      3 SYMBOL_FUNCTION_CALL     TRUE       c      2
3     1    1     1    1  3     12                 expr    FALSE       c      3
4     1    2     1    2  2     12                  '('     TRUE       (      4
5     1    3     1    3  4     12              COMMENT     TRUE       #      5
6     2    1     2    1  6      7            NUM_CONST     TRUE       1      6
7     2    1     2    1  7     12                 expr    FALSE       1      7
8     2    2     2    2  8     12                  ')'     TRUE       )      8
   short
1 c(#\n1
2      c
3      c
4      (
5      #
6      1
7      1
8      )
> styler:::get_parse_data(c("", "c(#", "1)", "#"))
  line1 col1 line2 col2 id parent                token terminal    text pos_id
1     2    1     3    2 14      0                 expr    FALSE c(#\n1)      1
2     2    1     2    1  3      5 SYMBOL_FUNCTION_CALL     TRUE       c      2
3     2    1     2    1  5     14                 expr    FALSE       c      3
4     2    2     2    2  4     14                  '('     TRUE       (      4
5     2    3     2    3  6     14              COMMENT     TRUE       #      5
6     3    1     3    1  8      9            NUM_CONST     TRUE       1      6
7     3    1     3    1  9     14                 expr    FALSE       1      7
8     3    2     3    2 10     14                  ')'     TRUE       )      8
9     4    1     4    1 18      0              COMMENT     TRUE       #      9
   short
1 c(#\n1
2      c
3      c
4      (
5      #
6      1
7      1
8      )
9      #
> 
> 
> 
> cleanEx()
> nameEx("find_tokens_to_update")
> ### * find_tokens_to_update
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: find_tokens_to_update
> ### Title: Find the tokens to update when applying a reference indention
> ### Aliases: find_tokens_to_update
> ### Keywords: internal
> 
> ### ** Examples
> 
> style_text("function(a =
+ b,
+ dd
+ ) {}", scope = "indention")
function(a =
      b,
    dd
    ) {}
> style_text("function(a,
+ b,
+ dd
+ ) {}", scope = "indention")
function(a,
    b,
    dd
    ) {}
> 
> 
> 
> cleanEx()
> nameEx("fix_quotes")
> ### * fix_quotes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix_quotes
> ### Title: Replace single quotes with double quotes
> ### Aliases: fix_quotes
> ### Keywords: internal
> 
> ### ** Examples
> 
> style_text("'here
+ is a string
+ '")
"here
is a string
"
> 
> 
> 
> cleanEx()
> nameEx("is_code_chunk_header_or_xaringan_or_code_output")
> ### * is_code_chunk_header_or_xaringan_or_code_output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_code_chunk_header_or_xaringan_or_code_output
> ### Title: Identify spinning code chunk header or xaringan
> ### Aliases: is_code_chunk_header_or_xaringan_or_code_output
> ### Keywords: internal
> 
> ### ** Examples
> 
> style_text(c(
+   "# title",
+   "some_code <- function() {}",
+   "#+ chunk-label, opt1=value1",
+   "call(3, 2, c(3:2))",
+   "#> 99"
+ ))
# title
some_code <- function() {}
#+ chunk-label, opt1=value1
call(3, 2, c(3:2))
#> 99
> 
> 
> 
> cleanEx()
> nameEx("is_shebang")
> ### * is_shebang
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_shebang
> ### Title: Identify comments that are shebangs
> ### Aliases: is_shebang
> ### Keywords: internal
> 
> ### ** Examples
> 
> style_text("#!/usr/bin/env Rscript")
#!/usr/bin/env Rscript
> 
> 
> 
> cleanEx()
> nameEx("map_filetype_to_pattern")
> ### * map_filetype_to_pattern
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: map_filetype_to_pattern
> ### Title: Map the file type to a corresponding regular expression
> ### Aliases: map_filetype_to_pattern
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::map_filetype_to_pattern(c(".rMd", "R"))
[1] "(\\.rmd|\\.r)$"
> 
> 
> 
> cleanEx()
> nameEx("match_stop_to_start")
> ### * match_stop_to_start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: match_stop_to_start
> ### Title: Match a stop candidate to a start
> ### Aliases: match_stop_to_start
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::match_stop_to_start(1, c(3, 4, 5))
[1] 2
> 
> 
> 
> cleanEx()
> nameEx("math_token_spacing")
> ### * math_token_spacing
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: math_token_spacing
> ### Title: Specify spacing around math tokens
> ### Aliases: math_token_spacing specify_math_token_spacing
> ###   tidyverse_math_token_spacing
> 
> ### ** Examples
> 
> style_text(
+   "1+1   -3",
+   math_token_spacing = specify_math_token_spacing(zero = "'+'"),
+   strict = FALSE
+ )
1+1   - 3
> style_text(
+   "1+1   -3",
+   math_token_spacing = specify_math_token_spacing(zero = "'+'"),
+   strict = TRUE
+ )
1+1 - 3
> style_text(
+   "1+1   -3",
+   math_token_spacing = tidyverse_math_token_spacing(),
+   strict = FALSE
+ )
1 + 1   - 3
> style_text(
+   "1+1   -3",
+   math_token_spacing = tidyverse_math_token_spacing(),
+   strict = TRUE
+ )
1 + 1 - 3
> 
> 
> 
> cleanEx()
> nameEx("needs_indention_one")
> ### * needs_indention_one
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: needs_indention_one
> ### Title: Check whether indention is needed
> ### Aliases: needs_indention_one
> ### Keywords: internal
> 
> ### ** Examples
> 
> style_text(c(
+   "call(named = c,",
+   "named = b)"
+ ), strict = FALSE)
call(named = c,
  named = b)
> 
> 
> 
> cleanEx()
> nameEx("next_non_comment")
> ### * next_non_comment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: next_non_comment
> ### Title: Find the index of the next or previous non-comment in a parse
> ###   table.
> ### Aliases: next_non_comment previous_non_comment
> 
> ### ** Examples
> 
> code <- "a <- # hi \n x %>% b()"
> writeLines(code)
a <- # hi 
 x %>% b()
> pd <- compute_parse_data_nested(code)
> child <- pd$child[[1]]
> previous_non_comment(child, 4L)
[1] 2
> next_non_comment(child, 2L)
[1] 4
> 
> 
> 
> cleanEx()
> nameEx("next_terminal")
> ### * next_terminal
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: next_terminal
> ### Title: Tell me what the next terminal is
> ### Aliases: next_terminal
> ### Keywords: internal
> 
> ### ** Examples
> 
> withr::with_options(
+   list(styler.cache_name = NULL), # temporarily deactivate cache
+   {
+     pd <- compute_parse_data_nested("if (TRUE) f()")
+     styler:::next_terminal(pd)
+   }
+ )
  position pos_id token text
1        1      2    IF   if
> 
> 
> 
> cleanEx()
> nameEx("parse_roxygen")
> ### * parse_roxygen
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_roxygen
> ### Title: Parse roxygen comments into text
> ### Aliases: parse_roxygen
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::parse_roxygen(c(
+   "#' @examples",
+   "#' 1+  1"
+ ))
$text
[1] "\n"      "1+  1\n"

$example_type
[1] "examples"

> styler:::parse_roxygen(c(
+   "#' @examples 33",
+   "#'1+  1"
+ ))
$text
[1] "33\n"    "1+  1\n"

$example_type
[1] "examples"

> 
> 
> 
> cleanEx()
> nameEx("parse_safely")
> ### * parse_safely
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_safely
> ### Title: Save parsing from text
> ### Aliases: parse_safely
> ### Keywords: internal
> 
> ### ** Examples
> 
> try(styler:::parse_safely("a + 3 -4 -> x\r\n glück + 1"))
Error in styler:::parse_safely("a + 3 -4 -> x\r\n glück + 1") : 
  The code to style seems to use Windows style line endings (CRLF). styler currently only supports Unix style line endings (LF). Please change the EOL character in your editor to Unix style and try again.
The parsing error was:
<text>:1:14: unexpected invalid token
1: a + 3 -4 -> x
                 ^
> # This cannot be detected as a EOL style problem because the first
> # line ends as expected with \n
> try(styler:::parse_safely("a + 3 -4 -> x\nx + 2\r\n glück + 1"))
Error in styler:::parse_safely("a + 3 -4 -> x\nx + 2\r\n glück + 1") : 
  <text>:2:6: unexpected invalid token
1: a + 3 -4 -> x
2: x + 2
        ^
> 
> styler:::parse_safely("a + 3 -4 -> \n glück + 1")
expression(glück + 1 <- a + 3 - 4)
> 
> 
> 
> cleanEx()
> nameEx("parse_transform_serialize_r_block")
> ### * parse_transform_serialize_r_block
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: parse_transform_serialize_r_block
> ### Title: Parse, transform and serialize a nested parse table
> ### Aliases: parse_transform_serialize_r_block
> ### Keywords: internal
> 
> ### ** Examples
> 
> text_in <- 'x<- function()
+ "here
+ is"
+ NULL
+ 1+ 1
+ '
> style_text(text_in, base_indention = 3)
   x <- function() {
     "here
is"
   }
   NULL
   1 + 1
> # not equal to the naive approach
> styler:::construct_vertical(
+   paste0(styler:::add_spaces(3), style_text(text_in), sep = "")
+ )
   x <- function() {
     "here
   is"
   }
   NULL
   1 + 1
> 
> 
> 
> cleanEx()
> nameEx("pd_is")
> ### * pd_is
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pd_is
> ### Title: What is a parse table representing?
> ### Aliases: pd_is is_curly_expr is_for_expr is_conditional_expr
> ###   is_while_expr is_function_call is_function_declaration is_comment
> ###   is_tilde_expr is_asymmetric_tilde_expr is_symmetric_tilde_expr
> 
> ### ** Examples
> 
> code <- "if (TRUE) { 1 }"
> pd <- compute_parse_data_nested(code)
> is_curly_expr(pd)
[1] FALSE
> child_of_child <- pd$child[[1]]$child[[5]]
> is_curly_expr(child_of_child)
[1] TRUE
> 
> code <- "for (i in 1:5) print(1:i)"
> pd <- compute_parse_data_nested(code)
> is_for_expr(pd)
[1] FALSE
> is_for_expr(pd$child[[1]])
[1] TRUE
> 
> code <- "if (TRUE) x <- 1 else x <- 0"
> pd <- compute_parse_data_nested(code)
> is_conditional_expr(pd)
[1] FALSE
> is_conditional_expr(pd$child[[1]])
[1] TRUE
> 
> code <- "x <- list(1:3)"
> pd <- compute_parse_data_nested(code)
> is_function_call(pd)
[1] FALSE
> child_of_child <- pd$child[[1]]$child[[3]]
> is_function_call(child_of_child)
[1] TRUE
> 
> code <- "foo <- function() NULL"
> pd <- compute_parse_data_nested(code)
> is_function_declaration(pd)
[1] FALSE
> child_of_child <- pd$child[[1]]$child[[3]]
> is_function_declaration(child_of_child)
[1] TRUE
> 
> code <- "x <- 1 # TODO: check value"
> pd <- compute_parse_data_nested(code)
> is_comment(pd)
[1] FALSE  TRUE
> 
> code <- "lm(wt ~ mpg, mtcars)"
> pd <- compute_parse_data_nested(code)
> is_tilde_expr(pd$child[[1]]$child[[3]])
[1] TRUE
> is_symmetric_tilde_expr(pd$child[[1]]$child[[3]])
[1] TRUE
> is_asymmetric_tilde_expr(pd$child[[1]]$child[[3]])
[1] FALSE
> 
> 
> 
> 
> cleanEx()
> nameEx("reindention")
> ### * reindention
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: reindention
> ### Title: Specify what is re-indented how
> ### Aliases: reindention specify_reindention tidyverse_reindention
> 
> ### ** Examples
> 
> style_text("a <- xyz", reindention = specify_reindention(
+   regex_pattern = "xyz", indention = 4, comments_only = FALSE
+ ))
a <-    xyz
> style_text("a <- xyz", reindention = tidyverse_reindention())
a <- xyz
> 
> 
> 
> cleanEx()
> nameEx("remove_roxygen_header")
> ### * remove_roxygen_header
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: remove_roxygen_header
> ### Title: Remove roxygen header
> ### Aliases: remove_roxygen_header
> ### Keywords: internal
> 
> ### ** Examples
> 
> #' @examples c(1, 2)
> 
> 
> 
> cleanEx()
> nameEx("roxygen_remove_extra_brace")
> ### * roxygen_remove_extra_brace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roxygen_remove_extra_brace
> ### Title: Fix 'tools::parse_Rd()' output
> ### Aliases: roxygen_remove_extra_brace
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::parse_roxygen(
+   c(
+     "#' @examples",
+     "#' x <- '{'",
+     "#' \\dontrun{",
+     "#' fu(x = 3)",
+     "#' }"
+   )
+ )
$text
 [1] "\n"          "x <- '"      ""            "{"           "'\n"        
 [6] "\\dontrun"   "{"           "\n"          "fu(x = 3)\n" "}"          
[11] "\n"         

$example_type
[1] "examples"

> styler:::parse_roxygen(
+   c(
+     "#' @examples",
+     "#' x <- '{'",
+     "#' \\dontrun{",
+     "#' c('{', \"'{{{\" ,\"[\")",
+     "#' }"
+   )
+ )
$text
 [1] "\n"                        "x <- '"                   
 [3] ""                          "{"                        
 [5] "'\n"                       "\\dontrun"                
 [7] "{"                         "\n"                       
 [9] "c('{', \"'{{{\" ,\"[\")\n" "}\n"                      

$example_type
[1] "examples"

> 
> 
> 
> cleanEx()
> nameEx("scope_normalize")
> ### * scope_normalize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scope_normalize
> ### Title: Convert the styling scope to its lower-level representation
> ### Aliases: scope_normalize
> 
> ### ** Examples
> 
> scope_normalize(I("tokens"))
[1] tokens
Levels: none < spaces < indention < line_breaks < tokens
> scope_normalize(I(c("indention", "tokens")))
[1] indention tokens   
Levels: none < spaces < indention < line_breaks < tokens
> 
> 
> 
> cleanEx()
> nameEx("set_and_assert_arg_filetype")
> ### * set_and_assert_arg_filetype
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_and_assert_arg_filetype
> ### Title: Set the file type argument
> ### Aliases: set_and_assert_arg_filetype
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::set_and_assert_arg_filetype("rMd")
[1] "\\.rmd"
> try(styler:::set_and_assert_arg_filetype("xyz"))
Error in assert_filetype(without_dot) : 
  filetype must not contain other values than 'qmd', 'R', 'Rmarkdown', 'Rmd', 'Rnw', or 'Rprofile' (case is ignored).
> 
> 
> 
> cleanEx()
> nameEx("set_arg_paths")
> ### * set_arg_paths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_arg_paths
> ### Title: Standardize paths in root
> ### Aliases: set_arg_paths
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::set_arg_paths(c("./file.R", "file.R", "../another-file.R"))
[1] "file.R"            "file.R"            "../another-file.R"
> 
> 
> 
> cleanEx()
> nameEx("set_line_break_before_curly_opening")
> ### * set_line_break_before_curly_opening
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_line_break_before_curly_opening
> ### Title: Set line break before a curly brace
> ### Aliases: set_line_break_before_curly_opening
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (FALSE) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ tryCatch(
+   {
+     f(8)
+   },
+   error = function(e) NULL
+ )
+ # last-argument case
+ testthat("braces braces are cool", {
+   code(to = execute)
+ })
+ call2(
+   x = 2, {
+     code(to = execute)
+   },
+   c = {
+     # this is the named case
+     g(x = 7)
+   }
+ )
+ tryGugus(
+   {
+     g5(k = na)
+   },
+   a + b # line break also here because
+   # preceded by brace expression
+ )
+ 
+ # brace expressions go on new line if part of a pipe, in function call...
+ c(
+   data %>%
+     filter(bar) %>%
+     {
+       cor(.$col1, .$col2, use = "complete.obs")
+     }
+ )
+ # ... or outside
+ data %>%
+   filter(bar) %>%
+   {
+     cor(.$col1, .$col2, use = "complete.obs")
+   }
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("specify_transformers_drop")
> ### * specify_transformers_drop
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: specify_transformers_drop
> ### Title: Specify which tokens must be absent for a transformer to be
> ###   dropped
> ### Aliases: specify_transformers_drop
> 
> ### ** Examples
> 
> dropping <- specify_transformers_drop(
+   spaces = c(remove_space_after_excl = "'!'")
+ )
> style_guide <- create_style_guide(
+   space = list(remove_space_after_excl = styler:::remove_space_after_excl),
+   transformers_drop = dropping
+ )
> # transformers_drop() will remove the transformer when the code does not
> # contain an exclamation mark
> style_guide_with_some_transformers_dropped <- styler:::transformers_drop(
+   "x <- 3;2", style_guide
+ )
> setdiff(
+   names(style_guide$space),
+   names(style_guide_with_some_transformers_dropped)
+ )
[1] "remove_space_after_excl"
> # note that dropping all transformers of a scope means that this scope
> # has an empty named list for this scope
> style_guide_with_some_transformers_dropped$space
named list()
> # this is not the same as if this scope was never specified.
> tidyverse_style(scope = "none")$space
NULL
> # Hence, styler should check for length 0 to decide if a scope is present or
> # not, not via `is.null()` and we can use the `is.null()` check to see if
> # this scope was initially required by the user.
> 
> 
> 
> cleanEx()
> nameEx("style_dir")
> ### * style_dir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: style_dir
> ### Title: Prettify arbitrary R code
> ### Aliases: style_dir
> 
> ### ** Examples
> 
> ## Don't show: 
> if (FALSE) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ style_dir("path/to/dir", filetype = c("rmd", ".R"))
+ 
+ # the following is identical (because of ... and defaults)
+ # but the first is most convenient:
+ style_dir(strict = TRUE)
+ style_dir(style = tidyverse_style, strict = TRUE)
+ style_dir(transformers = tidyverse_style(strict = TRUE))
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("style_file")
> ### * style_file
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: style_file
> ### Title: Style files with R source code
> ### Aliases: style_file
> 
> ### ** Examples
> 
> file <- tempfile("styler", fileext = ".R")
> writeLines("1++1", file)
> 
> # the following is identical (because of ... and defaults),
> # but the first is most convenient:
> style_file(file, strict = TRUE)
Styling  1  files:
 /tmp/RtmpRKd0O3/styler1fad2214ff0c9.R ℹ 
────────────────────────────────────────
Status	Count	Legend 
✔ 	0	File unchanged.
ℹ 	1	File changed.
✖ 	0	Styling threw an error.
────────────────────────────────────────
Please review the changes carefully!
> style_file(file, style = tidyverse_style, strict = TRUE)
Styling  1  files:
 /tmp/RtmpRKd0O3/styler1fad2214ff0c9.R ✔ 
────────────────────────────────────────
Status	Count	Legend 
✔ 	1	File unchanged.
ℹ 	0	File changed.
✖ 	0	Styling threw an error.
────────────────────────────────────────
> style_file(file, transformers = tidyverse_style(strict = TRUE))
Styling  1  files:
 /tmp/RtmpRKd0O3/styler1fad2214ff0c9.R ✔ 
────────────────────────────────────────
Status	Count	Legend 
✔ 	1	File unchanged.
ℹ 	0	File changed.
✖ 	0	Styling threw an error.
────────────────────────────────────────
> 
> # only style indention and less invasive  levels (i.e. spaces)
> style_file(file, scope = "indention", strict = TRUE)
Styling  1  files:
 /tmp/RtmpRKd0O3/styler1fad2214ff0c9.R ✔ 
────────────────────────────────────────
Status	Count	Legend 
✔ 	1	File unchanged.
ℹ 	0	File changed.
✖ 	0	Styling threw an error.
────────────────────────────────────────
> # name levels explicitly to not style less invasive levels
> style_file(file, scope = I(c("tokens", "spaces")), strict = TRUE)
Styling  1  files:
 /tmp/RtmpRKd0O3/styler1fad2214ff0c9.R ✔ 
────────────────────────────────────────
Status	Count	Legend 
✔ 	1	File unchanged.
ℹ 	0	File changed.
✖ 	0	Styling threw an error.
────────────────────────────────────────
> 
> readLines(file)
[1] "1 + +1"
> unlink(file)
> 
> 
> 
> cleanEx()
> nameEx("style_pkg")
> ### * style_pkg
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: style_pkg
> ### Title: Prettify R source code
> ### Aliases: style_pkg
> 
> ### ** Examples
> 
> ## Don't show: 
> if (FALSE) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # the following is identical (because of ... and defaults)
+ # but the first is most convenient:
+ style_pkg(strict = TRUE)
+ style_pkg(style = tidyverse_style, strict = TRUE)
+ style_pkg(transformers = tidyverse_style(strict = TRUE))
+ 
+ # more options from `tidyverse_style()`
+ style_pkg(
+   scope = "line_breaks",
+   math_token_spacing = specify_math_token_spacing(zero = "'+'")
+ )
+ 
+ # don't write back and fail if input is not already styled
+ style_pkg("/path/to/pkg/", dry = "fail")
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("style_text")
> ### * style_text
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: style_text
> ### Title: Style a string
> ### Aliases: style_text
> 
> ### ** Examples
> 
> style_text("call( 1)")
call(1)
> style_text("1    + 1", strict = FALSE)
1    + 1
> 
> # the following is identical (because of ... and defaults)
> # but the first is most convenient:
> style_text("a<-3++1", strict = TRUE)
a <- 3 + +1
> style_text("a<-3++1", style = tidyverse_style, strict = TRUE)
a <- 3 + +1
> style_text("a<-3++1", transformers = tidyverse_style(strict = TRUE))
a <- 3 + +1
> 
> # more invasive scopes include less invasive scopes by default
> style_text("a%>%b", scope = "spaces")
a %>% b
> style_text("a%>%b; a", scope = "line_breaks")
a %>% b; a
> style_text("a%>%b; a", scope = "tokens")
a %>% b()
a
> 
> # opt out with I() to only style specific levels
> style_text("a%>%b; a", scope = I("tokens"))
a%>%b()
a
> 
> 
> 
> cleanEx()
> nameEx("style_text_without_curly_curly")
> ### * style_text_without_curly_curly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: style_text_without_curly_curly
> ### Title: 'style_text()' without rules for {{
> ### Aliases: style_text_without_curly_curly
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::style_text_without_curly_curly("rlang::list2({{ x }} := 2L)")
rlang::list2({
  {
    x
  }
} := 2L)
> styler:::style_text("rlang::list2({{ x }} := 3)")
rlang::list2({{ x }} := 3)
> 
> 
> 
> cleanEx()
> nameEx("styler-package")
> ### * styler-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: styler-package
> ### Title: styler: Non-Invasive Pretty Printing of R Code
> ### Aliases: styler styler-package
> 
> ### ** Examples
> 
> style_text("call( 1)")
call(1)
> style_text("1    + 1", strict = FALSE)
1    + 1
> style_text("a%>%b", scope = "spaces")
a %>% b
> style_text("a%>%b; a", scope = "line_breaks")
a %>% b; a
> style_text("a%>%b; a", scope = "tokens")
a %>% b()
a
> 
> 
> 
> cleanEx()
> nameEx("styler_addins")
> ### * styler_addins
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: styler_addins
> ### Title: Stylers for RStudio Addins
> ### Aliases: styler_addins
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # save after styling when using the Addin
> ##D options(styler.save_after_styling = TRUE)
> ##D # only style with scope = "spaces" when using the Addin
> ##D val <- "styler::tidyverse_style(scope = 'spaces')"
> ##D options(
> ##D   styler.addins_style_transformer = val
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("stylerignore")
> ### * stylerignore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stylerignore
> ### Title: Turn off styling for parts of the code
> ### Aliases: stylerignore
> 
> ### ** Examples
> 
> # as long as the order of the markers is correct, the lines are ignored.
> style_text(
+   "
+   1+1
+   # styler: off
+   1+1
+   # styler: on
+   1+1
+   "
+ )
1 + 1
  # styler: off
  1+1
# styler: on
1 + 1
> 
> # if there is a stop marker before a start marker, styler won't be able
> # to figure out which lines you want to ignore and won't ignore anything,
> # issuing a warning.
> ## Not run: 
> ##D style_text(
> ##D   "
> ##D   1+1
> ##D   # styler: off
> ##D   1+1
> ##D   # styler: off
> ##D   1+1
> ##D   "
> ##D )
> ## End(Not run)
> # some alignment of code is detected, so you don't need to use stylerignore
> style_text(
+   "call(
+     xyz =  3,
+     x   = 11
+   )"
+ )
call(
  xyz =  3,
  x   = 11
)
> 
> 
> 
> cleanEx()
> nameEx("tidyverse_style")
> ### * tidyverse_style
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidyverse_style
> ### Title: The tidyverse style
> ### Aliases: tidyverse_style
> 
> ### ** Examples
> 
> style_text("call( 1)", style = tidyverse_style, scope = "spaces")
call(1)
> style_text("call( 1)", transformers = tidyverse_style(strict = TRUE))
call(1)
> style_text(c("ab <- 3", "a  <-3"), strict = FALSE) # keeps alignment of "<-"
ab <- 3
a  <- 3
> style_text(c("ab <- 3", "a  <-3"), strict = TRUE) # drops alignment of "<-"
ab <- 3
a <- 3
> 
> # styling line breaks only without spaces
> style_text(c("ab <- 3", "a =3"), strict = TRUE, scope = I(c("line_breaks", "tokens")))
ab <- 3
a <-3
> 
> 
> 
> cleanEx()
> nameEx("token_is_on_aligned_line")
> ### * token_is_on_aligned_line
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: token_is_on_aligned_line
> ### Title: Check if tokens are aligned
> ### Aliases: token_is_on_aligned_line
> ### Keywords: internal
> 
> ### ** Examples
> 
> library("magrittr")
> withr::with_options(
+   list(styler.cache_name = NULL), # temporarily deactivate cache
+   {
+     transformers <- tidyverse_style()
+     pd_nested <- compute_parse_data_nested(c(
+       "call(",
+       "  ab = 1L,",
+       "  a  = 2",
+       ")"
+     )) %>%
+       styler:::post_visit(transformers$initialize)
+     nest <- pd_nested$child[[1L]]
+     styler:::token_is_on_aligned_line(nest)
+   }
+ )
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘package:magrittr’

> nameEx("update_indention_ref")
> ### * update_indention_ref
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_indention_ref
> ### Title: Update the indention reference
> ### Aliases: update_indention_ref update_indention_ref_fun_dec
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D a <- function(x,
> ##D               y) {
> ##D   x + y
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("verify_roundtrip")
> ### * verify_roundtrip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: verify_roundtrip
> ### Title: Verify the styling
> ### Aliases: verify_roundtrip
> ### Keywords: internal
> 
> ### ** Examples
> 
> styler:::verify_roundtrip("a+1", "a + 1")
> styler:::verify_roundtrip("a+1", "a + 1 # comments are dropped")
> try(styler:::verify_roundtrip("a+1", "b - 3"))
Error in styler:::verify_roundtrip("a+1", "b - 3") : 
  The expression evaluated before the styling is not the same as the expression after styling. This should not happen.
ℹ This is an internal error that was detected in the styler package.
  Please report it at <https://github.com/r-lib/styler/issues> with a reprex (<https://tidyverse.org/help/>) and the full backtrace.
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.54 0.051 1.591 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
