
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:39:33.302] plan(): Setting new future strategy stack:
[17:39:33.302] List of future strategies:
[17:39:33.302] 1. sequential:
[17:39:33.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.302]    - tweaked: FALSE
[17:39:33.302]    - call: future::plan("sequential")
[17:39:33.313] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[17:39:33.370] plan(): Setting new future strategy stack:
[17:39:33.371] List of future strategies:
[17:39:33.371] 1. sequential:
[17:39:33.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.371]    - tweaked: FALSE
[17:39:33.371]    - call: plan(strategy)
[17:39:33.382] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:39:33.383] getGlobalsAndPackages() ...
[17:39:33.383] Searching for globals...
[17:39:33.387] 
[17:39:33.387] Searching for globals ... DONE
[17:39:33.388] - globals: [0] <none>
[17:39:33.388] getGlobalsAndPackages() ... DONE
[17:39:33.388] run() for ‘Future’ ...
[17:39:33.389] - state: ‘created’
[17:39:33.389] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.389]   - Field: ‘label’
[17:39:33.389]   - Field: ‘local’
[17:39:33.390]   - Field: ‘owner’
[17:39:33.390]   - Field: ‘envir’
[17:39:33.390]   - Field: ‘packages’
[17:39:33.390]   - Field: ‘gc’
[17:39:33.390]   - Field: ‘conditions’
[17:39:33.390]   - Field: ‘expr’
[17:39:33.390]   - Field: ‘uuid’
[17:39:33.390]   - Field: ‘seed’
[17:39:33.390]   - Field: ‘version’
[17:39:33.390]   - Field: ‘result’
[17:39:33.390]   - Field: ‘asynchronous’
[17:39:33.391]   - Field: ‘calls’
[17:39:33.391]   - Field: ‘globals’
[17:39:33.391]   - Field: ‘stdout’
[17:39:33.391]   - Field: ‘earlySignal’
[17:39:33.391]   - Field: ‘lazy’
[17:39:33.391]   - Field: ‘state’
[17:39:33.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.391] - Launch lazy future ...
[17:39:33.392] Packages needed by the future expression (n = 0): <none>
[17:39:33.392] Packages needed by future strategies (n = 0): <none>
[17:39:33.393] {
[17:39:33.393]     {
[17:39:33.393]         {
[17:39:33.393]             ...future.startTime <- base::Sys.time()
[17:39:33.393]             {
[17:39:33.393]                 {
[17:39:33.393]                   {
[17:39:33.393]                     base::local({
[17:39:33.393]                       has_future <- base::requireNamespace("future", 
[17:39:33.393]                         quietly = TRUE)
[17:39:33.393]                       if (has_future) {
[17:39:33.393]                         ns <- base::getNamespace("future")
[17:39:33.393]                         version <- ns[[".package"]][["version"]]
[17:39:33.393]                         if (is.null(version)) 
[17:39:33.393]                           version <- utils::packageVersion("future")
[17:39:33.393]                       }
[17:39:33.393]                       else {
[17:39:33.393]                         version <- NULL
[17:39:33.393]                       }
[17:39:33.393]                       if (!has_future || version < "1.8.0") {
[17:39:33.393]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.393]                           "", base::R.version$version.string), 
[17:39:33.393]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.393]                             "release", "version")], collapse = " "), 
[17:39:33.393]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.393]                           info)
[17:39:33.393]                         info <- base::paste(info, collapse = "; ")
[17:39:33.393]                         if (!has_future) {
[17:39:33.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.393]                             info)
[17:39:33.393]                         }
[17:39:33.393]                         else {
[17:39:33.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.393]                             info, version)
[17:39:33.393]                         }
[17:39:33.393]                         base::stop(msg)
[17:39:33.393]                       }
[17:39:33.393]                     })
[17:39:33.393]                   }
[17:39:33.393]                   ...future.strategy.old <- future::plan("list")
[17:39:33.393]                   options(future.plan = NULL)
[17:39:33.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.393]                 }
[17:39:33.393]                 ...future.workdir <- getwd()
[17:39:33.393]             }
[17:39:33.393]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.393]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.393]         }
[17:39:33.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.393]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.393]             base::names(...future.oldOptions))
[17:39:33.393]     }
[17:39:33.393]     if (FALSE) {
[17:39:33.393]     }
[17:39:33.393]     else {
[17:39:33.393]         if (TRUE) {
[17:39:33.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.393]                 open = "w")
[17:39:33.393]         }
[17:39:33.393]         else {
[17:39:33.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.393]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.393]         }
[17:39:33.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.393]             base::sink(type = "output", split = FALSE)
[17:39:33.393]             base::close(...future.stdout)
[17:39:33.393]         }, add = TRUE)
[17:39:33.393]     }
[17:39:33.393]     ...future.frame <- base::sys.nframe()
[17:39:33.393]     ...future.conditions <- base::list()
[17:39:33.393]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.393]     if (FALSE) {
[17:39:33.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.393]     }
[17:39:33.393]     ...future.result <- base::tryCatch({
[17:39:33.393]         base::withCallingHandlers({
[17:39:33.393]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.393]             future::FutureResult(value = ...future.value$value, 
[17:39:33.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.393]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.393]                     ...future.globalenv.names))
[17:39:33.393]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.393]         }, condition = base::local({
[17:39:33.393]             c <- base::c
[17:39:33.393]             inherits <- base::inherits
[17:39:33.393]             invokeRestart <- base::invokeRestart
[17:39:33.393]             length <- base::length
[17:39:33.393]             list <- base::list
[17:39:33.393]             seq.int <- base::seq.int
[17:39:33.393]             signalCondition <- base::signalCondition
[17:39:33.393]             sys.calls <- base::sys.calls
[17:39:33.393]             `[[` <- base::`[[`
[17:39:33.393]             `+` <- base::`+`
[17:39:33.393]             `<<-` <- base::`<<-`
[17:39:33.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.393]                   3L)]
[17:39:33.393]             }
[17:39:33.393]             function(cond) {
[17:39:33.393]                 is_error <- inherits(cond, "error")
[17:39:33.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.393]                   NULL)
[17:39:33.393]                 if (is_error) {
[17:39:33.393]                   sessionInformation <- function() {
[17:39:33.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.393]                       search = base::search(), system = base::Sys.info())
[17:39:33.393]                   }
[17:39:33.393]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.393]                     cond$call), session = sessionInformation(), 
[17:39:33.393]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.393]                   signalCondition(cond)
[17:39:33.393]                 }
[17:39:33.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.393]                 "immediateCondition"))) {
[17:39:33.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.393]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.393]                   if (TRUE && !signal) {
[17:39:33.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.393]                     {
[17:39:33.393]                       inherits <- base::inherits
[17:39:33.393]                       invokeRestart <- base::invokeRestart
[17:39:33.393]                       is.null <- base::is.null
[17:39:33.393]                       muffled <- FALSE
[17:39:33.393]                       if (inherits(cond, "message")) {
[17:39:33.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.393]                         if (muffled) 
[17:39:33.393]                           invokeRestart("muffleMessage")
[17:39:33.393]                       }
[17:39:33.393]                       else if (inherits(cond, "warning")) {
[17:39:33.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.393]                         if (muffled) 
[17:39:33.393]                           invokeRestart("muffleWarning")
[17:39:33.393]                       }
[17:39:33.393]                       else if (inherits(cond, "condition")) {
[17:39:33.393]                         if (!is.null(pattern)) {
[17:39:33.393]                           computeRestarts <- base::computeRestarts
[17:39:33.393]                           grepl <- base::grepl
[17:39:33.393]                           restarts <- computeRestarts(cond)
[17:39:33.393]                           for (restart in restarts) {
[17:39:33.393]                             name <- restart$name
[17:39:33.393]                             if (is.null(name)) 
[17:39:33.393]                               next
[17:39:33.393]                             if (!grepl(pattern, name)) 
[17:39:33.393]                               next
[17:39:33.393]                             invokeRestart(restart)
[17:39:33.393]                             muffled <- TRUE
[17:39:33.393]                             break
[17:39:33.393]                           }
[17:39:33.393]                         }
[17:39:33.393]                       }
[17:39:33.393]                       invisible(muffled)
[17:39:33.393]                     }
[17:39:33.393]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.393]                   }
[17:39:33.393]                 }
[17:39:33.393]                 else {
[17:39:33.393]                   if (TRUE) {
[17:39:33.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.393]                     {
[17:39:33.393]                       inherits <- base::inherits
[17:39:33.393]                       invokeRestart <- base::invokeRestart
[17:39:33.393]                       is.null <- base::is.null
[17:39:33.393]                       muffled <- FALSE
[17:39:33.393]                       if (inherits(cond, "message")) {
[17:39:33.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.393]                         if (muffled) 
[17:39:33.393]                           invokeRestart("muffleMessage")
[17:39:33.393]                       }
[17:39:33.393]                       else if (inherits(cond, "warning")) {
[17:39:33.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.393]                         if (muffled) 
[17:39:33.393]                           invokeRestart("muffleWarning")
[17:39:33.393]                       }
[17:39:33.393]                       else if (inherits(cond, "condition")) {
[17:39:33.393]                         if (!is.null(pattern)) {
[17:39:33.393]                           computeRestarts <- base::computeRestarts
[17:39:33.393]                           grepl <- base::grepl
[17:39:33.393]                           restarts <- computeRestarts(cond)
[17:39:33.393]                           for (restart in restarts) {
[17:39:33.393]                             name <- restart$name
[17:39:33.393]                             if (is.null(name)) 
[17:39:33.393]                               next
[17:39:33.393]                             if (!grepl(pattern, name)) 
[17:39:33.393]                               next
[17:39:33.393]                             invokeRestart(restart)
[17:39:33.393]                             muffled <- TRUE
[17:39:33.393]                             break
[17:39:33.393]                           }
[17:39:33.393]                         }
[17:39:33.393]                       }
[17:39:33.393]                       invisible(muffled)
[17:39:33.393]                     }
[17:39:33.393]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.393]                   }
[17:39:33.393]                 }
[17:39:33.393]             }
[17:39:33.393]         }))
[17:39:33.393]     }, error = function(ex) {
[17:39:33.393]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.393]                 ...future.rng), started = ...future.startTime, 
[17:39:33.393]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.393]             version = "1.8"), class = "FutureResult")
[17:39:33.393]     }, finally = {
[17:39:33.393]         if (!identical(...future.workdir, getwd())) 
[17:39:33.393]             setwd(...future.workdir)
[17:39:33.393]         {
[17:39:33.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.393]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.393]             }
[17:39:33.393]             base::options(...future.oldOptions)
[17:39:33.393]             if (.Platform$OS.type == "windows") {
[17:39:33.393]                 old_names <- names(...future.oldEnvVars)
[17:39:33.393]                 envs <- base::Sys.getenv()
[17:39:33.393]                 names <- names(envs)
[17:39:33.393]                 common <- intersect(names, old_names)
[17:39:33.393]                 added <- setdiff(names, old_names)
[17:39:33.393]                 removed <- setdiff(old_names, names)
[17:39:33.393]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.393]                   envs[common]]
[17:39:33.393]                 NAMES <- toupper(changed)
[17:39:33.393]                 args <- list()
[17:39:33.393]                 for (kk in seq_along(NAMES)) {
[17:39:33.393]                   name <- changed[[kk]]
[17:39:33.393]                   NAME <- NAMES[[kk]]
[17:39:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.393]                     next
[17:39:33.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.393]                 }
[17:39:33.393]                 NAMES <- toupper(added)
[17:39:33.393]                 for (kk in seq_along(NAMES)) {
[17:39:33.393]                   name <- added[[kk]]
[17:39:33.393]                   NAME <- NAMES[[kk]]
[17:39:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.393]                     next
[17:39:33.393]                   args[[name]] <- ""
[17:39:33.393]                 }
[17:39:33.393]                 NAMES <- toupper(removed)
[17:39:33.393]                 for (kk in seq_along(NAMES)) {
[17:39:33.393]                   name <- removed[[kk]]
[17:39:33.393]                   NAME <- NAMES[[kk]]
[17:39:33.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.393]                     next
[17:39:33.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.393]                 }
[17:39:33.393]                 if (length(args) > 0) 
[17:39:33.393]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.393]             }
[17:39:33.393]             else {
[17:39:33.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.393]             }
[17:39:33.393]             {
[17:39:33.393]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.393]                   0L) {
[17:39:33.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.393]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.393]                   base::options(opts)
[17:39:33.393]                 }
[17:39:33.393]                 {
[17:39:33.393]                   {
[17:39:33.393]                     NULL
[17:39:33.393]                     RNGkind("Mersenne-Twister")
[17:39:33.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.393]                       inherits = FALSE)
[17:39:33.393]                   }
[17:39:33.393]                   options(future.plan = NULL)
[17:39:33.393]                   if (is.na(NA_character_)) 
[17:39:33.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.393]                     .init = FALSE)
[17:39:33.393]                 }
[17:39:33.393]             }
[17:39:33.393]         }
[17:39:33.393]     })
[17:39:33.393]     if (TRUE) {
[17:39:33.393]         base::sink(type = "output", split = FALSE)
[17:39:33.393]         if (TRUE) {
[17:39:33.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.393]         }
[17:39:33.393]         else {
[17:39:33.393]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.393]         }
[17:39:33.393]         base::close(...future.stdout)
[17:39:33.393]         ...future.stdout <- NULL
[17:39:33.393]     }
[17:39:33.393]     ...future.result$conditions <- ...future.conditions
[17:39:33.393]     ...future.result$finished <- base::Sys.time()
[17:39:33.393]     ...future.result
[17:39:33.393] }
[17:39:33.395] plan(): Setting new future strategy stack:
[17:39:33.395] List of future strategies:
[17:39:33.395] 1. sequential:
[17:39:33.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.395]    - tweaked: FALSE
[17:39:33.395]    - call: NULL
[17:39:33.395] plan(): nbrOfWorkers() = 1
[17:39:33.397] plan(): Setting new future strategy stack:
[17:39:33.397] List of future strategies:
[17:39:33.397] 1. sequential:
[17:39:33.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.397]    - tweaked: FALSE
[17:39:33.397]    - call: plan(strategy)
[17:39:33.397] plan(): nbrOfWorkers() = 1
[17:39:33.397] SequentialFuture started (and completed)
[17:39:33.398] - Launch lazy future ... done
[17:39:33.398] run() for ‘SequentialFuture’ ... done
[17:39:33.398] getGlobalsAndPackages() ...
[17:39:33.398] Searching for globals...
[17:39:33.398] 
[17:39:33.399] Searching for globals ... DONE
[17:39:33.399] - globals: [0] <none>
[17:39:33.399] getGlobalsAndPackages() ... DONE
[17:39:33.399] run() for ‘Future’ ...
[17:39:33.399] - state: ‘created’
[17:39:33.399] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.399] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.400]   - Field: ‘label’
[17:39:33.400]   - Field: ‘local’
[17:39:33.400]   - Field: ‘owner’
[17:39:33.400]   - Field: ‘envir’
[17:39:33.400]   - Field: ‘packages’
[17:39:33.400]   - Field: ‘gc’
[17:39:33.400]   - Field: ‘conditions’
[17:39:33.400]   - Field: ‘expr’
[17:39:33.400]   - Field: ‘uuid’
[17:39:33.401]   - Field: ‘seed’
[17:39:33.401]   - Field: ‘version’
[17:39:33.401]   - Field: ‘result’
[17:39:33.401]   - Field: ‘asynchronous’
[17:39:33.401]   - Field: ‘calls’
[17:39:33.401]   - Field: ‘globals’
[17:39:33.401]   - Field: ‘stdout’
[17:39:33.401]   - Field: ‘earlySignal’
[17:39:33.401]   - Field: ‘lazy’
[17:39:33.401]   - Field: ‘state’
[17:39:33.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.402] - Launch lazy future ...
[17:39:33.402] Packages needed by the future expression (n = 0): <none>
[17:39:33.402] Packages needed by future strategies (n = 0): <none>
[17:39:33.402] {
[17:39:33.402]     {
[17:39:33.402]         {
[17:39:33.402]             ...future.startTime <- base::Sys.time()
[17:39:33.402]             {
[17:39:33.402]                 {
[17:39:33.402]                   {
[17:39:33.402]                     base::local({
[17:39:33.402]                       has_future <- base::requireNamespace("future", 
[17:39:33.402]                         quietly = TRUE)
[17:39:33.402]                       if (has_future) {
[17:39:33.402]                         ns <- base::getNamespace("future")
[17:39:33.402]                         version <- ns[[".package"]][["version"]]
[17:39:33.402]                         if (is.null(version)) 
[17:39:33.402]                           version <- utils::packageVersion("future")
[17:39:33.402]                       }
[17:39:33.402]                       else {
[17:39:33.402]                         version <- NULL
[17:39:33.402]                       }
[17:39:33.402]                       if (!has_future || version < "1.8.0") {
[17:39:33.402]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.402]                           "", base::R.version$version.string), 
[17:39:33.402]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.402]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.402]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.402]                             "release", "version")], collapse = " "), 
[17:39:33.402]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.402]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.402]                           info)
[17:39:33.402]                         info <- base::paste(info, collapse = "; ")
[17:39:33.402]                         if (!has_future) {
[17:39:33.402]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.402]                             info)
[17:39:33.402]                         }
[17:39:33.402]                         else {
[17:39:33.402]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.402]                             info, version)
[17:39:33.402]                         }
[17:39:33.402]                         base::stop(msg)
[17:39:33.402]                       }
[17:39:33.402]                     })
[17:39:33.402]                   }
[17:39:33.402]                   ...future.strategy.old <- future::plan("list")
[17:39:33.402]                   options(future.plan = NULL)
[17:39:33.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.402]                 }
[17:39:33.402]                 ...future.workdir <- getwd()
[17:39:33.402]             }
[17:39:33.402]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.402]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.402]         }
[17:39:33.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.402]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.402]             base::names(...future.oldOptions))
[17:39:33.402]     }
[17:39:33.402]     if (FALSE) {
[17:39:33.402]     }
[17:39:33.402]     else {
[17:39:33.402]         if (TRUE) {
[17:39:33.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.402]                 open = "w")
[17:39:33.402]         }
[17:39:33.402]         else {
[17:39:33.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.402]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.402]         }
[17:39:33.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.402]             base::sink(type = "output", split = FALSE)
[17:39:33.402]             base::close(...future.stdout)
[17:39:33.402]         }, add = TRUE)
[17:39:33.402]     }
[17:39:33.402]     ...future.frame <- base::sys.nframe()
[17:39:33.402]     ...future.conditions <- base::list()
[17:39:33.402]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.402]     if (FALSE) {
[17:39:33.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.402]     }
[17:39:33.402]     ...future.result <- base::tryCatch({
[17:39:33.402]         base::withCallingHandlers({
[17:39:33.402]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.402]             future::FutureResult(value = ...future.value$value, 
[17:39:33.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.402]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.402]                     ...future.globalenv.names))
[17:39:33.402]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.402]         }, condition = base::local({
[17:39:33.402]             c <- base::c
[17:39:33.402]             inherits <- base::inherits
[17:39:33.402]             invokeRestart <- base::invokeRestart
[17:39:33.402]             length <- base::length
[17:39:33.402]             list <- base::list
[17:39:33.402]             seq.int <- base::seq.int
[17:39:33.402]             signalCondition <- base::signalCondition
[17:39:33.402]             sys.calls <- base::sys.calls
[17:39:33.402]             `[[` <- base::`[[`
[17:39:33.402]             `+` <- base::`+`
[17:39:33.402]             `<<-` <- base::`<<-`
[17:39:33.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.402]                   3L)]
[17:39:33.402]             }
[17:39:33.402]             function(cond) {
[17:39:33.402]                 is_error <- inherits(cond, "error")
[17:39:33.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.402]                   NULL)
[17:39:33.402]                 if (is_error) {
[17:39:33.402]                   sessionInformation <- function() {
[17:39:33.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.402]                       search = base::search(), system = base::Sys.info())
[17:39:33.402]                   }
[17:39:33.402]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.402]                     cond$call), session = sessionInformation(), 
[17:39:33.402]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.402]                   signalCondition(cond)
[17:39:33.402]                 }
[17:39:33.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.402]                 "immediateCondition"))) {
[17:39:33.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.402]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.402]                   if (TRUE && !signal) {
[17:39:33.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.402]                     {
[17:39:33.402]                       inherits <- base::inherits
[17:39:33.402]                       invokeRestart <- base::invokeRestart
[17:39:33.402]                       is.null <- base::is.null
[17:39:33.402]                       muffled <- FALSE
[17:39:33.402]                       if (inherits(cond, "message")) {
[17:39:33.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.402]                         if (muffled) 
[17:39:33.402]                           invokeRestart("muffleMessage")
[17:39:33.402]                       }
[17:39:33.402]                       else if (inherits(cond, "warning")) {
[17:39:33.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.402]                         if (muffled) 
[17:39:33.402]                           invokeRestart("muffleWarning")
[17:39:33.402]                       }
[17:39:33.402]                       else if (inherits(cond, "condition")) {
[17:39:33.402]                         if (!is.null(pattern)) {
[17:39:33.402]                           computeRestarts <- base::computeRestarts
[17:39:33.402]                           grepl <- base::grepl
[17:39:33.402]                           restarts <- computeRestarts(cond)
[17:39:33.402]                           for (restart in restarts) {
[17:39:33.402]                             name <- restart$name
[17:39:33.402]                             if (is.null(name)) 
[17:39:33.402]                               next
[17:39:33.402]                             if (!grepl(pattern, name)) 
[17:39:33.402]                               next
[17:39:33.402]                             invokeRestart(restart)
[17:39:33.402]                             muffled <- TRUE
[17:39:33.402]                             break
[17:39:33.402]                           }
[17:39:33.402]                         }
[17:39:33.402]                       }
[17:39:33.402]                       invisible(muffled)
[17:39:33.402]                     }
[17:39:33.402]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.402]                   }
[17:39:33.402]                 }
[17:39:33.402]                 else {
[17:39:33.402]                   if (TRUE) {
[17:39:33.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.402]                     {
[17:39:33.402]                       inherits <- base::inherits
[17:39:33.402]                       invokeRestart <- base::invokeRestart
[17:39:33.402]                       is.null <- base::is.null
[17:39:33.402]                       muffled <- FALSE
[17:39:33.402]                       if (inherits(cond, "message")) {
[17:39:33.402]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.402]                         if (muffled) 
[17:39:33.402]                           invokeRestart("muffleMessage")
[17:39:33.402]                       }
[17:39:33.402]                       else if (inherits(cond, "warning")) {
[17:39:33.402]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.402]                         if (muffled) 
[17:39:33.402]                           invokeRestart("muffleWarning")
[17:39:33.402]                       }
[17:39:33.402]                       else if (inherits(cond, "condition")) {
[17:39:33.402]                         if (!is.null(pattern)) {
[17:39:33.402]                           computeRestarts <- base::computeRestarts
[17:39:33.402]                           grepl <- base::grepl
[17:39:33.402]                           restarts <- computeRestarts(cond)
[17:39:33.402]                           for (restart in restarts) {
[17:39:33.402]                             name <- restart$name
[17:39:33.402]                             if (is.null(name)) 
[17:39:33.402]                               next
[17:39:33.402]                             if (!grepl(pattern, name)) 
[17:39:33.402]                               next
[17:39:33.402]                             invokeRestart(restart)
[17:39:33.402]                             muffled <- TRUE
[17:39:33.402]                             break
[17:39:33.402]                           }
[17:39:33.402]                         }
[17:39:33.402]                       }
[17:39:33.402]                       invisible(muffled)
[17:39:33.402]                     }
[17:39:33.402]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.402]                   }
[17:39:33.402]                 }
[17:39:33.402]             }
[17:39:33.402]         }))
[17:39:33.402]     }, error = function(ex) {
[17:39:33.402]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.402]                 ...future.rng), started = ...future.startTime, 
[17:39:33.402]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.402]             version = "1.8"), class = "FutureResult")
[17:39:33.402]     }, finally = {
[17:39:33.402]         if (!identical(...future.workdir, getwd())) 
[17:39:33.402]             setwd(...future.workdir)
[17:39:33.402]         {
[17:39:33.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.402]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.402]             }
[17:39:33.402]             base::options(...future.oldOptions)
[17:39:33.402]             if (.Platform$OS.type == "windows") {
[17:39:33.402]                 old_names <- names(...future.oldEnvVars)
[17:39:33.402]                 envs <- base::Sys.getenv()
[17:39:33.402]                 names <- names(envs)
[17:39:33.402]                 common <- intersect(names, old_names)
[17:39:33.402]                 added <- setdiff(names, old_names)
[17:39:33.402]                 removed <- setdiff(old_names, names)
[17:39:33.402]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.402]                   envs[common]]
[17:39:33.402]                 NAMES <- toupper(changed)
[17:39:33.402]                 args <- list()
[17:39:33.402]                 for (kk in seq_along(NAMES)) {
[17:39:33.402]                   name <- changed[[kk]]
[17:39:33.402]                   NAME <- NAMES[[kk]]
[17:39:33.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.402]                     next
[17:39:33.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.402]                 }
[17:39:33.402]                 NAMES <- toupper(added)
[17:39:33.402]                 for (kk in seq_along(NAMES)) {
[17:39:33.402]                   name <- added[[kk]]
[17:39:33.402]                   NAME <- NAMES[[kk]]
[17:39:33.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.402]                     next
[17:39:33.402]                   args[[name]] <- ""
[17:39:33.402]                 }
[17:39:33.402]                 NAMES <- toupper(removed)
[17:39:33.402]                 for (kk in seq_along(NAMES)) {
[17:39:33.402]                   name <- removed[[kk]]
[17:39:33.402]                   NAME <- NAMES[[kk]]
[17:39:33.402]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.402]                     next
[17:39:33.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.402]                 }
[17:39:33.402]                 if (length(args) > 0) 
[17:39:33.402]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.402]             }
[17:39:33.402]             else {
[17:39:33.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.402]             }
[17:39:33.402]             {
[17:39:33.402]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.402]                   0L) {
[17:39:33.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.402]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.402]                   base::options(opts)
[17:39:33.402]                 }
[17:39:33.402]                 {
[17:39:33.402]                   {
[17:39:33.402]                     NULL
[17:39:33.402]                     RNGkind("Mersenne-Twister")
[17:39:33.402]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.402]                       inherits = FALSE)
[17:39:33.402]                   }
[17:39:33.402]                   options(future.plan = NULL)
[17:39:33.402]                   if (is.na(NA_character_)) 
[17:39:33.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.402]                     .init = FALSE)
[17:39:33.402]                 }
[17:39:33.402]             }
[17:39:33.402]         }
[17:39:33.402]     })
[17:39:33.402]     if (TRUE) {
[17:39:33.402]         base::sink(type = "output", split = FALSE)
[17:39:33.402]         if (TRUE) {
[17:39:33.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.402]         }
[17:39:33.402]         else {
[17:39:33.402]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.402]         }
[17:39:33.402]         base::close(...future.stdout)
[17:39:33.402]         ...future.stdout <- NULL
[17:39:33.402]     }
[17:39:33.402]     ...future.result$conditions <- ...future.conditions
[17:39:33.402]     ...future.result$finished <- base::Sys.time()
[17:39:33.402]     ...future.result
[17:39:33.402] }
[17:39:33.404] plan(): Setting new future strategy stack:
[17:39:33.404] List of future strategies:
[17:39:33.404] 1. sequential:
[17:39:33.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.404]    - tweaked: FALSE
[17:39:33.404]    - call: NULL
[17:39:33.404] plan(): nbrOfWorkers() = 1
[17:39:33.405] plan(): Setting new future strategy stack:
[17:39:33.405] List of future strategies:
[17:39:33.405] 1. sequential:
[17:39:33.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.405]    - tweaked: FALSE
[17:39:33.405]    - call: plan(strategy)
[17:39:33.406] plan(): nbrOfWorkers() = 1
[17:39:33.406] SequentialFuture started (and completed)
[17:39:33.406] - Launch lazy future ... done
[17:39:33.406] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adeeb9b850> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adee955378> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adeeb9b850> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adee955378> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:39:33.412] resolved() for ‘SequentialFuture’ ...
[17:39:33.413] - state: ‘finished’
[17:39:33.413] - run: TRUE
[17:39:33.413] - result: ‘FutureResult’
[17:39:33.413] resolved() for ‘SequentialFuture’ ... done
[17:39:33.413] resolved() for ‘SequentialFuture’ ...
[17:39:33.413] - state: ‘finished’
[17:39:33.413] - run: TRUE
[17:39:33.413] - result: ‘FutureResult’
[17:39:33.413] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:33.414] resolve() on list ...
[17:39:33.414]  recursive: 0
[17:39:33.415]  length: 6
[17:39:33.415]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:33.415] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.415] - nx: 6
[17:39:33.415] - relay: TRUE
[17:39:33.415] - stdout: TRUE
[17:39:33.415] - signal: TRUE
[17:39:33.415] - resignal: FALSE
[17:39:33.415] - force: TRUE
[17:39:33.415] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.416] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.416]  - until=2
[17:39:33.416]  - relaying element #2
[17:39:33.416] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.416] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.416] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.416]  length: 5 (resolved future 1)
[17:39:33.416] resolved() for ‘SequentialFuture’ ...
[17:39:33.416] - state: ‘finished’
[17:39:33.416] - run: TRUE
[17:39:33.417] - result: ‘FutureResult’
[17:39:33.417] resolved() for ‘SequentialFuture’ ... done
[17:39:33.417] Future #2
[17:39:33.417] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.417] - nx: 6
[17:39:33.417] - relay: TRUE
[17:39:33.417] - stdout: TRUE
[17:39:33.417] - signal: TRUE
[17:39:33.418] - resignal: FALSE
[17:39:33.418] - force: TRUE
[17:39:33.418] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.418] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.418]  - until=2
[17:39:33.418]  - relaying element #2
[17:39:33.418] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.418] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.418] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.419]  length: 4 (resolved future 2)
[17:39:33.419] resolved() for ‘SequentialFuture’ ...
[17:39:33.419] - state: ‘finished’
[17:39:33.419] - run: TRUE
[17:39:33.419] - result: ‘FutureResult’
[17:39:33.419] resolved() for ‘SequentialFuture’ ... done
[17:39:33.419] Future #3
[17:39:33.419] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.419] - nx: 6
[17:39:33.419] - relay: TRUE
[17:39:33.420] - stdout: TRUE
[17:39:33.420] - signal: TRUE
[17:39:33.420] - resignal: FALSE
[17:39:33.420] - force: TRUE
[17:39:33.420] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.420] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.420]  - until=3
[17:39:33.420]  - relaying element #3
[17:39:33.420] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.420] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.421] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.421]  length: 3 (resolved future 3)
[17:39:33.421] signalConditionsASAP(NULL, pos=4) ...
[17:39:33.421] - nx: 6
[17:39:33.421] - relay: TRUE
[17:39:33.421] - stdout: TRUE
[17:39:33.421] - signal: TRUE
[17:39:33.421] - resignal: FALSE
[17:39:33.421] - force: TRUE
[17:39:33.421] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.421] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.421]  - until=5
[17:39:33.422]  - relaying element #5
[17:39:33.422] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.422] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.422] signalConditionsASAP(NULL, pos=4) ... done
[17:39:33.422]  length: 2 (resolved future 4)
[17:39:33.422] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.422] - nx: 6
[17:39:33.422] - relay: TRUE
[17:39:33.422] - stdout: TRUE
[17:39:33.422] - signal: TRUE
[17:39:33.422] - resignal: FALSE
[17:39:33.422] - force: TRUE
[17:39:33.423] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.423] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.423]  - until=6
[17:39:33.423]  - relaying element #6
[17:39:33.423] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.423] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.423] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.423]  length: 1 (resolved future 5)
[17:39:33.423] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.423] - nx: 6
[17:39:33.423] - relay: TRUE
[17:39:33.426] - stdout: TRUE
[17:39:33.426] - signal: TRUE
[17:39:33.426] - resignal: FALSE
[17:39:33.426] - force: TRUE
[17:39:33.426] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.427] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.427]  - until=6
[17:39:33.427] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.427] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.427] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.427]  length: 0 (resolved future 6)
[17:39:33.427] Relaying remaining futures
[17:39:33.427] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.427] - nx: 6
[17:39:33.427] - relay: TRUE
[17:39:33.427] - stdout: TRUE
[17:39:33.427] - signal: TRUE
[17:39:33.428] - resignal: FALSE
[17:39:33.428] - force: TRUE
[17:39:33.428] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.428] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:33.428] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.428] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.428] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.428] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:39:33.430] getGlobalsAndPackages() ...
[17:39:33.431] Searching for globals...
[17:39:33.431] 
[17:39:33.431] Searching for globals ... DONE
[17:39:33.431] - globals: [0] <none>
[17:39:33.431] getGlobalsAndPackages() ... DONE
[17:39:33.431] run() for ‘Future’ ...
[17:39:33.431] - state: ‘created’
[17:39:33.432] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.432]   - Field: ‘label’
[17:39:33.432]   - Field: ‘local’
[17:39:33.432]   - Field: ‘owner’
[17:39:33.432]   - Field: ‘envir’
[17:39:33.432]   - Field: ‘packages’
[17:39:33.433]   - Field: ‘gc’
[17:39:33.433]   - Field: ‘conditions’
[17:39:33.433]   - Field: ‘expr’
[17:39:33.433]   - Field: ‘uuid’
[17:39:33.433]   - Field: ‘seed’
[17:39:33.433]   - Field: ‘version’
[17:39:33.433]   - Field: ‘result’
[17:39:33.433]   - Field: ‘asynchronous’
[17:39:33.433]   - Field: ‘calls’
[17:39:33.433]   - Field: ‘globals’
[17:39:33.433]   - Field: ‘stdout’
[17:39:33.434]   - Field: ‘earlySignal’
[17:39:33.434]   - Field: ‘lazy’
[17:39:33.434]   - Field: ‘state’
[17:39:33.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.434] - Launch lazy future ...
[17:39:33.434] Packages needed by the future expression (n = 0): <none>
[17:39:33.434] Packages needed by future strategies (n = 0): <none>
[17:39:33.435] {
[17:39:33.435]     {
[17:39:33.435]         {
[17:39:33.435]             ...future.startTime <- base::Sys.time()
[17:39:33.435]             {
[17:39:33.435]                 {
[17:39:33.435]                   {
[17:39:33.435]                     base::local({
[17:39:33.435]                       has_future <- base::requireNamespace("future", 
[17:39:33.435]                         quietly = TRUE)
[17:39:33.435]                       if (has_future) {
[17:39:33.435]                         ns <- base::getNamespace("future")
[17:39:33.435]                         version <- ns[[".package"]][["version"]]
[17:39:33.435]                         if (is.null(version)) 
[17:39:33.435]                           version <- utils::packageVersion("future")
[17:39:33.435]                       }
[17:39:33.435]                       else {
[17:39:33.435]                         version <- NULL
[17:39:33.435]                       }
[17:39:33.435]                       if (!has_future || version < "1.8.0") {
[17:39:33.435]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.435]                           "", base::R.version$version.string), 
[17:39:33.435]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.435]                             "release", "version")], collapse = " "), 
[17:39:33.435]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.435]                           info)
[17:39:33.435]                         info <- base::paste(info, collapse = "; ")
[17:39:33.435]                         if (!has_future) {
[17:39:33.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.435]                             info)
[17:39:33.435]                         }
[17:39:33.435]                         else {
[17:39:33.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.435]                             info, version)
[17:39:33.435]                         }
[17:39:33.435]                         base::stop(msg)
[17:39:33.435]                       }
[17:39:33.435]                     })
[17:39:33.435]                   }
[17:39:33.435]                   ...future.strategy.old <- future::plan("list")
[17:39:33.435]                   options(future.plan = NULL)
[17:39:33.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.435]                 }
[17:39:33.435]                 ...future.workdir <- getwd()
[17:39:33.435]             }
[17:39:33.435]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.435]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.435]         }
[17:39:33.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.435]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.435]             base::names(...future.oldOptions))
[17:39:33.435]     }
[17:39:33.435]     if (FALSE) {
[17:39:33.435]     }
[17:39:33.435]     else {
[17:39:33.435]         if (TRUE) {
[17:39:33.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.435]                 open = "w")
[17:39:33.435]         }
[17:39:33.435]         else {
[17:39:33.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.435]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.435]         }
[17:39:33.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.435]             base::sink(type = "output", split = FALSE)
[17:39:33.435]             base::close(...future.stdout)
[17:39:33.435]         }, add = TRUE)
[17:39:33.435]     }
[17:39:33.435]     ...future.frame <- base::sys.nframe()
[17:39:33.435]     ...future.conditions <- base::list()
[17:39:33.435]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.435]     if (FALSE) {
[17:39:33.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.435]     }
[17:39:33.435]     ...future.result <- base::tryCatch({
[17:39:33.435]         base::withCallingHandlers({
[17:39:33.435]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.435]             future::FutureResult(value = ...future.value$value, 
[17:39:33.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.435]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.435]                     ...future.globalenv.names))
[17:39:33.435]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.435]         }, condition = base::local({
[17:39:33.435]             c <- base::c
[17:39:33.435]             inherits <- base::inherits
[17:39:33.435]             invokeRestart <- base::invokeRestart
[17:39:33.435]             length <- base::length
[17:39:33.435]             list <- base::list
[17:39:33.435]             seq.int <- base::seq.int
[17:39:33.435]             signalCondition <- base::signalCondition
[17:39:33.435]             sys.calls <- base::sys.calls
[17:39:33.435]             `[[` <- base::`[[`
[17:39:33.435]             `+` <- base::`+`
[17:39:33.435]             `<<-` <- base::`<<-`
[17:39:33.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.435]                   3L)]
[17:39:33.435]             }
[17:39:33.435]             function(cond) {
[17:39:33.435]                 is_error <- inherits(cond, "error")
[17:39:33.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.435]                   NULL)
[17:39:33.435]                 if (is_error) {
[17:39:33.435]                   sessionInformation <- function() {
[17:39:33.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.435]                       search = base::search(), system = base::Sys.info())
[17:39:33.435]                   }
[17:39:33.435]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.435]                     cond$call), session = sessionInformation(), 
[17:39:33.435]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.435]                   signalCondition(cond)
[17:39:33.435]                 }
[17:39:33.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.435]                 "immediateCondition"))) {
[17:39:33.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.435]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.435]                   if (TRUE && !signal) {
[17:39:33.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.435]                     {
[17:39:33.435]                       inherits <- base::inherits
[17:39:33.435]                       invokeRestart <- base::invokeRestart
[17:39:33.435]                       is.null <- base::is.null
[17:39:33.435]                       muffled <- FALSE
[17:39:33.435]                       if (inherits(cond, "message")) {
[17:39:33.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.435]                         if (muffled) 
[17:39:33.435]                           invokeRestart("muffleMessage")
[17:39:33.435]                       }
[17:39:33.435]                       else if (inherits(cond, "warning")) {
[17:39:33.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.435]                         if (muffled) 
[17:39:33.435]                           invokeRestart("muffleWarning")
[17:39:33.435]                       }
[17:39:33.435]                       else if (inherits(cond, "condition")) {
[17:39:33.435]                         if (!is.null(pattern)) {
[17:39:33.435]                           computeRestarts <- base::computeRestarts
[17:39:33.435]                           grepl <- base::grepl
[17:39:33.435]                           restarts <- computeRestarts(cond)
[17:39:33.435]                           for (restart in restarts) {
[17:39:33.435]                             name <- restart$name
[17:39:33.435]                             if (is.null(name)) 
[17:39:33.435]                               next
[17:39:33.435]                             if (!grepl(pattern, name)) 
[17:39:33.435]                               next
[17:39:33.435]                             invokeRestart(restart)
[17:39:33.435]                             muffled <- TRUE
[17:39:33.435]                             break
[17:39:33.435]                           }
[17:39:33.435]                         }
[17:39:33.435]                       }
[17:39:33.435]                       invisible(muffled)
[17:39:33.435]                     }
[17:39:33.435]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.435]                   }
[17:39:33.435]                 }
[17:39:33.435]                 else {
[17:39:33.435]                   if (TRUE) {
[17:39:33.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.435]                     {
[17:39:33.435]                       inherits <- base::inherits
[17:39:33.435]                       invokeRestart <- base::invokeRestart
[17:39:33.435]                       is.null <- base::is.null
[17:39:33.435]                       muffled <- FALSE
[17:39:33.435]                       if (inherits(cond, "message")) {
[17:39:33.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.435]                         if (muffled) 
[17:39:33.435]                           invokeRestart("muffleMessage")
[17:39:33.435]                       }
[17:39:33.435]                       else if (inherits(cond, "warning")) {
[17:39:33.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.435]                         if (muffled) 
[17:39:33.435]                           invokeRestart("muffleWarning")
[17:39:33.435]                       }
[17:39:33.435]                       else if (inherits(cond, "condition")) {
[17:39:33.435]                         if (!is.null(pattern)) {
[17:39:33.435]                           computeRestarts <- base::computeRestarts
[17:39:33.435]                           grepl <- base::grepl
[17:39:33.435]                           restarts <- computeRestarts(cond)
[17:39:33.435]                           for (restart in restarts) {
[17:39:33.435]                             name <- restart$name
[17:39:33.435]                             if (is.null(name)) 
[17:39:33.435]                               next
[17:39:33.435]                             if (!grepl(pattern, name)) 
[17:39:33.435]                               next
[17:39:33.435]                             invokeRestart(restart)
[17:39:33.435]                             muffled <- TRUE
[17:39:33.435]                             break
[17:39:33.435]                           }
[17:39:33.435]                         }
[17:39:33.435]                       }
[17:39:33.435]                       invisible(muffled)
[17:39:33.435]                     }
[17:39:33.435]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.435]                   }
[17:39:33.435]                 }
[17:39:33.435]             }
[17:39:33.435]         }))
[17:39:33.435]     }, error = function(ex) {
[17:39:33.435]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.435]                 ...future.rng), started = ...future.startTime, 
[17:39:33.435]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.435]             version = "1.8"), class = "FutureResult")
[17:39:33.435]     }, finally = {
[17:39:33.435]         if (!identical(...future.workdir, getwd())) 
[17:39:33.435]             setwd(...future.workdir)
[17:39:33.435]         {
[17:39:33.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.435]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.435]             }
[17:39:33.435]             base::options(...future.oldOptions)
[17:39:33.435]             if (.Platform$OS.type == "windows") {
[17:39:33.435]                 old_names <- names(...future.oldEnvVars)
[17:39:33.435]                 envs <- base::Sys.getenv()
[17:39:33.435]                 names <- names(envs)
[17:39:33.435]                 common <- intersect(names, old_names)
[17:39:33.435]                 added <- setdiff(names, old_names)
[17:39:33.435]                 removed <- setdiff(old_names, names)
[17:39:33.435]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.435]                   envs[common]]
[17:39:33.435]                 NAMES <- toupper(changed)
[17:39:33.435]                 args <- list()
[17:39:33.435]                 for (kk in seq_along(NAMES)) {
[17:39:33.435]                   name <- changed[[kk]]
[17:39:33.435]                   NAME <- NAMES[[kk]]
[17:39:33.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.435]                     next
[17:39:33.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.435]                 }
[17:39:33.435]                 NAMES <- toupper(added)
[17:39:33.435]                 for (kk in seq_along(NAMES)) {
[17:39:33.435]                   name <- added[[kk]]
[17:39:33.435]                   NAME <- NAMES[[kk]]
[17:39:33.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.435]                     next
[17:39:33.435]                   args[[name]] <- ""
[17:39:33.435]                 }
[17:39:33.435]                 NAMES <- toupper(removed)
[17:39:33.435]                 for (kk in seq_along(NAMES)) {
[17:39:33.435]                   name <- removed[[kk]]
[17:39:33.435]                   NAME <- NAMES[[kk]]
[17:39:33.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.435]                     next
[17:39:33.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.435]                 }
[17:39:33.435]                 if (length(args) > 0) 
[17:39:33.435]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.435]             }
[17:39:33.435]             else {
[17:39:33.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.435]             }
[17:39:33.435]             {
[17:39:33.435]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.435]                   0L) {
[17:39:33.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.435]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.435]                   base::options(opts)
[17:39:33.435]                 }
[17:39:33.435]                 {
[17:39:33.435]                   {
[17:39:33.435]                     NULL
[17:39:33.435]                     RNGkind("Mersenne-Twister")
[17:39:33.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.435]                       inherits = FALSE)
[17:39:33.435]                   }
[17:39:33.435]                   options(future.plan = NULL)
[17:39:33.435]                   if (is.na(NA_character_)) 
[17:39:33.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.435]                     .init = FALSE)
[17:39:33.435]                 }
[17:39:33.435]             }
[17:39:33.435]         }
[17:39:33.435]     })
[17:39:33.435]     if (TRUE) {
[17:39:33.435]         base::sink(type = "output", split = FALSE)
[17:39:33.435]         if (TRUE) {
[17:39:33.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.435]         }
[17:39:33.435]         else {
[17:39:33.435]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.435]         }
[17:39:33.435]         base::close(...future.stdout)
[17:39:33.435]         ...future.stdout <- NULL
[17:39:33.435]     }
[17:39:33.435]     ...future.result$conditions <- ...future.conditions
[17:39:33.435]     ...future.result$finished <- base::Sys.time()
[17:39:33.435]     ...future.result
[17:39:33.435] }
[17:39:33.436] plan(): Setting new future strategy stack:
[17:39:33.436] List of future strategies:
[17:39:33.436] 1. sequential:
[17:39:33.436]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.436]    - tweaked: FALSE
[17:39:33.436]    - call: NULL
[17:39:33.437] plan(): nbrOfWorkers() = 1
[17:39:33.438] plan(): Setting new future strategy stack:
[17:39:33.438] List of future strategies:
[17:39:33.438] 1. sequential:
[17:39:33.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.438]    - tweaked: FALSE
[17:39:33.438]    - call: plan(strategy)
[17:39:33.438] plan(): nbrOfWorkers() = 1
[17:39:33.438] SequentialFuture started (and completed)
[17:39:33.438] - Launch lazy future ... done
[17:39:33.439] run() for ‘SequentialFuture’ ... done
[17:39:33.439] getGlobalsAndPackages() ...
[17:39:33.439] Searching for globals...
[17:39:33.439] 
[17:39:33.439] Searching for globals ... DONE
[17:39:33.439] - globals: [0] <none>
[17:39:33.439] getGlobalsAndPackages() ... DONE
[17:39:33.440] run() for ‘Future’ ...
[17:39:33.440] - state: ‘created’
[17:39:33.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.440] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.440]   - Field: ‘label’
[17:39:33.440]   - Field: ‘local’
[17:39:33.441]   - Field: ‘owner’
[17:39:33.441]   - Field: ‘envir’
[17:39:33.441]   - Field: ‘packages’
[17:39:33.441]   - Field: ‘gc’
[17:39:33.441]   - Field: ‘conditions’
[17:39:33.441]   - Field: ‘expr’
[17:39:33.441]   - Field: ‘uuid’
[17:39:33.441]   - Field: ‘seed’
[17:39:33.441]   - Field: ‘version’
[17:39:33.441]   - Field: ‘result’
[17:39:33.441]   - Field: ‘asynchronous’
[17:39:33.442]   - Field: ‘calls’
[17:39:33.442]   - Field: ‘globals’
[17:39:33.442]   - Field: ‘stdout’
[17:39:33.442]   - Field: ‘earlySignal’
[17:39:33.442]   - Field: ‘lazy’
[17:39:33.442]   - Field: ‘state’
[17:39:33.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.442] - Launch lazy future ...
[17:39:33.442] Packages needed by the future expression (n = 0): <none>
[17:39:33.442] Packages needed by future strategies (n = 0): <none>
[17:39:33.443] {
[17:39:33.443]     {
[17:39:33.443]         {
[17:39:33.443]             ...future.startTime <- base::Sys.time()
[17:39:33.443]             {
[17:39:33.443]                 {
[17:39:33.443]                   {
[17:39:33.443]                     base::local({
[17:39:33.443]                       has_future <- base::requireNamespace("future", 
[17:39:33.443]                         quietly = TRUE)
[17:39:33.443]                       if (has_future) {
[17:39:33.443]                         ns <- base::getNamespace("future")
[17:39:33.443]                         version <- ns[[".package"]][["version"]]
[17:39:33.443]                         if (is.null(version)) 
[17:39:33.443]                           version <- utils::packageVersion("future")
[17:39:33.443]                       }
[17:39:33.443]                       else {
[17:39:33.443]                         version <- NULL
[17:39:33.443]                       }
[17:39:33.443]                       if (!has_future || version < "1.8.0") {
[17:39:33.443]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.443]                           "", base::R.version$version.string), 
[17:39:33.443]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.443]                             "release", "version")], collapse = " "), 
[17:39:33.443]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.443]                           info)
[17:39:33.443]                         info <- base::paste(info, collapse = "; ")
[17:39:33.443]                         if (!has_future) {
[17:39:33.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.443]                             info)
[17:39:33.443]                         }
[17:39:33.443]                         else {
[17:39:33.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.443]                             info, version)
[17:39:33.443]                         }
[17:39:33.443]                         base::stop(msg)
[17:39:33.443]                       }
[17:39:33.443]                     })
[17:39:33.443]                   }
[17:39:33.443]                   ...future.strategy.old <- future::plan("list")
[17:39:33.443]                   options(future.plan = NULL)
[17:39:33.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.443]                 }
[17:39:33.443]                 ...future.workdir <- getwd()
[17:39:33.443]             }
[17:39:33.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.443]         }
[17:39:33.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.443]             base::names(...future.oldOptions))
[17:39:33.443]     }
[17:39:33.443]     if (FALSE) {
[17:39:33.443]     }
[17:39:33.443]     else {
[17:39:33.443]         if (TRUE) {
[17:39:33.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.443]                 open = "w")
[17:39:33.443]         }
[17:39:33.443]         else {
[17:39:33.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.443]         }
[17:39:33.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.443]             base::sink(type = "output", split = FALSE)
[17:39:33.443]             base::close(...future.stdout)
[17:39:33.443]         }, add = TRUE)
[17:39:33.443]     }
[17:39:33.443]     ...future.frame <- base::sys.nframe()
[17:39:33.443]     ...future.conditions <- base::list()
[17:39:33.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.443]     if (FALSE) {
[17:39:33.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.443]     }
[17:39:33.443]     ...future.result <- base::tryCatch({
[17:39:33.443]         base::withCallingHandlers({
[17:39:33.443]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.443]             future::FutureResult(value = ...future.value$value, 
[17:39:33.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.443]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.443]                     ...future.globalenv.names))
[17:39:33.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.443]         }, condition = base::local({
[17:39:33.443]             c <- base::c
[17:39:33.443]             inherits <- base::inherits
[17:39:33.443]             invokeRestart <- base::invokeRestart
[17:39:33.443]             length <- base::length
[17:39:33.443]             list <- base::list
[17:39:33.443]             seq.int <- base::seq.int
[17:39:33.443]             signalCondition <- base::signalCondition
[17:39:33.443]             sys.calls <- base::sys.calls
[17:39:33.443]             `[[` <- base::`[[`
[17:39:33.443]             `+` <- base::`+`
[17:39:33.443]             `<<-` <- base::`<<-`
[17:39:33.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.443]                   3L)]
[17:39:33.443]             }
[17:39:33.443]             function(cond) {
[17:39:33.443]                 is_error <- inherits(cond, "error")
[17:39:33.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.443]                   NULL)
[17:39:33.443]                 if (is_error) {
[17:39:33.443]                   sessionInformation <- function() {
[17:39:33.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.443]                       search = base::search(), system = base::Sys.info())
[17:39:33.443]                   }
[17:39:33.443]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.443]                     cond$call), session = sessionInformation(), 
[17:39:33.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.443]                   signalCondition(cond)
[17:39:33.443]                 }
[17:39:33.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.443]                 "immediateCondition"))) {
[17:39:33.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.443]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.443]                   if (TRUE && !signal) {
[17:39:33.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.443]                     {
[17:39:33.443]                       inherits <- base::inherits
[17:39:33.443]                       invokeRestart <- base::invokeRestart
[17:39:33.443]                       is.null <- base::is.null
[17:39:33.443]                       muffled <- FALSE
[17:39:33.443]                       if (inherits(cond, "message")) {
[17:39:33.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.443]                         if (muffled) 
[17:39:33.443]                           invokeRestart("muffleMessage")
[17:39:33.443]                       }
[17:39:33.443]                       else if (inherits(cond, "warning")) {
[17:39:33.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.443]                         if (muffled) 
[17:39:33.443]                           invokeRestart("muffleWarning")
[17:39:33.443]                       }
[17:39:33.443]                       else if (inherits(cond, "condition")) {
[17:39:33.443]                         if (!is.null(pattern)) {
[17:39:33.443]                           computeRestarts <- base::computeRestarts
[17:39:33.443]                           grepl <- base::grepl
[17:39:33.443]                           restarts <- computeRestarts(cond)
[17:39:33.443]                           for (restart in restarts) {
[17:39:33.443]                             name <- restart$name
[17:39:33.443]                             if (is.null(name)) 
[17:39:33.443]                               next
[17:39:33.443]                             if (!grepl(pattern, name)) 
[17:39:33.443]                               next
[17:39:33.443]                             invokeRestart(restart)
[17:39:33.443]                             muffled <- TRUE
[17:39:33.443]                             break
[17:39:33.443]                           }
[17:39:33.443]                         }
[17:39:33.443]                       }
[17:39:33.443]                       invisible(muffled)
[17:39:33.443]                     }
[17:39:33.443]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.443]                   }
[17:39:33.443]                 }
[17:39:33.443]                 else {
[17:39:33.443]                   if (TRUE) {
[17:39:33.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.443]                     {
[17:39:33.443]                       inherits <- base::inherits
[17:39:33.443]                       invokeRestart <- base::invokeRestart
[17:39:33.443]                       is.null <- base::is.null
[17:39:33.443]                       muffled <- FALSE
[17:39:33.443]                       if (inherits(cond, "message")) {
[17:39:33.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.443]                         if (muffled) 
[17:39:33.443]                           invokeRestart("muffleMessage")
[17:39:33.443]                       }
[17:39:33.443]                       else if (inherits(cond, "warning")) {
[17:39:33.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.443]                         if (muffled) 
[17:39:33.443]                           invokeRestart("muffleWarning")
[17:39:33.443]                       }
[17:39:33.443]                       else if (inherits(cond, "condition")) {
[17:39:33.443]                         if (!is.null(pattern)) {
[17:39:33.443]                           computeRestarts <- base::computeRestarts
[17:39:33.443]                           grepl <- base::grepl
[17:39:33.443]                           restarts <- computeRestarts(cond)
[17:39:33.443]                           for (restart in restarts) {
[17:39:33.443]                             name <- restart$name
[17:39:33.443]                             if (is.null(name)) 
[17:39:33.443]                               next
[17:39:33.443]                             if (!grepl(pattern, name)) 
[17:39:33.443]                               next
[17:39:33.443]                             invokeRestart(restart)
[17:39:33.443]                             muffled <- TRUE
[17:39:33.443]                             break
[17:39:33.443]                           }
[17:39:33.443]                         }
[17:39:33.443]                       }
[17:39:33.443]                       invisible(muffled)
[17:39:33.443]                     }
[17:39:33.443]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.443]                   }
[17:39:33.443]                 }
[17:39:33.443]             }
[17:39:33.443]         }))
[17:39:33.443]     }, error = function(ex) {
[17:39:33.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.443]                 ...future.rng), started = ...future.startTime, 
[17:39:33.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.443]             version = "1.8"), class = "FutureResult")
[17:39:33.443]     }, finally = {
[17:39:33.443]         if (!identical(...future.workdir, getwd())) 
[17:39:33.443]             setwd(...future.workdir)
[17:39:33.443]         {
[17:39:33.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.443]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.443]             }
[17:39:33.443]             base::options(...future.oldOptions)
[17:39:33.443]             if (.Platform$OS.type == "windows") {
[17:39:33.443]                 old_names <- names(...future.oldEnvVars)
[17:39:33.443]                 envs <- base::Sys.getenv()
[17:39:33.443]                 names <- names(envs)
[17:39:33.443]                 common <- intersect(names, old_names)
[17:39:33.443]                 added <- setdiff(names, old_names)
[17:39:33.443]                 removed <- setdiff(old_names, names)
[17:39:33.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.443]                   envs[common]]
[17:39:33.443]                 NAMES <- toupper(changed)
[17:39:33.443]                 args <- list()
[17:39:33.443]                 for (kk in seq_along(NAMES)) {
[17:39:33.443]                   name <- changed[[kk]]
[17:39:33.443]                   NAME <- NAMES[[kk]]
[17:39:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.443]                     next
[17:39:33.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.443]                 }
[17:39:33.443]                 NAMES <- toupper(added)
[17:39:33.443]                 for (kk in seq_along(NAMES)) {
[17:39:33.443]                   name <- added[[kk]]
[17:39:33.443]                   NAME <- NAMES[[kk]]
[17:39:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.443]                     next
[17:39:33.443]                   args[[name]] <- ""
[17:39:33.443]                 }
[17:39:33.443]                 NAMES <- toupper(removed)
[17:39:33.443]                 for (kk in seq_along(NAMES)) {
[17:39:33.443]                   name <- removed[[kk]]
[17:39:33.443]                   NAME <- NAMES[[kk]]
[17:39:33.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.443]                     next
[17:39:33.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.443]                 }
[17:39:33.443]                 if (length(args) > 0) 
[17:39:33.443]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.443]             }
[17:39:33.443]             else {
[17:39:33.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.443]             }
[17:39:33.443]             {
[17:39:33.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.443]                   0L) {
[17:39:33.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.443]                   base::options(opts)
[17:39:33.443]                 }
[17:39:33.443]                 {
[17:39:33.443]                   {
[17:39:33.443]                     NULL
[17:39:33.443]                     RNGkind("Mersenne-Twister")
[17:39:33.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.443]                       inherits = FALSE)
[17:39:33.443]                   }
[17:39:33.443]                   options(future.plan = NULL)
[17:39:33.443]                   if (is.na(NA_character_)) 
[17:39:33.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.443]                     .init = FALSE)
[17:39:33.443]                 }
[17:39:33.443]             }
[17:39:33.443]         }
[17:39:33.443]     })
[17:39:33.443]     if (TRUE) {
[17:39:33.443]         base::sink(type = "output", split = FALSE)
[17:39:33.443]         if (TRUE) {
[17:39:33.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.443]         }
[17:39:33.443]         else {
[17:39:33.443]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.443]         }
[17:39:33.443]         base::close(...future.stdout)
[17:39:33.443]         ...future.stdout <- NULL
[17:39:33.443]     }
[17:39:33.443]     ...future.result$conditions <- ...future.conditions
[17:39:33.443]     ...future.result$finished <- base::Sys.time()
[17:39:33.443]     ...future.result
[17:39:33.443] }
[17:39:33.445] plan(): Setting new future strategy stack:
[17:39:33.445] List of future strategies:
[17:39:33.445] 1. sequential:
[17:39:33.445]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.445]    - tweaked: FALSE
[17:39:33.445]    - call: NULL
[17:39:33.445] plan(): nbrOfWorkers() = 1
[17:39:33.446] plan(): Setting new future strategy stack:
[17:39:33.446] List of future strategies:
[17:39:33.446] 1. sequential:
[17:39:33.446]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.446]    - tweaked: FALSE
[17:39:33.446]    - call: plan(strategy)
[17:39:33.446] plan(): nbrOfWorkers() = 1
[17:39:33.447] SequentialFuture started (and completed)
[17:39:33.447] - Launch lazy future ... done
[17:39:33.447] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adedca32e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefc3e770> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adedca32e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefc3e770> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:33.452] resolved() for ‘SequentialFuture’ ...
[17:39:33.452] - state: ‘finished’
[17:39:33.452] - run: TRUE
[17:39:33.452] - result: ‘FutureResult’
[17:39:33.452] resolved() for ‘SequentialFuture’ ... done
[17:39:33.452] resolved() for ‘SequentialFuture’ ...
[17:39:33.452] - state: ‘finished’
[17:39:33.452] - run: TRUE
[17:39:33.452] - result: ‘FutureResult’
[17:39:33.452] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:33.454] resolve() on list ...
[17:39:33.454]  recursive: 0
[17:39:33.455]  length: 6
[17:39:33.455]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:33.455] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.455] - nx: 6
[17:39:33.455] - relay: TRUE
[17:39:33.455] - stdout: TRUE
[17:39:33.455] - signal: TRUE
[17:39:33.455] - resignal: FALSE
[17:39:33.455] - force: TRUE
[17:39:33.455] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.455] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.455]  - until=2
[17:39:33.456]  - relaying element #2
[17:39:33.456] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.456] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.456] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.456]  length: 5 (resolved future 1)
[17:39:33.456] resolved() for ‘SequentialFuture’ ...
[17:39:33.456] - state: ‘finished’
[17:39:33.456] - run: TRUE
[17:39:33.456] - result: ‘FutureResult’
[17:39:33.456] resolved() for ‘SequentialFuture’ ... done
[17:39:33.456] Future #2
[17:39:33.457] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.457] - nx: 6
[17:39:33.459] - relay: TRUE
[17:39:33.459] - stdout: TRUE
[17:39:33.459] - signal: TRUE
[17:39:33.459] - resignal: FALSE
[17:39:33.459] - force: TRUE
[17:39:33.459] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.459] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.459]  - until=2
[17:39:33.459]  - relaying element #2
[17:39:33.460] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.460] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.460] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.460]  length: 4 (resolved future 2)
[17:39:33.460] resolved() for ‘SequentialFuture’ ...
[17:39:33.460] - state: ‘finished’
[17:39:33.460] - run: TRUE
[17:39:33.460] - result: ‘FutureResult’
[17:39:33.460] resolved() for ‘SequentialFuture’ ... done
[17:39:33.460] Future #3
[17:39:33.461] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.461] - nx: 6
[17:39:33.461] - relay: TRUE
[17:39:33.461] - stdout: TRUE
[17:39:33.461] - signal: TRUE
[17:39:33.461] - resignal: FALSE
[17:39:33.461] - force: TRUE
[17:39:33.461] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.461] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.461]  - until=3
[17:39:33.461]  - relaying element #3
[17:39:33.462] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.462] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.462] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.462]  length: 3 (resolved future 3)
[17:39:33.462] signalConditionsASAP(NULL, pos=4) ...
[17:39:33.462] - nx: 6
[17:39:33.462] - relay: TRUE
[17:39:33.462] - stdout: TRUE
[17:39:33.462] - signal: TRUE
[17:39:33.462] - resignal: FALSE
[17:39:33.463] - force: TRUE
[17:39:33.463] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.463] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.463]  - until=5
[17:39:33.463]  - relaying element #5
[17:39:33.463] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.463] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.463] signalConditionsASAP(NULL, pos=4) ... done
[17:39:33.463]  length: 2 (resolved future 4)
[17:39:33.463] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.463] - nx: 6
[17:39:33.464] - relay: TRUE
[17:39:33.464] - stdout: TRUE
[17:39:33.464] - signal: TRUE
[17:39:33.464] - resignal: FALSE
[17:39:33.464] - force: TRUE
[17:39:33.464] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.464] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.464]  - until=6
[17:39:33.464]  - relaying element #6
[17:39:33.464] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.464] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.464] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.465]  length: 1 (resolved future 5)
[17:39:33.465] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.465] - nx: 6
[17:39:33.465] - relay: TRUE
[17:39:33.465] - stdout: TRUE
[17:39:33.465] - signal: TRUE
[17:39:33.465] - resignal: FALSE
[17:39:33.465] - force: TRUE
[17:39:33.465] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.465] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.465]  - until=6
[17:39:33.465] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.466] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.466] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.466]  length: 0 (resolved future 6)
[17:39:33.466] Relaying remaining futures
[17:39:33.466] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.466] - nx: 6
[17:39:33.466] - relay: TRUE
[17:39:33.466] - stdout: TRUE
[17:39:33.466] - signal: TRUE
[17:39:33.466] - resignal: FALSE
[17:39:33.466] - force: TRUE
[17:39:33.466] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.467] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:33.467] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.467] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.467] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.467] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:33.470] getGlobalsAndPackages() ...
[17:39:33.470] Searching for globals...
[17:39:33.471] 
[17:39:33.471] Searching for globals ... DONE
[17:39:33.471] - globals: [0] <none>
[17:39:33.471] getGlobalsAndPackages() ... DONE
[17:39:33.471] run() for ‘Future’ ...
[17:39:33.471] - state: ‘created’
[17:39:33.471] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.472]   - Field: ‘label’
[17:39:33.472]   - Field: ‘local’
[17:39:33.472]   - Field: ‘owner’
[17:39:33.472]   - Field: ‘envir’
[17:39:33.472]   - Field: ‘packages’
[17:39:33.472]   - Field: ‘gc’
[17:39:33.473]   - Field: ‘conditions’
[17:39:33.473]   - Field: ‘expr’
[17:39:33.473]   - Field: ‘uuid’
[17:39:33.473]   - Field: ‘seed’
[17:39:33.473]   - Field: ‘version’
[17:39:33.473]   - Field: ‘result’
[17:39:33.473]   - Field: ‘asynchronous’
[17:39:33.473]   - Field: ‘calls’
[17:39:33.473]   - Field: ‘globals’
[17:39:33.473]   - Field: ‘stdout’
[17:39:33.473]   - Field: ‘earlySignal’
[17:39:33.474]   - Field: ‘lazy’
[17:39:33.474]   - Field: ‘state’
[17:39:33.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.474] - Launch lazy future ...
[17:39:33.474] Packages needed by the future expression (n = 0): <none>
[17:39:33.474] Packages needed by future strategies (n = 0): <none>
[17:39:33.474] {
[17:39:33.474]     {
[17:39:33.474]         {
[17:39:33.474]             ...future.startTime <- base::Sys.time()
[17:39:33.474]             {
[17:39:33.474]                 {
[17:39:33.474]                   {
[17:39:33.474]                     base::local({
[17:39:33.474]                       has_future <- base::requireNamespace("future", 
[17:39:33.474]                         quietly = TRUE)
[17:39:33.474]                       if (has_future) {
[17:39:33.474]                         ns <- base::getNamespace("future")
[17:39:33.474]                         version <- ns[[".package"]][["version"]]
[17:39:33.474]                         if (is.null(version)) 
[17:39:33.474]                           version <- utils::packageVersion("future")
[17:39:33.474]                       }
[17:39:33.474]                       else {
[17:39:33.474]                         version <- NULL
[17:39:33.474]                       }
[17:39:33.474]                       if (!has_future || version < "1.8.0") {
[17:39:33.474]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.474]                           "", base::R.version$version.string), 
[17:39:33.474]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.474]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.474]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.474]                             "release", "version")], collapse = " "), 
[17:39:33.474]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.474]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.474]                           info)
[17:39:33.474]                         info <- base::paste(info, collapse = "; ")
[17:39:33.474]                         if (!has_future) {
[17:39:33.474]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.474]                             info)
[17:39:33.474]                         }
[17:39:33.474]                         else {
[17:39:33.474]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.474]                             info, version)
[17:39:33.474]                         }
[17:39:33.474]                         base::stop(msg)
[17:39:33.474]                       }
[17:39:33.474]                     })
[17:39:33.474]                   }
[17:39:33.474]                   ...future.strategy.old <- future::plan("list")
[17:39:33.474]                   options(future.plan = NULL)
[17:39:33.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.474]                 }
[17:39:33.474]                 ...future.workdir <- getwd()
[17:39:33.474]             }
[17:39:33.474]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.474]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.474]         }
[17:39:33.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.474]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.474]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.474]             base::names(...future.oldOptions))
[17:39:33.474]     }
[17:39:33.474]     if (FALSE) {
[17:39:33.474]     }
[17:39:33.474]     else {
[17:39:33.474]         if (TRUE) {
[17:39:33.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.474]                 open = "w")
[17:39:33.474]         }
[17:39:33.474]         else {
[17:39:33.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.474]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.474]         }
[17:39:33.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.474]             base::sink(type = "output", split = FALSE)
[17:39:33.474]             base::close(...future.stdout)
[17:39:33.474]         }, add = TRUE)
[17:39:33.474]     }
[17:39:33.474]     ...future.frame <- base::sys.nframe()
[17:39:33.474]     ...future.conditions <- base::list()
[17:39:33.474]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.474]     if (FALSE) {
[17:39:33.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.474]     }
[17:39:33.474]     ...future.result <- base::tryCatch({
[17:39:33.474]         base::withCallingHandlers({
[17:39:33.474]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.474]             future::FutureResult(value = ...future.value$value, 
[17:39:33.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.474]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.474]                     ...future.globalenv.names))
[17:39:33.474]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.474]         }, condition = base::local({
[17:39:33.474]             c <- base::c
[17:39:33.474]             inherits <- base::inherits
[17:39:33.474]             invokeRestart <- base::invokeRestart
[17:39:33.474]             length <- base::length
[17:39:33.474]             list <- base::list
[17:39:33.474]             seq.int <- base::seq.int
[17:39:33.474]             signalCondition <- base::signalCondition
[17:39:33.474]             sys.calls <- base::sys.calls
[17:39:33.474]             `[[` <- base::`[[`
[17:39:33.474]             `+` <- base::`+`
[17:39:33.474]             `<<-` <- base::`<<-`
[17:39:33.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.474]                   3L)]
[17:39:33.474]             }
[17:39:33.474]             function(cond) {
[17:39:33.474]                 is_error <- inherits(cond, "error")
[17:39:33.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.474]                   NULL)
[17:39:33.474]                 if (is_error) {
[17:39:33.474]                   sessionInformation <- function() {
[17:39:33.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.474]                       search = base::search(), system = base::Sys.info())
[17:39:33.474]                   }
[17:39:33.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.474]                     cond$call), session = sessionInformation(), 
[17:39:33.474]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.474]                   signalCondition(cond)
[17:39:33.474]                 }
[17:39:33.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.474]                 "immediateCondition"))) {
[17:39:33.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.474]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.474]                   if (TRUE && !signal) {
[17:39:33.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.474]                     {
[17:39:33.474]                       inherits <- base::inherits
[17:39:33.474]                       invokeRestart <- base::invokeRestart
[17:39:33.474]                       is.null <- base::is.null
[17:39:33.474]                       muffled <- FALSE
[17:39:33.474]                       if (inherits(cond, "message")) {
[17:39:33.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.474]                         if (muffled) 
[17:39:33.474]                           invokeRestart("muffleMessage")
[17:39:33.474]                       }
[17:39:33.474]                       else if (inherits(cond, "warning")) {
[17:39:33.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.474]                         if (muffled) 
[17:39:33.474]                           invokeRestart("muffleWarning")
[17:39:33.474]                       }
[17:39:33.474]                       else if (inherits(cond, "condition")) {
[17:39:33.474]                         if (!is.null(pattern)) {
[17:39:33.474]                           computeRestarts <- base::computeRestarts
[17:39:33.474]                           grepl <- base::grepl
[17:39:33.474]                           restarts <- computeRestarts(cond)
[17:39:33.474]                           for (restart in restarts) {
[17:39:33.474]                             name <- restart$name
[17:39:33.474]                             if (is.null(name)) 
[17:39:33.474]                               next
[17:39:33.474]                             if (!grepl(pattern, name)) 
[17:39:33.474]                               next
[17:39:33.474]                             invokeRestart(restart)
[17:39:33.474]                             muffled <- TRUE
[17:39:33.474]                             break
[17:39:33.474]                           }
[17:39:33.474]                         }
[17:39:33.474]                       }
[17:39:33.474]                       invisible(muffled)
[17:39:33.474]                     }
[17:39:33.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.474]                   }
[17:39:33.474]                 }
[17:39:33.474]                 else {
[17:39:33.474]                   if (TRUE) {
[17:39:33.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.474]                     {
[17:39:33.474]                       inherits <- base::inherits
[17:39:33.474]                       invokeRestart <- base::invokeRestart
[17:39:33.474]                       is.null <- base::is.null
[17:39:33.474]                       muffled <- FALSE
[17:39:33.474]                       if (inherits(cond, "message")) {
[17:39:33.474]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.474]                         if (muffled) 
[17:39:33.474]                           invokeRestart("muffleMessage")
[17:39:33.474]                       }
[17:39:33.474]                       else if (inherits(cond, "warning")) {
[17:39:33.474]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.474]                         if (muffled) 
[17:39:33.474]                           invokeRestart("muffleWarning")
[17:39:33.474]                       }
[17:39:33.474]                       else if (inherits(cond, "condition")) {
[17:39:33.474]                         if (!is.null(pattern)) {
[17:39:33.474]                           computeRestarts <- base::computeRestarts
[17:39:33.474]                           grepl <- base::grepl
[17:39:33.474]                           restarts <- computeRestarts(cond)
[17:39:33.474]                           for (restart in restarts) {
[17:39:33.474]                             name <- restart$name
[17:39:33.474]                             if (is.null(name)) 
[17:39:33.474]                               next
[17:39:33.474]                             if (!grepl(pattern, name)) 
[17:39:33.474]                               next
[17:39:33.474]                             invokeRestart(restart)
[17:39:33.474]                             muffled <- TRUE
[17:39:33.474]                             break
[17:39:33.474]                           }
[17:39:33.474]                         }
[17:39:33.474]                       }
[17:39:33.474]                       invisible(muffled)
[17:39:33.474]                     }
[17:39:33.474]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.474]                   }
[17:39:33.474]                 }
[17:39:33.474]             }
[17:39:33.474]         }))
[17:39:33.474]     }, error = function(ex) {
[17:39:33.474]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.474]                 ...future.rng), started = ...future.startTime, 
[17:39:33.474]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.474]             version = "1.8"), class = "FutureResult")
[17:39:33.474]     }, finally = {
[17:39:33.474]         if (!identical(...future.workdir, getwd())) 
[17:39:33.474]             setwd(...future.workdir)
[17:39:33.474]         {
[17:39:33.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.474]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.474]             }
[17:39:33.474]             base::options(...future.oldOptions)
[17:39:33.474]             if (.Platform$OS.type == "windows") {
[17:39:33.474]                 old_names <- names(...future.oldEnvVars)
[17:39:33.474]                 envs <- base::Sys.getenv()
[17:39:33.474]                 names <- names(envs)
[17:39:33.474]                 common <- intersect(names, old_names)
[17:39:33.474]                 added <- setdiff(names, old_names)
[17:39:33.474]                 removed <- setdiff(old_names, names)
[17:39:33.474]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.474]                   envs[common]]
[17:39:33.474]                 NAMES <- toupper(changed)
[17:39:33.474]                 args <- list()
[17:39:33.474]                 for (kk in seq_along(NAMES)) {
[17:39:33.474]                   name <- changed[[kk]]
[17:39:33.474]                   NAME <- NAMES[[kk]]
[17:39:33.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.474]                     next
[17:39:33.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.474]                 }
[17:39:33.474]                 NAMES <- toupper(added)
[17:39:33.474]                 for (kk in seq_along(NAMES)) {
[17:39:33.474]                   name <- added[[kk]]
[17:39:33.474]                   NAME <- NAMES[[kk]]
[17:39:33.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.474]                     next
[17:39:33.474]                   args[[name]] <- ""
[17:39:33.474]                 }
[17:39:33.474]                 NAMES <- toupper(removed)
[17:39:33.474]                 for (kk in seq_along(NAMES)) {
[17:39:33.474]                   name <- removed[[kk]]
[17:39:33.474]                   NAME <- NAMES[[kk]]
[17:39:33.474]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.474]                     next
[17:39:33.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.474]                 }
[17:39:33.474]                 if (length(args) > 0) 
[17:39:33.474]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.474]             }
[17:39:33.474]             else {
[17:39:33.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.474]             }
[17:39:33.474]             {
[17:39:33.474]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.474]                   0L) {
[17:39:33.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.474]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.474]                   base::options(opts)
[17:39:33.474]                 }
[17:39:33.474]                 {
[17:39:33.474]                   {
[17:39:33.474]                     NULL
[17:39:33.474]                     RNGkind("Mersenne-Twister")
[17:39:33.474]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.474]                       inherits = FALSE)
[17:39:33.474]                   }
[17:39:33.474]                   options(future.plan = NULL)
[17:39:33.474]                   if (is.na(NA_character_)) 
[17:39:33.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.474]                     .init = FALSE)
[17:39:33.474]                 }
[17:39:33.474]             }
[17:39:33.474]         }
[17:39:33.474]     })
[17:39:33.474]     if (TRUE) {
[17:39:33.474]         base::sink(type = "output", split = FALSE)
[17:39:33.474]         if (TRUE) {
[17:39:33.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.474]         }
[17:39:33.474]         else {
[17:39:33.474]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.474]         }
[17:39:33.474]         base::close(...future.stdout)
[17:39:33.474]         ...future.stdout <- NULL
[17:39:33.474]     }
[17:39:33.474]     ...future.result$conditions <- ...future.conditions
[17:39:33.474]     ...future.result$finished <- base::Sys.time()
[17:39:33.474]     ...future.result
[17:39:33.474] }
[17:39:33.476] plan(): Setting new future strategy stack:
[17:39:33.476] List of future strategies:
[17:39:33.476] 1. sequential:
[17:39:33.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.476]    - tweaked: FALSE
[17:39:33.476]    - call: NULL
[17:39:33.477] plan(): nbrOfWorkers() = 1
[17:39:33.478] plan(): Setting new future strategy stack:
[17:39:33.478] List of future strategies:
[17:39:33.478] 1. sequential:
[17:39:33.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.478]    - tweaked: FALSE
[17:39:33.478]    - call: plan(strategy)
[17:39:33.478] plan(): nbrOfWorkers() = 1
[17:39:33.478] SequentialFuture started (and completed)
[17:39:33.478] - Launch lazy future ... done
[17:39:33.478] run() for ‘SequentialFuture’ ... done
[17:39:33.479] getGlobalsAndPackages() ...
[17:39:33.479] Searching for globals...
[17:39:33.479] 
[17:39:33.479] Searching for globals ... DONE
[17:39:33.479] - globals: [0] <none>
[17:39:33.479] getGlobalsAndPackages() ... DONE
[17:39:33.479] run() for ‘Future’ ...
[17:39:33.480] - state: ‘created’
[17:39:33.480] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.480] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.480] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.480]   - Field: ‘label’
[17:39:33.480]   - Field: ‘local’
[17:39:33.480]   - Field: ‘owner’
[17:39:33.480]   - Field: ‘envir’
[17:39:33.480]   - Field: ‘packages’
[17:39:33.481]   - Field: ‘gc’
[17:39:33.481]   - Field: ‘conditions’
[17:39:33.481]   - Field: ‘expr’
[17:39:33.481]   - Field: ‘uuid’
[17:39:33.481]   - Field: ‘seed’
[17:39:33.481]   - Field: ‘version’
[17:39:33.481]   - Field: ‘result’
[17:39:33.481]   - Field: ‘asynchronous’
[17:39:33.481]   - Field: ‘calls’
[17:39:33.481]   - Field: ‘globals’
[17:39:33.481]   - Field: ‘stdout’
[17:39:33.482]   - Field: ‘earlySignal’
[17:39:33.482]   - Field: ‘lazy’
[17:39:33.482]   - Field: ‘state’
[17:39:33.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.482] - Launch lazy future ...
[17:39:33.482] Packages needed by the future expression (n = 0): <none>
[17:39:33.482] Packages needed by future strategies (n = 0): <none>
[17:39:33.483] {
[17:39:33.483]     {
[17:39:33.483]         {
[17:39:33.483]             ...future.startTime <- base::Sys.time()
[17:39:33.483]             {
[17:39:33.483]                 {
[17:39:33.483]                   {
[17:39:33.483]                     base::local({
[17:39:33.483]                       has_future <- base::requireNamespace("future", 
[17:39:33.483]                         quietly = TRUE)
[17:39:33.483]                       if (has_future) {
[17:39:33.483]                         ns <- base::getNamespace("future")
[17:39:33.483]                         version <- ns[[".package"]][["version"]]
[17:39:33.483]                         if (is.null(version)) 
[17:39:33.483]                           version <- utils::packageVersion("future")
[17:39:33.483]                       }
[17:39:33.483]                       else {
[17:39:33.483]                         version <- NULL
[17:39:33.483]                       }
[17:39:33.483]                       if (!has_future || version < "1.8.0") {
[17:39:33.483]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.483]                           "", base::R.version$version.string), 
[17:39:33.483]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.483]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.483]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.483]                             "release", "version")], collapse = " "), 
[17:39:33.483]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.483]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.483]                           info)
[17:39:33.483]                         info <- base::paste(info, collapse = "; ")
[17:39:33.483]                         if (!has_future) {
[17:39:33.483]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.483]                             info)
[17:39:33.483]                         }
[17:39:33.483]                         else {
[17:39:33.483]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.483]                             info, version)
[17:39:33.483]                         }
[17:39:33.483]                         base::stop(msg)
[17:39:33.483]                       }
[17:39:33.483]                     })
[17:39:33.483]                   }
[17:39:33.483]                   ...future.strategy.old <- future::plan("list")
[17:39:33.483]                   options(future.plan = NULL)
[17:39:33.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.483]                 }
[17:39:33.483]                 ...future.workdir <- getwd()
[17:39:33.483]             }
[17:39:33.483]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.483]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.483]         }
[17:39:33.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.483]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.483]             base::names(...future.oldOptions))
[17:39:33.483]     }
[17:39:33.483]     if (FALSE) {
[17:39:33.483]     }
[17:39:33.483]     else {
[17:39:33.483]         if (TRUE) {
[17:39:33.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.483]                 open = "w")
[17:39:33.483]         }
[17:39:33.483]         else {
[17:39:33.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.483]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.483]         }
[17:39:33.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.483]             base::sink(type = "output", split = FALSE)
[17:39:33.483]             base::close(...future.stdout)
[17:39:33.483]         }, add = TRUE)
[17:39:33.483]     }
[17:39:33.483]     ...future.frame <- base::sys.nframe()
[17:39:33.483]     ...future.conditions <- base::list()
[17:39:33.483]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.483]     if (FALSE) {
[17:39:33.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.483]     }
[17:39:33.483]     ...future.result <- base::tryCatch({
[17:39:33.483]         base::withCallingHandlers({
[17:39:33.483]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.483]             future::FutureResult(value = ...future.value$value, 
[17:39:33.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.483]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.483]                     ...future.globalenv.names))
[17:39:33.483]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.483]         }, condition = base::local({
[17:39:33.483]             c <- base::c
[17:39:33.483]             inherits <- base::inherits
[17:39:33.483]             invokeRestart <- base::invokeRestart
[17:39:33.483]             length <- base::length
[17:39:33.483]             list <- base::list
[17:39:33.483]             seq.int <- base::seq.int
[17:39:33.483]             signalCondition <- base::signalCondition
[17:39:33.483]             sys.calls <- base::sys.calls
[17:39:33.483]             `[[` <- base::`[[`
[17:39:33.483]             `+` <- base::`+`
[17:39:33.483]             `<<-` <- base::`<<-`
[17:39:33.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.483]                   3L)]
[17:39:33.483]             }
[17:39:33.483]             function(cond) {
[17:39:33.483]                 is_error <- inherits(cond, "error")
[17:39:33.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.483]                   NULL)
[17:39:33.483]                 if (is_error) {
[17:39:33.483]                   sessionInformation <- function() {
[17:39:33.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.483]                       search = base::search(), system = base::Sys.info())
[17:39:33.483]                   }
[17:39:33.483]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.483]                     cond$call), session = sessionInformation(), 
[17:39:33.483]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.483]                   signalCondition(cond)
[17:39:33.483]                 }
[17:39:33.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.483]                 "immediateCondition"))) {
[17:39:33.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.483]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.483]                   if (TRUE && !signal) {
[17:39:33.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.483]                     {
[17:39:33.483]                       inherits <- base::inherits
[17:39:33.483]                       invokeRestart <- base::invokeRestart
[17:39:33.483]                       is.null <- base::is.null
[17:39:33.483]                       muffled <- FALSE
[17:39:33.483]                       if (inherits(cond, "message")) {
[17:39:33.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.483]                         if (muffled) 
[17:39:33.483]                           invokeRestart("muffleMessage")
[17:39:33.483]                       }
[17:39:33.483]                       else if (inherits(cond, "warning")) {
[17:39:33.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.483]                         if (muffled) 
[17:39:33.483]                           invokeRestart("muffleWarning")
[17:39:33.483]                       }
[17:39:33.483]                       else if (inherits(cond, "condition")) {
[17:39:33.483]                         if (!is.null(pattern)) {
[17:39:33.483]                           computeRestarts <- base::computeRestarts
[17:39:33.483]                           grepl <- base::grepl
[17:39:33.483]                           restarts <- computeRestarts(cond)
[17:39:33.483]                           for (restart in restarts) {
[17:39:33.483]                             name <- restart$name
[17:39:33.483]                             if (is.null(name)) 
[17:39:33.483]                               next
[17:39:33.483]                             if (!grepl(pattern, name)) 
[17:39:33.483]                               next
[17:39:33.483]                             invokeRestart(restart)
[17:39:33.483]                             muffled <- TRUE
[17:39:33.483]                             break
[17:39:33.483]                           }
[17:39:33.483]                         }
[17:39:33.483]                       }
[17:39:33.483]                       invisible(muffled)
[17:39:33.483]                     }
[17:39:33.483]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.483]                   }
[17:39:33.483]                 }
[17:39:33.483]                 else {
[17:39:33.483]                   if (TRUE) {
[17:39:33.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.483]                     {
[17:39:33.483]                       inherits <- base::inherits
[17:39:33.483]                       invokeRestart <- base::invokeRestart
[17:39:33.483]                       is.null <- base::is.null
[17:39:33.483]                       muffled <- FALSE
[17:39:33.483]                       if (inherits(cond, "message")) {
[17:39:33.483]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.483]                         if (muffled) 
[17:39:33.483]                           invokeRestart("muffleMessage")
[17:39:33.483]                       }
[17:39:33.483]                       else if (inherits(cond, "warning")) {
[17:39:33.483]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.483]                         if (muffled) 
[17:39:33.483]                           invokeRestart("muffleWarning")
[17:39:33.483]                       }
[17:39:33.483]                       else if (inherits(cond, "condition")) {
[17:39:33.483]                         if (!is.null(pattern)) {
[17:39:33.483]                           computeRestarts <- base::computeRestarts
[17:39:33.483]                           grepl <- base::grepl
[17:39:33.483]                           restarts <- computeRestarts(cond)
[17:39:33.483]                           for (restart in restarts) {
[17:39:33.483]                             name <- restart$name
[17:39:33.483]                             if (is.null(name)) 
[17:39:33.483]                               next
[17:39:33.483]                             if (!grepl(pattern, name)) 
[17:39:33.483]                               next
[17:39:33.483]                             invokeRestart(restart)
[17:39:33.483]                             muffled <- TRUE
[17:39:33.483]                             break
[17:39:33.483]                           }
[17:39:33.483]                         }
[17:39:33.483]                       }
[17:39:33.483]                       invisible(muffled)
[17:39:33.483]                     }
[17:39:33.483]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.483]                   }
[17:39:33.483]                 }
[17:39:33.483]             }
[17:39:33.483]         }))
[17:39:33.483]     }, error = function(ex) {
[17:39:33.483]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.483]                 ...future.rng), started = ...future.startTime, 
[17:39:33.483]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.483]             version = "1.8"), class = "FutureResult")
[17:39:33.483]     }, finally = {
[17:39:33.483]         if (!identical(...future.workdir, getwd())) 
[17:39:33.483]             setwd(...future.workdir)
[17:39:33.483]         {
[17:39:33.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.483]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.483]             }
[17:39:33.483]             base::options(...future.oldOptions)
[17:39:33.483]             if (.Platform$OS.type == "windows") {
[17:39:33.483]                 old_names <- names(...future.oldEnvVars)
[17:39:33.483]                 envs <- base::Sys.getenv()
[17:39:33.483]                 names <- names(envs)
[17:39:33.483]                 common <- intersect(names, old_names)
[17:39:33.483]                 added <- setdiff(names, old_names)
[17:39:33.483]                 removed <- setdiff(old_names, names)
[17:39:33.483]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.483]                   envs[common]]
[17:39:33.483]                 NAMES <- toupper(changed)
[17:39:33.483]                 args <- list()
[17:39:33.483]                 for (kk in seq_along(NAMES)) {
[17:39:33.483]                   name <- changed[[kk]]
[17:39:33.483]                   NAME <- NAMES[[kk]]
[17:39:33.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.483]                     next
[17:39:33.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.483]                 }
[17:39:33.483]                 NAMES <- toupper(added)
[17:39:33.483]                 for (kk in seq_along(NAMES)) {
[17:39:33.483]                   name <- added[[kk]]
[17:39:33.483]                   NAME <- NAMES[[kk]]
[17:39:33.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.483]                     next
[17:39:33.483]                   args[[name]] <- ""
[17:39:33.483]                 }
[17:39:33.483]                 NAMES <- toupper(removed)
[17:39:33.483]                 for (kk in seq_along(NAMES)) {
[17:39:33.483]                   name <- removed[[kk]]
[17:39:33.483]                   NAME <- NAMES[[kk]]
[17:39:33.483]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.483]                     next
[17:39:33.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.483]                 }
[17:39:33.483]                 if (length(args) > 0) 
[17:39:33.483]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.483]             }
[17:39:33.483]             else {
[17:39:33.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.483]             }
[17:39:33.483]             {
[17:39:33.483]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.483]                   0L) {
[17:39:33.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.483]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.483]                   base::options(opts)
[17:39:33.483]                 }
[17:39:33.483]                 {
[17:39:33.483]                   {
[17:39:33.483]                     NULL
[17:39:33.483]                     RNGkind("Mersenne-Twister")
[17:39:33.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.483]                       inherits = FALSE)
[17:39:33.483]                   }
[17:39:33.483]                   options(future.plan = NULL)
[17:39:33.483]                   if (is.na(NA_character_)) 
[17:39:33.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.483]                     .init = FALSE)
[17:39:33.483]                 }
[17:39:33.483]             }
[17:39:33.483]         }
[17:39:33.483]     })
[17:39:33.483]     if (TRUE) {
[17:39:33.483]         base::sink(type = "output", split = FALSE)
[17:39:33.483]         if (TRUE) {
[17:39:33.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.483]         }
[17:39:33.483]         else {
[17:39:33.483]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.483]         }
[17:39:33.483]         base::close(...future.stdout)
[17:39:33.483]         ...future.stdout <- NULL
[17:39:33.483]     }
[17:39:33.483]     ...future.result$conditions <- ...future.conditions
[17:39:33.483]     ...future.result$finished <- base::Sys.time()
[17:39:33.483]     ...future.result
[17:39:33.483] }
[17:39:33.484] plan(): Setting new future strategy stack:
[17:39:33.485] List of future strategies:
[17:39:33.485] 1. sequential:
[17:39:33.485]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.485]    - tweaked: FALSE
[17:39:33.485]    - call: NULL
[17:39:33.485] plan(): nbrOfWorkers() = 1
[17:39:33.486] plan(): Setting new future strategy stack:
[17:39:33.486] List of future strategies:
[17:39:33.486] 1. sequential:
[17:39:33.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.486]    - tweaked: FALSE
[17:39:33.486]    - call: plan(strategy)
[17:39:33.486] plan(): nbrOfWorkers() = 1
[17:39:33.486] SequentialFuture started (and completed)
[17:39:33.487] - Launch lazy future ... done
[17:39:33.487] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefe2d550> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adf029a9e8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefe2d550> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adf029a9e8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:39:33.493] resolved() for ‘SequentialFuture’ ...
[17:39:33.493] - state: ‘finished’
[17:39:33.494] - run: TRUE
[17:39:33.494] - result: ‘FutureResult’
[17:39:33.494] resolved() for ‘SequentialFuture’ ... done
[17:39:33.494] resolved() for ‘SequentialFuture’ ...
[17:39:33.494] - state: ‘finished’
[17:39:33.494] - run: TRUE
[17:39:33.494] - result: ‘FutureResult’
[17:39:33.494] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:33.496] resolve() on list ...
[17:39:33.496]  recursive: 0
[17:39:33.496]  length: 6
[17:39:33.496]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:33.496] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.496] - nx: 6
[17:39:33.496] - relay: TRUE
[17:39:33.496] - stdout: TRUE
[17:39:33.497] - signal: TRUE
[17:39:33.497] - resignal: FALSE
[17:39:33.497] - force: TRUE
[17:39:33.497] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.497] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.497]  - until=2
[17:39:33.497]  - relaying element #2
[17:39:33.497] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.497] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.497] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.497]  length: 5 (resolved future 1)
[17:39:33.498] resolved() for ‘SequentialFuture’ ...
[17:39:33.498] - state: ‘finished’
[17:39:33.498] - run: TRUE
[17:39:33.498] - result: ‘FutureResult’
[17:39:33.498] resolved() for ‘SequentialFuture’ ... done
[17:39:33.498] Future #2
[17:39:33.498] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.498] - nx: 6
[17:39:33.498] - relay: TRUE
[17:39:33.498] - stdout: TRUE
[17:39:33.499] - signal: TRUE
[17:39:33.499] - resignal: FALSE
[17:39:33.499] - force: TRUE
[17:39:33.499] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.499] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.499]  - until=2
[17:39:33.499]  - relaying element #2
[17:39:33.499] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.499] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.499] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.500]  length: 4 (resolved future 2)
[17:39:33.500] resolved() for ‘SequentialFuture’ ...
[17:39:33.500] - state: ‘finished’
[17:39:33.500] - run: TRUE
[17:39:33.500] - result: ‘FutureResult’
[17:39:33.500] resolved() for ‘SequentialFuture’ ... done
[17:39:33.500] Future #3
[17:39:33.500] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.500] - nx: 6
[17:39:33.500] - relay: TRUE
[17:39:33.501] - stdout: TRUE
[17:39:33.501] - signal: TRUE
[17:39:33.501] - resignal: FALSE
[17:39:33.501] - force: TRUE
[17:39:33.501] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.501] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.501]  - until=3
[17:39:33.501]  - relaying element #3
[17:39:33.501] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.501] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.502]  length: 3 (resolved future 3)
[17:39:33.502] signalConditionsASAP(NULL, pos=4) ...
[17:39:33.502] - nx: 6
[17:39:33.502] - relay: TRUE
[17:39:33.502] - stdout: TRUE
[17:39:33.502] - signal: TRUE
[17:39:33.502] - resignal: FALSE
[17:39:33.502] - force: TRUE
[17:39:33.502] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.502]  - until=5
[17:39:33.503]  - relaying element #5
[17:39:33.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.503] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.503] signalConditionsASAP(NULL, pos=4) ... done
[17:39:33.503]  length: 2 (resolved future 4)
[17:39:33.503] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.503] - nx: 6
[17:39:33.503] - relay: TRUE
[17:39:33.503] - stdout: TRUE
[17:39:33.503] - signal: TRUE
[17:39:33.503] - resignal: FALSE
[17:39:33.503] - force: TRUE
[17:39:33.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.504] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.504]  - until=6
[17:39:33.504]  - relaying element #6
[17:39:33.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.504] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.504] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.504]  length: 1 (resolved future 5)
[17:39:33.504] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.504] - nx: 6
[17:39:33.504] - relay: TRUE
[17:39:33.505] - stdout: TRUE
[17:39:33.505] - signal: TRUE
[17:39:33.505] - resignal: FALSE
[17:39:33.505] - force: TRUE
[17:39:33.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.505] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.505]  - until=6
[17:39:33.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.505] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.505] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.505]  length: 0 (resolved future 6)
[17:39:33.505] Relaying remaining futures
[17:39:33.506] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.506] - nx: 6
[17:39:33.506] - relay: TRUE
[17:39:33.506] - stdout: TRUE
[17:39:33.506] - signal: TRUE
[17:39:33.506] - resignal: FALSE
[17:39:33.506] - force: TRUE
[17:39:33.506] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.506] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:33.506] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.506] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.507] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.507] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:33.510] getGlobalsAndPackages() ...
[17:39:33.510] Searching for globals...
[17:39:33.510] 
[17:39:33.510] Searching for globals ... DONE
[17:39:33.510] - globals: [0] <none>
[17:39:33.511] getGlobalsAndPackages() ... DONE
[17:39:33.511] run() for ‘Future’ ...
[17:39:33.511] - state: ‘created’
[17:39:33.511] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.511] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.511]   - Field: ‘label’
[17:39:33.512]   - Field: ‘local’
[17:39:33.512]   - Field: ‘owner’
[17:39:33.512]   - Field: ‘envir’
[17:39:33.512]   - Field: ‘packages’
[17:39:33.512]   - Field: ‘gc’
[17:39:33.512]   - Field: ‘conditions’
[17:39:33.512]   - Field: ‘expr’
[17:39:33.512]   - Field: ‘uuid’
[17:39:33.512]   - Field: ‘seed’
[17:39:33.512]   - Field: ‘version’
[17:39:33.512]   - Field: ‘result’
[17:39:33.513]   - Field: ‘asynchronous’
[17:39:33.513]   - Field: ‘calls’
[17:39:33.513]   - Field: ‘globals’
[17:39:33.513]   - Field: ‘stdout’
[17:39:33.513]   - Field: ‘earlySignal’
[17:39:33.513]   - Field: ‘lazy’
[17:39:33.513]   - Field: ‘state’
[17:39:33.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.513] - Launch lazy future ...
[17:39:33.513] Packages needed by the future expression (n = 0): <none>
[17:39:33.514] Packages needed by future strategies (n = 0): <none>
[17:39:33.514] {
[17:39:33.514]     {
[17:39:33.514]         {
[17:39:33.514]             ...future.startTime <- base::Sys.time()
[17:39:33.514]             {
[17:39:33.514]                 {
[17:39:33.514]                   {
[17:39:33.514]                     base::local({
[17:39:33.514]                       has_future <- base::requireNamespace("future", 
[17:39:33.514]                         quietly = TRUE)
[17:39:33.514]                       if (has_future) {
[17:39:33.514]                         ns <- base::getNamespace("future")
[17:39:33.514]                         version <- ns[[".package"]][["version"]]
[17:39:33.514]                         if (is.null(version)) 
[17:39:33.514]                           version <- utils::packageVersion("future")
[17:39:33.514]                       }
[17:39:33.514]                       else {
[17:39:33.514]                         version <- NULL
[17:39:33.514]                       }
[17:39:33.514]                       if (!has_future || version < "1.8.0") {
[17:39:33.514]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.514]                           "", base::R.version$version.string), 
[17:39:33.514]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.514]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.514]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.514]                             "release", "version")], collapse = " "), 
[17:39:33.514]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.514]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.514]                           info)
[17:39:33.514]                         info <- base::paste(info, collapse = "; ")
[17:39:33.514]                         if (!has_future) {
[17:39:33.514]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.514]                             info)
[17:39:33.514]                         }
[17:39:33.514]                         else {
[17:39:33.514]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.514]                             info, version)
[17:39:33.514]                         }
[17:39:33.514]                         base::stop(msg)
[17:39:33.514]                       }
[17:39:33.514]                     })
[17:39:33.514]                   }
[17:39:33.514]                   ...future.strategy.old <- future::plan("list")
[17:39:33.514]                   options(future.plan = NULL)
[17:39:33.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.514]                 }
[17:39:33.514]                 ...future.workdir <- getwd()
[17:39:33.514]             }
[17:39:33.514]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.514]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.514]         }
[17:39:33.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.514]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.514]             base::names(...future.oldOptions))
[17:39:33.514]     }
[17:39:33.514]     if (FALSE) {
[17:39:33.514]     }
[17:39:33.514]     else {
[17:39:33.514]         if (TRUE) {
[17:39:33.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.514]                 open = "w")
[17:39:33.514]         }
[17:39:33.514]         else {
[17:39:33.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.514]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.514]         }
[17:39:33.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.514]             base::sink(type = "output", split = FALSE)
[17:39:33.514]             base::close(...future.stdout)
[17:39:33.514]         }, add = TRUE)
[17:39:33.514]     }
[17:39:33.514]     ...future.frame <- base::sys.nframe()
[17:39:33.514]     ...future.conditions <- base::list()
[17:39:33.514]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.514]     if (FALSE) {
[17:39:33.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.514]     }
[17:39:33.514]     ...future.result <- base::tryCatch({
[17:39:33.514]         base::withCallingHandlers({
[17:39:33.514]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.514]             future::FutureResult(value = ...future.value$value, 
[17:39:33.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.514]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.514]                     ...future.globalenv.names))
[17:39:33.514]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.514]         }, condition = base::local({
[17:39:33.514]             c <- base::c
[17:39:33.514]             inherits <- base::inherits
[17:39:33.514]             invokeRestart <- base::invokeRestart
[17:39:33.514]             length <- base::length
[17:39:33.514]             list <- base::list
[17:39:33.514]             seq.int <- base::seq.int
[17:39:33.514]             signalCondition <- base::signalCondition
[17:39:33.514]             sys.calls <- base::sys.calls
[17:39:33.514]             `[[` <- base::`[[`
[17:39:33.514]             `+` <- base::`+`
[17:39:33.514]             `<<-` <- base::`<<-`
[17:39:33.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.514]                   3L)]
[17:39:33.514]             }
[17:39:33.514]             function(cond) {
[17:39:33.514]                 is_error <- inherits(cond, "error")
[17:39:33.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.514]                   NULL)
[17:39:33.514]                 if (is_error) {
[17:39:33.514]                   sessionInformation <- function() {
[17:39:33.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.514]                       search = base::search(), system = base::Sys.info())
[17:39:33.514]                   }
[17:39:33.514]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.514]                     cond$call), session = sessionInformation(), 
[17:39:33.514]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.514]                   signalCondition(cond)
[17:39:33.514]                 }
[17:39:33.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.514]                 "immediateCondition"))) {
[17:39:33.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.514]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.514]                   if (TRUE && !signal) {
[17:39:33.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.514]                     {
[17:39:33.514]                       inherits <- base::inherits
[17:39:33.514]                       invokeRestart <- base::invokeRestart
[17:39:33.514]                       is.null <- base::is.null
[17:39:33.514]                       muffled <- FALSE
[17:39:33.514]                       if (inherits(cond, "message")) {
[17:39:33.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.514]                         if (muffled) 
[17:39:33.514]                           invokeRestart("muffleMessage")
[17:39:33.514]                       }
[17:39:33.514]                       else if (inherits(cond, "warning")) {
[17:39:33.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.514]                         if (muffled) 
[17:39:33.514]                           invokeRestart("muffleWarning")
[17:39:33.514]                       }
[17:39:33.514]                       else if (inherits(cond, "condition")) {
[17:39:33.514]                         if (!is.null(pattern)) {
[17:39:33.514]                           computeRestarts <- base::computeRestarts
[17:39:33.514]                           grepl <- base::grepl
[17:39:33.514]                           restarts <- computeRestarts(cond)
[17:39:33.514]                           for (restart in restarts) {
[17:39:33.514]                             name <- restart$name
[17:39:33.514]                             if (is.null(name)) 
[17:39:33.514]                               next
[17:39:33.514]                             if (!grepl(pattern, name)) 
[17:39:33.514]                               next
[17:39:33.514]                             invokeRestart(restart)
[17:39:33.514]                             muffled <- TRUE
[17:39:33.514]                             break
[17:39:33.514]                           }
[17:39:33.514]                         }
[17:39:33.514]                       }
[17:39:33.514]                       invisible(muffled)
[17:39:33.514]                     }
[17:39:33.514]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.514]                   }
[17:39:33.514]                 }
[17:39:33.514]                 else {
[17:39:33.514]                   if (TRUE) {
[17:39:33.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.514]                     {
[17:39:33.514]                       inherits <- base::inherits
[17:39:33.514]                       invokeRestart <- base::invokeRestart
[17:39:33.514]                       is.null <- base::is.null
[17:39:33.514]                       muffled <- FALSE
[17:39:33.514]                       if (inherits(cond, "message")) {
[17:39:33.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.514]                         if (muffled) 
[17:39:33.514]                           invokeRestart("muffleMessage")
[17:39:33.514]                       }
[17:39:33.514]                       else if (inherits(cond, "warning")) {
[17:39:33.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.514]                         if (muffled) 
[17:39:33.514]                           invokeRestart("muffleWarning")
[17:39:33.514]                       }
[17:39:33.514]                       else if (inherits(cond, "condition")) {
[17:39:33.514]                         if (!is.null(pattern)) {
[17:39:33.514]                           computeRestarts <- base::computeRestarts
[17:39:33.514]                           grepl <- base::grepl
[17:39:33.514]                           restarts <- computeRestarts(cond)
[17:39:33.514]                           for (restart in restarts) {
[17:39:33.514]                             name <- restart$name
[17:39:33.514]                             if (is.null(name)) 
[17:39:33.514]                               next
[17:39:33.514]                             if (!grepl(pattern, name)) 
[17:39:33.514]                               next
[17:39:33.514]                             invokeRestart(restart)
[17:39:33.514]                             muffled <- TRUE
[17:39:33.514]                             break
[17:39:33.514]                           }
[17:39:33.514]                         }
[17:39:33.514]                       }
[17:39:33.514]                       invisible(muffled)
[17:39:33.514]                     }
[17:39:33.514]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.514]                   }
[17:39:33.514]                 }
[17:39:33.514]             }
[17:39:33.514]         }))
[17:39:33.514]     }, error = function(ex) {
[17:39:33.514]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.514]                 ...future.rng), started = ...future.startTime, 
[17:39:33.514]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.514]             version = "1.8"), class = "FutureResult")
[17:39:33.514]     }, finally = {
[17:39:33.514]         if (!identical(...future.workdir, getwd())) 
[17:39:33.514]             setwd(...future.workdir)
[17:39:33.514]         {
[17:39:33.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.514]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.514]             }
[17:39:33.514]             base::options(...future.oldOptions)
[17:39:33.514]             if (.Platform$OS.type == "windows") {
[17:39:33.514]                 old_names <- names(...future.oldEnvVars)
[17:39:33.514]                 envs <- base::Sys.getenv()
[17:39:33.514]                 names <- names(envs)
[17:39:33.514]                 common <- intersect(names, old_names)
[17:39:33.514]                 added <- setdiff(names, old_names)
[17:39:33.514]                 removed <- setdiff(old_names, names)
[17:39:33.514]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.514]                   envs[common]]
[17:39:33.514]                 NAMES <- toupper(changed)
[17:39:33.514]                 args <- list()
[17:39:33.514]                 for (kk in seq_along(NAMES)) {
[17:39:33.514]                   name <- changed[[kk]]
[17:39:33.514]                   NAME <- NAMES[[kk]]
[17:39:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.514]                     next
[17:39:33.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.514]                 }
[17:39:33.514]                 NAMES <- toupper(added)
[17:39:33.514]                 for (kk in seq_along(NAMES)) {
[17:39:33.514]                   name <- added[[kk]]
[17:39:33.514]                   NAME <- NAMES[[kk]]
[17:39:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.514]                     next
[17:39:33.514]                   args[[name]] <- ""
[17:39:33.514]                 }
[17:39:33.514]                 NAMES <- toupper(removed)
[17:39:33.514]                 for (kk in seq_along(NAMES)) {
[17:39:33.514]                   name <- removed[[kk]]
[17:39:33.514]                   NAME <- NAMES[[kk]]
[17:39:33.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.514]                     next
[17:39:33.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.514]                 }
[17:39:33.514]                 if (length(args) > 0) 
[17:39:33.514]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.514]             }
[17:39:33.514]             else {
[17:39:33.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.514]             }
[17:39:33.514]             {
[17:39:33.514]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.514]                   0L) {
[17:39:33.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.514]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.514]                   base::options(opts)
[17:39:33.514]                 }
[17:39:33.514]                 {
[17:39:33.514]                   {
[17:39:33.514]                     NULL
[17:39:33.514]                     RNGkind("Mersenne-Twister")
[17:39:33.514]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.514]                       inherits = FALSE)
[17:39:33.514]                   }
[17:39:33.514]                   options(future.plan = NULL)
[17:39:33.514]                   if (is.na(NA_character_)) 
[17:39:33.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.514]                     .init = FALSE)
[17:39:33.514]                 }
[17:39:33.514]             }
[17:39:33.514]         }
[17:39:33.514]     })
[17:39:33.514]     if (TRUE) {
[17:39:33.514]         base::sink(type = "output", split = FALSE)
[17:39:33.514]         if (TRUE) {
[17:39:33.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.514]         }
[17:39:33.514]         else {
[17:39:33.514]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.514]         }
[17:39:33.514]         base::close(...future.stdout)
[17:39:33.514]         ...future.stdout <- NULL
[17:39:33.514]     }
[17:39:33.514]     ...future.result$conditions <- ...future.conditions
[17:39:33.514]     ...future.result$finished <- base::Sys.time()
[17:39:33.514]     ...future.result
[17:39:33.514] }
[17:39:33.516] plan(): Setting new future strategy stack:
[17:39:33.516] List of future strategies:
[17:39:33.516] 1. sequential:
[17:39:33.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.516]    - tweaked: FALSE
[17:39:33.516]    - call: NULL
[17:39:33.516] plan(): nbrOfWorkers() = 1
[17:39:33.517] plan(): Setting new future strategy stack:
[17:39:33.517] List of future strategies:
[17:39:33.517] 1. sequential:
[17:39:33.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.517]    - tweaked: FALSE
[17:39:33.517]    - call: plan(strategy)
[17:39:33.518] plan(): nbrOfWorkers() = 1
[17:39:33.518] SequentialFuture started (and completed)
[17:39:33.518] - Launch lazy future ... done
[17:39:33.518] run() for ‘SequentialFuture’ ... done
[17:39:33.518] getGlobalsAndPackages() ...
[17:39:33.518] Searching for globals...
[17:39:33.519] 
[17:39:33.519] Searching for globals ... DONE
[17:39:33.519] - globals: [0] <none>
[17:39:33.520] getGlobalsAndPackages() ... DONE
[17:39:33.521] run() for ‘Future’ ...
[17:39:33.521] - state: ‘created’
[17:39:33.521] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.521] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.522]   - Field: ‘label’
[17:39:33.522]   - Field: ‘local’
[17:39:33.522]   - Field: ‘owner’
[17:39:33.522]   - Field: ‘envir’
[17:39:33.522]   - Field: ‘packages’
[17:39:33.522]   - Field: ‘gc’
[17:39:33.522]   - Field: ‘conditions’
[17:39:33.522]   - Field: ‘expr’
[17:39:33.522]   - Field: ‘uuid’
[17:39:33.522]   - Field: ‘seed’
[17:39:33.522]   - Field: ‘version’
[17:39:33.523]   - Field: ‘result’
[17:39:33.523]   - Field: ‘asynchronous’
[17:39:33.523]   - Field: ‘calls’
[17:39:33.523]   - Field: ‘globals’
[17:39:33.523]   - Field: ‘stdout’
[17:39:33.523]   - Field: ‘earlySignal’
[17:39:33.523]   - Field: ‘lazy’
[17:39:33.523]   - Field: ‘state’
[17:39:33.523] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.523] - Launch lazy future ...
[17:39:33.524] Packages needed by the future expression (n = 0): <none>
[17:39:33.524] Packages needed by future strategies (n = 0): <none>
[17:39:33.524] {
[17:39:33.524]     {
[17:39:33.524]         {
[17:39:33.524]             ...future.startTime <- base::Sys.time()
[17:39:33.524]             {
[17:39:33.524]                 {
[17:39:33.524]                   {
[17:39:33.524]                     base::local({
[17:39:33.524]                       has_future <- base::requireNamespace("future", 
[17:39:33.524]                         quietly = TRUE)
[17:39:33.524]                       if (has_future) {
[17:39:33.524]                         ns <- base::getNamespace("future")
[17:39:33.524]                         version <- ns[[".package"]][["version"]]
[17:39:33.524]                         if (is.null(version)) 
[17:39:33.524]                           version <- utils::packageVersion("future")
[17:39:33.524]                       }
[17:39:33.524]                       else {
[17:39:33.524]                         version <- NULL
[17:39:33.524]                       }
[17:39:33.524]                       if (!has_future || version < "1.8.0") {
[17:39:33.524]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.524]                           "", base::R.version$version.string), 
[17:39:33.524]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.524]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.524]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.524]                             "release", "version")], collapse = " "), 
[17:39:33.524]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.524]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.524]                           info)
[17:39:33.524]                         info <- base::paste(info, collapse = "; ")
[17:39:33.524]                         if (!has_future) {
[17:39:33.524]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.524]                             info)
[17:39:33.524]                         }
[17:39:33.524]                         else {
[17:39:33.524]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.524]                             info, version)
[17:39:33.524]                         }
[17:39:33.524]                         base::stop(msg)
[17:39:33.524]                       }
[17:39:33.524]                     })
[17:39:33.524]                   }
[17:39:33.524]                   ...future.strategy.old <- future::plan("list")
[17:39:33.524]                   options(future.plan = NULL)
[17:39:33.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.524]                 }
[17:39:33.524]                 ...future.workdir <- getwd()
[17:39:33.524]             }
[17:39:33.524]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.524]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.524]         }
[17:39:33.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.524]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.524]             base::names(...future.oldOptions))
[17:39:33.524]     }
[17:39:33.524]     if (FALSE) {
[17:39:33.524]     }
[17:39:33.524]     else {
[17:39:33.524]         if (TRUE) {
[17:39:33.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.524]                 open = "w")
[17:39:33.524]         }
[17:39:33.524]         else {
[17:39:33.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.524]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.524]         }
[17:39:33.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.524]             base::sink(type = "output", split = FALSE)
[17:39:33.524]             base::close(...future.stdout)
[17:39:33.524]         }, add = TRUE)
[17:39:33.524]     }
[17:39:33.524]     ...future.frame <- base::sys.nframe()
[17:39:33.524]     ...future.conditions <- base::list()
[17:39:33.524]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.524]     if (FALSE) {
[17:39:33.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.524]     }
[17:39:33.524]     ...future.result <- base::tryCatch({
[17:39:33.524]         base::withCallingHandlers({
[17:39:33.524]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.524]             future::FutureResult(value = ...future.value$value, 
[17:39:33.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.524]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.524]                     ...future.globalenv.names))
[17:39:33.524]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.524]         }, condition = base::local({
[17:39:33.524]             c <- base::c
[17:39:33.524]             inherits <- base::inherits
[17:39:33.524]             invokeRestart <- base::invokeRestart
[17:39:33.524]             length <- base::length
[17:39:33.524]             list <- base::list
[17:39:33.524]             seq.int <- base::seq.int
[17:39:33.524]             signalCondition <- base::signalCondition
[17:39:33.524]             sys.calls <- base::sys.calls
[17:39:33.524]             `[[` <- base::`[[`
[17:39:33.524]             `+` <- base::`+`
[17:39:33.524]             `<<-` <- base::`<<-`
[17:39:33.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.524]                   3L)]
[17:39:33.524]             }
[17:39:33.524]             function(cond) {
[17:39:33.524]                 is_error <- inherits(cond, "error")
[17:39:33.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.524]                   NULL)
[17:39:33.524]                 if (is_error) {
[17:39:33.524]                   sessionInformation <- function() {
[17:39:33.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.524]                       search = base::search(), system = base::Sys.info())
[17:39:33.524]                   }
[17:39:33.524]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.524]                     cond$call), session = sessionInformation(), 
[17:39:33.524]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.524]                   signalCondition(cond)
[17:39:33.524]                 }
[17:39:33.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.524]                 "immediateCondition"))) {
[17:39:33.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.524]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.524]                   if (TRUE && !signal) {
[17:39:33.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.524]                     {
[17:39:33.524]                       inherits <- base::inherits
[17:39:33.524]                       invokeRestart <- base::invokeRestart
[17:39:33.524]                       is.null <- base::is.null
[17:39:33.524]                       muffled <- FALSE
[17:39:33.524]                       if (inherits(cond, "message")) {
[17:39:33.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.524]                         if (muffled) 
[17:39:33.524]                           invokeRestart("muffleMessage")
[17:39:33.524]                       }
[17:39:33.524]                       else if (inherits(cond, "warning")) {
[17:39:33.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.524]                         if (muffled) 
[17:39:33.524]                           invokeRestart("muffleWarning")
[17:39:33.524]                       }
[17:39:33.524]                       else if (inherits(cond, "condition")) {
[17:39:33.524]                         if (!is.null(pattern)) {
[17:39:33.524]                           computeRestarts <- base::computeRestarts
[17:39:33.524]                           grepl <- base::grepl
[17:39:33.524]                           restarts <- computeRestarts(cond)
[17:39:33.524]                           for (restart in restarts) {
[17:39:33.524]                             name <- restart$name
[17:39:33.524]                             if (is.null(name)) 
[17:39:33.524]                               next
[17:39:33.524]                             if (!grepl(pattern, name)) 
[17:39:33.524]                               next
[17:39:33.524]                             invokeRestart(restart)
[17:39:33.524]                             muffled <- TRUE
[17:39:33.524]                             break
[17:39:33.524]                           }
[17:39:33.524]                         }
[17:39:33.524]                       }
[17:39:33.524]                       invisible(muffled)
[17:39:33.524]                     }
[17:39:33.524]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.524]                   }
[17:39:33.524]                 }
[17:39:33.524]                 else {
[17:39:33.524]                   if (TRUE) {
[17:39:33.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.524]                     {
[17:39:33.524]                       inherits <- base::inherits
[17:39:33.524]                       invokeRestart <- base::invokeRestart
[17:39:33.524]                       is.null <- base::is.null
[17:39:33.524]                       muffled <- FALSE
[17:39:33.524]                       if (inherits(cond, "message")) {
[17:39:33.524]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.524]                         if (muffled) 
[17:39:33.524]                           invokeRestart("muffleMessage")
[17:39:33.524]                       }
[17:39:33.524]                       else if (inherits(cond, "warning")) {
[17:39:33.524]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.524]                         if (muffled) 
[17:39:33.524]                           invokeRestart("muffleWarning")
[17:39:33.524]                       }
[17:39:33.524]                       else if (inherits(cond, "condition")) {
[17:39:33.524]                         if (!is.null(pattern)) {
[17:39:33.524]                           computeRestarts <- base::computeRestarts
[17:39:33.524]                           grepl <- base::grepl
[17:39:33.524]                           restarts <- computeRestarts(cond)
[17:39:33.524]                           for (restart in restarts) {
[17:39:33.524]                             name <- restart$name
[17:39:33.524]                             if (is.null(name)) 
[17:39:33.524]                               next
[17:39:33.524]                             if (!grepl(pattern, name)) 
[17:39:33.524]                               next
[17:39:33.524]                             invokeRestart(restart)
[17:39:33.524]                             muffled <- TRUE
[17:39:33.524]                             break
[17:39:33.524]                           }
[17:39:33.524]                         }
[17:39:33.524]                       }
[17:39:33.524]                       invisible(muffled)
[17:39:33.524]                     }
[17:39:33.524]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.524]                   }
[17:39:33.524]                 }
[17:39:33.524]             }
[17:39:33.524]         }))
[17:39:33.524]     }, error = function(ex) {
[17:39:33.524]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.524]                 ...future.rng), started = ...future.startTime, 
[17:39:33.524]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.524]             version = "1.8"), class = "FutureResult")
[17:39:33.524]     }, finally = {
[17:39:33.524]         if (!identical(...future.workdir, getwd())) 
[17:39:33.524]             setwd(...future.workdir)
[17:39:33.524]         {
[17:39:33.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.524]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.524]             }
[17:39:33.524]             base::options(...future.oldOptions)
[17:39:33.524]             if (.Platform$OS.type == "windows") {
[17:39:33.524]                 old_names <- names(...future.oldEnvVars)
[17:39:33.524]                 envs <- base::Sys.getenv()
[17:39:33.524]                 names <- names(envs)
[17:39:33.524]                 common <- intersect(names, old_names)
[17:39:33.524]                 added <- setdiff(names, old_names)
[17:39:33.524]                 removed <- setdiff(old_names, names)
[17:39:33.524]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.524]                   envs[common]]
[17:39:33.524]                 NAMES <- toupper(changed)
[17:39:33.524]                 args <- list()
[17:39:33.524]                 for (kk in seq_along(NAMES)) {
[17:39:33.524]                   name <- changed[[kk]]
[17:39:33.524]                   NAME <- NAMES[[kk]]
[17:39:33.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.524]                     next
[17:39:33.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.524]                 }
[17:39:33.524]                 NAMES <- toupper(added)
[17:39:33.524]                 for (kk in seq_along(NAMES)) {
[17:39:33.524]                   name <- added[[kk]]
[17:39:33.524]                   NAME <- NAMES[[kk]]
[17:39:33.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.524]                     next
[17:39:33.524]                   args[[name]] <- ""
[17:39:33.524]                 }
[17:39:33.524]                 NAMES <- toupper(removed)
[17:39:33.524]                 for (kk in seq_along(NAMES)) {
[17:39:33.524]                   name <- removed[[kk]]
[17:39:33.524]                   NAME <- NAMES[[kk]]
[17:39:33.524]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.524]                     next
[17:39:33.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.524]                 }
[17:39:33.524]                 if (length(args) > 0) 
[17:39:33.524]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.524]             }
[17:39:33.524]             else {
[17:39:33.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.524]             }
[17:39:33.524]             {
[17:39:33.524]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.524]                   0L) {
[17:39:33.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.524]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.524]                   base::options(opts)
[17:39:33.524]                 }
[17:39:33.524]                 {
[17:39:33.524]                   {
[17:39:33.524]                     NULL
[17:39:33.524]                     RNGkind("Mersenne-Twister")
[17:39:33.524]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.524]                       inherits = FALSE)
[17:39:33.524]                   }
[17:39:33.524]                   options(future.plan = NULL)
[17:39:33.524]                   if (is.na(NA_character_)) 
[17:39:33.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.524]                     .init = FALSE)
[17:39:33.524]                 }
[17:39:33.524]             }
[17:39:33.524]         }
[17:39:33.524]     })
[17:39:33.524]     if (TRUE) {
[17:39:33.524]         base::sink(type = "output", split = FALSE)
[17:39:33.524]         if (TRUE) {
[17:39:33.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.524]         }
[17:39:33.524]         else {
[17:39:33.524]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.524]         }
[17:39:33.524]         base::close(...future.stdout)
[17:39:33.524]         ...future.stdout <- NULL
[17:39:33.524]     }
[17:39:33.524]     ...future.result$conditions <- ...future.conditions
[17:39:33.524]     ...future.result$finished <- base::Sys.time()
[17:39:33.524]     ...future.result
[17:39:33.524] }
[17:39:33.526] plan(): Setting new future strategy stack:
[17:39:33.526] List of future strategies:
[17:39:33.526] 1. sequential:
[17:39:33.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.526]    - tweaked: FALSE
[17:39:33.526]    - call: NULL
[17:39:33.526] plan(): nbrOfWorkers() = 1
[17:39:33.527] plan(): Setting new future strategy stack:
[17:39:33.527] List of future strategies:
[17:39:33.527] 1. sequential:
[17:39:33.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.527]    - tweaked: FALSE
[17:39:33.527]    - call: plan(strategy)
[17:39:33.528] plan(): nbrOfWorkers() = 1
[17:39:33.528] SequentialFuture started (and completed)
[17:39:33.528] - Launch lazy future ... done
[17:39:33.528] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adf037ccc0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adef4f8050> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adf037ccc0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adef4f8050> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:33.533] resolved() for ‘SequentialFuture’ ...
[17:39:33.533] - state: ‘finished’
[17:39:33.533] - run: TRUE
[17:39:33.533] - result: ‘FutureResult’
[17:39:33.533] resolved() for ‘SequentialFuture’ ... done
[17:39:33.534] resolved() for ‘SequentialFuture’ ...
[17:39:33.534] - state: ‘finished’
[17:39:33.534] - run: TRUE
[17:39:33.534] - result: ‘FutureResult’
[17:39:33.534] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:33.536] resolve() on list ...
[17:39:33.536]  recursive: 0
[17:39:33.536]  length: 6
[17:39:33.536]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:33.536] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.536] - nx: 6
[17:39:33.536] - relay: TRUE
[17:39:33.536] - stdout: TRUE
[17:39:33.536] - signal: TRUE
[17:39:33.537] - resignal: FALSE
[17:39:33.537] - force: TRUE
[17:39:33.537] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.537] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.537]  - until=2
[17:39:33.537]  - relaying element #2
[17:39:33.537] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.537] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.537] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.537]  length: 5 (resolved future 1)
[17:39:33.537] resolved() for ‘SequentialFuture’ ...
[17:39:33.538] - state: ‘finished’
[17:39:33.538] - run: TRUE
[17:39:33.538] - result: ‘FutureResult’
[17:39:33.538] resolved() for ‘SequentialFuture’ ... done
[17:39:33.538] Future #2
[17:39:33.538] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.538] - nx: 6
[17:39:33.538] - relay: TRUE
[17:39:33.538] - stdout: TRUE
[17:39:33.538] - signal: TRUE
[17:39:33.539] - resignal: FALSE
[17:39:33.539] - force: TRUE
[17:39:33.539] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.539] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.539]  - until=2
[17:39:33.539]  - relaying element #2
[17:39:33.539] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.539] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.539] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.539]  length: 4 (resolved future 2)
[17:39:33.540] resolved() for ‘SequentialFuture’ ...
[17:39:33.540] - state: ‘finished’
[17:39:33.540] - run: TRUE
[17:39:33.540] - result: ‘FutureResult’
[17:39:33.540] resolved() for ‘SequentialFuture’ ... done
[17:39:33.540] Future #3
[17:39:33.540] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.540] - nx: 6
[17:39:33.540] - relay: TRUE
[17:39:33.540] - stdout: TRUE
[17:39:33.541] - signal: TRUE
[17:39:33.541] - resignal: FALSE
[17:39:33.541] - force: TRUE
[17:39:33.541] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.541] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.541]  - until=3
[17:39:33.541]  - relaying element #3
[17:39:33.541] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.541] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.541] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.542]  length: 3 (resolved future 3)
[17:39:33.542] signalConditionsASAP(NULL, pos=4) ...
[17:39:33.542] - nx: 6
[17:39:33.542] - relay: TRUE
[17:39:33.542] - stdout: TRUE
[17:39:33.542] - signal: TRUE
[17:39:33.542] - resignal: FALSE
[17:39:33.542] - force: TRUE
[17:39:33.542] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.542] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.542]  - until=5
[17:39:33.542]  - relaying element #5
[17:39:33.543] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.543] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.543] signalConditionsASAP(NULL, pos=4) ... done
[17:39:33.543]  length: 2 (resolved future 4)
[17:39:33.543] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.543] - nx: 6
[17:39:33.543] - relay: TRUE
[17:39:33.543] - stdout: TRUE
[17:39:33.543] - signal: TRUE
[17:39:33.543] - resignal: FALSE
[17:39:33.543] - force: TRUE
[17:39:33.544] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.544] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.544]  - until=6
[17:39:33.544]  - relaying element #6
[17:39:33.544] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.544] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.544] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.544]  length: 1 (resolved future 5)
[17:39:33.544] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.544] - nx: 6
[17:39:33.544] - relay: TRUE
[17:39:33.545] - stdout: TRUE
[17:39:33.545] - signal: TRUE
[17:39:33.545] - resignal: FALSE
[17:39:33.545] - force: TRUE
[17:39:33.545] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.545] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.545]  - until=6
[17:39:33.545] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.545] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.545] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.545]  length: 0 (resolved future 6)
[17:39:33.545] Relaying remaining futures
[17:39:33.546] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.546] - nx: 6
[17:39:33.546] - relay: TRUE
[17:39:33.546] - stdout: TRUE
[17:39:33.546] - signal: TRUE
[17:39:33.546] - resignal: FALSE
[17:39:33.546] - force: TRUE
[17:39:33.546] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.546] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:33.546] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.546] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.546] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.547] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:33.552] getGlobalsAndPackages() ...
[17:39:33.553] Searching for globals...
[17:39:33.553] 
[17:39:33.553] Searching for globals ... DONE
[17:39:33.553] - globals: [0] <none>
[17:39:33.553] getGlobalsAndPackages() ... DONE
[17:39:33.553] run() for ‘Future’ ...
[17:39:33.554] - state: ‘created’
[17:39:33.554] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.554]   - Field: ‘label’
[17:39:33.554]   - Field: ‘local’
[17:39:33.554]   - Field: ‘owner’
[17:39:33.554]   - Field: ‘envir’
[17:39:33.555]   - Field: ‘packages’
[17:39:33.555]   - Field: ‘gc’
[17:39:33.555]   - Field: ‘conditions’
[17:39:33.555]   - Field: ‘expr’
[17:39:33.555]   - Field: ‘uuid’
[17:39:33.555]   - Field: ‘seed’
[17:39:33.555]   - Field: ‘version’
[17:39:33.555]   - Field: ‘result’
[17:39:33.555]   - Field: ‘asynchronous’
[17:39:33.555]   - Field: ‘calls’
[17:39:33.555]   - Field: ‘globals’
[17:39:33.556]   - Field: ‘stdout’
[17:39:33.556]   - Field: ‘earlySignal’
[17:39:33.556]   - Field: ‘lazy’
[17:39:33.556]   - Field: ‘state’
[17:39:33.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.556] - Launch lazy future ...
[17:39:33.556] Packages needed by the future expression (n = 0): <none>
[17:39:33.556] Packages needed by future strategies (n = 0): <none>
[17:39:33.557] {
[17:39:33.557]     {
[17:39:33.557]         {
[17:39:33.557]             ...future.startTime <- base::Sys.time()
[17:39:33.557]             {
[17:39:33.557]                 {
[17:39:33.557]                   {
[17:39:33.557]                     base::local({
[17:39:33.557]                       has_future <- base::requireNamespace("future", 
[17:39:33.557]                         quietly = TRUE)
[17:39:33.557]                       if (has_future) {
[17:39:33.557]                         ns <- base::getNamespace("future")
[17:39:33.557]                         version <- ns[[".package"]][["version"]]
[17:39:33.557]                         if (is.null(version)) 
[17:39:33.557]                           version <- utils::packageVersion("future")
[17:39:33.557]                       }
[17:39:33.557]                       else {
[17:39:33.557]                         version <- NULL
[17:39:33.557]                       }
[17:39:33.557]                       if (!has_future || version < "1.8.0") {
[17:39:33.557]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.557]                           "", base::R.version$version.string), 
[17:39:33.557]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.557]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.557]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.557]                             "release", "version")], collapse = " "), 
[17:39:33.557]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.557]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.557]                           info)
[17:39:33.557]                         info <- base::paste(info, collapse = "; ")
[17:39:33.557]                         if (!has_future) {
[17:39:33.557]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.557]                             info)
[17:39:33.557]                         }
[17:39:33.557]                         else {
[17:39:33.557]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.557]                             info, version)
[17:39:33.557]                         }
[17:39:33.557]                         base::stop(msg)
[17:39:33.557]                       }
[17:39:33.557]                     })
[17:39:33.557]                   }
[17:39:33.557]                   ...future.strategy.old <- future::plan("list")
[17:39:33.557]                   options(future.plan = NULL)
[17:39:33.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.557]                 }
[17:39:33.557]                 ...future.workdir <- getwd()
[17:39:33.557]             }
[17:39:33.557]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.557]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.557]         }
[17:39:33.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.557]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.557]             base::names(...future.oldOptions))
[17:39:33.557]     }
[17:39:33.557]     if (FALSE) {
[17:39:33.557]     }
[17:39:33.557]     else {
[17:39:33.557]         if (TRUE) {
[17:39:33.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.557]                 open = "w")
[17:39:33.557]         }
[17:39:33.557]         else {
[17:39:33.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.557]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.557]         }
[17:39:33.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.557]             base::sink(type = "output", split = FALSE)
[17:39:33.557]             base::close(...future.stdout)
[17:39:33.557]         }, add = TRUE)
[17:39:33.557]     }
[17:39:33.557]     ...future.frame <- base::sys.nframe()
[17:39:33.557]     ...future.conditions <- base::list()
[17:39:33.557]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.557]     if (FALSE) {
[17:39:33.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.557]     }
[17:39:33.557]     ...future.result <- base::tryCatch({
[17:39:33.557]         base::withCallingHandlers({
[17:39:33.557]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.557]             future::FutureResult(value = ...future.value$value, 
[17:39:33.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.557]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.557]                     ...future.globalenv.names))
[17:39:33.557]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.557]         }, condition = base::local({
[17:39:33.557]             c <- base::c
[17:39:33.557]             inherits <- base::inherits
[17:39:33.557]             invokeRestart <- base::invokeRestart
[17:39:33.557]             length <- base::length
[17:39:33.557]             list <- base::list
[17:39:33.557]             seq.int <- base::seq.int
[17:39:33.557]             signalCondition <- base::signalCondition
[17:39:33.557]             sys.calls <- base::sys.calls
[17:39:33.557]             `[[` <- base::`[[`
[17:39:33.557]             `+` <- base::`+`
[17:39:33.557]             `<<-` <- base::`<<-`
[17:39:33.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.557]                   3L)]
[17:39:33.557]             }
[17:39:33.557]             function(cond) {
[17:39:33.557]                 is_error <- inherits(cond, "error")
[17:39:33.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.557]                   NULL)
[17:39:33.557]                 if (is_error) {
[17:39:33.557]                   sessionInformation <- function() {
[17:39:33.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.557]                       search = base::search(), system = base::Sys.info())
[17:39:33.557]                   }
[17:39:33.557]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.557]                     cond$call), session = sessionInformation(), 
[17:39:33.557]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.557]                   signalCondition(cond)
[17:39:33.557]                 }
[17:39:33.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.557]                 "immediateCondition"))) {
[17:39:33.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.557]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.557]                   if (TRUE && !signal) {
[17:39:33.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.557]                     {
[17:39:33.557]                       inherits <- base::inherits
[17:39:33.557]                       invokeRestart <- base::invokeRestart
[17:39:33.557]                       is.null <- base::is.null
[17:39:33.557]                       muffled <- FALSE
[17:39:33.557]                       if (inherits(cond, "message")) {
[17:39:33.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.557]                         if (muffled) 
[17:39:33.557]                           invokeRestart("muffleMessage")
[17:39:33.557]                       }
[17:39:33.557]                       else if (inherits(cond, "warning")) {
[17:39:33.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.557]                         if (muffled) 
[17:39:33.557]                           invokeRestart("muffleWarning")
[17:39:33.557]                       }
[17:39:33.557]                       else if (inherits(cond, "condition")) {
[17:39:33.557]                         if (!is.null(pattern)) {
[17:39:33.557]                           computeRestarts <- base::computeRestarts
[17:39:33.557]                           grepl <- base::grepl
[17:39:33.557]                           restarts <- computeRestarts(cond)
[17:39:33.557]                           for (restart in restarts) {
[17:39:33.557]                             name <- restart$name
[17:39:33.557]                             if (is.null(name)) 
[17:39:33.557]                               next
[17:39:33.557]                             if (!grepl(pattern, name)) 
[17:39:33.557]                               next
[17:39:33.557]                             invokeRestart(restart)
[17:39:33.557]                             muffled <- TRUE
[17:39:33.557]                             break
[17:39:33.557]                           }
[17:39:33.557]                         }
[17:39:33.557]                       }
[17:39:33.557]                       invisible(muffled)
[17:39:33.557]                     }
[17:39:33.557]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.557]                   }
[17:39:33.557]                 }
[17:39:33.557]                 else {
[17:39:33.557]                   if (TRUE) {
[17:39:33.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.557]                     {
[17:39:33.557]                       inherits <- base::inherits
[17:39:33.557]                       invokeRestart <- base::invokeRestart
[17:39:33.557]                       is.null <- base::is.null
[17:39:33.557]                       muffled <- FALSE
[17:39:33.557]                       if (inherits(cond, "message")) {
[17:39:33.557]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.557]                         if (muffled) 
[17:39:33.557]                           invokeRestart("muffleMessage")
[17:39:33.557]                       }
[17:39:33.557]                       else if (inherits(cond, "warning")) {
[17:39:33.557]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.557]                         if (muffled) 
[17:39:33.557]                           invokeRestart("muffleWarning")
[17:39:33.557]                       }
[17:39:33.557]                       else if (inherits(cond, "condition")) {
[17:39:33.557]                         if (!is.null(pattern)) {
[17:39:33.557]                           computeRestarts <- base::computeRestarts
[17:39:33.557]                           grepl <- base::grepl
[17:39:33.557]                           restarts <- computeRestarts(cond)
[17:39:33.557]                           for (restart in restarts) {
[17:39:33.557]                             name <- restart$name
[17:39:33.557]                             if (is.null(name)) 
[17:39:33.557]                               next
[17:39:33.557]                             if (!grepl(pattern, name)) 
[17:39:33.557]                               next
[17:39:33.557]                             invokeRestart(restart)
[17:39:33.557]                             muffled <- TRUE
[17:39:33.557]                             break
[17:39:33.557]                           }
[17:39:33.557]                         }
[17:39:33.557]                       }
[17:39:33.557]                       invisible(muffled)
[17:39:33.557]                     }
[17:39:33.557]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.557]                   }
[17:39:33.557]                 }
[17:39:33.557]             }
[17:39:33.557]         }))
[17:39:33.557]     }, error = function(ex) {
[17:39:33.557]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.557]                 ...future.rng), started = ...future.startTime, 
[17:39:33.557]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.557]             version = "1.8"), class = "FutureResult")
[17:39:33.557]     }, finally = {
[17:39:33.557]         if (!identical(...future.workdir, getwd())) 
[17:39:33.557]             setwd(...future.workdir)
[17:39:33.557]         {
[17:39:33.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.557]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.557]             }
[17:39:33.557]             base::options(...future.oldOptions)
[17:39:33.557]             if (.Platform$OS.type == "windows") {
[17:39:33.557]                 old_names <- names(...future.oldEnvVars)
[17:39:33.557]                 envs <- base::Sys.getenv()
[17:39:33.557]                 names <- names(envs)
[17:39:33.557]                 common <- intersect(names, old_names)
[17:39:33.557]                 added <- setdiff(names, old_names)
[17:39:33.557]                 removed <- setdiff(old_names, names)
[17:39:33.557]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.557]                   envs[common]]
[17:39:33.557]                 NAMES <- toupper(changed)
[17:39:33.557]                 args <- list()
[17:39:33.557]                 for (kk in seq_along(NAMES)) {
[17:39:33.557]                   name <- changed[[kk]]
[17:39:33.557]                   NAME <- NAMES[[kk]]
[17:39:33.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.557]                     next
[17:39:33.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.557]                 }
[17:39:33.557]                 NAMES <- toupper(added)
[17:39:33.557]                 for (kk in seq_along(NAMES)) {
[17:39:33.557]                   name <- added[[kk]]
[17:39:33.557]                   NAME <- NAMES[[kk]]
[17:39:33.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.557]                     next
[17:39:33.557]                   args[[name]] <- ""
[17:39:33.557]                 }
[17:39:33.557]                 NAMES <- toupper(removed)
[17:39:33.557]                 for (kk in seq_along(NAMES)) {
[17:39:33.557]                   name <- removed[[kk]]
[17:39:33.557]                   NAME <- NAMES[[kk]]
[17:39:33.557]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.557]                     next
[17:39:33.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.557]                 }
[17:39:33.557]                 if (length(args) > 0) 
[17:39:33.557]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.557]             }
[17:39:33.557]             else {
[17:39:33.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.557]             }
[17:39:33.557]             {
[17:39:33.557]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.557]                   0L) {
[17:39:33.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.557]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.557]                   base::options(opts)
[17:39:33.557]                 }
[17:39:33.557]                 {
[17:39:33.557]                   {
[17:39:33.557]                     NULL
[17:39:33.557]                     RNGkind("Mersenne-Twister")
[17:39:33.557]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.557]                       inherits = FALSE)
[17:39:33.557]                   }
[17:39:33.557]                   options(future.plan = NULL)
[17:39:33.557]                   if (is.na(NA_character_)) 
[17:39:33.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.557]                     .init = FALSE)
[17:39:33.557]                 }
[17:39:33.557]             }
[17:39:33.557]         }
[17:39:33.557]     })
[17:39:33.557]     if (TRUE) {
[17:39:33.557]         base::sink(type = "output", split = FALSE)
[17:39:33.557]         if (TRUE) {
[17:39:33.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.557]         }
[17:39:33.557]         else {
[17:39:33.557]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.557]         }
[17:39:33.557]         base::close(...future.stdout)
[17:39:33.557]         ...future.stdout <- NULL
[17:39:33.557]     }
[17:39:33.557]     ...future.result$conditions <- ...future.conditions
[17:39:33.557]     ...future.result$finished <- base::Sys.time()
[17:39:33.557]     ...future.result
[17:39:33.557] }
[17:39:33.559] plan(): Setting new future strategy stack:
[17:39:33.559] List of future strategies:
[17:39:33.559] 1. sequential:
[17:39:33.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.559]    - tweaked: FALSE
[17:39:33.559]    - call: NULL
[17:39:33.559] plan(): nbrOfWorkers() = 1
[17:39:33.560] plan(): Setting new future strategy stack:
[17:39:33.560] List of future strategies:
[17:39:33.560] 1. sequential:
[17:39:33.560]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.560]    - tweaked: FALSE
[17:39:33.560]    - call: plan(strategy)
[17:39:33.561] plan(): nbrOfWorkers() = 1
[17:39:33.561] SequentialFuture started (and completed)
[17:39:33.561] - Launch lazy future ... done
[17:39:33.561] run() for ‘SequentialFuture’ ... done
[17:39:33.561] getGlobalsAndPackages() ...
[17:39:33.561] Searching for globals...
[17:39:33.562] 
[17:39:33.562] Searching for globals ... DONE
[17:39:33.562] - globals: [0] <none>
[17:39:33.562] getGlobalsAndPackages() ... DONE
[17:39:33.562] run() for ‘Future’ ...
[17:39:33.562] - state: ‘created’
[17:39:33.562] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.563]   - Field: ‘label’
[17:39:33.563]   - Field: ‘local’
[17:39:33.563]   - Field: ‘owner’
[17:39:33.563]   - Field: ‘envir’
[17:39:33.563]   - Field: ‘packages’
[17:39:33.563]   - Field: ‘gc’
[17:39:33.563]   - Field: ‘conditions’
[17:39:33.563]   - Field: ‘expr’
[17:39:33.563]   - Field: ‘uuid’
[17:39:33.564]   - Field: ‘seed’
[17:39:33.564]   - Field: ‘version’
[17:39:33.564]   - Field: ‘result’
[17:39:33.564]   - Field: ‘asynchronous’
[17:39:33.564]   - Field: ‘calls’
[17:39:33.564]   - Field: ‘globals’
[17:39:33.564]   - Field: ‘stdout’
[17:39:33.564]   - Field: ‘earlySignal’
[17:39:33.564]   - Field: ‘lazy’
[17:39:33.564]   - Field: ‘state’
[17:39:33.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.565] - Launch lazy future ...
[17:39:33.565] Packages needed by the future expression (n = 0): <none>
[17:39:33.565] Packages needed by future strategies (n = 0): <none>
[17:39:33.565] {
[17:39:33.565]     {
[17:39:33.565]         {
[17:39:33.565]             ...future.startTime <- base::Sys.time()
[17:39:33.565]             {
[17:39:33.565]                 {
[17:39:33.565]                   {
[17:39:33.565]                     base::local({
[17:39:33.565]                       has_future <- base::requireNamespace("future", 
[17:39:33.565]                         quietly = TRUE)
[17:39:33.565]                       if (has_future) {
[17:39:33.565]                         ns <- base::getNamespace("future")
[17:39:33.565]                         version <- ns[[".package"]][["version"]]
[17:39:33.565]                         if (is.null(version)) 
[17:39:33.565]                           version <- utils::packageVersion("future")
[17:39:33.565]                       }
[17:39:33.565]                       else {
[17:39:33.565]                         version <- NULL
[17:39:33.565]                       }
[17:39:33.565]                       if (!has_future || version < "1.8.0") {
[17:39:33.565]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.565]                           "", base::R.version$version.string), 
[17:39:33.565]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.565]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.565]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.565]                             "release", "version")], collapse = " "), 
[17:39:33.565]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.565]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.565]                           info)
[17:39:33.565]                         info <- base::paste(info, collapse = "; ")
[17:39:33.565]                         if (!has_future) {
[17:39:33.565]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.565]                             info)
[17:39:33.565]                         }
[17:39:33.565]                         else {
[17:39:33.565]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.565]                             info, version)
[17:39:33.565]                         }
[17:39:33.565]                         base::stop(msg)
[17:39:33.565]                       }
[17:39:33.565]                     })
[17:39:33.565]                   }
[17:39:33.565]                   ...future.strategy.old <- future::plan("list")
[17:39:33.565]                   options(future.plan = NULL)
[17:39:33.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.565]                 }
[17:39:33.565]                 ...future.workdir <- getwd()
[17:39:33.565]             }
[17:39:33.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.565]         }
[17:39:33.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.565]             base::names(...future.oldOptions))
[17:39:33.565]     }
[17:39:33.565]     if (FALSE) {
[17:39:33.565]     }
[17:39:33.565]     else {
[17:39:33.565]         if (TRUE) {
[17:39:33.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.565]                 open = "w")
[17:39:33.565]         }
[17:39:33.565]         else {
[17:39:33.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.565]         }
[17:39:33.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.565]             base::sink(type = "output", split = FALSE)
[17:39:33.565]             base::close(...future.stdout)
[17:39:33.565]         }, add = TRUE)
[17:39:33.565]     }
[17:39:33.565]     ...future.frame <- base::sys.nframe()
[17:39:33.565]     ...future.conditions <- base::list()
[17:39:33.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.565]     if (FALSE) {
[17:39:33.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.565]     }
[17:39:33.565]     ...future.result <- base::tryCatch({
[17:39:33.565]         base::withCallingHandlers({
[17:39:33.565]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.565]             future::FutureResult(value = ...future.value$value, 
[17:39:33.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.565]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.565]                     ...future.globalenv.names))
[17:39:33.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.565]         }, condition = base::local({
[17:39:33.565]             c <- base::c
[17:39:33.565]             inherits <- base::inherits
[17:39:33.565]             invokeRestart <- base::invokeRestart
[17:39:33.565]             length <- base::length
[17:39:33.565]             list <- base::list
[17:39:33.565]             seq.int <- base::seq.int
[17:39:33.565]             signalCondition <- base::signalCondition
[17:39:33.565]             sys.calls <- base::sys.calls
[17:39:33.565]             `[[` <- base::`[[`
[17:39:33.565]             `+` <- base::`+`
[17:39:33.565]             `<<-` <- base::`<<-`
[17:39:33.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.565]                   3L)]
[17:39:33.565]             }
[17:39:33.565]             function(cond) {
[17:39:33.565]                 is_error <- inherits(cond, "error")
[17:39:33.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.565]                   NULL)
[17:39:33.565]                 if (is_error) {
[17:39:33.565]                   sessionInformation <- function() {
[17:39:33.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.565]                       search = base::search(), system = base::Sys.info())
[17:39:33.565]                   }
[17:39:33.565]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.565]                     cond$call), session = sessionInformation(), 
[17:39:33.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.565]                   signalCondition(cond)
[17:39:33.565]                 }
[17:39:33.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.565]                 "immediateCondition"))) {
[17:39:33.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.565]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.565]                   if (TRUE && !signal) {
[17:39:33.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.565]                     {
[17:39:33.565]                       inherits <- base::inherits
[17:39:33.565]                       invokeRestart <- base::invokeRestart
[17:39:33.565]                       is.null <- base::is.null
[17:39:33.565]                       muffled <- FALSE
[17:39:33.565]                       if (inherits(cond, "message")) {
[17:39:33.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.565]                         if (muffled) 
[17:39:33.565]                           invokeRestart("muffleMessage")
[17:39:33.565]                       }
[17:39:33.565]                       else if (inherits(cond, "warning")) {
[17:39:33.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.565]                         if (muffled) 
[17:39:33.565]                           invokeRestart("muffleWarning")
[17:39:33.565]                       }
[17:39:33.565]                       else if (inherits(cond, "condition")) {
[17:39:33.565]                         if (!is.null(pattern)) {
[17:39:33.565]                           computeRestarts <- base::computeRestarts
[17:39:33.565]                           grepl <- base::grepl
[17:39:33.565]                           restarts <- computeRestarts(cond)
[17:39:33.565]                           for (restart in restarts) {
[17:39:33.565]                             name <- restart$name
[17:39:33.565]                             if (is.null(name)) 
[17:39:33.565]                               next
[17:39:33.565]                             if (!grepl(pattern, name)) 
[17:39:33.565]                               next
[17:39:33.565]                             invokeRestart(restart)
[17:39:33.565]                             muffled <- TRUE
[17:39:33.565]                             break
[17:39:33.565]                           }
[17:39:33.565]                         }
[17:39:33.565]                       }
[17:39:33.565]                       invisible(muffled)
[17:39:33.565]                     }
[17:39:33.565]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.565]                   }
[17:39:33.565]                 }
[17:39:33.565]                 else {
[17:39:33.565]                   if (TRUE) {
[17:39:33.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.565]                     {
[17:39:33.565]                       inherits <- base::inherits
[17:39:33.565]                       invokeRestart <- base::invokeRestart
[17:39:33.565]                       is.null <- base::is.null
[17:39:33.565]                       muffled <- FALSE
[17:39:33.565]                       if (inherits(cond, "message")) {
[17:39:33.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.565]                         if (muffled) 
[17:39:33.565]                           invokeRestart("muffleMessage")
[17:39:33.565]                       }
[17:39:33.565]                       else if (inherits(cond, "warning")) {
[17:39:33.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.565]                         if (muffled) 
[17:39:33.565]                           invokeRestart("muffleWarning")
[17:39:33.565]                       }
[17:39:33.565]                       else if (inherits(cond, "condition")) {
[17:39:33.565]                         if (!is.null(pattern)) {
[17:39:33.565]                           computeRestarts <- base::computeRestarts
[17:39:33.565]                           grepl <- base::grepl
[17:39:33.565]                           restarts <- computeRestarts(cond)
[17:39:33.565]                           for (restart in restarts) {
[17:39:33.565]                             name <- restart$name
[17:39:33.565]                             if (is.null(name)) 
[17:39:33.565]                               next
[17:39:33.565]                             if (!grepl(pattern, name)) 
[17:39:33.565]                               next
[17:39:33.565]                             invokeRestart(restart)
[17:39:33.565]                             muffled <- TRUE
[17:39:33.565]                             break
[17:39:33.565]                           }
[17:39:33.565]                         }
[17:39:33.565]                       }
[17:39:33.565]                       invisible(muffled)
[17:39:33.565]                     }
[17:39:33.565]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.565]                   }
[17:39:33.565]                 }
[17:39:33.565]             }
[17:39:33.565]         }))
[17:39:33.565]     }, error = function(ex) {
[17:39:33.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.565]                 ...future.rng), started = ...future.startTime, 
[17:39:33.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.565]             version = "1.8"), class = "FutureResult")
[17:39:33.565]     }, finally = {
[17:39:33.565]         if (!identical(...future.workdir, getwd())) 
[17:39:33.565]             setwd(...future.workdir)
[17:39:33.565]         {
[17:39:33.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.565]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.565]             }
[17:39:33.565]             base::options(...future.oldOptions)
[17:39:33.565]             if (.Platform$OS.type == "windows") {
[17:39:33.565]                 old_names <- names(...future.oldEnvVars)
[17:39:33.565]                 envs <- base::Sys.getenv()
[17:39:33.565]                 names <- names(envs)
[17:39:33.565]                 common <- intersect(names, old_names)
[17:39:33.565]                 added <- setdiff(names, old_names)
[17:39:33.565]                 removed <- setdiff(old_names, names)
[17:39:33.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.565]                   envs[common]]
[17:39:33.565]                 NAMES <- toupper(changed)
[17:39:33.565]                 args <- list()
[17:39:33.565]                 for (kk in seq_along(NAMES)) {
[17:39:33.565]                   name <- changed[[kk]]
[17:39:33.565]                   NAME <- NAMES[[kk]]
[17:39:33.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.565]                     next
[17:39:33.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.565]                 }
[17:39:33.565]                 NAMES <- toupper(added)
[17:39:33.565]                 for (kk in seq_along(NAMES)) {
[17:39:33.565]                   name <- added[[kk]]
[17:39:33.565]                   NAME <- NAMES[[kk]]
[17:39:33.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.565]                     next
[17:39:33.565]                   args[[name]] <- ""
[17:39:33.565]                 }
[17:39:33.565]                 NAMES <- toupper(removed)
[17:39:33.565]                 for (kk in seq_along(NAMES)) {
[17:39:33.565]                   name <- removed[[kk]]
[17:39:33.565]                   NAME <- NAMES[[kk]]
[17:39:33.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.565]                     next
[17:39:33.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.565]                 }
[17:39:33.565]                 if (length(args) > 0) 
[17:39:33.565]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.565]             }
[17:39:33.565]             else {
[17:39:33.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.565]             }
[17:39:33.565]             {
[17:39:33.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.565]                   0L) {
[17:39:33.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.565]                   base::options(opts)
[17:39:33.565]                 }
[17:39:33.565]                 {
[17:39:33.565]                   {
[17:39:33.565]                     NULL
[17:39:33.565]                     RNGkind("Mersenne-Twister")
[17:39:33.565]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.565]                       inherits = FALSE)
[17:39:33.565]                   }
[17:39:33.565]                   options(future.plan = NULL)
[17:39:33.565]                   if (is.na(NA_character_)) 
[17:39:33.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.565]                     .init = FALSE)
[17:39:33.565]                 }
[17:39:33.565]             }
[17:39:33.565]         }
[17:39:33.565]     })
[17:39:33.565]     if (TRUE) {
[17:39:33.565]         base::sink(type = "output", split = FALSE)
[17:39:33.565]         if (TRUE) {
[17:39:33.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.565]         }
[17:39:33.565]         else {
[17:39:33.565]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.565]         }
[17:39:33.565]         base::close(...future.stdout)
[17:39:33.565]         ...future.stdout <- NULL
[17:39:33.565]     }
[17:39:33.565]     ...future.result$conditions <- ...future.conditions
[17:39:33.565]     ...future.result$finished <- base::Sys.time()
[17:39:33.565]     ...future.result
[17:39:33.565] }
[17:39:33.567] plan(): Setting new future strategy stack:
[17:39:33.567] List of future strategies:
[17:39:33.567] 1. sequential:
[17:39:33.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.567]    - tweaked: FALSE
[17:39:33.567]    - call: NULL
[17:39:33.568] plan(): nbrOfWorkers() = 1
[17:39:33.568] plan(): Setting new future strategy stack:
[17:39:33.569] List of future strategies:
[17:39:33.569] 1. sequential:
[17:39:33.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.569]    - tweaked: FALSE
[17:39:33.569]    - call: plan(strategy)
[17:39:33.569] plan(): nbrOfWorkers() = 1
[17:39:33.569] SequentialFuture started (and completed)
[17:39:33.569] - Launch lazy future ... done
[17:39:33.569] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adee68d840> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefa79fc8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adee68d840> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55adefa79fc8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:33.575] resolved() for ‘SequentialFuture’ ...
[17:39:33.575] - state: ‘finished’
[17:39:33.575] - run: TRUE
[17:39:33.575] - result: ‘FutureResult’
[17:39:33.575] resolved() for ‘SequentialFuture’ ... done
[17:39:33.575] resolved() for ‘SequentialFuture’ ...
[17:39:33.575] - state: ‘finished’
[17:39:33.575] - run: TRUE
[17:39:33.576] - result: ‘FutureResult’
[17:39:33.576] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:33.578] resolve() on list ...
[17:39:33.578]  recursive: 0
[17:39:33.578]  length: 6
[17:39:33.578]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:33.578] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.578] - nx: 6
[17:39:33.578] - relay: TRUE
[17:39:33.578] - stdout: TRUE
[17:39:33.578] - signal: TRUE
[17:39:33.579] - resignal: FALSE
[17:39:33.579] - force: TRUE
[17:39:33.579] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.579] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.579]  - until=2
[17:39:33.579]  - relaying element #2
[17:39:33.579] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.579] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.579] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.579]  length: 5 (resolved future 1)
[17:39:33.579] resolved() for ‘SequentialFuture’ ...
[17:39:33.580] - state: ‘finished’
[17:39:33.580] - run: TRUE
[17:39:33.580] - result: ‘FutureResult’
[17:39:33.580] resolved() for ‘SequentialFuture’ ... done
[17:39:33.580] Future #2
[17:39:33.580] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.580] - nx: 6
[17:39:33.580] - relay: TRUE
[17:39:33.580] - stdout: TRUE
[17:39:33.580] - signal: TRUE
[17:39:33.580] - resignal: FALSE
[17:39:33.581] - force: TRUE
[17:39:33.581] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.581] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.581]  - until=2
[17:39:33.581]  - relaying element #2
[17:39:33.581] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.581] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.581] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.581]  length: 4 (resolved future 2)
[17:39:33.584] resolved() for ‘SequentialFuture’ ...
[17:39:33.584] - state: ‘finished’
[17:39:33.584] - run: TRUE
[17:39:33.584] - result: ‘FutureResult’
[17:39:33.584] resolved() for ‘SequentialFuture’ ... done
[17:39:33.584] Future #3
[17:39:33.584] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.584] - nx: 6
[17:39:33.584] - relay: TRUE
[17:39:33.585] - stdout: TRUE
[17:39:33.585] - signal: TRUE
[17:39:33.585] - resignal: FALSE
[17:39:33.585] - force: TRUE
[17:39:33.585] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.585] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.585]  - until=3
[17:39:33.585]  - relaying element #3
[17:39:33.585] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.585] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.586] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.586]  length: 3 (resolved future 3)
[17:39:33.586] signalConditionsASAP(NULL, pos=4) ...
[17:39:33.586] - nx: 6
[17:39:33.586] - relay: TRUE
[17:39:33.586] - stdout: TRUE
[17:39:33.586] - signal: TRUE
[17:39:33.586] - resignal: FALSE
[17:39:33.586] - force: TRUE
[17:39:33.586] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.586] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.586]  - until=5
[17:39:33.587]  - relaying element #5
[17:39:33.587] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.587] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.587] signalConditionsASAP(NULL, pos=4) ... done
[17:39:33.587]  length: 2 (resolved future 4)
[17:39:33.587] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.587] - nx: 6
[17:39:33.587] - relay: TRUE
[17:39:33.587] - stdout: TRUE
[17:39:33.587] - signal: TRUE
[17:39:33.587] - resignal: FALSE
[17:39:33.587] - force: TRUE
[17:39:33.588] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.588] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.588]  - until=6
[17:39:33.588]  - relaying element #6
[17:39:33.588] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.588] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.588] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.588]  length: 1 (resolved future 5)
[17:39:33.588] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.588] - nx: 6
[17:39:33.588] - relay: TRUE
[17:39:33.589] - stdout: TRUE
[17:39:33.589] - signal: TRUE
[17:39:33.589] - resignal: FALSE
[17:39:33.589] - force: TRUE
[17:39:33.589] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.589] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.589]  - until=6
[17:39:33.589] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.589] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.589] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.589]  length: 0 (resolved future 6)
[17:39:33.590] Relaying remaining futures
[17:39:33.590] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.590] - nx: 6
[17:39:33.590] - relay: TRUE
[17:39:33.590] - stdout: TRUE
[17:39:33.590] - signal: TRUE
[17:39:33.590] - resignal: FALSE
[17:39:33.590] - force: TRUE
[17:39:33.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:33.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.591] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.591] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[17:39:33.599] plan(): Setting new future strategy stack:
[17:39:33.600] List of future strategies:
[17:39:33.600] 1. sequential:
[17:39:33.600]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.600]    - tweaked: FALSE
[17:39:33.600]    - call: plan(strategy)
[17:39:33.600] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:39:33.600] getGlobalsAndPackages() ...
[17:39:33.600] Searching for globals...
[17:39:33.601] 
[17:39:33.601] Searching for globals ... DONE
[17:39:33.601] - globals: [0] <none>
[17:39:33.601] getGlobalsAndPackages() ... DONE
[17:39:33.601] run() for ‘Future’ ...
[17:39:33.601] - state: ‘created’
[17:39:33.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.602] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.602] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.602]   - Field: ‘label’
[17:39:33.602]   - Field: ‘local’
[17:39:33.602]   - Field: ‘owner’
[17:39:33.602]   - Field: ‘envir’
[17:39:33.602]   - Field: ‘packages’
[17:39:33.602]   - Field: ‘gc’
[17:39:33.603]   - Field: ‘conditions’
[17:39:33.603]   - Field: ‘expr’
[17:39:33.603]   - Field: ‘uuid’
[17:39:33.603]   - Field: ‘seed’
[17:39:33.603]   - Field: ‘version’
[17:39:33.603]   - Field: ‘result’
[17:39:33.603]   - Field: ‘asynchronous’
[17:39:33.603]   - Field: ‘calls’
[17:39:33.603]   - Field: ‘globals’
[17:39:33.603]   - Field: ‘stdout’
[17:39:33.603]   - Field: ‘earlySignal’
[17:39:33.604]   - Field: ‘lazy’
[17:39:33.604]   - Field: ‘state’
[17:39:33.604] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.604] - Launch lazy future ...
[17:39:33.604] Packages needed by the future expression (n = 0): <none>
[17:39:33.604] Packages needed by future strategies (n = 0): <none>
[17:39:33.605] {
[17:39:33.605]     {
[17:39:33.605]         {
[17:39:33.605]             ...future.startTime <- base::Sys.time()
[17:39:33.605]             {
[17:39:33.605]                 {
[17:39:33.605]                   {
[17:39:33.605]                     base::local({
[17:39:33.605]                       has_future <- base::requireNamespace("future", 
[17:39:33.605]                         quietly = TRUE)
[17:39:33.605]                       if (has_future) {
[17:39:33.605]                         ns <- base::getNamespace("future")
[17:39:33.605]                         version <- ns[[".package"]][["version"]]
[17:39:33.605]                         if (is.null(version)) 
[17:39:33.605]                           version <- utils::packageVersion("future")
[17:39:33.605]                       }
[17:39:33.605]                       else {
[17:39:33.605]                         version <- NULL
[17:39:33.605]                       }
[17:39:33.605]                       if (!has_future || version < "1.8.0") {
[17:39:33.605]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.605]                           "", base::R.version$version.string), 
[17:39:33.605]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.605]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.605]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.605]                             "release", "version")], collapse = " "), 
[17:39:33.605]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.605]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.605]                           info)
[17:39:33.605]                         info <- base::paste(info, collapse = "; ")
[17:39:33.605]                         if (!has_future) {
[17:39:33.605]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.605]                             info)
[17:39:33.605]                         }
[17:39:33.605]                         else {
[17:39:33.605]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.605]                             info, version)
[17:39:33.605]                         }
[17:39:33.605]                         base::stop(msg)
[17:39:33.605]                       }
[17:39:33.605]                     })
[17:39:33.605]                   }
[17:39:33.605]                   ...future.strategy.old <- future::plan("list")
[17:39:33.605]                   options(future.plan = NULL)
[17:39:33.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.605]                 }
[17:39:33.605]                 ...future.workdir <- getwd()
[17:39:33.605]             }
[17:39:33.605]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.605]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.605]         }
[17:39:33.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.605]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.605]             base::names(...future.oldOptions))
[17:39:33.605]     }
[17:39:33.605]     if (FALSE) {
[17:39:33.605]     }
[17:39:33.605]     else {
[17:39:33.605]         if (TRUE) {
[17:39:33.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.605]                 open = "w")
[17:39:33.605]         }
[17:39:33.605]         else {
[17:39:33.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.605]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.605]         }
[17:39:33.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.605]             base::sink(type = "output", split = FALSE)
[17:39:33.605]             base::close(...future.stdout)
[17:39:33.605]         }, add = TRUE)
[17:39:33.605]     }
[17:39:33.605]     ...future.frame <- base::sys.nframe()
[17:39:33.605]     ...future.conditions <- base::list()
[17:39:33.605]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.605]     if (FALSE) {
[17:39:33.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.605]     }
[17:39:33.605]     ...future.result <- base::tryCatch({
[17:39:33.605]         base::withCallingHandlers({
[17:39:33.605]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.605]             future::FutureResult(value = ...future.value$value, 
[17:39:33.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.605]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.605]                     ...future.globalenv.names))
[17:39:33.605]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.605]         }, condition = base::local({
[17:39:33.605]             c <- base::c
[17:39:33.605]             inherits <- base::inherits
[17:39:33.605]             invokeRestart <- base::invokeRestart
[17:39:33.605]             length <- base::length
[17:39:33.605]             list <- base::list
[17:39:33.605]             seq.int <- base::seq.int
[17:39:33.605]             signalCondition <- base::signalCondition
[17:39:33.605]             sys.calls <- base::sys.calls
[17:39:33.605]             `[[` <- base::`[[`
[17:39:33.605]             `+` <- base::`+`
[17:39:33.605]             `<<-` <- base::`<<-`
[17:39:33.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.605]                   3L)]
[17:39:33.605]             }
[17:39:33.605]             function(cond) {
[17:39:33.605]                 is_error <- inherits(cond, "error")
[17:39:33.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.605]                   NULL)
[17:39:33.605]                 if (is_error) {
[17:39:33.605]                   sessionInformation <- function() {
[17:39:33.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.605]                       search = base::search(), system = base::Sys.info())
[17:39:33.605]                   }
[17:39:33.605]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.605]                     cond$call), session = sessionInformation(), 
[17:39:33.605]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.605]                   signalCondition(cond)
[17:39:33.605]                 }
[17:39:33.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.605]                 "immediateCondition"))) {
[17:39:33.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.605]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.605]                   if (TRUE && !signal) {
[17:39:33.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.605]                     {
[17:39:33.605]                       inherits <- base::inherits
[17:39:33.605]                       invokeRestart <- base::invokeRestart
[17:39:33.605]                       is.null <- base::is.null
[17:39:33.605]                       muffled <- FALSE
[17:39:33.605]                       if (inherits(cond, "message")) {
[17:39:33.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.605]                         if (muffled) 
[17:39:33.605]                           invokeRestart("muffleMessage")
[17:39:33.605]                       }
[17:39:33.605]                       else if (inherits(cond, "warning")) {
[17:39:33.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.605]                         if (muffled) 
[17:39:33.605]                           invokeRestart("muffleWarning")
[17:39:33.605]                       }
[17:39:33.605]                       else if (inherits(cond, "condition")) {
[17:39:33.605]                         if (!is.null(pattern)) {
[17:39:33.605]                           computeRestarts <- base::computeRestarts
[17:39:33.605]                           grepl <- base::grepl
[17:39:33.605]                           restarts <- computeRestarts(cond)
[17:39:33.605]                           for (restart in restarts) {
[17:39:33.605]                             name <- restart$name
[17:39:33.605]                             if (is.null(name)) 
[17:39:33.605]                               next
[17:39:33.605]                             if (!grepl(pattern, name)) 
[17:39:33.605]                               next
[17:39:33.605]                             invokeRestart(restart)
[17:39:33.605]                             muffled <- TRUE
[17:39:33.605]                             break
[17:39:33.605]                           }
[17:39:33.605]                         }
[17:39:33.605]                       }
[17:39:33.605]                       invisible(muffled)
[17:39:33.605]                     }
[17:39:33.605]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.605]                   }
[17:39:33.605]                 }
[17:39:33.605]                 else {
[17:39:33.605]                   if (TRUE) {
[17:39:33.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.605]                     {
[17:39:33.605]                       inherits <- base::inherits
[17:39:33.605]                       invokeRestart <- base::invokeRestart
[17:39:33.605]                       is.null <- base::is.null
[17:39:33.605]                       muffled <- FALSE
[17:39:33.605]                       if (inherits(cond, "message")) {
[17:39:33.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.605]                         if (muffled) 
[17:39:33.605]                           invokeRestart("muffleMessage")
[17:39:33.605]                       }
[17:39:33.605]                       else if (inherits(cond, "warning")) {
[17:39:33.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.605]                         if (muffled) 
[17:39:33.605]                           invokeRestart("muffleWarning")
[17:39:33.605]                       }
[17:39:33.605]                       else if (inherits(cond, "condition")) {
[17:39:33.605]                         if (!is.null(pattern)) {
[17:39:33.605]                           computeRestarts <- base::computeRestarts
[17:39:33.605]                           grepl <- base::grepl
[17:39:33.605]                           restarts <- computeRestarts(cond)
[17:39:33.605]                           for (restart in restarts) {
[17:39:33.605]                             name <- restart$name
[17:39:33.605]                             if (is.null(name)) 
[17:39:33.605]                               next
[17:39:33.605]                             if (!grepl(pattern, name)) 
[17:39:33.605]                               next
[17:39:33.605]                             invokeRestart(restart)
[17:39:33.605]                             muffled <- TRUE
[17:39:33.605]                             break
[17:39:33.605]                           }
[17:39:33.605]                         }
[17:39:33.605]                       }
[17:39:33.605]                       invisible(muffled)
[17:39:33.605]                     }
[17:39:33.605]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.605]                   }
[17:39:33.605]                 }
[17:39:33.605]             }
[17:39:33.605]         }))
[17:39:33.605]     }, error = function(ex) {
[17:39:33.605]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.605]                 ...future.rng), started = ...future.startTime, 
[17:39:33.605]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.605]             version = "1.8"), class = "FutureResult")
[17:39:33.605]     }, finally = {
[17:39:33.605]         if (!identical(...future.workdir, getwd())) 
[17:39:33.605]             setwd(...future.workdir)
[17:39:33.605]         {
[17:39:33.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.605]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.605]             }
[17:39:33.605]             base::options(...future.oldOptions)
[17:39:33.605]             if (.Platform$OS.type == "windows") {
[17:39:33.605]                 old_names <- names(...future.oldEnvVars)
[17:39:33.605]                 envs <- base::Sys.getenv()
[17:39:33.605]                 names <- names(envs)
[17:39:33.605]                 common <- intersect(names, old_names)
[17:39:33.605]                 added <- setdiff(names, old_names)
[17:39:33.605]                 removed <- setdiff(old_names, names)
[17:39:33.605]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.605]                   envs[common]]
[17:39:33.605]                 NAMES <- toupper(changed)
[17:39:33.605]                 args <- list()
[17:39:33.605]                 for (kk in seq_along(NAMES)) {
[17:39:33.605]                   name <- changed[[kk]]
[17:39:33.605]                   NAME <- NAMES[[kk]]
[17:39:33.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.605]                     next
[17:39:33.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.605]                 }
[17:39:33.605]                 NAMES <- toupper(added)
[17:39:33.605]                 for (kk in seq_along(NAMES)) {
[17:39:33.605]                   name <- added[[kk]]
[17:39:33.605]                   NAME <- NAMES[[kk]]
[17:39:33.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.605]                     next
[17:39:33.605]                   args[[name]] <- ""
[17:39:33.605]                 }
[17:39:33.605]                 NAMES <- toupper(removed)
[17:39:33.605]                 for (kk in seq_along(NAMES)) {
[17:39:33.605]                   name <- removed[[kk]]
[17:39:33.605]                   NAME <- NAMES[[kk]]
[17:39:33.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.605]                     next
[17:39:33.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.605]                 }
[17:39:33.605]                 if (length(args) > 0) 
[17:39:33.605]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.605]             }
[17:39:33.605]             else {
[17:39:33.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.605]             }
[17:39:33.605]             {
[17:39:33.605]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.605]                   0L) {
[17:39:33.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.605]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.605]                   base::options(opts)
[17:39:33.605]                 }
[17:39:33.605]                 {
[17:39:33.605]                   {
[17:39:33.605]                     NULL
[17:39:33.605]                     RNGkind("Mersenne-Twister")
[17:39:33.605]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.605]                       inherits = FALSE)
[17:39:33.605]                   }
[17:39:33.605]                   options(future.plan = NULL)
[17:39:33.605]                   if (is.na(NA_character_)) 
[17:39:33.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.605]                     .init = FALSE)
[17:39:33.605]                 }
[17:39:33.605]             }
[17:39:33.605]         }
[17:39:33.605]     })
[17:39:33.605]     if (TRUE) {
[17:39:33.605]         base::sink(type = "output", split = FALSE)
[17:39:33.605]         if (TRUE) {
[17:39:33.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.605]         }
[17:39:33.605]         else {
[17:39:33.605]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.605]         }
[17:39:33.605]         base::close(...future.stdout)
[17:39:33.605]         ...future.stdout <- NULL
[17:39:33.605]     }
[17:39:33.605]     ...future.result$conditions <- ...future.conditions
[17:39:33.605]     ...future.result$finished <- base::Sys.time()
[17:39:33.605]     ...future.result
[17:39:33.605] }
[17:39:33.606] plan(): Setting new future strategy stack:
[17:39:33.606] List of future strategies:
[17:39:33.606] 1. sequential:
[17:39:33.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.606]    - tweaked: FALSE
[17:39:33.606]    - call: NULL
[17:39:33.607] plan(): nbrOfWorkers() = 1
[17:39:33.608] plan(): Setting new future strategy stack:
[17:39:33.608] List of future strategies:
[17:39:33.608] 1. sequential:
[17:39:33.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.608]    - tweaked: FALSE
[17:39:33.608]    - call: plan(strategy)
[17:39:33.608] plan(): nbrOfWorkers() = 1
[17:39:33.608] SequentialFuture started (and completed)
[17:39:33.609] - Launch lazy future ... done
[17:39:33.609] run() for ‘SequentialFuture’ ... done
[17:39:33.609] getGlobalsAndPackages() ...
[17:39:33.609] Searching for globals...
[17:39:33.609] 
[17:39:33.609] Searching for globals ... DONE
[17:39:33.609] - globals: [0] <none>
[17:39:33.609] getGlobalsAndPackages() ... DONE
[17:39:33.610] run() for ‘Future’ ...
[17:39:33.610] - state: ‘created’
[17:39:33.610] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.610]   - Field: ‘label’
[17:39:33.613]   - Field: ‘local’
[17:39:33.613]   - Field: ‘owner’
[17:39:33.613]   - Field: ‘envir’
[17:39:33.613]   - Field: ‘packages’
[17:39:33.613]   - Field: ‘gc’
[17:39:33.613]   - Field: ‘conditions’
[17:39:33.613]   - Field: ‘expr’
[17:39:33.613]   - Field: ‘uuid’
[17:39:33.613]   - Field: ‘seed’
[17:39:33.613]   - Field: ‘version’
[17:39:33.613]   - Field: ‘result’
[17:39:33.614]   - Field: ‘asynchronous’
[17:39:33.614]   - Field: ‘calls’
[17:39:33.614]   - Field: ‘globals’
[17:39:33.614]   - Field: ‘stdout’
[17:39:33.614]   - Field: ‘earlySignal’
[17:39:33.614]   - Field: ‘lazy’
[17:39:33.614]   - Field: ‘state’
[17:39:33.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.614] - Launch lazy future ...
[17:39:33.614] Packages needed by the future expression (n = 0): <none>
[17:39:33.615] Packages needed by future strategies (n = 0): <none>
[17:39:33.615] {
[17:39:33.615]     {
[17:39:33.615]         {
[17:39:33.615]             ...future.startTime <- base::Sys.time()
[17:39:33.615]             {
[17:39:33.615]                 {
[17:39:33.615]                   {
[17:39:33.615]                     base::local({
[17:39:33.615]                       has_future <- base::requireNamespace("future", 
[17:39:33.615]                         quietly = TRUE)
[17:39:33.615]                       if (has_future) {
[17:39:33.615]                         ns <- base::getNamespace("future")
[17:39:33.615]                         version <- ns[[".package"]][["version"]]
[17:39:33.615]                         if (is.null(version)) 
[17:39:33.615]                           version <- utils::packageVersion("future")
[17:39:33.615]                       }
[17:39:33.615]                       else {
[17:39:33.615]                         version <- NULL
[17:39:33.615]                       }
[17:39:33.615]                       if (!has_future || version < "1.8.0") {
[17:39:33.615]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.615]                           "", base::R.version$version.string), 
[17:39:33.615]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.615]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.615]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.615]                             "release", "version")], collapse = " "), 
[17:39:33.615]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.615]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.615]                           info)
[17:39:33.615]                         info <- base::paste(info, collapse = "; ")
[17:39:33.615]                         if (!has_future) {
[17:39:33.615]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.615]                             info)
[17:39:33.615]                         }
[17:39:33.615]                         else {
[17:39:33.615]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.615]                             info, version)
[17:39:33.615]                         }
[17:39:33.615]                         base::stop(msg)
[17:39:33.615]                       }
[17:39:33.615]                     })
[17:39:33.615]                   }
[17:39:33.615]                   ...future.strategy.old <- future::plan("list")
[17:39:33.615]                   options(future.plan = NULL)
[17:39:33.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.615]                 }
[17:39:33.615]                 ...future.workdir <- getwd()
[17:39:33.615]             }
[17:39:33.615]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.615]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.615]         }
[17:39:33.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.615]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.615]             base::names(...future.oldOptions))
[17:39:33.615]     }
[17:39:33.615]     if (FALSE) {
[17:39:33.615]     }
[17:39:33.615]     else {
[17:39:33.615]         if (TRUE) {
[17:39:33.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.615]                 open = "w")
[17:39:33.615]         }
[17:39:33.615]         else {
[17:39:33.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.615]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.615]         }
[17:39:33.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.615]             base::sink(type = "output", split = FALSE)
[17:39:33.615]             base::close(...future.stdout)
[17:39:33.615]         }, add = TRUE)
[17:39:33.615]     }
[17:39:33.615]     ...future.frame <- base::sys.nframe()
[17:39:33.615]     ...future.conditions <- base::list()
[17:39:33.615]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.615]     if (FALSE) {
[17:39:33.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.615]     }
[17:39:33.615]     ...future.result <- base::tryCatch({
[17:39:33.615]         base::withCallingHandlers({
[17:39:33.615]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.615]             future::FutureResult(value = ...future.value$value, 
[17:39:33.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.615]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.615]                     ...future.globalenv.names))
[17:39:33.615]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.615]         }, condition = base::local({
[17:39:33.615]             c <- base::c
[17:39:33.615]             inherits <- base::inherits
[17:39:33.615]             invokeRestart <- base::invokeRestart
[17:39:33.615]             length <- base::length
[17:39:33.615]             list <- base::list
[17:39:33.615]             seq.int <- base::seq.int
[17:39:33.615]             signalCondition <- base::signalCondition
[17:39:33.615]             sys.calls <- base::sys.calls
[17:39:33.615]             `[[` <- base::`[[`
[17:39:33.615]             `+` <- base::`+`
[17:39:33.615]             `<<-` <- base::`<<-`
[17:39:33.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.615]                   3L)]
[17:39:33.615]             }
[17:39:33.615]             function(cond) {
[17:39:33.615]                 is_error <- inherits(cond, "error")
[17:39:33.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.615]                   NULL)
[17:39:33.615]                 if (is_error) {
[17:39:33.615]                   sessionInformation <- function() {
[17:39:33.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.615]                       search = base::search(), system = base::Sys.info())
[17:39:33.615]                   }
[17:39:33.615]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.615]                     cond$call), session = sessionInformation(), 
[17:39:33.615]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.615]                   signalCondition(cond)
[17:39:33.615]                 }
[17:39:33.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.615]                 "immediateCondition"))) {
[17:39:33.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.615]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.615]                   if (TRUE && !signal) {
[17:39:33.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.615]                     {
[17:39:33.615]                       inherits <- base::inherits
[17:39:33.615]                       invokeRestart <- base::invokeRestart
[17:39:33.615]                       is.null <- base::is.null
[17:39:33.615]                       muffled <- FALSE
[17:39:33.615]                       if (inherits(cond, "message")) {
[17:39:33.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.615]                         if (muffled) 
[17:39:33.615]                           invokeRestart("muffleMessage")
[17:39:33.615]                       }
[17:39:33.615]                       else if (inherits(cond, "warning")) {
[17:39:33.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.615]                         if (muffled) 
[17:39:33.615]                           invokeRestart("muffleWarning")
[17:39:33.615]                       }
[17:39:33.615]                       else if (inherits(cond, "condition")) {
[17:39:33.615]                         if (!is.null(pattern)) {
[17:39:33.615]                           computeRestarts <- base::computeRestarts
[17:39:33.615]                           grepl <- base::grepl
[17:39:33.615]                           restarts <- computeRestarts(cond)
[17:39:33.615]                           for (restart in restarts) {
[17:39:33.615]                             name <- restart$name
[17:39:33.615]                             if (is.null(name)) 
[17:39:33.615]                               next
[17:39:33.615]                             if (!grepl(pattern, name)) 
[17:39:33.615]                               next
[17:39:33.615]                             invokeRestart(restart)
[17:39:33.615]                             muffled <- TRUE
[17:39:33.615]                             break
[17:39:33.615]                           }
[17:39:33.615]                         }
[17:39:33.615]                       }
[17:39:33.615]                       invisible(muffled)
[17:39:33.615]                     }
[17:39:33.615]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.615]                   }
[17:39:33.615]                 }
[17:39:33.615]                 else {
[17:39:33.615]                   if (TRUE) {
[17:39:33.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.615]                     {
[17:39:33.615]                       inherits <- base::inherits
[17:39:33.615]                       invokeRestart <- base::invokeRestart
[17:39:33.615]                       is.null <- base::is.null
[17:39:33.615]                       muffled <- FALSE
[17:39:33.615]                       if (inherits(cond, "message")) {
[17:39:33.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.615]                         if (muffled) 
[17:39:33.615]                           invokeRestart("muffleMessage")
[17:39:33.615]                       }
[17:39:33.615]                       else if (inherits(cond, "warning")) {
[17:39:33.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.615]                         if (muffled) 
[17:39:33.615]                           invokeRestart("muffleWarning")
[17:39:33.615]                       }
[17:39:33.615]                       else if (inherits(cond, "condition")) {
[17:39:33.615]                         if (!is.null(pattern)) {
[17:39:33.615]                           computeRestarts <- base::computeRestarts
[17:39:33.615]                           grepl <- base::grepl
[17:39:33.615]                           restarts <- computeRestarts(cond)
[17:39:33.615]                           for (restart in restarts) {
[17:39:33.615]                             name <- restart$name
[17:39:33.615]                             if (is.null(name)) 
[17:39:33.615]                               next
[17:39:33.615]                             if (!grepl(pattern, name)) 
[17:39:33.615]                               next
[17:39:33.615]                             invokeRestart(restart)
[17:39:33.615]                             muffled <- TRUE
[17:39:33.615]                             break
[17:39:33.615]                           }
[17:39:33.615]                         }
[17:39:33.615]                       }
[17:39:33.615]                       invisible(muffled)
[17:39:33.615]                     }
[17:39:33.615]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.615]                   }
[17:39:33.615]                 }
[17:39:33.615]             }
[17:39:33.615]         }))
[17:39:33.615]     }, error = function(ex) {
[17:39:33.615]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.615]                 ...future.rng), started = ...future.startTime, 
[17:39:33.615]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.615]             version = "1.8"), class = "FutureResult")
[17:39:33.615]     }, finally = {
[17:39:33.615]         if (!identical(...future.workdir, getwd())) 
[17:39:33.615]             setwd(...future.workdir)
[17:39:33.615]         {
[17:39:33.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.615]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.615]             }
[17:39:33.615]             base::options(...future.oldOptions)
[17:39:33.615]             if (.Platform$OS.type == "windows") {
[17:39:33.615]                 old_names <- names(...future.oldEnvVars)
[17:39:33.615]                 envs <- base::Sys.getenv()
[17:39:33.615]                 names <- names(envs)
[17:39:33.615]                 common <- intersect(names, old_names)
[17:39:33.615]                 added <- setdiff(names, old_names)
[17:39:33.615]                 removed <- setdiff(old_names, names)
[17:39:33.615]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.615]                   envs[common]]
[17:39:33.615]                 NAMES <- toupper(changed)
[17:39:33.615]                 args <- list()
[17:39:33.615]                 for (kk in seq_along(NAMES)) {
[17:39:33.615]                   name <- changed[[kk]]
[17:39:33.615]                   NAME <- NAMES[[kk]]
[17:39:33.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.615]                     next
[17:39:33.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.615]                 }
[17:39:33.615]                 NAMES <- toupper(added)
[17:39:33.615]                 for (kk in seq_along(NAMES)) {
[17:39:33.615]                   name <- added[[kk]]
[17:39:33.615]                   NAME <- NAMES[[kk]]
[17:39:33.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.615]                     next
[17:39:33.615]                   args[[name]] <- ""
[17:39:33.615]                 }
[17:39:33.615]                 NAMES <- toupper(removed)
[17:39:33.615]                 for (kk in seq_along(NAMES)) {
[17:39:33.615]                   name <- removed[[kk]]
[17:39:33.615]                   NAME <- NAMES[[kk]]
[17:39:33.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.615]                     next
[17:39:33.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.615]                 }
[17:39:33.615]                 if (length(args) > 0) 
[17:39:33.615]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.615]             }
[17:39:33.615]             else {
[17:39:33.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.615]             }
[17:39:33.615]             {
[17:39:33.615]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.615]                   0L) {
[17:39:33.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.615]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.615]                   base::options(opts)
[17:39:33.615]                 }
[17:39:33.615]                 {
[17:39:33.615]                   {
[17:39:33.615]                     NULL
[17:39:33.615]                     RNGkind("Mersenne-Twister")
[17:39:33.615]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.615]                       inherits = FALSE)
[17:39:33.615]                   }
[17:39:33.615]                   options(future.plan = NULL)
[17:39:33.615]                   if (is.na(NA_character_)) 
[17:39:33.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.615]                     .init = FALSE)
[17:39:33.615]                 }
[17:39:33.615]             }
[17:39:33.615]         }
[17:39:33.615]     })
[17:39:33.615]     if (TRUE) {
[17:39:33.615]         base::sink(type = "output", split = FALSE)
[17:39:33.615]         if (TRUE) {
[17:39:33.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.615]         }
[17:39:33.615]         else {
[17:39:33.615]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.615]         }
[17:39:33.615]         base::close(...future.stdout)
[17:39:33.615]         ...future.stdout <- NULL
[17:39:33.615]     }
[17:39:33.615]     ...future.result$conditions <- ...future.conditions
[17:39:33.615]     ...future.result$finished <- base::Sys.time()
[17:39:33.615]     ...future.result
[17:39:33.615] }
[17:39:33.617] plan(): Setting new future strategy stack:
[17:39:33.617] List of future strategies:
[17:39:33.617] 1. sequential:
[17:39:33.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.617]    - tweaked: FALSE
[17:39:33.617]    - call: NULL
[17:39:33.617] plan(): nbrOfWorkers() = 1
[17:39:33.618] plan(): Setting new future strategy stack:
[17:39:33.618] List of future strategies:
[17:39:33.618] 1. sequential:
[17:39:33.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.618]    - tweaked: FALSE
[17:39:33.618]    - call: plan(strategy)
[17:39:33.619] plan(): nbrOfWorkers() = 1
[17:39:33.619] SequentialFuture started (and completed)
[17:39:33.619] - Launch lazy future ... done
[17:39:33.619] run() for ‘SequentialFuture’ ... done
[17:39:33.620] getGlobalsAndPackages() ...
[17:39:33.620] Searching for globals...
[17:39:33.622] - globals found: [1] ‘{’
[17:39:33.622] Searching for globals ... DONE
[17:39:33.622] Resolving globals: FALSE
[17:39:33.622] 
[17:39:33.622] 
[17:39:33.623] getGlobalsAndPackages() ... DONE
[17:39:33.623] run() for ‘Future’ ...
[17:39:33.623] - state: ‘created’
[17:39:33.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.623]   - Field: ‘label’
[17:39:33.624]   - Field: ‘local’
[17:39:33.624]   - Field: ‘owner’
[17:39:33.624]   - Field: ‘envir’
[17:39:33.624]   - Field: ‘packages’
[17:39:33.624]   - Field: ‘gc’
[17:39:33.624]   - Field: ‘conditions’
[17:39:33.624]   - Field: ‘expr’
[17:39:33.624]   - Field: ‘uuid’
[17:39:33.624]   - Field: ‘seed’
[17:39:33.624]   - Field: ‘version’
[17:39:33.624]   - Field: ‘result’
[17:39:33.625]   - Field: ‘asynchronous’
[17:39:33.625]   - Field: ‘calls’
[17:39:33.625]   - Field: ‘globals’
[17:39:33.625]   - Field: ‘stdout’
[17:39:33.625]   - Field: ‘earlySignal’
[17:39:33.625]   - Field: ‘lazy’
[17:39:33.625]   - Field: ‘state’
[17:39:33.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.625] - Launch lazy future ...
[17:39:33.625] Packages needed by the future expression (n = 0): <none>
[17:39:33.626] Packages needed by future strategies (n = 0): <none>
[17:39:33.626] {
[17:39:33.626]     {
[17:39:33.626]         {
[17:39:33.626]             ...future.startTime <- base::Sys.time()
[17:39:33.626]             {
[17:39:33.626]                 {
[17:39:33.626]                   {
[17:39:33.626]                     base::local({
[17:39:33.626]                       has_future <- base::requireNamespace("future", 
[17:39:33.626]                         quietly = TRUE)
[17:39:33.626]                       if (has_future) {
[17:39:33.626]                         ns <- base::getNamespace("future")
[17:39:33.626]                         version <- ns[[".package"]][["version"]]
[17:39:33.626]                         if (is.null(version)) 
[17:39:33.626]                           version <- utils::packageVersion("future")
[17:39:33.626]                       }
[17:39:33.626]                       else {
[17:39:33.626]                         version <- NULL
[17:39:33.626]                       }
[17:39:33.626]                       if (!has_future || version < "1.8.0") {
[17:39:33.626]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.626]                           "", base::R.version$version.string), 
[17:39:33.626]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.626]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.626]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.626]                             "release", "version")], collapse = " "), 
[17:39:33.626]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.626]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.626]                           info)
[17:39:33.626]                         info <- base::paste(info, collapse = "; ")
[17:39:33.626]                         if (!has_future) {
[17:39:33.626]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.626]                             info)
[17:39:33.626]                         }
[17:39:33.626]                         else {
[17:39:33.626]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.626]                             info, version)
[17:39:33.626]                         }
[17:39:33.626]                         base::stop(msg)
[17:39:33.626]                       }
[17:39:33.626]                     })
[17:39:33.626]                   }
[17:39:33.626]                   ...future.strategy.old <- future::plan("list")
[17:39:33.626]                   options(future.plan = NULL)
[17:39:33.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.626]                 }
[17:39:33.626]                 ...future.workdir <- getwd()
[17:39:33.626]             }
[17:39:33.626]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.626]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.626]         }
[17:39:33.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.626]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.626]             base::names(...future.oldOptions))
[17:39:33.626]     }
[17:39:33.626]     if (FALSE) {
[17:39:33.626]     }
[17:39:33.626]     else {
[17:39:33.626]         if (TRUE) {
[17:39:33.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.626]                 open = "w")
[17:39:33.626]         }
[17:39:33.626]         else {
[17:39:33.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.626]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.626]         }
[17:39:33.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.626]             base::sink(type = "output", split = FALSE)
[17:39:33.626]             base::close(...future.stdout)
[17:39:33.626]         }, add = TRUE)
[17:39:33.626]     }
[17:39:33.626]     ...future.frame <- base::sys.nframe()
[17:39:33.626]     ...future.conditions <- base::list()
[17:39:33.626]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.626]     if (FALSE) {
[17:39:33.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.626]     }
[17:39:33.626]     ...future.result <- base::tryCatch({
[17:39:33.626]         base::withCallingHandlers({
[17:39:33.626]             ...future.value <- base::withVisible(base::local({
[17:39:33.626]                 4
[17:39:33.626]             }))
[17:39:33.626]             future::FutureResult(value = ...future.value$value, 
[17:39:33.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.626]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.626]                     ...future.globalenv.names))
[17:39:33.626]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.626]         }, condition = base::local({
[17:39:33.626]             c <- base::c
[17:39:33.626]             inherits <- base::inherits
[17:39:33.626]             invokeRestart <- base::invokeRestart
[17:39:33.626]             length <- base::length
[17:39:33.626]             list <- base::list
[17:39:33.626]             seq.int <- base::seq.int
[17:39:33.626]             signalCondition <- base::signalCondition
[17:39:33.626]             sys.calls <- base::sys.calls
[17:39:33.626]             `[[` <- base::`[[`
[17:39:33.626]             `+` <- base::`+`
[17:39:33.626]             `<<-` <- base::`<<-`
[17:39:33.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.626]                   3L)]
[17:39:33.626]             }
[17:39:33.626]             function(cond) {
[17:39:33.626]                 is_error <- inherits(cond, "error")
[17:39:33.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.626]                   NULL)
[17:39:33.626]                 if (is_error) {
[17:39:33.626]                   sessionInformation <- function() {
[17:39:33.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.626]                       search = base::search(), system = base::Sys.info())
[17:39:33.626]                   }
[17:39:33.626]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.626]                     cond$call), session = sessionInformation(), 
[17:39:33.626]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.626]                   signalCondition(cond)
[17:39:33.626]                 }
[17:39:33.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.626]                 "immediateCondition"))) {
[17:39:33.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.626]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.626]                   if (TRUE && !signal) {
[17:39:33.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.626]                     {
[17:39:33.626]                       inherits <- base::inherits
[17:39:33.626]                       invokeRestart <- base::invokeRestart
[17:39:33.626]                       is.null <- base::is.null
[17:39:33.626]                       muffled <- FALSE
[17:39:33.626]                       if (inherits(cond, "message")) {
[17:39:33.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.626]                         if (muffled) 
[17:39:33.626]                           invokeRestart("muffleMessage")
[17:39:33.626]                       }
[17:39:33.626]                       else if (inherits(cond, "warning")) {
[17:39:33.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.626]                         if (muffled) 
[17:39:33.626]                           invokeRestart("muffleWarning")
[17:39:33.626]                       }
[17:39:33.626]                       else if (inherits(cond, "condition")) {
[17:39:33.626]                         if (!is.null(pattern)) {
[17:39:33.626]                           computeRestarts <- base::computeRestarts
[17:39:33.626]                           grepl <- base::grepl
[17:39:33.626]                           restarts <- computeRestarts(cond)
[17:39:33.626]                           for (restart in restarts) {
[17:39:33.626]                             name <- restart$name
[17:39:33.626]                             if (is.null(name)) 
[17:39:33.626]                               next
[17:39:33.626]                             if (!grepl(pattern, name)) 
[17:39:33.626]                               next
[17:39:33.626]                             invokeRestart(restart)
[17:39:33.626]                             muffled <- TRUE
[17:39:33.626]                             break
[17:39:33.626]                           }
[17:39:33.626]                         }
[17:39:33.626]                       }
[17:39:33.626]                       invisible(muffled)
[17:39:33.626]                     }
[17:39:33.626]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.626]                   }
[17:39:33.626]                 }
[17:39:33.626]                 else {
[17:39:33.626]                   if (TRUE) {
[17:39:33.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.626]                     {
[17:39:33.626]                       inherits <- base::inherits
[17:39:33.626]                       invokeRestart <- base::invokeRestart
[17:39:33.626]                       is.null <- base::is.null
[17:39:33.626]                       muffled <- FALSE
[17:39:33.626]                       if (inherits(cond, "message")) {
[17:39:33.626]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.626]                         if (muffled) 
[17:39:33.626]                           invokeRestart("muffleMessage")
[17:39:33.626]                       }
[17:39:33.626]                       else if (inherits(cond, "warning")) {
[17:39:33.626]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.626]                         if (muffled) 
[17:39:33.626]                           invokeRestart("muffleWarning")
[17:39:33.626]                       }
[17:39:33.626]                       else if (inherits(cond, "condition")) {
[17:39:33.626]                         if (!is.null(pattern)) {
[17:39:33.626]                           computeRestarts <- base::computeRestarts
[17:39:33.626]                           grepl <- base::grepl
[17:39:33.626]                           restarts <- computeRestarts(cond)
[17:39:33.626]                           for (restart in restarts) {
[17:39:33.626]                             name <- restart$name
[17:39:33.626]                             if (is.null(name)) 
[17:39:33.626]                               next
[17:39:33.626]                             if (!grepl(pattern, name)) 
[17:39:33.626]                               next
[17:39:33.626]                             invokeRestart(restart)
[17:39:33.626]                             muffled <- TRUE
[17:39:33.626]                             break
[17:39:33.626]                           }
[17:39:33.626]                         }
[17:39:33.626]                       }
[17:39:33.626]                       invisible(muffled)
[17:39:33.626]                     }
[17:39:33.626]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.626]                   }
[17:39:33.626]                 }
[17:39:33.626]             }
[17:39:33.626]         }))
[17:39:33.626]     }, error = function(ex) {
[17:39:33.626]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.626]                 ...future.rng), started = ...future.startTime, 
[17:39:33.626]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.626]             version = "1.8"), class = "FutureResult")
[17:39:33.626]     }, finally = {
[17:39:33.626]         if (!identical(...future.workdir, getwd())) 
[17:39:33.626]             setwd(...future.workdir)
[17:39:33.626]         {
[17:39:33.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.626]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.626]             }
[17:39:33.626]             base::options(...future.oldOptions)
[17:39:33.626]             if (.Platform$OS.type == "windows") {
[17:39:33.626]                 old_names <- names(...future.oldEnvVars)
[17:39:33.626]                 envs <- base::Sys.getenv()
[17:39:33.626]                 names <- names(envs)
[17:39:33.626]                 common <- intersect(names, old_names)
[17:39:33.626]                 added <- setdiff(names, old_names)
[17:39:33.626]                 removed <- setdiff(old_names, names)
[17:39:33.626]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.626]                   envs[common]]
[17:39:33.626]                 NAMES <- toupper(changed)
[17:39:33.626]                 args <- list()
[17:39:33.626]                 for (kk in seq_along(NAMES)) {
[17:39:33.626]                   name <- changed[[kk]]
[17:39:33.626]                   NAME <- NAMES[[kk]]
[17:39:33.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.626]                     next
[17:39:33.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.626]                 }
[17:39:33.626]                 NAMES <- toupper(added)
[17:39:33.626]                 for (kk in seq_along(NAMES)) {
[17:39:33.626]                   name <- added[[kk]]
[17:39:33.626]                   NAME <- NAMES[[kk]]
[17:39:33.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.626]                     next
[17:39:33.626]                   args[[name]] <- ""
[17:39:33.626]                 }
[17:39:33.626]                 NAMES <- toupper(removed)
[17:39:33.626]                 for (kk in seq_along(NAMES)) {
[17:39:33.626]                   name <- removed[[kk]]
[17:39:33.626]                   NAME <- NAMES[[kk]]
[17:39:33.626]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.626]                     next
[17:39:33.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.626]                 }
[17:39:33.626]                 if (length(args) > 0) 
[17:39:33.626]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.626]             }
[17:39:33.626]             else {
[17:39:33.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.626]             }
[17:39:33.626]             {
[17:39:33.626]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.626]                   0L) {
[17:39:33.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.626]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.626]                   base::options(opts)
[17:39:33.626]                 }
[17:39:33.626]                 {
[17:39:33.626]                   {
[17:39:33.626]                     NULL
[17:39:33.626]                     RNGkind("Mersenne-Twister")
[17:39:33.626]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.626]                       inherits = FALSE)
[17:39:33.626]                   }
[17:39:33.626]                   options(future.plan = NULL)
[17:39:33.626]                   if (is.na(NA_character_)) 
[17:39:33.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.626]                     .init = FALSE)
[17:39:33.626]                 }
[17:39:33.626]             }
[17:39:33.626]         }
[17:39:33.626]     })
[17:39:33.626]     if (TRUE) {
[17:39:33.626]         base::sink(type = "output", split = FALSE)
[17:39:33.626]         if (TRUE) {
[17:39:33.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.626]         }
[17:39:33.626]         else {
[17:39:33.626]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.626]         }
[17:39:33.626]         base::close(...future.stdout)
[17:39:33.626]         ...future.stdout <- NULL
[17:39:33.626]     }
[17:39:33.626]     ...future.result$conditions <- ...future.conditions
[17:39:33.626]     ...future.result$finished <- base::Sys.time()
[17:39:33.626]     ...future.result
[17:39:33.626] }
[17:39:33.628] plan(): Setting new future strategy stack:
[17:39:33.628] List of future strategies:
[17:39:33.628] 1. sequential:
[17:39:33.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.628]    - tweaked: FALSE
[17:39:33.628]    - call: NULL
[17:39:33.628] plan(): nbrOfWorkers() = 1
[17:39:33.629] plan(): Setting new future strategy stack:
[17:39:33.629] List of future strategies:
[17:39:33.629] 1. sequential:
[17:39:33.629]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.629]    - tweaked: FALSE
[17:39:33.629]    - call: plan(strategy)
[17:39:33.630] plan(): nbrOfWorkers() = 1
[17:39:33.630] SequentialFuture started (and completed)
[17:39:33.630] - Launch lazy future ... done
[17:39:33.630] run() for ‘SequentialFuture’ ... done
<environment: 0x55adf0259fe8> 
<environment: 0x55adeff31088> 
[17:39:33.631] resolved() for ‘SequentialFuture’ ...
[17:39:33.632] - state: ‘finished’
[17:39:33.632] - run: TRUE
[17:39:33.632] - result: ‘FutureResult’
[17:39:33.632] resolved() for ‘SequentialFuture’ ... done
[17:39:33.632] resolved() for ‘SequentialFuture’ ...
[17:39:33.632] - state: ‘finished’
[17:39:33.632] - run: TRUE
[17:39:33.632] - result: ‘FutureResult’
[17:39:33.632] resolved() for ‘SequentialFuture’ ... done
[17:39:33.632] resolved() for ‘SequentialFuture’ ...
[17:39:33.633] - state: ‘finished’
[17:39:33.633] - run: TRUE
[17:39:33.633] - result: ‘FutureResult’
[17:39:33.633] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:33.634] resolve() on environment ...
[17:39:33.634]  recursive: 0
[17:39:33.635]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:33.635] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.635] - nx: 4
[17:39:33.635] - relay: TRUE
[17:39:33.635] - stdout: TRUE
[17:39:33.635] - signal: TRUE
[17:39:33.635] - resignal: FALSE
[17:39:33.635] - force: TRUE
[17:39:33.635] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.636] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.636]  - until=2
[17:39:33.636]  - relaying element #2
[17:39:33.636] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.636] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.636] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.636]  length: 3 (resolved future 1)
[17:39:33.636] resolved() for ‘SequentialFuture’ ...
[17:39:33.636] - state: ‘finished’
[17:39:33.636] - run: TRUE
[17:39:33.637] - result: ‘FutureResult’
[17:39:33.637] resolved() for ‘SequentialFuture’ ... done
[17:39:33.637] Future #2
[17:39:33.637] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.637] - nx: 4
[17:39:33.637] - relay: TRUE
[17:39:33.637] - stdout: TRUE
[17:39:33.637] - signal: TRUE
[17:39:33.637] - resignal: FALSE
[17:39:33.637] - force: TRUE
[17:39:33.637] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.637] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.638]  - until=2
[17:39:33.638]  - relaying element #2
[17:39:33.638] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.638] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.638] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.638]  length: 2 (resolved future 2)
[17:39:33.638] resolved() for ‘SequentialFuture’ ...
[17:39:33.638] - state: ‘finished’
[17:39:33.638] - run: TRUE
[17:39:33.639] - result: ‘FutureResult’
[17:39:33.639] resolved() for ‘SequentialFuture’ ... done
[17:39:33.639] Future #3
[17:39:33.639] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.639] - nx: 4
[17:39:33.639] - relay: TRUE
[17:39:33.639] - stdout: TRUE
[17:39:33.639] - signal: TRUE
[17:39:33.639] - resignal: FALSE
[17:39:33.639] - force: TRUE
[17:39:33.639] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.639] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.640]  - until=3
[17:39:33.640]  - relaying element #3
[17:39:33.640] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.640] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.640] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.640]  length: 1 (resolved future 3)
[17:39:33.640] resolved() for ‘SequentialFuture’ ...
[17:39:33.640] - state: ‘finished’
[17:39:33.640] - run: TRUE
[17:39:33.641] - result: ‘FutureResult’
[17:39:33.641] resolved() for ‘SequentialFuture’ ... done
[17:39:33.641] Future #4
[17:39:33.641] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.641] - nx: 4
[17:39:33.641] - relay: TRUE
[17:39:33.641] - stdout: TRUE
[17:39:33.641] - signal: TRUE
[17:39:33.641] - resignal: FALSE
[17:39:33.641] - force: TRUE
[17:39:33.641] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.641] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.642]  - until=4
[17:39:33.642]  - relaying element #4
[17:39:33.642] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.642] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.642] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.642]  length: 0 (resolved future 4)
[17:39:33.642] Relaying remaining futures
[17:39:33.642] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.642] - nx: 4
[17:39:33.642] - relay: TRUE
[17:39:33.643] - stdout: TRUE
[17:39:33.643] - signal: TRUE
[17:39:33.643] - resignal: FALSE
[17:39:33.643] - force: TRUE
[17:39:33.645] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.645] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:33.645] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.645] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.645] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.646] resolve() on environment ... DONE
<environment: 0x55adf0145b00> 
Dimensions: c(1, 6)
[17:39:33.646] getGlobalsAndPackages() ...
[17:39:33.646] Searching for globals...
[17:39:33.647] 
[17:39:33.647] Searching for globals ... DONE
[17:39:33.647] - globals: [0] <none>
[17:39:33.647] getGlobalsAndPackages() ... DONE
[17:39:33.647] run() for ‘Future’ ...
[17:39:33.647] - state: ‘created’
[17:39:33.647] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.648] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.648]   - Field: ‘label’
[17:39:33.648]   - Field: ‘local’
[17:39:33.648]   - Field: ‘owner’
[17:39:33.648]   - Field: ‘envir’
[17:39:33.648]   - Field: ‘packages’
[17:39:33.648]   - Field: ‘gc’
[17:39:33.648]   - Field: ‘conditions’
[17:39:33.648]   - Field: ‘expr’
[17:39:33.649]   - Field: ‘uuid’
[17:39:33.649]   - Field: ‘seed’
[17:39:33.649]   - Field: ‘version’
[17:39:33.649]   - Field: ‘result’
[17:39:33.649]   - Field: ‘asynchronous’
[17:39:33.649]   - Field: ‘calls’
[17:39:33.649]   - Field: ‘globals’
[17:39:33.649]   - Field: ‘stdout’
[17:39:33.649]   - Field: ‘earlySignal’
[17:39:33.649]   - Field: ‘lazy’
[17:39:33.649]   - Field: ‘state’
[17:39:33.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.650] - Launch lazy future ...
[17:39:33.650] Packages needed by the future expression (n = 0): <none>
[17:39:33.650] Packages needed by future strategies (n = 0): <none>
[17:39:33.650] {
[17:39:33.650]     {
[17:39:33.650]         {
[17:39:33.650]             ...future.startTime <- base::Sys.time()
[17:39:33.650]             {
[17:39:33.650]                 {
[17:39:33.650]                   {
[17:39:33.650]                     base::local({
[17:39:33.650]                       has_future <- base::requireNamespace("future", 
[17:39:33.650]                         quietly = TRUE)
[17:39:33.650]                       if (has_future) {
[17:39:33.650]                         ns <- base::getNamespace("future")
[17:39:33.650]                         version <- ns[[".package"]][["version"]]
[17:39:33.650]                         if (is.null(version)) 
[17:39:33.650]                           version <- utils::packageVersion("future")
[17:39:33.650]                       }
[17:39:33.650]                       else {
[17:39:33.650]                         version <- NULL
[17:39:33.650]                       }
[17:39:33.650]                       if (!has_future || version < "1.8.0") {
[17:39:33.650]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.650]                           "", base::R.version$version.string), 
[17:39:33.650]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.650]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.650]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.650]                             "release", "version")], collapse = " "), 
[17:39:33.650]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.650]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.650]                           info)
[17:39:33.650]                         info <- base::paste(info, collapse = "; ")
[17:39:33.650]                         if (!has_future) {
[17:39:33.650]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.650]                             info)
[17:39:33.650]                         }
[17:39:33.650]                         else {
[17:39:33.650]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.650]                             info, version)
[17:39:33.650]                         }
[17:39:33.650]                         base::stop(msg)
[17:39:33.650]                       }
[17:39:33.650]                     })
[17:39:33.650]                   }
[17:39:33.650]                   ...future.strategy.old <- future::plan("list")
[17:39:33.650]                   options(future.plan = NULL)
[17:39:33.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.650]                 }
[17:39:33.650]                 ...future.workdir <- getwd()
[17:39:33.650]             }
[17:39:33.650]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.650]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.650]         }
[17:39:33.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.650]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.650]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.650]             base::names(...future.oldOptions))
[17:39:33.650]     }
[17:39:33.650]     if (FALSE) {
[17:39:33.650]     }
[17:39:33.650]     else {
[17:39:33.650]         if (TRUE) {
[17:39:33.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.650]                 open = "w")
[17:39:33.650]         }
[17:39:33.650]         else {
[17:39:33.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.650]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.650]         }
[17:39:33.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.650]             base::sink(type = "output", split = FALSE)
[17:39:33.650]             base::close(...future.stdout)
[17:39:33.650]         }, add = TRUE)
[17:39:33.650]     }
[17:39:33.650]     ...future.frame <- base::sys.nframe()
[17:39:33.650]     ...future.conditions <- base::list()
[17:39:33.650]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.650]     if (FALSE) {
[17:39:33.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.650]     }
[17:39:33.650]     ...future.result <- base::tryCatch({
[17:39:33.650]         base::withCallingHandlers({
[17:39:33.650]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.650]             future::FutureResult(value = ...future.value$value, 
[17:39:33.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.650]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.650]                     ...future.globalenv.names))
[17:39:33.650]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.650]         }, condition = base::local({
[17:39:33.650]             c <- base::c
[17:39:33.650]             inherits <- base::inherits
[17:39:33.650]             invokeRestart <- base::invokeRestart
[17:39:33.650]             length <- base::length
[17:39:33.650]             list <- base::list
[17:39:33.650]             seq.int <- base::seq.int
[17:39:33.650]             signalCondition <- base::signalCondition
[17:39:33.650]             sys.calls <- base::sys.calls
[17:39:33.650]             `[[` <- base::`[[`
[17:39:33.650]             `+` <- base::`+`
[17:39:33.650]             `<<-` <- base::`<<-`
[17:39:33.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.650]                   3L)]
[17:39:33.650]             }
[17:39:33.650]             function(cond) {
[17:39:33.650]                 is_error <- inherits(cond, "error")
[17:39:33.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.650]                   NULL)
[17:39:33.650]                 if (is_error) {
[17:39:33.650]                   sessionInformation <- function() {
[17:39:33.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.650]                       search = base::search(), system = base::Sys.info())
[17:39:33.650]                   }
[17:39:33.650]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.650]                     cond$call), session = sessionInformation(), 
[17:39:33.650]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.650]                   signalCondition(cond)
[17:39:33.650]                 }
[17:39:33.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.650]                 "immediateCondition"))) {
[17:39:33.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.650]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.650]                   if (TRUE && !signal) {
[17:39:33.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.650]                     {
[17:39:33.650]                       inherits <- base::inherits
[17:39:33.650]                       invokeRestart <- base::invokeRestart
[17:39:33.650]                       is.null <- base::is.null
[17:39:33.650]                       muffled <- FALSE
[17:39:33.650]                       if (inherits(cond, "message")) {
[17:39:33.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.650]                         if (muffled) 
[17:39:33.650]                           invokeRestart("muffleMessage")
[17:39:33.650]                       }
[17:39:33.650]                       else if (inherits(cond, "warning")) {
[17:39:33.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.650]                         if (muffled) 
[17:39:33.650]                           invokeRestart("muffleWarning")
[17:39:33.650]                       }
[17:39:33.650]                       else if (inherits(cond, "condition")) {
[17:39:33.650]                         if (!is.null(pattern)) {
[17:39:33.650]                           computeRestarts <- base::computeRestarts
[17:39:33.650]                           grepl <- base::grepl
[17:39:33.650]                           restarts <- computeRestarts(cond)
[17:39:33.650]                           for (restart in restarts) {
[17:39:33.650]                             name <- restart$name
[17:39:33.650]                             if (is.null(name)) 
[17:39:33.650]                               next
[17:39:33.650]                             if (!grepl(pattern, name)) 
[17:39:33.650]                               next
[17:39:33.650]                             invokeRestart(restart)
[17:39:33.650]                             muffled <- TRUE
[17:39:33.650]                             break
[17:39:33.650]                           }
[17:39:33.650]                         }
[17:39:33.650]                       }
[17:39:33.650]                       invisible(muffled)
[17:39:33.650]                     }
[17:39:33.650]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.650]                   }
[17:39:33.650]                 }
[17:39:33.650]                 else {
[17:39:33.650]                   if (TRUE) {
[17:39:33.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.650]                     {
[17:39:33.650]                       inherits <- base::inherits
[17:39:33.650]                       invokeRestart <- base::invokeRestart
[17:39:33.650]                       is.null <- base::is.null
[17:39:33.650]                       muffled <- FALSE
[17:39:33.650]                       if (inherits(cond, "message")) {
[17:39:33.650]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.650]                         if (muffled) 
[17:39:33.650]                           invokeRestart("muffleMessage")
[17:39:33.650]                       }
[17:39:33.650]                       else if (inherits(cond, "warning")) {
[17:39:33.650]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.650]                         if (muffled) 
[17:39:33.650]                           invokeRestart("muffleWarning")
[17:39:33.650]                       }
[17:39:33.650]                       else if (inherits(cond, "condition")) {
[17:39:33.650]                         if (!is.null(pattern)) {
[17:39:33.650]                           computeRestarts <- base::computeRestarts
[17:39:33.650]                           grepl <- base::grepl
[17:39:33.650]                           restarts <- computeRestarts(cond)
[17:39:33.650]                           for (restart in restarts) {
[17:39:33.650]                             name <- restart$name
[17:39:33.650]                             if (is.null(name)) 
[17:39:33.650]                               next
[17:39:33.650]                             if (!grepl(pattern, name)) 
[17:39:33.650]                               next
[17:39:33.650]                             invokeRestart(restart)
[17:39:33.650]                             muffled <- TRUE
[17:39:33.650]                             break
[17:39:33.650]                           }
[17:39:33.650]                         }
[17:39:33.650]                       }
[17:39:33.650]                       invisible(muffled)
[17:39:33.650]                     }
[17:39:33.650]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.650]                   }
[17:39:33.650]                 }
[17:39:33.650]             }
[17:39:33.650]         }))
[17:39:33.650]     }, error = function(ex) {
[17:39:33.650]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.650]                 ...future.rng), started = ...future.startTime, 
[17:39:33.650]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.650]             version = "1.8"), class = "FutureResult")
[17:39:33.650]     }, finally = {
[17:39:33.650]         if (!identical(...future.workdir, getwd())) 
[17:39:33.650]             setwd(...future.workdir)
[17:39:33.650]         {
[17:39:33.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.650]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.650]             }
[17:39:33.650]             base::options(...future.oldOptions)
[17:39:33.650]             if (.Platform$OS.type == "windows") {
[17:39:33.650]                 old_names <- names(...future.oldEnvVars)
[17:39:33.650]                 envs <- base::Sys.getenv()
[17:39:33.650]                 names <- names(envs)
[17:39:33.650]                 common <- intersect(names, old_names)
[17:39:33.650]                 added <- setdiff(names, old_names)
[17:39:33.650]                 removed <- setdiff(old_names, names)
[17:39:33.650]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.650]                   envs[common]]
[17:39:33.650]                 NAMES <- toupper(changed)
[17:39:33.650]                 args <- list()
[17:39:33.650]                 for (kk in seq_along(NAMES)) {
[17:39:33.650]                   name <- changed[[kk]]
[17:39:33.650]                   NAME <- NAMES[[kk]]
[17:39:33.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.650]                     next
[17:39:33.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.650]                 }
[17:39:33.650]                 NAMES <- toupper(added)
[17:39:33.650]                 for (kk in seq_along(NAMES)) {
[17:39:33.650]                   name <- added[[kk]]
[17:39:33.650]                   NAME <- NAMES[[kk]]
[17:39:33.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.650]                     next
[17:39:33.650]                   args[[name]] <- ""
[17:39:33.650]                 }
[17:39:33.650]                 NAMES <- toupper(removed)
[17:39:33.650]                 for (kk in seq_along(NAMES)) {
[17:39:33.650]                   name <- removed[[kk]]
[17:39:33.650]                   NAME <- NAMES[[kk]]
[17:39:33.650]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.650]                     next
[17:39:33.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.650]                 }
[17:39:33.650]                 if (length(args) > 0) 
[17:39:33.650]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.650]             }
[17:39:33.650]             else {
[17:39:33.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.650]             }
[17:39:33.650]             {
[17:39:33.650]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.650]                   0L) {
[17:39:33.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.650]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.650]                   base::options(opts)
[17:39:33.650]                 }
[17:39:33.650]                 {
[17:39:33.650]                   {
[17:39:33.650]                     NULL
[17:39:33.650]                     RNGkind("Mersenne-Twister")
[17:39:33.650]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.650]                       inherits = FALSE)
[17:39:33.650]                   }
[17:39:33.650]                   options(future.plan = NULL)
[17:39:33.650]                   if (is.na(NA_character_)) 
[17:39:33.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.650]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.650]                     .init = FALSE)
[17:39:33.650]                 }
[17:39:33.650]             }
[17:39:33.650]         }
[17:39:33.650]     })
[17:39:33.650]     if (TRUE) {
[17:39:33.650]         base::sink(type = "output", split = FALSE)
[17:39:33.650]         if (TRUE) {
[17:39:33.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.650]         }
[17:39:33.650]         else {
[17:39:33.650]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.650]         }
[17:39:33.650]         base::close(...future.stdout)
[17:39:33.650]         ...future.stdout <- NULL
[17:39:33.650]     }
[17:39:33.650]     ...future.result$conditions <- ...future.conditions
[17:39:33.650]     ...future.result$finished <- base::Sys.time()
[17:39:33.650]     ...future.result
[17:39:33.650] }
[17:39:33.652] plan(): Setting new future strategy stack:
[17:39:33.652] List of future strategies:
[17:39:33.652] 1. sequential:
[17:39:33.652]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.652]    - tweaked: FALSE
[17:39:33.652]    - call: NULL
[17:39:33.653] plan(): nbrOfWorkers() = 1
[17:39:33.653] plan(): Setting new future strategy stack:
[17:39:33.653] List of future strategies:
[17:39:33.653] 1. sequential:
[17:39:33.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.653]    - tweaked: FALSE
[17:39:33.653]    - call: plan(strategy)
[17:39:33.654] plan(): nbrOfWorkers() = 1
[17:39:33.654] SequentialFuture started (and completed)
[17:39:33.654] - Launch lazy future ... done
[17:39:33.654] run() for ‘SequentialFuture’ ... done
[17:39:33.654] getGlobalsAndPackages() ...
[17:39:33.654] Searching for globals...
[17:39:33.655] 
[17:39:33.655] Searching for globals ... DONE
[17:39:33.655] - globals: [0] <none>
[17:39:33.655] getGlobalsAndPackages() ... DONE
[17:39:33.655] run() for ‘Future’ ...
[17:39:33.655] - state: ‘created’
[17:39:33.656] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.656] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.656]   - Field: ‘label’
[17:39:33.656]   - Field: ‘local’
[17:39:33.656]   - Field: ‘owner’
[17:39:33.656]   - Field: ‘envir’
[17:39:33.656]   - Field: ‘packages’
[17:39:33.656]   - Field: ‘gc’
[17:39:33.657]   - Field: ‘conditions’
[17:39:33.657]   - Field: ‘expr’
[17:39:33.657]   - Field: ‘uuid’
[17:39:33.657]   - Field: ‘seed’
[17:39:33.657]   - Field: ‘version’
[17:39:33.657]   - Field: ‘result’
[17:39:33.657]   - Field: ‘asynchronous’
[17:39:33.657]   - Field: ‘calls’
[17:39:33.657]   - Field: ‘globals’
[17:39:33.657]   - Field: ‘stdout’
[17:39:33.657]   - Field: ‘earlySignal’
[17:39:33.658]   - Field: ‘lazy’
[17:39:33.658]   - Field: ‘state’
[17:39:33.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.658] - Launch lazy future ...
[17:39:33.658] Packages needed by the future expression (n = 0): <none>
[17:39:33.658] Packages needed by future strategies (n = 0): <none>
[17:39:33.658] {
[17:39:33.658]     {
[17:39:33.658]         {
[17:39:33.658]             ...future.startTime <- base::Sys.time()
[17:39:33.658]             {
[17:39:33.658]                 {
[17:39:33.658]                   {
[17:39:33.658]                     base::local({
[17:39:33.658]                       has_future <- base::requireNamespace("future", 
[17:39:33.658]                         quietly = TRUE)
[17:39:33.658]                       if (has_future) {
[17:39:33.658]                         ns <- base::getNamespace("future")
[17:39:33.658]                         version <- ns[[".package"]][["version"]]
[17:39:33.658]                         if (is.null(version)) 
[17:39:33.658]                           version <- utils::packageVersion("future")
[17:39:33.658]                       }
[17:39:33.658]                       else {
[17:39:33.658]                         version <- NULL
[17:39:33.658]                       }
[17:39:33.658]                       if (!has_future || version < "1.8.0") {
[17:39:33.658]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.658]                           "", base::R.version$version.string), 
[17:39:33.658]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.658]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.658]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.658]                             "release", "version")], collapse = " "), 
[17:39:33.658]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.658]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.658]                           info)
[17:39:33.658]                         info <- base::paste(info, collapse = "; ")
[17:39:33.658]                         if (!has_future) {
[17:39:33.658]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.658]                             info)
[17:39:33.658]                         }
[17:39:33.658]                         else {
[17:39:33.658]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.658]                             info, version)
[17:39:33.658]                         }
[17:39:33.658]                         base::stop(msg)
[17:39:33.658]                       }
[17:39:33.658]                     })
[17:39:33.658]                   }
[17:39:33.658]                   ...future.strategy.old <- future::plan("list")
[17:39:33.658]                   options(future.plan = NULL)
[17:39:33.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.658]                 }
[17:39:33.658]                 ...future.workdir <- getwd()
[17:39:33.658]             }
[17:39:33.658]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.658]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.658]         }
[17:39:33.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.658]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.658]             base::names(...future.oldOptions))
[17:39:33.658]     }
[17:39:33.658]     if (FALSE) {
[17:39:33.658]     }
[17:39:33.658]     else {
[17:39:33.658]         if (TRUE) {
[17:39:33.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.658]                 open = "w")
[17:39:33.658]         }
[17:39:33.658]         else {
[17:39:33.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.658]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.658]         }
[17:39:33.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.658]             base::sink(type = "output", split = FALSE)
[17:39:33.658]             base::close(...future.stdout)
[17:39:33.658]         }, add = TRUE)
[17:39:33.658]     }
[17:39:33.658]     ...future.frame <- base::sys.nframe()
[17:39:33.658]     ...future.conditions <- base::list()
[17:39:33.658]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.658]     if (FALSE) {
[17:39:33.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.658]     }
[17:39:33.658]     ...future.result <- base::tryCatch({
[17:39:33.658]         base::withCallingHandlers({
[17:39:33.658]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.658]             future::FutureResult(value = ...future.value$value, 
[17:39:33.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.658]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.658]                     ...future.globalenv.names))
[17:39:33.658]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.658]         }, condition = base::local({
[17:39:33.658]             c <- base::c
[17:39:33.658]             inherits <- base::inherits
[17:39:33.658]             invokeRestart <- base::invokeRestart
[17:39:33.658]             length <- base::length
[17:39:33.658]             list <- base::list
[17:39:33.658]             seq.int <- base::seq.int
[17:39:33.658]             signalCondition <- base::signalCondition
[17:39:33.658]             sys.calls <- base::sys.calls
[17:39:33.658]             `[[` <- base::`[[`
[17:39:33.658]             `+` <- base::`+`
[17:39:33.658]             `<<-` <- base::`<<-`
[17:39:33.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.658]                   3L)]
[17:39:33.658]             }
[17:39:33.658]             function(cond) {
[17:39:33.658]                 is_error <- inherits(cond, "error")
[17:39:33.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.658]                   NULL)
[17:39:33.658]                 if (is_error) {
[17:39:33.658]                   sessionInformation <- function() {
[17:39:33.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.658]                       search = base::search(), system = base::Sys.info())
[17:39:33.658]                   }
[17:39:33.658]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.658]                     cond$call), session = sessionInformation(), 
[17:39:33.658]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.658]                   signalCondition(cond)
[17:39:33.658]                 }
[17:39:33.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.658]                 "immediateCondition"))) {
[17:39:33.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.658]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.658]                   if (TRUE && !signal) {
[17:39:33.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.658]                     {
[17:39:33.658]                       inherits <- base::inherits
[17:39:33.658]                       invokeRestart <- base::invokeRestart
[17:39:33.658]                       is.null <- base::is.null
[17:39:33.658]                       muffled <- FALSE
[17:39:33.658]                       if (inherits(cond, "message")) {
[17:39:33.658]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.658]                         if (muffled) 
[17:39:33.658]                           invokeRestart("muffleMessage")
[17:39:33.658]                       }
[17:39:33.658]                       else if (inherits(cond, "warning")) {
[17:39:33.658]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.658]                         if (muffled) 
[17:39:33.658]                           invokeRestart("muffleWarning")
[17:39:33.658]                       }
[17:39:33.658]                       else if (inherits(cond, "condition")) {
[17:39:33.658]                         if (!is.null(pattern)) {
[17:39:33.658]                           computeRestarts <- base::computeRestarts
[17:39:33.658]                           grepl <- base::grepl
[17:39:33.658]                           restarts <- computeRestarts(cond)
[17:39:33.658]                           for (restart in restarts) {
[17:39:33.658]                             name <- restart$name
[17:39:33.658]                             if (is.null(name)) 
[17:39:33.658]                               next
[17:39:33.658]                             if (!grepl(pattern, name)) 
[17:39:33.658]                               next
[17:39:33.658]                             invokeRestart(restart)
[17:39:33.658]                             muffled <- TRUE
[17:39:33.658]                             break
[17:39:33.658]                           }
[17:39:33.658]                         }
[17:39:33.658]                       }
[17:39:33.658]                       invisible(muffled)
[17:39:33.658]                     }
[17:39:33.658]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.658]                   }
[17:39:33.658]                 }
[17:39:33.658]                 else {
[17:39:33.658]                   if (TRUE) {
[17:39:33.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.658]                     {
[17:39:33.658]                       inherits <- base::inherits
[17:39:33.658]                       invokeRestart <- base::invokeRestart
[17:39:33.658]                       is.null <- base::is.null
[17:39:33.658]                       muffled <- FALSE
[17:39:33.658]                       if (inherits(cond, "message")) {
[17:39:33.658]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.658]                         if (muffled) 
[17:39:33.658]                           invokeRestart("muffleMessage")
[17:39:33.658]                       }
[17:39:33.658]                       else if (inherits(cond, "warning")) {
[17:39:33.658]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.658]                         if (muffled) 
[17:39:33.658]                           invokeRestart("muffleWarning")
[17:39:33.658]                       }
[17:39:33.658]                       else if (inherits(cond, "condition")) {
[17:39:33.658]                         if (!is.null(pattern)) {
[17:39:33.658]                           computeRestarts <- base::computeRestarts
[17:39:33.658]                           grepl <- base::grepl
[17:39:33.658]                           restarts <- computeRestarts(cond)
[17:39:33.658]                           for (restart in restarts) {
[17:39:33.658]                             name <- restart$name
[17:39:33.658]                             if (is.null(name)) 
[17:39:33.658]                               next
[17:39:33.658]                             if (!grepl(pattern, name)) 
[17:39:33.658]                               next
[17:39:33.658]                             invokeRestart(restart)
[17:39:33.658]                             muffled <- TRUE
[17:39:33.658]                             break
[17:39:33.658]                           }
[17:39:33.658]                         }
[17:39:33.658]                       }
[17:39:33.658]                       invisible(muffled)
[17:39:33.658]                     }
[17:39:33.658]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.658]                   }
[17:39:33.658]                 }
[17:39:33.658]             }
[17:39:33.658]         }))
[17:39:33.658]     }, error = function(ex) {
[17:39:33.658]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.658]                 ...future.rng), started = ...future.startTime, 
[17:39:33.658]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.658]             version = "1.8"), class = "FutureResult")
[17:39:33.658]     }, finally = {
[17:39:33.658]         if (!identical(...future.workdir, getwd())) 
[17:39:33.658]             setwd(...future.workdir)
[17:39:33.658]         {
[17:39:33.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.658]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.658]             }
[17:39:33.658]             base::options(...future.oldOptions)
[17:39:33.658]             if (.Platform$OS.type == "windows") {
[17:39:33.658]                 old_names <- names(...future.oldEnvVars)
[17:39:33.658]                 envs <- base::Sys.getenv()
[17:39:33.658]                 names <- names(envs)
[17:39:33.658]                 common <- intersect(names, old_names)
[17:39:33.658]                 added <- setdiff(names, old_names)
[17:39:33.658]                 removed <- setdiff(old_names, names)
[17:39:33.658]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.658]                   envs[common]]
[17:39:33.658]                 NAMES <- toupper(changed)
[17:39:33.658]                 args <- list()
[17:39:33.658]                 for (kk in seq_along(NAMES)) {
[17:39:33.658]                   name <- changed[[kk]]
[17:39:33.658]                   NAME <- NAMES[[kk]]
[17:39:33.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.658]                     next
[17:39:33.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.658]                 }
[17:39:33.658]                 NAMES <- toupper(added)
[17:39:33.658]                 for (kk in seq_along(NAMES)) {
[17:39:33.658]                   name <- added[[kk]]
[17:39:33.658]                   NAME <- NAMES[[kk]]
[17:39:33.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.658]                     next
[17:39:33.658]                   args[[name]] <- ""
[17:39:33.658]                 }
[17:39:33.658]                 NAMES <- toupper(removed)
[17:39:33.658]                 for (kk in seq_along(NAMES)) {
[17:39:33.658]                   name <- removed[[kk]]
[17:39:33.658]                   NAME <- NAMES[[kk]]
[17:39:33.658]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.658]                     next
[17:39:33.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.658]                 }
[17:39:33.658]                 if (length(args) > 0) 
[17:39:33.658]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.658]             }
[17:39:33.658]             else {
[17:39:33.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.658]             }
[17:39:33.658]             {
[17:39:33.658]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.658]                   0L) {
[17:39:33.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.658]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.658]                   base::options(opts)
[17:39:33.658]                 }
[17:39:33.658]                 {
[17:39:33.658]                   {
[17:39:33.658]                     NULL
[17:39:33.658]                     RNGkind("Mersenne-Twister")
[17:39:33.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.658]                       inherits = FALSE)
[17:39:33.658]                   }
[17:39:33.658]                   options(future.plan = NULL)
[17:39:33.658]                   if (is.na(NA_character_)) 
[17:39:33.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.658]                     .init = FALSE)
[17:39:33.658]                 }
[17:39:33.658]             }
[17:39:33.658]         }
[17:39:33.658]     })
[17:39:33.658]     if (TRUE) {
[17:39:33.658]         base::sink(type = "output", split = FALSE)
[17:39:33.658]         if (TRUE) {
[17:39:33.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.658]         }
[17:39:33.658]         else {
[17:39:33.658]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.658]         }
[17:39:33.658]         base::close(...future.stdout)
[17:39:33.658]         ...future.stdout <- NULL
[17:39:33.658]     }
[17:39:33.658]     ...future.result$conditions <- ...future.conditions
[17:39:33.658]     ...future.result$finished <- base::Sys.time()
[17:39:33.658]     ...future.result
[17:39:33.658] }
[17:39:33.660] plan(): Setting new future strategy stack:
[17:39:33.660] List of future strategies:
[17:39:33.660] 1. sequential:
[17:39:33.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.660]    - tweaked: FALSE
[17:39:33.660]    - call: NULL
[17:39:33.661] plan(): nbrOfWorkers() = 1
[17:39:33.661] plan(): Setting new future strategy stack:
[17:39:33.662] List of future strategies:
[17:39:33.662] 1. sequential:
[17:39:33.662]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.662]    - tweaked: FALSE
[17:39:33.662]    - call: plan(strategy)
[17:39:33.662] plan(): nbrOfWorkers() = 1
[17:39:33.662] SequentialFuture started (and completed)
[17:39:33.662] - Launch lazy future ... done
[17:39:33.662] run() for ‘SequentialFuture’ ... done
[17:39:33.663] getGlobalsAndPackages() ...
[17:39:33.663] Searching for globals...
[17:39:33.663] - globals found: [1] ‘{’
[17:39:33.663] Searching for globals ... DONE
[17:39:33.663] Resolving globals: FALSE
[17:39:33.664] 
[17:39:33.664] 
[17:39:33.664] getGlobalsAndPackages() ... DONE
[17:39:33.664] run() for ‘Future’ ...
[17:39:33.664] - state: ‘created’
[17:39:33.664] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.665]   - Field: ‘label’
[17:39:33.665]   - Field: ‘local’
[17:39:33.665]   - Field: ‘owner’
[17:39:33.665]   - Field: ‘envir’
[17:39:33.665]   - Field: ‘packages’
[17:39:33.665]   - Field: ‘gc’
[17:39:33.665]   - Field: ‘conditions’
[17:39:33.666]   - Field: ‘expr’
[17:39:33.666]   - Field: ‘uuid’
[17:39:33.666]   - Field: ‘seed’
[17:39:33.666]   - Field: ‘version’
[17:39:33.666]   - Field: ‘result’
[17:39:33.666]   - Field: ‘asynchronous’
[17:39:33.666]   - Field: ‘calls’
[17:39:33.666]   - Field: ‘globals’
[17:39:33.666]   - Field: ‘stdout’
[17:39:33.666]   - Field: ‘earlySignal’
[17:39:33.666]   - Field: ‘lazy’
[17:39:33.666]   - Field: ‘state’
[17:39:33.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.667] - Launch lazy future ...
[17:39:33.667] Packages needed by the future expression (n = 0): <none>
[17:39:33.667] Packages needed by future strategies (n = 0): <none>
[17:39:33.667] {
[17:39:33.667]     {
[17:39:33.667]         {
[17:39:33.667]             ...future.startTime <- base::Sys.time()
[17:39:33.667]             {
[17:39:33.667]                 {
[17:39:33.667]                   {
[17:39:33.667]                     base::local({
[17:39:33.667]                       has_future <- base::requireNamespace("future", 
[17:39:33.667]                         quietly = TRUE)
[17:39:33.667]                       if (has_future) {
[17:39:33.667]                         ns <- base::getNamespace("future")
[17:39:33.667]                         version <- ns[[".package"]][["version"]]
[17:39:33.667]                         if (is.null(version)) 
[17:39:33.667]                           version <- utils::packageVersion("future")
[17:39:33.667]                       }
[17:39:33.667]                       else {
[17:39:33.667]                         version <- NULL
[17:39:33.667]                       }
[17:39:33.667]                       if (!has_future || version < "1.8.0") {
[17:39:33.667]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.667]                           "", base::R.version$version.string), 
[17:39:33.667]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.667]                             "release", "version")], collapse = " "), 
[17:39:33.667]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.667]                           info)
[17:39:33.667]                         info <- base::paste(info, collapse = "; ")
[17:39:33.667]                         if (!has_future) {
[17:39:33.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.667]                             info)
[17:39:33.667]                         }
[17:39:33.667]                         else {
[17:39:33.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.667]                             info, version)
[17:39:33.667]                         }
[17:39:33.667]                         base::stop(msg)
[17:39:33.667]                       }
[17:39:33.667]                     })
[17:39:33.667]                   }
[17:39:33.667]                   ...future.strategy.old <- future::plan("list")
[17:39:33.667]                   options(future.plan = NULL)
[17:39:33.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.667]                 }
[17:39:33.667]                 ...future.workdir <- getwd()
[17:39:33.667]             }
[17:39:33.667]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.667]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.667]         }
[17:39:33.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.667]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.667]             base::names(...future.oldOptions))
[17:39:33.667]     }
[17:39:33.667]     if (FALSE) {
[17:39:33.667]     }
[17:39:33.667]     else {
[17:39:33.667]         if (TRUE) {
[17:39:33.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.667]                 open = "w")
[17:39:33.667]         }
[17:39:33.667]         else {
[17:39:33.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.667]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.667]         }
[17:39:33.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.667]             base::sink(type = "output", split = FALSE)
[17:39:33.667]             base::close(...future.stdout)
[17:39:33.667]         }, add = TRUE)
[17:39:33.667]     }
[17:39:33.667]     ...future.frame <- base::sys.nframe()
[17:39:33.667]     ...future.conditions <- base::list()
[17:39:33.667]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.667]     if (FALSE) {
[17:39:33.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.667]     }
[17:39:33.667]     ...future.result <- base::tryCatch({
[17:39:33.667]         base::withCallingHandlers({
[17:39:33.667]             ...future.value <- base::withVisible(base::local({
[17:39:33.667]                 4
[17:39:33.667]             }))
[17:39:33.667]             future::FutureResult(value = ...future.value$value, 
[17:39:33.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.667]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.667]                     ...future.globalenv.names))
[17:39:33.667]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.667]         }, condition = base::local({
[17:39:33.667]             c <- base::c
[17:39:33.667]             inherits <- base::inherits
[17:39:33.667]             invokeRestart <- base::invokeRestart
[17:39:33.667]             length <- base::length
[17:39:33.667]             list <- base::list
[17:39:33.667]             seq.int <- base::seq.int
[17:39:33.667]             signalCondition <- base::signalCondition
[17:39:33.667]             sys.calls <- base::sys.calls
[17:39:33.667]             `[[` <- base::`[[`
[17:39:33.667]             `+` <- base::`+`
[17:39:33.667]             `<<-` <- base::`<<-`
[17:39:33.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.667]                   3L)]
[17:39:33.667]             }
[17:39:33.667]             function(cond) {
[17:39:33.667]                 is_error <- inherits(cond, "error")
[17:39:33.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.667]                   NULL)
[17:39:33.667]                 if (is_error) {
[17:39:33.667]                   sessionInformation <- function() {
[17:39:33.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.667]                       search = base::search(), system = base::Sys.info())
[17:39:33.667]                   }
[17:39:33.667]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.667]                     cond$call), session = sessionInformation(), 
[17:39:33.667]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.667]                   signalCondition(cond)
[17:39:33.667]                 }
[17:39:33.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.667]                 "immediateCondition"))) {
[17:39:33.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.667]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.667]                   if (TRUE && !signal) {
[17:39:33.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.667]                     {
[17:39:33.667]                       inherits <- base::inherits
[17:39:33.667]                       invokeRestart <- base::invokeRestart
[17:39:33.667]                       is.null <- base::is.null
[17:39:33.667]                       muffled <- FALSE
[17:39:33.667]                       if (inherits(cond, "message")) {
[17:39:33.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.667]                         if (muffled) 
[17:39:33.667]                           invokeRestart("muffleMessage")
[17:39:33.667]                       }
[17:39:33.667]                       else if (inherits(cond, "warning")) {
[17:39:33.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.667]                         if (muffled) 
[17:39:33.667]                           invokeRestart("muffleWarning")
[17:39:33.667]                       }
[17:39:33.667]                       else if (inherits(cond, "condition")) {
[17:39:33.667]                         if (!is.null(pattern)) {
[17:39:33.667]                           computeRestarts <- base::computeRestarts
[17:39:33.667]                           grepl <- base::grepl
[17:39:33.667]                           restarts <- computeRestarts(cond)
[17:39:33.667]                           for (restart in restarts) {
[17:39:33.667]                             name <- restart$name
[17:39:33.667]                             if (is.null(name)) 
[17:39:33.667]                               next
[17:39:33.667]                             if (!grepl(pattern, name)) 
[17:39:33.667]                               next
[17:39:33.667]                             invokeRestart(restart)
[17:39:33.667]                             muffled <- TRUE
[17:39:33.667]                             break
[17:39:33.667]                           }
[17:39:33.667]                         }
[17:39:33.667]                       }
[17:39:33.667]                       invisible(muffled)
[17:39:33.667]                     }
[17:39:33.667]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.667]                   }
[17:39:33.667]                 }
[17:39:33.667]                 else {
[17:39:33.667]                   if (TRUE) {
[17:39:33.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.667]                     {
[17:39:33.667]                       inherits <- base::inherits
[17:39:33.667]                       invokeRestart <- base::invokeRestart
[17:39:33.667]                       is.null <- base::is.null
[17:39:33.667]                       muffled <- FALSE
[17:39:33.667]                       if (inherits(cond, "message")) {
[17:39:33.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.667]                         if (muffled) 
[17:39:33.667]                           invokeRestart("muffleMessage")
[17:39:33.667]                       }
[17:39:33.667]                       else if (inherits(cond, "warning")) {
[17:39:33.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.667]                         if (muffled) 
[17:39:33.667]                           invokeRestart("muffleWarning")
[17:39:33.667]                       }
[17:39:33.667]                       else if (inherits(cond, "condition")) {
[17:39:33.667]                         if (!is.null(pattern)) {
[17:39:33.667]                           computeRestarts <- base::computeRestarts
[17:39:33.667]                           grepl <- base::grepl
[17:39:33.667]                           restarts <- computeRestarts(cond)
[17:39:33.667]                           for (restart in restarts) {
[17:39:33.667]                             name <- restart$name
[17:39:33.667]                             if (is.null(name)) 
[17:39:33.667]                               next
[17:39:33.667]                             if (!grepl(pattern, name)) 
[17:39:33.667]                               next
[17:39:33.667]                             invokeRestart(restart)
[17:39:33.667]                             muffled <- TRUE
[17:39:33.667]                             break
[17:39:33.667]                           }
[17:39:33.667]                         }
[17:39:33.667]                       }
[17:39:33.667]                       invisible(muffled)
[17:39:33.667]                     }
[17:39:33.667]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.667]                   }
[17:39:33.667]                 }
[17:39:33.667]             }
[17:39:33.667]         }))
[17:39:33.667]     }, error = function(ex) {
[17:39:33.667]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.667]                 ...future.rng), started = ...future.startTime, 
[17:39:33.667]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.667]             version = "1.8"), class = "FutureResult")
[17:39:33.667]     }, finally = {
[17:39:33.667]         if (!identical(...future.workdir, getwd())) 
[17:39:33.667]             setwd(...future.workdir)
[17:39:33.667]         {
[17:39:33.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.667]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.667]             }
[17:39:33.667]             base::options(...future.oldOptions)
[17:39:33.667]             if (.Platform$OS.type == "windows") {
[17:39:33.667]                 old_names <- names(...future.oldEnvVars)
[17:39:33.667]                 envs <- base::Sys.getenv()
[17:39:33.667]                 names <- names(envs)
[17:39:33.667]                 common <- intersect(names, old_names)
[17:39:33.667]                 added <- setdiff(names, old_names)
[17:39:33.667]                 removed <- setdiff(old_names, names)
[17:39:33.667]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.667]                   envs[common]]
[17:39:33.667]                 NAMES <- toupper(changed)
[17:39:33.667]                 args <- list()
[17:39:33.667]                 for (kk in seq_along(NAMES)) {
[17:39:33.667]                   name <- changed[[kk]]
[17:39:33.667]                   NAME <- NAMES[[kk]]
[17:39:33.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.667]                     next
[17:39:33.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.667]                 }
[17:39:33.667]                 NAMES <- toupper(added)
[17:39:33.667]                 for (kk in seq_along(NAMES)) {
[17:39:33.667]                   name <- added[[kk]]
[17:39:33.667]                   NAME <- NAMES[[kk]]
[17:39:33.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.667]                     next
[17:39:33.667]                   args[[name]] <- ""
[17:39:33.667]                 }
[17:39:33.667]                 NAMES <- toupper(removed)
[17:39:33.667]                 for (kk in seq_along(NAMES)) {
[17:39:33.667]                   name <- removed[[kk]]
[17:39:33.667]                   NAME <- NAMES[[kk]]
[17:39:33.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.667]                     next
[17:39:33.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.667]                 }
[17:39:33.667]                 if (length(args) > 0) 
[17:39:33.667]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.667]             }
[17:39:33.667]             else {
[17:39:33.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.667]             }
[17:39:33.667]             {
[17:39:33.667]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.667]                   0L) {
[17:39:33.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.667]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.667]                   base::options(opts)
[17:39:33.667]                 }
[17:39:33.667]                 {
[17:39:33.667]                   {
[17:39:33.667]                     NULL
[17:39:33.667]                     RNGkind("Mersenne-Twister")
[17:39:33.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.667]                       inherits = FALSE)
[17:39:33.667]                   }
[17:39:33.667]                   options(future.plan = NULL)
[17:39:33.667]                   if (is.na(NA_character_)) 
[17:39:33.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.667]                     .init = FALSE)
[17:39:33.667]                 }
[17:39:33.667]             }
[17:39:33.667]         }
[17:39:33.667]     })
[17:39:33.667]     if (TRUE) {
[17:39:33.667]         base::sink(type = "output", split = FALSE)
[17:39:33.667]         if (TRUE) {
[17:39:33.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.667]         }
[17:39:33.667]         else {
[17:39:33.667]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.667]         }
[17:39:33.667]         base::close(...future.stdout)
[17:39:33.667]         ...future.stdout <- NULL
[17:39:33.667]     }
[17:39:33.667]     ...future.result$conditions <- ...future.conditions
[17:39:33.667]     ...future.result$finished <- base::Sys.time()
[17:39:33.667]     ...future.result
[17:39:33.667] }
[17:39:33.669] plan(): Setting new future strategy stack:
[17:39:33.669] List of future strategies:
[17:39:33.669] 1. sequential:
[17:39:33.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.669]    - tweaked: FALSE
[17:39:33.669]    - call: NULL
[17:39:33.670] plan(): nbrOfWorkers() = 1
[17:39:33.670] plan(): Setting new future strategy stack:
[17:39:33.670] List of future strategies:
[17:39:33.670] 1. sequential:
[17:39:33.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.670]    - tweaked: FALSE
[17:39:33.670]    - call: plan(strategy)
[17:39:33.671] plan(): nbrOfWorkers() = 1
[17:39:33.671] SequentialFuture started (and completed)
[17:39:33.671] - Launch lazy future ... done
[17:39:33.671] run() for ‘SequentialFuture’ ... done
<environment: 0x55adee9c76f0> 
<environment: 0x55adf04f41c8> 
[17:39:33.672] resolved() for ‘SequentialFuture’ ...
[17:39:33.673] - state: ‘finished’
[17:39:33.673] - run: TRUE
[17:39:33.673] - result: ‘FutureResult’
[17:39:33.673] resolved() for ‘SequentialFuture’ ... done
[17:39:33.673] resolved() for ‘SequentialFuture’ ...
[17:39:33.673] - state: ‘finished’
[17:39:33.673] - run: TRUE
[17:39:33.673] - result: ‘FutureResult’
[17:39:33.673] resolved() for ‘SequentialFuture’ ... done
[17:39:33.673] resolved() for ‘SequentialFuture’ ...
[17:39:33.673] - state: ‘finished’
[17:39:33.674] - run: TRUE
[17:39:33.674] - result: ‘FutureResult’
[17:39:33.674] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:33.677] resolve() on environment ...
[17:39:33.677]  recursive: 0
[17:39:33.677]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:33.677] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.678] - nx: 4
[17:39:33.678] - relay: TRUE
[17:39:33.678] - stdout: TRUE
[17:39:33.678] - signal: TRUE
[17:39:33.678] - resignal: FALSE
[17:39:33.678] - force: TRUE
[17:39:33.678] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.678] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.678]  - until=2
[17:39:33.678]  - relaying element #2
[17:39:33.678] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.678] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.679] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.679]  length: 3 (resolved future 1)
[17:39:33.679] resolved() for ‘SequentialFuture’ ...
[17:39:33.679] - state: ‘finished’
[17:39:33.679] - run: TRUE
[17:39:33.679] - result: ‘FutureResult’
[17:39:33.679] resolved() for ‘SequentialFuture’ ... done
[17:39:33.679] Future #2
[17:39:33.679] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.679] - nx: 4
[17:39:33.680] - relay: TRUE
[17:39:33.680] - stdout: TRUE
[17:39:33.680] - signal: TRUE
[17:39:33.680] - resignal: FALSE
[17:39:33.680] - force: TRUE
[17:39:33.680] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.680] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.680]  - until=2
[17:39:33.680]  - relaying element #2
[17:39:33.680] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.681] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.681] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.681]  length: 2 (resolved future 2)
[17:39:33.681] resolved() for ‘SequentialFuture’ ...
[17:39:33.681] - state: ‘finished’
[17:39:33.681] - run: TRUE
[17:39:33.681] - result: ‘FutureResult’
[17:39:33.681] resolved() for ‘SequentialFuture’ ... done
[17:39:33.681] Future #3
[17:39:33.681] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.682] - nx: 4
[17:39:33.682] - relay: TRUE
[17:39:33.682] - stdout: TRUE
[17:39:33.682] - signal: TRUE
[17:39:33.682] - resignal: FALSE
[17:39:33.682] - force: TRUE
[17:39:33.682] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.682] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.682]  - until=3
[17:39:33.682]  - relaying element #3
[17:39:33.682] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.683] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.683] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.683]  length: 1 (resolved future 3)
[17:39:33.683] resolved() for ‘SequentialFuture’ ...
[17:39:33.683] - state: ‘finished’
[17:39:33.683] - run: TRUE
[17:39:33.683] - result: ‘FutureResult’
[17:39:33.683] resolved() for ‘SequentialFuture’ ... done
[17:39:33.683] Future #4
[17:39:33.683] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.684] - nx: 4
[17:39:33.684] - relay: TRUE
[17:39:33.684] - stdout: TRUE
[17:39:33.684] - signal: TRUE
[17:39:33.684] - resignal: FALSE
[17:39:33.684] - force: TRUE
[17:39:33.684] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.684] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.684]  - until=4
[17:39:33.684]  - relaying element #4
[17:39:33.684] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.685] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.685] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.685]  length: 0 (resolved future 4)
[17:39:33.685] Relaying remaining futures
[17:39:33.685] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.685] - nx: 4
[17:39:33.685] - relay: TRUE
[17:39:33.685] - stdout: TRUE
[17:39:33.685] - signal: TRUE
[17:39:33.685] - resignal: FALSE
[17:39:33.685] - force: TRUE
[17:39:33.685] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.686] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:33.686] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.686] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.686] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.686] resolve() on environment ... DONE
<environment: 0x55adef5ba918> 
Dimensions: c(2, 3)
[17:39:33.687] getGlobalsAndPackages() ...
[17:39:33.687] Searching for globals...
[17:39:33.687] 
[17:39:33.687] Searching for globals ... DONE
[17:39:33.687] - globals: [0] <none>
[17:39:33.687] getGlobalsAndPackages() ... DONE
[17:39:33.687] run() for ‘Future’ ...
[17:39:33.688] - state: ‘created’
[17:39:33.688] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.688] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.688]   - Field: ‘label’
[17:39:33.688]   - Field: ‘local’
[17:39:33.688]   - Field: ‘owner’
[17:39:33.688]   - Field: ‘envir’
[17:39:33.689]   - Field: ‘packages’
[17:39:33.689]   - Field: ‘gc’
[17:39:33.689]   - Field: ‘conditions’
[17:39:33.689]   - Field: ‘expr’
[17:39:33.689]   - Field: ‘uuid’
[17:39:33.689]   - Field: ‘seed’
[17:39:33.689]   - Field: ‘version’
[17:39:33.689]   - Field: ‘result’
[17:39:33.689]   - Field: ‘asynchronous’
[17:39:33.689]   - Field: ‘calls’
[17:39:33.689]   - Field: ‘globals’
[17:39:33.690]   - Field: ‘stdout’
[17:39:33.690]   - Field: ‘earlySignal’
[17:39:33.690]   - Field: ‘lazy’
[17:39:33.690]   - Field: ‘state’
[17:39:33.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.690] - Launch lazy future ...
[17:39:33.690] Packages needed by the future expression (n = 0): <none>
[17:39:33.690] Packages needed by future strategies (n = 0): <none>
[17:39:33.691] {
[17:39:33.691]     {
[17:39:33.691]         {
[17:39:33.691]             ...future.startTime <- base::Sys.time()
[17:39:33.691]             {
[17:39:33.691]                 {
[17:39:33.691]                   {
[17:39:33.691]                     base::local({
[17:39:33.691]                       has_future <- base::requireNamespace("future", 
[17:39:33.691]                         quietly = TRUE)
[17:39:33.691]                       if (has_future) {
[17:39:33.691]                         ns <- base::getNamespace("future")
[17:39:33.691]                         version <- ns[[".package"]][["version"]]
[17:39:33.691]                         if (is.null(version)) 
[17:39:33.691]                           version <- utils::packageVersion("future")
[17:39:33.691]                       }
[17:39:33.691]                       else {
[17:39:33.691]                         version <- NULL
[17:39:33.691]                       }
[17:39:33.691]                       if (!has_future || version < "1.8.0") {
[17:39:33.691]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.691]                           "", base::R.version$version.string), 
[17:39:33.691]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.691]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.691]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.691]                             "release", "version")], collapse = " "), 
[17:39:33.691]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.691]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.691]                           info)
[17:39:33.691]                         info <- base::paste(info, collapse = "; ")
[17:39:33.691]                         if (!has_future) {
[17:39:33.691]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.691]                             info)
[17:39:33.691]                         }
[17:39:33.691]                         else {
[17:39:33.691]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.691]                             info, version)
[17:39:33.691]                         }
[17:39:33.691]                         base::stop(msg)
[17:39:33.691]                       }
[17:39:33.691]                     })
[17:39:33.691]                   }
[17:39:33.691]                   ...future.strategy.old <- future::plan("list")
[17:39:33.691]                   options(future.plan = NULL)
[17:39:33.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.691]                 }
[17:39:33.691]                 ...future.workdir <- getwd()
[17:39:33.691]             }
[17:39:33.691]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.691]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.691]         }
[17:39:33.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.691]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.691]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.691]             base::names(...future.oldOptions))
[17:39:33.691]     }
[17:39:33.691]     if (FALSE) {
[17:39:33.691]     }
[17:39:33.691]     else {
[17:39:33.691]         if (TRUE) {
[17:39:33.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.691]                 open = "w")
[17:39:33.691]         }
[17:39:33.691]         else {
[17:39:33.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.691]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.691]         }
[17:39:33.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.691]             base::sink(type = "output", split = FALSE)
[17:39:33.691]             base::close(...future.stdout)
[17:39:33.691]         }, add = TRUE)
[17:39:33.691]     }
[17:39:33.691]     ...future.frame <- base::sys.nframe()
[17:39:33.691]     ...future.conditions <- base::list()
[17:39:33.691]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.691]     if (FALSE) {
[17:39:33.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.691]     }
[17:39:33.691]     ...future.result <- base::tryCatch({
[17:39:33.691]         base::withCallingHandlers({
[17:39:33.691]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.691]             future::FutureResult(value = ...future.value$value, 
[17:39:33.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.691]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.691]                     ...future.globalenv.names))
[17:39:33.691]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.691]         }, condition = base::local({
[17:39:33.691]             c <- base::c
[17:39:33.691]             inherits <- base::inherits
[17:39:33.691]             invokeRestart <- base::invokeRestart
[17:39:33.691]             length <- base::length
[17:39:33.691]             list <- base::list
[17:39:33.691]             seq.int <- base::seq.int
[17:39:33.691]             signalCondition <- base::signalCondition
[17:39:33.691]             sys.calls <- base::sys.calls
[17:39:33.691]             `[[` <- base::`[[`
[17:39:33.691]             `+` <- base::`+`
[17:39:33.691]             `<<-` <- base::`<<-`
[17:39:33.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.691]                   3L)]
[17:39:33.691]             }
[17:39:33.691]             function(cond) {
[17:39:33.691]                 is_error <- inherits(cond, "error")
[17:39:33.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.691]                   NULL)
[17:39:33.691]                 if (is_error) {
[17:39:33.691]                   sessionInformation <- function() {
[17:39:33.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.691]                       search = base::search(), system = base::Sys.info())
[17:39:33.691]                   }
[17:39:33.691]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.691]                     cond$call), session = sessionInformation(), 
[17:39:33.691]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.691]                   signalCondition(cond)
[17:39:33.691]                 }
[17:39:33.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.691]                 "immediateCondition"))) {
[17:39:33.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.691]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.691]                   if (TRUE && !signal) {
[17:39:33.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.691]                     {
[17:39:33.691]                       inherits <- base::inherits
[17:39:33.691]                       invokeRestart <- base::invokeRestart
[17:39:33.691]                       is.null <- base::is.null
[17:39:33.691]                       muffled <- FALSE
[17:39:33.691]                       if (inherits(cond, "message")) {
[17:39:33.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.691]                         if (muffled) 
[17:39:33.691]                           invokeRestart("muffleMessage")
[17:39:33.691]                       }
[17:39:33.691]                       else if (inherits(cond, "warning")) {
[17:39:33.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.691]                         if (muffled) 
[17:39:33.691]                           invokeRestart("muffleWarning")
[17:39:33.691]                       }
[17:39:33.691]                       else if (inherits(cond, "condition")) {
[17:39:33.691]                         if (!is.null(pattern)) {
[17:39:33.691]                           computeRestarts <- base::computeRestarts
[17:39:33.691]                           grepl <- base::grepl
[17:39:33.691]                           restarts <- computeRestarts(cond)
[17:39:33.691]                           for (restart in restarts) {
[17:39:33.691]                             name <- restart$name
[17:39:33.691]                             if (is.null(name)) 
[17:39:33.691]                               next
[17:39:33.691]                             if (!grepl(pattern, name)) 
[17:39:33.691]                               next
[17:39:33.691]                             invokeRestart(restart)
[17:39:33.691]                             muffled <- TRUE
[17:39:33.691]                             break
[17:39:33.691]                           }
[17:39:33.691]                         }
[17:39:33.691]                       }
[17:39:33.691]                       invisible(muffled)
[17:39:33.691]                     }
[17:39:33.691]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.691]                   }
[17:39:33.691]                 }
[17:39:33.691]                 else {
[17:39:33.691]                   if (TRUE) {
[17:39:33.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.691]                     {
[17:39:33.691]                       inherits <- base::inherits
[17:39:33.691]                       invokeRestart <- base::invokeRestart
[17:39:33.691]                       is.null <- base::is.null
[17:39:33.691]                       muffled <- FALSE
[17:39:33.691]                       if (inherits(cond, "message")) {
[17:39:33.691]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.691]                         if (muffled) 
[17:39:33.691]                           invokeRestart("muffleMessage")
[17:39:33.691]                       }
[17:39:33.691]                       else if (inherits(cond, "warning")) {
[17:39:33.691]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.691]                         if (muffled) 
[17:39:33.691]                           invokeRestart("muffleWarning")
[17:39:33.691]                       }
[17:39:33.691]                       else if (inherits(cond, "condition")) {
[17:39:33.691]                         if (!is.null(pattern)) {
[17:39:33.691]                           computeRestarts <- base::computeRestarts
[17:39:33.691]                           grepl <- base::grepl
[17:39:33.691]                           restarts <- computeRestarts(cond)
[17:39:33.691]                           for (restart in restarts) {
[17:39:33.691]                             name <- restart$name
[17:39:33.691]                             if (is.null(name)) 
[17:39:33.691]                               next
[17:39:33.691]                             if (!grepl(pattern, name)) 
[17:39:33.691]                               next
[17:39:33.691]                             invokeRestart(restart)
[17:39:33.691]                             muffled <- TRUE
[17:39:33.691]                             break
[17:39:33.691]                           }
[17:39:33.691]                         }
[17:39:33.691]                       }
[17:39:33.691]                       invisible(muffled)
[17:39:33.691]                     }
[17:39:33.691]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.691]                   }
[17:39:33.691]                 }
[17:39:33.691]             }
[17:39:33.691]         }))
[17:39:33.691]     }, error = function(ex) {
[17:39:33.691]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.691]                 ...future.rng), started = ...future.startTime, 
[17:39:33.691]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.691]             version = "1.8"), class = "FutureResult")
[17:39:33.691]     }, finally = {
[17:39:33.691]         if (!identical(...future.workdir, getwd())) 
[17:39:33.691]             setwd(...future.workdir)
[17:39:33.691]         {
[17:39:33.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.691]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.691]             }
[17:39:33.691]             base::options(...future.oldOptions)
[17:39:33.691]             if (.Platform$OS.type == "windows") {
[17:39:33.691]                 old_names <- names(...future.oldEnvVars)
[17:39:33.691]                 envs <- base::Sys.getenv()
[17:39:33.691]                 names <- names(envs)
[17:39:33.691]                 common <- intersect(names, old_names)
[17:39:33.691]                 added <- setdiff(names, old_names)
[17:39:33.691]                 removed <- setdiff(old_names, names)
[17:39:33.691]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.691]                   envs[common]]
[17:39:33.691]                 NAMES <- toupper(changed)
[17:39:33.691]                 args <- list()
[17:39:33.691]                 for (kk in seq_along(NAMES)) {
[17:39:33.691]                   name <- changed[[kk]]
[17:39:33.691]                   NAME <- NAMES[[kk]]
[17:39:33.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.691]                     next
[17:39:33.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.691]                 }
[17:39:33.691]                 NAMES <- toupper(added)
[17:39:33.691]                 for (kk in seq_along(NAMES)) {
[17:39:33.691]                   name <- added[[kk]]
[17:39:33.691]                   NAME <- NAMES[[kk]]
[17:39:33.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.691]                     next
[17:39:33.691]                   args[[name]] <- ""
[17:39:33.691]                 }
[17:39:33.691]                 NAMES <- toupper(removed)
[17:39:33.691]                 for (kk in seq_along(NAMES)) {
[17:39:33.691]                   name <- removed[[kk]]
[17:39:33.691]                   NAME <- NAMES[[kk]]
[17:39:33.691]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.691]                     next
[17:39:33.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.691]                 }
[17:39:33.691]                 if (length(args) > 0) 
[17:39:33.691]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.691]             }
[17:39:33.691]             else {
[17:39:33.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.691]             }
[17:39:33.691]             {
[17:39:33.691]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.691]                   0L) {
[17:39:33.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.691]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.691]                   base::options(opts)
[17:39:33.691]                 }
[17:39:33.691]                 {
[17:39:33.691]                   {
[17:39:33.691]                     NULL
[17:39:33.691]                     RNGkind("Mersenne-Twister")
[17:39:33.691]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.691]                       inherits = FALSE)
[17:39:33.691]                   }
[17:39:33.691]                   options(future.plan = NULL)
[17:39:33.691]                   if (is.na(NA_character_)) 
[17:39:33.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.691]                     .init = FALSE)
[17:39:33.691]                 }
[17:39:33.691]             }
[17:39:33.691]         }
[17:39:33.691]     })
[17:39:33.691]     if (TRUE) {
[17:39:33.691]         base::sink(type = "output", split = FALSE)
[17:39:33.691]         if (TRUE) {
[17:39:33.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.691]         }
[17:39:33.691]         else {
[17:39:33.691]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.691]         }
[17:39:33.691]         base::close(...future.stdout)
[17:39:33.691]         ...future.stdout <- NULL
[17:39:33.691]     }
[17:39:33.691]     ...future.result$conditions <- ...future.conditions
[17:39:33.691]     ...future.result$finished <- base::Sys.time()
[17:39:33.691]     ...future.result
[17:39:33.691] }
[17:39:33.692] plan(): Setting new future strategy stack:
[17:39:33.693] List of future strategies:
[17:39:33.693] 1. sequential:
[17:39:33.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.693]    - tweaked: FALSE
[17:39:33.693]    - call: NULL
[17:39:33.693] plan(): nbrOfWorkers() = 1
[17:39:33.694] plan(): Setting new future strategy stack:
[17:39:33.694] List of future strategies:
[17:39:33.694] 1. sequential:
[17:39:33.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.694]    - tweaked: FALSE
[17:39:33.694]    - call: plan(strategy)
[17:39:33.694] plan(): nbrOfWorkers() = 1
[17:39:33.694] SequentialFuture started (and completed)
[17:39:33.695] - Launch lazy future ... done
[17:39:33.695] run() for ‘SequentialFuture’ ... done
[17:39:33.695] getGlobalsAndPackages() ...
[17:39:33.695] Searching for globals...
[17:39:33.695] 
[17:39:33.695] Searching for globals ... DONE
[17:39:33.695] - globals: [0] <none>
[17:39:33.695] getGlobalsAndPackages() ... DONE
[17:39:33.696] run() for ‘Future’ ...
[17:39:33.696] - state: ‘created’
[17:39:33.696] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.696] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.696]   - Field: ‘label’
[17:39:33.697]   - Field: ‘local’
[17:39:33.697]   - Field: ‘owner’
[17:39:33.697]   - Field: ‘envir’
[17:39:33.697]   - Field: ‘packages’
[17:39:33.697]   - Field: ‘gc’
[17:39:33.697]   - Field: ‘conditions’
[17:39:33.697]   - Field: ‘expr’
[17:39:33.697]   - Field: ‘uuid’
[17:39:33.697]   - Field: ‘seed’
[17:39:33.697]   - Field: ‘version’
[17:39:33.697]   - Field: ‘result’
[17:39:33.698]   - Field: ‘asynchronous’
[17:39:33.698]   - Field: ‘calls’
[17:39:33.698]   - Field: ‘globals’
[17:39:33.698]   - Field: ‘stdout’
[17:39:33.698]   - Field: ‘earlySignal’
[17:39:33.698]   - Field: ‘lazy’
[17:39:33.698]   - Field: ‘state’
[17:39:33.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.698] - Launch lazy future ...
[17:39:33.698] Packages needed by the future expression (n = 0): <none>
[17:39:33.699] Packages needed by future strategies (n = 0): <none>
[17:39:33.699] {
[17:39:33.699]     {
[17:39:33.699]         {
[17:39:33.699]             ...future.startTime <- base::Sys.time()
[17:39:33.699]             {
[17:39:33.699]                 {
[17:39:33.699]                   {
[17:39:33.699]                     base::local({
[17:39:33.699]                       has_future <- base::requireNamespace("future", 
[17:39:33.699]                         quietly = TRUE)
[17:39:33.699]                       if (has_future) {
[17:39:33.699]                         ns <- base::getNamespace("future")
[17:39:33.699]                         version <- ns[[".package"]][["version"]]
[17:39:33.699]                         if (is.null(version)) 
[17:39:33.699]                           version <- utils::packageVersion("future")
[17:39:33.699]                       }
[17:39:33.699]                       else {
[17:39:33.699]                         version <- NULL
[17:39:33.699]                       }
[17:39:33.699]                       if (!has_future || version < "1.8.0") {
[17:39:33.699]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.699]                           "", base::R.version$version.string), 
[17:39:33.699]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.699]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.699]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.699]                             "release", "version")], collapse = " "), 
[17:39:33.699]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.699]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.699]                           info)
[17:39:33.699]                         info <- base::paste(info, collapse = "; ")
[17:39:33.699]                         if (!has_future) {
[17:39:33.699]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.699]                             info)
[17:39:33.699]                         }
[17:39:33.699]                         else {
[17:39:33.699]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.699]                             info, version)
[17:39:33.699]                         }
[17:39:33.699]                         base::stop(msg)
[17:39:33.699]                       }
[17:39:33.699]                     })
[17:39:33.699]                   }
[17:39:33.699]                   ...future.strategy.old <- future::plan("list")
[17:39:33.699]                   options(future.plan = NULL)
[17:39:33.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.699]                 }
[17:39:33.699]                 ...future.workdir <- getwd()
[17:39:33.699]             }
[17:39:33.699]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.699]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.699]         }
[17:39:33.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.699]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.699]             base::names(...future.oldOptions))
[17:39:33.699]     }
[17:39:33.699]     if (FALSE) {
[17:39:33.699]     }
[17:39:33.699]     else {
[17:39:33.699]         if (TRUE) {
[17:39:33.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.699]                 open = "w")
[17:39:33.699]         }
[17:39:33.699]         else {
[17:39:33.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.699]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.699]         }
[17:39:33.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.699]             base::sink(type = "output", split = FALSE)
[17:39:33.699]             base::close(...future.stdout)
[17:39:33.699]         }, add = TRUE)
[17:39:33.699]     }
[17:39:33.699]     ...future.frame <- base::sys.nframe()
[17:39:33.699]     ...future.conditions <- base::list()
[17:39:33.699]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.699]     if (FALSE) {
[17:39:33.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.699]     }
[17:39:33.699]     ...future.result <- base::tryCatch({
[17:39:33.699]         base::withCallingHandlers({
[17:39:33.699]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.699]             future::FutureResult(value = ...future.value$value, 
[17:39:33.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.699]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.699]                     ...future.globalenv.names))
[17:39:33.699]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.699]         }, condition = base::local({
[17:39:33.699]             c <- base::c
[17:39:33.699]             inherits <- base::inherits
[17:39:33.699]             invokeRestart <- base::invokeRestart
[17:39:33.699]             length <- base::length
[17:39:33.699]             list <- base::list
[17:39:33.699]             seq.int <- base::seq.int
[17:39:33.699]             signalCondition <- base::signalCondition
[17:39:33.699]             sys.calls <- base::sys.calls
[17:39:33.699]             `[[` <- base::`[[`
[17:39:33.699]             `+` <- base::`+`
[17:39:33.699]             `<<-` <- base::`<<-`
[17:39:33.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.699]                   3L)]
[17:39:33.699]             }
[17:39:33.699]             function(cond) {
[17:39:33.699]                 is_error <- inherits(cond, "error")
[17:39:33.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.699]                   NULL)
[17:39:33.699]                 if (is_error) {
[17:39:33.699]                   sessionInformation <- function() {
[17:39:33.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.699]                       search = base::search(), system = base::Sys.info())
[17:39:33.699]                   }
[17:39:33.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.699]                     cond$call), session = sessionInformation(), 
[17:39:33.699]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.699]                   signalCondition(cond)
[17:39:33.699]                 }
[17:39:33.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.699]                 "immediateCondition"))) {
[17:39:33.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.699]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.699]                   if (TRUE && !signal) {
[17:39:33.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.699]                     {
[17:39:33.699]                       inherits <- base::inherits
[17:39:33.699]                       invokeRestart <- base::invokeRestart
[17:39:33.699]                       is.null <- base::is.null
[17:39:33.699]                       muffled <- FALSE
[17:39:33.699]                       if (inherits(cond, "message")) {
[17:39:33.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.699]                         if (muffled) 
[17:39:33.699]                           invokeRestart("muffleMessage")
[17:39:33.699]                       }
[17:39:33.699]                       else if (inherits(cond, "warning")) {
[17:39:33.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.699]                         if (muffled) 
[17:39:33.699]                           invokeRestart("muffleWarning")
[17:39:33.699]                       }
[17:39:33.699]                       else if (inherits(cond, "condition")) {
[17:39:33.699]                         if (!is.null(pattern)) {
[17:39:33.699]                           computeRestarts <- base::computeRestarts
[17:39:33.699]                           grepl <- base::grepl
[17:39:33.699]                           restarts <- computeRestarts(cond)
[17:39:33.699]                           for (restart in restarts) {
[17:39:33.699]                             name <- restart$name
[17:39:33.699]                             if (is.null(name)) 
[17:39:33.699]                               next
[17:39:33.699]                             if (!grepl(pattern, name)) 
[17:39:33.699]                               next
[17:39:33.699]                             invokeRestart(restart)
[17:39:33.699]                             muffled <- TRUE
[17:39:33.699]                             break
[17:39:33.699]                           }
[17:39:33.699]                         }
[17:39:33.699]                       }
[17:39:33.699]                       invisible(muffled)
[17:39:33.699]                     }
[17:39:33.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.699]                   }
[17:39:33.699]                 }
[17:39:33.699]                 else {
[17:39:33.699]                   if (TRUE) {
[17:39:33.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.699]                     {
[17:39:33.699]                       inherits <- base::inherits
[17:39:33.699]                       invokeRestart <- base::invokeRestart
[17:39:33.699]                       is.null <- base::is.null
[17:39:33.699]                       muffled <- FALSE
[17:39:33.699]                       if (inherits(cond, "message")) {
[17:39:33.699]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.699]                         if (muffled) 
[17:39:33.699]                           invokeRestart("muffleMessage")
[17:39:33.699]                       }
[17:39:33.699]                       else if (inherits(cond, "warning")) {
[17:39:33.699]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.699]                         if (muffled) 
[17:39:33.699]                           invokeRestart("muffleWarning")
[17:39:33.699]                       }
[17:39:33.699]                       else if (inherits(cond, "condition")) {
[17:39:33.699]                         if (!is.null(pattern)) {
[17:39:33.699]                           computeRestarts <- base::computeRestarts
[17:39:33.699]                           grepl <- base::grepl
[17:39:33.699]                           restarts <- computeRestarts(cond)
[17:39:33.699]                           for (restart in restarts) {
[17:39:33.699]                             name <- restart$name
[17:39:33.699]                             if (is.null(name)) 
[17:39:33.699]                               next
[17:39:33.699]                             if (!grepl(pattern, name)) 
[17:39:33.699]                               next
[17:39:33.699]                             invokeRestart(restart)
[17:39:33.699]                             muffled <- TRUE
[17:39:33.699]                             break
[17:39:33.699]                           }
[17:39:33.699]                         }
[17:39:33.699]                       }
[17:39:33.699]                       invisible(muffled)
[17:39:33.699]                     }
[17:39:33.699]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.699]                   }
[17:39:33.699]                 }
[17:39:33.699]             }
[17:39:33.699]         }))
[17:39:33.699]     }, error = function(ex) {
[17:39:33.699]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.699]                 ...future.rng), started = ...future.startTime, 
[17:39:33.699]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.699]             version = "1.8"), class = "FutureResult")
[17:39:33.699]     }, finally = {
[17:39:33.699]         if (!identical(...future.workdir, getwd())) 
[17:39:33.699]             setwd(...future.workdir)
[17:39:33.699]         {
[17:39:33.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.699]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.699]             }
[17:39:33.699]             base::options(...future.oldOptions)
[17:39:33.699]             if (.Platform$OS.type == "windows") {
[17:39:33.699]                 old_names <- names(...future.oldEnvVars)
[17:39:33.699]                 envs <- base::Sys.getenv()
[17:39:33.699]                 names <- names(envs)
[17:39:33.699]                 common <- intersect(names, old_names)
[17:39:33.699]                 added <- setdiff(names, old_names)
[17:39:33.699]                 removed <- setdiff(old_names, names)
[17:39:33.699]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.699]                   envs[common]]
[17:39:33.699]                 NAMES <- toupper(changed)
[17:39:33.699]                 args <- list()
[17:39:33.699]                 for (kk in seq_along(NAMES)) {
[17:39:33.699]                   name <- changed[[kk]]
[17:39:33.699]                   NAME <- NAMES[[kk]]
[17:39:33.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.699]                     next
[17:39:33.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.699]                 }
[17:39:33.699]                 NAMES <- toupper(added)
[17:39:33.699]                 for (kk in seq_along(NAMES)) {
[17:39:33.699]                   name <- added[[kk]]
[17:39:33.699]                   NAME <- NAMES[[kk]]
[17:39:33.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.699]                     next
[17:39:33.699]                   args[[name]] <- ""
[17:39:33.699]                 }
[17:39:33.699]                 NAMES <- toupper(removed)
[17:39:33.699]                 for (kk in seq_along(NAMES)) {
[17:39:33.699]                   name <- removed[[kk]]
[17:39:33.699]                   NAME <- NAMES[[kk]]
[17:39:33.699]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.699]                     next
[17:39:33.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.699]                 }
[17:39:33.699]                 if (length(args) > 0) 
[17:39:33.699]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.699]             }
[17:39:33.699]             else {
[17:39:33.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.699]             }
[17:39:33.699]             {
[17:39:33.699]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.699]                   0L) {
[17:39:33.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.699]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.699]                   base::options(opts)
[17:39:33.699]                 }
[17:39:33.699]                 {
[17:39:33.699]                   {
[17:39:33.699]                     NULL
[17:39:33.699]                     RNGkind("Mersenne-Twister")
[17:39:33.699]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.699]                       inherits = FALSE)
[17:39:33.699]                   }
[17:39:33.699]                   options(future.plan = NULL)
[17:39:33.699]                   if (is.na(NA_character_)) 
[17:39:33.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.699]                     .init = FALSE)
[17:39:33.699]                 }
[17:39:33.699]             }
[17:39:33.699]         }
[17:39:33.699]     })
[17:39:33.699]     if (TRUE) {
[17:39:33.699]         base::sink(type = "output", split = FALSE)
[17:39:33.699]         if (TRUE) {
[17:39:33.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.699]         }
[17:39:33.699]         else {
[17:39:33.699]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.699]         }
[17:39:33.699]         base::close(...future.stdout)
[17:39:33.699]         ...future.stdout <- NULL
[17:39:33.699]     }
[17:39:33.699]     ...future.result$conditions <- ...future.conditions
[17:39:33.699]     ...future.result$finished <- base::Sys.time()
[17:39:33.699]     ...future.result
[17:39:33.699] }
[17:39:33.701] plan(): Setting new future strategy stack:
[17:39:33.701] List of future strategies:
[17:39:33.701] 1. sequential:
[17:39:33.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.701]    - tweaked: FALSE
[17:39:33.701]    - call: NULL
[17:39:33.701] plan(): nbrOfWorkers() = 1
[17:39:33.702] plan(): Setting new future strategy stack:
[17:39:33.702] List of future strategies:
[17:39:33.702] 1. sequential:
[17:39:33.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.702]    - tweaked: FALSE
[17:39:33.702]    - call: plan(strategy)
[17:39:33.702] plan(): nbrOfWorkers() = 1
[17:39:33.703] SequentialFuture started (and completed)
[17:39:33.703] - Launch lazy future ... done
[17:39:33.703] run() for ‘SequentialFuture’ ... done
[17:39:33.703] getGlobalsAndPackages() ...
[17:39:33.703] Searching for globals...
[17:39:33.704] - globals found: [1] ‘{’
[17:39:33.704] Searching for globals ... DONE
[17:39:33.704] Resolving globals: FALSE
[17:39:33.704] 
[17:39:33.704] 
[17:39:33.707] getGlobalsAndPackages() ... DONE
[17:39:33.707] run() for ‘Future’ ...
[17:39:33.707] - state: ‘created’
[17:39:33.707] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.707] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.708]   - Field: ‘label’
[17:39:33.708]   - Field: ‘local’
[17:39:33.708]   - Field: ‘owner’
[17:39:33.708]   - Field: ‘envir’
[17:39:33.708]   - Field: ‘packages’
[17:39:33.708]   - Field: ‘gc’
[17:39:33.708]   - Field: ‘conditions’
[17:39:33.708]   - Field: ‘expr’
[17:39:33.709]   - Field: ‘uuid’
[17:39:33.709]   - Field: ‘seed’
[17:39:33.709]   - Field: ‘version’
[17:39:33.709]   - Field: ‘result’
[17:39:33.709]   - Field: ‘asynchronous’
[17:39:33.709]   - Field: ‘calls’
[17:39:33.709]   - Field: ‘globals’
[17:39:33.709]   - Field: ‘stdout’
[17:39:33.709]   - Field: ‘earlySignal’
[17:39:33.709]   - Field: ‘lazy’
[17:39:33.709]   - Field: ‘state’
[17:39:33.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.710] - Launch lazy future ...
[17:39:33.710] Packages needed by the future expression (n = 0): <none>
[17:39:33.710] Packages needed by future strategies (n = 0): <none>
[17:39:33.710] {
[17:39:33.710]     {
[17:39:33.710]         {
[17:39:33.710]             ...future.startTime <- base::Sys.time()
[17:39:33.710]             {
[17:39:33.710]                 {
[17:39:33.710]                   {
[17:39:33.710]                     base::local({
[17:39:33.710]                       has_future <- base::requireNamespace("future", 
[17:39:33.710]                         quietly = TRUE)
[17:39:33.710]                       if (has_future) {
[17:39:33.710]                         ns <- base::getNamespace("future")
[17:39:33.710]                         version <- ns[[".package"]][["version"]]
[17:39:33.710]                         if (is.null(version)) 
[17:39:33.710]                           version <- utils::packageVersion("future")
[17:39:33.710]                       }
[17:39:33.710]                       else {
[17:39:33.710]                         version <- NULL
[17:39:33.710]                       }
[17:39:33.710]                       if (!has_future || version < "1.8.0") {
[17:39:33.710]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.710]                           "", base::R.version$version.string), 
[17:39:33.710]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.710]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.710]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.710]                             "release", "version")], collapse = " "), 
[17:39:33.710]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.710]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.710]                           info)
[17:39:33.710]                         info <- base::paste(info, collapse = "; ")
[17:39:33.710]                         if (!has_future) {
[17:39:33.710]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.710]                             info)
[17:39:33.710]                         }
[17:39:33.710]                         else {
[17:39:33.710]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.710]                             info, version)
[17:39:33.710]                         }
[17:39:33.710]                         base::stop(msg)
[17:39:33.710]                       }
[17:39:33.710]                     })
[17:39:33.710]                   }
[17:39:33.710]                   ...future.strategy.old <- future::plan("list")
[17:39:33.710]                   options(future.plan = NULL)
[17:39:33.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.710]                 }
[17:39:33.710]                 ...future.workdir <- getwd()
[17:39:33.710]             }
[17:39:33.710]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.710]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.710]         }
[17:39:33.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.710]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.710]             base::names(...future.oldOptions))
[17:39:33.710]     }
[17:39:33.710]     if (FALSE) {
[17:39:33.710]     }
[17:39:33.710]     else {
[17:39:33.710]         if (TRUE) {
[17:39:33.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.710]                 open = "w")
[17:39:33.710]         }
[17:39:33.710]         else {
[17:39:33.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.710]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.710]         }
[17:39:33.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.710]             base::sink(type = "output", split = FALSE)
[17:39:33.710]             base::close(...future.stdout)
[17:39:33.710]         }, add = TRUE)
[17:39:33.710]     }
[17:39:33.710]     ...future.frame <- base::sys.nframe()
[17:39:33.710]     ...future.conditions <- base::list()
[17:39:33.710]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.710]     if (FALSE) {
[17:39:33.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.710]     }
[17:39:33.710]     ...future.result <- base::tryCatch({
[17:39:33.710]         base::withCallingHandlers({
[17:39:33.710]             ...future.value <- base::withVisible(base::local({
[17:39:33.710]                 4
[17:39:33.710]             }))
[17:39:33.710]             future::FutureResult(value = ...future.value$value, 
[17:39:33.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.710]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.710]                     ...future.globalenv.names))
[17:39:33.710]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.710]         }, condition = base::local({
[17:39:33.710]             c <- base::c
[17:39:33.710]             inherits <- base::inherits
[17:39:33.710]             invokeRestart <- base::invokeRestart
[17:39:33.710]             length <- base::length
[17:39:33.710]             list <- base::list
[17:39:33.710]             seq.int <- base::seq.int
[17:39:33.710]             signalCondition <- base::signalCondition
[17:39:33.710]             sys.calls <- base::sys.calls
[17:39:33.710]             `[[` <- base::`[[`
[17:39:33.710]             `+` <- base::`+`
[17:39:33.710]             `<<-` <- base::`<<-`
[17:39:33.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.710]                   3L)]
[17:39:33.710]             }
[17:39:33.710]             function(cond) {
[17:39:33.710]                 is_error <- inherits(cond, "error")
[17:39:33.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.710]                   NULL)
[17:39:33.710]                 if (is_error) {
[17:39:33.710]                   sessionInformation <- function() {
[17:39:33.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.710]                       search = base::search(), system = base::Sys.info())
[17:39:33.710]                   }
[17:39:33.710]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.710]                     cond$call), session = sessionInformation(), 
[17:39:33.710]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.710]                   signalCondition(cond)
[17:39:33.710]                 }
[17:39:33.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.710]                 "immediateCondition"))) {
[17:39:33.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.710]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.710]                   if (TRUE && !signal) {
[17:39:33.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.710]                     {
[17:39:33.710]                       inherits <- base::inherits
[17:39:33.710]                       invokeRestart <- base::invokeRestart
[17:39:33.710]                       is.null <- base::is.null
[17:39:33.710]                       muffled <- FALSE
[17:39:33.710]                       if (inherits(cond, "message")) {
[17:39:33.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.710]                         if (muffled) 
[17:39:33.710]                           invokeRestart("muffleMessage")
[17:39:33.710]                       }
[17:39:33.710]                       else if (inherits(cond, "warning")) {
[17:39:33.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.710]                         if (muffled) 
[17:39:33.710]                           invokeRestart("muffleWarning")
[17:39:33.710]                       }
[17:39:33.710]                       else if (inherits(cond, "condition")) {
[17:39:33.710]                         if (!is.null(pattern)) {
[17:39:33.710]                           computeRestarts <- base::computeRestarts
[17:39:33.710]                           grepl <- base::grepl
[17:39:33.710]                           restarts <- computeRestarts(cond)
[17:39:33.710]                           for (restart in restarts) {
[17:39:33.710]                             name <- restart$name
[17:39:33.710]                             if (is.null(name)) 
[17:39:33.710]                               next
[17:39:33.710]                             if (!grepl(pattern, name)) 
[17:39:33.710]                               next
[17:39:33.710]                             invokeRestart(restart)
[17:39:33.710]                             muffled <- TRUE
[17:39:33.710]                             break
[17:39:33.710]                           }
[17:39:33.710]                         }
[17:39:33.710]                       }
[17:39:33.710]                       invisible(muffled)
[17:39:33.710]                     }
[17:39:33.710]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.710]                   }
[17:39:33.710]                 }
[17:39:33.710]                 else {
[17:39:33.710]                   if (TRUE) {
[17:39:33.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.710]                     {
[17:39:33.710]                       inherits <- base::inherits
[17:39:33.710]                       invokeRestart <- base::invokeRestart
[17:39:33.710]                       is.null <- base::is.null
[17:39:33.710]                       muffled <- FALSE
[17:39:33.710]                       if (inherits(cond, "message")) {
[17:39:33.710]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.710]                         if (muffled) 
[17:39:33.710]                           invokeRestart("muffleMessage")
[17:39:33.710]                       }
[17:39:33.710]                       else if (inherits(cond, "warning")) {
[17:39:33.710]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.710]                         if (muffled) 
[17:39:33.710]                           invokeRestart("muffleWarning")
[17:39:33.710]                       }
[17:39:33.710]                       else if (inherits(cond, "condition")) {
[17:39:33.710]                         if (!is.null(pattern)) {
[17:39:33.710]                           computeRestarts <- base::computeRestarts
[17:39:33.710]                           grepl <- base::grepl
[17:39:33.710]                           restarts <- computeRestarts(cond)
[17:39:33.710]                           for (restart in restarts) {
[17:39:33.710]                             name <- restart$name
[17:39:33.710]                             if (is.null(name)) 
[17:39:33.710]                               next
[17:39:33.710]                             if (!grepl(pattern, name)) 
[17:39:33.710]                               next
[17:39:33.710]                             invokeRestart(restart)
[17:39:33.710]                             muffled <- TRUE
[17:39:33.710]                             break
[17:39:33.710]                           }
[17:39:33.710]                         }
[17:39:33.710]                       }
[17:39:33.710]                       invisible(muffled)
[17:39:33.710]                     }
[17:39:33.710]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.710]                   }
[17:39:33.710]                 }
[17:39:33.710]             }
[17:39:33.710]         }))
[17:39:33.710]     }, error = function(ex) {
[17:39:33.710]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.710]                 ...future.rng), started = ...future.startTime, 
[17:39:33.710]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.710]             version = "1.8"), class = "FutureResult")
[17:39:33.710]     }, finally = {
[17:39:33.710]         if (!identical(...future.workdir, getwd())) 
[17:39:33.710]             setwd(...future.workdir)
[17:39:33.710]         {
[17:39:33.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.710]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.710]             }
[17:39:33.710]             base::options(...future.oldOptions)
[17:39:33.710]             if (.Platform$OS.type == "windows") {
[17:39:33.710]                 old_names <- names(...future.oldEnvVars)
[17:39:33.710]                 envs <- base::Sys.getenv()
[17:39:33.710]                 names <- names(envs)
[17:39:33.710]                 common <- intersect(names, old_names)
[17:39:33.710]                 added <- setdiff(names, old_names)
[17:39:33.710]                 removed <- setdiff(old_names, names)
[17:39:33.710]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.710]                   envs[common]]
[17:39:33.710]                 NAMES <- toupper(changed)
[17:39:33.710]                 args <- list()
[17:39:33.710]                 for (kk in seq_along(NAMES)) {
[17:39:33.710]                   name <- changed[[kk]]
[17:39:33.710]                   NAME <- NAMES[[kk]]
[17:39:33.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.710]                     next
[17:39:33.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.710]                 }
[17:39:33.710]                 NAMES <- toupper(added)
[17:39:33.710]                 for (kk in seq_along(NAMES)) {
[17:39:33.710]                   name <- added[[kk]]
[17:39:33.710]                   NAME <- NAMES[[kk]]
[17:39:33.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.710]                     next
[17:39:33.710]                   args[[name]] <- ""
[17:39:33.710]                 }
[17:39:33.710]                 NAMES <- toupper(removed)
[17:39:33.710]                 for (kk in seq_along(NAMES)) {
[17:39:33.710]                   name <- removed[[kk]]
[17:39:33.710]                   NAME <- NAMES[[kk]]
[17:39:33.710]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.710]                     next
[17:39:33.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.710]                 }
[17:39:33.710]                 if (length(args) > 0) 
[17:39:33.710]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.710]             }
[17:39:33.710]             else {
[17:39:33.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.710]             }
[17:39:33.710]             {
[17:39:33.710]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.710]                   0L) {
[17:39:33.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.710]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.710]                   base::options(opts)
[17:39:33.710]                 }
[17:39:33.710]                 {
[17:39:33.710]                   {
[17:39:33.710]                     NULL
[17:39:33.710]                     RNGkind("Mersenne-Twister")
[17:39:33.710]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.710]                       inherits = FALSE)
[17:39:33.710]                   }
[17:39:33.710]                   options(future.plan = NULL)
[17:39:33.710]                   if (is.na(NA_character_)) 
[17:39:33.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.710]                     .init = FALSE)
[17:39:33.710]                 }
[17:39:33.710]             }
[17:39:33.710]         }
[17:39:33.710]     })
[17:39:33.710]     if (TRUE) {
[17:39:33.710]         base::sink(type = "output", split = FALSE)
[17:39:33.710]         if (TRUE) {
[17:39:33.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.710]         }
[17:39:33.710]         else {
[17:39:33.710]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.710]         }
[17:39:33.710]         base::close(...future.stdout)
[17:39:33.710]         ...future.stdout <- NULL
[17:39:33.710]     }
[17:39:33.710]     ...future.result$conditions <- ...future.conditions
[17:39:33.710]     ...future.result$finished <- base::Sys.time()
[17:39:33.710]     ...future.result
[17:39:33.710] }
[17:39:33.712] plan(): Setting new future strategy stack:
[17:39:33.712] List of future strategies:
[17:39:33.712] 1. sequential:
[17:39:33.712]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.712]    - tweaked: FALSE
[17:39:33.712]    - call: NULL
[17:39:33.713] plan(): nbrOfWorkers() = 1
[17:39:33.714] plan(): Setting new future strategy stack:
[17:39:33.714] List of future strategies:
[17:39:33.714] 1. sequential:
[17:39:33.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.714]    - tweaked: FALSE
[17:39:33.714]    - call: plan(strategy)
[17:39:33.714] plan(): nbrOfWorkers() = 1
[17:39:33.714] SequentialFuture started (and completed)
[17:39:33.714] - Launch lazy future ... done
[17:39:33.714] run() for ‘SequentialFuture’ ... done
<environment: 0x55adefbf9b00> 
<environment: 0x55adee2403f0> 
[17:39:33.716] resolved() for ‘SequentialFuture’ ...
[17:39:33.716] - state: ‘finished’
[17:39:33.716] - run: TRUE
[17:39:33.716] - result: ‘FutureResult’
[17:39:33.716] resolved() for ‘SequentialFuture’ ... done
[17:39:33.716] resolved() for ‘SequentialFuture’ ...
[17:39:33.716] - state: ‘finished’
[17:39:33.716] - run: TRUE
[17:39:33.717] - result: ‘FutureResult’
[17:39:33.717] resolved() for ‘SequentialFuture’ ... done
[17:39:33.717] resolved() for ‘SequentialFuture’ ...
[17:39:33.717] - state: ‘finished’
[17:39:33.717] - run: TRUE
[17:39:33.717] - result: ‘FutureResult’
[17:39:33.717] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:33.718] resolve() on environment ...
[17:39:33.718]  recursive: 0
[17:39:33.719]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:33.719] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.719] - nx: 4
[17:39:33.719] - relay: TRUE
[17:39:33.719] - stdout: TRUE
[17:39:33.719] - signal: TRUE
[17:39:33.719] - resignal: FALSE
[17:39:33.720] - force: TRUE
[17:39:33.720] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.720] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.720]  - until=2
[17:39:33.720]  - relaying element #2
[17:39:33.720] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.720] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.720] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.720]  length: 3 (resolved future 1)
[17:39:33.720] resolved() for ‘SequentialFuture’ ...
[17:39:33.720] - state: ‘finished’
[17:39:33.721] - run: TRUE
[17:39:33.721] - result: ‘FutureResult’
[17:39:33.721] resolved() for ‘SequentialFuture’ ... done
[17:39:33.721] Future #2
[17:39:33.721] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.721] - nx: 4
[17:39:33.721] - relay: TRUE
[17:39:33.721] - stdout: TRUE
[17:39:33.721] - signal: TRUE
[17:39:33.721] - resignal: FALSE
[17:39:33.722] - force: TRUE
[17:39:33.722] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.722] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.722]  - until=2
[17:39:33.722]  - relaying element #2
[17:39:33.722] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.722] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.722] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.722]  length: 2 (resolved future 2)
[17:39:33.722] resolved() for ‘SequentialFuture’ ...
[17:39:33.723] - state: ‘finished’
[17:39:33.723] - run: TRUE
[17:39:33.723] - result: ‘FutureResult’
[17:39:33.723] resolved() for ‘SequentialFuture’ ... done
[17:39:33.723] Future #3
[17:39:33.723] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.723] - nx: 4
[17:39:33.723] - relay: TRUE
[17:39:33.723] - stdout: TRUE
[17:39:33.723] - signal: TRUE
[17:39:33.723] - resignal: FALSE
[17:39:33.724] - force: TRUE
[17:39:33.724] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.724] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.724]  - until=3
[17:39:33.724]  - relaying element #3
[17:39:33.724] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.724] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.724] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.724]  length: 1 (resolved future 3)
[17:39:33.725] resolved() for ‘SequentialFuture’ ...
[17:39:33.725] - state: ‘finished’
[17:39:33.725] - run: TRUE
[17:39:33.725] - result: ‘FutureResult’
[17:39:33.725] resolved() for ‘SequentialFuture’ ... done
[17:39:33.725] Future #4
[17:39:33.725] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.725] - nx: 4
[17:39:33.725] - relay: TRUE
[17:39:33.725] - stdout: TRUE
[17:39:33.725] - signal: TRUE
[17:39:33.726] - resignal: FALSE
[17:39:33.726] - force: TRUE
[17:39:33.726] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.726] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.726]  - until=4
[17:39:33.726]  - relaying element #4
[17:39:33.726] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.726] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.726] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.726]  length: 0 (resolved future 4)
[17:39:33.727] Relaying remaining futures
[17:39:33.727] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.727] - nx: 4
[17:39:33.727] - relay: TRUE
[17:39:33.727] - stdout: TRUE
[17:39:33.727] - signal: TRUE
[17:39:33.727] - resignal: FALSE
[17:39:33.727] - force: TRUE
[17:39:33.727] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.727] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:33.727] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.727] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.728] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.728] resolve() on environment ... DONE
<environment: 0x55adefb7f588> 
Dimensions: c(2, 3, 1)
[17:39:33.728] getGlobalsAndPackages() ...
[17:39:33.728] Searching for globals...
[17:39:33.729] 
[17:39:33.729] Searching for globals ... DONE
[17:39:33.729] - globals: [0] <none>
[17:39:33.729] getGlobalsAndPackages() ... DONE
[17:39:33.729] run() for ‘Future’ ...
[17:39:33.729] - state: ‘created’
[17:39:33.729] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.730]   - Field: ‘label’
[17:39:33.730]   - Field: ‘local’
[17:39:33.730]   - Field: ‘owner’
[17:39:33.730]   - Field: ‘envir’
[17:39:33.730]   - Field: ‘packages’
[17:39:33.730]   - Field: ‘gc’
[17:39:33.731]   - Field: ‘conditions’
[17:39:33.731]   - Field: ‘expr’
[17:39:33.731]   - Field: ‘uuid’
[17:39:33.731]   - Field: ‘seed’
[17:39:33.731]   - Field: ‘version’
[17:39:33.731]   - Field: ‘result’
[17:39:33.731]   - Field: ‘asynchronous’
[17:39:33.731]   - Field: ‘calls’
[17:39:33.731]   - Field: ‘globals’
[17:39:33.731]   - Field: ‘stdout’
[17:39:33.731]   - Field: ‘earlySignal’
[17:39:33.732]   - Field: ‘lazy’
[17:39:33.732]   - Field: ‘state’
[17:39:33.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.732] - Launch lazy future ...
[17:39:33.732] Packages needed by the future expression (n = 0): <none>
[17:39:33.732] Packages needed by future strategies (n = 0): <none>
[17:39:33.733] {
[17:39:33.733]     {
[17:39:33.733]         {
[17:39:33.733]             ...future.startTime <- base::Sys.time()
[17:39:33.733]             {
[17:39:33.733]                 {
[17:39:33.733]                   {
[17:39:33.733]                     base::local({
[17:39:33.733]                       has_future <- base::requireNamespace("future", 
[17:39:33.733]                         quietly = TRUE)
[17:39:33.733]                       if (has_future) {
[17:39:33.733]                         ns <- base::getNamespace("future")
[17:39:33.733]                         version <- ns[[".package"]][["version"]]
[17:39:33.733]                         if (is.null(version)) 
[17:39:33.733]                           version <- utils::packageVersion("future")
[17:39:33.733]                       }
[17:39:33.733]                       else {
[17:39:33.733]                         version <- NULL
[17:39:33.733]                       }
[17:39:33.733]                       if (!has_future || version < "1.8.0") {
[17:39:33.733]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.733]                           "", base::R.version$version.string), 
[17:39:33.733]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.733]                             "release", "version")], collapse = " "), 
[17:39:33.733]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.733]                           info)
[17:39:33.733]                         info <- base::paste(info, collapse = "; ")
[17:39:33.733]                         if (!has_future) {
[17:39:33.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.733]                             info)
[17:39:33.733]                         }
[17:39:33.733]                         else {
[17:39:33.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.733]                             info, version)
[17:39:33.733]                         }
[17:39:33.733]                         base::stop(msg)
[17:39:33.733]                       }
[17:39:33.733]                     })
[17:39:33.733]                   }
[17:39:33.733]                   ...future.strategy.old <- future::plan("list")
[17:39:33.733]                   options(future.plan = NULL)
[17:39:33.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.733]                 }
[17:39:33.733]                 ...future.workdir <- getwd()
[17:39:33.733]             }
[17:39:33.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.733]         }
[17:39:33.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.733]             base::names(...future.oldOptions))
[17:39:33.733]     }
[17:39:33.733]     if (FALSE) {
[17:39:33.733]     }
[17:39:33.733]     else {
[17:39:33.733]         if (TRUE) {
[17:39:33.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.733]                 open = "w")
[17:39:33.733]         }
[17:39:33.733]         else {
[17:39:33.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.733]         }
[17:39:33.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.733]             base::sink(type = "output", split = FALSE)
[17:39:33.733]             base::close(...future.stdout)
[17:39:33.733]         }, add = TRUE)
[17:39:33.733]     }
[17:39:33.733]     ...future.frame <- base::sys.nframe()
[17:39:33.733]     ...future.conditions <- base::list()
[17:39:33.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.733]     if (FALSE) {
[17:39:33.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.733]     }
[17:39:33.733]     ...future.result <- base::tryCatch({
[17:39:33.733]         base::withCallingHandlers({
[17:39:33.733]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.733]             future::FutureResult(value = ...future.value$value, 
[17:39:33.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.733]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.733]                     ...future.globalenv.names))
[17:39:33.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.733]         }, condition = base::local({
[17:39:33.733]             c <- base::c
[17:39:33.733]             inherits <- base::inherits
[17:39:33.733]             invokeRestart <- base::invokeRestart
[17:39:33.733]             length <- base::length
[17:39:33.733]             list <- base::list
[17:39:33.733]             seq.int <- base::seq.int
[17:39:33.733]             signalCondition <- base::signalCondition
[17:39:33.733]             sys.calls <- base::sys.calls
[17:39:33.733]             `[[` <- base::`[[`
[17:39:33.733]             `+` <- base::`+`
[17:39:33.733]             `<<-` <- base::`<<-`
[17:39:33.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.733]                   3L)]
[17:39:33.733]             }
[17:39:33.733]             function(cond) {
[17:39:33.733]                 is_error <- inherits(cond, "error")
[17:39:33.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.733]                   NULL)
[17:39:33.733]                 if (is_error) {
[17:39:33.733]                   sessionInformation <- function() {
[17:39:33.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.733]                       search = base::search(), system = base::Sys.info())
[17:39:33.733]                   }
[17:39:33.733]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.733]                     cond$call), session = sessionInformation(), 
[17:39:33.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.733]                   signalCondition(cond)
[17:39:33.733]                 }
[17:39:33.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.733]                 "immediateCondition"))) {
[17:39:33.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.733]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.733]                   if (TRUE && !signal) {
[17:39:33.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.733]                     {
[17:39:33.733]                       inherits <- base::inherits
[17:39:33.733]                       invokeRestart <- base::invokeRestart
[17:39:33.733]                       is.null <- base::is.null
[17:39:33.733]                       muffled <- FALSE
[17:39:33.733]                       if (inherits(cond, "message")) {
[17:39:33.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.733]                         if (muffled) 
[17:39:33.733]                           invokeRestart("muffleMessage")
[17:39:33.733]                       }
[17:39:33.733]                       else if (inherits(cond, "warning")) {
[17:39:33.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.733]                         if (muffled) 
[17:39:33.733]                           invokeRestart("muffleWarning")
[17:39:33.733]                       }
[17:39:33.733]                       else if (inherits(cond, "condition")) {
[17:39:33.733]                         if (!is.null(pattern)) {
[17:39:33.733]                           computeRestarts <- base::computeRestarts
[17:39:33.733]                           grepl <- base::grepl
[17:39:33.733]                           restarts <- computeRestarts(cond)
[17:39:33.733]                           for (restart in restarts) {
[17:39:33.733]                             name <- restart$name
[17:39:33.733]                             if (is.null(name)) 
[17:39:33.733]                               next
[17:39:33.733]                             if (!grepl(pattern, name)) 
[17:39:33.733]                               next
[17:39:33.733]                             invokeRestart(restart)
[17:39:33.733]                             muffled <- TRUE
[17:39:33.733]                             break
[17:39:33.733]                           }
[17:39:33.733]                         }
[17:39:33.733]                       }
[17:39:33.733]                       invisible(muffled)
[17:39:33.733]                     }
[17:39:33.733]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.733]                   }
[17:39:33.733]                 }
[17:39:33.733]                 else {
[17:39:33.733]                   if (TRUE) {
[17:39:33.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.733]                     {
[17:39:33.733]                       inherits <- base::inherits
[17:39:33.733]                       invokeRestart <- base::invokeRestart
[17:39:33.733]                       is.null <- base::is.null
[17:39:33.733]                       muffled <- FALSE
[17:39:33.733]                       if (inherits(cond, "message")) {
[17:39:33.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.733]                         if (muffled) 
[17:39:33.733]                           invokeRestart("muffleMessage")
[17:39:33.733]                       }
[17:39:33.733]                       else if (inherits(cond, "warning")) {
[17:39:33.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.733]                         if (muffled) 
[17:39:33.733]                           invokeRestart("muffleWarning")
[17:39:33.733]                       }
[17:39:33.733]                       else if (inherits(cond, "condition")) {
[17:39:33.733]                         if (!is.null(pattern)) {
[17:39:33.733]                           computeRestarts <- base::computeRestarts
[17:39:33.733]                           grepl <- base::grepl
[17:39:33.733]                           restarts <- computeRestarts(cond)
[17:39:33.733]                           for (restart in restarts) {
[17:39:33.733]                             name <- restart$name
[17:39:33.733]                             if (is.null(name)) 
[17:39:33.733]                               next
[17:39:33.733]                             if (!grepl(pattern, name)) 
[17:39:33.733]                               next
[17:39:33.733]                             invokeRestart(restart)
[17:39:33.733]                             muffled <- TRUE
[17:39:33.733]                             break
[17:39:33.733]                           }
[17:39:33.733]                         }
[17:39:33.733]                       }
[17:39:33.733]                       invisible(muffled)
[17:39:33.733]                     }
[17:39:33.733]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.733]                   }
[17:39:33.733]                 }
[17:39:33.733]             }
[17:39:33.733]         }))
[17:39:33.733]     }, error = function(ex) {
[17:39:33.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.733]                 ...future.rng), started = ...future.startTime, 
[17:39:33.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.733]             version = "1.8"), class = "FutureResult")
[17:39:33.733]     }, finally = {
[17:39:33.733]         if (!identical(...future.workdir, getwd())) 
[17:39:33.733]             setwd(...future.workdir)
[17:39:33.733]         {
[17:39:33.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.733]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.733]             }
[17:39:33.733]             base::options(...future.oldOptions)
[17:39:33.733]             if (.Platform$OS.type == "windows") {
[17:39:33.733]                 old_names <- names(...future.oldEnvVars)
[17:39:33.733]                 envs <- base::Sys.getenv()
[17:39:33.733]                 names <- names(envs)
[17:39:33.733]                 common <- intersect(names, old_names)
[17:39:33.733]                 added <- setdiff(names, old_names)
[17:39:33.733]                 removed <- setdiff(old_names, names)
[17:39:33.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.733]                   envs[common]]
[17:39:33.733]                 NAMES <- toupper(changed)
[17:39:33.733]                 args <- list()
[17:39:33.733]                 for (kk in seq_along(NAMES)) {
[17:39:33.733]                   name <- changed[[kk]]
[17:39:33.733]                   NAME <- NAMES[[kk]]
[17:39:33.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.733]                     next
[17:39:33.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.733]                 }
[17:39:33.733]                 NAMES <- toupper(added)
[17:39:33.733]                 for (kk in seq_along(NAMES)) {
[17:39:33.733]                   name <- added[[kk]]
[17:39:33.733]                   NAME <- NAMES[[kk]]
[17:39:33.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.733]                     next
[17:39:33.733]                   args[[name]] <- ""
[17:39:33.733]                 }
[17:39:33.733]                 NAMES <- toupper(removed)
[17:39:33.733]                 for (kk in seq_along(NAMES)) {
[17:39:33.733]                   name <- removed[[kk]]
[17:39:33.733]                   NAME <- NAMES[[kk]]
[17:39:33.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.733]                     next
[17:39:33.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.733]                 }
[17:39:33.733]                 if (length(args) > 0) 
[17:39:33.733]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.733]             }
[17:39:33.733]             else {
[17:39:33.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.733]             }
[17:39:33.733]             {
[17:39:33.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.733]                   0L) {
[17:39:33.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.733]                   base::options(opts)
[17:39:33.733]                 }
[17:39:33.733]                 {
[17:39:33.733]                   {
[17:39:33.733]                     NULL
[17:39:33.733]                     RNGkind("Mersenne-Twister")
[17:39:33.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.733]                       inherits = FALSE)
[17:39:33.733]                   }
[17:39:33.733]                   options(future.plan = NULL)
[17:39:33.733]                   if (is.na(NA_character_)) 
[17:39:33.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.733]                     .init = FALSE)
[17:39:33.733]                 }
[17:39:33.733]             }
[17:39:33.733]         }
[17:39:33.733]     })
[17:39:33.733]     if (TRUE) {
[17:39:33.733]         base::sink(type = "output", split = FALSE)
[17:39:33.733]         if (TRUE) {
[17:39:33.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.733]         }
[17:39:33.733]         else {
[17:39:33.733]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.733]         }
[17:39:33.733]         base::close(...future.stdout)
[17:39:33.733]         ...future.stdout <- NULL
[17:39:33.733]     }
[17:39:33.733]     ...future.result$conditions <- ...future.conditions
[17:39:33.733]     ...future.result$finished <- base::Sys.time()
[17:39:33.733]     ...future.result
[17:39:33.733] }
[17:39:33.735] plan(): Setting new future strategy stack:
[17:39:33.735] List of future strategies:
[17:39:33.735] 1. sequential:
[17:39:33.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.735]    - tweaked: FALSE
[17:39:33.735]    - call: NULL
[17:39:33.737] plan(): nbrOfWorkers() = 1
[17:39:33.738] plan(): Setting new future strategy stack:
[17:39:33.738] List of future strategies:
[17:39:33.738] 1. sequential:
[17:39:33.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.738]    - tweaked: FALSE
[17:39:33.738]    - call: plan(strategy)
[17:39:33.739] plan(): nbrOfWorkers() = 1
[17:39:33.739] SequentialFuture started (and completed)
[17:39:33.739] - Launch lazy future ... done
[17:39:33.739] run() for ‘SequentialFuture’ ... done
[17:39:33.739] getGlobalsAndPackages() ...
[17:39:33.740] Searching for globals...
[17:39:33.740] 
[17:39:33.740] Searching for globals ... DONE
[17:39:33.740] - globals: [0] <none>
[17:39:33.740] getGlobalsAndPackages() ... DONE
[17:39:33.740] run() for ‘Future’ ...
[17:39:33.741] - state: ‘created’
[17:39:33.741] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.741] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.741]   - Field: ‘label’
[17:39:33.741]   - Field: ‘local’
[17:39:33.741]   - Field: ‘owner’
[17:39:33.741]   - Field: ‘envir’
[17:39:33.742]   - Field: ‘packages’
[17:39:33.742]   - Field: ‘gc’
[17:39:33.742]   - Field: ‘conditions’
[17:39:33.742]   - Field: ‘expr’
[17:39:33.742]   - Field: ‘uuid’
[17:39:33.742]   - Field: ‘seed’
[17:39:33.742]   - Field: ‘version’
[17:39:33.742]   - Field: ‘result’
[17:39:33.742]   - Field: ‘asynchronous’
[17:39:33.742]   - Field: ‘calls’
[17:39:33.742]   - Field: ‘globals’
[17:39:33.743]   - Field: ‘stdout’
[17:39:33.743]   - Field: ‘earlySignal’
[17:39:33.743]   - Field: ‘lazy’
[17:39:33.743]   - Field: ‘state’
[17:39:33.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.743] - Launch lazy future ...
[17:39:33.743] Packages needed by the future expression (n = 0): <none>
[17:39:33.743] Packages needed by future strategies (n = 0): <none>
[17:39:33.744] {
[17:39:33.744]     {
[17:39:33.744]         {
[17:39:33.744]             ...future.startTime <- base::Sys.time()
[17:39:33.744]             {
[17:39:33.744]                 {
[17:39:33.744]                   {
[17:39:33.744]                     base::local({
[17:39:33.744]                       has_future <- base::requireNamespace("future", 
[17:39:33.744]                         quietly = TRUE)
[17:39:33.744]                       if (has_future) {
[17:39:33.744]                         ns <- base::getNamespace("future")
[17:39:33.744]                         version <- ns[[".package"]][["version"]]
[17:39:33.744]                         if (is.null(version)) 
[17:39:33.744]                           version <- utils::packageVersion("future")
[17:39:33.744]                       }
[17:39:33.744]                       else {
[17:39:33.744]                         version <- NULL
[17:39:33.744]                       }
[17:39:33.744]                       if (!has_future || version < "1.8.0") {
[17:39:33.744]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.744]                           "", base::R.version$version.string), 
[17:39:33.744]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.744]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.744]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.744]                             "release", "version")], collapse = " "), 
[17:39:33.744]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.744]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.744]                           info)
[17:39:33.744]                         info <- base::paste(info, collapse = "; ")
[17:39:33.744]                         if (!has_future) {
[17:39:33.744]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.744]                             info)
[17:39:33.744]                         }
[17:39:33.744]                         else {
[17:39:33.744]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.744]                             info, version)
[17:39:33.744]                         }
[17:39:33.744]                         base::stop(msg)
[17:39:33.744]                       }
[17:39:33.744]                     })
[17:39:33.744]                   }
[17:39:33.744]                   ...future.strategy.old <- future::plan("list")
[17:39:33.744]                   options(future.plan = NULL)
[17:39:33.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.744]                 }
[17:39:33.744]                 ...future.workdir <- getwd()
[17:39:33.744]             }
[17:39:33.744]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.744]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.744]         }
[17:39:33.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.744]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.744]             base::names(...future.oldOptions))
[17:39:33.744]     }
[17:39:33.744]     if (FALSE) {
[17:39:33.744]     }
[17:39:33.744]     else {
[17:39:33.744]         if (TRUE) {
[17:39:33.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.744]                 open = "w")
[17:39:33.744]         }
[17:39:33.744]         else {
[17:39:33.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.744]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.744]         }
[17:39:33.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.744]             base::sink(type = "output", split = FALSE)
[17:39:33.744]             base::close(...future.stdout)
[17:39:33.744]         }, add = TRUE)
[17:39:33.744]     }
[17:39:33.744]     ...future.frame <- base::sys.nframe()
[17:39:33.744]     ...future.conditions <- base::list()
[17:39:33.744]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.744]     if (FALSE) {
[17:39:33.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.744]     }
[17:39:33.744]     ...future.result <- base::tryCatch({
[17:39:33.744]         base::withCallingHandlers({
[17:39:33.744]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.744]             future::FutureResult(value = ...future.value$value, 
[17:39:33.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.744]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.744]                     ...future.globalenv.names))
[17:39:33.744]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.744]         }, condition = base::local({
[17:39:33.744]             c <- base::c
[17:39:33.744]             inherits <- base::inherits
[17:39:33.744]             invokeRestart <- base::invokeRestart
[17:39:33.744]             length <- base::length
[17:39:33.744]             list <- base::list
[17:39:33.744]             seq.int <- base::seq.int
[17:39:33.744]             signalCondition <- base::signalCondition
[17:39:33.744]             sys.calls <- base::sys.calls
[17:39:33.744]             `[[` <- base::`[[`
[17:39:33.744]             `+` <- base::`+`
[17:39:33.744]             `<<-` <- base::`<<-`
[17:39:33.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.744]                   3L)]
[17:39:33.744]             }
[17:39:33.744]             function(cond) {
[17:39:33.744]                 is_error <- inherits(cond, "error")
[17:39:33.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.744]                   NULL)
[17:39:33.744]                 if (is_error) {
[17:39:33.744]                   sessionInformation <- function() {
[17:39:33.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.744]                       search = base::search(), system = base::Sys.info())
[17:39:33.744]                   }
[17:39:33.744]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.744]                     cond$call), session = sessionInformation(), 
[17:39:33.744]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.744]                   signalCondition(cond)
[17:39:33.744]                 }
[17:39:33.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.744]                 "immediateCondition"))) {
[17:39:33.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.744]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.744]                   if (TRUE && !signal) {
[17:39:33.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.744]                     {
[17:39:33.744]                       inherits <- base::inherits
[17:39:33.744]                       invokeRestart <- base::invokeRestart
[17:39:33.744]                       is.null <- base::is.null
[17:39:33.744]                       muffled <- FALSE
[17:39:33.744]                       if (inherits(cond, "message")) {
[17:39:33.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.744]                         if (muffled) 
[17:39:33.744]                           invokeRestart("muffleMessage")
[17:39:33.744]                       }
[17:39:33.744]                       else if (inherits(cond, "warning")) {
[17:39:33.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.744]                         if (muffled) 
[17:39:33.744]                           invokeRestart("muffleWarning")
[17:39:33.744]                       }
[17:39:33.744]                       else if (inherits(cond, "condition")) {
[17:39:33.744]                         if (!is.null(pattern)) {
[17:39:33.744]                           computeRestarts <- base::computeRestarts
[17:39:33.744]                           grepl <- base::grepl
[17:39:33.744]                           restarts <- computeRestarts(cond)
[17:39:33.744]                           for (restart in restarts) {
[17:39:33.744]                             name <- restart$name
[17:39:33.744]                             if (is.null(name)) 
[17:39:33.744]                               next
[17:39:33.744]                             if (!grepl(pattern, name)) 
[17:39:33.744]                               next
[17:39:33.744]                             invokeRestart(restart)
[17:39:33.744]                             muffled <- TRUE
[17:39:33.744]                             break
[17:39:33.744]                           }
[17:39:33.744]                         }
[17:39:33.744]                       }
[17:39:33.744]                       invisible(muffled)
[17:39:33.744]                     }
[17:39:33.744]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.744]                   }
[17:39:33.744]                 }
[17:39:33.744]                 else {
[17:39:33.744]                   if (TRUE) {
[17:39:33.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.744]                     {
[17:39:33.744]                       inherits <- base::inherits
[17:39:33.744]                       invokeRestart <- base::invokeRestart
[17:39:33.744]                       is.null <- base::is.null
[17:39:33.744]                       muffled <- FALSE
[17:39:33.744]                       if (inherits(cond, "message")) {
[17:39:33.744]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.744]                         if (muffled) 
[17:39:33.744]                           invokeRestart("muffleMessage")
[17:39:33.744]                       }
[17:39:33.744]                       else if (inherits(cond, "warning")) {
[17:39:33.744]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.744]                         if (muffled) 
[17:39:33.744]                           invokeRestart("muffleWarning")
[17:39:33.744]                       }
[17:39:33.744]                       else if (inherits(cond, "condition")) {
[17:39:33.744]                         if (!is.null(pattern)) {
[17:39:33.744]                           computeRestarts <- base::computeRestarts
[17:39:33.744]                           grepl <- base::grepl
[17:39:33.744]                           restarts <- computeRestarts(cond)
[17:39:33.744]                           for (restart in restarts) {
[17:39:33.744]                             name <- restart$name
[17:39:33.744]                             if (is.null(name)) 
[17:39:33.744]                               next
[17:39:33.744]                             if (!grepl(pattern, name)) 
[17:39:33.744]                               next
[17:39:33.744]                             invokeRestart(restart)
[17:39:33.744]                             muffled <- TRUE
[17:39:33.744]                             break
[17:39:33.744]                           }
[17:39:33.744]                         }
[17:39:33.744]                       }
[17:39:33.744]                       invisible(muffled)
[17:39:33.744]                     }
[17:39:33.744]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.744]                   }
[17:39:33.744]                 }
[17:39:33.744]             }
[17:39:33.744]         }))
[17:39:33.744]     }, error = function(ex) {
[17:39:33.744]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.744]                 ...future.rng), started = ...future.startTime, 
[17:39:33.744]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.744]             version = "1.8"), class = "FutureResult")
[17:39:33.744]     }, finally = {
[17:39:33.744]         if (!identical(...future.workdir, getwd())) 
[17:39:33.744]             setwd(...future.workdir)
[17:39:33.744]         {
[17:39:33.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.744]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.744]             }
[17:39:33.744]             base::options(...future.oldOptions)
[17:39:33.744]             if (.Platform$OS.type == "windows") {
[17:39:33.744]                 old_names <- names(...future.oldEnvVars)
[17:39:33.744]                 envs <- base::Sys.getenv()
[17:39:33.744]                 names <- names(envs)
[17:39:33.744]                 common <- intersect(names, old_names)
[17:39:33.744]                 added <- setdiff(names, old_names)
[17:39:33.744]                 removed <- setdiff(old_names, names)
[17:39:33.744]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.744]                   envs[common]]
[17:39:33.744]                 NAMES <- toupper(changed)
[17:39:33.744]                 args <- list()
[17:39:33.744]                 for (kk in seq_along(NAMES)) {
[17:39:33.744]                   name <- changed[[kk]]
[17:39:33.744]                   NAME <- NAMES[[kk]]
[17:39:33.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.744]                     next
[17:39:33.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.744]                 }
[17:39:33.744]                 NAMES <- toupper(added)
[17:39:33.744]                 for (kk in seq_along(NAMES)) {
[17:39:33.744]                   name <- added[[kk]]
[17:39:33.744]                   NAME <- NAMES[[kk]]
[17:39:33.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.744]                     next
[17:39:33.744]                   args[[name]] <- ""
[17:39:33.744]                 }
[17:39:33.744]                 NAMES <- toupper(removed)
[17:39:33.744]                 for (kk in seq_along(NAMES)) {
[17:39:33.744]                   name <- removed[[kk]]
[17:39:33.744]                   NAME <- NAMES[[kk]]
[17:39:33.744]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.744]                     next
[17:39:33.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.744]                 }
[17:39:33.744]                 if (length(args) > 0) 
[17:39:33.744]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.744]             }
[17:39:33.744]             else {
[17:39:33.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.744]             }
[17:39:33.744]             {
[17:39:33.744]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.744]                   0L) {
[17:39:33.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.744]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.744]                   base::options(opts)
[17:39:33.744]                 }
[17:39:33.744]                 {
[17:39:33.744]                   {
[17:39:33.744]                     NULL
[17:39:33.744]                     RNGkind("Mersenne-Twister")
[17:39:33.744]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.744]                       inherits = FALSE)
[17:39:33.744]                   }
[17:39:33.744]                   options(future.plan = NULL)
[17:39:33.744]                   if (is.na(NA_character_)) 
[17:39:33.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.744]                     .init = FALSE)
[17:39:33.744]                 }
[17:39:33.744]             }
[17:39:33.744]         }
[17:39:33.744]     })
[17:39:33.744]     if (TRUE) {
[17:39:33.744]         base::sink(type = "output", split = FALSE)
[17:39:33.744]         if (TRUE) {
[17:39:33.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.744]         }
[17:39:33.744]         else {
[17:39:33.744]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.744]         }
[17:39:33.744]         base::close(...future.stdout)
[17:39:33.744]         ...future.stdout <- NULL
[17:39:33.744]     }
[17:39:33.744]     ...future.result$conditions <- ...future.conditions
[17:39:33.744]     ...future.result$finished <- base::Sys.time()
[17:39:33.744]     ...future.result
[17:39:33.744] }
[17:39:33.745] plan(): Setting new future strategy stack:
[17:39:33.746] List of future strategies:
[17:39:33.746] 1. sequential:
[17:39:33.746]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.746]    - tweaked: FALSE
[17:39:33.746]    - call: NULL
[17:39:33.746] plan(): nbrOfWorkers() = 1
[17:39:33.747] plan(): Setting new future strategy stack:
[17:39:33.747] List of future strategies:
[17:39:33.747] 1. sequential:
[17:39:33.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.747]    - tweaked: FALSE
[17:39:33.747]    - call: plan(strategy)
[17:39:33.747] plan(): nbrOfWorkers() = 1
[17:39:33.748] SequentialFuture started (and completed)
[17:39:33.748] - Launch lazy future ... done
[17:39:33.748] run() for ‘SequentialFuture’ ... done
[17:39:33.748] getGlobalsAndPackages() ...
[17:39:33.748] Searching for globals...
[17:39:33.749] - globals found: [1] ‘{’
[17:39:33.749] Searching for globals ... DONE
[17:39:33.749] Resolving globals: FALSE
[17:39:33.750] 
[17:39:33.750] 
[17:39:33.750] getGlobalsAndPackages() ... DONE
[17:39:33.750] run() for ‘Future’ ...
[17:39:33.750] - state: ‘created’
[17:39:33.750] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.751] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.751]   - Field: ‘label’
[17:39:33.751]   - Field: ‘local’
[17:39:33.751]   - Field: ‘owner’
[17:39:33.751]   - Field: ‘envir’
[17:39:33.751]   - Field: ‘packages’
[17:39:33.751]   - Field: ‘gc’
[17:39:33.751]   - Field: ‘conditions’
[17:39:33.752]   - Field: ‘expr’
[17:39:33.752]   - Field: ‘uuid’
[17:39:33.752]   - Field: ‘seed’
[17:39:33.752]   - Field: ‘version’
[17:39:33.752]   - Field: ‘result’
[17:39:33.752]   - Field: ‘asynchronous’
[17:39:33.752]   - Field: ‘calls’
[17:39:33.752]   - Field: ‘globals’
[17:39:33.752]   - Field: ‘stdout’
[17:39:33.752]   - Field: ‘earlySignal’
[17:39:33.753]   - Field: ‘lazy’
[17:39:33.753]   - Field: ‘state’
[17:39:33.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.753] - Launch lazy future ...
[17:39:33.753] Packages needed by the future expression (n = 0): <none>
[17:39:33.753] Packages needed by future strategies (n = 0): <none>
[17:39:33.754] {
[17:39:33.754]     {
[17:39:33.754]         {
[17:39:33.754]             ...future.startTime <- base::Sys.time()
[17:39:33.754]             {
[17:39:33.754]                 {
[17:39:33.754]                   {
[17:39:33.754]                     base::local({
[17:39:33.754]                       has_future <- base::requireNamespace("future", 
[17:39:33.754]                         quietly = TRUE)
[17:39:33.754]                       if (has_future) {
[17:39:33.754]                         ns <- base::getNamespace("future")
[17:39:33.754]                         version <- ns[[".package"]][["version"]]
[17:39:33.754]                         if (is.null(version)) 
[17:39:33.754]                           version <- utils::packageVersion("future")
[17:39:33.754]                       }
[17:39:33.754]                       else {
[17:39:33.754]                         version <- NULL
[17:39:33.754]                       }
[17:39:33.754]                       if (!has_future || version < "1.8.0") {
[17:39:33.754]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.754]                           "", base::R.version$version.string), 
[17:39:33.754]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.754]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.754]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.754]                             "release", "version")], collapse = " "), 
[17:39:33.754]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.754]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.754]                           info)
[17:39:33.754]                         info <- base::paste(info, collapse = "; ")
[17:39:33.754]                         if (!has_future) {
[17:39:33.754]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.754]                             info)
[17:39:33.754]                         }
[17:39:33.754]                         else {
[17:39:33.754]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.754]                             info, version)
[17:39:33.754]                         }
[17:39:33.754]                         base::stop(msg)
[17:39:33.754]                       }
[17:39:33.754]                     })
[17:39:33.754]                   }
[17:39:33.754]                   ...future.strategy.old <- future::plan("list")
[17:39:33.754]                   options(future.plan = NULL)
[17:39:33.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.754]                 }
[17:39:33.754]                 ...future.workdir <- getwd()
[17:39:33.754]             }
[17:39:33.754]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.754]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.754]         }
[17:39:33.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.754]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.754]             base::names(...future.oldOptions))
[17:39:33.754]     }
[17:39:33.754]     if (FALSE) {
[17:39:33.754]     }
[17:39:33.754]     else {
[17:39:33.754]         if (TRUE) {
[17:39:33.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.754]                 open = "w")
[17:39:33.754]         }
[17:39:33.754]         else {
[17:39:33.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.754]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.754]         }
[17:39:33.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.754]             base::sink(type = "output", split = FALSE)
[17:39:33.754]             base::close(...future.stdout)
[17:39:33.754]         }, add = TRUE)
[17:39:33.754]     }
[17:39:33.754]     ...future.frame <- base::sys.nframe()
[17:39:33.754]     ...future.conditions <- base::list()
[17:39:33.754]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.754]     if (FALSE) {
[17:39:33.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.754]     }
[17:39:33.754]     ...future.result <- base::tryCatch({
[17:39:33.754]         base::withCallingHandlers({
[17:39:33.754]             ...future.value <- base::withVisible(base::local({
[17:39:33.754]                 4
[17:39:33.754]             }))
[17:39:33.754]             future::FutureResult(value = ...future.value$value, 
[17:39:33.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.754]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.754]                     ...future.globalenv.names))
[17:39:33.754]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.754]         }, condition = base::local({
[17:39:33.754]             c <- base::c
[17:39:33.754]             inherits <- base::inherits
[17:39:33.754]             invokeRestart <- base::invokeRestart
[17:39:33.754]             length <- base::length
[17:39:33.754]             list <- base::list
[17:39:33.754]             seq.int <- base::seq.int
[17:39:33.754]             signalCondition <- base::signalCondition
[17:39:33.754]             sys.calls <- base::sys.calls
[17:39:33.754]             `[[` <- base::`[[`
[17:39:33.754]             `+` <- base::`+`
[17:39:33.754]             `<<-` <- base::`<<-`
[17:39:33.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.754]                   3L)]
[17:39:33.754]             }
[17:39:33.754]             function(cond) {
[17:39:33.754]                 is_error <- inherits(cond, "error")
[17:39:33.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.754]                   NULL)
[17:39:33.754]                 if (is_error) {
[17:39:33.754]                   sessionInformation <- function() {
[17:39:33.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.754]                       search = base::search(), system = base::Sys.info())
[17:39:33.754]                   }
[17:39:33.754]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.754]                     cond$call), session = sessionInformation(), 
[17:39:33.754]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.754]                   signalCondition(cond)
[17:39:33.754]                 }
[17:39:33.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.754]                 "immediateCondition"))) {
[17:39:33.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.754]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.754]                   if (TRUE && !signal) {
[17:39:33.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.754]                     {
[17:39:33.754]                       inherits <- base::inherits
[17:39:33.754]                       invokeRestart <- base::invokeRestart
[17:39:33.754]                       is.null <- base::is.null
[17:39:33.754]                       muffled <- FALSE
[17:39:33.754]                       if (inherits(cond, "message")) {
[17:39:33.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.754]                         if (muffled) 
[17:39:33.754]                           invokeRestart("muffleMessage")
[17:39:33.754]                       }
[17:39:33.754]                       else if (inherits(cond, "warning")) {
[17:39:33.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.754]                         if (muffled) 
[17:39:33.754]                           invokeRestart("muffleWarning")
[17:39:33.754]                       }
[17:39:33.754]                       else if (inherits(cond, "condition")) {
[17:39:33.754]                         if (!is.null(pattern)) {
[17:39:33.754]                           computeRestarts <- base::computeRestarts
[17:39:33.754]                           grepl <- base::grepl
[17:39:33.754]                           restarts <- computeRestarts(cond)
[17:39:33.754]                           for (restart in restarts) {
[17:39:33.754]                             name <- restart$name
[17:39:33.754]                             if (is.null(name)) 
[17:39:33.754]                               next
[17:39:33.754]                             if (!grepl(pattern, name)) 
[17:39:33.754]                               next
[17:39:33.754]                             invokeRestart(restart)
[17:39:33.754]                             muffled <- TRUE
[17:39:33.754]                             break
[17:39:33.754]                           }
[17:39:33.754]                         }
[17:39:33.754]                       }
[17:39:33.754]                       invisible(muffled)
[17:39:33.754]                     }
[17:39:33.754]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.754]                   }
[17:39:33.754]                 }
[17:39:33.754]                 else {
[17:39:33.754]                   if (TRUE) {
[17:39:33.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.754]                     {
[17:39:33.754]                       inherits <- base::inherits
[17:39:33.754]                       invokeRestart <- base::invokeRestart
[17:39:33.754]                       is.null <- base::is.null
[17:39:33.754]                       muffled <- FALSE
[17:39:33.754]                       if (inherits(cond, "message")) {
[17:39:33.754]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.754]                         if (muffled) 
[17:39:33.754]                           invokeRestart("muffleMessage")
[17:39:33.754]                       }
[17:39:33.754]                       else if (inherits(cond, "warning")) {
[17:39:33.754]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.754]                         if (muffled) 
[17:39:33.754]                           invokeRestart("muffleWarning")
[17:39:33.754]                       }
[17:39:33.754]                       else if (inherits(cond, "condition")) {
[17:39:33.754]                         if (!is.null(pattern)) {
[17:39:33.754]                           computeRestarts <- base::computeRestarts
[17:39:33.754]                           grepl <- base::grepl
[17:39:33.754]                           restarts <- computeRestarts(cond)
[17:39:33.754]                           for (restart in restarts) {
[17:39:33.754]                             name <- restart$name
[17:39:33.754]                             if (is.null(name)) 
[17:39:33.754]                               next
[17:39:33.754]                             if (!grepl(pattern, name)) 
[17:39:33.754]                               next
[17:39:33.754]                             invokeRestart(restart)
[17:39:33.754]                             muffled <- TRUE
[17:39:33.754]                             break
[17:39:33.754]                           }
[17:39:33.754]                         }
[17:39:33.754]                       }
[17:39:33.754]                       invisible(muffled)
[17:39:33.754]                     }
[17:39:33.754]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.754]                   }
[17:39:33.754]                 }
[17:39:33.754]             }
[17:39:33.754]         }))
[17:39:33.754]     }, error = function(ex) {
[17:39:33.754]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.754]                 ...future.rng), started = ...future.startTime, 
[17:39:33.754]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.754]             version = "1.8"), class = "FutureResult")
[17:39:33.754]     }, finally = {
[17:39:33.754]         if (!identical(...future.workdir, getwd())) 
[17:39:33.754]             setwd(...future.workdir)
[17:39:33.754]         {
[17:39:33.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.754]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.754]             }
[17:39:33.754]             base::options(...future.oldOptions)
[17:39:33.754]             if (.Platform$OS.type == "windows") {
[17:39:33.754]                 old_names <- names(...future.oldEnvVars)
[17:39:33.754]                 envs <- base::Sys.getenv()
[17:39:33.754]                 names <- names(envs)
[17:39:33.754]                 common <- intersect(names, old_names)
[17:39:33.754]                 added <- setdiff(names, old_names)
[17:39:33.754]                 removed <- setdiff(old_names, names)
[17:39:33.754]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.754]                   envs[common]]
[17:39:33.754]                 NAMES <- toupper(changed)
[17:39:33.754]                 args <- list()
[17:39:33.754]                 for (kk in seq_along(NAMES)) {
[17:39:33.754]                   name <- changed[[kk]]
[17:39:33.754]                   NAME <- NAMES[[kk]]
[17:39:33.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.754]                     next
[17:39:33.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.754]                 }
[17:39:33.754]                 NAMES <- toupper(added)
[17:39:33.754]                 for (kk in seq_along(NAMES)) {
[17:39:33.754]                   name <- added[[kk]]
[17:39:33.754]                   NAME <- NAMES[[kk]]
[17:39:33.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.754]                     next
[17:39:33.754]                   args[[name]] <- ""
[17:39:33.754]                 }
[17:39:33.754]                 NAMES <- toupper(removed)
[17:39:33.754]                 for (kk in seq_along(NAMES)) {
[17:39:33.754]                   name <- removed[[kk]]
[17:39:33.754]                   NAME <- NAMES[[kk]]
[17:39:33.754]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.754]                     next
[17:39:33.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.754]                 }
[17:39:33.754]                 if (length(args) > 0) 
[17:39:33.754]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.754]             }
[17:39:33.754]             else {
[17:39:33.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.754]             }
[17:39:33.754]             {
[17:39:33.754]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.754]                   0L) {
[17:39:33.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.754]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.754]                   base::options(opts)
[17:39:33.754]                 }
[17:39:33.754]                 {
[17:39:33.754]                   {
[17:39:33.754]                     NULL
[17:39:33.754]                     RNGkind("Mersenne-Twister")
[17:39:33.754]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.754]                       inherits = FALSE)
[17:39:33.754]                   }
[17:39:33.754]                   options(future.plan = NULL)
[17:39:33.754]                   if (is.na(NA_character_)) 
[17:39:33.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.754]                     .init = FALSE)
[17:39:33.754]                 }
[17:39:33.754]             }
[17:39:33.754]         }
[17:39:33.754]     })
[17:39:33.754]     if (TRUE) {
[17:39:33.754]         base::sink(type = "output", split = FALSE)
[17:39:33.754]         if (TRUE) {
[17:39:33.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.754]         }
[17:39:33.754]         else {
[17:39:33.754]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.754]         }
[17:39:33.754]         base::close(...future.stdout)
[17:39:33.754]         ...future.stdout <- NULL
[17:39:33.754]     }
[17:39:33.754]     ...future.result$conditions <- ...future.conditions
[17:39:33.754]     ...future.result$finished <- base::Sys.time()
[17:39:33.754]     ...future.result
[17:39:33.754] }
[17:39:33.755] plan(): Setting new future strategy stack:
[17:39:33.755] List of future strategies:
[17:39:33.755] 1. sequential:
[17:39:33.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.755]    - tweaked: FALSE
[17:39:33.755]    - call: NULL
[17:39:33.756] plan(): nbrOfWorkers() = 1
[17:39:33.757] plan(): Setting new future strategy stack:
[17:39:33.757] List of future strategies:
[17:39:33.757] 1. sequential:
[17:39:33.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.757]    - tweaked: FALSE
[17:39:33.757]    - call: plan(strategy)
[17:39:33.757] plan(): nbrOfWorkers() = 1
[17:39:33.758] SequentialFuture started (and completed)
[17:39:33.758] - Launch lazy future ... done
[17:39:33.758] run() for ‘SequentialFuture’ ... done
<environment: 0x55adf037be40> 
<environment: 0x55adf016e788> 
[17:39:33.759] resolved() for ‘SequentialFuture’ ...
[17:39:33.759] - state: ‘finished’
[17:39:33.759] - run: TRUE
[17:39:33.759] - result: ‘FutureResult’
[17:39:33.760] resolved() for ‘SequentialFuture’ ... done
[17:39:33.760] resolved() for ‘SequentialFuture’ ...
[17:39:33.760] - state: ‘finished’
[17:39:33.760] - run: TRUE
[17:39:33.760] - result: ‘FutureResult’
[17:39:33.760] resolved() for ‘SequentialFuture’ ... done
[17:39:33.760] resolved() for ‘SequentialFuture’ ...
[17:39:33.760] - state: ‘finished’
[17:39:33.760] - run: TRUE
[17:39:33.760] - result: ‘FutureResult’
[17:39:33.760] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:33.762] resolve() on environment ...
[17:39:33.762]  recursive: 0
[17:39:33.762]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:33.762] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.762] - nx: 4
[17:39:33.763] - relay: TRUE
[17:39:33.763] - stdout: TRUE
[17:39:33.763] - signal: TRUE
[17:39:33.763] - resignal: FALSE
[17:39:33.763] - force: TRUE
[17:39:33.763] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.763] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.763]  - until=2
[17:39:33.763]  - relaying element #2
[17:39:33.763] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.763] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.764] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.764]  length: 3 (resolved future 1)
[17:39:33.764] resolved() for ‘SequentialFuture’ ...
[17:39:33.764] - state: ‘finished’
[17:39:33.764] - run: TRUE
[17:39:33.764] - result: ‘FutureResult’
[17:39:33.764] resolved() for ‘SequentialFuture’ ... done
[17:39:33.764] Future #2
[17:39:33.764] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.764] - nx: 4
[17:39:33.765] - relay: TRUE
[17:39:33.765] - stdout: TRUE
[17:39:33.765] - signal: TRUE
[17:39:33.765] - resignal: FALSE
[17:39:33.765] - force: TRUE
[17:39:33.765] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.765] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.765]  - until=2
[17:39:33.765]  - relaying element #2
[17:39:33.765] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.766] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.766] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.766]  length: 2 (resolved future 2)
[17:39:33.766] resolved() for ‘SequentialFuture’ ...
[17:39:33.766] - state: ‘finished’
[17:39:33.766] - run: TRUE
[17:39:33.766] - result: ‘FutureResult’
[17:39:33.766] resolved() for ‘SequentialFuture’ ... done
[17:39:33.766] Future #3
[17:39:33.766] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.767] - nx: 4
[17:39:33.767] - relay: TRUE
[17:39:33.767] - stdout: TRUE
[17:39:33.767] - signal: TRUE
[17:39:33.767] - resignal: FALSE
[17:39:33.767] - force: TRUE
[17:39:33.769] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.769] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.769]  - until=3
[17:39:33.770]  - relaying element #3
[17:39:33.770] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.770] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.770] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.770]  length: 1 (resolved future 3)
[17:39:33.770] resolved() for ‘SequentialFuture’ ...
[17:39:33.770] - state: ‘finished’
[17:39:33.770] - run: TRUE
[17:39:33.770] - result: ‘FutureResult’
[17:39:33.771] resolved() for ‘SequentialFuture’ ... done
[17:39:33.771] Future #4
[17:39:33.771] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.771] - nx: 4
[17:39:33.771] - relay: TRUE
[17:39:33.771] - stdout: TRUE
[17:39:33.771] - signal: TRUE
[17:39:33.771] - resignal: FALSE
[17:39:33.771] - force: TRUE
[17:39:33.771] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.771] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.772]  - until=4
[17:39:33.772]  - relaying element #4
[17:39:33.772] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.772] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.772] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.772]  length: 0 (resolved future 4)
[17:39:33.772] Relaying remaining futures
[17:39:33.772] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.773] - nx: 4
[17:39:33.773] - relay: TRUE
[17:39:33.773] - stdout: TRUE
[17:39:33.773] - signal: TRUE
[17:39:33.773] - resignal: FALSE
[17:39:33.773] - force: TRUE
[17:39:33.773] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.773] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:33.773] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.773] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.774] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.774] resolve() on environment ... DONE
<environment: 0x55adf030b920> 
Dimensions: c(2, 1, 3, 1)
[17:39:33.774] getGlobalsAndPackages() ...
[17:39:33.774] Searching for globals...
[17:39:33.775] 
[17:39:33.775] Searching for globals ... DONE
[17:39:33.775] - globals: [0] <none>
[17:39:33.775] getGlobalsAndPackages() ... DONE
[17:39:33.775] run() for ‘Future’ ...
[17:39:33.775] - state: ‘created’
[17:39:33.775] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.776]   - Field: ‘label’
[17:39:33.776]   - Field: ‘local’
[17:39:33.776]   - Field: ‘owner’
[17:39:33.776]   - Field: ‘envir’
[17:39:33.776]   - Field: ‘packages’
[17:39:33.776]   - Field: ‘gc’
[17:39:33.777]   - Field: ‘conditions’
[17:39:33.777]   - Field: ‘expr’
[17:39:33.777]   - Field: ‘uuid’
[17:39:33.777]   - Field: ‘seed’
[17:39:33.777]   - Field: ‘version’
[17:39:33.777]   - Field: ‘result’
[17:39:33.777]   - Field: ‘asynchronous’
[17:39:33.777]   - Field: ‘calls’
[17:39:33.777]   - Field: ‘globals’
[17:39:33.777]   - Field: ‘stdout’
[17:39:33.777]   - Field: ‘earlySignal’
[17:39:33.778]   - Field: ‘lazy’
[17:39:33.778]   - Field: ‘state’
[17:39:33.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.778] - Launch lazy future ...
[17:39:33.778] Packages needed by the future expression (n = 0): <none>
[17:39:33.778] Packages needed by future strategies (n = 0): <none>
[17:39:33.779] {
[17:39:33.779]     {
[17:39:33.779]         {
[17:39:33.779]             ...future.startTime <- base::Sys.time()
[17:39:33.779]             {
[17:39:33.779]                 {
[17:39:33.779]                   {
[17:39:33.779]                     base::local({
[17:39:33.779]                       has_future <- base::requireNamespace("future", 
[17:39:33.779]                         quietly = TRUE)
[17:39:33.779]                       if (has_future) {
[17:39:33.779]                         ns <- base::getNamespace("future")
[17:39:33.779]                         version <- ns[[".package"]][["version"]]
[17:39:33.779]                         if (is.null(version)) 
[17:39:33.779]                           version <- utils::packageVersion("future")
[17:39:33.779]                       }
[17:39:33.779]                       else {
[17:39:33.779]                         version <- NULL
[17:39:33.779]                       }
[17:39:33.779]                       if (!has_future || version < "1.8.0") {
[17:39:33.779]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.779]                           "", base::R.version$version.string), 
[17:39:33.779]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.779]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.779]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.779]                             "release", "version")], collapse = " "), 
[17:39:33.779]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.779]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.779]                           info)
[17:39:33.779]                         info <- base::paste(info, collapse = "; ")
[17:39:33.779]                         if (!has_future) {
[17:39:33.779]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.779]                             info)
[17:39:33.779]                         }
[17:39:33.779]                         else {
[17:39:33.779]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.779]                             info, version)
[17:39:33.779]                         }
[17:39:33.779]                         base::stop(msg)
[17:39:33.779]                       }
[17:39:33.779]                     })
[17:39:33.779]                   }
[17:39:33.779]                   ...future.strategy.old <- future::plan("list")
[17:39:33.779]                   options(future.plan = NULL)
[17:39:33.779]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.779]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.779]                 }
[17:39:33.779]                 ...future.workdir <- getwd()
[17:39:33.779]             }
[17:39:33.779]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.779]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.779]         }
[17:39:33.779]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.779]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.779]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.779]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.779]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.779]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.779]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.779]             base::names(...future.oldOptions))
[17:39:33.779]     }
[17:39:33.779]     if (FALSE) {
[17:39:33.779]     }
[17:39:33.779]     else {
[17:39:33.779]         if (TRUE) {
[17:39:33.779]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.779]                 open = "w")
[17:39:33.779]         }
[17:39:33.779]         else {
[17:39:33.779]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.779]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.779]         }
[17:39:33.779]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.779]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.779]             base::sink(type = "output", split = FALSE)
[17:39:33.779]             base::close(...future.stdout)
[17:39:33.779]         }, add = TRUE)
[17:39:33.779]     }
[17:39:33.779]     ...future.frame <- base::sys.nframe()
[17:39:33.779]     ...future.conditions <- base::list()
[17:39:33.779]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.779]     if (FALSE) {
[17:39:33.779]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.779]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.779]     }
[17:39:33.779]     ...future.result <- base::tryCatch({
[17:39:33.779]         base::withCallingHandlers({
[17:39:33.779]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.779]             future::FutureResult(value = ...future.value$value, 
[17:39:33.779]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.779]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.779]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.779]                     ...future.globalenv.names))
[17:39:33.779]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.779]         }, condition = base::local({
[17:39:33.779]             c <- base::c
[17:39:33.779]             inherits <- base::inherits
[17:39:33.779]             invokeRestart <- base::invokeRestart
[17:39:33.779]             length <- base::length
[17:39:33.779]             list <- base::list
[17:39:33.779]             seq.int <- base::seq.int
[17:39:33.779]             signalCondition <- base::signalCondition
[17:39:33.779]             sys.calls <- base::sys.calls
[17:39:33.779]             `[[` <- base::`[[`
[17:39:33.779]             `+` <- base::`+`
[17:39:33.779]             `<<-` <- base::`<<-`
[17:39:33.779]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.779]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.779]                   3L)]
[17:39:33.779]             }
[17:39:33.779]             function(cond) {
[17:39:33.779]                 is_error <- inherits(cond, "error")
[17:39:33.779]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.779]                   NULL)
[17:39:33.779]                 if (is_error) {
[17:39:33.779]                   sessionInformation <- function() {
[17:39:33.779]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.779]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.779]                       search = base::search(), system = base::Sys.info())
[17:39:33.779]                   }
[17:39:33.779]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.779]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.779]                     cond$call), session = sessionInformation(), 
[17:39:33.779]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.779]                   signalCondition(cond)
[17:39:33.779]                 }
[17:39:33.779]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.779]                 "immediateCondition"))) {
[17:39:33.779]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.779]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.779]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.779]                   if (TRUE && !signal) {
[17:39:33.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.779]                     {
[17:39:33.779]                       inherits <- base::inherits
[17:39:33.779]                       invokeRestart <- base::invokeRestart
[17:39:33.779]                       is.null <- base::is.null
[17:39:33.779]                       muffled <- FALSE
[17:39:33.779]                       if (inherits(cond, "message")) {
[17:39:33.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.779]                         if (muffled) 
[17:39:33.779]                           invokeRestart("muffleMessage")
[17:39:33.779]                       }
[17:39:33.779]                       else if (inherits(cond, "warning")) {
[17:39:33.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.779]                         if (muffled) 
[17:39:33.779]                           invokeRestart("muffleWarning")
[17:39:33.779]                       }
[17:39:33.779]                       else if (inherits(cond, "condition")) {
[17:39:33.779]                         if (!is.null(pattern)) {
[17:39:33.779]                           computeRestarts <- base::computeRestarts
[17:39:33.779]                           grepl <- base::grepl
[17:39:33.779]                           restarts <- computeRestarts(cond)
[17:39:33.779]                           for (restart in restarts) {
[17:39:33.779]                             name <- restart$name
[17:39:33.779]                             if (is.null(name)) 
[17:39:33.779]                               next
[17:39:33.779]                             if (!grepl(pattern, name)) 
[17:39:33.779]                               next
[17:39:33.779]                             invokeRestart(restart)
[17:39:33.779]                             muffled <- TRUE
[17:39:33.779]                             break
[17:39:33.779]                           }
[17:39:33.779]                         }
[17:39:33.779]                       }
[17:39:33.779]                       invisible(muffled)
[17:39:33.779]                     }
[17:39:33.779]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.779]                   }
[17:39:33.779]                 }
[17:39:33.779]                 else {
[17:39:33.779]                   if (TRUE) {
[17:39:33.779]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.779]                     {
[17:39:33.779]                       inherits <- base::inherits
[17:39:33.779]                       invokeRestart <- base::invokeRestart
[17:39:33.779]                       is.null <- base::is.null
[17:39:33.779]                       muffled <- FALSE
[17:39:33.779]                       if (inherits(cond, "message")) {
[17:39:33.779]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.779]                         if (muffled) 
[17:39:33.779]                           invokeRestart("muffleMessage")
[17:39:33.779]                       }
[17:39:33.779]                       else if (inherits(cond, "warning")) {
[17:39:33.779]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.779]                         if (muffled) 
[17:39:33.779]                           invokeRestart("muffleWarning")
[17:39:33.779]                       }
[17:39:33.779]                       else if (inherits(cond, "condition")) {
[17:39:33.779]                         if (!is.null(pattern)) {
[17:39:33.779]                           computeRestarts <- base::computeRestarts
[17:39:33.779]                           grepl <- base::grepl
[17:39:33.779]                           restarts <- computeRestarts(cond)
[17:39:33.779]                           for (restart in restarts) {
[17:39:33.779]                             name <- restart$name
[17:39:33.779]                             if (is.null(name)) 
[17:39:33.779]                               next
[17:39:33.779]                             if (!grepl(pattern, name)) 
[17:39:33.779]                               next
[17:39:33.779]                             invokeRestart(restart)
[17:39:33.779]                             muffled <- TRUE
[17:39:33.779]                             break
[17:39:33.779]                           }
[17:39:33.779]                         }
[17:39:33.779]                       }
[17:39:33.779]                       invisible(muffled)
[17:39:33.779]                     }
[17:39:33.779]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.779]                   }
[17:39:33.779]                 }
[17:39:33.779]             }
[17:39:33.779]         }))
[17:39:33.779]     }, error = function(ex) {
[17:39:33.779]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.779]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.779]                 ...future.rng), started = ...future.startTime, 
[17:39:33.779]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.779]             version = "1.8"), class = "FutureResult")
[17:39:33.779]     }, finally = {
[17:39:33.779]         if (!identical(...future.workdir, getwd())) 
[17:39:33.779]             setwd(...future.workdir)
[17:39:33.779]         {
[17:39:33.779]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.779]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.779]             }
[17:39:33.779]             base::options(...future.oldOptions)
[17:39:33.779]             if (.Platform$OS.type == "windows") {
[17:39:33.779]                 old_names <- names(...future.oldEnvVars)
[17:39:33.779]                 envs <- base::Sys.getenv()
[17:39:33.779]                 names <- names(envs)
[17:39:33.779]                 common <- intersect(names, old_names)
[17:39:33.779]                 added <- setdiff(names, old_names)
[17:39:33.779]                 removed <- setdiff(old_names, names)
[17:39:33.779]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.779]                   envs[common]]
[17:39:33.779]                 NAMES <- toupper(changed)
[17:39:33.779]                 args <- list()
[17:39:33.779]                 for (kk in seq_along(NAMES)) {
[17:39:33.779]                   name <- changed[[kk]]
[17:39:33.779]                   NAME <- NAMES[[kk]]
[17:39:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.779]                     next
[17:39:33.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.779]                 }
[17:39:33.779]                 NAMES <- toupper(added)
[17:39:33.779]                 for (kk in seq_along(NAMES)) {
[17:39:33.779]                   name <- added[[kk]]
[17:39:33.779]                   NAME <- NAMES[[kk]]
[17:39:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.779]                     next
[17:39:33.779]                   args[[name]] <- ""
[17:39:33.779]                 }
[17:39:33.779]                 NAMES <- toupper(removed)
[17:39:33.779]                 for (kk in seq_along(NAMES)) {
[17:39:33.779]                   name <- removed[[kk]]
[17:39:33.779]                   NAME <- NAMES[[kk]]
[17:39:33.779]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.779]                     next
[17:39:33.779]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.779]                 }
[17:39:33.779]                 if (length(args) > 0) 
[17:39:33.779]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.779]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.779]             }
[17:39:33.779]             else {
[17:39:33.779]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.779]             }
[17:39:33.779]             {
[17:39:33.779]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.779]                   0L) {
[17:39:33.779]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.779]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.779]                   base::options(opts)
[17:39:33.779]                 }
[17:39:33.779]                 {
[17:39:33.779]                   {
[17:39:33.779]                     NULL
[17:39:33.779]                     RNGkind("Mersenne-Twister")
[17:39:33.779]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.779]                       inherits = FALSE)
[17:39:33.779]                   }
[17:39:33.779]                   options(future.plan = NULL)
[17:39:33.779]                   if (is.na(NA_character_)) 
[17:39:33.779]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.779]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.779]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.779]                     .init = FALSE)
[17:39:33.779]                 }
[17:39:33.779]             }
[17:39:33.779]         }
[17:39:33.779]     })
[17:39:33.779]     if (TRUE) {
[17:39:33.779]         base::sink(type = "output", split = FALSE)
[17:39:33.779]         if (TRUE) {
[17:39:33.779]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.779]         }
[17:39:33.779]         else {
[17:39:33.779]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.779]         }
[17:39:33.779]         base::close(...future.stdout)
[17:39:33.779]         ...future.stdout <- NULL
[17:39:33.779]     }
[17:39:33.779]     ...future.result$conditions <- ...future.conditions
[17:39:33.779]     ...future.result$finished <- base::Sys.time()
[17:39:33.779]     ...future.result
[17:39:33.779] }
[17:39:33.780] plan(): Setting new future strategy stack:
[17:39:33.781] List of future strategies:
[17:39:33.781] 1. sequential:
[17:39:33.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.781]    - tweaked: FALSE
[17:39:33.781]    - call: NULL
[17:39:33.781] plan(): nbrOfWorkers() = 1
[17:39:33.782] plan(): Setting new future strategy stack:
[17:39:33.782] List of future strategies:
[17:39:33.782] 1. sequential:
[17:39:33.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.782]    - tweaked: FALSE
[17:39:33.782]    - call: plan(strategy)
[17:39:33.782] plan(): nbrOfWorkers() = 1
[17:39:33.782] SequentialFuture started (and completed)
[17:39:33.783] - Launch lazy future ... done
[17:39:33.783] run() for ‘SequentialFuture’ ... done
[17:39:33.783] getGlobalsAndPackages() ...
[17:39:33.783] Searching for globals...
[17:39:33.783] 
[17:39:33.783] Searching for globals ... DONE
[17:39:33.783] - globals: [0] <none>
[17:39:33.783] getGlobalsAndPackages() ... DONE
[17:39:33.784] run() for ‘Future’ ...
[17:39:33.784] - state: ‘created’
[17:39:33.784] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.784]   - Field: ‘label’
[17:39:33.784]   - Field: ‘local’
[17:39:33.785]   - Field: ‘owner’
[17:39:33.785]   - Field: ‘envir’
[17:39:33.785]   - Field: ‘packages’
[17:39:33.785]   - Field: ‘gc’
[17:39:33.785]   - Field: ‘conditions’
[17:39:33.785]   - Field: ‘expr’
[17:39:33.785]   - Field: ‘uuid’
[17:39:33.785]   - Field: ‘seed’
[17:39:33.785]   - Field: ‘version’
[17:39:33.785]   - Field: ‘result’
[17:39:33.785]   - Field: ‘asynchronous’
[17:39:33.786]   - Field: ‘calls’
[17:39:33.786]   - Field: ‘globals’
[17:39:33.786]   - Field: ‘stdout’
[17:39:33.786]   - Field: ‘earlySignal’
[17:39:33.786]   - Field: ‘lazy’
[17:39:33.786]   - Field: ‘state’
[17:39:33.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.786] - Launch lazy future ...
[17:39:33.786] Packages needed by the future expression (n = 0): <none>
[17:39:33.786] Packages needed by future strategies (n = 0): <none>
[17:39:33.787] {
[17:39:33.787]     {
[17:39:33.787]         {
[17:39:33.787]             ...future.startTime <- base::Sys.time()
[17:39:33.787]             {
[17:39:33.787]                 {
[17:39:33.787]                   {
[17:39:33.787]                     base::local({
[17:39:33.787]                       has_future <- base::requireNamespace("future", 
[17:39:33.787]                         quietly = TRUE)
[17:39:33.787]                       if (has_future) {
[17:39:33.787]                         ns <- base::getNamespace("future")
[17:39:33.787]                         version <- ns[[".package"]][["version"]]
[17:39:33.787]                         if (is.null(version)) 
[17:39:33.787]                           version <- utils::packageVersion("future")
[17:39:33.787]                       }
[17:39:33.787]                       else {
[17:39:33.787]                         version <- NULL
[17:39:33.787]                       }
[17:39:33.787]                       if (!has_future || version < "1.8.0") {
[17:39:33.787]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.787]                           "", base::R.version$version.string), 
[17:39:33.787]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.787]                             "release", "version")], collapse = " "), 
[17:39:33.787]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.787]                           info)
[17:39:33.787]                         info <- base::paste(info, collapse = "; ")
[17:39:33.787]                         if (!has_future) {
[17:39:33.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.787]                             info)
[17:39:33.787]                         }
[17:39:33.787]                         else {
[17:39:33.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.787]                             info, version)
[17:39:33.787]                         }
[17:39:33.787]                         base::stop(msg)
[17:39:33.787]                       }
[17:39:33.787]                     })
[17:39:33.787]                   }
[17:39:33.787]                   ...future.strategy.old <- future::plan("list")
[17:39:33.787]                   options(future.plan = NULL)
[17:39:33.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.787]                 }
[17:39:33.787]                 ...future.workdir <- getwd()
[17:39:33.787]             }
[17:39:33.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.787]         }
[17:39:33.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.787]             base::names(...future.oldOptions))
[17:39:33.787]     }
[17:39:33.787]     if (FALSE) {
[17:39:33.787]     }
[17:39:33.787]     else {
[17:39:33.787]         if (TRUE) {
[17:39:33.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.787]                 open = "w")
[17:39:33.787]         }
[17:39:33.787]         else {
[17:39:33.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.787]         }
[17:39:33.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.787]             base::sink(type = "output", split = FALSE)
[17:39:33.787]             base::close(...future.stdout)
[17:39:33.787]         }, add = TRUE)
[17:39:33.787]     }
[17:39:33.787]     ...future.frame <- base::sys.nframe()
[17:39:33.787]     ...future.conditions <- base::list()
[17:39:33.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.787]     if (FALSE) {
[17:39:33.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.787]     }
[17:39:33.787]     ...future.result <- base::tryCatch({
[17:39:33.787]         base::withCallingHandlers({
[17:39:33.787]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.787]             future::FutureResult(value = ...future.value$value, 
[17:39:33.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.787]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.787]                     ...future.globalenv.names))
[17:39:33.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.787]         }, condition = base::local({
[17:39:33.787]             c <- base::c
[17:39:33.787]             inherits <- base::inherits
[17:39:33.787]             invokeRestart <- base::invokeRestart
[17:39:33.787]             length <- base::length
[17:39:33.787]             list <- base::list
[17:39:33.787]             seq.int <- base::seq.int
[17:39:33.787]             signalCondition <- base::signalCondition
[17:39:33.787]             sys.calls <- base::sys.calls
[17:39:33.787]             `[[` <- base::`[[`
[17:39:33.787]             `+` <- base::`+`
[17:39:33.787]             `<<-` <- base::`<<-`
[17:39:33.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.787]                   3L)]
[17:39:33.787]             }
[17:39:33.787]             function(cond) {
[17:39:33.787]                 is_error <- inherits(cond, "error")
[17:39:33.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.787]                   NULL)
[17:39:33.787]                 if (is_error) {
[17:39:33.787]                   sessionInformation <- function() {
[17:39:33.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.787]                       search = base::search(), system = base::Sys.info())
[17:39:33.787]                   }
[17:39:33.787]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.787]                     cond$call), session = sessionInformation(), 
[17:39:33.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.787]                   signalCondition(cond)
[17:39:33.787]                 }
[17:39:33.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.787]                 "immediateCondition"))) {
[17:39:33.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.787]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.787]                   if (TRUE && !signal) {
[17:39:33.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.787]                     {
[17:39:33.787]                       inherits <- base::inherits
[17:39:33.787]                       invokeRestart <- base::invokeRestart
[17:39:33.787]                       is.null <- base::is.null
[17:39:33.787]                       muffled <- FALSE
[17:39:33.787]                       if (inherits(cond, "message")) {
[17:39:33.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.787]                         if (muffled) 
[17:39:33.787]                           invokeRestart("muffleMessage")
[17:39:33.787]                       }
[17:39:33.787]                       else if (inherits(cond, "warning")) {
[17:39:33.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.787]                         if (muffled) 
[17:39:33.787]                           invokeRestart("muffleWarning")
[17:39:33.787]                       }
[17:39:33.787]                       else if (inherits(cond, "condition")) {
[17:39:33.787]                         if (!is.null(pattern)) {
[17:39:33.787]                           computeRestarts <- base::computeRestarts
[17:39:33.787]                           grepl <- base::grepl
[17:39:33.787]                           restarts <- computeRestarts(cond)
[17:39:33.787]                           for (restart in restarts) {
[17:39:33.787]                             name <- restart$name
[17:39:33.787]                             if (is.null(name)) 
[17:39:33.787]                               next
[17:39:33.787]                             if (!grepl(pattern, name)) 
[17:39:33.787]                               next
[17:39:33.787]                             invokeRestart(restart)
[17:39:33.787]                             muffled <- TRUE
[17:39:33.787]                             break
[17:39:33.787]                           }
[17:39:33.787]                         }
[17:39:33.787]                       }
[17:39:33.787]                       invisible(muffled)
[17:39:33.787]                     }
[17:39:33.787]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.787]                   }
[17:39:33.787]                 }
[17:39:33.787]                 else {
[17:39:33.787]                   if (TRUE) {
[17:39:33.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.787]                     {
[17:39:33.787]                       inherits <- base::inherits
[17:39:33.787]                       invokeRestart <- base::invokeRestart
[17:39:33.787]                       is.null <- base::is.null
[17:39:33.787]                       muffled <- FALSE
[17:39:33.787]                       if (inherits(cond, "message")) {
[17:39:33.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.787]                         if (muffled) 
[17:39:33.787]                           invokeRestart("muffleMessage")
[17:39:33.787]                       }
[17:39:33.787]                       else if (inherits(cond, "warning")) {
[17:39:33.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.787]                         if (muffled) 
[17:39:33.787]                           invokeRestart("muffleWarning")
[17:39:33.787]                       }
[17:39:33.787]                       else if (inherits(cond, "condition")) {
[17:39:33.787]                         if (!is.null(pattern)) {
[17:39:33.787]                           computeRestarts <- base::computeRestarts
[17:39:33.787]                           grepl <- base::grepl
[17:39:33.787]                           restarts <- computeRestarts(cond)
[17:39:33.787]                           for (restart in restarts) {
[17:39:33.787]                             name <- restart$name
[17:39:33.787]                             if (is.null(name)) 
[17:39:33.787]                               next
[17:39:33.787]                             if (!grepl(pattern, name)) 
[17:39:33.787]                               next
[17:39:33.787]                             invokeRestart(restart)
[17:39:33.787]                             muffled <- TRUE
[17:39:33.787]                             break
[17:39:33.787]                           }
[17:39:33.787]                         }
[17:39:33.787]                       }
[17:39:33.787]                       invisible(muffled)
[17:39:33.787]                     }
[17:39:33.787]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.787]                   }
[17:39:33.787]                 }
[17:39:33.787]             }
[17:39:33.787]         }))
[17:39:33.787]     }, error = function(ex) {
[17:39:33.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.787]                 ...future.rng), started = ...future.startTime, 
[17:39:33.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.787]             version = "1.8"), class = "FutureResult")
[17:39:33.787]     }, finally = {
[17:39:33.787]         if (!identical(...future.workdir, getwd())) 
[17:39:33.787]             setwd(...future.workdir)
[17:39:33.787]         {
[17:39:33.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.787]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.787]             }
[17:39:33.787]             base::options(...future.oldOptions)
[17:39:33.787]             if (.Platform$OS.type == "windows") {
[17:39:33.787]                 old_names <- names(...future.oldEnvVars)
[17:39:33.787]                 envs <- base::Sys.getenv()
[17:39:33.787]                 names <- names(envs)
[17:39:33.787]                 common <- intersect(names, old_names)
[17:39:33.787]                 added <- setdiff(names, old_names)
[17:39:33.787]                 removed <- setdiff(old_names, names)
[17:39:33.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.787]                   envs[common]]
[17:39:33.787]                 NAMES <- toupper(changed)
[17:39:33.787]                 args <- list()
[17:39:33.787]                 for (kk in seq_along(NAMES)) {
[17:39:33.787]                   name <- changed[[kk]]
[17:39:33.787]                   NAME <- NAMES[[kk]]
[17:39:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.787]                     next
[17:39:33.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.787]                 }
[17:39:33.787]                 NAMES <- toupper(added)
[17:39:33.787]                 for (kk in seq_along(NAMES)) {
[17:39:33.787]                   name <- added[[kk]]
[17:39:33.787]                   NAME <- NAMES[[kk]]
[17:39:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.787]                     next
[17:39:33.787]                   args[[name]] <- ""
[17:39:33.787]                 }
[17:39:33.787]                 NAMES <- toupper(removed)
[17:39:33.787]                 for (kk in seq_along(NAMES)) {
[17:39:33.787]                   name <- removed[[kk]]
[17:39:33.787]                   NAME <- NAMES[[kk]]
[17:39:33.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.787]                     next
[17:39:33.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.787]                 }
[17:39:33.787]                 if (length(args) > 0) 
[17:39:33.787]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.787]             }
[17:39:33.787]             else {
[17:39:33.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.787]             }
[17:39:33.787]             {
[17:39:33.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.787]                   0L) {
[17:39:33.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.787]                   base::options(opts)
[17:39:33.787]                 }
[17:39:33.787]                 {
[17:39:33.787]                   {
[17:39:33.787]                     NULL
[17:39:33.787]                     RNGkind("Mersenne-Twister")
[17:39:33.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.787]                       inherits = FALSE)
[17:39:33.787]                   }
[17:39:33.787]                   options(future.plan = NULL)
[17:39:33.787]                   if (is.na(NA_character_)) 
[17:39:33.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.787]                     .init = FALSE)
[17:39:33.787]                 }
[17:39:33.787]             }
[17:39:33.787]         }
[17:39:33.787]     })
[17:39:33.787]     if (TRUE) {
[17:39:33.787]         base::sink(type = "output", split = FALSE)
[17:39:33.787]         if (TRUE) {
[17:39:33.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.787]         }
[17:39:33.787]         else {
[17:39:33.787]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.787]         }
[17:39:33.787]         base::close(...future.stdout)
[17:39:33.787]         ...future.stdout <- NULL
[17:39:33.787]     }
[17:39:33.787]     ...future.result$conditions <- ...future.conditions
[17:39:33.787]     ...future.result$finished <- base::Sys.time()
[17:39:33.787]     ...future.result
[17:39:33.787] }
[17:39:33.789] plan(): Setting new future strategy stack:
[17:39:33.789] List of future strategies:
[17:39:33.789] 1. sequential:
[17:39:33.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.789]    - tweaked: FALSE
[17:39:33.789]    - call: NULL
[17:39:33.789] plan(): nbrOfWorkers() = 1
[17:39:33.790] plan(): Setting new future strategy stack:
[17:39:33.790] List of future strategies:
[17:39:33.790] 1. sequential:
[17:39:33.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.790]    - tweaked: FALSE
[17:39:33.790]    - call: plan(strategy)
[17:39:33.791] plan(): nbrOfWorkers() = 1
[17:39:33.791] SequentialFuture started (and completed)
[17:39:33.791] - Launch lazy future ... done
[17:39:33.791] run() for ‘SequentialFuture’ ... done
[17:39:33.791] getGlobalsAndPackages() ...
[17:39:33.791] Searching for globals...
[17:39:33.792] - globals found: [1] ‘{’
[17:39:33.792] Searching for globals ... DONE
[17:39:33.792] Resolving globals: FALSE
[17:39:33.792] 
[17:39:33.793] 
[17:39:33.793] getGlobalsAndPackages() ... DONE
[17:39:33.793] run() for ‘Future’ ...
[17:39:33.793] - state: ‘created’
[17:39:33.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.793] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.794]   - Field: ‘label’
[17:39:33.794]   - Field: ‘local’
[17:39:33.794]   - Field: ‘owner’
[17:39:33.794]   - Field: ‘envir’
[17:39:33.794]   - Field: ‘packages’
[17:39:33.794]   - Field: ‘gc’
[17:39:33.794]   - Field: ‘conditions’
[17:39:33.794]   - Field: ‘expr’
[17:39:33.794]   - Field: ‘uuid’
[17:39:33.794]   - Field: ‘seed’
[17:39:33.795]   - Field: ‘version’
[17:39:33.795]   - Field: ‘result’
[17:39:33.795]   - Field: ‘asynchronous’
[17:39:33.795]   - Field: ‘calls’
[17:39:33.795]   - Field: ‘globals’
[17:39:33.795]   - Field: ‘stdout’
[17:39:33.795]   - Field: ‘earlySignal’
[17:39:33.795]   - Field: ‘lazy’
[17:39:33.795]   - Field: ‘state’
[17:39:33.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.795] - Launch lazy future ...
[17:39:33.796] Packages needed by the future expression (n = 0): <none>
[17:39:33.796] Packages needed by future strategies (n = 0): <none>
[17:39:33.796] {
[17:39:33.796]     {
[17:39:33.796]         {
[17:39:33.796]             ...future.startTime <- base::Sys.time()
[17:39:33.796]             {
[17:39:33.796]                 {
[17:39:33.796]                   {
[17:39:33.796]                     base::local({
[17:39:33.796]                       has_future <- base::requireNamespace("future", 
[17:39:33.796]                         quietly = TRUE)
[17:39:33.796]                       if (has_future) {
[17:39:33.796]                         ns <- base::getNamespace("future")
[17:39:33.796]                         version <- ns[[".package"]][["version"]]
[17:39:33.796]                         if (is.null(version)) 
[17:39:33.796]                           version <- utils::packageVersion("future")
[17:39:33.796]                       }
[17:39:33.796]                       else {
[17:39:33.796]                         version <- NULL
[17:39:33.796]                       }
[17:39:33.796]                       if (!has_future || version < "1.8.0") {
[17:39:33.796]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.796]                           "", base::R.version$version.string), 
[17:39:33.796]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.796]                             "release", "version")], collapse = " "), 
[17:39:33.796]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.796]                           info)
[17:39:33.796]                         info <- base::paste(info, collapse = "; ")
[17:39:33.796]                         if (!has_future) {
[17:39:33.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.796]                             info)
[17:39:33.796]                         }
[17:39:33.796]                         else {
[17:39:33.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.796]                             info, version)
[17:39:33.796]                         }
[17:39:33.796]                         base::stop(msg)
[17:39:33.796]                       }
[17:39:33.796]                     })
[17:39:33.796]                   }
[17:39:33.796]                   ...future.strategy.old <- future::plan("list")
[17:39:33.796]                   options(future.plan = NULL)
[17:39:33.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.796]                 }
[17:39:33.796]                 ...future.workdir <- getwd()
[17:39:33.796]             }
[17:39:33.796]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.796]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.796]         }
[17:39:33.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.796]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.796]             base::names(...future.oldOptions))
[17:39:33.796]     }
[17:39:33.796]     if (FALSE) {
[17:39:33.796]     }
[17:39:33.796]     else {
[17:39:33.796]         if (TRUE) {
[17:39:33.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.796]                 open = "w")
[17:39:33.796]         }
[17:39:33.796]         else {
[17:39:33.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.796]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.796]         }
[17:39:33.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.796]             base::sink(type = "output", split = FALSE)
[17:39:33.796]             base::close(...future.stdout)
[17:39:33.796]         }, add = TRUE)
[17:39:33.796]     }
[17:39:33.796]     ...future.frame <- base::sys.nframe()
[17:39:33.796]     ...future.conditions <- base::list()
[17:39:33.796]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.796]     if (FALSE) {
[17:39:33.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.796]     }
[17:39:33.796]     ...future.result <- base::tryCatch({
[17:39:33.796]         base::withCallingHandlers({
[17:39:33.796]             ...future.value <- base::withVisible(base::local({
[17:39:33.796]                 4
[17:39:33.796]             }))
[17:39:33.796]             future::FutureResult(value = ...future.value$value, 
[17:39:33.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.796]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.796]                     ...future.globalenv.names))
[17:39:33.796]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.796]         }, condition = base::local({
[17:39:33.796]             c <- base::c
[17:39:33.796]             inherits <- base::inherits
[17:39:33.796]             invokeRestart <- base::invokeRestart
[17:39:33.796]             length <- base::length
[17:39:33.796]             list <- base::list
[17:39:33.796]             seq.int <- base::seq.int
[17:39:33.796]             signalCondition <- base::signalCondition
[17:39:33.796]             sys.calls <- base::sys.calls
[17:39:33.796]             `[[` <- base::`[[`
[17:39:33.796]             `+` <- base::`+`
[17:39:33.796]             `<<-` <- base::`<<-`
[17:39:33.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.796]                   3L)]
[17:39:33.796]             }
[17:39:33.796]             function(cond) {
[17:39:33.796]                 is_error <- inherits(cond, "error")
[17:39:33.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.796]                   NULL)
[17:39:33.796]                 if (is_error) {
[17:39:33.796]                   sessionInformation <- function() {
[17:39:33.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.796]                       search = base::search(), system = base::Sys.info())
[17:39:33.796]                   }
[17:39:33.796]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.796]                     cond$call), session = sessionInformation(), 
[17:39:33.796]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.796]                   signalCondition(cond)
[17:39:33.796]                 }
[17:39:33.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.796]                 "immediateCondition"))) {
[17:39:33.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.796]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.796]                   if (TRUE && !signal) {
[17:39:33.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.796]                     {
[17:39:33.796]                       inherits <- base::inherits
[17:39:33.796]                       invokeRestart <- base::invokeRestart
[17:39:33.796]                       is.null <- base::is.null
[17:39:33.796]                       muffled <- FALSE
[17:39:33.796]                       if (inherits(cond, "message")) {
[17:39:33.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.796]                         if (muffled) 
[17:39:33.796]                           invokeRestart("muffleMessage")
[17:39:33.796]                       }
[17:39:33.796]                       else if (inherits(cond, "warning")) {
[17:39:33.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.796]                         if (muffled) 
[17:39:33.796]                           invokeRestart("muffleWarning")
[17:39:33.796]                       }
[17:39:33.796]                       else if (inherits(cond, "condition")) {
[17:39:33.796]                         if (!is.null(pattern)) {
[17:39:33.796]                           computeRestarts <- base::computeRestarts
[17:39:33.796]                           grepl <- base::grepl
[17:39:33.796]                           restarts <- computeRestarts(cond)
[17:39:33.796]                           for (restart in restarts) {
[17:39:33.796]                             name <- restart$name
[17:39:33.796]                             if (is.null(name)) 
[17:39:33.796]                               next
[17:39:33.796]                             if (!grepl(pattern, name)) 
[17:39:33.796]                               next
[17:39:33.796]                             invokeRestart(restart)
[17:39:33.796]                             muffled <- TRUE
[17:39:33.796]                             break
[17:39:33.796]                           }
[17:39:33.796]                         }
[17:39:33.796]                       }
[17:39:33.796]                       invisible(muffled)
[17:39:33.796]                     }
[17:39:33.796]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.796]                   }
[17:39:33.796]                 }
[17:39:33.796]                 else {
[17:39:33.796]                   if (TRUE) {
[17:39:33.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.796]                     {
[17:39:33.796]                       inherits <- base::inherits
[17:39:33.796]                       invokeRestart <- base::invokeRestart
[17:39:33.796]                       is.null <- base::is.null
[17:39:33.796]                       muffled <- FALSE
[17:39:33.796]                       if (inherits(cond, "message")) {
[17:39:33.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.796]                         if (muffled) 
[17:39:33.796]                           invokeRestart("muffleMessage")
[17:39:33.796]                       }
[17:39:33.796]                       else if (inherits(cond, "warning")) {
[17:39:33.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.796]                         if (muffled) 
[17:39:33.796]                           invokeRestart("muffleWarning")
[17:39:33.796]                       }
[17:39:33.796]                       else if (inherits(cond, "condition")) {
[17:39:33.796]                         if (!is.null(pattern)) {
[17:39:33.796]                           computeRestarts <- base::computeRestarts
[17:39:33.796]                           grepl <- base::grepl
[17:39:33.796]                           restarts <- computeRestarts(cond)
[17:39:33.796]                           for (restart in restarts) {
[17:39:33.796]                             name <- restart$name
[17:39:33.796]                             if (is.null(name)) 
[17:39:33.796]                               next
[17:39:33.796]                             if (!grepl(pattern, name)) 
[17:39:33.796]                               next
[17:39:33.796]                             invokeRestart(restart)
[17:39:33.796]                             muffled <- TRUE
[17:39:33.796]                             break
[17:39:33.796]                           }
[17:39:33.796]                         }
[17:39:33.796]                       }
[17:39:33.796]                       invisible(muffled)
[17:39:33.796]                     }
[17:39:33.796]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.796]                   }
[17:39:33.796]                 }
[17:39:33.796]             }
[17:39:33.796]         }))
[17:39:33.796]     }, error = function(ex) {
[17:39:33.796]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.796]                 ...future.rng), started = ...future.startTime, 
[17:39:33.796]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.796]             version = "1.8"), class = "FutureResult")
[17:39:33.796]     }, finally = {
[17:39:33.796]         if (!identical(...future.workdir, getwd())) 
[17:39:33.796]             setwd(...future.workdir)
[17:39:33.796]         {
[17:39:33.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.796]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.796]             }
[17:39:33.796]             base::options(...future.oldOptions)
[17:39:33.796]             if (.Platform$OS.type == "windows") {
[17:39:33.796]                 old_names <- names(...future.oldEnvVars)
[17:39:33.796]                 envs <- base::Sys.getenv()
[17:39:33.796]                 names <- names(envs)
[17:39:33.796]                 common <- intersect(names, old_names)
[17:39:33.796]                 added <- setdiff(names, old_names)
[17:39:33.796]                 removed <- setdiff(old_names, names)
[17:39:33.796]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.796]                   envs[common]]
[17:39:33.796]                 NAMES <- toupper(changed)
[17:39:33.796]                 args <- list()
[17:39:33.796]                 for (kk in seq_along(NAMES)) {
[17:39:33.796]                   name <- changed[[kk]]
[17:39:33.796]                   NAME <- NAMES[[kk]]
[17:39:33.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.796]                     next
[17:39:33.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.796]                 }
[17:39:33.796]                 NAMES <- toupper(added)
[17:39:33.796]                 for (kk in seq_along(NAMES)) {
[17:39:33.796]                   name <- added[[kk]]
[17:39:33.796]                   NAME <- NAMES[[kk]]
[17:39:33.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.796]                     next
[17:39:33.796]                   args[[name]] <- ""
[17:39:33.796]                 }
[17:39:33.796]                 NAMES <- toupper(removed)
[17:39:33.796]                 for (kk in seq_along(NAMES)) {
[17:39:33.796]                   name <- removed[[kk]]
[17:39:33.796]                   NAME <- NAMES[[kk]]
[17:39:33.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.796]                     next
[17:39:33.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.796]                 }
[17:39:33.796]                 if (length(args) > 0) 
[17:39:33.796]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.796]             }
[17:39:33.796]             else {
[17:39:33.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.796]             }
[17:39:33.796]             {
[17:39:33.796]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.796]                   0L) {
[17:39:33.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.796]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.796]                   base::options(opts)
[17:39:33.796]                 }
[17:39:33.796]                 {
[17:39:33.796]                   {
[17:39:33.796]                     NULL
[17:39:33.796]                     RNGkind("Mersenne-Twister")
[17:39:33.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.796]                       inherits = FALSE)
[17:39:33.796]                   }
[17:39:33.796]                   options(future.plan = NULL)
[17:39:33.796]                   if (is.na(NA_character_)) 
[17:39:33.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.796]                     .init = FALSE)
[17:39:33.796]                 }
[17:39:33.796]             }
[17:39:33.796]         }
[17:39:33.796]     })
[17:39:33.796]     if (TRUE) {
[17:39:33.796]         base::sink(type = "output", split = FALSE)
[17:39:33.796]         if (TRUE) {
[17:39:33.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.796]         }
[17:39:33.796]         else {
[17:39:33.796]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.796]         }
[17:39:33.796]         base::close(...future.stdout)
[17:39:33.796]         ...future.stdout <- NULL
[17:39:33.796]     }
[17:39:33.796]     ...future.result$conditions <- ...future.conditions
[17:39:33.796]     ...future.result$finished <- base::Sys.time()
[17:39:33.796]     ...future.result
[17:39:33.796] }
[17:39:33.798] plan(): Setting new future strategy stack:
[17:39:33.798] List of future strategies:
[17:39:33.798] 1. sequential:
[17:39:33.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.798]    - tweaked: FALSE
[17:39:33.798]    - call: NULL
[17:39:33.798] plan(): nbrOfWorkers() = 1
[17:39:33.801] plan(): Setting new future strategy stack:
[17:39:33.801] List of future strategies:
[17:39:33.801] 1. sequential:
[17:39:33.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.801]    - tweaked: FALSE
[17:39:33.801]    - call: plan(strategy)
[17:39:33.802] plan(): nbrOfWorkers() = 1
[17:39:33.802] SequentialFuture started (and completed)
[17:39:33.802] - Launch lazy future ... done
[17:39:33.802] run() for ‘SequentialFuture’ ... done
<environment: 0x55adedd50f38> 
<environment: 0x55adee8b80d0> 
[17:39:33.804] resolved() for ‘SequentialFuture’ ...
[17:39:33.804] - state: ‘finished’
[17:39:33.804] - run: TRUE
[17:39:33.804] - result: ‘FutureResult’
[17:39:33.804] resolved() for ‘SequentialFuture’ ... done
[17:39:33.804] resolved() for ‘SequentialFuture’ ...
[17:39:33.804] - state: ‘finished’
[17:39:33.804] - run: TRUE
[17:39:33.804] - result: ‘FutureResult’
[17:39:33.805] resolved() for ‘SequentialFuture’ ... done
[17:39:33.805] resolved() for ‘SequentialFuture’ ...
[17:39:33.805] - state: ‘finished’
[17:39:33.805] - run: TRUE
[17:39:33.805] - result: ‘FutureResult’
[17:39:33.805] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:33.806] resolve() on environment ...
[17:39:33.806]  recursive: 0
[17:39:33.807]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:33.807] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.807] - nx: 4
[17:39:33.807] - relay: TRUE
[17:39:33.807] - stdout: TRUE
[17:39:33.807] - signal: TRUE
[17:39:33.807] - resignal: FALSE
[17:39:33.807] - force: TRUE
[17:39:33.807] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.807] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.808]  - until=2
[17:39:33.808]  - relaying element #2
[17:39:33.808] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.808] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.808] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.808]  length: 3 (resolved future 1)
[17:39:33.808] resolved() for ‘SequentialFuture’ ...
[17:39:33.808] - state: ‘finished’
[17:39:33.808] - run: TRUE
[17:39:33.808] - result: ‘FutureResult’
[17:39:33.809] resolved() for ‘SequentialFuture’ ... done
[17:39:33.809] Future #2
[17:39:33.809] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.809] - nx: 4
[17:39:33.809] - relay: TRUE
[17:39:33.809] - stdout: TRUE
[17:39:33.809] - signal: TRUE
[17:39:33.809] - resignal: FALSE
[17:39:33.809] - force: TRUE
[17:39:33.809] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:33.809] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:33.810]  - until=2
[17:39:33.810]  - relaying element #2
[17:39:33.810] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.810] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.810] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.810]  length: 2 (resolved future 2)
[17:39:33.810] resolved() for ‘SequentialFuture’ ...
[17:39:33.810] - state: ‘finished’
[17:39:33.810] - run: TRUE
[17:39:33.810] - result: ‘FutureResult’
[17:39:33.811] resolved() for ‘SequentialFuture’ ... done
[17:39:33.811] Future #3
[17:39:33.811] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.811] - nx: 4
[17:39:33.811] - relay: TRUE
[17:39:33.811] - stdout: TRUE
[17:39:33.811] - signal: TRUE
[17:39:33.811] - resignal: FALSE
[17:39:33.811] - force: TRUE
[17:39:33.811] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:33.811] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:33.812]  - until=3
[17:39:33.812]  - relaying element #3
[17:39:33.812] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.812] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.812] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.812]  length: 1 (resolved future 3)
[17:39:33.812] resolved() for ‘SequentialFuture’ ...
[17:39:33.812] - state: ‘finished’
[17:39:33.812] - run: TRUE
[17:39:33.812] - result: ‘FutureResult’
[17:39:33.813] resolved() for ‘SequentialFuture’ ... done
[17:39:33.813] Future #4
[17:39:33.813] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.813] - nx: 4
[17:39:33.813] - relay: TRUE
[17:39:33.813] - stdout: TRUE
[17:39:33.813] - signal: TRUE
[17:39:33.813] - resignal: FALSE
[17:39:33.813] - force: TRUE
[17:39:33.813] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:33.813] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:33.814]  - until=4
[17:39:33.814]  - relaying element #4
[17:39:33.814] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.814] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.814] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.814]  length: 0 (resolved future 4)
[17:39:33.814] Relaying remaining futures
[17:39:33.814] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.814] - nx: 4
[17:39:33.814] - relay: TRUE
[17:39:33.815] - stdout: TRUE
[17:39:33.815] - signal: TRUE
[17:39:33.815] - resignal: FALSE
[17:39:33.815] - force: TRUE
[17:39:33.815] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.815] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:33.815] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:33.815] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:33.815] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.815] resolve() on environment ... DONE
<environment: 0x55adeddb7cf8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[17:39:33.816] plan(): Setting new future strategy stack:
[17:39:33.816] List of future strategies:
[17:39:33.816] 1. sequential:
[17:39:33.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.816]    - tweaked: FALSE
[17:39:33.816]    - call: plan(strategy)
[17:39:33.817] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:39:33.817] getGlobalsAndPackages() ...
[17:39:33.817] Searching for globals...
[17:39:33.818] 
[17:39:33.818] Searching for globals ... DONE
[17:39:33.818] - globals: [0] <none>
[17:39:33.818] getGlobalsAndPackages() ... DONE
[17:39:33.818] run() for ‘Future’ ...
[17:39:33.818] - state: ‘created’
[17:39:33.818] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.819]   - Field: ‘label’
[17:39:33.819]   - Field: ‘local’
[17:39:33.819]   - Field: ‘owner’
[17:39:33.819]   - Field: ‘envir’
[17:39:33.819]   - Field: ‘packages’
[17:39:33.819]   - Field: ‘gc’
[17:39:33.819]   - Field: ‘conditions’
[17:39:33.819]   - Field: ‘expr’
[17:39:33.820]   - Field: ‘uuid’
[17:39:33.820]   - Field: ‘seed’
[17:39:33.820]   - Field: ‘version’
[17:39:33.820]   - Field: ‘result’
[17:39:33.820]   - Field: ‘asynchronous’
[17:39:33.820]   - Field: ‘calls’
[17:39:33.820]   - Field: ‘globals’
[17:39:33.820]   - Field: ‘stdout’
[17:39:33.820]   - Field: ‘earlySignal’
[17:39:33.820]   - Field: ‘lazy’
[17:39:33.821]   - Field: ‘state’
[17:39:33.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.821] - Launch lazy future ...
[17:39:33.821] Packages needed by the future expression (n = 0): <none>
[17:39:33.821] Packages needed by future strategies (n = 0): <none>
[17:39:33.821] {
[17:39:33.821]     {
[17:39:33.821]         {
[17:39:33.821]             ...future.startTime <- base::Sys.time()
[17:39:33.821]             {
[17:39:33.821]                 {
[17:39:33.821]                   {
[17:39:33.821]                     base::local({
[17:39:33.821]                       has_future <- base::requireNamespace("future", 
[17:39:33.821]                         quietly = TRUE)
[17:39:33.821]                       if (has_future) {
[17:39:33.821]                         ns <- base::getNamespace("future")
[17:39:33.821]                         version <- ns[[".package"]][["version"]]
[17:39:33.821]                         if (is.null(version)) 
[17:39:33.821]                           version <- utils::packageVersion("future")
[17:39:33.821]                       }
[17:39:33.821]                       else {
[17:39:33.821]                         version <- NULL
[17:39:33.821]                       }
[17:39:33.821]                       if (!has_future || version < "1.8.0") {
[17:39:33.821]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.821]                           "", base::R.version$version.string), 
[17:39:33.821]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.821]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.821]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.821]                             "release", "version")], collapse = " "), 
[17:39:33.821]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.821]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.821]                           info)
[17:39:33.821]                         info <- base::paste(info, collapse = "; ")
[17:39:33.821]                         if (!has_future) {
[17:39:33.821]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.821]                             info)
[17:39:33.821]                         }
[17:39:33.821]                         else {
[17:39:33.821]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.821]                             info, version)
[17:39:33.821]                         }
[17:39:33.821]                         base::stop(msg)
[17:39:33.821]                       }
[17:39:33.821]                     })
[17:39:33.821]                   }
[17:39:33.821]                   ...future.strategy.old <- future::plan("list")
[17:39:33.821]                   options(future.plan = NULL)
[17:39:33.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.821]                 }
[17:39:33.821]                 ...future.workdir <- getwd()
[17:39:33.821]             }
[17:39:33.821]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.821]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.821]         }
[17:39:33.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.821]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.821]             base::names(...future.oldOptions))
[17:39:33.821]     }
[17:39:33.821]     if (FALSE) {
[17:39:33.821]     }
[17:39:33.821]     else {
[17:39:33.821]         if (TRUE) {
[17:39:33.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.821]                 open = "w")
[17:39:33.821]         }
[17:39:33.821]         else {
[17:39:33.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.821]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.821]         }
[17:39:33.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.821]             base::sink(type = "output", split = FALSE)
[17:39:33.821]             base::close(...future.stdout)
[17:39:33.821]         }, add = TRUE)
[17:39:33.821]     }
[17:39:33.821]     ...future.frame <- base::sys.nframe()
[17:39:33.821]     ...future.conditions <- base::list()
[17:39:33.821]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.821]     if (FALSE) {
[17:39:33.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.821]     }
[17:39:33.821]     ...future.result <- base::tryCatch({
[17:39:33.821]         base::withCallingHandlers({
[17:39:33.821]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.821]             future::FutureResult(value = ...future.value$value, 
[17:39:33.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.821]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.821]                     ...future.globalenv.names))
[17:39:33.821]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.821]         }, condition = base::local({
[17:39:33.821]             c <- base::c
[17:39:33.821]             inherits <- base::inherits
[17:39:33.821]             invokeRestart <- base::invokeRestart
[17:39:33.821]             length <- base::length
[17:39:33.821]             list <- base::list
[17:39:33.821]             seq.int <- base::seq.int
[17:39:33.821]             signalCondition <- base::signalCondition
[17:39:33.821]             sys.calls <- base::sys.calls
[17:39:33.821]             `[[` <- base::`[[`
[17:39:33.821]             `+` <- base::`+`
[17:39:33.821]             `<<-` <- base::`<<-`
[17:39:33.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.821]                   3L)]
[17:39:33.821]             }
[17:39:33.821]             function(cond) {
[17:39:33.821]                 is_error <- inherits(cond, "error")
[17:39:33.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.821]                   NULL)
[17:39:33.821]                 if (is_error) {
[17:39:33.821]                   sessionInformation <- function() {
[17:39:33.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.821]                       search = base::search(), system = base::Sys.info())
[17:39:33.821]                   }
[17:39:33.821]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.821]                     cond$call), session = sessionInformation(), 
[17:39:33.821]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.821]                   signalCondition(cond)
[17:39:33.821]                 }
[17:39:33.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.821]                 "immediateCondition"))) {
[17:39:33.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.821]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.821]                   if (TRUE && !signal) {
[17:39:33.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.821]                     {
[17:39:33.821]                       inherits <- base::inherits
[17:39:33.821]                       invokeRestart <- base::invokeRestart
[17:39:33.821]                       is.null <- base::is.null
[17:39:33.821]                       muffled <- FALSE
[17:39:33.821]                       if (inherits(cond, "message")) {
[17:39:33.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.821]                         if (muffled) 
[17:39:33.821]                           invokeRestart("muffleMessage")
[17:39:33.821]                       }
[17:39:33.821]                       else if (inherits(cond, "warning")) {
[17:39:33.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.821]                         if (muffled) 
[17:39:33.821]                           invokeRestart("muffleWarning")
[17:39:33.821]                       }
[17:39:33.821]                       else if (inherits(cond, "condition")) {
[17:39:33.821]                         if (!is.null(pattern)) {
[17:39:33.821]                           computeRestarts <- base::computeRestarts
[17:39:33.821]                           grepl <- base::grepl
[17:39:33.821]                           restarts <- computeRestarts(cond)
[17:39:33.821]                           for (restart in restarts) {
[17:39:33.821]                             name <- restart$name
[17:39:33.821]                             if (is.null(name)) 
[17:39:33.821]                               next
[17:39:33.821]                             if (!grepl(pattern, name)) 
[17:39:33.821]                               next
[17:39:33.821]                             invokeRestart(restart)
[17:39:33.821]                             muffled <- TRUE
[17:39:33.821]                             break
[17:39:33.821]                           }
[17:39:33.821]                         }
[17:39:33.821]                       }
[17:39:33.821]                       invisible(muffled)
[17:39:33.821]                     }
[17:39:33.821]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.821]                   }
[17:39:33.821]                 }
[17:39:33.821]                 else {
[17:39:33.821]                   if (TRUE) {
[17:39:33.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.821]                     {
[17:39:33.821]                       inherits <- base::inherits
[17:39:33.821]                       invokeRestart <- base::invokeRestart
[17:39:33.821]                       is.null <- base::is.null
[17:39:33.821]                       muffled <- FALSE
[17:39:33.821]                       if (inherits(cond, "message")) {
[17:39:33.821]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.821]                         if (muffled) 
[17:39:33.821]                           invokeRestart("muffleMessage")
[17:39:33.821]                       }
[17:39:33.821]                       else if (inherits(cond, "warning")) {
[17:39:33.821]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.821]                         if (muffled) 
[17:39:33.821]                           invokeRestart("muffleWarning")
[17:39:33.821]                       }
[17:39:33.821]                       else if (inherits(cond, "condition")) {
[17:39:33.821]                         if (!is.null(pattern)) {
[17:39:33.821]                           computeRestarts <- base::computeRestarts
[17:39:33.821]                           grepl <- base::grepl
[17:39:33.821]                           restarts <- computeRestarts(cond)
[17:39:33.821]                           for (restart in restarts) {
[17:39:33.821]                             name <- restart$name
[17:39:33.821]                             if (is.null(name)) 
[17:39:33.821]                               next
[17:39:33.821]                             if (!grepl(pattern, name)) 
[17:39:33.821]                               next
[17:39:33.821]                             invokeRestart(restart)
[17:39:33.821]                             muffled <- TRUE
[17:39:33.821]                             break
[17:39:33.821]                           }
[17:39:33.821]                         }
[17:39:33.821]                       }
[17:39:33.821]                       invisible(muffled)
[17:39:33.821]                     }
[17:39:33.821]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.821]                   }
[17:39:33.821]                 }
[17:39:33.821]             }
[17:39:33.821]         }))
[17:39:33.821]     }, error = function(ex) {
[17:39:33.821]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.821]                 ...future.rng), started = ...future.startTime, 
[17:39:33.821]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.821]             version = "1.8"), class = "FutureResult")
[17:39:33.821]     }, finally = {
[17:39:33.821]         if (!identical(...future.workdir, getwd())) 
[17:39:33.821]             setwd(...future.workdir)
[17:39:33.821]         {
[17:39:33.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.821]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.821]             }
[17:39:33.821]             base::options(...future.oldOptions)
[17:39:33.821]             if (.Platform$OS.type == "windows") {
[17:39:33.821]                 old_names <- names(...future.oldEnvVars)
[17:39:33.821]                 envs <- base::Sys.getenv()
[17:39:33.821]                 names <- names(envs)
[17:39:33.821]                 common <- intersect(names, old_names)
[17:39:33.821]                 added <- setdiff(names, old_names)
[17:39:33.821]                 removed <- setdiff(old_names, names)
[17:39:33.821]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.821]                   envs[common]]
[17:39:33.821]                 NAMES <- toupper(changed)
[17:39:33.821]                 args <- list()
[17:39:33.821]                 for (kk in seq_along(NAMES)) {
[17:39:33.821]                   name <- changed[[kk]]
[17:39:33.821]                   NAME <- NAMES[[kk]]
[17:39:33.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.821]                     next
[17:39:33.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.821]                 }
[17:39:33.821]                 NAMES <- toupper(added)
[17:39:33.821]                 for (kk in seq_along(NAMES)) {
[17:39:33.821]                   name <- added[[kk]]
[17:39:33.821]                   NAME <- NAMES[[kk]]
[17:39:33.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.821]                     next
[17:39:33.821]                   args[[name]] <- ""
[17:39:33.821]                 }
[17:39:33.821]                 NAMES <- toupper(removed)
[17:39:33.821]                 for (kk in seq_along(NAMES)) {
[17:39:33.821]                   name <- removed[[kk]]
[17:39:33.821]                   NAME <- NAMES[[kk]]
[17:39:33.821]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.821]                     next
[17:39:33.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.821]                 }
[17:39:33.821]                 if (length(args) > 0) 
[17:39:33.821]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.821]             }
[17:39:33.821]             else {
[17:39:33.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.821]             }
[17:39:33.821]             {
[17:39:33.821]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.821]                   0L) {
[17:39:33.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.821]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.821]                   base::options(opts)
[17:39:33.821]                 }
[17:39:33.821]                 {
[17:39:33.821]                   {
[17:39:33.821]                     NULL
[17:39:33.821]                     RNGkind("Mersenne-Twister")
[17:39:33.821]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.821]                       inherits = FALSE)
[17:39:33.821]                   }
[17:39:33.821]                   options(future.plan = NULL)
[17:39:33.821]                   if (is.na(NA_character_)) 
[17:39:33.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.821]                     .init = FALSE)
[17:39:33.821]                 }
[17:39:33.821]             }
[17:39:33.821]         }
[17:39:33.821]     })
[17:39:33.821]     if (TRUE) {
[17:39:33.821]         base::sink(type = "output", split = FALSE)
[17:39:33.821]         if (TRUE) {
[17:39:33.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.821]         }
[17:39:33.821]         else {
[17:39:33.821]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.821]         }
[17:39:33.821]         base::close(...future.stdout)
[17:39:33.821]         ...future.stdout <- NULL
[17:39:33.821]     }
[17:39:33.821]     ...future.result$conditions <- ...future.conditions
[17:39:33.821]     ...future.result$finished <- base::Sys.time()
[17:39:33.821]     ...future.result
[17:39:33.821] }
[17:39:33.823] plan(): Setting new future strategy stack:
[17:39:33.823] List of future strategies:
[17:39:33.823] 1. sequential:
[17:39:33.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.823]    - tweaked: FALSE
[17:39:33.823]    - call: NULL
[17:39:33.824] plan(): nbrOfWorkers() = 1
[17:39:33.825] plan(): Setting new future strategy stack:
[17:39:33.825] List of future strategies:
[17:39:33.825] 1. sequential:
[17:39:33.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.825]    - tweaked: FALSE
[17:39:33.825]    - call: plan(strategy)
[17:39:33.825] plan(): nbrOfWorkers() = 1
[17:39:33.825] SequentialFuture started (and completed)
[17:39:33.825] - Launch lazy future ... done
[17:39:33.825] run() for ‘SequentialFuture’ ... done
[17:39:33.826] getGlobalsAndPackages() ...
[17:39:33.826] Searching for globals...
[17:39:33.826] 
[17:39:33.826] Searching for globals ... DONE
[17:39:33.826] - globals: [0] <none>
[17:39:33.826] getGlobalsAndPackages() ... DONE
[17:39:33.826] run() for ‘Future’ ...
[17:39:33.827] - state: ‘created’
[17:39:33.827] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.827] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.827] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.827]   - Field: ‘label’
[17:39:33.827]   - Field: ‘local’
[17:39:33.829]   - Field: ‘owner’
[17:39:33.830]   - Field: ‘envir’
[17:39:33.830]   - Field: ‘packages’
[17:39:33.830]   - Field: ‘gc’
[17:39:33.830]   - Field: ‘conditions’
[17:39:33.830]   - Field: ‘expr’
[17:39:33.830]   - Field: ‘uuid’
[17:39:33.830]   - Field: ‘seed’
[17:39:33.830]   - Field: ‘version’
[17:39:33.830]   - Field: ‘result’
[17:39:33.830]   - Field: ‘asynchronous’
[17:39:33.831]   - Field: ‘calls’
[17:39:33.831]   - Field: ‘globals’
[17:39:33.831]   - Field: ‘stdout’
[17:39:33.831]   - Field: ‘earlySignal’
[17:39:33.831]   - Field: ‘lazy’
[17:39:33.831]   - Field: ‘state’
[17:39:33.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.831] - Launch lazy future ...
[17:39:33.831] Packages needed by the future expression (n = 0): <none>
[17:39:33.831] Packages needed by future strategies (n = 0): <none>
[17:39:33.832] {
[17:39:33.832]     {
[17:39:33.832]         {
[17:39:33.832]             ...future.startTime <- base::Sys.time()
[17:39:33.832]             {
[17:39:33.832]                 {
[17:39:33.832]                   {
[17:39:33.832]                     base::local({
[17:39:33.832]                       has_future <- base::requireNamespace("future", 
[17:39:33.832]                         quietly = TRUE)
[17:39:33.832]                       if (has_future) {
[17:39:33.832]                         ns <- base::getNamespace("future")
[17:39:33.832]                         version <- ns[[".package"]][["version"]]
[17:39:33.832]                         if (is.null(version)) 
[17:39:33.832]                           version <- utils::packageVersion("future")
[17:39:33.832]                       }
[17:39:33.832]                       else {
[17:39:33.832]                         version <- NULL
[17:39:33.832]                       }
[17:39:33.832]                       if (!has_future || version < "1.8.0") {
[17:39:33.832]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.832]                           "", base::R.version$version.string), 
[17:39:33.832]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.832]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.832]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.832]                             "release", "version")], collapse = " "), 
[17:39:33.832]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.832]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.832]                           info)
[17:39:33.832]                         info <- base::paste(info, collapse = "; ")
[17:39:33.832]                         if (!has_future) {
[17:39:33.832]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.832]                             info)
[17:39:33.832]                         }
[17:39:33.832]                         else {
[17:39:33.832]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.832]                             info, version)
[17:39:33.832]                         }
[17:39:33.832]                         base::stop(msg)
[17:39:33.832]                       }
[17:39:33.832]                     })
[17:39:33.832]                   }
[17:39:33.832]                   ...future.strategy.old <- future::plan("list")
[17:39:33.832]                   options(future.plan = NULL)
[17:39:33.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.832]                 }
[17:39:33.832]                 ...future.workdir <- getwd()
[17:39:33.832]             }
[17:39:33.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.832]         }
[17:39:33.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.832]             base::names(...future.oldOptions))
[17:39:33.832]     }
[17:39:33.832]     if (FALSE) {
[17:39:33.832]     }
[17:39:33.832]     else {
[17:39:33.832]         if (TRUE) {
[17:39:33.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.832]                 open = "w")
[17:39:33.832]         }
[17:39:33.832]         else {
[17:39:33.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.832]         }
[17:39:33.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.832]             base::sink(type = "output", split = FALSE)
[17:39:33.832]             base::close(...future.stdout)
[17:39:33.832]         }, add = TRUE)
[17:39:33.832]     }
[17:39:33.832]     ...future.frame <- base::sys.nframe()
[17:39:33.832]     ...future.conditions <- base::list()
[17:39:33.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.832]     if (FALSE) {
[17:39:33.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.832]     }
[17:39:33.832]     ...future.result <- base::tryCatch({
[17:39:33.832]         base::withCallingHandlers({
[17:39:33.832]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.832]             future::FutureResult(value = ...future.value$value, 
[17:39:33.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.832]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.832]                     ...future.globalenv.names))
[17:39:33.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.832]         }, condition = base::local({
[17:39:33.832]             c <- base::c
[17:39:33.832]             inherits <- base::inherits
[17:39:33.832]             invokeRestart <- base::invokeRestart
[17:39:33.832]             length <- base::length
[17:39:33.832]             list <- base::list
[17:39:33.832]             seq.int <- base::seq.int
[17:39:33.832]             signalCondition <- base::signalCondition
[17:39:33.832]             sys.calls <- base::sys.calls
[17:39:33.832]             `[[` <- base::`[[`
[17:39:33.832]             `+` <- base::`+`
[17:39:33.832]             `<<-` <- base::`<<-`
[17:39:33.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.832]                   3L)]
[17:39:33.832]             }
[17:39:33.832]             function(cond) {
[17:39:33.832]                 is_error <- inherits(cond, "error")
[17:39:33.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.832]                   NULL)
[17:39:33.832]                 if (is_error) {
[17:39:33.832]                   sessionInformation <- function() {
[17:39:33.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.832]                       search = base::search(), system = base::Sys.info())
[17:39:33.832]                   }
[17:39:33.832]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.832]                     cond$call), session = sessionInformation(), 
[17:39:33.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.832]                   signalCondition(cond)
[17:39:33.832]                 }
[17:39:33.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.832]                 "immediateCondition"))) {
[17:39:33.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.832]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.832]                   if (TRUE && !signal) {
[17:39:33.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.832]                     {
[17:39:33.832]                       inherits <- base::inherits
[17:39:33.832]                       invokeRestart <- base::invokeRestart
[17:39:33.832]                       is.null <- base::is.null
[17:39:33.832]                       muffled <- FALSE
[17:39:33.832]                       if (inherits(cond, "message")) {
[17:39:33.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.832]                         if (muffled) 
[17:39:33.832]                           invokeRestart("muffleMessage")
[17:39:33.832]                       }
[17:39:33.832]                       else if (inherits(cond, "warning")) {
[17:39:33.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.832]                         if (muffled) 
[17:39:33.832]                           invokeRestart("muffleWarning")
[17:39:33.832]                       }
[17:39:33.832]                       else if (inherits(cond, "condition")) {
[17:39:33.832]                         if (!is.null(pattern)) {
[17:39:33.832]                           computeRestarts <- base::computeRestarts
[17:39:33.832]                           grepl <- base::grepl
[17:39:33.832]                           restarts <- computeRestarts(cond)
[17:39:33.832]                           for (restart in restarts) {
[17:39:33.832]                             name <- restart$name
[17:39:33.832]                             if (is.null(name)) 
[17:39:33.832]                               next
[17:39:33.832]                             if (!grepl(pattern, name)) 
[17:39:33.832]                               next
[17:39:33.832]                             invokeRestart(restart)
[17:39:33.832]                             muffled <- TRUE
[17:39:33.832]                             break
[17:39:33.832]                           }
[17:39:33.832]                         }
[17:39:33.832]                       }
[17:39:33.832]                       invisible(muffled)
[17:39:33.832]                     }
[17:39:33.832]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.832]                   }
[17:39:33.832]                 }
[17:39:33.832]                 else {
[17:39:33.832]                   if (TRUE) {
[17:39:33.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.832]                     {
[17:39:33.832]                       inherits <- base::inherits
[17:39:33.832]                       invokeRestart <- base::invokeRestart
[17:39:33.832]                       is.null <- base::is.null
[17:39:33.832]                       muffled <- FALSE
[17:39:33.832]                       if (inherits(cond, "message")) {
[17:39:33.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.832]                         if (muffled) 
[17:39:33.832]                           invokeRestart("muffleMessage")
[17:39:33.832]                       }
[17:39:33.832]                       else if (inherits(cond, "warning")) {
[17:39:33.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.832]                         if (muffled) 
[17:39:33.832]                           invokeRestart("muffleWarning")
[17:39:33.832]                       }
[17:39:33.832]                       else if (inherits(cond, "condition")) {
[17:39:33.832]                         if (!is.null(pattern)) {
[17:39:33.832]                           computeRestarts <- base::computeRestarts
[17:39:33.832]                           grepl <- base::grepl
[17:39:33.832]                           restarts <- computeRestarts(cond)
[17:39:33.832]                           for (restart in restarts) {
[17:39:33.832]                             name <- restart$name
[17:39:33.832]                             if (is.null(name)) 
[17:39:33.832]                               next
[17:39:33.832]                             if (!grepl(pattern, name)) 
[17:39:33.832]                               next
[17:39:33.832]                             invokeRestart(restart)
[17:39:33.832]                             muffled <- TRUE
[17:39:33.832]                             break
[17:39:33.832]                           }
[17:39:33.832]                         }
[17:39:33.832]                       }
[17:39:33.832]                       invisible(muffled)
[17:39:33.832]                     }
[17:39:33.832]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.832]                   }
[17:39:33.832]                 }
[17:39:33.832]             }
[17:39:33.832]         }))
[17:39:33.832]     }, error = function(ex) {
[17:39:33.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.832]                 ...future.rng), started = ...future.startTime, 
[17:39:33.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.832]             version = "1.8"), class = "FutureResult")
[17:39:33.832]     }, finally = {
[17:39:33.832]         if (!identical(...future.workdir, getwd())) 
[17:39:33.832]             setwd(...future.workdir)
[17:39:33.832]         {
[17:39:33.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.832]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.832]             }
[17:39:33.832]             base::options(...future.oldOptions)
[17:39:33.832]             if (.Platform$OS.type == "windows") {
[17:39:33.832]                 old_names <- names(...future.oldEnvVars)
[17:39:33.832]                 envs <- base::Sys.getenv()
[17:39:33.832]                 names <- names(envs)
[17:39:33.832]                 common <- intersect(names, old_names)
[17:39:33.832]                 added <- setdiff(names, old_names)
[17:39:33.832]                 removed <- setdiff(old_names, names)
[17:39:33.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.832]                   envs[common]]
[17:39:33.832]                 NAMES <- toupper(changed)
[17:39:33.832]                 args <- list()
[17:39:33.832]                 for (kk in seq_along(NAMES)) {
[17:39:33.832]                   name <- changed[[kk]]
[17:39:33.832]                   NAME <- NAMES[[kk]]
[17:39:33.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.832]                     next
[17:39:33.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.832]                 }
[17:39:33.832]                 NAMES <- toupper(added)
[17:39:33.832]                 for (kk in seq_along(NAMES)) {
[17:39:33.832]                   name <- added[[kk]]
[17:39:33.832]                   NAME <- NAMES[[kk]]
[17:39:33.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.832]                     next
[17:39:33.832]                   args[[name]] <- ""
[17:39:33.832]                 }
[17:39:33.832]                 NAMES <- toupper(removed)
[17:39:33.832]                 for (kk in seq_along(NAMES)) {
[17:39:33.832]                   name <- removed[[kk]]
[17:39:33.832]                   NAME <- NAMES[[kk]]
[17:39:33.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.832]                     next
[17:39:33.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.832]                 }
[17:39:33.832]                 if (length(args) > 0) 
[17:39:33.832]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.832]             }
[17:39:33.832]             else {
[17:39:33.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.832]             }
[17:39:33.832]             {
[17:39:33.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.832]                   0L) {
[17:39:33.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.832]                   base::options(opts)
[17:39:33.832]                 }
[17:39:33.832]                 {
[17:39:33.832]                   {
[17:39:33.832]                     NULL
[17:39:33.832]                     RNGkind("Mersenne-Twister")
[17:39:33.832]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.832]                       inherits = FALSE)
[17:39:33.832]                   }
[17:39:33.832]                   options(future.plan = NULL)
[17:39:33.832]                   if (is.na(NA_character_)) 
[17:39:33.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.832]                     .init = FALSE)
[17:39:33.832]                 }
[17:39:33.832]             }
[17:39:33.832]         }
[17:39:33.832]     })
[17:39:33.832]     if (TRUE) {
[17:39:33.832]         base::sink(type = "output", split = FALSE)
[17:39:33.832]         if (TRUE) {
[17:39:33.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.832]         }
[17:39:33.832]         else {
[17:39:33.832]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.832]         }
[17:39:33.832]         base::close(...future.stdout)
[17:39:33.832]         ...future.stdout <- NULL
[17:39:33.832]     }
[17:39:33.832]     ...future.result$conditions <- ...future.conditions
[17:39:33.832]     ...future.result$finished <- base::Sys.time()
[17:39:33.832]     ...future.result
[17:39:33.832] }
[17:39:33.834] plan(): Setting new future strategy stack:
[17:39:33.834] List of future strategies:
[17:39:33.834] 1. sequential:
[17:39:33.834]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.834]    - tweaked: FALSE
[17:39:33.834]    - call: NULL
[17:39:33.834] plan(): nbrOfWorkers() = 1
[17:39:33.835] plan(): Setting new future strategy stack:
[17:39:33.835] List of future strategies:
[17:39:33.835] 1. sequential:
[17:39:33.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.835]    - tweaked: FALSE
[17:39:33.835]    - call: plan(strategy)
[17:39:33.835] plan(): nbrOfWorkers() = 1
[17:39:33.836] SequentialFuture started (and completed)
[17:39:33.836] - Launch lazy future ... done
[17:39:33.836] run() for ‘SequentialFuture’ ... done
[17:39:33.836] getGlobalsAndPackages() ...
[17:39:33.837] Searching for globals...
[17:39:33.837] - globals found: [1] ‘{’
[17:39:33.837] Searching for globals ... DONE
[17:39:33.837] Resolving globals: FALSE
[17:39:33.838] 
[17:39:33.838] 
[17:39:33.838] getGlobalsAndPackages() ... DONE
[17:39:33.838] run() for ‘Future’ ...
[17:39:33.838] - state: ‘created’
[17:39:33.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.839]   - Field: ‘label’
[17:39:33.839]   - Field: ‘local’
[17:39:33.839]   - Field: ‘owner’
[17:39:33.839]   - Field: ‘envir’
[17:39:33.839]   - Field: ‘packages’
[17:39:33.839]   - Field: ‘gc’
[17:39:33.839]   - Field: ‘conditions’
[17:39:33.839]   - Field: ‘expr’
[17:39:33.839]   - Field: ‘uuid’
[17:39:33.840]   - Field: ‘seed’
[17:39:33.840]   - Field: ‘version’
[17:39:33.840]   - Field: ‘result’
[17:39:33.840]   - Field: ‘asynchronous’
[17:39:33.840]   - Field: ‘calls’
[17:39:33.840]   - Field: ‘globals’
[17:39:33.840]   - Field: ‘stdout’
[17:39:33.840]   - Field: ‘earlySignal’
[17:39:33.840]   - Field: ‘lazy’
[17:39:33.840]   - Field: ‘state’
[17:39:33.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.841] - Launch lazy future ...
[17:39:33.841] Packages needed by the future expression (n = 0): <none>
[17:39:33.841] Packages needed by future strategies (n = 0): <none>
[17:39:33.841] {
[17:39:33.841]     {
[17:39:33.841]         {
[17:39:33.841]             ...future.startTime <- base::Sys.time()
[17:39:33.841]             {
[17:39:33.841]                 {
[17:39:33.841]                   {
[17:39:33.841]                     base::local({
[17:39:33.841]                       has_future <- base::requireNamespace("future", 
[17:39:33.841]                         quietly = TRUE)
[17:39:33.841]                       if (has_future) {
[17:39:33.841]                         ns <- base::getNamespace("future")
[17:39:33.841]                         version <- ns[[".package"]][["version"]]
[17:39:33.841]                         if (is.null(version)) 
[17:39:33.841]                           version <- utils::packageVersion("future")
[17:39:33.841]                       }
[17:39:33.841]                       else {
[17:39:33.841]                         version <- NULL
[17:39:33.841]                       }
[17:39:33.841]                       if (!has_future || version < "1.8.0") {
[17:39:33.841]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.841]                           "", base::R.version$version.string), 
[17:39:33.841]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.841]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.841]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.841]                             "release", "version")], collapse = " "), 
[17:39:33.841]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.841]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.841]                           info)
[17:39:33.841]                         info <- base::paste(info, collapse = "; ")
[17:39:33.841]                         if (!has_future) {
[17:39:33.841]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.841]                             info)
[17:39:33.841]                         }
[17:39:33.841]                         else {
[17:39:33.841]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.841]                             info, version)
[17:39:33.841]                         }
[17:39:33.841]                         base::stop(msg)
[17:39:33.841]                       }
[17:39:33.841]                     })
[17:39:33.841]                   }
[17:39:33.841]                   ...future.strategy.old <- future::plan("list")
[17:39:33.841]                   options(future.plan = NULL)
[17:39:33.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.841]                 }
[17:39:33.841]                 ...future.workdir <- getwd()
[17:39:33.841]             }
[17:39:33.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.841]         }
[17:39:33.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.841]             base::names(...future.oldOptions))
[17:39:33.841]     }
[17:39:33.841]     if (FALSE) {
[17:39:33.841]     }
[17:39:33.841]     else {
[17:39:33.841]         if (TRUE) {
[17:39:33.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.841]                 open = "w")
[17:39:33.841]         }
[17:39:33.841]         else {
[17:39:33.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.841]         }
[17:39:33.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.841]             base::sink(type = "output", split = FALSE)
[17:39:33.841]             base::close(...future.stdout)
[17:39:33.841]         }, add = TRUE)
[17:39:33.841]     }
[17:39:33.841]     ...future.frame <- base::sys.nframe()
[17:39:33.841]     ...future.conditions <- base::list()
[17:39:33.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.841]     if (FALSE) {
[17:39:33.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.841]     }
[17:39:33.841]     ...future.result <- base::tryCatch({
[17:39:33.841]         base::withCallingHandlers({
[17:39:33.841]             ...future.value <- base::withVisible(base::local({
[17:39:33.841]                 4
[17:39:33.841]             }))
[17:39:33.841]             future::FutureResult(value = ...future.value$value, 
[17:39:33.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.841]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.841]                     ...future.globalenv.names))
[17:39:33.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.841]         }, condition = base::local({
[17:39:33.841]             c <- base::c
[17:39:33.841]             inherits <- base::inherits
[17:39:33.841]             invokeRestart <- base::invokeRestart
[17:39:33.841]             length <- base::length
[17:39:33.841]             list <- base::list
[17:39:33.841]             seq.int <- base::seq.int
[17:39:33.841]             signalCondition <- base::signalCondition
[17:39:33.841]             sys.calls <- base::sys.calls
[17:39:33.841]             `[[` <- base::`[[`
[17:39:33.841]             `+` <- base::`+`
[17:39:33.841]             `<<-` <- base::`<<-`
[17:39:33.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.841]                   3L)]
[17:39:33.841]             }
[17:39:33.841]             function(cond) {
[17:39:33.841]                 is_error <- inherits(cond, "error")
[17:39:33.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.841]                   NULL)
[17:39:33.841]                 if (is_error) {
[17:39:33.841]                   sessionInformation <- function() {
[17:39:33.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.841]                       search = base::search(), system = base::Sys.info())
[17:39:33.841]                   }
[17:39:33.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.841]                     cond$call), session = sessionInformation(), 
[17:39:33.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.841]                   signalCondition(cond)
[17:39:33.841]                 }
[17:39:33.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.841]                 "immediateCondition"))) {
[17:39:33.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.841]                   if (TRUE && !signal) {
[17:39:33.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.841]                     {
[17:39:33.841]                       inherits <- base::inherits
[17:39:33.841]                       invokeRestart <- base::invokeRestart
[17:39:33.841]                       is.null <- base::is.null
[17:39:33.841]                       muffled <- FALSE
[17:39:33.841]                       if (inherits(cond, "message")) {
[17:39:33.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.841]                         if (muffled) 
[17:39:33.841]                           invokeRestart("muffleMessage")
[17:39:33.841]                       }
[17:39:33.841]                       else if (inherits(cond, "warning")) {
[17:39:33.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.841]                         if (muffled) 
[17:39:33.841]                           invokeRestart("muffleWarning")
[17:39:33.841]                       }
[17:39:33.841]                       else if (inherits(cond, "condition")) {
[17:39:33.841]                         if (!is.null(pattern)) {
[17:39:33.841]                           computeRestarts <- base::computeRestarts
[17:39:33.841]                           grepl <- base::grepl
[17:39:33.841]                           restarts <- computeRestarts(cond)
[17:39:33.841]                           for (restart in restarts) {
[17:39:33.841]                             name <- restart$name
[17:39:33.841]                             if (is.null(name)) 
[17:39:33.841]                               next
[17:39:33.841]                             if (!grepl(pattern, name)) 
[17:39:33.841]                               next
[17:39:33.841]                             invokeRestart(restart)
[17:39:33.841]                             muffled <- TRUE
[17:39:33.841]                             break
[17:39:33.841]                           }
[17:39:33.841]                         }
[17:39:33.841]                       }
[17:39:33.841]                       invisible(muffled)
[17:39:33.841]                     }
[17:39:33.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.841]                   }
[17:39:33.841]                 }
[17:39:33.841]                 else {
[17:39:33.841]                   if (TRUE) {
[17:39:33.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.841]                     {
[17:39:33.841]                       inherits <- base::inherits
[17:39:33.841]                       invokeRestart <- base::invokeRestart
[17:39:33.841]                       is.null <- base::is.null
[17:39:33.841]                       muffled <- FALSE
[17:39:33.841]                       if (inherits(cond, "message")) {
[17:39:33.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.841]                         if (muffled) 
[17:39:33.841]                           invokeRestart("muffleMessage")
[17:39:33.841]                       }
[17:39:33.841]                       else if (inherits(cond, "warning")) {
[17:39:33.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.841]                         if (muffled) 
[17:39:33.841]                           invokeRestart("muffleWarning")
[17:39:33.841]                       }
[17:39:33.841]                       else if (inherits(cond, "condition")) {
[17:39:33.841]                         if (!is.null(pattern)) {
[17:39:33.841]                           computeRestarts <- base::computeRestarts
[17:39:33.841]                           grepl <- base::grepl
[17:39:33.841]                           restarts <- computeRestarts(cond)
[17:39:33.841]                           for (restart in restarts) {
[17:39:33.841]                             name <- restart$name
[17:39:33.841]                             if (is.null(name)) 
[17:39:33.841]                               next
[17:39:33.841]                             if (!grepl(pattern, name)) 
[17:39:33.841]                               next
[17:39:33.841]                             invokeRestart(restart)
[17:39:33.841]                             muffled <- TRUE
[17:39:33.841]                             break
[17:39:33.841]                           }
[17:39:33.841]                         }
[17:39:33.841]                       }
[17:39:33.841]                       invisible(muffled)
[17:39:33.841]                     }
[17:39:33.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.841]                   }
[17:39:33.841]                 }
[17:39:33.841]             }
[17:39:33.841]         }))
[17:39:33.841]     }, error = function(ex) {
[17:39:33.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.841]                 ...future.rng), started = ...future.startTime, 
[17:39:33.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.841]             version = "1.8"), class = "FutureResult")
[17:39:33.841]     }, finally = {
[17:39:33.841]         if (!identical(...future.workdir, getwd())) 
[17:39:33.841]             setwd(...future.workdir)
[17:39:33.841]         {
[17:39:33.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.841]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.841]             }
[17:39:33.841]             base::options(...future.oldOptions)
[17:39:33.841]             if (.Platform$OS.type == "windows") {
[17:39:33.841]                 old_names <- names(...future.oldEnvVars)
[17:39:33.841]                 envs <- base::Sys.getenv()
[17:39:33.841]                 names <- names(envs)
[17:39:33.841]                 common <- intersect(names, old_names)
[17:39:33.841]                 added <- setdiff(names, old_names)
[17:39:33.841]                 removed <- setdiff(old_names, names)
[17:39:33.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.841]                   envs[common]]
[17:39:33.841]                 NAMES <- toupper(changed)
[17:39:33.841]                 args <- list()
[17:39:33.841]                 for (kk in seq_along(NAMES)) {
[17:39:33.841]                   name <- changed[[kk]]
[17:39:33.841]                   NAME <- NAMES[[kk]]
[17:39:33.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.841]                     next
[17:39:33.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.841]                 }
[17:39:33.841]                 NAMES <- toupper(added)
[17:39:33.841]                 for (kk in seq_along(NAMES)) {
[17:39:33.841]                   name <- added[[kk]]
[17:39:33.841]                   NAME <- NAMES[[kk]]
[17:39:33.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.841]                     next
[17:39:33.841]                   args[[name]] <- ""
[17:39:33.841]                 }
[17:39:33.841]                 NAMES <- toupper(removed)
[17:39:33.841]                 for (kk in seq_along(NAMES)) {
[17:39:33.841]                   name <- removed[[kk]]
[17:39:33.841]                   NAME <- NAMES[[kk]]
[17:39:33.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.841]                     next
[17:39:33.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.841]                 }
[17:39:33.841]                 if (length(args) > 0) 
[17:39:33.841]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.841]             }
[17:39:33.841]             else {
[17:39:33.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.841]             }
[17:39:33.841]             {
[17:39:33.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.841]                   0L) {
[17:39:33.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.841]                   base::options(opts)
[17:39:33.841]                 }
[17:39:33.841]                 {
[17:39:33.841]                   {
[17:39:33.841]                     NULL
[17:39:33.841]                     RNGkind("Mersenne-Twister")
[17:39:33.841]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.841]                       inherits = FALSE)
[17:39:33.841]                   }
[17:39:33.841]                   options(future.plan = NULL)
[17:39:33.841]                   if (is.na(NA_character_)) 
[17:39:33.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.841]                     .init = FALSE)
[17:39:33.841]                 }
[17:39:33.841]             }
[17:39:33.841]         }
[17:39:33.841]     })
[17:39:33.841]     if (TRUE) {
[17:39:33.841]         base::sink(type = "output", split = FALSE)
[17:39:33.841]         if (TRUE) {
[17:39:33.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.841]         }
[17:39:33.841]         else {
[17:39:33.841]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.841]         }
[17:39:33.841]         base::close(...future.stdout)
[17:39:33.841]         ...future.stdout <- NULL
[17:39:33.841]     }
[17:39:33.841]     ...future.result$conditions <- ...future.conditions
[17:39:33.841]     ...future.result$finished <- base::Sys.time()
[17:39:33.841]     ...future.result
[17:39:33.841] }
[17:39:33.843] plan(): Setting new future strategy stack:
[17:39:33.843] List of future strategies:
[17:39:33.843] 1. sequential:
[17:39:33.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.843]    - tweaked: FALSE
[17:39:33.843]    - call: NULL
[17:39:33.844] plan(): nbrOfWorkers() = 1
[17:39:33.844] plan(): Setting new future strategy stack:
[17:39:33.844] List of future strategies:
[17:39:33.844] 1. sequential:
[17:39:33.844]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.844]    - tweaked: FALSE
[17:39:33.844]    - call: plan(strategy)
[17:39:33.845] plan(): nbrOfWorkers() = 1
[17:39:33.845] SequentialFuture started (and completed)
[17:39:33.845] - Launch lazy future ... done
[17:39:33.845] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf01468c8> 
Classes 'listenv', 'environment' <environment: 0x55adeff9a478> 
[17:39:33.848] resolved() for ‘SequentialFuture’ ...
[17:39:33.848] - state: ‘finished’
[17:39:33.849] - run: TRUE
[17:39:33.849] - result: ‘FutureResult’
[17:39:33.849] resolved() for ‘SequentialFuture’ ... done
[17:39:33.849] resolved() for ‘SequentialFuture’ ...
[17:39:33.849] - state: ‘finished’
[17:39:33.849] - run: TRUE
[17:39:33.849] - result: ‘FutureResult’
[17:39:33.849] resolved() for ‘SequentialFuture’ ... done
[17:39:33.849] resolved() for ‘SequentialFuture’ ...
[17:39:33.849] - state: ‘finished’
[17:39:33.849] - run: TRUE
[17:39:33.850] - result: ‘FutureResult’
[17:39:33.850] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:33.851] resolve() on list environment ...
[17:39:33.851]  recursive: 0
[17:39:33.852]  length: 6
[17:39:33.852]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:33.853] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.853] - nx: 6
[17:39:33.853] - relay: TRUE
[17:39:33.853] - stdout: TRUE
[17:39:33.853] - signal: TRUE
[17:39:33.853] - resignal: FALSE
[17:39:33.853] - force: TRUE
[17:39:33.853] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.853] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.853]  - until=2
[17:39:33.853]  - relaying element #2
[17:39:33.854] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.854] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.854] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.854]  length: 5 (resolved future 1)
[17:39:33.854] resolved() for ‘SequentialFuture’ ...
[17:39:33.854] - state: ‘finished’
[17:39:33.854] - run: TRUE
[17:39:33.854] - result: ‘FutureResult’
[17:39:33.854] resolved() for ‘SequentialFuture’ ... done
[17:39:33.854] Future #2
[17:39:33.855] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.855] - nx: 6
[17:39:33.855] - relay: TRUE
[17:39:33.855] - stdout: TRUE
[17:39:33.855] - signal: TRUE
[17:39:33.855] - resignal: FALSE
[17:39:33.855] - force: TRUE
[17:39:33.855] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.855] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.855]  - until=2
[17:39:33.855]  - relaying element #2
[17:39:33.856] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.856] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.856] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.856]  length: 4 (resolved future 2)
[17:39:33.856] resolved() for ‘SequentialFuture’ ...
[17:39:33.856] - state: ‘finished’
[17:39:33.856] - run: TRUE
[17:39:33.856] - result: ‘FutureResult’
[17:39:33.856] resolved() for ‘SequentialFuture’ ... done
[17:39:33.859] Future #3
[17:39:33.859] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.859] - nx: 6
[17:39:33.859] - relay: TRUE
[17:39:33.859] - stdout: TRUE
[17:39:33.859] - signal: TRUE
[17:39:33.859] - resignal: FALSE
[17:39:33.859] - force: TRUE
[17:39:33.859] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.860] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.860]  - until=3
[17:39:33.860]  - relaying element #3
[17:39:33.860] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.860] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.860] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.860]  length: 3 (resolved future 3)
[17:39:33.860] resolved() for ‘SequentialFuture’ ...
[17:39:33.860] - state: ‘finished’
[17:39:33.861] - run: TRUE
[17:39:33.861] - result: ‘FutureResult’
[17:39:33.861] resolved() for ‘SequentialFuture’ ... done
[17:39:33.861] Future #4
[17:39:33.861] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.861] - nx: 6
[17:39:33.861] - relay: TRUE
[17:39:33.861] - stdout: TRUE
[17:39:33.861] - signal: TRUE
[17:39:33.861] - resignal: FALSE
[17:39:33.861] - force: TRUE
[17:39:33.862] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.862] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.862]  - until=4
[17:39:33.862]  - relaying element #4
[17:39:33.862] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.862] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.862] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.862]  length: 2 (resolved future 4)
[17:39:33.862] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.862] - nx: 6
[17:39:33.863] - relay: TRUE
[17:39:33.863] - stdout: TRUE
[17:39:33.863] - signal: TRUE
[17:39:33.863] - resignal: FALSE
[17:39:33.863] - force: TRUE
[17:39:33.863] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.863] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.863]  - until=6
[17:39:33.863]  - relaying element #6
[17:39:33.863] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.863] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.863] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.864]  length: 1 (resolved future 5)
[17:39:33.864] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.864] - nx: 6
[17:39:33.864] - relay: TRUE
[17:39:33.864] - stdout: TRUE
[17:39:33.864] - signal: TRUE
[17:39:33.864] - resignal: FALSE
[17:39:33.864] - force: TRUE
[17:39:33.864] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.864] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.864]  - until=6
[17:39:33.865] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.865] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.865] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.865]  length: 0 (resolved future 6)
[17:39:33.865] Relaying remaining futures
[17:39:33.865] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.865] - nx: 6
[17:39:33.865] - relay: TRUE
[17:39:33.865] - stdout: TRUE
[17:39:33.865] - signal: TRUE
[17:39:33.865] - resignal: FALSE
[17:39:33.865] - force: TRUE
[17:39:33.866] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.866] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:33.866] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.866] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.866] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.866] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55adf027b800> 
Dimensions: c(1, 6)
[17:39:33.867] getGlobalsAndPackages() ...
[17:39:33.867] Searching for globals...
[17:39:33.867] 
[17:39:33.867] Searching for globals ... DONE
[17:39:33.867] - globals: [0] <none>
[17:39:33.867] getGlobalsAndPackages() ... DONE
[17:39:33.868] run() for ‘Future’ ...
[17:39:33.868] - state: ‘created’
[17:39:33.868] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.868] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.868]   - Field: ‘label’
[17:39:33.869]   - Field: ‘local’
[17:39:33.869]   - Field: ‘owner’
[17:39:33.869]   - Field: ‘envir’
[17:39:33.869]   - Field: ‘packages’
[17:39:33.869]   - Field: ‘gc’
[17:39:33.869]   - Field: ‘conditions’
[17:39:33.869]   - Field: ‘expr’
[17:39:33.869]   - Field: ‘uuid’
[17:39:33.869]   - Field: ‘seed’
[17:39:33.869]   - Field: ‘version’
[17:39:33.869]   - Field: ‘result’
[17:39:33.870]   - Field: ‘asynchronous’
[17:39:33.870]   - Field: ‘calls’
[17:39:33.870]   - Field: ‘globals’
[17:39:33.870]   - Field: ‘stdout’
[17:39:33.870]   - Field: ‘earlySignal’
[17:39:33.870]   - Field: ‘lazy’
[17:39:33.870]   - Field: ‘state’
[17:39:33.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.870] - Launch lazy future ...
[17:39:33.870] Packages needed by the future expression (n = 0): <none>
[17:39:33.871] Packages needed by future strategies (n = 0): <none>
[17:39:33.871] {
[17:39:33.871]     {
[17:39:33.871]         {
[17:39:33.871]             ...future.startTime <- base::Sys.time()
[17:39:33.871]             {
[17:39:33.871]                 {
[17:39:33.871]                   {
[17:39:33.871]                     base::local({
[17:39:33.871]                       has_future <- base::requireNamespace("future", 
[17:39:33.871]                         quietly = TRUE)
[17:39:33.871]                       if (has_future) {
[17:39:33.871]                         ns <- base::getNamespace("future")
[17:39:33.871]                         version <- ns[[".package"]][["version"]]
[17:39:33.871]                         if (is.null(version)) 
[17:39:33.871]                           version <- utils::packageVersion("future")
[17:39:33.871]                       }
[17:39:33.871]                       else {
[17:39:33.871]                         version <- NULL
[17:39:33.871]                       }
[17:39:33.871]                       if (!has_future || version < "1.8.0") {
[17:39:33.871]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.871]                           "", base::R.version$version.string), 
[17:39:33.871]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.871]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.871]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.871]                             "release", "version")], collapse = " "), 
[17:39:33.871]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.871]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.871]                           info)
[17:39:33.871]                         info <- base::paste(info, collapse = "; ")
[17:39:33.871]                         if (!has_future) {
[17:39:33.871]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.871]                             info)
[17:39:33.871]                         }
[17:39:33.871]                         else {
[17:39:33.871]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.871]                             info, version)
[17:39:33.871]                         }
[17:39:33.871]                         base::stop(msg)
[17:39:33.871]                       }
[17:39:33.871]                     })
[17:39:33.871]                   }
[17:39:33.871]                   ...future.strategy.old <- future::plan("list")
[17:39:33.871]                   options(future.plan = NULL)
[17:39:33.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.871]                 }
[17:39:33.871]                 ...future.workdir <- getwd()
[17:39:33.871]             }
[17:39:33.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.871]         }
[17:39:33.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.871]             base::names(...future.oldOptions))
[17:39:33.871]     }
[17:39:33.871]     if (FALSE) {
[17:39:33.871]     }
[17:39:33.871]     else {
[17:39:33.871]         if (TRUE) {
[17:39:33.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.871]                 open = "w")
[17:39:33.871]         }
[17:39:33.871]         else {
[17:39:33.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.871]         }
[17:39:33.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.871]             base::sink(type = "output", split = FALSE)
[17:39:33.871]             base::close(...future.stdout)
[17:39:33.871]         }, add = TRUE)
[17:39:33.871]     }
[17:39:33.871]     ...future.frame <- base::sys.nframe()
[17:39:33.871]     ...future.conditions <- base::list()
[17:39:33.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.871]     if (FALSE) {
[17:39:33.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.871]     }
[17:39:33.871]     ...future.result <- base::tryCatch({
[17:39:33.871]         base::withCallingHandlers({
[17:39:33.871]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.871]             future::FutureResult(value = ...future.value$value, 
[17:39:33.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.871]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.871]                     ...future.globalenv.names))
[17:39:33.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.871]         }, condition = base::local({
[17:39:33.871]             c <- base::c
[17:39:33.871]             inherits <- base::inherits
[17:39:33.871]             invokeRestart <- base::invokeRestart
[17:39:33.871]             length <- base::length
[17:39:33.871]             list <- base::list
[17:39:33.871]             seq.int <- base::seq.int
[17:39:33.871]             signalCondition <- base::signalCondition
[17:39:33.871]             sys.calls <- base::sys.calls
[17:39:33.871]             `[[` <- base::`[[`
[17:39:33.871]             `+` <- base::`+`
[17:39:33.871]             `<<-` <- base::`<<-`
[17:39:33.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.871]                   3L)]
[17:39:33.871]             }
[17:39:33.871]             function(cond) {
[17:39:33.871]                 is_error <- inherits(cond, "error")
[17:39:33.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.871]                   NULL)
[17:39:33.871]                 if (is_error) {
[17:39:33.871]                   sessionInformation <- function() {
[17:39:33.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.871]                       search = base::search(), system = base::Sys.info())
[17:39:33.871]                   }
[17:39:33.871]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.871]                     cond$call), session = sessionInformation(), 
[17:39:33.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.871]                   signalCondition(cond)
[17:39:33.871]                 }
[17:39:33.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.871]                 "immediateCondition"))) {
[17:39:33.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.871]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.871]                   if (TRUE && !signal) {
[17:39:33.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.871]                     {
[17:39:33.871]                       inherits <- base::inherits
[17:39:33.871]                       invokeRestart <- base::invokeRestart
[17:39:33.871]                       is.null <- base::is.null
[17:39:33.871]                       muffled <- FALSE
[17:39:33.871]                       if (inherits(cond, "message")) {
[17:39:33.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.871]                         if (muffled) 
[17:39:33.871]                           invokeRestart("muffleMessage")
[17:39:33.871]                       }
[17:39:33.871]                       else if (inherits(cond, "warning")) {
[17:39:33.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.871]                         if (muffled) 
[17:39:33.871]                           invokeRestart("muffleWarning")
[17:39:33.871]                       }
[17:39:33.871]                       else if (inherits(cond, "condition")) {
[17:39:33.871]                         if (!is.null(pattern)) {
[17:39:33.871]                           computeRestarts <- base::computeRestarts
[17:39:33.871]                           grepl <- base::grepl
[17:39:33.871]                           restarts <- computeRestarts(cond)
[17:39:33.871]                           for (restart in restarts) {
[17:39:33.871]                             name <- restart$name
[17:39:33.871]                             if (is.null(name)) 
[17:39:33.871]                               next
[17:39:33.871]                             if (!grepl(pattern, name)) 
[17:39:33.871]                               next
[17:39:33.871]                             invokeRestart(restart)
[17:39:33.871]                             muffled <- TRUE
[17:39:33.871]                             break
[17:39:33.871]                           }
[17:39:33.871]                         }
[17:39:33.871]                       }
[17:39:33.871]                       invisible(muffled)
[17:39:33.871]                     }
[17:39:33.871]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.871]                   }
[17:39:33.871]                 }
[17:39:33.871]                 else {
[17:39:33.871]                   if (TRUE) {
[17:39:33.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.871]                     {
[17:39:33.871]                       inherits <- base::inherits
[17:39:33.871]                       invokeRestart <- base::invokeRestart
[17:39:33.871]                       is.null <- base::is.null
[17:39:33.871]                       muffled <- FALSE
[17:39:33.871]                       if (inherits(cond, "message")) {
[17:39:33.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.871]                         if (muffled) 
[17:39:33.871]                           invokeRestart("muffleMessage")
[17:39:33.871]                       }
[17:39:33.871]                       else if (inherits(cond, "warning")) {
[17:39:33.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.871]                         if (muffled) 
[17:39:33.871]                           invokeRestart("muffleWarning")
[17:39:33.871]                       }
[17:39:33.871]                       else if (inherits(cond, "condition")) {
[17:39:33.871]                         if (!is.null(pattern)) {
[17:39:33.871]                           computeRestarts <- base::computeRestarts
[17:39:33.871]                           grepl <- base::grepl
[17:39:33.871]                           restarts <- computeRestarts(cond)
[17:39:33.871]                           for (restart in restarts) {
[17:39:33.871]                             name <- restart$name
[17:39:33.871]                             if (is.null(name)) 
[17:39:33.871]                               next
[17:39:33.871]                             if (!grepl(pattern, name)) 
[17:39:33.871]                               next
[17:39:33.871]                             invokeRestart(restart)
[17:39:33.871]                             muffled <- TRUE
[17:39:33.871]                             break
[17:39:33.871]                           }
[17:39:33.871]                         }
[17:39:33.871]                       }
[17:39:33.871]                       invisible(muffled)
[17:39:33.871]                     }
[17:39:33.871]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.871]                   }
[17:39:33.871]                 }
[17:39:33.871]             }
[17:39:33.871]         }))
[17:39:33.871]     }, error = function(ex) {
[17:39:33.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.871]                 ...future.rng), started = ...future.startTime, 
[17:39:33.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.871]             version = "1.8"), class = "FutureResult")
[17:39:33.871]     }, finally = {
[17:39:33.871]         if (!identical(...future.workdir, getwd())) 
[17:39:33.871]             setwd(...future.workdir)
[17:39:33.871]         {
[17:39:33.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.871]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.871]             }
[17:39:33.871]             base::options(...future.oldOptions)
[17:39:33.871]             if (.Platform$OS.type == "windows") {
[17:39:33.871]                 old_names <- names(...future.oldEnvVars)
[17:39:33.871]                 envs <- base::Sys.getenv()
[17:39:33.871]                 names <- names(envs)
[17:39:33.871]                 common <- intersect(names, old_names)
[17:39:33.871]                 added <- setdiff(names, old_names)
[17:39:33.871]                 removed <- setdiff(old_names, names)
[17:39:33.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.871]                   envs[common]]
[17:39:33.871]                 NAMES <- toupper(changed)
[17:39:33.871]                 args <- list()
[17:39:33.871]                 for (kk in seq_along(NAMES)) {
[17:39:33.871]                   name <- changed[[kk]]
[17:39:33.871]                   NAME <- NAMES[[kk]]
[17:39:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.871]                     next
[17:39:33.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.871]                 }
[17:39:33.871]                 NAMES <- toupper(added)
[17:39:33.871]                 for (kk in seq_along(NAMES)) {
[17:39:33.871]                   name <- added[[kk]]
[17:39:33.871]                   NAME <- NAMES[[kk]]
[17:39:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.871]                     next
[17:39:33.871]                   args[[name]] <- ""
[17:39:33.871]                 }
[17:39:33.871]                 NAMES <- toupper(removed)
[17:39:33.871]                 for (kk in seq_along(NAMES)) {
[17:39:33.871]                   name <- removed[[kk]]
[17:39:33.871]                   NAME <- NAMES[[kk]]
[17:39:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.871]                     next
[17:39:33.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.871]                 }
[17:39:33.871]                 if (length(args) > 0) 
[17:39:33.871]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.871]             }
[17:39:33.871]             else {
[17:39:33.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.871]             }
[17:39:33.871]             {
[17:39:33.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.871]                   0L) {
[17:39:33.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.871]                   base::options(opts)
[17:39:33.871]                 }
[17:39:33.871]                 {
[17:39:33.871]                   {
[17:39:33.871]                     NULL
[17:39:33.871]                     RNGkind("Mersenne-Twister")
[17:39:33.871]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.871]                       inherits = FALSE)
[17:39:33.871]                   }
[17:39:33.871]                   options(future.plan = NULL)
[17:39:33.871]                   if (is.na(NA_character_)) 
[17:39:33.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.871]                     .init = FALSE)
[17:39:33.871]                 }
[17:39:33.871]             }
[17:39:33.871]         }
[17:39:33.871]     })
[17:39:33.871]     if (TRUE) {
[17:39:33.871]         base::sink(type = "output", split = FALSE)
[17:39:33.871]         if (TRUE) {
[17:39:33.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.871]         }
[17:39:33.871]         else {
[17:39:33.871]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.871]         }
[17:39:33.871]         base::close(...future.stdout)
[17:39:33.871]         ...future.stdout <- NULL
[17:39:33.871]     }
[17:39:33.871]     ...future.result$conditions <- ...future.conditions
[17:39:33.871]     ...future.result$finished <- base::Sys.time()
[17:39:33.871]     ...future.result
[17:39:33.871] }
[17:39:33.873] plan(): Setting new future strategy stack:
[17:39:33.873] List of future strategies:
[17:39:33.873] 1. sequential:
[17:39:33.873]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.873]    - tweaked: FALSE
[17:39:33.873]    - call: NULL
[17:39:33.873] plan(): nbrOfWorkers() = 1
[17:39:33.874] plan(): Setting new future strategy stack:
[17:39:33.874] List of future strategies:
[17:39:33.874] 1. sequential:
[17:39:33.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.874]    - tweaked: FALSE
[17:39:33.874]    - call: plan(strategy)
[17:39:33.875] plan(): nbrOfWorkers() = 1
[17:39:33.875] SequentialFuture started (and completed)
[17:39:33.875] - Launch lazy future ... done
[17:39:33.875] run() for ‘SequentialFuture’ ... done
[17:39:33.875] getGlobalsAndPackages() ...
[17:39:33.875] Searching for globals...
[17:39:33.875] 
[17:39:33.876] Searching for globals ... DONE
[17:39:33.876] - globals: [0] <none>
[17:39:33.876] getGlobalsAndPackages() ... DONE
[17:39:33.876] run() for ‘Future’ ...
[17:39:33.876] - state: ‘created’
[17:39:33.876] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.877]   - Field: ‘label’
[17:39:33.877]   - Field: ‘local’
[17:39:33.877]   - Field: ‘owner’
[17:39:33.877]   - Field: ‘envir’
[17:39:33.877]   - Field: ‘packages’
[17:39:33.877]   - Field: ‘gc’
[17:39:33.877]   - Field: ‘conditions’
[17:39:33.877]   - Field: ‘expr’
[17:39:33.877]   - Field: ‘uuid’
[17:39:33.877]   - Field: ‘seed’
[17:39:33.878]   - Field: ‘version’
[17:39:33.878]   - Field: ‘result’
[17:39:33.878]   - Field: ‘asynchronous’
[17:39:33.878]   - Field: ‘calls’
[17:39:33.878]   - Field: ‘globals’
[17:39:33.878]   - Field: ‘stdout’
[17:39:33.878]   - Field: ‘earlySignal’
[17:39:33.878]   - Field: ‘lazy’
[17:39:33.878]   - Field: ‘state’
[17:39:33.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.878] - Launch lazy future ...
[17:39:33.879] Packages needed by the future expression (n = 0): <none>
[17:39:33.879] Packages needed by future strategies (n = 0): <none>
[17:39:33.879] {
[17:39:33.879]     {
[17:39:33.879]         {
[17:39:33.879]             ...future.startTime <- base::Sys.time()
[17:39:33.879]             {
[17:39:33.879]                 {
[17:39:33.879]                   {
[17:39:33.879]                     base::local({
[17:39:33.879]                       has_future <- base::requireNamespace("future", 
[17:39:33.879]                         quietly = TRUE)
[17:39:33.879]                       if (has_future) {
[17:39:33.879]                         ns <- base::getNamespace("future")
[17:39:33.879]                         version <- ns[[".package"]][["version"]]
[17:39:33.879]                         if (is.null(version)) 
[17:39:33.879]                           version <- utils::packageVersion("future")
[17:39:33.879]                       }
[17:39:33.879]                       else {
[17:39:33.879]                         version <- NULL
[17:39:33.879]                       }
[17:39:33.879]                       if (!has_future || version < "1.8.0") {
[17:39:33.879]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.879]                           "", base::R.version$version.string), 
[17:39:33.879]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.879]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.879]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.879]                             "release", "version")], collapse = " "), 
[17:39:33.879]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.879]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.879]                           info)
[17:39:33.879]                         info <- base::paste(info, collapse = "; ")
[17:39:33.879]                         if (!has_future) {
[17:39:33.879]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.879]                             info)
[17:39:33.879]                         }
[17:39:33.879]                         else {
[17:39:33.879]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.879]                             info, version)
[17:39:33.879]                         }
[17:39:33.879]                         base::stop(msg)
[17:39:33.879]                       }
[17:39:33.879]                     })
[17:39:33.879]                   }
[17:39:33.879]                   ...future.strategy.old <- future::plan("list")
[17:39:33.879]                   options(future.plan = NULL)
[17:39:33.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.879]                 }
[17:39:33.879]                 ...future.workdir <- getwd()
[17:39:33.879]             }
[17:39:33.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.879]         }
[17:39:33.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.879]             base::names(...future.oldOptions))
[17:39:33.879]     }
[17:39:33.879]     if (FALSE) {
[17:39:33.879]     }
[17:39:33.879]     else {
[17:39:33.879]         if (TRUE) {
[17:39:33.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.879]                 open = "w")
[17:39:33.879]         }
[17:39:33.879]         else {
[17:39:33.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.879]         }
[17:39:33.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.879]             base::sink(type = "output", split = FALSE)
[17:39:33.879]             base::close(...future.stdout)
[17:39:33.879]         }, add = TRUE)
[17:39:33.879]     }
[17:39:33.879]     ...future.frame <- base::sys.nframe()
[17:39:33.879]     ...future.conditions <- base::list()
[17:39:33.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.879]     if (FALSE) {
[17:39:33.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.879]     }
[17:39:33.879]     ...future.result <- base::tryCatch({
[17:39:33.879]         base::withCallingHandlers({
[17:39:33.879]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.879]             future::FutureResult(value = ...future.value$value, 
[17:39:33.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.879]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.879]                     ...future.globalenv.names))
[17:39:33.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.879]         }, condition = base::local({
[17:39:33.879]             c <- base::c
[17:39:33.879]             inherits <- base::inherits
[17:39:33.879]             invokeRestart <- base::invokeRestart
[17:39:33.879]             length <- base::length
[17:39:33.879]             list <- base::list
[17:39:33.879]             seq.int <- base::seq.int
[17:39:33.879]             signalCondition <- base::signalCondition
[17:39:33.879]             sys.calls <- base::sys.calls
[17:39:33.879]             `[[` <- base::`[[`
[17:39:33.879]             `+` <- base::`+`
[17:39:33.879]             `<<-` <- base::`<<-`
[17:39:33.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.879]                   3L)]
[17:39:33.879]             }
[17:39:33.879]             function(cond) {
[17:39:33.879]                 is_error <- inherits(cond, "error")
[17:39:33.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.879]                   NULL)
[17:39:33.879]                 if (is_error) {
[17:39:33.879]                   sessionInformation <- function() {
[17:39:33.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.879]                       search = base::search(), system = base::Sys.info())
[17:39:33.879]                   }
[17:39:33.879]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.879]                     cond$call), session = sessionInformation(), 
[17:39:33.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.879]                   signalCondition(cond)
[17:39:33.879]                 }
[17:39:33.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.879]                 "immediateCondition"))) {
[17:39:33.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.879]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.879]                   if (TRUE && !signal) {
[17:39:33.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.879]                     {
[17:39:33.879]                       inherits <- base::inherits
[17:39:33.879]                       invokeRestart <- base::invokeRestart
[17:39:33.879]                       is.null <- base::is.null
[17:39:33.879]                       muffled <- FALSE
[17:39:33.879]                       if (inherits(cond, "message")) {
[17:39:33.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.879]                         if (muffled) 
[17:39:33.879]                           invokeRestart("muffleMessage")
[17:39:33.879]                       }
[17:39:33.879]                       else if (inherits(cond, "warning")) {
[17:39:33.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.879]                         if (muffled) 
[17:39:33.879]                           invokeRestart("muffleWarning")
[17:39:33.879]                       }
[17:39:33.879]                       else if (inherits(cond, "condition")) {
[17:39:33.879]                         if (!is.null(pattern)) {
[17:39:33.879]                           computeRestarts <- base::computeRestarts
[17:39:33.879]                           grepl <- base::grepl
[17:39:33.879]                           restarts <- computeRestarts(cond)
[17:39:33.879]                           for (restart in restarts) {
[17:39:33.879]                             name <- restart$name
[17:39:33.879]                             if (is.null(name)) 
[17:39:33.879]                               next
[17:39:33.879]                             if (!grepl(pattern, name)) 
[17:39:33.879]                               next
[17:39:33.879]                             invokeRestart(restart)
[17:39:33.879]                             muffled <- TRUE
[17:39:33.879]                             break
[17:39:33.879]                           }
[17:39:33.879]                         }
[17:39:33.879]                       }
[17:39:33.879]                       invisible(muffled)
[17:39:33.879]                     }
[17:39:33.879]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.879]                   }
[17:39:33.879]                 }
[17:39:33.879]                 else {
[17:39:33.879]                   if (TRUE) {
[17:39:33.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.879]                     {
[17:39:33.879]                       inherits <- base::inherits
[17:39:33.879]                       invokeRestart <- base::invokeRestart
[17:39:33.879]                       is.null <- base::is.null
[17:39:33.879]                       muffled <- FALSE
[17:39:33.879]                       if (inherits(cond, "message")) {
[17:39:33.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.879]                         if (muffled) 
[17:39:33.879]                           invokeRestart("muffleMessage")
[17:39:33.879]                       }
[17:39:33.879]                       else if (inherits(cond, "warning")) {
[17:39:33.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.879]                         if (muffled) 
[17:39:33.879]                           invokeRestart("muffleWarning")
[17:39:33.879]                       }
[17:39:33.879]                       else if (inherits(cond, "condition")) {
[17:39:33.879]                         if (!is.null(pattern)) {
[17:39:33.879]                           computeRestarts <- base::computeRestarts
[17:39:33.879]                           grepl <- base::grepl
[17:39:33.879]                           restarts <- computeRestarts(cond)
[17:39:33.879]                           for (restart in restarts) {
[17:39:33.879]                             name <- restart$name
[17:39:33.879]                             if (is.null(name)) 
[17:39:33.879]                               next
[17:39:33.879]                             if (!grepl(pattern, name)) 
[17:39:33.879]                               next
[17:39:33.879]                             invokeRestart(restart)
[17:39:33.879]                             muffled <- TRUE
[17:39:33.879]                             break
[17:39:33.879]                           }
[17:39:33.879]                         }
[17:39:33.879]                       }
[17:39:33.879]                       invisible(muffled)
[17:39:33.879]                     }
[17:39:33.879]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.879]                   }
[17:39:33.879]                 }
[17:39:33.879]             }
[17:39:33.879]         }))
[17:39:33.879]     }, error = function(ex) {
[17:39:33.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.879]                 ...future.rng), started = ...future.startTime, 
[17:39:33.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.879]             version = "1.8"), class = "FutureResult")
[17:39:33.879]     }, finally = {
[17:39:33.879]         if (!identical(...future.workdir, getwd())) 
[17:39:33.879]             setwd(...future.workdir)
[17:39:33.879]         {
[17:39:33.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.879]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.879]             }
[17:39:33.879]             base::options(...future.oldOptions)
[17:39:33.879]             if (.Platform$OS.type == "windows") {
[17:39:33.879]                 old_names <- names(...future.oldEnvVars)
[17:39:33.879]                 envs <- base::Sys.getenv()
[17:39:33.879]                 names <- names(envs)
[17:39:33.879]                 common <- intersect(names, old_names)
[17:39:33.879]                 added <- setdiff(names, old_names)
[17:39:33.879]                 removed <- setdiff(old_names, names)
[17:39:33.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.879]                   envs[common]]
[17:39:33.879]                 NAMES <- toupper(changed)
[17:39:33.879]                 args <- list()
[17:39:33.879]                 for (kk in seq_along(NAMES)) {
[17:39:33.879]                   name <- changed[[kk]]
[17:39:33.879]                   NAME <- NAMES[[kk]]
[17:39:33.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.879]                     next
[17:39:33.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.879]                 }
[17:39:33.879]                 NAMES <- toupper(added)
[17:39:33.879]                 for (kk in seq_along(NAMES)) {
[17:39:33.879]                   name <- added[[kk]]
[17:39:33.879]                   NAME <- NAMES[[kk]]
[17:39:33.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.879]                     next
[17:39:33.879]                   args[[name]] <- ""
[17:39:33.879]                 }
[17:39:33.879]                 NAMES <- toupper(removed)
[17:39:33.879]                 for (kk in seq_along(NAMES)) {
[17:39:33.879]                   name <- removed[[kk]]
[17:39:33.879]                   NAME <- NAMES[[kk]]
[17:39:33.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.879]                     next
[17:39:33.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.879]                 }
[17:39:33.879]                 if (length(args) > 0) 
[17:39:33.879]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.879]             }
[17:39:33.879]             else {
[17:39:33.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.879]             }
[17:39:33.879]             {
[17:39:33.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.879]                   0L) {
[17:39:33.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.879]                   base::options(opts)
[17:39:33.879]                 }
[17:39:33.879]                 {
[17:39:33.879]                   {
[17:39:33.879]                     NULL
[17:39:33.879]                     RNGkind("Mersenne-Twister")
[17:39:33.879]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.879]                       inherits = FALSE)
[17:39:33.879]                   }
[17:39:33.879]                   options(future.plan = NULL)
[17:39:33.879]                   if (is.na(NA_character_)) 
[17:39:33.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.879]                     .init = FALSE)
[17:39:33.879]                 }
[17:39:33.879]             }
[17:39:33.879]         }
[17:39:33.879]     })
[17:39:33.879]     if (TRUE) {
[17:39:33.879]         base::sink(type = "output", split = FALSE)
[17:39:33.879]         if (TRUE) {
[17:39:33.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.879]         }
[17:39:33.879]         else {
[17:39:33.879]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.879]         }
[17:39:33.879]         base::close(...future.stdout)
[17:39:33.879]         ...future.stdout <- NULL
[17:39:33.879]     }
[17:39:33.879]     ...future.result$conditions <- ...future.conditions
[17:39:33.879]     ...future.result$finished <- base::Sys.time()
[17:39:33.879]     ...future.result
[17:39:33.879] }
[17:39:33.881] plan(): Setting new future strategy stack:
[17:39:33.881] List of future strategies:
[17:39:33.881] 1. sequential:
[17:39:33.881]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.881]    - tweaked: FALSE
[17:39:33.881]    - call: NULL
[17:39:33.881] plan(): nbrOfWorkers() = 1
[17:39:33.882] plan(): Setting new future strategy stack:
[17:39:33.882] List of future strategies:
[17:39:33.882] 1. sequential:
[17:39:33.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.882]    - tweaked: FALSE
[17:39:33.882]    - call: plan(strategy)
[17:39:33.883] plan(): nbrOfWorkers() = 1
[17:39:33.883] SequentialFuture started (and completed)
[17:39:33.883] - Launch lazy future ... done
[17:39:33.883] run() for ‘SequentialFuture’ ... done
[17:39:33.883] getGlobalsAndPackages() ...
[17:39:33.883] Searching for globals...
[17:39:33.884] - globals found: [1] ‘{’
[17:39:33.884] Searching for globals ... DONE
[17:39:33.884] Resolving globals: FALSE
[17:39:33.885] 
[17:39:33.887] 
[17:39:33.887] getGlobalsAndPackages() ... DONE
[17:39:33.887] run() for ‘Future’ ...
[17:39:33.887] - state: ‘created’
[17:39:33.887] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.888]   - Field: ‘label’
[17:39:33.888]   - Field: ‘local’
[17:39:33.888]   - Field: ‘owner’
[17:39:33.888]   - Field: ‘envir’
[17:39:33.888]   - Field: ‘packages’
[17:39:33.888]   - Field: ‘gc’
[17:39:33.888]   - Field: ‘conditions’
[17:39:33.888]   - Field: ‘expr’
[17:39:33.889]   - Field: ‘uuid’
[17:39:33.889]   - Field: ‘seed’
[17:39:33.889]   - Field: ‘version’
[17:39:33.889]   - Field: ‘result’
[17:39:33.889]   - Field: ‘asynchronous’
[17:39:33.889]   - Field: ‘calls’
[17:39:33.889]   - Field: ‘globals’
[17:39:33.889]   - Field: ‘stdout’
[17:39:33.889]   - Field: ‘earlySignal’
[17:39:33.889]   - Field: ‘lazy’
[17:39:33.889]   - Field: ‘state’
[17:39:33.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.890] - Launch lazy future ...
[17:39:33.890] Packages needed by the future expression (n = 0): <none>
[17:39:33.890] Packages needed by future strategies (n = 0): <none>
[17:39:33.890] {
[17:39:33.890]     {
[17:39:33.890]         {
[17:39:33.890]             ...future.startTime <- base::Sys.time()
[17:39:33.890]             {
[17:39:33.890]                 {
[17:39:33.890]                   {
[17:39:33.890]                     base::local({
[17:39:33.890]                       has_future <- base::requireNamespace("future", 
[17:39:33.890]                         quietly = TRUE)
[17:39:33.890]                       if (has_future) {
[17:39:33.890]                         ns <- base::getNamespace("future")
[17:39:33.890]                         version <- ns[[".package"]][["version"]]
[17:39:33.890]                         if (is.null(version)) 
[17:39:33.890]                           version <- utils::packageVersion("future")
[17:39:33.890]                       }
[17:39:33.890]                       else {
[17:39:33.890]                         version <- NULL
[17:39:33.890]                       }
[17:39:33.890]                       if (!has_future || version < "1.8.0") {
[17:39:33.890]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.890]                           "", base::R.version$version.string), 
[17:39:33.890]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.890]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.890]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.890]                             "release", "version")], collapse = " "), 
[17:39:33.890]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.890]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.890]                           info)
[17:39:33.890]                         info <- base::paste(info, collapse = "; ")
[17:39:33.890]                         if (!has_future) {
[17:39:33.890]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.890]                             info)
[17:39:33.890]                         }
[17:39:33.890]                         else {
[17:39:33.890]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.890]                             info, version)
[17:39:33.890]                         }
[17:39:33.890]                         base::stop(msg)
[17:39:33.890]                       }
[17:39:33.890]                     })
[17:39:33.890]                   }
[17:39:33.890]                   ...future.strategy.old <- future::plan("list")
[17:39:33.890]                   options(future.plan = NULL)
[17:39:33.890]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.890]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.890]                 }
[17:39:33.890]                 ...future.workdir <- getwd()
[17:39:33.890]             }
[17:39:33.890]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.890]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.890]         }
[17:39:33.890]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.890]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.890]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.890]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.890]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.890]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.890]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.890]             base::names(...future.oldOptions))
[17:39:33.890]     }
[17:39:33.890]     if (FALSE) {
[17:39:33.890]     }
[17:39:33.890]     else {
[17:39:33.890]         if (TRUE) {
[17:39:33.890]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.890]                 open = "w")
[17:39:33.890]         }
[17:39:33.890]         else {
[17:39:33.890]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.890]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.890]         }
[17:39:33.890]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.890]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.890]             base::sink(type = "output", split = FALSE)
[17:39:33.890]             base::close(...future.stdout)
[17:39:33.890]         }, add = TRUE)
[17:39:33.890]     }
[17:39:33.890]     ...future.frame <- base::sys.nframe()
[17:39:33.890]     ...future.conditions <- base::list()
[17:39:33.890]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.890]     if (FALSE) {
[17:39:33.890]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.890]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.890]     }
[17:39:33.890]     ...future.result <- base::tryCatch({
[17:39:33.890]         base::withCallingHandlers({
[17:39:33.890]             ...future.value <- base::withVisible(base::local({
[17:39:33.890]                 4
[17:39:33.890]             }))
[17:39:33.890]             future::FutureResult(value = ...future.value$value, 
[17:39:33.890]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.890]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.890]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.890]                     ...future.globalenv.names))
[17:39:33.890]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.890]         }, condition = base::local({
[17:39:33.890]             c <- base::c
[17:39:33.890]             inherits <- base::inherits
[17:39:33.890]             invokeRestart <- base::invokeRestart
[17:39:33.890]             length <- base::length
[17:39:33.890]             list <- base::list
[17:39:33.890]             seq.int <- base::seq.int
[17:39:33.890]             signalCondition <- base::signalCondition
[17:39:33.890]             sys.calls <- base::sys.calls
[17:39:33.890]             `[[` <- base::`[[`
[17:39:33.890]             `+` <- base::`+`
[17:39:33.890]             `<<-` <- base::`<<-`
[17:39:33.890]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.890]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.890]                   3L)]
[17:39:33.890]             }
[17:39:33.890]             function(cond) {
[17:39:33.890]                 is_error <- inherits(cond, "error")
[17:39:33.890]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.890]                   NULL)
[17:39:33.890]                 if (is_error) {
[17:39:33.890]                   sessionInformation <- function() {
[17:39:33.890]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.890]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.890]                       search = base::search(), system = base::Sys.info())
[17:39:33.890]                   }
[17:39:33.890]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.890]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.890]                     cond$call), session = sessionInformation(), 
[17:39:33.890]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.890]                   signalCondition(cond)
[17:39:33.890]                 }
[17:39:33.890]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.890]                 "immediateCondition"))) {
[17:39:33.890]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.890]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.890]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.890]                   if (TRUE && !signal) {
[17:39:33.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.890]                     {
[17:39:33.890]                       inherits <- base::inherits
[17:39:33.890]                       invokeRestart <- base::invokeRestart
[17:39:33.890]                       is.null <- base::is.null
[17:39:33.890]                       muffled <- FALSE
[17:39:33.890]                       if (inherits(cond, "message")) {
[17:39:33.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.890]                         if (muffled) 
[17:39:33.890]                           invokeRestart("muffleMessage")
[17:39:33.890]                       }
[17:39:33.890]                       else if (inherits(cond, "warning")) {
[17:39:33.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.890]                         if (muffled) 
[17:39:33.890]                           invokeRestart("muffleWarning")
[17:39:33.890]                       }
[17:39:33.890]                       else if (inherits(cond, "condition")) {
[17:39:33.890]                         if (!is.null(pattern)) {
[17:39:33.890]                           computeRestarts <- base::computeRestarts
[17:39:33.890]                           grepl <- base::grepl
[17:39:33.890]                           restarts <- computeRestarts(cond)
[17:39:33.890]                           for (restart in restarts) {
[17:39:33.890]                             name <- restart$name
[17:39:33.890]                             if (is.null(name)) 
[17:39:33.890]                               next
[17:39:33.890]                             if (!grepl(pattern, name)) 
[17:39:33.890]                               next
[17:39:33.890]                             invokeRestart(restart)
[17:39:33.890]                             muffled <- TRUE
[17:39:33.890]                             break
[17:39:33.890]                           }
[17:39:33.890]                         }
[17:39:33.890]                       }
[17:39:33.890]                       invisible(muffled)
[17:39:33.890]                     }
[17:39:33.890]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.890]                   }
[17:39:33.890]                 }
[17:39:33.890]                 else {
[17:39:33.890]                   if (TRUE) {
[17:39:33.890]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.890]                     {
[17:39:33.890]                       inherits <- base::inherits
[17:39:33.890]                       invokeRestart <- base::invokeRestart
[17:39:33.890]                       is.null <- base::is.null
[17:39:33.890]                       muffled <- FALSE
[17:39:33.890]                       if (inherits(cond, "message")) {
[17:39:33.890]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.890]                         if (muffled) 
[17:39:33.890]                           invokeRestart("muffleMessage")
[17:39:33.890]                       }
[17:39:33.890]                       else if (inherits(cond, "warning")) {
[17:39:33.890]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.890]                         if (muffled) 
[17:39:33.890]                           invokeRestart("muffleWarning")
[17:39:33.890]                       }
[17:39:33.890]                       else if (inherits(cond, "condition")) {
[17:39:33.890]                         if (!is.null(pattern)) {
[17:39:33.890]                           computeRestarts <- base::computeRestarts
[17:39:33.890]                           grepl <- base::grepl
[17:39:33.890]                           restarts <- computeRestarts(cond)
[17:39:33.890]                           for (restart in restarts) {
[17:39:33.890]                             name <- restart$name
[17:39:33.890]                             if (is.null(name)) 
[17:39:33.890]                               next
[17:39:33.890]                             if (!grepl(pattern, name)) 
[17:39:33.890]                               next
[17:39:33.890]                             invokeRestart(restart)
[17:39:33.890]                             muffled <- TRUE
[17:39:33.890]                             break
[17:39:33.890]                           }
[17:39:33.890]                         }
[17:39:33.890]                       }
[17:39:33.890]                       invisible(muffled)
[17:39:33.890]                     }
[17:39:33.890]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.890]                   }
[17:39:33.890]                 }
[17:39:33.890]             }
[17:39:33.890]         }))
[17:39:33.890]     }, error = function(ex) {
[17:39:33.890]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.890]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.890]                 ...future.rng), started = ...future.startTime, 
[17:39:33.890]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.890]             version = "1.8"), class = "FutureResult")
[17:39:33.890]     }, finally = {
[17:39:33.890]         if (!identical(...future.workdir, getwd())) 
[17:39:33.890]             setwd(...future.workdir)
[17:39:33.890]         {
[17:39:33.890]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.890]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.890]             }
[17:39:33.890]             base::options(...future.oldOptions)
[17:39:33.890]             if (.Platform$OS.type == "windows") {
[17:39:33.890]                 old_names <- names(...future.oldEnvVars)
[17:39:33.890]                 envs <- base::Sys.getenv()
[17:39:33.890]                 names <- names(envs)
[17:39:33.890]                 common <- intersect(names, old_names)
[17:39:33.890]                 added <- setdiff(names, old_names)
[17:39:33.890]                 removed <- setdiff(old_names, names)
[17:39:33.890]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.890]                   envs[common]]
[17:39:33.890]                 NAMES <- toupper(changed)
[17:39:33.890]                 args <- list()
[17:39:33.890]                 for (kk in seq_along(NAMES)) {
[17:39:33.890]                   name <- changed[[kk]]
[17:39:33.890]                   NAME <- NAMES[[kk]]
[17:39:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.890]                     next
[17:39:33.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.890]                 }
[17:39:33.890]                 NAMES <- toupper(added)
[17:39:33.890]                 for (kk in seq_along(NAMES)) {
[17:39:33.890]                   name <- added[[kk]]
[17:39:33.890]                   NAME <- NAMES[[kk]]
[17:39:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.890]                     next
[17:39:33.890]                   args[[name]] <- ""
[17:39:33.890]                 }
[17:39:33.890]                 NAMES <- toupper(removed)
[17:39:33.890]                 for (kk in seq_along(NAMES)) {
[17:39:33.890]                   name <- removed[[kk]]
[17:39:33.890]                   NAME <- NAMES[[kk]]
[17:39:33.890]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.890]                     next
[17:39:33.890]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.890]                 }
[17:39:33.890]                 if (length(args) > 0) 
[17:39:33.890]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.890]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.890]             }
[17:39:33.890]             else {
[17:39:33.890]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.890]             }
[17:39:33.890]             {
[17:39:33.890]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.890]                   0L) {
[17:39:33.890]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.890]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.890]                   base::options(opts)
[17:39:33.890]                 }
[17:39:33.890]                 {
[17:39:33.890]                   {
[17:39:33.890]                     NULL
[17:39:33.890]                     RNGkind("Mersenne-Twister")
[17:39:33.890]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.890]                       inherits = FALSE)
[17:39:33.890]                   }
[17:39:33.890]                   options(future.plan = NULL)
[17:39:33.890]                   if (is.na(NA_character_)) 
[17:39:33.890]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.890]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.890]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.890]                     .init = FALSE)
[17:39:33.890]                 }
[17:39:33.890]             }
[17:39:33.890]         }
[17:39:33.890]     })
[17:39:33.890]     if (TRUE) {
[17:39:33.890]         base::sink(type = "output", split = FALSE)
[17:39:33.890]         if (TRUE) {
[17:39:33.890]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.890]         }
[17:39:33.890]         else {
[17:39:33.890]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.890]         }
[17:39:33.890]         base::close(...future.stdout)
[17:39:33.890]         ...future.stdout <- NULL
[17:39:33.890]     }
[17:39:33.890]     ...future.result$conditions <- ...future.conditions
[17:39:33.890]     ...future.result$finished <- base::Sys.time()
[17:39:33.890]     ...future.result
[17:39:33.890] }
[17:39:33.892] plan(): Setting new future strategy stack:
[17:39:33.892] List of future strategies:
[17:39:33.892] 1. sequential:
[17:39:33.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.892]    - tweaked: FALSE
[17:39:33.892]    - call: NULL
[17:39:33.893] plan(): nbrOfWorkers() = 1
[17:39:33.893] plan(): Setting new future strategy stack:
[17:39:33.893] List of future strategies:
[17:39:33.893] 1. sequential:
[17:39:33.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.893]    - tweaked: FALSE
[17:39:33.893]    - call: plan(strategy)
[17:39:33.894] plan(): nbrOfWorkers() = 1
[17:39:33.894] SequentialFuture started (and completed)
[17:39:33.894] - Launch lazy future ... done
[17:39:33.894] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adefb24a78> 
Classes 'listenv', 'environment' <environment: 0x55adee9067d0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:33.898] resolved() for ‘SequentialFuture’ ...
[17:39:33.898] - state: ‘finished’
[17:39:33.898] - run: TRUE
[17:39:33.898] - result: ‘FutureResult’
[17:39:33.898] resolved() for ‘SequentialFuture’ ... done
[17:39:33.898] resolved() for ‘SequentialFuture’ ...
[17:39:33.898] - state: ‘finished’
[17:39:33.899] - run: TRUE
[17:39:33.899] - result: ‘FutureResult’
[17:39:33.899] resolved() for ‘SequentialFuture’ ... done
[17:39:33.899] resolved() for ‘SequentialFuture’ ...
[17:39:33.899] - state: ‘finished’
[17:39:33.899] - run: TRUE
[17:39:33.899] - result: ‘FutureResult’
[17:39:33.899] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:33.901] resolve() on list environment ...
[17:39:33.902]  recursive: 0
[17:39:33.902]  length: 6
[17:39:33.903]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:33.903] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.903] - nx: 6
[17:39:33.903] - relay: TRUE
[17:39:33.903] - stdout: TRUE
[17:39:33.903] - signal: TRUE
[17:39:33.903] - resignal: FALSE
[17:39:33.903] - force: TRUE
[17:39:33.903] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.903] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.903]  - until=2
[17:39:33.904]  - relaying element #2
[17:39:33.904] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.904] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.904] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.904]  length: 5 (resolved future 1)
[17:39:33.904] resolved() for ‘SequentialFuture’ ...
[17:39:33.904] - state: ‘finished’
[17:39:33.904] - run: TRUE
[17:39:33.904] - result: ‘FutureResult’
[17:39:33.905] resolved() for ‘SequentialFuture’ ... done
[17:39:33.905] Future #2
[17:39:33.905] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.905] - nx: 6
[17:39:33.905] - relay: TRUE
[17:39:33.905] - stdout: TRUE
[17:39:33.905] - signal: TRUE
[17:39:33.905] - resignal: FALSE
[17:39:33.905] - force: TRUE
[17:39:33.905] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.905] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.906]  - until=2
[17:39:33.906]  - relaying element #2
[17:39:33.906] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.906] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.906] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.906]  length: 4 (resolved future 2)
[17:39:33.906] resolved() for ‘SequentialFuture’ ...
[17:39:33.906] - state: ‘finished’
[17:39:33.906] - run: TRUE
[17:39:33.906] - result: ‘FutureResult’
[17:39:33.907] resolved() for ‘SequentialFuture’ ... done
[17:39:33.907] Future #3
[17:39:33.907] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.907] - nx: 6
[17:39:33.907] - relay: TRUE
[17:39:33.907] - stdout: TRUE
[17:39:33.907] - signal: TRUE
[17:39:33.907] - resignal: FALSE
[17:39:33.907] - force: TRUE
[17:39:33.907] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.907] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.908]  - until=3
[17:39:33.908]  - relaying element #3
[17:39:33.908] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.908] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.908] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.908]  length: 3 (resolved future 3)
[17:39:33.908] resolved() for ‘SequentialFuture’ ...
[17:39:33.908] - state: ‘finished’
[17:39:33.908] - run: TRUE
[17:39:33.909] - result: ‘FutureResult’
[17:39:33.909] resolved() for ‘SequentialFuture’ ... done
[17:39:33.909] Future #4
[17:39:33.909] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.909] - nx: 6
[17:39:33.909] - relay: TRUE
[17:39:33.909] - stdout: TRUE
[17:39:33.909] - signal: TRUE
[17:39:33.909] - resignal: FALSE
[17:39:33.909] - force: TRUE
[17:39:33.909] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.910] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.910]  - until=4
[17:39:33.910]  - relaying element #4
[17:39:33.910] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.910] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.910] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.910]  length: 2 (resolved future 4)
[17:39:33.910] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.910] - nx: 6
[17:39:33.943] - relay: TRUE
[17:39:33.943] - stdout: TRUE
[17:39:33.943] - signal: TRUE
[17:39:33.943] - resignal: FALSE
[17:39:33.943] - force: TRUE
[17:39:33.944] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.944] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.944]  - until=6
[17:39:33.944]  - relaying element #6
[17:39:33.944] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.944] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.944] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.944]  length: 1 (resolved future 5)
[17:39:33.945] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.945] - nx: 6
[17:39:33.945] - relay: TRUE
[17:39:33.945] - stdout: TRUE
[17:39:33.945] - signal: TRUE
[17:39:33.945] - resignal: FALSE
[17:39:33.945] - force: TRUE
[17:39:33.945] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.945] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.945]  - until=6
[17:39:33.945] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.946] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.946] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.946]  length: 0 (resolved future 6)
[17:39:33.946] Relaying remaining futures
[17:39:33.946] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.946] - nx: 6
[17:39:33.946] - relay: TRUE
[17:39:33.946] - stdout: TRUE
[17:39:33.946] - signal: TRUE
[17:39:33.946] - resignal: FALSE
[17:39:33.946] - force: TRUE
[17:39:33.947] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.947] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:33.947] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.947] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.947] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.947] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55adeffde030> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:33.949] getGlobalsAndPackages() ...
[17:39:33.950] Searching for globals...
[17:39:33.950] 
[17:39:33.950] Searching for globals ... DONE
[17:39:33.950] - globals: [0] <none>
[17:39:33.950] getGlobalsAndPackages() ... DONE
[17:39:33.950] run() for ‘Future’ ...
[17:39:33.951] - state: ‘created’
[17:39:33.951] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.951] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.951]   - Field: ‘label’
[17:39:33.951]   - Field: ‘local’
[17:39:33.951]   - Field: ‘owner’
[17:39:33.952]   - Field: ‘envir’
[17:39:33.952]   - Field: ‘packages’
[17:39:33.952]   - Field: ‘gc’
[17:39:33.952]   - Field: ‘conditions’
[17:39:33.952]   - Field: ‘expr’
[17:39:33.952]   - Field: ‘uuid’
[17:39:33.952]   - Field: ‘seed’
[17:39:33.952]   - Field: ‘version’
[17:39:33.952]   - Field: ‘result’
[17:39:33.952]   - Field: ‘asynchronous’
[17:39:33.952]   - Field: ‘calls’
[17:39:33.953]   - Field: ‘globals’
[17:39:33.953]   - Field: ‘stdout’
[17:39:33.953]   - Field: ‘earlySignal’
[17:39:33.953]   - Field: ‘lazy’
[17:39:33.953]   - Field: ‘state’
[17:39:33.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.953] - Launch lazy future ...
[17:39:33.953] Packages needed by the future expression (n = 0): <none>
[17:39:33.953] Packages needed by future strategies (n = 0): <none>
[17:39:33.954] {
[17:39:33.954]     {
[17:39:33.954]         {
[17:39:33.954]             ...future.startTime <- base::Sys.time()
[17:39:33.954]             {
[17:39:33.954]                 {
[17:39:33.954]                   {
[17:39:33.954]                     base::local({
[17:39:33.954]                       has_future <- base::requireNamespace("future", 
[17:39:33.954]                         quietly = TRUE)
[17:39:33.954]                       if (has_future) {
[17:39:33.954]                         ns <- base::getNamespace("future")
[17:39:33.954]                         version <- ns[[".package"]][["version"]]
[17:39:33.954]                         if (is.null(version)) 
[17:39:33.954]                           version <- utils::packageVersion("future")
[17:39:33.954]                       }
[17:39:33.954]                       else {
[17:39:33.954]                         version <- NULL
[17:39:33.954]                       }
[17:39:33.954]                       if (!has_future || version < "1.8.0") {
[17:39:33.954]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.954]                           "", base::R.version$version.string), 
[17:39:33.954]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.954]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.954]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.954]                             "release", "version")], collapse = " "), 
[17:39:33.954]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.954]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.954]                           info)
[17:39:33.954]                         info <- base::paste(info, collapse = "; ")
[17:39:33.954]                         if (!has_future) {
[17:39:33.954]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.954]                             info)
[17:39:33.954]                         }
[17:39:33.954]                         else {
[17:39:33.954]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.954]                             info, version)
[17:39:33.954]                         }
[17:39:33.954]                         base::stop(msg)
[17:39:33.954]                       }
[17:39:33.954]                     })
[17:39:33.954]                   }
[17:39:33.954]                   ...future.strategy.old <- future::plan("list")
[17:39:33.954]                   options(future.plan = NULL)
[17:39:33.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.954]                 }
[17:39:33.954]                 ...future.workdir <- getwd()
[17:39:33.954]             }
[17:39:33.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.954]         }
[17:39:33.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.954]             base::names(...future.oldOptions))
[17:39:33.954]     }
[17:39:33.954]     if (FALSE) {
[17:39:33.954]     }
[17:39:33.954]     else {
[17:39:33.954]         if (TRUE) {
[17:39:33.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.954]                 open = "w")
[17:39:33.954]         }
[17:39:33.954]         else {
[17:39:33.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.954]         }
[17:39:33.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.954]             base::sink(type = "output", split = FALSE)
[17:39:33.954]             base::close(...future.stdout)
[17:39:33.954]         }, add = TRUE)
[17:39:33.954]     }
[17:39:33.954]     ...future.frame <- base::sys.nframe()
[17:39:33.954]     ...future.conditions <- base::list()
[17:39:33.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.954]     if (FALSE) {
[17:39:33.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.954]     }
[17:39:33.954]     ...future.result <- base::tryCatch({
[17:39:33.954]         base::withCallingHandlers({
[17:39:33.954]             ...future.value <- base::withVisible(base::local(2))
[17:39:33.954]             future::FutureResult(value = ...future.value$value, 
[17:39:33.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.954]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.954]                     ...future.globalenv.names))
[17:39:33.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.954]         }, condition = base::local({
[17:39:33.954]             c <- base::c
[17:39:33.954]             inherits <- base::inherits
[17:39:33.954]             invokeRestart <- base::invokeRestart
[17:39:33.954]             length <- base::length
[17:39:33.954]             list <- base::list
[17:39:33.954]             seq.int <- base::seq.int
[17:39:33.954]             signalCondition <- base::signalCondition
[17:39:33.954]             sys.calls <- base::sys.calls
[17:39:33.954]             `[[` <- base::`[[`
[17:39:33.954]             `+` <- base::`+`
[17:39:33.954]             `<<-` <- base::`<<-`
[17:39:33.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.954]                   3L)]
[17:39:33.954]             }
[17:39:33.954]             function(cond) {
[17:39:33.954]                 is_error <- inherits(cond, "error")
[17:39:33.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.954]                   NULL)
[17:39:33.954]                 if (is_error) {
[17:39:33.954]                   sessionInformation <- function() {
[17:39:33.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.954]                       search = base::search(), system = base::Sys.info())
[17:39:33.954]                   }
[17:39:33.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.954]                     cond$call), session = sessionInformation(), 
[17:39:33.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.954]                   signalCondition(cond)
[17:39:33.954]                 }
[17:39:33.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.954]                 "immediateCondition"))) {
[17:39:33.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.954]                   if (TRUE && !signal) {
[17:39:33.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.954]                     {
[17:39:33.954]                       inherits <- base::inherits
[17:39:33.954]                       invokeRestart <- base::invokeRestart
[17:39:33.954]                       is.null <- base::is.null
[17:39:33.954]                       muffled <- FALSE
[17:39:33.954]                       if (inherits(cond, "message")) {
[17:39:33.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.954]                         if (muffled) 
[17:39:33.954]                           invokeRestart("muffleMessage")
[17:39:33.954]                       }
[17:39:33.954]                       else if (inherits(cond, "warning")) {
[17:39:33.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.954]                         if (muffled) 
[17:39:33.954]                           invokeRestart("muffleWarning")
[17:39:33.954]                       }
[17:39:33.954]                       else if (inherits(cond, "condition")) {
[17:39:33.954]                         if (!is.null(pattern)) {
[17:39:33.954]                           computeRestarts <- base::computeRestarts
[17:39:33.954]                           grepl <- base::grepl
[17:39:33.954]                           restarts <- computeRestarts(cond)
[17:39:33.954]                           for (restart in restarts) {
[17:39:33.954]                             name <- restart$name
[17:39:33.954]                             if (is.null(name)) 
[17:39:33.954]                               next
[17:39:33.954]                             if (!grepl(pattern, name)) 
[17:39:33.954]                               next
[17:39:33.954]                             invokeRestart(restart)
[17:39:33.954]                             muffled <- TRUE
[17:39:33.954]                             break
[17:39:33.954]                           }
[17:39:33.954]                         }
[17:39:33.954]                       }
[17:39:33.954]                       invisible(muffled)
[17:39:33.954]                     }
[17:39:33.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.954]                   }
[17:39:33.954]                 }
[17:39:33.954]                 else {
[17:39:33.954]                   if (TRUE) {
[17:39:33.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.954]                     {
[17:39:33.954]                       inherits <- base::inherits
[17:39:33.954]                       invokeRestart <- base::invokeRestart
[17:39:33.954]                       is.null <- base::is.null
[17:39:33.954]                       muffled <- FALSE
[17:39:33.954]                       if (inherits(cond, "message")) {
[17:39:33.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.954]                         if (muffled) 
[17:39:33.954]                           invokeRestart("muffleMessage")
[17:39:33.954]                       }
[17:39:33.954]                       else if (inherits(cond, "warning")) {
[17:39:33.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.954]                         if (muffled) 
[17:39:33.954]                           invokeRestart("muffleWarning")
[17:39:33.954]                       }
[17:39:33.954]                       else if (inherits(cond, "condition")) {
[17:39:33.954]                         if (!is.null(pattern)) {
[17:39:33.954]                           computeRestarts <- base::computeRestarts
[17:39:33.954]                           grepl <- base::grepl
[17:39:33.954]                           restarts <- computeRestarts(cond)
[17:39:33.954]                           for (restart in restarts) {
[17:39:33.954]                             name <- restart$name
[17:39:33.954]                             if (is.null(name)) 
[17:39:33.954]                               next
[17:39:33.954]                             if (!grepl(pattern, name)) 
[17:39:33.954]                               next
[17:39:33.954]                             invokeRestart(restart)
[17:39:33.954]                             muffled <- TRUE
[17:39:33.954]                             break
[17:39:33.954]                           }
[17:39:33.954]                         }
[17:39:33.954]                       }
[17:39:33.954]                       invisible(muffled)
[17:39:33.954]                     }
[17:39:33.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.954]                   }
[17:39:33.954]                 }
[17:39:33.954]             }
[17:39:33.954]         }))
[17:39:33.954]     }, error = function(ex) {
[17:39:33.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.954]                 ...future.rng), started = ...future.startTime, 
[17:39:33.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.954]             version = "1.8"), class = "FutureResult")
[17:39:33.954]     }, finally = {
[17:39:33.954]         if (!identical(...future.workdir, getwd())) 
[17:39:33.954]             setwd(...future.workdir)
[17:39:33.954]         {
[17:39:33.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.954]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.954]             }
[17:39:33.954]             base::options(...future.oldOptions)
[17:39:33.954]             if (.Platform$OS.type == "windows") {
[17:39:33.954]                 old_names <- names(...future.oldEnvVars)
[17:39:33.954]                 envs <- base::Sys.getenv()
[17:39:33.954]                 names <- names(envs)
[17:39:33.954]                 common <- intersect(names, old_names)
[17:39:33.954]                 added <- setdiff(names, old_names)
[17:39:33.954]                 removed <- setdiff(old_names, names)
[17:39:33.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.954]                   envs[common]]
[17:39:33.954]                 NAMES <- toupper(changed)
[17:39:33.954]                 args <- list()
[17:39:33.954]                 for (kk in seq_along(NAMES)) {
[17:39:33.954]                   name <- changed[[kk]]
[17:39:33.954]                   NAME <- NAMES[[kk]]
[17:39:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.954]                     next
[17:39:33.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.954]                 }
[17:39:33.954]                 NAMES <- toupper(added)
[17:39:33.954]                 for (kk in seq_along(NAMES)) {
[17:39:33.954]                   name <- added[[kk]]
[17:39:33.954]                   NAME <- NAMES[[kk]]
[17:39:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.954]                     next
[17:39:33.954]                   args[[name]] <- ""
[17:39:33.954]                 }
[17:39:33.954]                 NAMES <- toupper(removed)
[17:39:33.954]                 for (kk in seq_along(NAMES)) {
[17:39:33.954]                   name <- removed[[kk]]
[17:39:33.954]                   NAME <- NAMES[[kk]]
[17:39:33.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.954]                     next
[17:39:33.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.954]                 }
[17:39:33.954]                 if (length(args) > 0) 
[17:39:33.954]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.954]             }
[17:39:33.954]             else {
[17:39:33.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.954]             }
[17:39:33.954]             {
[17:39:33.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.954]                   0L) {
[17:39:33.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.954]                   base::options(opts)
[17:39:33.954]                 }
[17:39:33.954]                 {
[17:39:33.954]                   {
[17:39:33.954]                     NULL
[17:39:33.954]                     RNGkind("Mersenne-Twister")
[17:39:33.954]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.954]                       inherits = FALSE)
[17:39:33.954]                   }
[17:39:33.954]                   options(future.plan = NULL)
[17:39:33.954]                   if (is.na(NA_character_)) 
[17:39:33.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.954]                     .init = FALSE)
[17:39:33.954]                 }
[17:39:33.954]             }
[17:39:33.954]         }
[17:39:33.954]     })
[17:39:33.954]     if (TRUE) {
[17:39:33.954]         base::sink(type = "output", split = FALSE)
[17:39:33.954]         if (TRUE) {
[17:39:33.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.954]         }
[17:39:33.954]         else {
[17:39:33.954]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.954]         }
[17:39:33.954]         base::close(...future.stdout)
[17:39:33.954]         ...future.stdout <- NULL
[17:39:33.954]     }
[17:39:33.954]     ...future.result$conditions <- ...future.conditions
[17:39:33.954]     ...future.result$finished <- base::Sys.time()
[17:39:33.954]     ...future.result
[17:39:33.954] }
[17:39:33.956] plan(): Setting new future strategy stack:
[17:39:33.956] List of future strategies:
[17:39:33.956] 1. sequential:
[17:39:33.956]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.956]    - tweaked: FALSE
[17:39:33.956]    - call: NULL
[17:39:33.956] plan(): nbrOfWorkers() = 1
[17:39:33.957] plan(): Setting new future strategy stack:
[17:39:33.957] List of future strategies:
[17:39:33.957] 1. sequential:
[17:39:33.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.957]    - tweaked: FALSE
[17:39:33.957]    - call: plan(strategy)
[17:39:33.958] plan(): nbrOfWorkers() = 1
[17:39:33.958] SequentialFuture started (and completed)
[17:39:33.958] - Launch lazy future ... done
[17:39:33.958] run() for ‘SequentialFuture’ ... done
[17:39:33.958] getGlobalsAndPackages() ...
[17:39:33.958] Searching for globals...
[17:39:33.959] 
[17:39:33.959] Searching for globals ... DONE
[17:39:33.959] - globals: [0] <none>
[17:39:33.959] getGlobalsAndPackages() ... DONE
[17:39:33.959] run() for ‘Future’ ...
[17:39:33.959] - state: ‘created’
[17:39:33.960] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.960]   - Field: ‘label’
[17:39:33.960]   - Field: ‘local’
[17:39:33.960]   - Field: ‘owner’
[17:39:33.960]   - Field: ‘envir’
[17:39:33.960]   - Field: ‘packages’
[17:39:33.960]   - Field: ‘gc’
[17:39:33.961]   - Field: ‘conditions’
[17:39:33.961]   - Field: ‘expr’
[17:39:33.961]   - Field: ‘uuid’
[17:39:33.961]   - Field: ‘seed’
[17:39:33.961]   - Field: ‘version’
[17:39:33.961]   - Field: ‘result’
[17:39:33.961]   - Field: ‘asynchronous’
[17:39:33.961]   - Field: ‘calls’
[17:39:33.961]   - Field: ‘globals’
[17:39:33.961]   - Field: ‘stdout’
[17:39:33.961]   - Field: ‘earlySignal’
[17:39:33.962]   - Field: ‘lazy’
[17:39:33.962]   - Field: ‘state’
[17:39:33.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.962] - Launch lazy future ...
[17:39:33.962] Packages needed by the future expression (n = 0): <none>
[17:39:33.962] Packages needed by future strategies (n = 0): <none>
[17:39:33.963] {
[17:39:33.963]     {
[17:39:33.963]         {
[17:39:33.963]             ...future.startTime <- base::Sys.time()
[17:39:33.963]             {
[17:39:33.963]                 {
[17:39:33.963]                   {
[17:39:33.963]                     base::local({
[17:39:33.963]                       has_future <- base::requireNamespace("future", 
[17:39:33.963]                         quietly = TRUE)
[17:39:33.963]                       if (has_future) {
[17:39:33.963]                         ns <- base::getNamespace("future")
[17:39:33.963]                         version <- ns[[".package"]][["version"]]
[17:39:33.963]                         if (is.null(version)) 
[17:39:33.963]                           version <- utils::packageVersion("future")
[17:39:33.963]                       }
[17:39:33.963]                       else {
[17:39:33.963]                         version <- NULL
[17:39:33.963]                       }
[17:39:33.963]                       if (!has_future || version < "1.8.0") {
[17:39:33.963]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.963]                           "", base::R.version$version.string), 
[17:39:33.963]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.963]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.963]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.963]                             "release", "version")], collapse = " "), 
[17:39:33.963]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.963]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.963]                           info)
[17:39:33.963]                         info <- base::paste(info, collapse = "; ")
[17:39:33.963]                         if (!has_future) {
[17:39:33.963]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.963]                             info)
[17:39:33.963]                         }
[17:39:33.963]                         else {
[17:39:33.963]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.963]                             info, version)
[17:39:33.963]                         }
[17:39:33.963]                         base::stop(msg)
[17:39:33.963]                       }
[17:39:33.963]                     })
[17:39:33.963]                   }
[17:39:33.963]                   ...future.strategy.old <- future::plan("list")
[17:39:33.963]                   options(future.plan = NULL)
[17:39:33.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.963]                 }
[17:39:33.963]                 ...future.workdir <- getwd()
[17:39:33.963]             }
[17:39:33.963]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.963]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.963]         }
[17:39:33.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.963]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.963]             base::names(...future.oldOptions))
[17:39:33.963]     }
[17:39:33.963]     if (FALSE) {
[17:39:33.963]     }
[17:39:33.963]     else {
[17:39:33.963]         if (TRUE) {
[17:39:33.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.963]                 open = "w")
[17:39:33.963]         }
[17:39:33.963]         else {
[17:39:33.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.963]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.963]         }
[17:39:33.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.963]             base::sink(type = "output", split = FALSE)
[17:39:33.963]             base::close(...future.stdout)
[17:39:33.963]         }, add = TRUE)
[17:39:33.963]     }
[17:39:33.963]     ...future.frame <- base::sys.nframe()
[17:39:33.963]     ...future.conditions <- base::list()
[17:39:33.963]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.963]     if (FALSE) {
[17:39:33.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.963]     }
[17:39:33.963]     ...future.result <- base::tryCatch({
[17:39:33.963]         base::withCallingHandlers({
[17:39:33.963]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:33.963]             future::FutureResult(value = ...future.value$value, 
[17:39:33.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.963]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.963]                     ...future.globalenv.names))
[17:39:33.963]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.963]         }, condition = base::local({
[17:39:33.963]             c <- base::c
[17:39:33.963]             inherits <- base::inherits
[17:39:33.963]             invokeRestart <- base::invokeRestart
[17:39:33.963]             length <- base::length
[17:39:33.963]             list <- base::list
[17:39:33.963]             seq.int <- base::seq.int
[17:39:33.963]             signalCondition <- base::signalCondition
[17:39:33.963]             sys.calls <- base::sys.calls
[17:39:33.963]             `[[` <- base::`[[`
[17:39:33.963]             `+` <- base::`+`
[17:39:33.963]             `<<-` <- base::`<<-`
[17:39:33.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.963]                   3L)]
[17:39:33.963]             }
[17:39:33.963]             function(cond) {
[17:39:33.963]                 is_error <- inherits(cond, "error")
[17:39:33.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.963]                   NULL)
[17:39:33.963]                 if (is_error) {
[17:39:33.963]                   sessionInformation <- function() {
[17:39:33.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.963]                       search = base::search(), system = base::Sys.info())
[17:39:33.963]                   }
[17:39:33.963]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.963]                     cond$call), session = sessionInformation(), 
[17:39:33.963]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.963]                   signalCondition(cond)
[17:39:33.963]                 }
[17:39:33.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.963]                 "immediateCondition"))) {
[17:39:33.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.963]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.963]                   if (TRUE && !signal) {
[17:39:33.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.963]                     {
[17:39:33.963]                       inherits <- base::inherits
[17:39:33.963]                       invokeRestart <- base::invokeRestart
[17:39:33.963]                       is.null <- base::is.null
[17:39:33.963]                       muffled <- FALSE
[17:39:33.963]                       if (inherits(cond, "message")) {
[17:39:33.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.963]                         if (muffled) 
[17:39:33.963]                           invokeRestart("muffleMessage")
[17:39:33.963]                       }
[17:39:33.963]                       else if (inherits(cond, "warning")) {
[17:39:33.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.963]                         if (muffled) 
[17:39:33.963]                           invokeRestart("muffleWarning")
[17:39:33.963]                       }
[17:39:33.963]                       else if (inherits(cond, "condition")) {
[17:39:33.963]                         if (!is.null(pattern)) {
[17:39:33.963]                           computeRestarts <- base::computeRestarts
[17:39:33.963]                           grepl <- base::grepl
[17:39:33.963]                           restarts <- computeRestarts(cond)
[17:39:33.963]                           for (restart in restarts) {
[17:39:33.963]                             name <- restart$name
[17:39:33.963]                             if (is.null(name)) 
[17:39:33.963]                               next
[17:39:33.963]                             if (!grepl(pattern, name)) 
[17:39:33.963]                               next
[17:39:33.963]                             invokeRestart(restart)
[17:39:33.963]                             muffled <- TRUE
[17:39:33.963]                             break
[17:39:33.963]                           }
[17:39:33.963]                         }
[17:39:33.963]                       }
[17:39:33.963]                       invisible(muffled)
[17:39:33.963]                     }
[17:39:33.963]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.963]                   }
[17:39:33.963]                 }
[17:39:33.963]                 else {
[17:39:33.963]                   if (TRUE) {
[17:39:33.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.963]                     {
[17:39:33.963]                       inherits <- base::inherits
[17:39:33.963]                       invokeRestart <- base::invokeRestart
[17:39:33.963]                       is.null <- base::is.null
[17:39:33.963]                       muffled <- FALSE
[17:39:33.963]                       if (inherits(cond, "message")) {
[17:39:33.963]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.963]                         if (muffled) 
[17:39:33.963]                           invokeRestart("muffleMessage")
[17:39:33.963]                       }
[17:39:33.963]                       else if (inherits(cond, "warning")) {
[17:39:33.963]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.963]                         if (muffled) 
[17:39:33.963]                           invokeRestart("muffleWarning")
[17:39:33.963]                       }
[17:39:33.963]                       else if (inherits(cond, "condition")) {
[17:39:33.963]                         if (!is.null(pattern)) {
[17:39:33.963]                           computeRestarts <- base::computeRestarts
[17:39:33.963]                           grepl <- base::grepl
[17:39:33.963]                           restarts <- computeRestarts(cond)
[17:39:33.963]                           for (restart in restarts) {
[17:39:33.963]                             name <- restart$name
[17:39:33.963]                             if (is.null(name)) 
[17:39:33.963]                               next
[17:39:33.963]                             if (!grepl(pattern, name)) 
[17:39:33.963]                               next
[17:39:33.963]                             invokeRestart(restart)
[17:39:33.963]                             muffled <- TRUE
[17:39:33.963]                             break
[17:39:33.963]                           }
[17:39:33.963]                         }
[17:39:33.963]                       }
[17:39:33.963]                       invisible(muffled)
[17:39:33.963]                     }
[17:39:33.963]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.963]                   }
[17:39:33.963]                 }
[17:39:33.963]             }
[17:39:33.963]         }))
[17:39:33.963]     }, error = function(ex) {
[17:39:33.963]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.963]                 ...future.rng), started = ...future.startTime, 
[17:39:33.963]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.963]             version = "1.8"), class = "FutureResult")
[17:39:33.963]     }, finally = {
[17:39:33.963]         if (!identical(...future.workdir, getwd())) 
[17:39:33.963]             setwd(...future.workdir)
[17:39:33.963]         {
[17:39:33.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.963]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.963]             }
[17:39:33.963]             base::options(...future.oldOptions)
[17:39:33.963]             if (.Platform$OS.type == "windows") {
[17:39:33.963]                 old_names <- names(...future.oldEnvVars)
[17:39:33.963]                 envs <- base::Sys.getenv()
[17:39:33.963]                 names <- names(envs)
[17:39:33.963]                 common <- intersect(names, old_names)
[17:39:33.963]                 added <- setdiff(names, old_names)
[17:39:33.963]                 removed <- setdiff(old_names, names)
[17:39:33.963]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.963]                   envs[common]]
[17:39:33.963]                 NAMES <- toupper(changed)
[17:39:33.963]                 args <- list()
[17:39:33.963]                 for (kk in seq_along(NAMES)) {
[17:39:33.963]                   name <- changed[[kk]]
[17:39:33.963]                   NAME <- NAMES[[kk]]
[17:39:33.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.963]                     next
[17:39:33.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.963]                 }
[17:39:33.963]                 NAMES <- toupper(added)
[17:39:33.963]                 for (kk in seq_along(NAMES)) {
[17:39:33.963]                   name <- added[[kk]]
[17:39:33.963]                   NAME <- NAMES[[kk]]
[17:39:33.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.963]                     next
[17:39:33.963]                   args[[name]] <- ""
[17:39:33.963]                 }
[17:39:33.963]                 NAMES <- toupper(removed)
[17:39:33.963]                 for (kk in seq_along(NAMES)) {
[17:39:33.963]                   name <- removed[[kk]]
[17:39:33.963]                   NAME <- NAMES[[kk]]
[17:39:33.963]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.963]                     next
[17:39:33.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.963]                 }
[17:39:33.963]                 if (length(args) > 0) 
[17:39:33.963]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.963]             }
[17:39:33.963]             else {
[17:39:33.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.963]             }
[17:39:33.963]             {
[17:39:33.963]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.963]                   0L) {
[17:39:33.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.963]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.963]                   base::options(opts)
[17:39:33.963]                 }
[17:39:33.963]                 {
[17:39:33.963]                   {
[17:39:33.963]                     NULL
[17:39:33.963]                     RNGkind("Mersenne-Twister")
[17:39:33.963]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.963]                       inherits = FALSE)
[17:39:33.963]                   }
[17:39:33.963]                   options(future.plan = NULL)
[17:39:33.963]                   if (is.na(NA_character_)) 
[17:39:33.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.963]                     .init = FALSE)
[17:39:33.963]                 }
[17:39:33.963]             }
[17:39:33.963]         }
[17:39:33.963]     })
[17:39:33.963]     if (TRUE) {
[17:39:33.963]         base::sink(type = "output", split = FALSE)
[17:39:33.963]         if (TRUE) {
[17:39:33.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.963]         }
[17:39:33.963]         else {
[17:39:33.963]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.963]         }
[17:39:33.963]         base::close(...future.stdout)
[17:39:33.963]         ...future.stdout <- NULL
[17:39:33.963]     }
[17:39:33.963]     ...future.result$conditions <- ...future.conditions
[17:39:33.963]     ...future.result$finished <- base::Sys.time()
[17:39:33.963]     ...future.result
[17:39:33.963] }
[17:39:33.964] plan(): Setting new future strategy stack:
[17:39:33.964] List of future strategies:
[17:39:33.964] 1. sequential:
[17:39:33.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.964]    - tweaked: FALSE
[17:39:33.964]    - call: NULL
[17:39:33.965] plan(): nbrOfWorkers() = 1
[17:39:33.966] plan(): Setting new future strategy stack:
[17:39:33.966] List of future strategies:
[17:39:33.966] 1. sequential:
[17:39:33.966]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.966]    - tweaked: FALSE
[17:39:33.966]    - call: plan(strategy)
[17:39:33.966] plan(): nbrOfWorkers() = 1
[17:39:33.966] SequentialFuture started (and completed)
[17:39:33.967] - Launch lazy future ... done
[17:39:33.967] run() for ‘SequentialFuture’ ... done
[17:39:33.967] getGlobalsAndPackages() ...
[17:39:33.967] Searching for globals...
[17:39:33.968] - globals found: [1] ‘{’
[17:39:33.968] Searching for globals ... DONE
[17:39:33.968] Resolving globals: FALSE
[17:39:33.968] 
[17:39:33.968] 
[17:39:33.968] getGlobalsAndPackages() ... DONE
[17:39:33.969] run() for ‘Future’ ...
[17:39:33.969] - state: ‘created’
[17:39:33.969] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:33.969] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:33.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:33.969]   - Field: ‘label’
[17:39:33.969]   - Field: ‘local’
[17:39:33.970]   - Field: ‘owner’
[17:39:33.970]   - Field: ‘envir’
[17:39:33.970]   - Field: ‘packages’
[17:39:33.970]   - Field: ‘gc’
[17:39:33.970]   - Field: ‘conditions’
[17:39:33.970]   - Field: ‘expr’
[17:39:33.970]   - Field: ‘uuid’
[17:39:33.970]   - Field: ‘seed’
[17:39:33.970]   - Field: ‘version’
[17:39:33.970]   - Field: ‘result’
[17:39:33.970]   - Field: ‘asynchronous’
[17:39:33.971]   - Field: ‘calls’
[17:39:33.971]   - Field: ‘globals’
[17:39:33.971]   - Field: ‘stdout’
[17:39:33.971]   - Field: ‘earlySignal’
[17:39:33.971]   - Field: ‘lazy’
[17:39:33.971]   - Field: ‘state’
[17:39:33.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:33.971] - Launch lazy future ...
[17:39:33.971] Packages needed by the future expression (n = 0): <none>
[17:39:33.971] Packages needed by future strategies (n = 0): <none>
[17:39:33.972] {
[17:39:33.972]     {
[17:39:33.972]         {
[17:39:33.972]             ...future.startTime <- base::Sys.time()
[17:39:33.972]             {
[17:39:33.972]                 {
[17:39:33.972]                   {
[17:39:33.972]                     base::local({
[17:39:33.972]                       has_future <- base::requireNamespace("future", 
[17:39:33.972]                         quietly = TRUE)
[17:39:33.972]                       if (has_future) {
[17:39:33.972]                         ns <- base::getNamespace("future")
[17:39:33.972]                         version <- ns[[".package"]][["version"]]
[17:39:33.972]                         if (is.null(version)) 
[17:39:33.972]                           version <- utils::packageVersion("future")
[17:39:33.972]                       }
[17:39:33.972]                       else {
[17:39:33.972]                         version <- NULL
[17:39:33.972]                       }
[17:39:33.972]                       if (!has_future || version < "1.8.0") {
[17:39:33.972]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:33.972]                           "", base::R.version$version.string), 
[17:39:33.972]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:33.972]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:33.972]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:33.972]                             "release", "version")], collapse = " "), 
[17:39:33.972]                           hostname = base::Sys.info()[["nodename"]])
[17:39:33.972]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:33.972]                           info)
[17:39:33.972]                         info <- base::paste(info, collapse = "; ")
[17:39:33.972]                         if (!has_future) {
[17:39:33.972]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:33.972]                             info)
[17:39:33.972]                         }
[17:39:33.972]                         else {
[17:39:33.972]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:33.972]                             info, version)
[17:39:33.972]                         }
[17:39:33.972]                         base::stop(msg)
[17:39:33.972]                       }
[17:39:33.972]                     })
[17:39:33.972]                   }
[17:39:33.972]                   ...future.strategy.old <- future::plan("list")
[17:39:33.972]                   options(future.plan = NULL)
[17:39:33.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:33.972]                 }
[17:39:33.972]                 ...future.workdir <- getwd()
[17:39:33.972]             }
[17:39:33.972]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:33.972]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:33.972]         }
[17:39:33.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:33.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:33.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:33.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:33.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:33.972]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:33.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:33.972]             base::names(...future.oldOptions))
[17:39:33.972]     }
[17:39:33.972]     if (FALSE) {
[17:39:33.972]     }
[17:39:33.972]     else {
[17:39:33.972]         if (TRUE) {
[17:39:33.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:33.972]                 open = "w")
[17:39:33.972]         }
[17:39:33.972]         else {
[17:39:33.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:33.972]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:33.972]         }
[17:39:33.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:33.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:33.972]             base::sink(type = "output", split = FALSE)
[17:39:33.972]             base::close(...future.stdout)
[17:39:33.972]         }, add = TRUE)
[17:39:33.972]     }
[17:39:33.972]     ...future.frame <- base::sys.nframe()
[17:39:33.972]     ...future.conditions <- base::list()
[17:39:33.972]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:33.972]     if (FALSE) {
[17:39:33.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:33.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:33.972]     }
[17:39:33.972]     ...future.result <- base::tryCatch({
[17:39:33.972]         base::withCallingHandlers({
[17:39:33.972]             ...future.value <- base::withVisible(base::local({
[17:39:33.972]                 4
[17:39:33.972]             }))
[17:39:33.972]             future::FutureResult(value = ...future.value$value, 
[17:39:33.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.972]                   ...future.rng), globalenv = if (FALSE) 
[17:39:33.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:33.972]                     ...future.globalenv.names))
[17:39:33.972]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:33.972]         }, condition = base::local({
[17:39:33.972]             c <- base::c
[17:39:33.972]             inherits <- base::inherits
[17:39:33.972]             invokeRestart <- base::invokeRestart
[17:39:33.972]             length <- base::length
[17:39:33.972]             list <- base::list
[17:39:33.972]             seq.int <- base::seq.int
[17:39:33.972]             signalCondition <- base::signalCondition
[17:39:33.972]             sys.calls <- base::sys.calls
[17:39:33.972]             `[[` <- base::`[[`
[17:39:33.972]             `+` <- base::`+`
[17:39:33.972]             `<<-` <- base::`<<-`
[17:39:33.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:33.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:33.972]                   3L)]
[17:39:33.972]             }
[17:39:33.972]             function(cond) {
[17:39:33.972]                 is_error <- inherits(cond, "error")
[17:39:33.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:33.972]                   NULL)
[17:39:33.972]                 if (is_error) {
[17:39:33.972]                   sessionInformation <- function() {
[17:39:33.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:33.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:33.972]                       search = base::search(), system = base::Sys.info())
[17:39:33.972]                   }
[17:39:33.972]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:33.972]                     cond$call), session = sessionInformation(), 
[17:39:33.972]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:33.972]                   signalCondition(cond)
[17:39:33.972]                 }
[17:39:33.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:33.972]                 "immediateCondition"))) {
[17:39:33.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:33.972]                   ...future.conditions[[length(...future.conditions) + 
[17:39:33.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:33.972]                   if (TRUE && !signal) {
[17:39:33.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.972]                     {
[17:39:33.972]                       inherits <- base::inherits
[17:39:33.972]                       invokeRestart <- base::invokeRestart
[17:39:33.972]                       is.null <- base::is.null
[17:39:33.972]                       muffled <- FALSE
[17:39:33.972]                       if (inherits(cond, "message")) {
[17:39:33.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.972]                         if (muffled) 
[17:39:33.972]                           invokeRestart("muffleMessage")
[17:39:33.972]                       }
[17:39:33.972]                       else if (inherits(cond, "warning")) {
[17:39:33.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.972]                         if (muffled) 
[17:39:33.972]                           invokeRestart("muffleWarning")
[17:39:33.972]                       }
[17:39:33.972]                       else if (inherits(cond, "condition")) {
[17:39:33.972]                         if (!is.null(pattern)) {
[17:39:33.972]                           computeRestarts <- base::computeRestarts
[17:39:33.972]                           grepl <- base::grepl
[17:39:33.972]                           restarts <- computeRestarts(cond)
[17:39:33.972]                           for (restart in restarts) {
[17:39:33.972]                             name <- restart$name
[17:39:33.972]                             if (is.null(name)) 
[17:39:33.972]                               next
[17:39:33.972]                             if (!grepl(pattern, name)) 
[17:39:33.972]                               next
[17:39:33.972]                             invokeRestart(restart)
[17:39:33.972]                             muffled <- TRUE
[17:39:33.972]                             break
[17:39:33.972]                           }
[17:39:33.972]                         }
[17:39:33.972]                       }
[17:39:33.972]                       invisible(muffled)
[17:39:33.972]                     }
[17:39:33.972]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.972]                   }
[17:39:33.972]                 }
[17:39:33.972]                 else {
[17:39:33.972]                   if (TRUE) {
[17:39:33.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:33.972]                     {
[17:39:33.972]                       inherits <- base::inherits
[17:39:33.972]                       invokeRestart <- base::invokeRestart
[17:39:33.972]                       is.null <- base::is.null
[17:39:33.972]                       muffled <- FALSE
[17:39:33.972]                       if (inherits(cond, "message")) {
[17:39:33.972]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:33.972]                         if (muffled) 
[17:39:33.972]                           invokeRestart("muffleMessage")
[17:39:33.972]                       }
[17:39:33.972]                       else if (inherits(cond, "warning")) {
[17:39:33.972]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:33.972]                         if (muffled) 
[17:39:33.972]                           invokeRestart("muffleWarning")
[17:39:33.972]                       }
[17:39:33.972]                       else if (inherits(cond, "condition")) {
[17:39:33.972]                         if (!is.null(pattern)) {
[17:39:33.972]                           computeRestarts <- base::computeRestarts
[17:39:33.972]                           grepl <- base::grepl
[17:39:33.972]                           restarts <- computeRestarts(cond)
[17:39:33.972]                           for (restart in restarts) {
[17:39:33.972]                             name <- restart$name
[17:39:33.972]                             if (is.null(name)) 
[17:39:33.972]                               next
[17:39:33.972]                             if (!grepl(pattern, name)) 
[17:39:33.972]                               next
[17:39:33.972]                             invokeRestart(restart)
[17:39:33.972]                             muffled <- TRUE
[17:39:33.972]                             break
[17:39:33.972]                           }
[17:39:33.972]                         }
[17:39:33.972]                       }
[17:39:33.972]                       invisible(muffled)
[17:39:33.972]                     }
[17:39:33.972]                     muffleCondition(cond, pattern = "^muffle")
[17:39:33.972]                   }
[17:39:33.972]                 }
[17:39:33.972]             }
[17:39:33.972]         }))
[17:39:33.972]     }, error = function(ex) {
[17:39:33.972]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:33.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:33.972]                 ...future.rng), started = ...future.startTime, 
[17:39:33.972]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:33.972]             version = "1.8"), class = "FutureResult")
[17:39:33.972]     }, finally = {
[17:39:33.972]         if (!identical(...future.workdir, getwd())) 
[17:39:33.972]             setwd(...future.workdir)
[17:39:33.972]         {
[17:39:33.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:33.972]                 ...future.oldOptions$nwarnings <- NULL
[17:39:33.972]             }
[17:39:33.972]             base::options(...future.oldOptions)
[17:39:33.972]             if (.Platform$OS.type == "windows") {
[17:39:33.972]                 old_names <- names(...future.oldEnvVars)
[17:39:33.972]                 envs <- base::Sys.getenv()
[17:39:33.972]                 names <- names(envs)
[17:39:33.972]                 common <- intersect(names, old_names)
[17:39:33.972]                 added <- setdiff(names, old_names)
[17:39:33.972]                 removed <- setdiff(old_names, names)
[17:39:33.972]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:33.972]                   envs[common]]
[17:39:33.972]                 NAMES <- toupper(changed)
[17:39:33.972]                 args <- list()
[17:39:33.972]                 for (kk in seq_along(NAMES)) {
[17:39:33.972]                   name <- changed[[kk]]
[17:39:33.972]                   NAME <- NAMES[[kk]]
[17:39:33.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.972]                     next
[17:39:33.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.972]                 }
[17:39:33.972]                 NAMES <- toupper(added)
[17:39:33.972]                 for (kk in seq_along(NAMES)) {
[17:39:33.972]                   name <- added[[kk]]
[17:39:33.972]                   NAME <- NAMES[[kk]]
[17:39:33.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.972]                     next
[17:39:33.972]                   args[[name]] <- ""
[17:39:33.972]                 }
[17:39:33.972]                 NAMES <- toupper(removed)
[17:39:33.972]                 for (kk in seq_along(NAMES)) {
[17:39:33.972]                   name <- removed[[kk]]
[17:39:33.972]                   NAME <- NAMES[[kk]]
[17:39:33.972]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:33.972]                     next
[17:39:33.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:33.972]                 }
[17:39:33.972]                 if (length(args) > 0) 
[17:39:33.972]                   base::do.call(base::Sys.setenv, args = args)
[17:39:33.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:33.972]             }
[17:39:33.972]             else {
[17:39:33.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:33.972]             }
[17:39:33.972]             {
[17:39:33.972]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:33.972]                   0L) {
[17:39:33.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:33.972]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:33.972]                   base::options(opts)
[17:39:33.972]                 }
[17:39:33.972]                 {
[17:39:33.972]                   {
[17:39:33.972]                     NULL
[17:39:33.972]                     RNGkind("Mersenne-Twister")
[17:39:33.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:33.972]                       inherits = FALSE)
[17:39:33.972]                   }
[17:39:33.972]                   options(future.plan = NULL)
[17:39:33.972]                   if (is.na(NA_character_)) 
[17:39:33.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:33.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:33.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:33.972]                     .init = FALSE)
[17:39:33.972]                 }
[17:39:33.972]             }
[17:39:33.972]         }
[17:39:33.972]     })
[17:39:33.972]     if (TRUE) {
[17:39:33.972]         base::sink(type = "output", split = FALSE)
[17:39:33.972]         if (TRUE) {
[17:39:33.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:33.972]         }
[17:39:33.972]         else {
[17:39:33.972]             ...future.result["stdout"] <- base::list(NULL)
[17:39:33.972]         }
[17:39:33.972]         base::close(...future.stdout)
[17:39:33.972]         ...future.stdout <- NULL
[17:39:33.972]     }
[17:39:33.972]     ...future.result$conditions <- ...future.conditions
[17:39:33.972]     ...future.result$finished <- base::Sys.time()
[17:39:33.972]     ...future.result
[17:39:33.972] }
[17:39:33.974] plan(): Setting new future strategy stack:
[17:39:33.974] List of future strategies:
[17:39:33.974] 1. sequential:
[17:39:33.974]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.974]    - tweaked: FALSE
[17:39:33.974]    - call: NULL
[17:39:33.974] plan(): nbrOfWorkers() = 1
[17:39:33.975] plan(): Setting new future strategy stack:
[17:39:33.975] List of future strategies:
[17:39:33.975] 1. sequential:
[17:39:33.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:33.975]    - tweaked: FALSE
[17:39:33.975]    - call: plan(strategy)
[17:39:33.976] plan(): nbrOfWorkers() = 1
[17:39:33.976] SequentialFuture started (and completed)
[17:39:33.976] - Launch lazy future ... done
[17:39:33.978] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adeddc5f98> 
Classes 'listenv', 'environment' <environment: 0x55adefba5cd0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:39:33.982] resolved() for ‘SequentialFuture’ ...
[17:39:33.982] - state: ‘finished’
[17:39:33.982] - run: TRUE
[17:39:33.982] - result: ‘FutureResult’
[17:39:33.982] resolved() for ‘SequentialFuture’ ... done
[17:39:33.982] resolved() for ‘SequentialFuture’ ...
[17:39:33.982] - state: ‘finished’
[17:39:33.983] - run: TRUE
[17:39:33.983] - result: ‘FutureResult’
[17:39:33.983] resolved() for ‘SequentialFuture’ ... done
[17:39:33.983] resolved() for ‘SequentialFuture’ ...
[17:39:33.983] - state: ‘finished’
[17:39:33.983] - run: TRUE
[17:39:33.983] - result: ‘FutureResult’
[17:39:33.983] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:33.985] resolve() on list environment ...
[17:39:33.986]  recursive: 0
[17:39:33.987]  length: 6
[17:39:33.987]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:33.987] signalConditionsASAP(numeric, pos=1) ...
[17:39:33.987] - nx: 6
[17:39:33.987] - relay: TRUE
[17:39:33.987] - stdout: TRUE
[17:39:33.987] - signal: TRUE
[17:39:33.987] - resignal: FALSE
[17:39:33.987] - force: TRUE
[17:39:33.987] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.987] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.988]  - until=2
[17:39:33.988]  - relaying element #2
[17:39:33.988] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.988] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.988] signalConditionsASAP(NULL, pos=1) ... done
[17:39:33.988]  length: 5 (resolved future 1)
[17:39:33.988] resolved() for ‘SequentialFuture’ ...
[17:39:33.988] - state: ‘finished’
[17:39:33.988] - run: TRUE
[17:39:33.988] - result: ‘FutureResult’
[17:39:33.988] resolved() for ‘SequentialFuture’ ... done
[17:39:33.989] Future #2
[17:39:33.989] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:33.989] - nx: 6
[17:39:33.989] - relay: TRUE
[17:39:33.989] - stdout: TRUE
[17:39:33.989] - signal: TRUE
[17:39:33.989] - resignal: FALSE
[17:39:33.989] - force: TRUE
[17:39:33.989] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.989] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:33.990]  - until=2
[17:39:33.990]  - relaying element #2
[17:39:33.990] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.990] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.990] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:33.990]  length: 4 (resolved future 2)
[17:39:33.990] resolved() for ‘SequentialFuture’ ...
[17:39:33.990] - state: ‘finished’
[17:39:33.990] - run: TRUE
[17:39:33.991] - result: ‘FutureResult’
[17:39:33.991] resolved() for ‘SequentialFuture’ ... done
[17:39:33.991] Future #3
[17:39:33.991] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:33.991] - nx: 6
[17:39:33.991] - relay: TRUE
[17:39:33.991] - stdout: TRUE
[17:39:33.991] - signal: TRUE
[17:39:33.991] - resignal: FALSE
[17:39:33.991] - force: TRUE
[17:39:33.991] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.992] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:33.992]  - until=3
[17:39:33.992]  - relaying element #3
[17:39:33.992] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.992] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.992] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:33.992]  length: 3 (resolved future 3)
[17:39:33.992] resolved() for ‘SequentialFuture’ ...
[17:39:33.992] - state: ‘finished’
[17:39:33.993] - run: TRUE
[17:39:33.993] - result: ‘FutureResult’
[17:39:33.993] resolved() for ‘SequentialFuture’ ... done
[17:39:33.993] Future #4
[17:39:33.993] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:33.993] - nx: 6
[17:39:33.993] - relay: TRUE
[17:39:33.993] - stdout: TRUE
[17:39:33.993] - signal: TRUE
[17:39:33.993] - resignal: FALSE
[17:39:33.993] - force: TRUE
[17:39:33.993] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.994] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:33.994]  - until=4
[17:39:33.994]  - relaying element #4
[17:39:33.994] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.994] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.994] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:33.994]  length: 2 (resolved future 4)
[17:39:33.994] signalConditionsASAP(NULL, pos=5) ...
[17:39:33.994] - nx: 6
[17:39:33.994] - relay: TRUE
[17:39:33.995] - stdout: TRUE
[17:39:33.995] - signal: TRUE
[17:39:33.995] - resignal: FALSE
[17:39:33.995] - force: TRUE
[17:39:33.995] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.995] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.995]  - until=6
[17:39:33.995]  - relaying element #6
[17:39:33.995] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.995] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.995] signalConditionsASAP(NULL, pos=5) ... done
[17:39:33.995]  length: 1 (resolved future 5)
[17:39:33.996] signalConditionsASAP(numeric, pos=6) ...
[17:39:33.996] - nx: 6
[17:39:33.996] - relay: TRUE
[17:39:33.996] - stdout: TRUE
[17:39:33.996] - signal: TRUE
[17:39:33.996] - resignal: FALSE
[17:39:33.996] - force: TRUE
[17:39:33.996] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:33.996] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.996]  - until=6
[17:39:33.996] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.997] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.997] signalConditionsASAP(numeric, pos=6) ... done
[17:39:33.997]  length: 0 (resolved future 6)
[17:39:33.997] Relaying remaining futures
[17:39:33.997] signalConditionsASAP(NULL, pos=0) ...
[17:39:33.997] - nx: 6
[17:39:33.997] - relay: TRUE
[17:39:33.997] - stdout: TRUE
[17:39:33.997] - signal: TRUE
[17:39:33.997] - resignal: FALSE
[17:39:33.997] - force: TRUE
[17:39:33.997] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.998] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:33.998] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:33.998] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:33.998] signalConditionsASAP(NULL, pos=0) ... done
[17:39:33.998] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55adee225ee8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:34.000] getGlobalsAndPackages() ...
[17:39:34.000] Searching for globals...
[17:39:34.000] 
[17:39:34.000] Searching for globals ... DONE
[17:39:34.001] - globals: [0] <none>
[17:39:34.001] getGlobalsAndPackages() ... DONE
[17:39:34.001] run() for ‘Future’ ...
[17:39:34.001] - state: ‘created’
[17:39:34.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.001] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.002]   - Field: ‘label’
[17:39:34.002]   - Field: ‘local’
[17:39:34.002]   - Field: ‘owner’
[17:39:34.002]   - Field: ‘envir’
[17:39:34.002]   - Field: ‘packages’
[17:39:34.002]   - Field: ‘gc’
[17:39:34.002]   - Field: ‘conditions’
[17:39:34.002]   - Field: ‘expr’
[17:39:34.002]   - Field: ‘uuid’
[17:39:34.003]   - Field: ‘seed’
[17:39:34.003]   - Field: ‘version’
[17:39:34.003]   - Field: ‘result’
[17:39:34.003]   - Field: ‘asynchronous’
[17:39:34.003]   - Field: ‘calls’
[17:39:34.003]   - Field: ‘globals’
[17:39:34.003]   - Field: ‘stdout’
[17:39:34.005]   - Field: ‘earlySignal’
[17:39:34.005]   - Field: ‘lazy’
[17:39:34.005]   - Field: ‘state’
[17:39:34.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.005] - Launch lazy future ...
[17:39:34.005] Packages needed by the future expression (n = 0): <none>
[17:39:34.005] Packages needed by future strategies (n = 0): <none>
[17:39:34.006] {
[17:39:34.006]     {
[17:39:34.006]         {
[17:39:34.006]             ...future.startTime <- base::Sys.time()
[17:39:34.006]             {
[17:39:34.006]                 {
[17:39:34.006]                   {
[17:39:34.006]                     base::local({
[17:39:34.006]                       has_future <- base::requireNamespace("future", 
[17:39:34.006]                         quietly = TRUE)
[17:39:34.006]                       if (has_future) {
[17:39:34.006]                         ns <- base::getNamespace("future")
[17:39:34.006]                         version <- ns[[".package"]][["version"]]
[17:39:34.006]                         if (is.null(version)) 
[17:39:34.006]                           version <- utils::packageVersion("future")
[17:39:34.006]                       }
[17:39:34.006]                       else {
[17:39:34.006]                         version <- NULL
[17:39:34.006]                       }
[17:39:34.006]                       if (!has_future || version < "1.8.0") {
[17:39:34.006]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.006]                           "", base::R.version$version.string), 
[17:39:34.006]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.006]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.006]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.006]                             "release", "version")], collapse = " "), 
[17:39:34.006]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.006]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.006]                           info)
[17:39:34.006]                         info <- base::paste(info, collapse = "; ")
[17:39:34.006]                         if (!has_future) {
[17:39:34.006]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.006]                             info)
[17:39:34.006]                         }
[17:39:34.006]                         else {
[17:39:34.006]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.006]                             info, version)
[17:39:34.006]                         }
[17:39:34.006]                         base::stop(msg)
[17:39:34.006]                       }
[17:39:34.006]                     })
[17:39:34.006]                   }
[17:39:34.006]                   ...future.strategy.old <- future::plan("list")
[17:39:34.006]                   options(future.plan = NULL)
[17:39:34.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.006]                 }
[17:39:34.006]                 ...future.workdir <- getwd()
[17:39:34.006]             }
[17:39:34.006]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.006]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.006]         }
[17:39:34.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.006]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.006]             base::names(...future.oldOptions))
[17:39:34.006]     }
[17:39:34.006]     if (FALSE) {
[17:39:34.006]     }
[17:39:34.006]     else {
[17:39:34.006]         if (TRUE) {
[17:39:34.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.006]                 open = "w")
[17:39:34.006]         }
[17:39:34.006]         else {
[17:39:34.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.006]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.006]         }
[17:39:34.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.006]             base::sink(type = "output", split = FALSE)
[17:39:34.006]             base::close(...future.stdout)
[17:39:34.006]         }, add = TRUE)
[17:39:34.006]     }
[17:39:34.006]     ...future.frame <- base::sys.nframe()
[17:39:34.006]     ...future.conditions <- base::list()
[17:39:34.006]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.006]     if (FALSE) {
[17:39:34.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.006]     }
[17:39:34.006]     ...future.result <- base::tryCatch({
[17:39:34.006]         base::withCallingHandlers({
[17:39:34.006]             ...future.value <- base::withVisible(base::local(2))
[17:39:34.006]             future::FutureResult(value = ...future.value$value, 
[17:39:34.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.006]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.006]                     ...future.globalenv.names))
[17:39:34.006]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.006]         }, condition = base::local({
[17:39:34.006]             c <- base::c
[17:39:34.006]             inherits <- base::inherits
[17:39:34.006]             invokeRestart <- base::invokeRestart
[17:39:34.006]             length <- base::length
[17:39:34.006]             list <- base::list
[17:39:34.006]             seq.int <- base::seq.int
[17:39:34.006]             signalCondition <- base::signalCondition
[17:39:34.006]             sys.calls <- base::sys.calls
[17:39:34.006]             `[[` <- base::`[[`
[17:39:34.006]             `+` <- base::`+`
[17:39:34.006]             `<<-` <- base::`<<-`
[17:39:34.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.006]                   3L)]
[17:39:34.006]             }
[17:39:34.006]             function(cond) {
[17:39:34.006]                 is_error <- inherits(cond, "error")
[17:39:34.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.006]                   NULL)
[17:39:34.006]                 if (is_error) {
[17:39:34.006]                   sessionInformation <- function() {
[17:39:34.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.006]                       search = base::search(), system = base::Sys.info())
[17:39:34.006]                   }
[17:39:34.006]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.006]                     cond$call), session = sessionInformation(), 
[17:39:34.006]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.006]                   signalCondition(cond)
[17:39:34.006]                 }
[17:39:34.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.006]                 "immediateCondition"))) {
[17:39:34.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.006]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.006]                   if (TRUE && !signal) {
[17:39:34.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.006]                     {
[17:39:34.006]                       inherits <- base::inherits
[17:39:34.006]                       invokeRestart <- base::invokeRestart
[17:39:34.006]                       is.null <- base::is.null
[17:39:34.006]                       muffled <- FALSE
[17:39:34.006]                       if (inherits(cond, "message")) {
[17:39:34.006]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.006]                         if (muffled) 
[17:39:34.006]                           invokeRestart("muffleMessage")
[17:39:34.006]                       }
[17:39:34.006]                       else if (inherits(cond, "warning")) {
[17:39:34.006]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.006]                         if (muffled) 
[17:39:34.006]                           invokeRestart("muffleWarning")
[17:39:34.006]                       }
[17:39:34.006]                       else if (inherits(cond, "condition")) {
[17:39:34.006]                         if (!is.null(pattern)) {
[17:39:34.006]                           computeRestarts <- base::computeRestarts
[17:39:34.006]                           grepl <- base::grepl
[17:39:34.006]                           restarts <- computeRestarts(cond)
[17:39:34.006]                           for (restart in restarts) {
[17:39:34.006]                             name <- restart$name
[17:39:34.006]                             if (is.null(name)) 
[17:39:34.006]                               next
[17:39:34.006]                             if (!grepl(pattern, name)) 
[17:39:34.006]                               next
[17:39:34.006]                             invokeRestart(restart)
[17:39:34.006]                             muffled <- TRUE
[17:39:34.006]                             break
[17:39:34.006]                           }
[17:39:34.006]                         }
[17:39:34.006]                       }
[17:39:34.006]                       invisible(muffled)
[17:39:34.006]                     }
[17:39:34.006]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.006]                   }
[17:39:34.006]                 }
[17:39:34.006]                 else {
[17:39:34.006]                   if (TRUE) {
[17:39:34.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.006]                     {
[17:39:34.006]                       inherits <- base::inherits
[17:39:34.006]                       invokeRestart <- base::invokeRestart
[17:39:34.006]                       is.null <- base::is.null
[17:39:34.006]                       muffled <- FALSE
[17:39:34.006]                       if (inherits(cond, "message")) {
[17:39:34.006]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.006]                         if (muffled) 
[17:39:34.006]                           invokeRestart("muffleMessage")
[17:39:34.006]                       }
[17:39:34.006]                       else if (inherits(cond, "warning")) {
[17:39:34.006]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.006]                         if (muffled) 
[17:39:34.006]                           invokeRestart("muffleWarning")
[17:39:34.006]                       }
[17:39:34.006]                       else if (inherits(cond, "condition")) {
[17:39:34.006]                         if (!is.null(pattern)) {
[17:39:34.006]                           computeRestarts <- base::computeRestarts
[17:39:34.006]                           grepl <- base::grepl
[17:39:34.006]                           restarts <- computeRestarts(cond)
[17:39:34.006]                           for (restart in restarts) {
[17:39:34.006]                             name <- restart$name
[17:39:34.006]                             if (is.null(name)) 
[17:39:34.006]                               next
[17:39:34.006]                             if (!grepl(pattern, name)) 
[17:39:34.006]                               next
[17:39:34.006]                             invokeRestart(restart)
[17:39:34.006]                             muffled <- TRUE
[17:39:34.006]                             break
[17:39:34.006]                           }
[17:39:34.006]                         }
[17:39:34.006]                       }
[17:39:34.006]                       invisible(muffled)
[17:39:34.006]                     }
[17:39:34.006]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.006]                   }
[17:39:34.006]                 }
[17:39:34.006]             }
[17:39:34.006]         }))
[17:39:34.006]     }, error = function(ex) {
[17:39:34.006]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.006]                 ...future.rng), started = ...future.startTime, 
[17:39:34.006]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.006]             version = "1.8"), class = "FutureResult")
[17:39:34.006]     }, finally = {
[17:39:34.006]         if (!identical(...future.workdir, getwd())) 
[17:39:34.006]             setwd(...future.workdir)
[17:39:34.006]         {
[17:39:34.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.006]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.006]             }
[17:39:34.006]             base::options(...future.oldOptions)
[17:39:34.006]             if (.Platform$OS.type == "windows") {
[17:39:34.006]                 old_names <- names(...future.oldEnvVars)
[17:39:34.006]                 envs <- base::Sys.getenv()
[17:39:34.006]                 names <- names(envs)
[17:39:34.006]                 common <- intersect(names, old_names)
[17:39:34.006]                 added <- setdiff(names, old_names)
[17:39:34.006]                 removed <- setdiff(old_names, names)
[17:39:34.006]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.006]                   envs[common]]
[17:39:34.006]                 NAMES <- toupper(changed)
[17:39:34.006]                 args <- list()
[17:39:34.006]                 for (kk in seq_along(NAMES)) {
[17:39:34.006]                   name <- changed[[kk]]
[17:39:34.006]                   NAME <- NAMES[[kk]]
[17:39:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.006]                     next
[17:39:34.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.006]                 }
[17:39:34.006]                 NAMES <- toupper(added)
[17:39:34.006]                 for (kk in seq_along(NAMES)) {
[17:39:34.006]                   name <- added[[kk]]
[17:39:34.006]                   NAME <- NAMES[[kk]]
[17:39:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.006]                     next
[17:39:34.006]                   args[[name]] <- ""
[17:39:34.006]                 }
[17:39:34.006]                 NAMES <- toupper(removed)
[17:39:34.006]                 for (kk in seq_along(NAMES)) {
[17:39:34.006]                   name <- removed[[kk]]
[17:39:34.006]                   NAME <- NAMES[[kk]]
[17:39:34.006]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.006]                     next
[17:39:34.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.006]                 }
[17:39:34.006]                 if (length(args) > 0) 
[17:39:34.006]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.006]             }
[17:39:34.006]             else {
[17:39:34.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.006]             }
[17:39:34.006]             {
[17:39:34.006]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.006]                   0L) {
[17:39:34.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.006]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.006]                   base::options(opts)
[17:39:34.006]                 }
[17:39:34.006]                 {
[17:39:34.006]                   {
[17:39:34.006]                     NULL
[17:39:34.006]                     RNGkind("Mersenne-Twister")
[17:39:34.006]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.006]                       inherits = FALSE)
[17:39:34.006]                   }
[17:39:34.006]                   options(future.plan = NULL)
[17:39:34.006]                   if (is.na(NA_character_)) 
[17:39:34.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.006]                     .init = FALSE)
[17:39:34.006]                 }
[17:39:34.006]             }
[17:39:34.006]         }
[17:39:34.006]     })
[17:39:34.006]     if (TRUE) {
[17:39:34.006]         base::sink(type = "output", split = FALSE)
[17:39:34.006]         if (TRUE) {
[17:39:34.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.006]         }
[17:39:34.006]         else {
[17:39:34.006]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.006]         }
[17:39:34.006]         base::close(...future.stdout)
[17:39:34.006]         ...future.stdout <- NULL
[17:39:34.006]     }
[17:39:34.006]     ...future.result$conditions <- ...future.conditions
[17:39:34.006]     ...future.result$finished <- base::Sys.time()
[17:39:34.006]     ...future.result
[17:39:34.006] }
[17:39:34.008] plan(): Setting new future strategy stack:
[17:39:34.008] List of future strategies:
[17:39:34.008] 1. sequential:
[17:39:34.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.008]    - tweaked: FALSE
[17:39:34.008]    - call: NULL
[17:39:34.008] plan(): nbrOfWorkers() = 1
[17:39:34.009] plan(): Setting new future strategy stack:
[17:39:34.009] List of future strategies:
[17:39:34.009] 1. sequential:
[17:39:34.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.009]    - tweaked: FALSE
[17:39:34.009]    - call: plan(strategy)
[17:39:34.010] plan(): nbrOfWorkers() = 1
[17:39:34.010] SequentialFuture started (and completed)
[17:39:34.010] - Launch lazy future ... done
[17:39:34.010] run() for ‘SequentialFuture’ ... done
[17:39:34.010] getGlobalsAndPackages() ...
[17:39:34.010] Searching for globals...
[17:39:34.011] 
[17:39:34.011] Searching for globals ... DONE
[17:39:34.011] - globals: [0] <none>
[17:39:34.011] getGlobalsAndPackages() ... DONE
[17:39:34.011] run() for ‘Future’ ...
[17:39:34.011] - state: ‘created’
[17:39:34.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.012]   - Field: ‘label’
[17:39:34.012]   - Field: ‘local’
[17:39:34.012]   - Field: ‘owner’
[17:39:34.012]   - Field: ‘envir’
[17:39:34.012]   - Field: ‘packages’
[17:39:34.012]   - Field: ‘gc’
[17:39:34.012]   - Field: ‘conditions’
[17:39:34.013]   - Field: ‘expr’
[17:39:34.013]   - Field: ‘uuid’
[17:39:34.013]   - Field: ‘seed’
[17:39:34.013]   - Field: ‘version’
[17:39:34.013]   - Field: ‘result’
[17:39:34.013]   - Field: ‘asynchronous’
[17:39:34.013]   - Field: ‘calls’
[17:39:34.013]   - Field: ‘globals’
[17:39:34.013]   - Field: ‘stdout’
[17:39:34.013]   - Field: ‘earlySignal’
[17:39:34.013]   - Field: ‘lazy’
[17:39:34.014]   - Field: ‘state’
[17:39:34.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.014] - Launch lazy future ...
[17:39:34.014] Packages needed by the future expression (n = 0): <none>
[17:39:34.014] Packages needed by future strategies (n = 0): <none>
[17:39:34.014] {
[17:39:34.014]     {
[17:39:34.014]         {
[17:39:34.014]             ...future.startTime <- base::Sys.time()
[17:39:34.014]             {
[17:39:34.014]                 {
[17:39:34.014]                   {
[17:39:34.014]                     base::local({
[17:39:34.014]                       has_future <- base::requireNamespace("future", 
[17:39:34.014]                         quietly = TRUE)
[17:39:34.014]                       if (has_future) {
[17:39:34.014]                         ns <- base::getNamespace("future")
[17:39:34.014]                         version <- ns[[".package"]][["version"]]
[17:39:34.014]                         if (is.null(version)) 
[17:39:34.014]                           version <- utils::packageVersion("future")
[17:39:34.014]                       }
[17:39:34.014]                       else {
[17:39:34.014]                         version <- NULL
[17:39:34.014]                       }
[17:39:34.014]                       if (!has_future || version < "1.8.0") {
[17:39:34.014]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.014]                           "", base::R.version$version.string), 
[17:39:34.014]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.014]                             "release", "version")], collapse = " "), 
[17:39:34.014]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.014]                           info)
[17:39:34.014]                         info <- base::paste(info, collapse = "; ")
[17:39:34.014]                         if (!has_future) {
[17:39:34.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.014]                             info)
[17:39:34.014]                         }
[17:39:34.014]                         else {
[17:39:34.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.014]                             info, version)
[17:39:34.014]                         }
[17:39:34.014]                         base::stop(msg)
[17:39:34.014]                       }
[17:39:34.014]                     })
[17:39:34.014]                   }
[17:39:34.014]                   ...future.strategy.old <- future::plan("list")
[17:39:34.014]                   options(future.plan = NULL)
[17:39:34.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.014]                 }
[17:39:34.014]                 ...future.workdir <- getwd()
[17:39:34.014]             }
[17:39:34.014]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.014]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.014]         }
[17:39:34.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.014]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.014]             base::names(...future.oldOptions))
[17:39:34.014]     }
[17:39:34.014]     if (FALSE) {
[17:39:34.014]     }
[17:39:34.014]     else {
[17:39:34.014]         if (TRUE) {
[17:39:34.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.014]                 open = "w")
[17:39:34.014]         }
[17:39:34.014]         else {
[17:39:34.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.014]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.014]         }
[17:39:34.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.014]             base::sink(type = "output", split = FALSE)
[17:39:34.014]             base::close(...future.stdout)
[17:39:34.014]         }, add = TRUE)
[17:39:34.014]     }
[17:39:34.014]     ...future.frame <- base::sys.nframe()
[17:39:34.014]     ...future.conditions <- base::list()
[17:39:34.014]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.014]     if (FALSE) {
[17:39:34.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.014]     }
[17:39:34.014]     ...future.result <- base::tryCatch({
[17:39:34.014]         base::withCallingHandlers({
[17:39:34.014]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:34.014]             future::FutureResult(value = ...future.value$value, 
[17:39:34.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.014]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.014]                     ...future.globalenv.names))
[17:39:34.014]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.014]         }, condition = base::local({
[17:39:34.014]             c <- base::c
[17:39:34.014]             inherits <- base::inherits
[17:39:34.014]             invokeRestart <- base::invokeRestart
[17:39:34.014]             length <- base::length
[17:39:34.014]             list <- base::list
[17:39:34.014]             seq.int <- base::seq.int
[17:39:34.014]             signalCondition <- base::signalCondition
[17:39:34.014]             sys.calls <- base::sys.calls
[17:39:34.014]             `[[` <- base::`[[`
[17:39:34.014]             `+` <- base::`+`
[17:39:34.014]             `<<-` <- base::`<<-`
[17:39:34.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.014]                   3L)]
[17:39:34.014]             }
[17:39:34.014]             function(cond) {
[17:39:34.014]                 is_error <- inherits(cond, "error")
[17:39:34.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.014]                   NULL)
[17:39:34.014]                 if (is_error) {
[17:39:34.014]                   sessionInformation <- function() {
[17:39:34.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.014]                       search = base::search(), system = base::Sys.info())
[17:39:34.014]                   }
[17:39:34.014]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.014]                     cond$call), session = sessionInformation(), 
[17:39:34.014]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.014]                   signalCondition(cond)
[17:39:34.014]                 }
[17:39:34.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.014]                 "immediateCondition"))) {
[17:39:34.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.014]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.014]                   if (TRUE && !signal) {
[17:39:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.014]                     {
[17:39:34.014]                       inherits <- base::inherits
[17:39:34.014]                       invokeRestart <- base::invokeRestart
[17:39:34.014]                       is.null <- base::is.null
[17:39:34.014]                       muffled <- FALSE
[17:39:34.014]                       if (inherits(cond, "message")) {
[17:39:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.014]                         if (muffled) 
[17:39:34.014]                           invokeRestart("muffleMessage")
[17:39:34.014]                       }
[17:39:34.014]                       else if (inherits(cond, "warning")) {
[17:39:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.014]                         if (muffled) 
[17:39:34.014]                           invokeRestart("muffleWarning")
[17:39:34.014]                       }
[17:39:34.014]                       else if (inherits(cond, "condition")) {
[17:39:34.014]                         if (!is.null(pattern)) {
[17:39:34.014]                           computeRestarts <- base::computeRestarts
[17:39:34.014]                           grepl <- base::grepl
[17:39:34.014]                           restarts <- computeRestarts(cond)
[17:39:34.014]                           for (restart in restarts) {
[17:39:34.014]                             name <- restart$name
[17:39:34.014]                             if (is.null(name)) 
[17:39:34.014]                               next
[17:39:34.014]                             if (!grepl(pattern, name)) 
[17:39:34.014]                               next
[17:39:34.014]                             invokeRestart(restart)
[17:39:34.014]                             muffled <- TRUE
[17:39:34.014]                             break
[17:39:34.014]                           }
[17:39:34.014]                         }
[17:39:34.014]                       }
[17:39:34.014]                       invisible(muffled)
[17:39:34.014]                     }
[17:39:34.014]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.014]                   }
[17:39:34.014]                 }
[17:39:34.014]                 else {
[17:39:34.014]                   if (TRUE) {
[17:39:34.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.014]                     {
[17:39:34.014]                       inherits <- base::inherits
[17:39:34.014]                       invokeRestart <- base::invokeRestart
[17:39:34.014]                       is.null <- base::is.null
[17:39:34.014]                       muffled <- FALSE
[17:39:34.014]                       if (inherits(cond, "message")) {
[17:39:34.014]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.014]                         if (muffled) 
[17:39:34.014]                           invokeRestart("muffleMessage")
[17:39:34.014]                       }
[17:39:34.014]                       else if (inherits(cond, "warning")) {
[17:39:34.014]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.014]                         if (muffled) 
[17:39:34.014]                           invokeRestart("muffleWarning")
[17:39:34.014]                       }
[17:39:34.014]                       else if (inherits(cond, "condition")) {
[17:39:34.014]                         if (!is.null(pattern)) {
[17:39:34.014]                           computeRestarts <- base::computeRestarts
[17:39:34.014]                           grepl <- base::grepl
[17:39:34.014]                           restarts <- computeRestarts(cond)
[17:39:34.014]                           for (restart in restarts) {
[17:39:34.014]                             name <- restart$name
[17:39:34.014]                             if (is.null(name)) 
[17:39:34.014]                               next
[17:39:34.014]                             if (!grepl(pattern, name)) 
[17:39:34.014]                               next
[17:39:34.014]                             invokeRestart(restart)
[17:39:34.014]                             muffled <- TRUE
[17:39:34.014]                             break
[17:39:34.014]                           }
[17:39:34.014]                         }
[17:39:34.014]                       }
[17:39:34.014]                       invisible(muffled)
[17:39:34.014]                     }
[17:39:34.014]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.014]                   }
[17:39:34.014]                 }
[17:39:34.014]             }
[17:39:34.014]         }))
[17:39:34.014]     }, error = function(ex) {
[17:39:34.014]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.014]                 ...future.rng), started = ...future.startTime, 
[17:39:34.014]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.014]             version = "1.8"), class = "FutureResult")
[17:39:34.014]     }, finally = {
[17:39:34.014]         if (!identical(...future.workdir, getwd())) 
[17:39:34.014]             setwd(...future.workdir)
[17:39:34.014]         {
[17:39:34.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.014]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.014]             }
[17:39:34.014]             base::options(...future.oldOptions)
[17:39:34.014]             if (.Platform$OS.type == "windows") {
[17:39:34.014]                 old_names <- names(...future.oldEnvVars)
[17:39:34.014]                 envs <- base::Sys.getenv()
[17:39:34.014]                 names <- names(envs)
[17:39:34.014]                 common <- intersect(names, old_names)
[17:39:34.014]                 added <- setdiff(names, old_names)
[17:39:34.014]                 removed <- setdiff(old_names, names)
[17:39:34.014]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.014]                   envs[common]]
[17:39:34.014]                 NAMES <- toupper(changed)
[17:39:34.014]                 args <- list()
[17:39:34.014]                 for (kk in seq_along(NAMES)) {
[17:39:34.014]                   name <- changed[[kk]]
[17:39:34.014]                   NAME <- NAMES[[kk]]
[17:39:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.014]                     next
[17:39:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.014]                 }
[17:39:34.014]                 NAMES <- toupper(added)
[17:39:34.014]                 for (kk in seq_along(NAMES)) {
[17:39:34.014]                   name <- added[[kk]]
[17:39:34.014]                   NAME <- NAMES[[kk]]
[17:39:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.014]                     next
[17:39:34.014]                   args[[name]] <- ""
[17:39:34.014]                 }
[17:39:34.014]                 NAMES <- toupper(removed)
[17:39:34.014]                 for (kk in seq_along(NAMES)) {
[17:39:34.014]                   name <- removed[[kk]]
[17:39:34.014]                   NAME <- NAMES[[kk]]
[17:39:34.014]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.014]                     next
[17:39:34.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.014]                 }
[17:39:34.014]                 if (length(args) > 0) 
[17:39:34.014]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.014]             }
[17:39:34.014]             else {
[17:39:34.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.014]             }
[17:39:34.014]             {
[17:39:34.014]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.014]                   0L) {
[17:39:34.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.014]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.014]                   base::options(opts)
[17:39:34.014]                 }
[17:39:34.014]                 {
[17:39:34.014]                   {
[17:39:34.014]                     NULL
[17:39:34.014]                     RNGkind("Mersenne-Twister")
[17:39:34.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.014]                       inherits = FALSE)
[17:39:34.014]                   }
[17:39:34.014]                   options(future.plan = NULL)
[17:39:34.014]                   if (is.na(NA_character_)) 
[17:39:34.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.014]                     .init = FALSE)
[17:39:34.014]                 }
[17:39:34.014]             }
[17:39:34.014]         }
[17:39:34.014]     })
[17:39:34.014]     if (TRUE) {
[17:39:34.014]         base::sink(type = "output", split = FALSE)
[17:39:34.014]         if (TRUE) {
[17:39:34.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.014]         }
[17:39:34.014]         else {
[17:39:34.014]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.014]         }
[17:39:34.014]         base::close(...future.stdout)
[17:39:34.014]         ...future.stdout <- NULL
[17:39:34.014]     }
[17:39:34.014]     ...future.result$conditions <- ...future.conditions
[17:39:34.014]     ...future.result$finished <- base::Sys.time()
[17:39:34.014]     ...future.result
[17:39:34.014] }
[17:39:34.016] plan(): Setting new future strategy stack:
[17:39:34.016] List of future strategies:
[17:39:34.016] 1. sequential:
[17:39:34.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.016]    - tweaked: FALSE
[17:39:34.016]    - call: NULL
[17:39:34.017] plan(): nbrOfWorkers() = 1
[17:39:34.017] plan(): Setting new future strategy stack:
[17:39:34.018] List of future strategies:
[17:39:34.018] 1. sequential:
[17:39:34.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.018]    - tweaked: FALSE
[17:39:34.018]    - call: plan(strategy)
[17:39:34.018] plan(): nbrOfWorkers() = 1
[17:39:34.018] SequentialFuture started (and completed)
[17:39:34.018] - Launch lazy future ... done
[17:39:34.018] run() for ‘SequentialFuture’ ... done
[17:39:34.019] getGlobalsAndPackages() ...
[17:39:34.019] Searching for globals...
[17:39:34.019] - globals found: [1] ‘{’
[17:39:34.019] Searching for globals ... DONE
[17:39:34.020] Resolving globals: FALSE
[17:39:34.020] 
[17:39:34.020] 
[17:39:34.020] getGlobalsAndPackages() ... DONE
[17:39:34.020] run() for ‘Future’ ...
[17:39:34.020] - state: ‘created’
[17:39:34.020] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.021]   - Field: ‘label’
[17:39:34.021]   - Field: ‘local’
[17:39:34.021]   - Field: ‘owner’
[17:39:34.021]   - Field: ‘envir’
[17:39:34.021]   - Field: ‘packages’
[17:39:34.021]   - Field: ‘gc’
[17:39:34.022]   - Field: ‘conditions’
[17:39:34.022]   - Field: ‘expr’
[17:39:34.022]   - Field: ‘uuid’
[17:39:34.022]   - Field: ‘seed’
[17:39:34.022]   - Field: ‘version’
[17:39:34.022]   - Field: ‘result’
[17:39:34.022]   - Field: ‘asynchronous’
[17:39:34.022]   - Field: ‘calls’
[17:39:34.022]   - Field: ‘globals’
[17:39:34.022]   - Field: ‘stdout’
[17:39:34.022]   - Field: ‘earlySignal’
[17:39:34.023]   - Field: ‘lazy’
[17:39:34.023]   - Field: ‘state’
[17:39:34.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.023] - Launch lazy future ...
[17:39:34.023] Packages needed by the future expression (n = 0): <none>
[17:39:34.023] Packages needed by future strategies (n = 0): <none>
[17:39:34.023] {
[17:39:34.023]     {
[17:39:34.023]         {
[17:39:34.023]             ...future.startTime <- base::Sys.time()
[17:39:34.023]             {
[17:39:34.023]                 {
[17:39:34.023]                   {
[17:39:34.023]                     base::local({
[17:39:34.023]                       has_future <- base::requireNamespace("future", 
[17:39:34.023]                         quietly = TRUE)
[17:39:34.023]                       if (has_future) {
[17:39:34.023]                         ns <- base::getNamespace("future")
[17:39:34.023]                         version <- ns[[".package"]][["version"]]
[17:39:34.023]                         if (is.null(version)) 
[17:39:34.023]                           version <- utils::packageVersion("future")
[17:39:34.023]                       }
[17:39:34.023]                       else {
[17:39:34.023]                         version <- NULL
[17:39:34.023]                       }
[17:39:34.023]                       if (!has_future || version < "1.8.0") {
[17:39:34.023]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.023]                           "", base::R.version$version.string), 
[17:39:34.023]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.023]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.023]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.023]                             "release", "version")], collapse = " "), 
[17:39:34.023]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.023]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.023]                           info)
[17:39:34.023]                         info <- base::paste(info, collapse = "; ")
[17:39:34.023]                         if (!has_future) {
[17:39:34.023]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.023]                             info)
[17:39:34.023]                         }
[17:39:34.023]                         else {
[17:39:34.023]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.023]                             info, version)
[17:39:34.023]                         }
[17:39:34.023]                         base::stop(msg)
[17:39:34.023]                       }
[17:39:34.023]                     })
[17:39:34.023]                   }
[17:39:34.023]                   ...future.strategy.old <- future::plan("list")
[17:39:34.023]                   options(future.plan = NULL)
[17:39:34.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.023]                 }
[17:39:34.023]                 ...future.workdir <- getwd()
[17:39:34.023]             }
[17:39:34.023]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.023]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.023]         }
[17:39:34.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.023]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.023]             base::names(...future.oldOptions))
[17:39:34.023]     }
[17:39:34.023]     if (FALSE) {
[17:39:34.023]     }
[17:39:34.023]     else {
[17:39:34.023]         if (TRUE) {
[17:39:34.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.023]                 open = "w")
[17:39:34.023]         }
[17:39:34.023]         else {
[17:39:34.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.023]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.023]         }
[17:39:34.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.023]             base::sink(type = "output", split = FALSE)
[17:39:34.023]             base::close(...future.stdout)
[17:39:34.023]         }, add = TRUE)
[17:39:34.023]     }
[17:39:34.023]     ...future.frame <- base::sys.nframe()
[17:39:34.023]     ...future.conditions <- base::list()
[17:39:34.023]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.023]     if (FALSE) {
[17:39:34.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.023]     }
[17:39:34.023]     ...future.result <- base::tryCatch({
[17:39:34.023]         base::withCallingHandlers({
[17:39:34.023]             ...future.value <- base::withVisible(base::local({
[17:39:34.023]                 4
[17:39:34.023]             }))
[17:39:34.023]             future::FutureResult(value = ...future.value$value, 
[17:39:34.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.023]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.023]                     ...future.globalenv.names))
[17:39:34.023]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.023]         }, condition = base::local({
[17:39:34.023]             c <- base::c
[17:39:34.023]             inherits <- base::inherits
[17:39:34.023]             invokeRestart <- base::invokeRestart
[17:39:34.023]             length <- base::length
[17:39:34.023]             list <- base::list
[17:39:34.023]             seq.int <- base::seq.int
[17:39:34.023]             signalCondition <- base::signalCondition
[17:39:34.023]             sys.calls <- base::sys.calls
[17:39:34.023]             `[[` <- base::`[[`
[17:39:34.023]             `+` <- base::`+`
[17:39:34.023]             `<<-` <- base::`<<-`
[17:39:34.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.023]                   3L)]
[17:39:34.023]             }
[17:39:34.023]             function(cond) {
[17:39:34.023]                 is_error <- inherits(cond, "error")
[17:39:34.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.023]                   NULL)
[17:39:34.023]                 if (is_error) {
[17:39:34.023]                   sessionInformation <- function() {
[17:39:34.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.023]                       search = base::search(), system = base::Sys.info())
[17:39:34.023]                   }
[17:39:34.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.023]                     cond$call), session = sessionInformation(), 
[17:39:34.023]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.023]                   signalCondition(cond)
[17:39:34.023]                 }
[17:39:34.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.023]                 "immediateCondition"))) {
[17:39:34.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.023]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.023]                   if (TRUE && !signal) {
[17:39:34.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.023]                     {
[17:39:34.023]                       inherits <- base::inherits
[17:39:34.023]                       invokeRestart <- base::invokeRestart
[17:39:34.023]                       is.null <- base::is.null
[17:39:34.023]                       muffled <- FALSE
[17:39:34.023]                       if (inherits(cond, "message")) {
[17:39:34.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.023]                         if (muffled) 
[17:39:34.023]                           invokeRestart("muffleMessage")
[17:39:34.023]                       }
[17:39:34.023]                       else if (inherits(cond, "warning")) {
[17:39:34.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.023]                         if (muffled) 
[17:39:34.023]                           invokeRestart("muffleWarning")
[17:39:34.023]                       }
[17:39:34.023]                       else if (inherits(cond, "condition")) {
[17:39:34.023]                         if (!is.null(pattern)) {
[17:39:34.023]                           computeRestarts <- base::computeRestarts
[17:39:34.023]                           grepl <- base::grepl
[17:39:34.023]                           restarts <- computeRestarts(cond)
[17:39:34.023]                           for (restart in restarts) {
[17:39:34.023]                             name <- restart$name
[17:39:34.023]                             if (is.null(name)) 
[17:39:34.023]                               next
[17:39:34.023]                             if (!grepl(pattern, name)) 
[17:39:34.023]                               next
[17:39:34.023]                             invokeRestart(restart)
[17:39:34.023]                             muffled <- TRUE
[17:39:34.023]                             break
[17:39:34.023]                           }
[17:39:34.023]                         }
[17:39:34.023]                       }
[17:39:34.023]                       invisible(muffled)
[17:39:34.023]                     }
[17:39:34.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.023]                   }
[17:39:34.023]                 }
[17:39:34.023]                 else {
[17:39:34.023]                   if (TRUE) {
[17:39:34.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.023]                     {
[17:39:34.023]                       inherits <- base::inherits
[17:39:34.023]                       invokeRestart <- base::invokeRestart
[17:39:34.023]                       is.null <- base::is.null
[17:39:34.023]                       muffled <- FALSE
[17:39:34.023]                       if (inherits(cond, "message")) {
[17:39:34.023]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.023]                         if (muffled) 
[17:39:34.023]                           invokeRestart("muffleMessage")
[17:39:34.023]                       }
[17:39:34.023]                       else if (inherits(cond, "warning")) {
[17:39:34.023]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.023]                         if (muffled) 
[17:39:34.023]                           invokeRestart("muffleWarning")
[17:39:34.023]                       }
[17:39:34.023]                       else if (inherits(cond, "condition")) {
[17:39:34.023]                         if (!is.null(pattern)) {
[17:39:34.023]                           computeRestarts <- base::computeRestarts
[17:39:34.023]                           grepl <- base::grepl
[17:39:34.023]                           restarts <- computeRestarts(cond)
[17:39:34.023]                           for (restart in restarts) {
[17:39:34.023]                             name <- restart$name
[17:39:34.023]                             if (is.null(name)) 
[17:39:34.023]                               next
[17:39:34.023]                             if (!grepl(pattern, name)) 
[17:39:34.023]                               next
[17:39:34.023]                             invokeRestart(restart)
[17:39:34.023]                             muffled <- TRUE
[17:39:34.023]                             break
[17:39:34.023]                           }
[17:39:34.023]                         }
[17:39:34.023]                       }
[17:39:34.023]                       invisible(muffled)
[17:39:34.023]                     }
[17:39:34.023]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.023]                   }
[17:39:34.023]                 }
[17:39:34.023]             }
[17:39:34.023]         }))
[17:39:34.023]     }, error = function(ex) {
[17:39:34.023]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.023]                 ...future.rng), started = ...future.startTime, 
[17:39:34.023]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.023]             version = "1.8"), class = "FutureResult")
[17:39:34.023]     }, finally = {
[17:39:34.023]         if (!identical(...future.workdir, getwd())) 
[17:39:34.023]             setwd(...future.workdir)
[17:39:34.023]         {
[17:39:34.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.023]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.023]             }
[17:39:34.023]             base::options(...future.oldOptions)
[17:39:34.023]             if (.Platform$OS.type == "windows") {
[17:39:34.023]                 old_names <- names(...future.oldEnvVars)
[17:39:34.023]                 envs <- base::Sys.getenv()
[17:39:34.023]                 names <- names(envs)
[17:39:34.023]                 common <- intersect(names, old_names)
[17:39:34.023]                 added <- setdiff(names, old_names)
[17:39:34.023]                 removed <- setdiff(old_names, names)
[17:39:34.023]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.023]                   envs[common]]
[17:39:34.023]                 NAMES <- toupper(changed)
[17:39:34.023]                 args <- list()
[17:39:34.023]                 for (kk in seq_along(NAMES)) {
[17:39:34.023]                   name <- changed[[kk]]
[17:39:34.023]                   NAME <- NAMES[[kk]]
[17:39:34.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.023]                     next
[17:39:34.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.023]                 }
[17:39:34.023]                 NAMES <- toupper(added)
[17:39:34.023]                 for (kk in seq_along(NAMES)) {
[17:39:34.023]                   name <- added[[kk]]
[17:39:34.023]                   NAME <- NAMES[[kk]]
[17:39:34.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.023]                     next
[17:39:34.023]                   args[[name]] <- ""
[17:39:34.023]                 }
[17:39:34.023]                 NAMES <- toupper(removed)
[17:39:34.023]                 for (kk in seq_along(NAMES)) {
[17:39:34.023]                   name <- removed[[kk]]
[17:39:34.023]                   NAME <- NAMES[[kk]]
[17:39:34.023]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.023]                     next
[17:39:34.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.023]                 }
[17:39:34.023]                 if (length(args) > 0) 
[17:39:34.023]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.023]             }
[17:39:34.023]             else {
[17:39:34.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.023]             }
[17:39:34.023]             {
[17:39:34.023]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.023]                   0L) {
[17:39:34.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.023]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.023]                   base::options(opts)
[17:39:34.023]                 }
[17:39:34.023]                 {
[17:39:34.023]                   {
[17:39:34.023]                     NULL
[17:39:34.023]                     RNGkind("Mersenne-Twister")
[17:39:34.023]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.023]                       inherits = FALSE)
[17:39:34.023]                   }
[17:39:34.023]                   options(future.plan = NULL)
[17:39:34.023]                   if (is.na(NA_character_)) 
[17:39:34.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.023]                     .init = FALSE)
[17:39:34.023]                 }
[17:39:34.023]             }
[17:39:34.023]         }
[17:39:34.023]     })
[17:39:34.023]     if (TRUE) {
[17:39:34.023]         base::sink(type = "output", split = FALSE)
[17:39:34.023]         if (TRUE) {
[17:39:34.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.023]         }
[17:39:34.023]         else {
[17:39:34.023]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.023]         }
[17:39:34.023]         base::close(...future.stdout)
[17:39:34.023]         ...future.stdout <- NULL
[17:39:34.023]     }
[17:39:34.023]     ...future.result$conditions <- ...future.conditions
[17:39:34.023]     ...future.result$finished <- base::Sys.time()
[17:39:34.023]     ...future.result
[17:39:34.023] }
[17:39:34.025] plan(): Setting new future strategy stack:
[17:39:34.025] List of future strategies:
[17:39:34.025] 1. sequential:
[17:39:34.025]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.025]    - tweaked: FALSE
[17:39:34.025]    - call: NULL
[17:39:34.026] plan(): nbrOfWorkers() = 1
[17:39:34.027] plan(): Setting new future strategy stack:
[17:39:34.027] List of future strategies:
[17:39:34.027] 1. sequential:
[17:39:34.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.027]    - tweaked: FALSE
[17:39:34.027]    - call: plan(strategy)
[17:39:34.027] plan(): nbrOfWorkers() = 1
[17:39:34.027] SequentialFuture started (and completed)
[17:39:34.027] - Launch lazy future ... done
[17:39:34.027] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf0555000> 
Classes 'listenv', 'environment' <environment: 0x55adf02495b8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:34.031] resolved() for ‘SequentialFuture’ ...
[17:39:34.031] - state: ‘finished’
[17:39:34.032] - run: TRUE
[17:39:34.032] - result: ‘FutureResult’
[17:39:34.032] resolved() for ‘SequentialFuture’ ... done
[17:39:34.032] resolved() for ‘SequentialFuture’ ...
[17:39:34.032] - state: ‘finished’
[17:39:34.032] - run: TRUE
[17:39:34.032] - result: ‘FutureResult’
[17:39:34.032] resolved() for ‘SequentialFuture’ ... done
[17:39:34.032] resolved() for ‘SequentialFuture’ ...
[17:39:34.032] - state: ‘finished’
[17:39:34.032] - run: TRUE
[17:39:34.033] - result: ‘FutureResult’
[17:39:34.033] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:34.035] resolve() on list environment ...
[17:39:34.035]  recursive: 0
[17:39:34.038]  length: 6
[17:39:34.038]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:34.039] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.039] - nx: 6
[17:39:34.039] - relay: TRUE
[17:39:34.039] - stdout: TRUE
[17:39:34.039] - signal: TRUE
[17:39:34.039] - resignal: FALSE
[17:39:34.039] - force: TRUE
[17:39:34.039] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.039] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.039]  - until=2
[17:39:34.039]  - relaying element #2
[17:39:34.040] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.040] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.040] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.040]  length: 5 (resolved future 1)
[17:39:34.040] resolved() for ‘SequentialFuture’ ...
[17:39:34.040] - state: ‘finished’
[17:39:34.040] - run: TRUE
[17:39:34.040] - result: ‘FutureResult’
[17:39:34.040] resolved() for ‘SequentialFuture’ ... done
[17:39:34.040] Future #2
[17:39:34.041] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:34.041] - nx: 6
[17:39:34.041] - relay: TRUE
[17:39:34.041] - stdout: TRUE
[17:39:34.041] - signal: TRUE
[17:39:34.041] - resignal: FALSE
[17:39:34.041] - force: TRUE
[17:39:34.041] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.041] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.041]  - until=2
[17:39:34.041]  - relaying element #2
[17:39:34.042] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.042] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.042] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:34.042]  length: 4 (resolved future 2)
[17:39:34.042] resolved() for ‘SequentialFuture’ ...
[17:39:34.042] - state: ‘finished’
[17:39:34.042] - run: TRUE
[17:39:34.042] - result: ‘FutureResult’
[17:39:34.042] resolved() for ‘SequentialFuture’ ... done
[17:39:34.043] Future #3
[17:39:34.043] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:34.043] - nx: 6
[17:39:34.043] - relay: TRUE
[17:39:34.043] - stdout: TRUE
[17:39:34.043] - signal: TRUE
[17:39:34.043] - resignal: FALSE
[17:39:34.043] - force: TRUE
[17:39:34.043] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.043] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.043]  - until=3
[17:39:34.044]  - relaying element #3
[17:39:34.044] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.044] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:34.044]  length: 3 (resolved future 3)
[17:39:34.044] resolved() for ‘SequentialFuture’ ...
[17:39:34.044] - state: ‘finished’
[17:39:34.044] - run: TRUE
[17:39:34.044] - result: ‘FutureResult’
[17:39:34.044] resolved() for ‘SequentialFuture’ ... done
[17:39:34.045] Future #4
[17:39:34.045] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:34.045] - nx: 6
[17:39:34.045] - relay: TRUE
[17:39:34.045] - stdout: TRUE
[17:39:34.045] - signal: TRUE
[17:39:34.045] - resignal: FALSE
[17:39:34.045] - force: TRUE
[17:39:34.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.045]  - until=4
[17:39:34.046]  - relaying element #4
[17:39:34.046] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.046] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.046] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:34.046]  length: 2 (resolved future 4)
[17:39:34.046] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.046] - nx: 6
[17:39:34.046] - relay: TRUE
[17:39:34.046] - stdout: TRUE
[17:39:34.046] - signal: TRUE
[17:39:34.047] - resignal: FALSE
[17:39:34.047] - force: TRUE
[17:39:34.047] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.047] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.047]  - until=6
[17:39:34.047]  - relaying element #6
[17:39:34.047] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.047] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.047] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.047]  length: 1 (resolved future 5)
[17:39:34.047] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.047] - nx: 6
[17:39:34.048] - relay: TRUE
[17:39:34.048] - stdout: TRUE
[17:39:34.048] - signal: TRUE
[17:39:34.048] - resignal: FALSE
[17:39:34.048] - force: TRUE
[17:39:34.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.048]  - until=6
[17:39:34.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.049] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.049]  length: 0 (resolved future 6)
[17:39:34.049] Relaying remaining futures
[17:39:34.049] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.049] - nx: 6
[17:39:34.049] - relay: TRUE
[17:39:34.049] - stdout: TRUE
[17:39:34.049] - signal: TRUE
[17:39:34.049] - resignal: FALSE
[17:39:34.049] - force: TRUE
[17:39:34.049] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.049] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:34.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.050] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.050] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.050] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55adf0924670> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:34.052] getGlobalsAndPackages() ...
[17:39:34.052] Searching for globals...
[17:39:34.053] 
[17:39:34.053] Searching for globals ... DONE
[17:39:34.053] - globals: [0] <none>
[17:39:34.053] getGlobalsAndPackages() ... DONE
[17:39:34.053] run() for ‘Future’ ...
[17:39:34.053] - state: ‘created’
[17:39:34.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.054] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.054]   - Field: ‘label’
[17:39:34.054]   - Field: ‘local’
[17:39:34.054]   - Field: ‘owner’
[17:39:34.054]   - Field: ‘envir’
[17:39:34.054]   - Field: ‘packages’
[17:39:34.054]   - Field: ‘gc’
[17:39:34.054]   - Field: ‘conditions’
[17:39:34.055]   - Field: ‘expr’
[17:39:34.055]   - Field: ‘uuid’
[17:39:34.055]   - Field: ‘seed’
[17:39:34.055]   - Field: ‘version’
[17:39:34.055]   - Field: ‘result’
[17:39:34.055]   - Field: ‘asynchronous’
[17:39:34.055]   - Field: ‘calls’
[17:39:34.055]   - Field: ‘globals’
[17:39:34.055]   - Field: ‘stdout’
[17:39:34.055]   - Field: ‘earlySignal’
[17:39:34.055]   - Field: ‘lazy’
[17:39:34.055]   - Field: ‘state’
[17:39:34.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.056] - Launch lazy future ...
[17:39:34.056] Packages needed by the future expression (n = 0): <none>
[17:39:34.056] Packages needed by future strategies (n = 0): <none>
[17:39:34.056] {
[17:39:34.056]     {
[17:39:34.056]         {
[17:39:34.056]             ...future.startTime <- base::Sys.time()
[17:39:34.056]             {
[17:39:34.056]                 {
[17:39:34.056]                   {
[17:39:34.056]                     base::local({
[17:39:34.056]                       has_future <- base::requireNamespace("future", 
[17:39:34.056]                         quietly = TRUE)
[17:39:34.056]                       if (has_future) {
[17:39:34.056]                         ns <- base::getNamespace("future")
[17:39:34.056]                         version <- ns[[".package"]][["version"]]
[17:39:34.056]                         if (is.null(version)) 
[17:39:34.056]                           version <- utils::packageVersion("future")
[17:39:34.056]                       }
[17:39:34.056]                       else {
[17:39:34.056]                         version <- NULL
[17:39:34.056]                       }
[17:39:34.056]                       if (!has_future || version < "1.8.0") {
[17:39:34.056]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.056]                           "", base::R.version$version.string), 
[17:39:34.056]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.056]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.056]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.056]                             "release", "version")], collapse = " "), 
[17:39:34.056]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.056]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.056]                           info)
[17:39:34.056]                         info <- base::paste(info, collapse = "; ")
[17:39:34.056]                         if (!has_future) {
[17:39:34.056]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.056]                             info)
[17:39:34.056]                         }
[17:39:34.056]                         else {
[17:39:34.056]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.056]                             info, version)
[17:39:34.056]                         }
[17:39:34.056]                         base::stop(msg)
[17:39:34.056]                       }
[17:39:34.056]                     })
[17:39:34.056]                   }
[17:39:34.056]                   ...future.strategy.old <- future::plan("list")
[17:39:34.056]                   options(future.plan = NULL)
[17:39:34.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.056]                 }
[17:39:34.056]                 ...future.workdir <- getwd()
[17:39:34.056]             }
[17:39:34.056]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.056]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.056]         }
[17:39:34.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.056]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.056]             base::names(...future.oldOptions))
[17:39:34.056]     }
[17:39:34.056]     if (FALSE) {
[17:39:34.056]     }
[17:39:34.056]     else {
[17:39:34.056]         if (TRUE) {
[17:39:34.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.056]                 open = "w")
[17:39:34.056]         }
[17:39:34.056]         else {
[17:39:34.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.056]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.056]         }
[17:39:34.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.056]             base::sink(type = "output", split = FALSE)
[17:39:34.056]             base::close(...future.stdout)
[17:39:34.056]         }, add = TRUE)
[17:39:34.056]     }
[17:39:34.056]     ...future.frame <- base::sys.nframe()
[17:39:34.056]     ...future.conditions <- base::list()
[17:39:34.056]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.056]     if (FALSE) {
[17:39:34.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.056]     }
[17:39:34.056]     ...future.result <- base::tryCatch({
[17:39:34.056]         base::withCallingHandlers({
[17:39:34.056]             ...future.value <- base::withVisible(base::local(2))
[17:39:34.056]             future::FutureResult(value = ...future.value$value, 
[17:39:34.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.056]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.056]                     ...future.globalenv.names))
[17:39:34.056]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.056]         }, condition = base::local({
[17:39:34.056]             c <- base::c
[17:39:34.056]             inherits <- base::inherits
[17:39:34.056]             invokeRestart <- base::invokeRestart
[17:39:34.056]             length <- base::length
[17:39:34.056]             list <- base::list
[17:39:34.056]             seq.int <- base::seq.int
[17:39:34.056]             signalCondition <- base::signalCondition
[17:39:34.056]             sys.calls <- base::sys.calls
[17:39:34.056]             `[[` <- base::`[[`
[17:39:34.056]             `+` <- base::`+`
[17:39:34.056]             `<<-` <- base::`<<-`
[17:39:34.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.056]                   3L)]
[17:39:34.056]             }
[17:39:34.056]             function(cond) {
[17:39:34.056]                 is_error <- inherits(cond, "error")
[17:39:34.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.056]                   NULL)
[17:39:34.056]                 if (is_error) {
[17:39:34.056]                   sessionInformation <- function() {
[17:39:34.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.056]                       search = base::search(), system = base::Sys.info())
[17:39:34.056]                   }
[17:39:34.056]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.056]                     cond$call), session = sessionInformation(), 
[17:39:34.056]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.056]                   signalCondition(cond)
[17:39:34.056]                 }
[17:39:34.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.056]                 "immediateCondition"))) {
[17:39:34.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.056]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.056]                   if (TRUE && !signal) {
[17:39:34.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.056]                     {
[17:39:34.056]                       inherits <- base::inherits
[17:39:34.056]                       invokeRestart <- base::invokeRestart
[17:39:34.056]                       is.null <- base::is.null
[17:39:34.056]                       muffled <- FALSE
[17:39:34.056]                       if (inherits(cond, "message")) {
[17:39:34.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.056]                         if (muffled) 
[17:39:34.056]                           invokeRestart("muffleMessage")
[17:39:34.056]                       }
[17:39:34.056]                       else if (inherits(cond, "warning")) {
[17:39:34.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.056]                         if (muffled) 
[17:39:34.056]                           invokeRestart("muffleWarning")
[17:39:34.056]                       }
[17:39:34.056]                       else if (inherits(cond, "condition")) {
[17:39:34.056]                         if (!is.null(pattern)) {
[17:39:34.056]                           computeRestarts <- base::computeRestarts
[17:39:34.056]                           grepl <- base::grepl
[17:39:34.056]                           restarts <- computeRestarts(cond)
[17:39:34.056]                           for (restart in restarts) {
[17:39:34.056]                             name <- restart$name
[17:39:34.056]                             if (is.null(name)) 
[17:39:34.056]                               next
[17:39:34.056]                             if (!grepl(pattern, name)) 
[17:39:34.056]                               next
[17:39:34.056]                             invokeRestart(restart)
[17:39:34.056]                             muffled <- TRUE
[17:39:34.056]                             break
[17:39:34.056]                           }
[17:39:34.056]                         }
[17:39:34.056]                       }
[17:39:34.056]                       invisible(muffled)
[17:39:34.056]                     }
[17:39:34.056]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.056]                   }
[17:39:34.056]                 }
[17:39:34.056]                 else {
[17:39:34.056]                   if (TRUE) {
[17:39:34.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.056]                     {
[17:39:34.056]                       inherits <- base::inherits
[17:39:34.056]                       invokeRestart <- base::invokeRestart
[17:39:34.056]                       is.null <- base::is.null
[17:39:34.056]                       muffled <- FALSE
[17:39:34.056]                       if (inherits(cond, "message")) {
[17:39:34.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.056]                         if (muffled) 
[17:39:34.056]                           invokeRestart("muffleMessage")
[17:39:34.056]                       }
[17:39:34.056]                       else if (inherits(cond, "warning")) {
[17:39:34.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.056]                         if (muffled) 
[17:39:34.056]                           invokeRestart("muffleWarning")
[17:39:34.056]                       }
[17:39:34.056]                       else if (inherits(cond, "condition")) {
[17:39:34.056]                         if (!is.null(pattern)) {
[17:39:34.056]                           computeRestarts <- base::computeRestarts
[17:39:34.056]                           grepl <- base::grepl
[17:39:34.056]                           restarts <- computeRestarts(cond)
[17:39:34.056]                           for (restart in restarts) {
[17:39:34.056]                             name <- restart$name
[17:39:34.056]                             if (is.null(name)) 
[17:39:34.056]                               next
[17:39:34.056]                             if (!grepl(pattern, name)) 
[17:39:34.056]                               next
[17:39:34.056]                             invokeRestart(restart)
[17:39:34.056]                             muffled <- TRUE
[17:39:34.056]                             break
[17:39:34.056]                           }
[17:39:34.056]                         }
[17:39:34.056]                       }
[17:39:34.056]                       invisible(muffled)
[17:39:34.056]                     }
[17:39:34.056]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.056]                   }
[17:39:34.056]                 }
[17:39:34.056]             }
[17:39:34.056]         }))
[17:39:34.056]     }, error = function(ex) {
[17:39:34.056]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.056]                 ...future.rng), started = ...future.startTime, 
[17:39:34.056]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.056]             version = "1.8"), class = "FutureResult")
[17:39:34.056]     }, finally = {
[17:39:34.056]         if (!identical(...future.workdir, getwd())) 
[17:39:34.056]             setwd(...future.workdir)
[17:39:34.056]         {
[17:39:34.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.056]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.056]             }
[17:39:34.056]             base::options(...future.oldOptions)
[17:39:34.056]             if (.Platform$OS.type == "windows") {
[17:39:34.056]                 old_names <- names(...future.oldEnvVars)
[17:39:34.056]                 envs <- base::Sys.getenv()
[17:39:34.056]                 names <- names(envs)
[17:39:34.056]                 common <- intersect(names, old_names)
[17:39:34.056]                 added <- setdiff(names, old_names)
[17:39:34.056]                 removed <- setdiff(old_names, names)
[17:39:34.056]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.056]                   envs[common]]
[17:39:34.056]                 NAMES <- toupper(changed)
[17:39:34.056]                 args <- list()
[17:39:34.056]                 for (kk in seq_along(NAMES)) {
[17:39:34.056]                   name <- changed[[kk]]
[17:39:34.056]                   NAME <- NAMES[[kk]]
[17:39:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.056]                     next
[17:39:34.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.056]                 }
[17:39:34.056]                 NAMES <- toupper(added)
[17:39:34.056]                 for (kk in seq_along(NAMES)) {
[17:39:34.056]                   name <- added[[kk]]
[17:39:34.056]                   NAME <- NAMES[[kk]]
[17:39:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.056]                     next
[17:39:34.056]                   args[[name]] <- ""
[17:39:34.056]                 }
[17:39:34.056]                 NAMES <- toupper(removed)
[17:39:34.056]                 for (kk in seq_along(NAMES)) {
[17:39:34.056]                   name <- removed[[kk]]
[17:39:34.056]                   NAME <- NAMES[[kk]]
[17:39:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.056]                     next
[17:39:34.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.056]                 }
[17:39:34.056]                 if (length(args) > 0) 
[17:39:34.056]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.056]             }
[17:39:34.056]             else {
[17:39:34.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.056]             }
[17:39:34.056]             {
[17:39:34.056]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.056]                   0L) {
[17:39:34.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.056]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.056]                   base::options(opts)
[17:39:34.056]                 }
[17:39:34.056]                 {
[17:39:34.056]                   {
[17:39:34.056]                     NULL
[17:39:34.056]                     RNGkind("Mersenne-Twister")
[17:39:34.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.056]                       inherits = FALSE)
[17:39:34.056]                   }
[17:39:34.056]                   options(future.plan = NULL)
[17:39:34.056]                   if (is.na(NA_character_)) 
[17:39:34.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.056]                     .init = FALSE)
[17:39:34.056]                 }
[17:39:34.056]             }
[17:39:34.056]         }
[17:39:34.056]     })
[17:39:34.056]     if (TRUE) {
[17:39:34.056]         base::sink(type = "output", split = FALSE)
[17:39:34.056]         if (TRUE) {
[17:39:34.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.056]         }
[17:39:34.056]         else {
[17:39:34.056]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.056]         }
[17:39:34.056]         base::close(...future.stdout)
[17:39:34.056]         ...future.stdout <- NULL
[17:39:34.056]     }
[17:39:34.056]     ...future.result$conditions <- ...future.conditions
[17:39:34.056]     ...future.result$finished <- base::Sys.time()
[17:39:34.056]     ...future.result
[17:39:34.056] }
[17:39:34.058] plan(): Setting new future strategy stack:
[17:39:34.058] List of future strategies:
[17:39:34.058] 1. sequential:
[17:39:34.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.058]    - tweaked: FALSE
[17:39:34.058]    - call: NULL
[17:39:34.059] plan(): nbrOfWorkers() = 1
[17:39:34.060] plan(): Setting new future strategy stack:
[17:39:34.060] List of future strategies:
[17:39:34.060] 1. sequential:
[17:39:34.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.060]    - tweaked: FALSE
[17:39:34.060]    - call: plan(strategy)
[17:39:34.060] plan(): nbrOfWorkers() = 1
[17:39:34.060] SequentialFuture started (and completed)
[17:39:34.060] - Launch lazy future ... done
[17:39:34.061] run() for ‘SequentialFuture’ ... done
[17:39:34.061] getGlobalsAndPackages() ...
[17:39:34.061] Searching for globals...
[17:39:34.061] 
[17:39:34.061] Searching for globals ... DONE
[17:39:34.061] - globals: [0] <none>
[17:39:34.061] getGlobalsAndPackages() ... DONE
[17:39:34.062] run() for ‘Future’ ...
[17:39:34.062] - state: ‘created’
[17:39:34.062] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.062] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.062]   - Field: ‘label’
[17:39:34.062]   - Field: ‘local’
[17:39:34.063]   - Field: ‘owner’
[17:39:34.063]   - Field: ‘envir’
[17:39:34.063]   - Field: ‘packages’
[17:39:34.063]   - Field: ‘gc’
[17:39:34.063]   - Field: ‘conditions’
[17:39:34.063]   - Field: ‘expr’
[17:39:34.063]   - Field: ‘uuid’
[17:39:34.063]   - Field: ‘seed’
[17:39:34.063]   - Field: ‘version’
[17:39:34.063]   - Field: ‘result’
[17:39:34.063]   - Field: ‘asynchronous’
[17:39:34.064]   - Field: ‘calls’
[17:39:34.064]   - Field: ‘globals’
[17:39:34.064]   - Field: ‘stdout’
[17:39:34.064]   - Field: ‘earlySignal’
[17:39:34.064]   - Field: ‘lazy’
[17:39:34.064]   - Field: ‘state’
[17:39:34.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.064] - Launch lazy future ...
[17:39:34.064] Packages needed by the future expression (n = 0): <none>
[17:39:34.065] Packages needed by future strategies (n = 0): <none>
[17:39:34.067] {
[17:39:34.067]     {
[17:39:34.067]         {
[17:39:34.067]             ...future.startTime <- base::Sys.time()
[17:39:34.067]             {
[17:39:34.067]                 {
[17:39:34.067]                   {
[17:39:34.067]                     base::local({
[17:39:34.067]                       has_future <- base::requireNamespace("future", 
[17:39:34.067]                         quietly = TRUE)
[17:39:34.067]                       if (has_future) {
[17:39:34.067]                         ns <- base::getNamespace("future")
[17:39:34.067]                         version <- ns[[".package"]][["version"]]
[17:39:34.067]                         if (is.null(version)) 
[17:39:34.067]                           version <- utils::packageVersion("future")
[17:39:34.067]                       }
[17:39:34.067]                       else {
[17:39:34.067]                         version <- NULL
[17:39:34.067]                       }
[17:39:34.067]                       if (!has_future || version < "1.8.0") {
[17:39:34.067]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.067]                           "", base::R.version$version.string), 
[17:39:34.067]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.067]                             "release", "version")], collapse = " "), 
[17:39:34.067]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.067]                           info)
[17:39:34.067]                         info <- base::paste(info, collapse = "; ")
[17:39:34.067]                         if (!has_future) {
[17:39:34.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.067]                             info)
[17:39:34.067]                         }
[17:39:34.067]                         else {
[17:39:34.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.067]                             info, version)
[17:39:34.067]                         }
[17:39:34.067]                         base::stop(msg)
[17:39:34.067]                       }
[17:39:34.067]                     })
[17:39:34.067]                   }
[17:39:34.067]                   ...future.strategy.old <- future::plan("list")
[17:39:34.067]                   options(future.plan = NULL)
[17:39:34.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.067]                 }
[17:39:34.067]                 ...future.workdir <- getwd()
[17:39:34.067]             }
[17:39:34.067]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.067]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.067]         }
[17:39:34.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.067]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.067]             base::names(...future.oldOptions))
[17:39:34.067]     }
[17:39:34.067]     if (FALSE) {
[17:39:34.067]     }
[17:39:34.067]     else {
[17:39:34.067]         if (TRUE) {
[17:39:34.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.067]                 open = "w")
[17:39:34.067]         }
[17:39:34.067]         else {
[17:39:34.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.067]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.067]         }
[17:39:34.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.067]             base::sink(type = "output", split = FALSE)
[17:39:34.067]             base::close(...future.stdout)
[17:39:34.067]         }, add = TRUE)
[17:39:34.067]     }
[17:39:34.067]     ...future.frame <- base::sys.nframe()
[17:39:34.067]     ...future.conditions <- base::list()
[17:39:34.067]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.067]     if (FALSE) {
[17:39:34.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.067]     }
[17:39:34.067]     ...future.result <- base::tryCatch({
[17:39:34.067]         base::withCallingHandlers({
[17:39:34.067]             ...future.value <- base::withVisible(base::local(NULL))
[17:39:34.067]             future::FutureResult(value = ...future.value$value, 
[17:39:34.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.067]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.067]                     ...future.globalenv.names))
[17:39:34.067]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.067]         }, condition = base::local({
[17:39:34.067]             c <- base::c
[17:39:34.067]             inherits <- base::inherits
[17:39:34.067]             invokeRestart <- base::invokeRestart
[17:39:34.067]             length <- base::length
[17:39:34.067]             list <- base::list
[17:39:34.067]             seq.int <- base::seq.int
[17:39:34.067]             signalCondition <- base::signalCondition
[17:39:34.067]             sys.calls <- base::sys.calls
[17:39:34.067]             `[[` <- base::`[[`
[17:39:34.067]             `+` <- base::`+`
[17:39:34.067]             `<<-` <- base::`<<-`
[17:39:34.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.067]                   3L)]
[17:39:34.067]             }
[17:39:34.067]             function(cond) {
[17:39:34.067]                 is_error <- inherits(cond, "error")
[17:39:34.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.067]                   NULL)
[17:39:34.067]                 if (is_error) {
[17:39:34.067]                   sessionInformation <- function() {
[17:39:34.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.067]                       search = base::search(), system = base::Sys.info())
[17:39:34.067]                   }
[17:39:34.067]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.067]                     cond$call), session = sessionInformation(), 
[17:39:34.067]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.067]                   signalCondition(cond)
[17:39:34.067]                 }
[17:39:34.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.067]                 "immediateCondition"))) {
[17:39:34.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.067]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.067]                   if (TRUE && !signal) {
[17:39:34.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.067]                     {
[17:39:34.067]                       inherits <- base::inherits
[17:39:34.067]                       invokeRestart <- base::invokeRestart
[17:39:34.067]                       is.null <- base::is.null
[17:39:34.067]                       muffled <- FALSE
[17:39:34.067]                       if (inherits(cond, "message")) {
[17:39:34.067]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.067]                         if (muffled) 
[17:39:34.067]                           invokeRestart("muffleMessage")
[17:39:34.067]                       }
[17:39:34.067]                       else if (inherits(cond, "warning")) {
[17:39:34.067]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.067]                         if (muffled) 
[17:39:34.067]                           invokeRestart("muffleWarning")
[17:39:34.067]                       }
[17:39:34.067]                       else if (inherits(cond, "condition")) {
[17:39:34.067]                         if (!is.null(pattern)) {
[17:39:34.067]                           computeRestarts <- base::computeRestarts
[17:39:34.067]                           grepl <- base::grepl
[17:39:34.067]                           restarts <- computeRestarts(cond)
[17:39:34.067]                           for (restart in restarts) {
[17:39:34.067]                             name <- restart$name
[17:39:34.067]                             if (is.null(name)) 
[17:39:34.067]                               next
[17:39:34.067]                             if (!grepl(pattern, name)) 
[17:39:34.067]                               next
[17:39:34.067]                             invokeRestart(restart)
[17:39:34.067]                             muffled <- TRUE
[17:39:34.067]                             break
[17:39:34.067]                           }
[17:39:34.067]                         }
[17:39:34.067]                       }
[17:39:34.067]                       invisible(muffled)
[17:39:34.067]                     }
[17:39:34.067]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.067]                   }
[17:39:34.067]                 }
[17:39:34.067]                 else {
[17:39:34.067]                   if (TRUE) {
[17:39:34.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.067]                     {
[17:39:34.067]                       inherits <- base::inherits
[17:39:34.067]                       invokeRestart <- base::invokeRestart
[17:39:34.067]                       is.null <- base::is.null
[17:39:34.067]                       muffled <- FALSE
[17:39:34.067]                       if (inherits(cond, "message")) {
[17:39:34.067]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.067]                         if (muffled) 
[17:39:34.067]                           invokeRestart("muffleMessage")
[17:39:34.067]                       }
[17:39:34.067]                       else if (inherits(cond, "warning")) {
[17:39:34.067]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.067]                         if (muffled) 
[17:39:34.067]                           invokeRestart("muffleWarning")
[17:39:34.067]                       }
[17:39:34.067]                       else if (inherits(cond, "condition")) {
[17:39:34.067]                         if (!is.null(pattern)) {
[17:39:34.067]                           computeRestarts <- base::computeRestarts
[17:39:34.067]                           grepl <- base::grepl
[17:39:34.067]                           restarts <- computeRestarts(cond)
[17:39:34.067]                           for (restart in restarts) {
[17:39:34.067]                             name <- restart$name
[17:39:34.067]                             if (is.null(name)) 
[17:39:34.067]                               next
[17:39:34.067]                             if (!grepl(pattern, name)) 
[17:39:34.067]                               next
[17:39:34.067]                             invokeRestart(restart)
[17:39:34.067]                             muffled <- TRUE
[17:39:34.067]                             break
[17:39:34.067]                           }
[17:39:34.067]                         }
[17:39:34.067]                       }
[17:39:34.067]                       invisible(muffled)
[17:39:34.067]                     }
[17:39:34.067]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.067]                   }
[17:39:34.067]                 }
[17:39:34.067]             }
[17:39:34.067]         }))
[17:39:34.067]     }, error = function(ex) {
[17:39:34.067]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.067]                 ...future.rng), started = ...future.startTime, 
[17:39:34.067]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.067]             version = "1.8"), class = "FutureResult")
[17:39:34.067]     }, finally = {
[17:39:34.067]         if (!identical(...future.workdir, getwd())) 
[17:39:34.067]             setwd(...future.workdir)
[17:39:34.067]         {
[17:39:34.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.067]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.067]             }
[17:39:34.067]             base::options(...future.oldOptions)
[17:39:34.067]             if (.Platform$OS.type == "windows") {
[17:39:34.067]                 old_names <- names(...future.oldEnvVars)
[17:39:34.067]                 envs <- base::Sys.getenv()
[17:39:34.067]                 names <- names(envs)
[17:39:34.067]                 common <- intersect(names, old_names)
[17:39:34.067]                 added <- setdiff(names, old_names)
[17:39:34.067]                 removed <- setdiff(old_names, names)
[17:39:34.067]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.067]                   envs[common]]
[17:39:34.067]                 NAMES <- toupper(changed)
[17:39:34.067]                 args <- list()
[17:39:34.067]                 for (kk in seq_along(NAMES)) {
[17:39:34.067]                   name <- changed[[kk]]
[17:39:34.067]                   NAME <- NAMES[[kk]]
[17:39:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.067]                     next
[17:39:34.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.067]                 }
[17:39:34.067]                 NAMES <- toupper(added)
[17:39:34.067]                 for (kk in seq_along(NAMES)) {
[17:39:34.067]                   name <- added[[kk]]
[17:39:34.067]                   NAME <- NAMES[[kk]]
[17:39:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.067]                     next
[17:39:34.067]                   args[[name]] <- ""
[17:39:34.067]                 }
[17:39:34.067]                 NAMES <- toupper(removed)
[17:39:34.067]                 for (kk in seq_along(NAMES)) {
[17:39:34.067]                   name <- removed[[kk]]
[17:39:34.067]                   NAME <- NAMES[[kk]]
[17:39:34.067]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.067]                     next
[17:39:34.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.067]                 }
[17:39:34.067]                 if (length(args) > 0) 
[17:39:34.067]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.067]             }
[17:39:34.067]             else {
[17:39:34.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.067]             }
[17:39:34.067]             {
[17:39:34.067]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.067]                   0L) {
[17:39:34.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.067]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.067]                   base::options(opts)
[17:39:34.067]                 }
[17:39:34.067]                 {
[17:39:34.067]                   {
[17:39:34.067]                     NULL
[17:39:34.067]                     RNGkind("Mersenne-Twister")
[17:39:34.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.067]                       inherits = FALSE)
[17:39:34.067]                   }
[17:39:34.067]                   options(future.plan = NULL)
[17:39:34.067]                   if (is.na(NA_character_)) 
[17:39:34.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.067]                     .init = FALSE)
[17:39:34.067]                 }
[17:39:34.067]             }
[17:39:34.067]         }
[17:39:34.067]     })
[17:39:34.067]     if (TRUE) {
[17:39:34.067]         base::sink(type = "output", split = FALSE)
[17:39:34.067]         if (TRUE) {
[17:39:34.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.067]         }
[17:39:34.067]         else {
[17:39:34.067]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.067]         }
[17:39:34.067]         base::close(...future.stdout)
[17:39:34.067]         ...future.stdout <- NULL
[17:39:34.067]     }
[17:39:34.067]     ...future.result$conditions <- ...future.conditions
[17:39:34.067]     ...future.result$finished <- base::Sys.time()
[17:39:34.067]     ...future.result
[17:39:34.067] }
[17:39:34.069] plan(): Setting new future strategy stack:
[17:39:34.069] List of future strategies:
[17:39:34.069] 1. sequential:
[17:39:34.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.069]    - tweaked: FALSE
[17:39:34.069]    - call: NULL
[17:39:34.069] plan(): nbrOfWorkers() = 1
[17:39:34.070] plan(): Setting new future strategy stack:
[17:39:34.070] List of future strategies:
[17:39:34.070] 1. sequential:
[17:39:34.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.070]    - tweaked: FALSE
[17:39:34.070]    - call: plan(strategy)
[17:39:34.071] plan(): nbrOfWorkers() = 1
[17:39:34.071] SequentialFuture started (and completed)
[17:39:34.071] - Launch lazy future ... done
[17:39:34.071] run() for ‘SequentialFuture’ ... done
[17:39:34.071] getGlobalsAndPackages() ...
[17:39:34.071] Searching for globals...
[17:39:34.072] - globals found: [1] ‘{’
[17:39:34.072] Searching for globals ... DONE
[17:39:34.072] Resolving globals: FALSE
[17:39:34.073] 
[17:39:34.073] 
[17:39:34.073] getGlobalsAndPackages() ... DONE
[17:39:34.073] run() for ‘Future’ ...
[17:39:34.073] - state: ‘created’
[17:39:34.073] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:39:34.073] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:39:34.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:39:34.074]   - Field: ‘label’
[17:39:34.074]   - Field: ‘local’
[17:39:34.074]   - Field: ‘owner’
[17:39:34.074]   - Field: ‘envir’
[17:39:34.074]   - Field: ‘packages’
[17:39:34.074]   - Field: ‘gc’
[17:39:34.074]   - Field: ‘conditions’
[17:39:34.074]   - Field: ‘expr’
[17:39:34.074]   - Field: ‘uuid’
[17:39:34.074]   - Field: ‘seed’
[17:39:34.075]   - Field: ‘version’
[17:39:34.075]   - Field: ‘result’
[17:39:34.075]   - Field: ‘asynchronous’
[17:39:34.075]   - Field: ‘calls’
[17:39:34.075]   - Field: ‘globals’
[17:39:34.075]   - Field: ‘stdout’
[17:39:34.075]   - Field: ‘earlySignal’
[17:39:34.075]   - Field: ‘lazy’
[17:39:34.075]   - Field: ‘state’
[17:39:34.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:39:34.075] - Launch lazy future ...
[17:39:34.076] Packages needed by the future expression (n = 0): <none>
[17:39:34.076] Packages needed by future strategies (n = 0): <none>
[17:39:34.076] {
[17:39:34.076]     {
[17:39:34.076]         {
[17:39:34.076]             ...future.startTime <- base::Sys.time()
[17:39:34.076]             {
[17:39:34.076]                 {
[17:39:34.076]                   {
[17:39:34.076]                     base::local({
[17:39:34.076]                       has_future <- base::requireNamespace("future", 
[17:39:34.076]                         quietly = TRUE)
[17:39:34.076]                       if (has_future) {
[17:39:34.076]                         ns <- base::getNamespace("future")
[17:39:34.076]                         version <- ns[[".package"]][["version"]]
[17:39:34.076]                         if (is.null(version)) 
[17:39:34.076]                           version <- utils::packageVersion("future")
[17:39:34.076]                       }
[17:39:34.076]                       else {
[17:39:34.076]                         version <- NULL
[17:39:34.076]                       }
[17:39:34.076]                       if (!has_future || version < "1.8.0") {
[17:39:34.076]                         info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.076]                           "", base::R.version$version.string), 
[17:39:34.076]                           platform = base::sprintf("%s (%s-bit)", 
[17:39:34.076]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.076]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.076]                             "release", "version")], collapse = " "), 
[17:39:34.076]                           hostname = base::Sys.info()[["nodename"]])
[17:39:34.076]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.076]                           info)
[17:39:34.076]                         info <- base::paste(info, collapse = "; ")
[17:39:34.076]                         if (!has_future) {
[17:39:34.076]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.076]                             info)
[17:39:34.076]                         }
[17:39:34.076]                         else {
[17:39:34.076]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.076]                             info, version)
[17:39:34.076]                         }
[17:39:34.076]                         base::stop(msg)
[17:39:34.076]                       }
[17:39:34.076]                     })
[17:39:34.076]                   }
[17:39:34.076]                   ...future.strategy.old <- future::plan("list")
[17:39:34.076]                   options(future.plan = NULL)
[17:39:34.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.076]                 }
[17:39:34.076]                 ...future.workdir <- getwd()
[17:39:34.076]             }
[17:39:34.076]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.076]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.076]         }
[17:39:34.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.076]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.076]             base::names(...future.oldOptions))
[17:39:34.076]     }
[17:39:34.076]     if (FALSE) {
[17:39:34.076]     }
[17:39:34.076]     else {
[17:39:34.076]         if (TRUE) {
[17:39:34.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.076]                 open = "w")
[17:39:34.076]         }
[17:39:34.076]         else {
[17:39:34.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.076]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.076]         }
[17:39:34.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.076]             base::sink(type = "output", split = FALSE)
[17:39:34.076]             base::close(...future.stdout)
[17:39:34.076]         }, add = TRUE)
[17:39:34.076]     }
[17:39:34.076]     ...future.frame <- base::sys.nframe()
[17:39:34.076]     ...future.conditions <- base::list()
[17:39:34.076]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.076]     if (FALSE) {
[17:39:34.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.076]     }
[17:39:34.076]     ...future.result <- base::tryCatch({
[17:39:34.076]         base::withCallingHandlers({
[17:39:34.076]             ...future.value <- base::withVisible(base::local({
[17:39:34.076]                 4
[17:39:34.076]             }))
[17:39:34.076]             future::FutureResult(value = ...future.value$value, 
[17:39:34.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.076]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.076]                     ...future.globalenv.names))
[17:39:34.076]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.076]         }, condition = base::local({
[17:39:34.076]             c <- base::c
[17:39:34.076]             inherits <- base::inherits
[17:39:34.076]             invokeRestart <- base::invokeRestart
[17:39:34.076]             length <- base::length
[17:39:34.076]             list <- base::list
[17:39:34.076]             seq.int <- base::seq.int
[17:39:34.076]             signalCondition <- base::signalCondition
[17:39:34.076]             sys.calls <- base::sys.calls
[17:39:34.076]             `[[` <- base::`[[`
[17:39:34.076]             `+` <- base::`+`
[17:39:34.076]             `<<-` <- base::`<<-`
[17:39:34.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.076]                   3L)]
[17:39:34.076]             }
[17:39:34.076]             function(cond) {
[17:39:34.076]                 is_error <- inherits(cond, "error")
[17:39:34.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.076]                   NULL)
[17:39:34.076]                 if (is_error) {
[17:39:34.076]                   sessionInformation <- function() {
[17:39:34.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.076]                       search = base::search(), system = base::Sys.info())
[17:39:34.076]                   }
[17:39:34.076]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.076]                     cond$call), session = sessionInformation(), 
[17:39:34.076]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.076]                   signalCondition(cond)
[17:39:34.076]                 }
[17:39:34.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.076]                 "immediateCondition"))) {
[17:39:34.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.076]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.076]                   if (TRUE && !signal) {
[17:39:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.076]                     {
[17:39:34.076]                       inherits <- base::inherits
[17:39:34.076]                       invokeRestart <- base::invokeRestart
[17:39:34.076]                       is.null <- base::is.null
[17:39:34.076]                       muffled <- FALSE
[17:39:34.076]                       if (inherits(cond, "message")) {
[17:39:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.076]                         if (muffled) 
[17:39:34.076]                           invokeRestart("muffleMessage")
[17:39:34.076]                       }
[17:39:34.076]                       else if (inherits(cond, "warning")) {
[17:39:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.076]                         if (muffled) 
[17:39:34.076]                           invokeRestart("muffleWarning")
[17:39:34.076]                       }
[17:39:34.076]                       else if (inherits(cond, "condition")) {
[17:39:34.076]                         if (!is.null(pattern)) {
[17:39:34.076]                           computeRestarts <- base::computeRestarts
[17:39:34.076]                           grepl <- base::grepl
[17:39:34.076]                           restarts <- computeRestarts(cond)
[17:39:34.076]                           for (restart in restarts) {
[17:39:34.076]                             name <- restart$name
[17:39:34.076]                             if (is.null(name)) 
[17:39:34.076]                               next
[17:39:34.076]                             if (!grepl(pattern, name)) 
[17:39:34.076]                               next
[17:39:34.076]                             invokeRestart(restart)
[17:39:34.076]                             muffled <- TRUE
[17:39:34.076]                             break
[17:39:34.076]                           }
[17:39:34.076]                         }
[17:39:34.076]                       }
[17:39:34.076]                       invisible(muffled)
[17:39:34.076]                     }
[17:39:34.076]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.076]                   }
[17:39:34.076]                 }
[17:39:34.076]                 else {
[17:39:34.076]                   if (TRUE) {
[17:39:34.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.076]                     {
[17:39:34.076]                       inherits <- base::inherits
[17:39:34.076]                       invokeRestart <- base::invokeRestart
[17:39:34.076]                       is.null <- base::is.null
[17:39:34.076]                       muffled <- FALSE
[17:39:34.076]                       if (inherits(cond, "message")) {
[17:39:34.076]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.076]                         if (muffled) 
[17:39:34.076]                           invokeRestart("muffleMessage")
[17:39:34.076]                       }
[17:39:34.076]                       else if (inherits(cond, "warning")) {
[17:39:34.076]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.076]                         if (muffled) 
[17:39:34.076]                           invokeRestart("muffleWarning")
[17:39:34.076]                       }
[17:39:34.076]                       else if (inherits(cond, "condition")) {
[17:39:34.076]                         if (!is.null(pattern)) {
[17:39:34.076]                           computeRestarts <- base::computeRestarts
[17:39:34.076]                           grepl <- base::grepl
[17:39:34.076]                           restarts <- computeRestarts(cond)
[17:39:34.076]                           for (restart in restarts) {
[17:39:34.076]                             name <- restart$name
[17:39:34.076]                             if (is.null(name)) 
[17:39:34.076]                               next
[17:39:34.076]                             if (!grepl(pattern, name)) 
[17:39:34.076]                               next
[17:39:34.076]                             invokeRestart(restart)
[17:39:34.076]                             muffled <- TRUE
[17:39:34.076]                             break
[17:39:34.076]                           }
[17:39:34.076]                         }
[17:39:34.076]                       }
[17:39:34.076]                       invisible(muffled)
[17:39:34.076]                     }
[17:39:34.076]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.076]                   }
[17:39:34.076]                 }
[17:39:34.076]             }
[17:39:34.076]         }))
[17:39:34.076]     }, error = function(ex) {
[17:39:34.076]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.076]                 ...future.rng), started = ...future.startTime, 
[17:39:34.076]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.076]             version = "1.8"), class = "FutureResult")
[17:39:34.076]     }, finally = {
[17:39:34.076]         if (!identical(...future.workdir, getwd())) 
[17:39:34.076]             setwd(...future.workdir)
[17:39:34.076]         {
[17:39:34.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.076]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.076]             }
[17:39:34.076]             base::options(...future.oldOptions)
[17:39:34.076]             if (.Platform$OS.type == "windows") {
[17:39:34.076]                 old_names <- names(...future.oldEnvVars)
[17:39:34.076]                 envs <- base::Sys.getenv()
[17:39:34.076]                 names <- names(envs)
[17:39:34.076]                 common <- intersect(names, old_names)
[17:39:34.076]                 added <- setdiff(names, old_names)
[17:39:34.076]                 removed <- setdiff(old_names, names)
[17:39:34.076]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.076]                   envs[common]]
[17:39:34.076]                 NAMES <- toupper(changed)
[17:39:34.076]                 args <- list()
[17:39:34.076]                 for (kk in seq_along(NAMES)) {
[17:39:34.076]                   name <- changed[[kk]]
[17:39:34.076]                   NAME <- NAMES[[kk]]
[17:39:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.076]                     next
[17:39:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.076]                 }
[17:39:34.076]                 NAMES <- toupper(added)
[17:39:34.076]                 for (kk in seq_along(NAMES)) {
[17:39:34.076]                   name <- added[[kk]]
[17:39:34.076]                   NAME <- NAMES[[kk]]
[17:39:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.076]                     next
[17:39:34.076]                   args[[name]] <- ""
[17:39:34.076]                 }
[17:39:34.076]                 NAMES <- toupper(removed)
[17:39:34.076]                 for (kk in seq_along(NAMES)) {
[17:39:34.076]                   name <- removed[[kk]]
[17:39:34.076]                   NAME <- NAMES[[kk]]
[17:39:34.076]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.076]                     next
[17:39:34.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.076]                 }
[17:39:34.076]                 if (length(args) > 0) 
[17:39:34.076]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.076]             }
[17:39:34.076]             else {
[17:39:34.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.076]             }
[17:39:34.076]             {
[17:39:34.076]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.076]                   0L) {
[17:39:34.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.076]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.076]                   base::options(opts)
[17:39:34.076]                 }
[17:39:34.076]                 {
[17:39:34.076]                   {
[17:39:34.076]                     NULL
[17:39:34.076]                     RNGkind("Mersenne-Twister")
[17:39:34.076]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:39:34.076]                       inherits = FALSE)
[17:39:34.076]                   }
[17:39:34.076]                   options(future.plan = NULL)
[17:39:34.076]                   if (is.na(NA_character_)) 
[17:39:34.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.076]                     .init = FALSE)
[17:39:34.076]                 }
[17:39:34.076]             }
[17:39:34.076]         }
[17:39:34.076]     })
[17:39:34.076]     if (TRUE) {
[17:39:34.076]         base::sink(type = "output", split = FALSE)
[17:39:34.076]         if (TRUE) {
[17:39:34.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.076]         }
[17:39:34.076]         else {
[17:39:34.076]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.076]         }
[17:39:34.076]         base::close(...future.stdout)
[17:39:34.076]         ...future.stdout <- NULL
[17:39:34.076]     }
[17:39:34.076]     ...future.result$conditions <- ...future.conditions
[17:39:34.076]     ...future.result$finished <- base::Sys.time()
[17:39:34.076]     ...future.result
[17:39:34.076] }
[17:39:34.078] plan(): Setting new future strategy stack:
[17:39:34.078] List of future strategies:
[17:39:34.078] 1. sequential:
[17:39:34.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.078]    - tweaked: FALSE
[17:39:34.078]    - call: NULL
[17:39:34.078] plan(): nbrOfWorkers() = 1
[17:39:34.079] plan(): Setting new future strategy stack:
[17:39:34.079] List of future strategies:
[17:39:34.079] 1. sequential:
[17:39:34.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.079]    - tweaked: FALSE
[17:39:34.079]    - call: plan(strategy)
[17:39:34.080] plan(): nbrOfWorkers() = 1
[17:39:34.080] SequentialFuture started (and completed)
[17:39:34.080] - Launch lazy future ... done
[17:39:34.080] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf0033100> 
Classes 'listenv', 'environment' <environment: 0x55adefbab8e0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:34.084] resolved() for ‘SequentialFuture’ ...
[17:39:34.084] - state: ‘finished’
[17:39:34.084] - run: TRUE
[17:39:34.084] - result: ‘FutureResult’
[17:39:34.084] resolved() for ‘SequentialFuture’ ... done
[17:39:34.084] resolved() for ‘SequentialFuture’ ...
[17:39:34.085] - state: ‘finished’
[17:39:34.085] - run: TRUE
[17:39:34.085] - result: ‘FutureResult’
[17:39:34.085] resolved() for ‘SequentialFuture’ ... done
[17:39:34.085] resolved() for ‘SequentialFuture’ ...
[17:39:34.085] - state: ‘finished’
[17:39:34.085] - run: TRUE
[17:39:34.085] - result: ‘FutureResult’
[17:39:34.085] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:34.088] resolve() on list environment ...
[17:39:34.088]  recursive: 0
[17:39:34.089]  length: 6
[17:39:34.089]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:34.089] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.089] - nx: 6
[17:39:34.089] - relay: TRUE
[17:39:34.089] - stdout: TRUE
[17:39:34.089] - signal: TRUE
[17:39:34.090] - resignal: FALSE
[17:39:34.090] - force: TRUE
[17:39:34.090] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.090] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.090]  - until=2
[17:39:34.090]  - relaying element #2
[17:39:34.090] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.090] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.090] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.090]  length: 5 (resolved future 1)
[17:39:34.090] resolved() for ‘SequentialFuture’ ...
[17:39:34.091] - state: ‘finished’
[17:39:34.091] - run: TRUE
[17:39:34.091] - result: ‘FutureResult’
[17:39:34.091] resolved() for ‘SequentialFuture’ ... done
[17:39:34.091] Future #2
[17:39:34.091] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:39:34.091] - nx: 6
[17:39:34.091] - relay: TRUE
[17:39:34.091] - stdout: TRUE
[17:39:34.091] - signal: TRUE
[17:39:34.092] - resignal: FALSE
[17:39:34.092] - force: TRUE
[17:39:34.092] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.092] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.092]  - until=2
[17:39:34.092]  - relaying element #2
[17:39:34.092] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.092] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.092] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:39:34.092]  length: 4 (resolved future 2)
[17:39:34.093] resolved() for ‘SequentialFuture’ ...
[17:39:34.093] - state: ‘finished’
[17:39:34.093] - run: TRUE
[17:39:34.093] - result: ‘FutureResult’
[17:39:34.093] resolved() for ‘SequentialFuture’ ... done
[17:39:34.093] Future #3
[17:39:34.093] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:39:34.093] - nx: 6
[17:39:34.093] - relay: TRUE
[17:39:34.093] - stdout: TRUE
[17:39:34.093] - signal: TRUE
[17:39:34.094] - resignal: FALSE
[17:39:34.094] - force: TRUE
[17:39:34.094] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.094] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.094]  - until=3
[17:39:34.094]  - relaying element #3
[17:39:34.096] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.096] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.096] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:39:34.096]  length: 3 (resolved future 3)
[17:39:34.097] resolved() for ‘SequentialFuture’ ...
[17:39:34.097] - state: ‘finished’
[17:39:34.097] - run: TRUE
[17:39:34.097] - result: ‘FutureResult’
[17:39:34.097] resolved() for ‘SequentialFuture’ ... done
[17:39:34.097] Future #4
[17:39:34.097] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:39:34.097] - nx: 6
[17:39:34.097] - relay: TRUE
[17:39:34.098] - stdout: TRUE
[17:39:34.098] - signal: TRUE
[17:39:34.098] - resignal: FALSE
[17:39:34.098] - force: TRUE
[17:39:34.098] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.098] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.098]  - until=4
[17:39:34.098]  - relaying element #4
[17:39:34.098] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.098] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.099] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:39:34.099]  length: 2 (resolved future 4)
[17:39:34.099] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.099] - nx: 6
[17:39:34.099] - relay: TRUE
[17:39:34.099] - stdout: TRUE
[17:39:34.099] - signal: TRUE
[17:39:34.099] - resignal: FALSE
[17:39:34.099] - force: TRUE
[17:39:34.099] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.099] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.099]  - until=6
[17:39:34.100]  - relaying element #6
[17:39:34.100] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.100] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.100] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.100]  length: 1 (resolved future 5)
[17:39:34.100] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.100] - nx: 6
[17:39:34.100] - relay: TRUE
[17:39:34.100] - stdout: TRUE
[17:39:34.100] - signal: TRUE
[17:39:34.100] - resignal: FALSE
[17:39:34.101] - force: TRUE
[17:39:34.101] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.101] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.101]  - until=6
[17:39:34.101] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.101] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.101] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.101]  length: 0 (resolved future 6)
[17:39:34.101] Relaying remaining futures
[17:39:34.101] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.101] - nx: 6
[17:39:34.102] - relay: TRUE
[17:39:34.102] - stdout: TRUE
[17:39:34.102] - signal: TRUE
[17:39:34.102] - resignal: FALSE
[17:39:34.102] - force: TRUE
[17:39:34.102] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.102] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:34.102] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.102] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.102] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.102] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55adf0264518> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[17:39:34.105] plan(): Setting new future strategy stack:
[17:39:34.106] List of future strategies:
[17:39:34.106] 1. multicore:
[17:39:34.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.106]    - tweaked: FALSE
[17:39:34.106]    - call: plan(strategy)
[17:39:34.109] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:34.110] getGlobalsAndPackages() ...
[17:39:34.110] Searching for globals...
[17:39:34.110] 
[17:39:34.110] Searching for globals ... DONE
[17:39:34.110] - globals: [0] <none>
[17:39:34.110] getGlobalsAndPackages() ... DONE
[17:39:34.110] run() for ‘Future’ ...
[17:39:34.111] - state: ‘created’
[17:39:34.111] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.114] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.114]   - Field: ‘label’
[17:39:34.114]   - Field: ‘local’
[17:39:34.115]   - Field: ‘owner’
[17:39:34.115]   - Field: ‘envir’
[17:39:34.115]   - Field: ‘workers’
[17:39:34.115]   - Field: ‘packages’
[17:39:34.115]   - Field: ‘gc’
[17:39:34.115]   - Field: ‘job’
[17:39:34.115]   - Field: ‘conditions’
[17:39:34.115]   - Field: ‘expr’
[17:39:34.115]   - Field: ‘uuid’
[17:39:34.115]   - Field: ‘seed’
[17:39:34.115]   - Field: ‘version’
[17:39:34.116]   - Field: ‘result’
[17:39:34.116]   - Field: ‘asynchronous’
[17:39:34.116]   - Field: ‘calls’
[17:39:34.116]   - Field: ‘globals’
[17:39:34.116]   - Field: ‘stdout’
[17:39:34.116]   - Field: ‘earlySignal’
[17:39:34.116]   - Field: ‘lazy’
[17:39:34.116]   - Field: ‘state’
[17:39:34.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.116] - Launch lazy future ...
[17:39:34.117] Packages needed by the future expression (n = 0): <none>
[17:39:34.117] Packages needed by future strategies (n = 0): <none>
[17:39:34.118] {
[17:39:34.118]     {
[17:39:34.118]         {
[17:39:34.118]             ...future.startTime <- base::Sys.time()
[17:39:34.118]             {
[17:39:34.118]                 {
[17:39:34.118]                   {
[17:39:34.118]                     {
[17:39:34.118]                       base::local({
[17:39:34.118]                         has_future <- base::requireNamespace("future", 
[17:39:34.118]                           quietly = TRUE)
[17:39:34.118]                         if (has_future) {
[17:39:34.118]                           ns <- base::getNamespace("future")
[17:39:34.118]                           version <- ns[[".package"]][["version"]]
[17:39:34.118]                           if (is.null(version)) 
[17:39:34.118]                             version <- utils::packageVersion("future")
[17:39:34.118]                         }
[17:39:34.118]                         else {
[17:39:34.118]                           version <- NULL
[17:39:34.118]                         }
[17:39:34.118]                         if (!has_future || version < "1.8.0") {
[17:39:34.118]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.118]                             "", base::R.version$version.string), 
[17:39:34.118]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.118]                               "release", "version")], collapse = " "), 
[17:39:34.118]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.118]                             info)
[17:39:34.118]                           info <- base::paste(info, collapse = "; ")
[17:39:34.118]                           if (!has_future) {
[17:39:34.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.118]                               info)
[17:39:34.118]                           }
[17:39:34.118]                           else {
[17:39:34.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.118]                               info, version)
[17:39:34.118]                           }
[17:39:34.118]                           base::stop(msg)
[17:39:34.118]                         }
[17:39:34.118]                       })
[17:39:34.118]                     }
[17:39:34.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.118]                     base::options(mc.cores = 1L)
[17:39:34.118]                   }
[17:39:34.118]                   ...future.strategy.old <- future::plan("list")
[17:39:34.118]                   options(future.plan = NULL)
[17:39:34.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.118]                 }
[17:39:34.118]                 ...future.workdir <- getwd()
[17:39:34.118]             }
[17:39:34.118]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.118]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.118]         }
[17:39:34.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.118]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.118]             base::names(...future.oldOptions))
[17:39:34.118]     }
[17:39:34.118]     if (FALSE) {
[17:39:34.118]     }
[17:39:34.118]     else {
[17:39:34.118]         if (TRUE) {
[17:39:34.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.118]                 open = "w")
[17:39:34.118]         }
[17:39:34.118]         else {
[17:39:34.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.118]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.118]         }
[17:39:34.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.118]             base::sink(type = "output", split = FALSE)
[17:39:34.118]             base::close(...future.stdout)
[17:39:34.118]         }, add = TRUE)
[17:39:34.118]     }
[17:39:34.118]     ...future.frame <- base::sys.nframe()
[17:39:34.118]     ...future.conditions <- base::list()
[17:39:34.118]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.118]     if (FALSE) {
[17:39:34.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.118]     }
[17:39:34.118]     ...future.result <- base::tryCatch({
[17:39:34.118]         base::withCallingHandlers({
[17:39:34.118]             ...future.value <- base::withVisible(base::local({
[17:39:34.118]                 withCallingHandlers({
[17:39:34.118]                   2
[17:39:34.118]                 }, immediateCondition = function(cond) {
[17:39:34.118]                   save_rds <- function (object, pathname, ...) 
[17:39:34.118]                   {
[17:39:34.118]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.118]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.118]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.118]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.118]                         fi_tmp[["mtime"]])
[17:39:34.118]                     }
[17:39:34.118]                     tryCatch({
[17:39:34.118]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.118]                     }, error = function(ex) {
[17:39:34.118]                       msg <- conditionMessage(ex)
[17:39:34.118]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.118]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.118]                         fi_tmp[["mtime"]], msg)
[17:39:34.118]                       ex$message <- msg
[17:39:34.118]                       stop(ex)
[17:39:34.118]                     })
[17:39:34.118]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.118]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.118]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.118]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.118]                       fi <- file.info(pathname)
[17:39:34.118]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.118]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.118]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.118]                         fi[["size"]], fi[["mtime"]])
[17:39:34.118]                       stop(msg)
[17:39:34.118]                     }
[17:39:34.118]                     invisible(pathname)
[17:39:34.118]                   }
[17:39:34.118]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.118]                     rootPath = tempdir()) 
[17:39:34.118]                   {
[17:39:34.118]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.118]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.118]                       tmpdir = path, fileext = ".rds")
[17:39:34.118]                     save_rds(obj, file)
[17:39:34.118]                   }
[17:39:34.118]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.118]                   {
[17:39:34.118]                     inherits <- base::inherits
[17:39:34.118]                     invokeRestart <- base::invokeRestart
[17:39:34.118]                     is.null <- base::is.null
[17:39:34.118]                     muffled <- FALSE
[17:39:34.118]                     if (inherits(cond, "message")) {
[17:39:34.118]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.118]                       if (muffled) 
[17:39:34.118]                         invokeRestart("muffleMessage")
[17:39:34.118]                     }
[17:39:34.118]                     else if (inherits(cond, "warning")) {
[17:39:34.118]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.118]                       if (muffled) 
[17:39:34.118]                         invokeRestart("muffleWarning")
[17:39:34.118]                     }
[17:39:34.118]                     else if (inherits(cond, "condition")) {
[17:39:34.118]                       if (!is.null(pattern)) {
[17:39:34.118]                         computeRestarts <- base::computeRestarts
[17:39:34.118]                         grepl <- base::grepl
[17:39:34.118]                         restarts <- computeRestarts(cond)
[17:39:34.118]                         for (restart in restarts) {
[17:39:34.118]                           name <- restart$name
[17:39:34.118]                           if (is.null(name)) 
[17:39:34.118]                             next
[17:39:34.118]                           if (!grepl(pattern, name)) 
[17:39:34.118]                             next
[17:39:34.118]                           invokeRestart(restart)
[17:39:34.118]                           muffled <- TRUE
[17:39:34.118]                           break
[17:39:34.118]                         }
[17:39:34.118]                       }
[17:39:34.118]                     }
[17:39:34.118]                     invisible(muffled)
[17:39:34.118]                   }
[17:39:34.118]                   muffleCondition(cond)
[17:39:34.118]                 })
[17:39:34.118]             }))
[17:39:34.118]             future::FutureResult(value = ...future.value$value, 
[17:39:34.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.118]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.118]                     ...future.globalenv.names))
[17:39:34.118]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.118]         }, condition = base::local({
[17:39:34.118]             c <- base::c
[17:39:34.118]             inherits <- base::inherits
[17:39:34.118]             invokeRestart <- base::invokeRestart
[17:39:34.118]             length <- base::length
[17:39:34.118]             list <- base::list
[17:39:34.118]             seq.int <- base::seq.int
[17:39:34.118]             signalCondition <- base::signalCondition
[17:39:34.118]             sys.calls <- base::sys.calls
[17:39:34.118]             `[[` <- base::`[[`
[17:39:34.118]             `+` <- base::`+`
[17:39:34.118]             `<<-` <- base::`<<-`
[17:39:34.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.118]                   3L)]
[17:39:34.118]             }
[17:39:34.118]             function(cond) {
[17:39:34.118]                 is_error <- inherits(cond, "error")
[17:39:34.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.118]                   NULL)
[17:39:34.118]                 if (is_error) {
[17:39:34.118]                   sessionInformation <- function() {
[17:39:34.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.118]                       search = base::search(), system = base::Sys.info())
[17:39:34.118]                   }
[17:39:34.118]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.118]                     cond$call), session = sessionInformation(), 
[17:39:34.118]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.118]                   signalCondition(cond)
[17:39:34.118]                 }
[17:39:34.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.118]                 "immediateCondition"))) {
[17:39:34.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.118]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.118]                   if (TRUE && !signal) {
[17:39:34.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.118]                     {
[17:39:34.118]                       inherits <- base::inherits
[17:39:34.118]                       invokeRestart <- base::invokeRestart
[17:39:34.118]                       is.null <- base::is.null
[17:39:34.118]                       muffled <- FALSE
[17:39:34.118]                       if (inherits(cond, "message")) {
[17:39:34.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.118]                         if (muffled) 
[17:39:34.118]                           invokeRestart("muffleMessage")
[17:39:34.118]                       }
[17:39:34.118]                       else if (inherits(cond, "warning")) {
[17:39:34.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.118]                         if (muffled) 
[17:39:34.118]                           invokeRestart("muffleWarning")
[17:39:34.118]                       }
[17:39:34.118]                       else if (inherits(cond, "condition")) {
[17:39:34.118]                         if (!is.null(pattern)) {
[17:39:34.118]                           computeRestarts <- base::computeRestarts
[17:39:34.118]                           grepl <- base::grepl
[17:39:34.118]                           restarts <- computeRestarts(cond)
[17:39:34.118]                           for (restart in restarts) {
[17:39:34.118]                             name <- restart$name
[17:39:34.118]                             if (is.null(name)) 
[17:39:34.118]                               next
[17:39:34.118]                             if (!grepl(pattern, name)) 
[17:39:34.118]                               next
[17:39:34.118]                             invokeRestart(restart)
[17:39:34.118]                             muffled <- TRUE
[17:39:34.118]                             break
[17:39:34.118]                           }
[17:39:34.118]                         }
[17:39:34.118]                       }
[17:39:34.118]                       invisible(muffled)
[17:39:34.118]                     }
[17:39:34.118]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.118]                   }
[17:39:34.118]                 }
[17:39:34.118]                 else {
[17:39:34.118]                   if (TRUE) {
[17:39:34.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.118]                     {
[17:39:34.118]                       inherits <- base::inherits
[17:39:34.118]                       invokeRestart <- base::invokeRestart
[17:39:34.118]                       is.null <- base::is.null
[17:39:34.118]                       muffled <- FALSE
[17:39:34.118]                       if (inherits(cond, "message")) {
[17:39:34.118]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.118]                         if (muffled) 
[17:39:34.118]                           invokeRestart("muffleMessage")
[17:39:34.118]                       }
[17:39:34.118]                       else if (inherits(cond, "warning")) {
[17:39:34.118]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.118]                         if (muffled) 
[17:39:34.118]                           invokeRestart("muffleWarning")
[17:39:34.118]                       }
[17:39:34.118]                       else if (inherits(cond, "condition")) {
[17:39:34.118]                         if (!is.null(pattern)) {
[17:39:34.118]                           computeRestarts <- base::computeRestarts
[17:39:34.118]                           grepl <- base::grepl
[17:39:34.118]                           restarts <- computeRestarts(cond)
[17:39:34.118]                           for (restart in restarts) {
[17:39:34.118]                             name <- restart$name
[17:39:34.118]                             if (is.null(name)) 
[17:39:34.118]                               next
[17:39:34.118]                             if (!grepl(pattern, name)) 
[17:39:34.118]                               next
[17:39:34.118]                             invokeRestart(restart)
[17:39:34.118]                             muffled <- TRUE
[17:39:34.118]                             break
[17:39:34.118]                           }
[17:39:34.118]                         }
[17:39:34.118]                       }
[17:39:34.118]                       invisible(muffled)
[17:39:34.118]                     }
[17:39:34.118]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.118]                   }
[17:39:34.118]                 }
[17:39:34.118]             }
[17:39:34.118]         }))
[17:39:34.118]     }, error = function(ex) {
[17:39:34.118]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.118]                 ...future.rng), started = ...future.startTime, 
[17:39:34.118]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.118]             version = "1.8"), class = "FutureResult")
[17:39:34.118]     }, finally = {
[17:39:34.118]         if (!identical(...future.workdir, getwd())) 
[17:39:34.118]             setwd(...future.workdir)
[17:39:34.118]         {
[17:39:34.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.118]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.118]             }
[17:39:34.118]             base::options(...future.oldOptions)
[17:39:34.118]             if (.Platform$OS.type == "windows") {
[17:39:34.118]                 old_names <- names(...future.oldEnvVars)
[17:39:34.118]                 envs <- base::Sys.getenv()
[17:39:34.118]                 names <- names(envs)
[17:39:34.118]                 common <- intersect(names, old_names)
[17:39:34.118]                 added <- setdiff(names, old_names)
[17:39:34.118]                 removed <- setdiff(old_names, names)
[17:39:34.118]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.118]                   envs[common]]
[17:39:34.118]                 NAMES <- toupper(changed)
[17:39:34.118]                 args <- list()
[17:39:34.118]                 for (kk in seq_along(NAMES)) {
[17:39:34.118]                   name <- changed[[kk]]
[17:39:34.118]                   NAME <- NAMES[[kk]]
[17:39:34.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.118]                     next
[17:39:34.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.118]                 }
[17:39:34.118]                 NAMES <- toupper(added)
[17:39:34.118]                 for (kk in seq_along(NAMES)) {
[17:39:34.118]                   name <- added[[kk]]
[17:39:34.118]                   NAME <- NAMES[[kk]]
[17:39:34.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.118]                     next
[17:39:34.118]                   args[[name]] <- ""
[17:39:34.118]                 }
[17:39:34.118]                 NAMES <- toupper(removed)
[17:39:34.118]                 for (kk in seq_along(NAMES)) {
[17:39:34.118]                   name <- removed[[kk]]
[17:39:34.118]                   NAME <- NAMES[[kk]]
[17:39:34.118]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.118]                     next
[17:39:34.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.118]                 }
[17:39:34.118]                 if (length(args) > 0) 
[17:39:34.118]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.118]             }
[17:39:34.118]             else {
[17:39:34.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.118]             }
[17:39:34.118]             {
[17:39:34.118]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.118]                   0L) {
[17:39:34.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.118]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.118]                   base::options(opts)
[17:39:34.118]                 }
[17:39:34.118]                 {
[17:39:34.118]                   {
[17:39:34.118]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.118]                     NULL
[17:39:34.118]                   }
[17:39:34.118]                   options(future.plan = NULL)
[17:39:34.118]                   if (is.na(NA_character_)) 
[17:39:34.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.118]                     .init = FALSE)
[17:39:34.118]                 }
[17:39:34.118]             }
[17:39:34.118]         }
[17:39:34.118]     })
[17:39:34.118]     if (TRUE) {
[17:39:34.118]         base::sink(type = "output", split = FALSE)
[17:39:34.118]         if (TRUE) {
[17:39:34.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.118]         }
[17:39:34.118]         else {
[17:39:34.118]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.118]         }
[17:39:34.118]         base::close(...future.stdout)
[17:39:34.118]         ...future.stdout <- NULL
[17:39:34.118]     }
[17:39:34.118]     ...future.result$conditions <- ...future.conditions
[17:39:34.118]     ...future.result$finished <- base::Sys.time()
[17:39:34.118]     ...future.result
[17:39:34.118] }
[17:39:34.120] requestCore(): workers = 2
[17:39:34.123] MulticoreFuture started
[17:39:34.124] - Launch lazy future ... done
[17:39:34.124] plan(): Setting new future strategy stack:
[17:39:34.124] run() for ‘MulticoreFuture’ ... done
[17:39:34.124] getGlobalsAndPackages() ...
[17:39:34.124] Searching for globals...
[17:39:34.124] List of future strategies:
[17:39:34.124] 1. sequential:
[17:39:34.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.124]    - tweaked: FALSE
[17:39:34.124]    - call: NULL
[17:39:34.125] plan(): nbrOfWorkers() = 1
[17:39:34.126] 
[17:39:34.126] Searching for globals ... DONE
[17:39:34.126] - globals: [0] <none>
[17:39:34.126] getGlobalsAndPackages() ... DONE
[17:39:34.127] run() for ‘Future’ ...
[17:39:34.127] - state: ‘created’
[17:39:34.127] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.127] plan(): Setting new future strategy stack:
[17:39:34.127] List of future strategies:
[17:39:34.127] 1. multicore:
[17:39:34.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.127]    - tweaked: FALSE
[17:39:34.127]    - call: plan(strategy)
[17:39:34.132] plan(): nbrOfWorkers() = 2
[17:39:34.132] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.132]   - Field: ‘label’
[17:39:34.133]   - Field: ‘local’
[17:39:34.133]   - Field: ‘owner’
[17:39:34.133]   - Field: ‘envir’
[17:39:34.133]   - Field: ‘workers’
[17:39:34.133]   - Field: ‘packages’
[17:39:34.133]   - Field: ‘gc’
[17:39:34.133]   - Field: ‘job’
[17:39:34.134]   - Field: ‘conditions’
[17:39:34.134]   - Field: ‘expr’
[17:39:34.134]   - Field: ‘uuid’
[17:39:34.134]   - Field: ‘seed’
[17:39:34.134]   - Field: ‘version’
[17:39:34.134]   - Field: ‘result’
[17:39:34.134]   - Field: ‘asynchronous’
[17:39:34.134]   - Field: ‘calls’
[17:39:34.135]   - Field: ‘globals’
[17:39:34.135]   - Field: ‘stdout’
[17:39:34.135]   - Field: ‘earlySignal’
[17:39:34.135]   - Field: ‘lazy’
[17:39:34.135]   - Field: ‘state’
[17:39:34.135] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.135] - Launch lazy future ...
[17:39:34.136] Packages needed by the future expression (n = 0): <none>
[17:39:34.136] Packages needed by future strategies (n = 0): <none>
[17:39:34.137] {
[17:39:34.137]     {
[17:39:34.137]         {
[17:39:34.137]             ...future.startTime <- base::Sys.time()
[17:39:34.137]             {
[17:39:34.137]                 {
[17:39:34.137]                   {
[17:39:34.137]                     {
[17:39:34.137]                       base::local({
[17:39:34.137]                         has_future <- base::requireNamespace("future", 
[17:39:34.137]                           quietly = TRUE)
[17:39:34.137]                         if (has_future) {
[17:39:34.137]                           ns <- base::getNamespace("future")
[17:39:34.137]                           version <- ns[[".package"]][["version"]]
[17:39:34.137]                           if (is.null(version)) 
[17:39:34.137]                             version <- utils::packageVersion("future")
[17:39:34.137]                         }
[17:39:34.137]                         else {
[17:39:34.137]                           version <- NULL
[17:39:34.137]                         }
[17:39:34.137]                         if (!has_future || version < "1.8.0") {
[17:39:34.137]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.137]                             "", base::R.version$version.string), 
[17:39:34.137]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.137]                               "release", "version")], collapse = " "), 
[17:39:34.137]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.137]                             info)
[17:39:34.137]                           info <- base::paste(info, collapse = "; ")
[17:39:34.137]                           if (!has_future) {
[17:39:34.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.137]                               info)
[17:39:34.137]                           }
[17:39:34.137]                           else {
[17:39:34.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.137]                               info, version)
[17:39:34.137]                           }
[17:39:34.137]                           base::stop(msg)
[17:39:34.137]                         }
[17:39:34.137]                       })
[17:39:34.137]                     }
[17:39:34.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.137]                     base::options(mc.cores = 1L)
[17:39:34.137]                   }
[17:39:34.137]                   ...future.strategy.old <- future::plan("list")
[17:39:34.137]                   options(future.plan = NULL)
[17:39:34.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.137]                 }
[17:39:34.137]                 ...future.workdir <- getwd()
[17:39:34.137]             }
[17:39:34.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.137]         }
[17:39:34.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.137]             base::names(...future.oldOptions))
[17:39:34.137]     }
[17:39:34.137]     if (FALSE) {
[17:39:34.137]     }
[17:39:34.137]     else {
[17:39:34.137]         if (TRUE) {
[17:39:34.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.137]                 open = "w")
[17:39:34.137]         }
[17:39:34.137]         else {
[17:39:34.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.137]         }
[17:39:34.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.137]             base::sink(type = "output", split = FALSE)
[17:39:34.137]             base::close(...future.stdout)
[17:39:34.137]         }, add = TRUE)
[17:39:34.137]     }
[17:39:34.137]     ...future.frame <- base::sys.nframe()
[17:39:34.137]     ...future.conditions <- base::list()
[17:39:34.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.137]     if (FALSE) {
[17:39:34.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.137]     }
[17:39:34.137]     ...future.result <- base::tryCatch({
[17:39:34.137]         base::withCallingHandlers({
[17:39:34.137]             ...future.value <- base::withVisible(base::local({
[17:39:34.137]                 withCallingHandlers({
[17:39:34.137]                   NULL
[17:39:34.137]                 }, immediateCondition = function(cond) {
[17:39:34.137]                   save_rds <- function (object, pathname, ...) 
[17:39:34.137]                   {
[17:39:34.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.137]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.137]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.137]                         fi_tmp[["mtime"]])
[17:39:34.137]                     }
[17:39:34.137]                     tryCatch({
[17:39:34.137]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.137]                     }, error = function(ex) {
[17:39:34.137]                       msg <- conditionMessage(ex)
[17:39:34.137]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.137]                         fi_tmp[["mtime"]], msg)
[17:39:34.137]                       ex$message <- msg
[17:39:34.137]                       stop(ex)
[17:39:34.137]                     })
[17:39:34.137]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.137]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.137]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.137]                       fi <- file.info(pathname)
[17:39:34.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.137]                         fi[["size"]], fi[["mtime"]])
[17:39:34.137]                       stop(msg)
[17:39:34.137]                     }
[17:39:34.137]                     invisible(pathname)
[17:39:34.137]                   }
[17:39:34.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.137]                     rootPath = tempdir()) 
[17:39:34.137]                   {
[17:39:34.137]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.137]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.137]                       tmpdir = path, fileext = ".rds")
[17:39:34.137]                     save_rds(obj, file)
[17:39:34.137]                   }
[17:39:34.137]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.137]                   {
[17:39:34.137]                     inherits <- base::inherits
[17:39:34.137]                     invokeRestart <- base::invokeRestart
[17:39:34.137]                     is.null <- base::is.null
[17:39:34.137]                     muffled <- FALSE
[17:39:34.137]                     if (inherits(cond, "message")) {
[17:39:34.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.137]                       if (muffled) 
[17:39:34.137]                         invokeRestart("muffleMessage")
[17:39:34.137]                     }
[17:39:34.137]                     else if (inherits(cond, "warning")) {
[17:39:34.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.137]                       if (muffled) 
[17:39:34.137]                         invokeRestart("muffleWarning")
[17:39:34.137]                     }
[17:39:34.137]                     else if (inherits(cond, "condition")) {
[17:39:34.137]                       if (!is.null(pattern)) {
[17:39:34.137]                         computeRestarts <- base::computeRestarts
[17:39:34.137]                         grepl <- base::grepl
[17:39:34.137]                         restarts <- computeRestarts(cond)
[17:39:34.137]                         for (restart in restarts) {
[17:39:34.137]                           name <- restart$name
[17:39:34.137]                           if (is.null(name)) 
[17:39:34.137]                             next
[17:39:34.137]                           if (!grepl(pattern, name)) 
[17:39:34.137]                             next
[17:39:34.137]                           invokeRestart(restart)
[17:39:34.137]                           muffled <- TRUE
[17:39:34.137]                           break
[17:39:34.137]                         }
[17:39:34.137]                       }
[17:39:34.137]                     }
[17:39:34.137]                     invisible(muffled)
[17:39:34.137]                   }
[17:39:34.137]                   muffleCondition(cond)
[17:39:34.137]                 })
[17:39:34.137]             }))
[17:39:34.137]             future::FutureResult(value = ...future.value$value, 
[17:39:34.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.137]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.137]                     ...future.globalenv.names))
[17:39:34.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.137]         }, condition = base::local({
[17:39:34.137]             c <- base::c
[17:39:34.137]             inherits <- base::inherits
[17:39:34.137]             invokeRestart <- base::invokeRestart
[17:39:34.137]             length <- base::length
[17:39:34.137]             list <- base::list
[17:39:34.137]             seq.int <- base::seq.int
[17:39:34.137]             signalCondition <- base::signalCondition
[17:39:34.137]             sys.calls <- base::sys.calls
[17:39:34.137]             `[[` <- base::`[[`
[17:39:34.137]             `+` <- base::`+`
[17:39:34.137]             `<<-` <- base::`<<-`
[17:39:34.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.137]                   3L)]
[17:39:34.137]             }
[17:39:34.137]             function(cond) {
[17:39:34.137]                 is_error <- inherits(cond, "error")
[17:39:34.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.137]                   NULL)
[17:39:34.137]                 if (is_error) {
[17:39:34.137]                   sessionInformation <- function() {
[17:39:34.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.137]                       search = base::search(), system = base::Sys.info())
[17:39:34.137]                   }
[17:39:34.137]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.137]                     cond$call), session = sessionInformation(), 
[17:39:34.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.137]                   signalCondition(cond)
[17:39:34.137]                 }
[17:39:34.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.137]                 "immediateCondition"))) {
[17:39:34.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.137]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.137]                   if (TRUE && !signal) {
[17:39:34.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.137]                     {
[17:39:34.137]                       inherits <- base::inherits
[17:39:34.137]                       invokeRestart <- base::invokeRestart
[17:39:34.137]                       is.null <- base::is.null
[17:39:34.137]                       muffled <- FALSE
[17:39:34.137]                       if (inherits(cond, "message")) {
[17:39:34.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.137]                         if (muffled) 
[17:39:34.137]                           invokeRestart("muffleMessage")
[17:39:34.137]                       }
[17:39:34.137]                       else if (inherits(cond, "warning")) {
[17:39:34.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.137]                         if (muffled) 
[17:39:34.137]                           invokeRestart("muffleWarning")
[17:39:34.137]                       }
[17:39:34.137]                       else if (inherits(cond, "condition")) {
[17:39:34.137]                         if (!is.null(pattern)) {
[17:39:34.137]                           computeRestarts <- base::computeRestarts
[17:39:34.137]                           grepl <- base::grepl
[17:39:34.137]                           restarts <- computeRestarts(cond)
[17:39:34.137]                           for (restart in restarts) {
[17:39:34.137]                             name <- restart$name
[17:39:34.137]                             if (is.null(name)) 
[17:39:34.137]                               next
[17:39:34.137]                             if (!grepl(pattern, name)) 
[17:39:34.137]                               next
[17:39:34.137]                             invokeRestart(restart)
[17:39:34.137]                             muffled <- TRUE
[17:39:34.137]                             break
[17:39:34.137]                           }
[17:39:34.137]                         }
[17:39:34.137]                       }
[17:39:34.137]                       invisible(muffled)
[17:39:34.137]                     }
[17:39:34.137]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.137]                   }
[17:39:34.137]                 }
[17:39:34.137]                 else {
[17:39:34.137]                   if (TRUE) {
[17:39:34.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.137]                     {
[17:39:34.137]                       inherits <- base::inherits
[17:39:34.137]                       invokeRestart <- base::invokeRestart
[17:39:34.137]                       is.null <- base::is.null
[17:39:34.137]                       muffled <- FALSE
[17:39:34.137]                       if (inherits(cond, "message")) {
[17:39:34.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.137]                         if (muffled) 
[17:39:34.137]                           invokeRestart("muffleMessage")
[17:39:34.137]                       }
[17:39:34.137]                       else if (inherits(cond, "warning")) {
[17:39:34.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.137]                         if (muffled) 
[17:39:34.137]                           invokeRestart("muffleWarning")
[17:39:34.137]                       }
[17:39:34.137]                       else if (inherits(cond, "condition")) {
[17:39:34.137]                         if (!is.null(pattern)) {
[17:39:34.137]                           computeRestarts <- base::computeRestarts
[17:39:34.137]                           grepl <- base::grepl
[17:39:34.137]                           restarts <- computeRestarts(cond)
[17:39:34.137]                           for (restart in restarts) {
[17:39:34.137]                             name <- restart$name
[17:39:34.137]                             if (is.null(name)) 
[17:39:34.137]                               next
[17:39:34.137]                             if (!grepl(pattern, name)) 
[17:39:34.137]                               next
[17:39:34.137]                             invokeRestart(restart)
[17:39:34.137]                             muffled <- TRUE
[17:39:34.137]                             break
[17:39:34.137]                           }
[17:39:34.137]                         }
[17:39:34.137]                       }
[17:39:34.137]                       invisible(muffled)
[17:39:34.137]                     }
[17:39:34.137]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.137]                   }
[17:39:34.137]                 }
[17:39:34.137]             }
[17:39:34.137]         }))
[17:39:34.137]     }, error = function(ex) {
[17:39:34.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.137]                 ...future.rng), started = ...future.startTime, 
[17:39:34.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.137]             version = "1.8"), class = "FutureResult")
[17:39:34.137]     }, finally = {
[17:39:34.137]         if (!identical(...future.workdir, getwd())) 
[17:39:34.137]             setwd(...future.workdir)
[17:39:34.137]         {
[17:39:34.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.137]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.137]             }
[17:39:34.137]             base::options(...future.oldOptions)
[17:39:34.137]             if (.Platform$OS.type == "windows") {
[17:39:34.137]                 old_names <- names(...future.oldEnvVars)
[17:39:34.137]                 envs <- base::Sys.getenv()
[17:39:34.137]                 names <- names(envs)
[17:39:34.137]                 common <- intersect(names, old_names)
[17:39:34.137]                 added <- setdiff(names, old_names)
[17:39:34.137]                 removed <- setdiff(old_names, names)
[17:39:34.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.137]                   envs[common]]
[17:39:34.137]                 NAMES <- toupper(changed)
[17:39:34.137]                 args <- list()
[17:39:34.137]                 for (kk in seq_along(NAMES)) {
[17:39:34.137]                   name <- changed[[kk]]
[17:39:34.137]                   NAME <- NAMES[[kk]]
[17:39:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.137]                     next
[17:39:34.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.137]                 }
[17:39:34.137]                 NAMES <- toupper(added)
[17:39:34.137]                 for (kk in seq_along(NAMES)) {
[17:39:34.137]                   name <- added[[kk]]
[17:39:34.137]                   NAME <- NAMES[[kk]]
[17:39:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.137]                     next
[17:39:34.137]                   args[[name]] <- ""
[17:39:34.137]                 }
[17:39:34.137]                 NAMES <- toupper(removed)
[17:39:34.137]                 for (kk in seq_along(NAMES)) {
[17:39:34.137]                   name <- removed[[kk]]
[17:39:34.137]                   NAME <- NAMES[[kk]]
[17:39:34.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.137]                     next
[17:39:34.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.137]                 }
[17:39:34.137]                 if (length(args) > 0) 
[17:39:34.137]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.137]             }
[17:39:34.137]             else {
[17:39:34.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.137]             }
[17:39:34.137]             {
[17:39:34.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.137]                   0L) {
[17:39:34.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.137]                   base::options(opts)
[17:39:34.137]                 }
[17:39:34.137]                 {
[17:39:34.137]                   {
[17:39:34.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.137]                     NULL
[17:39:34.137]                   }
[17:39:34.137]                   options(future.plan = NULL)
[17:39:34.137]                   if (is.na(NA_character_)) 
[17:39:34.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.137]                     .init = FALSE)
[17:39:34.137]                 }
[17:39:34.137]             }
[17:39:34.137]         }
[17:39:34.137]     })
[17:39:34.137]     if (TRUE) {
[17:39:34.137]         base::sink(type = "output", split = FALSE)
[17:39:34.137]         if (TRUE) {
[17:39:34.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.137]         }
[17:39:34.137]         else {
[17:39:34.137]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.137]         }
[17:39:34.137]         base::close(...future.stdout)
[17:39:34.137]         ...future.stdout <- NULL
[17:39:34.137]     }
[17:39:34.137]     ...future.result$conditions <- ...future.conditions
[17:39:34.137]     ...future.result$finished <- base::Sys.time()
[17:39:34.137]     ...future.result
[17:39:34.137] }
[17:39:34.140] requestCore(): workers = 2
[17:39:34.152] MulticoreFuture started
[17:39:34.152] - Launch lazy future ... done
[17:39:34.153] run() for ‘MulticoreFuture’ ... done
[17:39:34.153] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:39:34.153] List of future strategies:
[17:39:34.153] 1. sequential:
[17:39:34.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.153]    - tweaked: FALSE
[17:39:34.153]    - call: NULL
[17:39:34.155] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefc2c910> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf02664e0> 
 $  : NULL
 $  :[17:39:34.157] plan(): Setting new future strategy stack:
 NULL
 $  :[17:39:34.158] List of future strategies:
[17:39:34.158] 1. multicore:
[17:39:34.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.158]    - tweaked: FALSE
[17:39:34.158]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefc2c910> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf02664e0> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:39:34.163] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:34.165] resolve() on list ...
[17:39:34.165]  recursive: 0
[17:39:34.165]  length: 6
[17:39:34.165]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:34.165] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.166] - nx: 6
[17:39:34.166] - relay: TRUE
[17:39:34.166] - stdout: TRUE
[17:39:34.166] - signal: TRUE
[17:39:34.166] - resignal: FALSE
[17:39:34.166] - force: TRUE
[17:39:34.166] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.166] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.167]  - until=2
[17:39:34.167]  - relaying element #2
[17:39:34.167] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.167] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.167] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.167]  length: 5 (resolved future 1)
[17:39:34.168] Future #2
[17:39:34.168] result() for MulticoreFuture ...
[17:39:34.170] result() for MulticoreFuture ...
[17:39:34.170] result() for MulticoreFuture ... done
[17:39:34.170] result() for MulticoreFuture ... done
[17:39:34.170] result() for MulticoreFuture ...
[17:39:34.171] result() for MulticoreFuture ... done
[17:39:34.171] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:34.171] - nx: 6
[17:39:34.171] - relay: TRUE
[17:39:34.171] - stdout: TRUE
[17:39:34.171] - signal: TRUE
[17:39:34.171] - resignal: FALSE
[17:39:34.172] - force: TRUE
[17:39:34.172] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.172] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.172]  - until=2
[17:39:34.172]  - relaying element #2
[17:39:34.172] result() for MulticoreFuture ...
[17:39:34.172] result() for MulticoreFuture ... done
[17:39:34.173] result() for MulticoreFuture ...
[17:39:34.173] result() for MulticoreFuture ... done
[17:39:34.173] result() for MulticoreFuture ...
[17:39:34.173] result() for MulticoreFuture ... done
[17:39:34.173] result() for MulticoreFuture ...
[17:39:34.173] result() for MulticoreFuture ... done
[17:39:34.173] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.173] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.174] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:34.174]  length: 4 (resolved future 2)
[17:39:34.174] Future #3
[17:39:34.174] result() for MulticoreFuture ...
[17:39:34.175] result() for MulticoreFuture ...
[17:39:34.175] result() for MulticoreFuture ... done
[17:39:34.175] result() for MulticoreFuture ... done
[17:39:34.175] result() for MulticoreFuture ...
[17:39:34.175] result() for MulticoreFuture ... done
[17:39:34.176] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:34.176] - nx: 6
[17:39:34.176] - relay: TRUE
[17:39:34.176] - stdout: TRUE
[17:39:34.176] - signal: TRUE
[17:39:34.176] - resignal: FALSE
[17:39:34.176] - force: TRUE
[17:39:34.176] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.176] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.177]  - until=3
[17:39:34.177]  - relaying element #3
[17:39:34.177] result() for MulticoreFuture ...
[17:39:34.177] result() for MulticoreFuture ... done
[17:39:34.177] result() for MulticoreFuture ...
[17:39:34.177] result() for MulticoreFuture ... done
[17:39:34.177] result() for MulticoreFuture ...
[17:39:34.177] result() for MulticoreFuture ... done
[17:39:34.178] result() for MulticoreFuture ...
[17:39:34.178] result() for MulticoreFuture ... done
[17:39:34.178] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.178] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.178] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:34.178]  length: 3 (resolved future 3)
[17:39:34.178] signalConditionsASAP(NULL, pos=4) ...
[17:39:34.178] - nx: 6
[17:39:34.178] - relay: TRUE
[17:39:34.178] - stdout: TRUE
[17:39:34.179] - signal: TRUE
[17:39:34.179] - resignal: FALSE
[17:39:34.179] - force: TRUE
[17:39:34.179] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.179] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.179]  - until=5
[17:39:34.179]  - relaying element #5
[17:39:34.179] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.179] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.179] signalConditionsASAP(NULL, pos=4) ... done
[17:39:34.180]  length: 2 (resolved future 4)
[17:39:34.180] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.180] - nx: 6
[17:39:34.180] - relay: TRUE
[17:39:34.180] - stdout: TRUE
[17:39:34.180] - signal: TRUE
[17:39:34.180] - resignal: FALSE
[17:39:34.180] - force: TRUE
[17:39:34.180] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.180] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.181]  - until=6
[17:39:34.181]  - relaying element #6
[17:39:34.181] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.181] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.181] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.181]  length: 1 (resolved future 5)
[17:39:34.181] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.181] - nx: 6
[17:39:34.181] - relay: TRUE
[17:39:34.181] - stdout: TRUE
[17:39:34.182] - signal: TRUE
[17:39:34.182] - resignal: FALSE
[17:39:34.182] - force: TRUE
[17:39:34.182] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.182] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.182]  - until=6
[17:39:34.182] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.182] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.182] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.182]  length: 0 (resolved future 6)
[17:39:34.183] Relaying remaining futures
[17:39:34.183] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.183] - nx: 6
[17:39:34.183] - relay: TRUE
[17:39:34.183] - stdout: TRUE
[17:39:34.183] - signal: TRUE
[17:39:34.183] - resignal: FALSE
[17:39:34.183] - force: TRUE
[17:39:34.183] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:34.184] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.184] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.184] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.184] resolve() on list ... DONE
[17:39:34.184] result() for MulticoreFuture ...
[17:39:34.184] result() for MulticoreFuture ... done
[17:39:34.184] result() for MulticoreFuture ...
[17:39:34.184] result() for MulticoreFuture ... done
[17:39:34.184] result() for MulticoreFuture ...
[17:39:34.185] result() for MulticoreFuture ... done
[17:39:34.185] result() for MulticoreFuture ...
[17:39:34.185] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:39:34.187] getGlobalsAndPackages() ...
[17:39:34.187] Searching for globals...
[17:39:34.188] 
[17:39:34.188] Searching for globals ... DONE
[17:39:34.188] - globals: [0] <none>
[17:39:34.188] getGlobalsAndPackages() ... DONE
[17:39:34.188] run() for ‘Future’ ...
[17:39:34.189] - state: ‘created’
[17:39:34.189] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.195] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.195] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.196]   - Field: ‘label’
[17:39:34.196]   - Field: ‘local’
[17:39:34.196]   - Field: ‘owner’
[17:39:34.196]   - Field: ‘envir’
[17:39:34.196]   - Field: ‘workers’
[17:39:34.196]   - Field: ‘packages’
[17:39:34.197]   - Field: ‘gc’
[17:39:34.197]   - Field: ‘job’
[17:39:34.197]   - Field: ‘conditions’
[17:39:34.197]   - Field: ‘expr’
[17:39:34.197]   - Field: ‘uuid’
[17:39:34.197]   - Field: ‘seed’
[17:39:34.197]   - Field: ‘version’
[17:39:34.197]   - Field: ‘result’
[17:39:34.197]   - Field: ‘asynchronous’
[17:39:34.198]   - Field: ‘calls’
[17:39:34.198]   - Field: ‘globals’
[17:39:34.198]   - Field: ‘stdout’
[17:39:34.198]   - Field: ‘earlySignal’
[17:39:34.198]   - Field: ‘lazy’
[17:39:34.198]   - Field: ‘state’
[17:39:34.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.198] - Launch lazy future ...
[17:39:34.198] Packages needed by the future expression (n = 0): <none>
[17:39:34.199] Packages needed by future strategies (n = 0): <none>
[17:39:34.199] {
[17:39:34.199]     {
[17:39:34.199]         {
[17:39:34.199]             ...future.startTime <- base::Sys.time()
[17:39:34.199]             {
[17:39:34.199]                 {
[17:39:34.199]                   {
[17:39:34.199]                     {
[17:39:34.199]                       base::local({
[17:39:34.199]                         has_future <- base::requireNamespace("future", 
[17:39:34.199]                           quietly = TRUE)
[17:39:34.199]                         if (has_future) {
[17:39:34.199]                           ns <- base::getNamespace("future")
[17:39:34.199]                           version <- ns[[".package"]][["version"]]
[17:39:34.199]                           if (is.null(version)) 
[17:39:34.199]                             version <- utils::packageVersion("future")
[17:39:34.199]                         }
[17:39:34.199]                         else {
[17:39:34.199]                           version <- NULL
[17:39:34.199]                         }
[17:39:34.199]                         if (!has_future || version < "1.8.0") {
[17:39:34.199]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.199]                             "", base::R.version$version.string), 
[17:39:34.199]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.199]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.199]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.199]                               "release", "version")], collapse = " "), 
[17:39:34.199]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.199]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.199]                             info)
[17:39:34.199]                           info <- base::paste(info, collapse = "; ")
[17:39:34.199]                           if (!has_future) {
[17:39:34.199]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.199]                               info)
[17:39:34.199]                           }
[17:39:34.199]                           else {
[17:39:34.199]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.199]                               info, version)
[17:39:34.199]                           }
[17:39:34.199]                           base::stop(msg)
[17:39:34.199]                         }
[17:39:34.199]                       })
[17:39:34.199]                     }
[17:39:34.199]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.199]                     base::options(mc.cores = 1L)
[17:39:34.199]                   }
[17:39:34.199]                   ...future.strategy.old <- future::plan("list")
[17:39:34.199]                   options(future.plan = NULL)
[17:39:34.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.199]                 }
[17:39:34.199]                 ...future.workdir <- getwd()
[17:39:34.199]             }
[17:39:34.199]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.199]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.199]         }
[17:39:34.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.199]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.199]             base::names(...future.oldOptions))
[17:39:34.199]     }
[17:39:34.199]     if (FALSE) {
[17:39:34.199]     }
[17:39:34.199]     else {
[17:39:34.199]         if (TRUE) {
[17:39:34.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.199]                 open = "w")
[17:39:34.199]         }
[17:39:34.199]         else {
[17:39:34.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.199]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.199]         }
[17:39:34.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.199]             base::sink(type = "output", split = FALSE)
[17:39:34.199]             base::close(...future.stdout)
[17:39:34.199]         }, add = TRUE)
[17:39:34.199]     }
[17:39:34.199]     ...future.frame <- base::sys.nframe()
[17:39:34.199]     ...future.conditions <- base::list()
[17:39:34.199]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.199]     if (FALSE) {
[17:39:34.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.199]     }
[17:39:34.199]     ...future.result <- base::tryCatch({
[17:39:34.199]         base::withCallingHandlers({
[17:39:34.199]             ...future.value <- base::withVisible(base::local({
[17:39:34.199]                 withCallingHandlers({
[17:39:34.199]                   2
[17:39:34.199]                 }, immediateCondition = function(cond) {
[17:39:34.199]                   save_rds <- function (object, pathname, ...) 
[17:39:34.199]                   {
[17:39:34.199]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.199]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.199]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.199]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.199]                         fi_tmp[["mtime"]])
[17:39:34.199]                     }
[17:39:34.199]                     tryCatch({
[17:39:34.199]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.199]                     }, error = function(ex) {
[17:39:34.199]                       msg <- conditionMessage(ex)
[17:39:34.199]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.199]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.199]                         fi_tmp[["mtime"]], msg)
[17:39:34.199]                       ex$message <- msg
[17:39:34.199]                       stop(ex)
[17:39:34.199]                     })
[17:39:34.199]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.199]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.199]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.199]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.199]                       fi <- file.info(pathname)
[17:39:34.199]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.199]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.199]                         fi[["size"]], fi[["mtime"]])
[17:39:34.199]                       stop(msg)
[17:39:34.199]                     }
[17:39:34.199]                     invisible(pathname)
[17:39:34.199]                   }
[17:39:34.199]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.199]                     rootPath = tempdir()) 
[17:39:34.199]                   {
[17:39:34.199]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.199]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.199]                       tmpdir = path, fileext = ".rds")
[17:39:34.199]                     save_rds(obj, file)
[17:39:34.199]                   }
[17:39:34.199]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.199]                   {
[17:39:34.199]                     inherits <- base::inherits
[17:39:34.199]                     invokeRestart <- base::invokeRestart
[17:39:34.199]                     is.null <- base::is.null
[17:39:34.199]                     muffled <- FALSE
[17:39:34.199]                     if (inherits(cond, "message")) {
[17:39:34.199]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.199]                       if (muffled) 
[17:39:34.199]                         invokeRestart("muffleMessage")
[17:39:34.199]                     }
[17:39:34.199]                     else if (inherits(cond, "warning")) {
[17:39:34.199]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.199]                       if (muffled) 
[17:39:34.199]                         invokeRestart("muffleWarning")
[17:39:34.199]                     }
[17:39:34.199]                     else if (inherits(cond, "condition")) {
[17:39:34.199]                       if (!is.null(pattern)) {
[17:39:34.199]                         computeRestarts <- base::computeRestarts
[17:39:34.199]                         grepl <- base::grepl
[17:39:34.199]                         restarts <- computeRestarts(cond)
[17:39:34.199]                         for (restart in restarts) {
[17:39:34.199]                           name <- restart$name
[17:39:34.199]                           if (is.null(name)) 
[17:39:34.199]                             next
[17:39:34.199]                           if (!grepl(pattern, name)) 
[17:39:34.199]                             next
[17:39:34.199]                           invokeRestart(restart)
[17:39:34.199]                           muffled <- TRUE
[17:39:34.199]                           break
[17:39:34.199]                         }
[17:39:34.199]                       }
[17:39:34.199]                     }
[17:39:34.199]                     invisible(muffled)
[17:39:34.199]                   }
[17:39:34.199]                   muffleCondition(cond)
[17:39:34.199]                 })
[17:39:34.199]             }))
[17:39:34.199]             future::FutureResult(value = ...future.value$value, 
[17:39:34.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.199]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.199]                     ...future.globalenv.names))
[17:39:34.199]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.199]         }, condition = base::local({
[17:39:34.199]             c <- base::c
[17:39:34.199]             inherits <- base::inherits
[17:39:34.199]             invokeRestart <- base::invokeRestart
[17:39:34.199]             length <- base::length
[17:39:34.199]             list <- base::list
[17:39:34.199]             seq.int <- base::seq.int
[17:39:34.199]             signalCondition <- base::signalCondition
[17:39:34.199]             sys.calls <- base::sys.calls
[17:39:34.199]             `[[` <- base::`[[`
[17:39:34.199]             `+` <- base::`+`
[17:39:34.199]             `<<-` <- base::`<<-`
[17:39:34.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.199]                   3L)]
[17:39:34.199]             }
[17:39:34.199]             function(cond) {
[17:39:34.199]                 is_error <- inherits(cond, "error")
[17:39:34.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.199]                   NULL)
[17:39:34.199]                 if (is_error) {
[17:39:34.199]                   sessionInformation <- function() {
[17:39:34.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.199]                       search = base::search(), system = base::Sys.info())
[17:39:34.199]                   }
[17:39:34.199]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.199]                     cond$call), session = sessionInformation(), 
[17:39:34.199]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.199]                   signalCondition(cond)
[17:39:34.199]                 }
[17:39:34.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.199]                 "immediateCondition"))) {
[17:39:34.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.199]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.199]                   if (TRUE && !signal) {
[17:39:34.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.199]                     {
[17:39:34.199]                       inherits <- base::inherits
[17:39:34.199]                       invokeRestart <- base::invokeRestart
[17:39:34.199]                       is.null <- base::is.null
[17:39:34.199]                       muffled <- FALSE
[17:39:34.199]                       if (inherits(cond, "message")) {
[17:39:34.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.199]                         if (muffled) 
[17:39:34.199]                           invokeRestart("muffleMessage")
[17:39:34.199]                       }
[17:39:34.199]                       else if (inherits(cond, "warning")) {
[17:39:34.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.199]                         if (muffled) 
[17:39:34.199]                           invokeRestart("muffleWarning")
[17:39:34.199]                       }
[17:39:34.199]                       else if (inherits(cond, "condition")) {
[17:39:34.199]                         if (!is.null(pattern)) {
[17:39:34.199]                           computeRestarts <- base::computeRestarts
[17:39:34.199]                           grepl <- base::grepl
[17:39:34.199]                           restarts <- computeRestarts(cond)
[17:39:34.199]                           for (restart in restarts) {
[17:39:34.199]                             name <- restart$name
[17:39:34.199]                             if (is.null(name)) 
[17:39:34.199]                               next
[17:39:34.199]                             if (!grepl(pattern, name)) 
[17:39:34.199]                               next
[17:39:34.199]                             invokeRestart(restart)
[17:39:34.199]                             muffled <- TRUE
[17:39:34.199]                             break
[17:39:34.199]                           }
[17:39:34.199]                         }
[17:39:34.199]                       }
[17:39:34.199]                       invisible(muffled)
[17:39:34.199]                     }
[17:39:34.199]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.199]                   }
[17:39:34.199]                 }
[17:39:34.199]                 else {
[17:39:34.199]                   if (TRUE) {
[17:39:34.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.199]                     {
[17:39:34.199]                       inherits <- base::inherits
[17:39:34.199]                       invokeRestart <- base::invokeRestart
[17:39:34.199]                       is.null <- base::is.null
[17:39:34.199]                       muffled <- FALSE
[17:39:34.199]                       if (inherits(cond, "message")) {
[17:39:34.199]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.199]                         if (muffled) 
[17:39:34.199]                           invokeRestart("muffleMessage")
[17:39:34.199]                       }
[17:39:34.199]                       else if (inherits(cond, "warning")) {
[17:39:34.199]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.199]                         if (muffled) 
[17:39:34.199]                           invokeRestart("muffleWarning")
[17:39:34.199]                       }
[17:39:34.199]                       else if (inherits(cond, "condition")) {
[17:39:34.199]                         if (!is.null(pattern)) {
[17:39:34.199]                           computeRestarts <- base::computeRestarts
[17:39:34.199]                           grepl <- base::grepl
[17:39:34.199]                           restarts <- computeRestarts(cond)
[17:39:34.199]                           for (restart in restarts) {
[17:39:34.199]                             name <- restart$name
[17:39:34.199]                             if (is.null(name)) 
[17:39:34.199]                               next
[17:39:34.199]                             if (!grepl(pattern, name)) 
[17:39:34.199]                               next
[17:39:34.199]                             invokeRestart(restart)
[17:39:34.199]                             muffled <- TRUE
[17:39:34.199]                             break
[17:39:34.199]                           }
[17:39:34.199]                         }
[17:39:34.199]                       }
[17:39:34.199]                       invisible(muffled)
[17:39:34.199]                     }
[17:39:34.199]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.199]                   }
[17:39:34.199]                 }
[17:39:34.199]             }
[17:39:34.199]         }))
[17:39:34.199]     }, error = function(ex) {
[17:39:34.199]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.199]                 ...future.rng), started = ...future.startTime, 
[17:39:34.199]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.199]             version = "1.8"), class = "FutureResult")
[17:39:34.199]     }, finally = {
[17:39:34.199]         if (!identical(...future.workdir, getwd())) 
[17:39:34.199]             setwd(...future.workdir)
[17:39:34.199]         {
[17:39:34.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.199]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.199]             }
[17:39:34.199]             base::options(...future.oldOptions)
[17:39:34.199]             if (.Platform$OS.type == "windows") {
[17:39:34.199]                 old_names <- names(...future.oldEnvVars)
[17:39:34.199]                 envs <- base::Sys.getenv()
[17:39:34.199]                 names <- names(envs)
[17:39:34.199]                 common <- intersect(names, old_names)
[17:39:34.199]                 added <- setdiff(names, old_names)
[17:39:34.199]                 removed <- setdiff(old_names, names)
[17:39:34.199]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.199]                   envs[common]]
[17:39:34.199]                 NAMES <- toupper(changed)
[17:39:34.199]                 args <- list()
[17:39:34.199]                 for (kk in seq_along(NAMES)) {
[17:39:34.199]                   name <- changed[[kk]]
[17:39:34.199]                   NAME <- NAMES[[kk]]
[17:39:34.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.199]                     next
[17:39:34.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.199]                 }
[17:39:34.199]                 NAMES <- toupper(added)
[17:39:34.199]                 for (kk in seq_along(NAMES)) {
[17:39:34.199]                   name <- added[[kk]]
[17:39:34.199]                   NAME <- NAMES[[kk]]
[17:39:34.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.199]                     next
[17:39:34.199]                   args[[name]] <- ""
[17:39:34.199]                 }
[17:39:34.199]                 NAMES <- toupper(removed)
[17:39:34.199]                 for (kk in seq_along(NAMES)) {
[17:39:34.199]                   name <- removed[[kk]]
[17:39:34.199]                   NAME <- NAMES[[kk]]
[17:39:34.199]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.199]                     next
[17:39:34.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.199]                 }
[17:39:34.199]                 if (length(args) > 0) 
[17:39:34.199]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.199]             }
[17:39:34.199]             else {
[17:39:34.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.199]             }
[17:39:34.199]             {
[17:39:34.199]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.199]                   0L) {
[17:39:34.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.199]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.199]                   base::options(opts)
[17:39:34.199]                 }
[17:39:34.199]                 {
[17:39:34.199]                   {
[17:39:34.199]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.199]                     NULL
[17:39:34.199]                   }
[17:39:34.199]                   options(future.plan = NULL)
[17:39:34.199]                   if (is.na(NA_character_)) 
[17:39:34.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.199]                     .init = FALSE)
[17:39:34.199]                 }
[17:39:34.199]             }
[17:39:34.199]         }
[17:39:34.199]     })
[17:39:34.199]     if (TRUE) {
[17:39:34.199]         base::sink(type = "output", split = FALSE)
[17:39:34.199]         if (TRUE) {
[17:39:34.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.199]         }
[17:39:34.199]         else {
[17:39:34.199]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.199]         }
[17:39:34.199]         base::close(...future.stdout)
[17:39:34.199]         ...future.stdout <- NULL
[17:39:34.199]     }
[17:39:34.199]     ...future.result$conditions <- ...future.conditions
[17:39:34.199]     ...future.result$finished <- base::Sys.time()
[17:39:34.199]     ...future.result
[17:39:34.199] }
[17:39:34.202] requestCore(): workers = 2
[17:39:34.204] MulticoreFuture started
[17:39:34.204] - Launch lazy future ... done
[17:39:34.204] run() for ‘MulticoreFuture’ ... done
[17:39:34.205] getGlobalsAndPackages() ...
[17:39:34.205] plan(): Setting new future strategy stack:
[17:39:34.205] Searching for globals...
[17:39:34.205] List of future strategies:
[17:39:34.205] 1. sequential:
[17:39:34.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.205]    - tweaked: FALSE
[17:39:34.205]    - call: NULL
[17:39:34.206] 
[17:39:34.206] Searching for globals ... DONE
[17:39:34.206] plan(): nbrOfWorkers() = 1
[17:39:34.206] - globals: [0] <none>
[17:39:34.207] getGlobalsAndPackages() ... DONE
[17:39:34.207] run() for ‘Future’ ...
[17:39:34.207] - state: ‘created’
[17:39:34.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.208] plan(): Setting new future strategy stack:
[17:39:34.208] List of future strategies:
[17:39:34.208] 1. multicore:
[17:39:34.208]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.208]    - tweaked: FALSE
[17:39:34.208]    - call: plan(strategy)
[17:39:34.213] plan(): nbrOfWorkers() = 2
[17:39:34.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.213]   - Field: ‘label’
[17:39:34.213]   - Field: ‘local’
[17:39:34.214]   - Field: ‘owner’
[17:39:34.214]   - Field: ‘envir’
[17:39:34.214]   - Field: ‘workers’
[17:39:34.214]   - Field: ‘packages’
[17:39:34.214]   - Field: ‘gc’
[17:39:34.214]   - Field: ‘job’
[17:39:34.214]   - Field: ‘conditions’
[17:39:34.215]   - Field: ‘expr’
[17:39:34.215]   - Field: ‘uuid’
[17:39:34.215]   - Field: ‘seed’
[17:39:34.215]   - Field: ‘version’
[17:39:34.215]   - Field: ‘result’
[17:39:34.215]   - Field: ‘asynchronous’
[17:39:34.216]   - Field: ‘calls’
[17:39:34.216]   - Field: ‘globals’
[17:39:34.216]   - Field: ‘stdout’
[17:39:34.216]   - Field: ‘earlySignal’
[17:39:34.216]   - Field: ‘lazy’
[17:39:34.216]   - Field: ‘state’
[17:39:34.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.217] - Launch lazy future ...
[17:39:34.217] Packages needed by the future expression (n = 0): <none>
[17:39:34.217] Packages needed by future strategies (n = 0): <none>
[17:39:34.218] {
[17:39:34.218]     {
[17:39:34.218]         {
[17:39:34.218]             ...future.startTime <- base::Sys.time()
[17:39:34.218]             {
[17:39:34.218]                 {
[17:39:34.218]                   {
[17:39:34.218]                     {
[17:39:34.218]                       base::local({
[17:39:34.218]                         has_future <- base::requireNamespace("future", 
[17:39:34.218]                           quietly = TRUE)
[17:39:34.218]                         if (has_future) {
[17:39:34.218]                           ns <- base::getNamespace("future")
[17:39:34.218]                           version <- ns[[".package"]][["version"]]
[17:39:34.218]                           if (is.null(version)) 
[17:39:34.218]                             version <- utils::packageVersion("future")
[17:39:34.218]                         }
[17:39:34.218]                         else {
[17:39:34.218]                           version <- NULL
[17:39:34.218]                         }
[17:39:34.218]                         if (!has_future || version < "1.8.0") {
[17:39:34.218]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.218]                             "", base::R.version$version.string), 
[17:39:34.218]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.218]                               "release", "version")], collapse = " "), 
[17:39:34.218]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.218]                             info)
[17:39:34.218]                           info <- base::paste(info, collapse = "; ")
[17:39:34.218]                           if (!has_future) {
[17:39:34.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.218]                               info)
[17:39:34.218]                           }
[17:39:34.218]                           else {
[17:39:34.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.218]                               info, version)
[17:39:34.218]                           }
[17:39:34.218]                           base::stop(msg)
[17:39:34.218]                         }
[17:39:34.218]                       })
[17:39:34.218]                     }
[17:39:34.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.218]                     base::options(mc.cores = 1L)
[17:39:34.218]                   }
[17:39:34.218]                   ...future.strategy.old <- future::plan("list")
[17:39:34.218]                   options(future.plan = NULL)
[17:39:34.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.218]                 }
[17:39:34.218]                 ...future.workdir <- getwd()
[17:39:34.218]             }
[17:39:34.218]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.218]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.218]         }
[17:39:34.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.218]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.218]             base::names(...future.oldOptions))
[17:39:34.218]     }
[17:39:34.218]     if (FALSE) {
[17:39:34.218]     }
[17:39:34.218]     else {
[17:39:34.218]         if (TRUE) {
[17:39:34.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.218]                 open = "w")
[17:39:34.218]         }
[17:39:34.218]         else {
[17:39:34.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.218]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.218]         }
[17:39:34.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.218]             base::sink(type = "output", split = FALSE)
[17:39:34.218]             base::close(...future.stdout)
[17:39:34.218]         }, add = TRUE)
[17:39:34.218]     }
[17:39:34.218]     ...future.frame <- base::sys.nframe()
[17:39:34.218]     ...future.conditions <- base::list()
[17:39:34.218]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.218]     if (FALSE) {
[17:39:34.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.218]     }
[17:39:34.218]     ...future.result <- base::tryCatch({
[17:39:34.218]         base::withCallingHandlers({
[17:39:34.218]             ...future.value <- base::withVisible(base::local({
[17:39:34.218]                 withCallingHandlers({
[17:39:34.218]                   NULL
[17:39:34.218]                 }, immediateCondition = function(cond) {
[17:39:34.218]                   save_rds <- function (object, pathname, ...) 
[17:39:34.218]                   {
[17:39:34.218]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.218]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.218]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.218]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.218]                         fi_tmp[["mtime"]])
[17:39:34.218]                     }
[17:39:34.218]                     tryCatch({
[17:39:34.218]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.218]                     }, error = function(ex) {
[17:39:34.218]                       msg <- conditionMessage(ex)
[17:39:34.218]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.218]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.218]                         fi_tmp[["mtime"]], msg)
[17:39:34.218]                       ex$message <- msg
[17:39:34.218]                       stop(ex)
[17:39:34.218]                     })
[17:39:34.218]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.218]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.218]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.218]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.218]                       fi <- file.info(pathname)
[17:39:34.218]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.218]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.218]                         fi[["size"]], fi[["mtime"]])
[17:39:34.218]                       stop(msg)
[17:39:34.218]                     }
[17:39:34.218]                     invisible(pathname)
[17:39:34.218]                   }
[17:39:34.218]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.218]                     rootPath = tempdir()) 
[17:39:34.218]                   {
[17:39:34.218]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.218]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.218]                       tmpdir = path, fileext = ".rds")
[17:39:34.218]                     save_rds(obj, file)
[17:39:34.218]                   }
[17:39:34.218]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.218]                   {
[17:39:34.218]                     inherits <- base::inherits
[17:39:34.218]                     invokeRestart <- base::invokeRestart
[17:39:34.218]                     is.null <- base::is.null
[17:39:34.218]                     muffled <- FALSE
[17:39:34.218]                     if (inherits(cond, "message")) {
[17:39:34.218]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.218]                       if (muffled) 
[17:39:34.218]                         invokeRestart("muffleMessage")
[17:39:34.218]                     }
[17:39:34.218]                     else if (inherits(cond, "warning")) {
[17:39:34.218]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.218]                       if (muffled) 
[17:39:34.218]                         invokeRestart("muffleWarning")
[17:39:34.218]                     }
[17:39:34.218]                     else if (inherits(cond, "condition")) {
[17:39:34.218]                       if (!is.null(pattern)) {
[17:39:34.218]                         computeRestarts <- base::computeRestarts
[17:39:34.218]                         grepl <- base::grepl
[17:39:34.218]                         restarts <- computeRestarts(cond)
[17:39:34.218]                         for (restart in restarts) {
[17:39:34.218]                           name <- restart$name
[17:39:34.218]                           if (is.null(name)) 
[17:39:34.218]                             next
[17:39:34.218]                           if (!grepl(pattern, name)) 
[17:39:34.218]                             next
[17:39:34.218]                           invokeRestart(restart)
[17:39:34.218]                           muffled <- TRUE
[17:39:34.218]                           break
[17:39:34.218]                         }
[17:39:34.218]                       }
[17:39:34.218]                     }
[17:39:34.218]                     invisible(muffled)
[17:39:34.218]                   }
[17:39:34.218]                   muffleCondition(cond)
[17:39:34.218]                 })
[17:39:34.218]             }))
[17:39:34.218]             future::FutureResult(value = ...future.value$value, 
[17:39:34.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.218]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.218]                     ...future.globalenv.names))
[17:39:34.218]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.218]         }, condition = base::local({
[17:39:34.218]             c <- base::c
[17:39:34.218]             inherits <- base::inherits
[17:39:34.218]             invokeRestart <- base::invokeRestart
[17:39:34.218]             length <- base::length
[17:39:34.218]             list <- base::list
[17:39:34.218]             seq.int <- base::seq.int
[17:39:34.218]             signalCondition <- base::signalCondition
[17:39:34.218]             sys.calls <- base::sys.calls
[17:39:34.218]             `[[` <- base::`[[`
[17:39:34.218]             `+` <- base::`+`
[17:39:34.218]             `<<-` <- base::`<<-`
[17:39:34.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.218]                   3L)]
[17:39:34.218]             }
[17:39:34.218]             function(cond) {
[17:39:34.218]                 is_error <- inherits(cond, "error")
[17:39:34.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.218]                   NULL)
[17:39:34.218]                 if (is_error) {
[17:39:34.218]                   sessionInformation <- function() {
[17:39:34.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.218]                       search = base::search(), system = base::Sys.info())
[17:39:34.218]                   }
[17:39:34.218]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.218]                     cond$call), session = sessionInformation(), 
[17:39:34.218]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.218]                   signalCondition(cond)
[17:39:34.218]                 }
[17:39:34.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.218]                 "immediateCondition"))) {
[17:39:34.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.218]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.218]                   if (TRUE && !signal) {
[17:39:34.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.218]                     {
[17:39:34.218]                       inherits <- base::inherits
[17:39:34.218]                       invokeRestart <- base::invokeRestart
[17:39:34.218]                       is.null <- base::is.null
[17:39:34.218]                       muffled <- FALSE
[17:39:34.218]                       if (inherits(cond, "message")) {
[17:39:34.218]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.218]                         if (muffled) 
[17:39:34.218]                           invokeRestart("muffleMessage")
[17:39:34.218]                       }
[17:39:34.218]                       else if (inherits(cond, "warning")) {
[17:39:34.218]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.218]                         if (muffled) 
[17:39:34.218]                           invokeRestart("muffleWarning")
[17:39:34.218]                       }
[17:39:34.218]                       else if (inherits(cond, "condition")) {
[17:39:34.218]                         if (!is.null(pattern)) {
[17:39:34.218]                           computeRestarts <- base::computeRestarts
[17:39:34.218]                           grepl <- base::grepl
[17:39:34.218]                           restarts <- computeRestarts(cond)
[17:39:34.218]                           for (restart in restarts) {
[17:39:34.218]                             name <- restart$name
[17:39:34.218]                             if (is.null(name)) 
[17:39:34.218]                               next
[17:39:34.218]                             if (!grepl(pattern, name)) 
[17:39:34.218]                               next
[17:39:34.218]                             invokeRestart(restart)
[17:39:34.218]                             muffled <- TRUE
[17:39:34.218]                             break
[17:39:34.218]                           }
[17:39:34.218]                         }
[17:39:34.218]                       }
[17:39:34.218]                       invisible(muffled)
[17:39:34.218]                     }
[17:39:34.218]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.218]                   }
[17:39:34.218]                 }
[17:39:34.218]                 else {
[17:39:34.218]                   if (TRUE) {
[17:39:34.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.218]                     {
[17:39:34.218]                       inherits <- base::inherits
[17:39:34.218]                       invokeRestart <- base::invokeRestart
[17:39:34.218]                       is.null <- base::is.null
[17:39:34.218]                       muffled <- FALSE
[17:39:34.218]                       if (inherits(cond, "message")) {
[17:39:34.218]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.218]                         if (muffled) 
[17:39:34.218]                           invokeRestart("muffleMessage")
[17:39:34.218]                       }
[17:39:34.218]                       else if (inherits(cond, "warning")) {
[17:39:34.218]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.218]                         if (muffled) 
[17:39:34.218]                           invokeRestart("muffleWarning")
[17:39:34.218]                       }
[17:39:34.218]                       else if (inherits(cond, "condition")) {
[17:39:34.218]                         if (!is.null(pattern)) {
[17:39:34.218]                           computeRestarts <- base::computeRestarts
[17:39:34.218]                           grepl <- base::grepl
[17:39:34.218]                           restarts <- computeRestarts(cond)
[17:39:34.218]                           for (restart in restarts) {
[17:39:34.218]                             name <- restart$name
[17:39:34.218]                             if (is.null(name)) 
[17:39:34.218]                               next
[17:39:34.218]                             if (!grepl(pattern, name)) 
[17:39:34.218]                               next
[17:39:34.218]                             invokeRestart(restart)
[17:39:34.218]                             muffled <- TRUE
[17:39:34.218]                             break
[17:39:34.218]                           }
[17:39:34.218]                         }
[17:39:34.218]                       }
[17:39:34.218]                       invisible(muffled)
[17:39:34.218]                     }
[17:39:34.218]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.218]                   }
[17:39:34.218]                 }
[17:39:34.218]             }
[17:39:34.218]         }))
[17:39:34.218]     }, error = function(ex) {
[17:39:34.218]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.218]                 ...future.rng), started = ...future.startTime, 
[17:39:34.218]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.218]             version = "1.8"), class = "FutureResult")
[17:39:34.218]     }, finally = {
[17:39:34.218]         if (!identical(...future.workdir, getwd())) 
[17:39:34.218]             setwd(...future.workdir)
[17:39:34.218]         {
[17:39:34.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.218]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.218]             }
[17:39:34.218]             base::options(...future.oldOptions)
[17:39:34.218]             if (.Platform$OS.type == "windows") {
[17:39:34.218]                 old_names <- names(...future.oldEnvVars)
[17:39:34.218]                 envs <- base::Sys.getenv()
[17:39:34.218]                 names <- names(envs)
[17:39:34.218]                 common <- intersect(names, old_names)
[17:39:34.218]                 added <- setdiff(names, old_names)
[17:39:34.218]                 removed <- setdiff(old_names, names)
[17:39:34.218]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.218]                   envs[common]]
[17:39:34.218]                 NAMES <- toupper(changed)
[17:39:34.218]                 args <- list()
[17:39:34.218]                 for (kk in seq_along(NAMES)) {
[17:39:34.218]                   name <- changed[[kk]]
[17:39:34.218]                   NAME <- NAMES[[kk]]
[17:39:34.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.218]                     next
[17:39:34.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.218]                 }
[17:39:34.218]                 NAMES <- toupper(added)
[17:39:34.218]                 for (kk in seq_along(NAMES)) {
[17:39:34.218]                   name <- added[[kk]]
[17:39:34.218]                   NAME <- NAMES[[kk]]
[17:39:34.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.218]                     next
[17:39:34.218]                   args[[name]] <- ""
[17:39:34.218]                 }
[17:39:34.218]                 NAMES <- toupper(removed)
[17:39:34.218]                 for (kk in seq_along(NAMES)) {
[17:39:34.218]                   name <- removed[[kk]]
[17:39:34.218]                   NAME <- NAMES[[kk]]
[17:39:34.218]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.218]                     next
[17:39:34.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.218]                 }
[17:39:34.218]                 if (length(args) > 0) 
[17:39:34.218]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.218]             }
[17:39:34.218]             else {
[17:39:34.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.218]             }
[17:39:34.218]             {
[17:39:34.218]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.218]                   0L) {
[17:39:34.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.218]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.218]                   base::options(opts)
[17:39:34.218]                 }
[17:39:34.218]                 {
[17:39:34.218]                   {
[17:39:34.218]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.218]                     NULL
[17:39:34.218]                   }
[17:39:34.218]                   options(future.plan = NULL)
[17:39:34.218]                   if (is.na(NA_character_)) 
[17:39:34.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.218]                     .init = FALSE)
[17:39:34.218]                 }
[17:39:34.218]             }
[17:39:34.218]         }
[17:39:34.218]     })
[17:39:34.218]     if (TRUE) {
[17:39:34.218]         base::sink(type = "output", split = FALSE)
[17:39:34.218]         if (TRUE) {
[17:39:34.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.218]         }
[17:39:34.218]         else {
[17:39:34.218]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.218]         }
[17:39:34.218]         base::close(...future.stdout)
[17:39:34.218]         ...future.stdout <- NULL
[17:39:34.218]     }
[17:39:34.218]     ...future.result$conditions <- ...future.conditions
[17:39:34.218]     ...future.result$finished <- base::Sys.time()
[17:39:34.218]     ...future.result
[17:39:34.218] }
[17:39:34.223] requestCore(): workers = 2
[17:39:34.226] MulticoreFuture started
[17:39:34.226] - Launch lazy future ... done
[17:39:34.227] run() for ‘MulticoreFuture’ ... done
[17:39:34.227] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:39:34.227] List of future strategies:
[17:39:34.227] 1. sequential:
[17:39:34.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.227]    - tweaked: FALSE
[17:39:34.227]    - call: NULL
 num 1
 $ b[17:39:34.228] plan(): nbrOfWorkers() = 1
:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf08819c8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adee2b5100> 
 $  : NULL
 $  : NULL
 $  :[17:39:34.231] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[17:39:34.231] List of future strategies:
[17:39:34.231] 1. multicore:
[17:39:34.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.231]    - tweaked: FALSE
[17:39:34.231]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf08819c8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adee2b5100> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:34.236] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:34.239] resolve() on list ...
[17:39:34.239]  recursive: 0
[17:39:34.240]  length: 6
[17:39:34.240]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:34.240] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.240] - nx: 6
[17:39:34.240] - relay: TRUE
[17:39:34.240] - stdout: TRUE
[17:39:34.240] - signal: TRUE
[17:39:34.241] - resignal: FALSE
[17:39:34.241] - force: TRUE
[17:39:34.241] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.241] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.241]  - until=2
[17:39:34.241]  - relaying element #2
[17:39:34.241] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.242] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.242] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.242]  length: 5 (resolved future 1)
[17:39:34.242] Future #2
[17:39:34.242] result() for MulticoreFuture ...
[17:39:34.243] result() for MulticoreFuture ...
[17:39:34.244] result() for MulticoreFuture ... done
[17:39:34.244] result() for MulticoreFuture ... done
[17:39:34.244] result() for MulticoreFuture ...
[17:39:34.244] result() for MulticoreFuture ... done
[17:39:34.244] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:34.244] - nx: 6
[17:39:34.244] - relay: TRUE
[17:39:34.245] - stdout: TRUE
[17:39:34.245] - signal: TRUE
[17:39:34.245] - resignal: FALSE
[17:39:34.245] - force: TRUE
[17:39:34.245] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.245] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.245]  - until=2
[17:39:34.245]  - relaying element #2
[17:39:34.246] result() for MulticoreFuture ...
[17:39:34.246] result() for MulticoreFuture ... done
[17:39:34.246] result() for MulticoreFuture ...
[17:39:34.246] result() for MulticoreFuture ... done
[17:39:34.246] result() for MulticoreFuture ...
[17:39:34.246] result() for MulticoreFuture ... done
[17:39:34.247] result() for MulticoreFuture ...
[17:39:34.247] result() for MulticoreFuture ... done
[17:39:34.247] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.247] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.247] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:34.247]  length: 4 (resolved future 2)
[17:39:34.247] Future #3
[17:39:34.248] result() for MulticoreFuture ...
[17:39:34.248] result() for MulticoreFuture ...
[17:39:34.249] result() for MulticoreFuture ... done
[17:39:34.249] result() for MulticoreFuture ... done
[17:39:34.249] result() for MulticoreFuture ...
[17:39:34.249] result() for MulticoreFuture ... done
[17:39:34.249] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:34.250] - nx: 6
[17:39:34.250] - relay: TRUE
[17:39:34.250] - stdout: TRUE
[17:39:34.250] - signal: TRUE
[17:39:34.250] - resignal: FALSE
[17:39:34.250] - force: TRUE
[17:39:34.250] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.251] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.251]  - until=3
[17:39:34.251]  - relaying element #3
[17:39:34.251] result() for MulticoreFuture ...
[17:39:34.251] result() for MulticoreFuture ... done
[17:39:34.251] result() for MulticoreFuture ...
[17:39:34.252] result() for MulticoreFuture ... done
[17:39:34.252] result() for MulticoreFuture ...
[17:39:34.252] result() for MulticoreFuture ... done
[17:39:34.254] result() for MulticoreFuture ...
[17:39:34.254] result() for MulticoreFuture ... done
[17:39:34.255] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.255] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:34.255]  length: 3 (resolved future 3)
[17:39:34.255] signalConditionsASAP(NULL, pos=4) ...
[17:39:34.256] - nx: 6
[17:39:34.256] - relay: TRUE
[17:39:34.256] - stdout: TRUE
[17:39:34.256] - signal: TRUE
[17:39:34.256] - resignal: FALSE
[17:39:34.256] - force: TRUE
[17:39:34.256] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.257] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.257]  - until=5
[17:39:34.257]  - relaying element #5
[17:39:34.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.257] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.257] signalConditionsASAP(NULL, pos=4) ... done
[17:39:34.257]  length: 2 (resolved future 4)
[17:39:34.257] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.257] - nx: 6
[17:39:34.258] - relay: TRUE
[17:39:34.258] - stdout: TRUE
[17:39:34.258] - signal: TRUE
[17:39:34.258] - resignal: FALSE
[17:39:34.258] - force: TRUE
[17:39:34.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.258] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.258]  - until=6
[17:39:34.258]  - relaying element #6
[17:39:34.259] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.259] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.259] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.259]  length: 1 (resolved future 5)
[17:39:34.259] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.259] - nx: 6
[17:39:34.259] - relay: TRUE
[17:39:34.259] - stdout: TRUE
[17:39:34.259] - signal: TRUE
[17:39:34.260] - resignal: FALSE
[17:39:34.260] - force: TRUE
[17:39:34.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.260]  - until=6
[17:39:34.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.260] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.260] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.260]  length: 0 (resolved future 6)
[17:39:34.261] Relaying remaining futures
[17:39:34.261] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.261] - nx: 6
[17:39:34.261] - relay: TRUE
[17:39:34.261] - stdout: TRUE
[17:39:34.261] - signal: TRUE
[17:39:34.261] - resignal: FALSE
[17:39:34.261] - force: TRUE
[17:39:34.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.261] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:34.262] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.262] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.262] resolve() on list ... DONE
[17:39:34.262] result() for MulticoreFuture ...
[17:39:34.262] result() for MulticoreFuture ... done
[17:39:34.262] result() for MulticoreFuture ...
[17:39:34.262] result() for MulticoreFuture ... done
[17:39:34.263] result() for MulticoreFuture ...
[17:39:34.263] result() for MulticoreFuture ... done
[17:39:34.263] result() for MulticoreFuture ...
[17:39:34.263] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:34.267] getGlobalsAndPackages() ...
[17:39:34.267] Searching for globals...
[17:39:34.267] 
[17:39:34.267] Searching for globals ... DONE
[17:39:34.267] - globals: [0] <none>
[17:39:34.267] getGlobalsAndPackages() ... DONE
[17:39:34.268] run() for ‘Future’ ...
[17:39:34.268] - state: ‘created’
[17:39:34.268] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.272]   - Field: ‘label’
[17:39:34.272]   - Field: ‘local’
[17:39:34.272]   - Field: ‘owner’
[17:39:34.272]   - Field: ‘envir’
[17:39:34.272]   - Field: ‘workers’
[17:39:34.273]   - Field: ‘packages’
[17:39:34.273]   - Field: ‘gc’
[17:39:34.273]   - Field: ‘job’
[17:39:34.273]   - Field: ‘conditions’
[17:39:34.273]   - Field: ‘expr’
[17:39:34.273]   - Field: ‘uuid’
[17:39:34.273]   - Field: ‘seed’
[17:39:34.273]   - Field: ‘version’
[17:39:34.273]   - Field: ‘result’
[17:39:34.273]   - Field: ‘asynchronous’
[17:39:34.273]   - Field: ‘calls’
[17:39:34.274]   - Field: ‘globals’
[17:39:34.274]   - Field: ‘stdout’
[17:39:34.274]   - Field: ‘earlySignal’
[17:39:34.274]   - Field: ‘lazy’
[17:39:34.274]   - Field: ‘state’
[17:39:34.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.274] - Launch lazy future ...
[17:39:34.274] Packages needed by the future expression (n = 0): <none>
[17:39:34.274] Packages needed by future strategies (n = 0): <none>
[17:39:34.275] {
[17:39:34.275]     {
[17:39:34.275]         {
[17:39:34.275]             ...future.startTime <- base::Sys.time()
[17:39:34.275]             {
[17:39:34.275]                 {
[17:39:34.275]                   {
[17:39:34.275]                     {
[17:39:34.275]                       base::local({
[17:39:34.275]                         has_future <- base::requireNamespace("future", 
[17:39:34.275]                           quietly = TRUE)
[17:39:34.275]                         if (has_future) {
[17:39:34.275]                           ns <- base::getNamespace("future")
[17:39:34.275]                           version <- ns[[".package"]][["version"]]
[17:39:34.275]                           if (is.null(version)) 
[17:39:34.275]                             version <- utils::packageVersion("future")
[17:39:34.275]                         }
[17:39:34.275]                         else {
[17:39:34.275]                           version <- NULL
[17:39:34.275]                         }
[17:39:34.275]                         if (!has_future || version < "1.8.0") {
[17:39:34.275]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.275]                             "", base::R.version$version.string), 
[17:39:34.275]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.275]                               "release", "version")], collapse = " "), 
[17:39:34.275]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.275]                             info)
[17:39:34.275]                           info <- base::paste(info, collapse = "; ")
[17:39:34.275]                           if (!has_future) {
[17:39:34.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.275]                               info)
[17:39:34.275]                           }
[17:39:34.275]                           else {
[17:39:34.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.275]                               info, version)
[17:39:34.275]                           }
[17:39:34.275]                           base::stop(msg)
[17:39:34.275]                         }
[17:39:34.275]                       })
[17:39:34.275]                     }
[17:39:34.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.275]                     base::options(mc.cores = 1L)
[17:39:34.275]                   }
[17:39:34.275]                   ...future.strategy.old <- future::plan("list")
[17:39:34.275]                   options(future.plan = NULL)
[17:39:34.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.275]                 }
[17:39:34.275]                 ...future.workdir <- getwd()
[17:39:34.275]             }
[17:39:34.275]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.275]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.275]         }
[17:39:34.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.275]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.275]             base::names(...future.oldOptions))
[17:39:34.275]     }
[17:39:34.275]     if (FALSE) {
[17:39:34.275]     }
[17:39:34.275]     else {
[17:39:34.275]         if (TRUE) {
[17:39:34.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.275]                 open = "w")
[17:39:34.275]         }
[17:39:34.275]         else {
[17:39:34.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.275]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.275]         }
[17:39:34.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.275]             base::sink(type = "output", split = FALSE)
[17:39:34.275]             base::close(...future.stdout)
[17:39:34.275]         }, add = TRUE)
[17:39:34.275]     }
[17:39:34.275]     ...future.frame <- base::sys.nframe()
[17:39:34.275]     ...future.conditions <- base::list()
[17:39:34.275]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.275]     if (FALSE) {
[17:39:34.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.275]     }
[17:39:34.275]     ...future.result <- base::tryCatch({
[17:39:34.275]         base::withCallingHandlers({
[17:39:34.275]             ...future.value <- base::withVisible(base::local({
[17:39:34.275]                 withCallingHandlers({
[17:39:34.275]                   2
[17:39:34.275]                 }, immediateCondition = function(cond) {
[17:39:34.275]                   save_rds <- function (object, pathname, ...) 
[17:39:34.275]                   {
[17:39:34.275]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.275]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.275]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.275]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.275]                         fi_tmp[["mtime"]])
[17:39:34.275]                     }
[17:39:34.275]                     tryCatch({
[17:39:34.275]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.275]                     }, error = function(ex) {
[17:39:34.275]                       msg <- conditionMessage(ex)
[17:39:34.275]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.275]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.275]                         fi_tmp[["mtime"]], msg)
[17:39:34.275]                       ex$message <- msg
[17:39:34.275]                       stop(ex)
[17:39:34.275]                     })
[17:39:34.275]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.275]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.275]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.275]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.275]                       fi <- file.info(pathname)
[17:39:34.275]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.275]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.275]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.275]                         fi[["size"]], fi[["mtime"]])
[17:39:34.275]                       stop(msg)
[17:39:34.275]                     }
[17:39:34.275]                     invisible(pathname)
[17:39:34.275]                   }
[17:39:34.275]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.275]                     rootPath = tempdir()) 
[17:39:34.275]                   {
[17:39:34.275]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.275]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.275]                       tmpdir = path, fileext = ".rds")
[17:39:34.275]                     save_rds(obj, file)
[17:39:34.275]                   }
[17:39:34.275]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.275]                   {
[17:39:34.275]                     inherits <- base::inherits
[17:39:34.275]                     invokeRestart <- base::invokeRestart
[17:39:34.275]                     is.null <- base::is.null
[17:39:34.275]                     muffled <- FALSE
[17:39:34.275]                     if (inherits(cond, "message")) {
[17:39:34.275]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.275]                       if (muffled) 
[17:39:34.275]                         invokeRestart("muffleMessage")
[17:39:34.275]                     }
[17:39:34.275]                     else if (inherits(cond, "warning")) {
[17:39:34.275]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.275]                       if (muffled) 
[17:39:34.275]                         invokeRestart("muffleWarning")
[17:39:34.275]                     }
[17:39:34.275]                     else if (inherits(cond, "condition")) {
[17:39:34.275]                       if (!is.null(pattern)) {
[17:39:34.275]                         computeRestarts <- base::computeRestarts
[17:39:34.275]                         grepl <- base::grepl
[17:39:34.275]                         restarts <- computeRestarts(cond)
[17:39:34.275]                         for (restart in restarts) {
[17:39:34.275]                           name <- restart$name
[17:39:34.275]                           if (is.null(name)) 
[17:39:34.275]                             next
[17:39:34.275]                           if (!grepl(pattern, name)) 
[17:39:34.275]                             next
[17:39:34.275]                           invokeRestart(restart)
[17:39:34.275]                           muffled <- TRUE
[17:39:34.275]                           break
[17:39:34.275]                         }
[17:39:34.275]                       }
[17:39:34.275]                     }
[17:39:34.275]                     invisible(muffled)
[17:39:34.275]                   }
[17:39:34.275]                   muffleCondition(cond)
[17:39:34.275]                 })
[17:39:34.275]             }))
[17:39:34.275]             future::FutureResult(value = ...future.value$value, 
[17:39:34.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.275]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.275]                     ...future.globalenv.names))
[17:39:34.275]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.275]         }, condition = base::local({
[17:39:34.275]             c <- base::c
[17:39:34.275]             inherits <- base::inherits
[17:39:34.275]             invokeRestart <- base::invokeRestart
[17:39:34.275]             length <- base::length
[17:39:34.275]             list <- base::list
[17:39:34.275]             seq.int <- base::seq.int
[17:39:34.275]             signalCondition <- base::signalCondition
[17:39:34.275]             sys.calls <- base::sys.calls
[17:39:34.275]             `[[` <- base::`[[`
[17:39:34.275]             `+` <- base::`+`
[17:39:34.275]             `<<-` <- base::`<<-`
[17:39:34.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.275]                   3L)]
[17:39:34.275]             }
[17:39:34.275]             function(cond) {
[17:39:34.275]                 is_error <- inherits(cond, "error")
[17:39:34.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.275]                   NULL)
[17:39:34.275]                 if (is_error) {
[17:39:34.275]                   sessionInformation <- function() {
[17:39:34.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.275]                       search = base::search(), system = base::Sys.info())
[17:39:34.275]                   }
[17:39:34.275]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.275]                     cond$call), session = sessionInformation(), 
[17:39:34.275]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.275]                   signalCondition(cond)
[17:39:34.275]                 }
[17:39:34.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.275]                 "immediateCondition"))) {
[17:39:34.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.275]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.275]                   if (TRUE && !signal) {
[17:39:34.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.275]                     {
[17:39:34.275]                       inherits <- base::inherits
[17:39:34.275]                       invokeRestart <- base::invokeRestart
[17:39:34.275]                       is.null <- base::is.null
[17:39:34.275]                       muffled <- FALSE
[17:39:34.275]                       if (inherits(cond, "message")) {
[17:39:34.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.275]                         if (muffled) 
[17:39:34.275]                           invokeRestart("muffleMessage")
[17:39:34.275]                       }
[17:39:34.275]                       else if (inherits(cond, "warning")) {
[17:39:34.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.275]                         if (muffled) 
[17:39:34.275]                           invokeRestart("muffleWarning")
[17:39:34.275]                       }
[17:39:34.275]                       else if (inherits(cond, "condition")) {
[17:39:34.275]                         if (!is.null(pattern)) {
[17:39:34.275]                           computeRestarts <- base::computeRestarts
[17:39:34.275]                           grepl <- base::grepl
[17:39:34.275]                           restarts <- computeRestarts(cond)
[17:39:34.275]                           for (restart in restarts) {
[17:39:34.275]                             name <- restart$name
[17:39:34.275]                             if (is.null(name)) 
[17:39:34.275]                               next
[17:39:34.275]                             if (!grepl(pattern, name)) 
[17:39:34.275]                               next
[17:39:34.275]                             invokeRestart(restart)
[17:39:34.275]                             muffled <- TRUE
[17:39:34.275]                             break
[17:39:34.275]                           }
[17:39:34.275]                         }
[17:39:34.275]                       }
[17:39:34.275]                       invisible(muffled)
[17:39:34.275]                     }
[17:39:34.275]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.275]                   }
[17:39:34.275]                 }
[17:39:34.275]                 else {
[17:39:34.275]                   if (TRUE) {
[17:39:34.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.275]                     {
[17:39:34.275]                       inherits <- base::inherits
[17:39:34.275]                       invokeRestart <- base::invokeRestart
[17:39:34.275]                       is.null <- base::is.null
[17:39:34.275]                       muffled <- FALSE
[17:39:34.275]                       if (inherits(cond, "message")) {
[17:39:34.275]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.275]                         if (muffled) 
[17:39:34.275]                           invokeRestart("muffleMessage")
[17:39:34.275]                       }
[17:39:34.275]                       else if (inherits(cond, "warning")) {
[17:39:34.275]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.275]                         if (muffled) 
[17:39:34.275]                           invokeRestart("muffleWarning")
[17:39:34.275]                       }
[17:39:34.275]                       else if (inherits(cond, "condition")) {
[17:39:34.275]                         if (!is.null(pattern)) {
[17:39:34.275]                           computeRestarts <- base::computeRestarts
[17:39:34.275]                           grepl <- base::grepl
[17:39:34.275]                           restarts <- computeRestarts(cond)
[17:39:34.275]                           for (restart in restarts) {
[17:39:34.275]                             name <- restart$name
[17:39:34.275]                             if (is.null(name)) 
[17:39:34.275]                               next
[17:39:34.275]                             if (!grepl(pattern, name)) 
[17:39:34.275]                               next
[17:39:34.275]                             invokeRestart(restart)
[17:39:34.275]                             muffled <- TRUE
[17:39:34.275]                             break
[17:39:34.275]                           }
[17:39:34.275]                         }
[17:39:34.275]                       }
[17:39:34.275]                       invisible(muffled)
[17:39:34.275]                     }
[17:39:34.275]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.275]                   }
[17:39:34.275]                 }
[17:39:34.275]             }
[17:39:34.275]         }))
[17:39:34.275]     }, error = function(ex) {
[17:39:34.275]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.275]                 ...future.rng), started = ...future.startTime, 
[17:39:34.275]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.275]             version = "1.8"), class = "FutureResult")
[17:39:34.275]     }, finally = {
[17:39:34.275]         if (!identical(...future.workdir, getwd())) 
[17:39:34.275]             setwd(...future.workdir)
[17:39:34.275]         {
[17:39:34.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.275]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.275]             }
[17:39:34.275]             base::options(...future.oldOptions)
[17:39:34.275]             if (.Platform$OS.type == "windows") {
[17:39:34.275]                 old_names <- names(...future.oldEnvVars)
[17:39:34.275]                 envs <- base::Sys.getenv()
[17:39:34.275]                 names <- names(envs)
[17:39:34.275]                 common <- intersect(names, old_names)
[17:39:34.275]                 added <- setdiff(names, old_names)
[17:39:34.275]                 removed <- setdiff(old_names, names)
[17:39:34.275]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.275]                   envs[common]]
[17:39:34.275]                 NAMES <- toupper(changed)
[17:39:34.275]                 args <- list()
[17:39:34.275]                 for (kk in seq_along(NAMES)) {
[17:39:34.275]                   name <- changed[[kk]]
[17:39:34.275]                   NAME <- NAMES[[kk]]
[17:39:34.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.275]                     next
[17:39:34.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.275]                 }
[17:39:34.275]                 NAMES <- toupper(added)
[17:39:34.275]                 for (kk in seq_along(NAMES)) {
[17:39:34.275]                   name <- added[[kk]]
[17:39:34.275]                   NAME <- NAMES[[kk]]
[17:39:34.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.275]                     next
[17:39:34.275]                   args[[name]] <- ""
[17:39:34.275]                 }
[17:39:34.275]                 NAMES <- toupper(removed)
[17:39:34.275]                 for (kk in seq_along(NAMES)) {
[17:39:34.275]                   name <- removed[[kk]]
[17:39:34.275]                   NAME <- NAMES[[kk]]
[17:39:34.275]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.275]                     next
[17:39:34.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.275]                 }
[17:39:34.275]                 if (length(args) > 0) 
[17:39:34.275]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.275]             }
[17:39:34.275]             else {
[17:39:34.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.275]             }
[17:39:34.275]             {
[17:39:34.275]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.275]                   0L) {
[17:39:34.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.275]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.275]                   base::options(opts)
[17:39:34.275]                 }
[17:39:34.275]                 {
[17:39:34.275]                   {
[17:39:34.275]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.275]                     NULL
[17:39:34.275]                   }
[17:39:34.275]                   options(future.plan = NULL)
[17:39:34.275]                   if (is.na(NA_character_)) 
[17:39:34.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.275]                     .init = FALSE)
[17:39:34.275]                 }
[17:39:34.275]             }
[17:39:34.275]         }
[17:39:34.275]     })
[17:39:34.275]     if (TRUE) {
[17:39:34.275]         base::sink(type = "output", split = FALSE)
[17:39:34.275]         if (TRUE) {
[17:39:34.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.275]         }
[17:39:34.275]         else {
[17:39:34.275]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.275]         }
[17:39:34.275]         base::close(...future.stdout)
[17:39:34.275]         ...future.stdout <- NULL
[17:39:34.275]     }
[17:39:34.275]     ...future.result$conditions <- ...future.conditions
[17:39:34.275]     ...future.result$finished <- base::Sys.time()
[17:39:34.275]     ...future.result
[17:39:34.275] }
[17:39:34.277] requestCore(): workers = 2
[17:39:34.279] MulticoreFuture started
[17:39:34.280] - Launch lazy future ... done
[17:39:34.280] run() for ‘MulticoreFuture’ ... done
[17:39:34.280] getGlobalsAndPackages() ...
[17:39:34.280] Searching for globals...
[17:39:34.280] plan(): Setting new future strategy stack:
[17:39:34.281] 
[17:39:34.281] List of future strategies:
[17:39:34.281] 1. sequential:
[17:39:34.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.281]    - tweaked: FALSE
[17:39:34.281]    - call: NULL
[17:39:34.281] Searching for globals ... DONE
[17:39:34.282] plan(): nbrOfWorkers() = 1
[17:39:34.282] - globals: [0] <none>
[17:39:34.282] getGlobalsAndPackages() ... DONE
[17:39:34.282] run() for ‘Future’ ...
[17:39:34.282] - state: ‘created’
[17:39:34.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.283] plan(): Setting new future strategy stack:
[17:39:34.284] List of future strategies:
[17:39:34.284] 1. multicore:
[17:39:34.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.284]    - tweaked: FALSE
[17:39:34.284]    - call: plan(strategy)
[17:39:34.288] plan(): nbrOfWorkers() = 2
[17:39:34.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.288]   - Field: ‘label’
[17:39:34.288]   - Field: ‘local’
[17:39:34.288]   - Field: ‘owner’
[17:39:34.289]   - Field: ‘envir’
[17:39:34.289]   - Field: ‘workers’
[17:39:34.289]   - Field: ‘packages’
[17:39:34.289]   - Field: ‘gc’
[17:39:34.289]   - Field: ‘job’
[17:39:34.289]   - Field: ‘conditions’
[17:39:34.290]   - Field: ‘expr’
[17:39:34.290]   - Field: ‘uuid’
[17:39:34.290]   - Field: ‘seed’
[17:39:34.290]   - Field: ‘version’
[17:39:34.290]   - Field: ‘result’
[17:39:34.290]   - Field: ‘asynchronous’
[17:39:34.290]   - Field: ‘calls’
[17:39:34.291]   - Field: ‘globals’
[17:39:34.291]   - Field: ‘stdout’
[17:39:34.291]   - Field: ‘earlySignal’
[17:39:34.291]   - Field: ‘lazy’
[17:39:34.291]   - Field: ‘state’
[17:39:34.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.291] - Launch lazy future ...
[17:39:34.292] Packages needed by the future expression (n = 0): <none>
[17:39:34.292] Packages needed by future strategies (n = 0): <none>
[17:39:34.293] {
[17:39:34.293]     {
[17:39:34.293]         {
[17:39:34.293]             ...future.startTime <- base::Sys.time()
[17:39:34.293]             {
[17:39:34.293]                 {
[17:39:34.293]                   {
[17:39:34.293]                     {
[17:39:34.293]                       base::local({
[17:39:34.293]                         has_future <- base::requireNamespace("future", 
[17:39:34.293]                           quietly = TRUE)
[17:39:34.293]                         if (has_future) {
[17:39:34.293]                           ns <- base::getNamespace("future")
[17:39:34.293]                           version <- ns[[".package"]][["version"]]
[17:39:34.293]                           if (is.null(version)) 
[17:39:34.293]                             version <- utils::packageVersion("future")
[17:39:34.293]                         }
[17:39:34.293]                         else {
[17:39:34.293]                           version <- NULL
[17:39:34.293]                         }
[17:39:34.293]                         if (!has_future || version < "1.8.0") {
[17:39:34.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.293]                             "", base::R.version$version.string), 
[17:39:34.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.293]                               "release", "version")], collapse = " "), 
[17:39:34.293]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.293]                             info)
[17:39:34.293]                           info <- base::paste(info, collapse = "; ")
[17:39:34.293]                           if (!has_future) {
[17:39:34.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.293]                               info)
[17:39:34.293]                           }
[17:39:34.293]                           else {
[17:39:34.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.293]                               info, version)
[17:39:34.293]                           }
[17:39:34.293]                           base::stop(msg)
[17:39:34.293]                         }
[17:39:34.293]                       })
[17:39:34.293]                     }
[17:39:34.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.293]                     base::options(mc.cores = 1L)
[17:39:34.293]                   }
[17:39:34.293]                   ...future.strategy.old <- future::plan("list")
[17:39:34.293]                   options(future.plan = NULL)
[17:39:34.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.293]                 }
[17:39:34.293]                 ...future.workdir <- getwd()
[17:39:34.293]             }
[17:39:34.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.293]         }
[17:39:34.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.293]             base::names(...future.oldOptions))
[17:39:34.293]     }
[17:39:34.293]     if (FALSE) {
[17:39:34.293]     }
[17:39:34.293]     else {
[17:39:34.293]         if (TRUE) {
[17:39:34.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.293]                 open = "w")
[17:39:34.293]         }
[17:39:34.293]         else {
[17:39:34.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.293]         }
[17:39:34.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.293]             base::sink(type = "output", split = FALSE)
[17:39:34.293]             base::close(...future.stdout)
[17:39:34.293]         }, add = TRUE)
[17:39:34.293]     }
[17:39:34.293]     ...future.frame <- base::sys.nframe()
[17:39:34.293]     ...future.conditions <- base::list()
[17:39:34.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.293]     if (FALSE) {
[17:39:34.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.293]     }
[17:39:34.293]     ...future.result <- base::tryCatch({
[17:39:34.293]         base::withCallingHandlers({
[17:39:34.293]             ...future.value <- base::withVisible(base::local({
[17:39:34.293]                 withCallingHandlers({
[17:39:34.293]                   NULL
[17:39:34.293]                 }, immediateCondition = function(cond) {
[17:39:34.293]                   save_rds <- function (object, pathname, ...) 
[17:39:34.293]                   {
[17:39:34.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.293]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.293]                         fi_tmp[["mtime"]])
[17:39:34.293]                     }
[17:39:34.293]                     tryCatch({
[17:39:34.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.293]                     }, error = function(ex) {
[17:39:34.293]                       msg <- conditionMessage(ex)
[17:39:34.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.293]                         fi_tmp[["mtime"]], msg)
[17:39:34.293]                       ex$message <- msg
[17:39:34.293]                       stop(ex)
[17:39:34.293]                     })
[17:39:34.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.293]                       fi <- file.info(pathname)
[17:39:34.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.293]                         fi[["size"]], fi[["mtime"]])
[17:39:34.293]                       stop(msg)
[17:39:34.293]                     }
[17:39:34.293]                     invisible(pathname)
[17:39:34.293]                   }
[17:39:34.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.293]                     rootPath = tempdir()) 
[17:39:34.293]                   {
[17:39:34.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.293]                       tmpdir = path, fileext = ".rds")
[17:39:34.293]                     save_rds(obj, file)
[17:39:34.293]                   }
[17:39:34.293]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.293]                   {
[17:39:34.293]                     inherits <- base::inherits
[17:39:34.293]                     invokeRestart <- base::invokeRestart
[17:39:34.293]                     is.null <- base::is.null
[17:39:34.293]                     muffled <- FALSE
[17:39:34.293]                     if (inherits(cond, "message")) {
[17:39:34.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.293]                       if (muffled) 
[17:39:34.293]                         invokeRestart("muffleMessage")
[17:39:34.293]                     }
[17:39:34.293]                     else if (inherits(cond, "warning")) {
[17:39:34.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.293]                       if (muffled) 
[17:39:34.293]                         invokeRestart("muffleWarning")
[17:39:34.293]                     }
[17:39:34.293]                     else if (inherits(cond, "condition")) {
[17:39:34.293]                       if (!is.null(pattern)) {
[17:39:34.293]                         computeRestarts <- base::computeRestarts
[17:39:34.293]                         grepl <- base::grepl
[17:39:34.293]                         restarts <- computeRestarts(cond)
[17:39:34.293]                         for (restart in restarts) {
[17:39:34.293]                           name <- restart$name
[17:39:34.293]                           if (is.null(name)) 
[17:39:34.293]                             next
[17:39:34.293]                           if (!grepl(pattern, name)) 
[17:39:34.293]                             next
[17:39:34.293]                           invokeRestart(restart)
[17:39:34.293]                           muffled <- TRUE
[17:39:34.293]                           break
[17:39:34.293]                         }
[17:39:34.293]                       }
[17:39:34.293]                     }
[17:39:34.293]                     invisible(muffled)
[17:39:34.293]                   }
[17:39:34.293]                   muffleCondition(cond)
[17:39:34.293]                 })
[17:39:34.293]             }))
[17:39:34.293]             future::FutureResult(value = ...future.value$value, 
[17:39:34.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.293]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.293]                     ...future.globalenv.names))
[17:39:34.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.293]         }, condition = base::local({
[17:39:34.293]             c <- base::c
[17:39:34.293]             inherits <- base::inherits
[17:39:34.293]             invokeRestart <- base::invokeRestart
[17:39:34.293]             length <- base::length
[17:39:34.293]             list <- base::list
[17:39:34.293]             seq.int <- base::seq.int
[17:39:34.293]             signalCondition <- base::signalCondition
[17:39:34.293]             sys.calls <- base::sys.calls
[17:39:34.293]             `[[` <- base::`[[`
[17:39:34.293]             `+` <- base::`+`
[17:39:34.293]             `<<-` <- base::`<<-`
[17:39:34.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.293]                   3L)]
[17:39:34.293]             }
[17:39:34.293]             function(cond) {
[17:39:34.293]                 is_error <- inherits(cond, "error")
[17:39:34.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.293]                   NULL)
[17:39:34.293]                 if (is_error) {
[17:39:34.293]                   sessionInformation <- function() {
[17:39:34.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.293]                       search = base::search(), system = base::Sys.info())
[17:39:34.293]                   }
[17:39:34.293]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.293]                     cond$call), session = sessionInformation(), 
[17:39:34.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.293]                   signalCondition(cond)
[17:39:34.293]                 }
[17:39:34.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.293]                 "immediateCondition"))) {
[17:39:34.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.293]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.293]                   if (TRUE && !signal) {
[17:39:34.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.293]                     {
[17:39:34.293]                       inherits <- base::inherits
[17:39:34.293]                       invokeRestart <- base::invokeRestart
[17:39:34.293]                       is.null <- base::is.null
[17:39:34.293]                       muffled <- FALSE
[17:39:34.293]                       if (inherits(cond, "message")) {
[17:39:34.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.293]                         if (muffled) 
[17:39:34.293]                           invokeRestart("muffleMessage")
[17:39:34.293]                       }
[17:39:34.293]                       else if (inherits(cond, "warning")) {
[17:39:34.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.293]                         if (muffled) 
[17:39:34.293]                           invokeRestart("muffleWarning")
[17:39:34.293]                       }
[17:39:34.293]                       else if (inherits(cond, "condition")) {
[17:39:34.293]                         if (!is.null(pattern)) {
[17:39:34.293]                           computeRestarts <- base::computeRestarts
[17:39:34.293]                           grepl <- base::grepl
[17:39:34.293]                           restarts <- computeRestarts(cond)
[17:39:34.293]                           for (restart in restarts) {
[17:39:34.293]                             name <- restart$name
[17:39:34.293]                             if (is.null(name)) 
[17:39:34.293]                               next
[17:39:34.293]                             if (!grepl(pattern, name)) 
[17:39:34.293]                               next
[17:39:34.293]                             invokeRestart(restart)
[17:39:34.293]                             muffled <- TRUE
[17:39:34.293]                             break
[17:39:34.293]                           }
[17:39:34.293]                         }
[17:39:34.293]                       }
[17:39:34.293]                       invisible(muffled)
[17:39:34.293]                     }
[17:39:34.293]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.293]                   }
[17:39:34.293]                 }
[17:39:34.293]                 else {
[17:39:34.293]                   if (TRUE) {
[17:39:34.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.293]                     {
[17:39:34.293]                       inherits <- base::inherits
[17:39:34.293]                       invokeRestart <- base::invokeRestart
[17:39:34.293]                       is.null <- base::is.null
[17:39:34.293]                       muffled <- FALSE
[17:39:34.293]                       if (inherits(cond, "message")) {
[17:39:34.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.293]                         if (muffled) 
[17:39:34.293]                           invokeRestart("muffleMessage")
[17:39:34.293]                       }
[17:39:34.293]                       else if (inherits(cond, "warning")) {
[17:39:34.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.293]                         if (muffled) 
[17:39:34.293]                           invokeRestart("muffleWarning")
[17:39:34.293]                       }
[17:39:34.293]                       else if (inherits(cond, "condition")) {
[17:39:34.293]                         if (!is.null(pattern)) {
[17:39:34.293]                           computeRestarts <- base::computeRestarts
[17:39:34.293]                           grepl <- base::grepl
[17:39:34.293]                           restarts <- computeRestarts(cond)
[17:39:34.293]                           for (restart in restarts) {
[17:39:34.293]                             name <- restart$name
[17:39:34.293]                             if (is.null(name)) 
[17:39:34.293]                               next
[17:39:34.293]                             if (!grepl(pattern, name)) 
[17:39:34.293]                               next
[17:39:34.293]                             invokeRestart(restart)
[17:39:34.293]                             muffled <- TRUE
[17:39:34.293]                             break
[17:39:34.293]                           }
[17:39:34.293]                         }
[17:39:34.293]                       }
[17:39:34.293]                       invisible(muffled)
[17:39:34.293]                     }
[17:39:34.293]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.293]                   }
[17:39:34.293]                 }
[17:39:34.293]             }
[17:39:34.293]         }))
[17:39:34.293]     }, error = function(ex) {
[17:39:34.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.293]                 ...future.rng), started = ...future.startTime, 
[17:39:34.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.293]             version = "1.8"), class = "FutureResult")
[17:39:34.293]     }, finally = {
[17:39:34.293]         if (!identical(...future.workdir, getwd())) 
[17:39:34.293]             setwd(...future.workdir)
[17:39:34.293]         {
[17:39:34.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.293]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.293]             }
[17:39:34.293]             base::options(...future.oldOptions)
[17:39:34.293]             if (.Platform$OS.type == "windows") {
[17:39:34.293]                 old_names <- names(...future.oldEnvVars)
[17:39:34.293]                 envs <- base::Sys.getenv()
[17:39:34.293]                 names <- names(envs)
[17:39:34.293]                 common <- intersect(names, old_names)
[17:39:34.293]                 added <- setdiff(names, old_names)
[17:39:34.293]                 removed <- setdiff(old_names, names)
[17:39:34.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.293]                   envs[common]]
[17:39:34.293]                 NAMES <- toupper(changed)
[17:39:34.293]                 args <- list()
[17:39:34.293]                 for (kk in seq_along(NAMES)) {
[17:39:34.293]                   name <- changed[[kk]]
[17:39:34.293]                   NAME <- NAMES[[kk]]
[17:39:34.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.293]                     next
[17:39:34.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.293]                 }
[17:39:34.293]                 NAMES <- toupper(added)
[17:39:34.293]                 for (kk in seq_along(NAMES)) {
[17:39:34.293]                   name <- added[[kk]]
[17:39:34.293]                   NAME <- NAMES[[kk]]
[17:39:34.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.293]                     next
[17:39:34.293]                   args[[name]] <- ""
[17:39:34.293]                 }
[17:39:34.293]                 NAMES <- toupper(removed)
[17:39:34.293]                 for (kk in seq_along(NAMES)) {
[17:39:34.293]                   name <- removed[[kk]]
[17:39:34.293]                   NAME <- NAMES[[kk]]
[17:39:34.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.293]                     next
[17:39:34.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.293]                 }
[17:39:34.293]                 if (length(args) > 0) 
[17:39:34.293]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.293]             }
[17:39:34.293]             else {
[17:39:34.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.293]             }
[17:39:34.293]             {
[17:39:34.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.293]                   0L) {
[17:39:34.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.293]                   base::options(opts)
[17:39:34.293]                 }
[17:39:34.293]                 {
[17:39:34.293]                   {
[17:39:34.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.293]                     NULL
[17:39:34.293]                   }
[17:39:34.293]                   options(future.plan = NULL)
[17:39:34.293]                   if (is.na(NA_character_)) 
[17:39:34.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.293]                     .init = FALSE)
[17:39:34.293]                 }
[17:39:34.293]             }
[17:39:34.293]         }
[17:39:34.293]     })
[17:39:34.293]     if (TRUE) {
[17:39:34.293]         base::sink(type = "output", split = FALSE)
[17:39:34.293]         if (TRUE) {
[17:39:34.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.293]         }
[17:39:34.293]         else {
[17:39:34.293]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.293]         }
[17:39:34.293]         base::close(...future.stdout)
[17:39:34.293]         ...future.stdout <- NULL
[17:39:34.293]     }
[17:39:34.293]     ...future.result$conditions <- ...future.conditions
[17:39:34.293]     ...future.result$finished <- base::Sys.time()
[17:39:34.293]     ...future.result
[17:39:34.293] }
[17:39:34.296] requestCore(): workers = 2
[17:39:34.299] MulticoreFuture started
[17:39:34.299] - Launch lazy future ... done
[17:39:34.299] run() for ‘MulticoreFuture’ ... done
List of 6
 [17:39:34.300] plan(): Setting new future strategy stack:
$ a: num 1
 $ b:[17:39:34.300] List of future strategies:
[17:39:34.300] 1. sequential:
[17:39:34.300]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.300]    - tweaked: FALSE
[17:39:34.300]    - call: NULL
[17:39:34.301] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefbd8fc8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf01f4150> 
 $  : NULL
 $  : NULL
 $  :[17:39:34.303] plan(): Setting new future strategy stack:
[17:39:34.304] List of future strategies:
[17:39:34.304] 1. multicore:
[17:39:34.304]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.304]    - tweaked: FALSE
[17:39:34.304]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefbd8fc8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf01f4150> 
 $  : NULL
 $  :[17:39:34.313] plan(): nbrOfWorkers() = 2
 NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:34.319] resolve() on list ...
[17:39:34.319]  recursive: 0
[17:39:34.320]  length: 6
[17:39:34.320]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:34.320] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.320] - nx: 6
[17:39:34.320] - relay: TRUE
[17:39:34.320] - stdout: TRUE
[17:39:34.321] - signal: TRUE
[17:39:34.321] - resignal: FALSE
[17:39:34.321] - force: TRUE
[17:39:34.321] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.321] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.321]  - until=2
[17:39:34.321]  - relaying element #2
[17:39:34.322] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.322] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.322] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.322]  length: 5 (resolved future 1)
[17:39:34.322] Future #2
[17:39:34.322] result() for MulticoreFuture ...
[17:39:34.323] result() for MulticoreFuture ...
[17:39:34.323] result() for MulticoreFuture ... done
[17:39:34.324] result() for MulticoreFuture ... done
[17:39:34.324] result() for MulticoreFuture ...
[17:39:34.324] result() for MulticoreFuture ... done
[17:39:34.324] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:34.324] - nx: 6
[17:39:34.324] - relay: TRUE
[17:39:34.324] - stdout: TRUE
[17:39:34.324] - signal: TRUE
[17:39:34.325] - resignal: FALSE
[17:39:34.325] - force: TRUE
[17:39:34.325] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.325] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.325]  - until=2
[17:39:34.325]  - relaying element #2
[17:39:34.325] result() for MulticoreFuture ...
[17:39:34.325] result() for MulticoreFuture ... done
[17:39:34.326] result() for MulticoreFuture ...
[17:39:34.326] result() for MulticoreFuture ... done
[17:39:34.326] result() for MulticoreFuture ...
[17:39:34.326] result() for MulticoreFuture ... done
[17:39:34.326] result() for MulticoreFuture ...
[17:39:34.326] result() for MulticoreFuture ... done
[17:39:34.326] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.327] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.327] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:34.327]  length: 4 (resolved future 2)
[17:39:34.327] Future #3
[17:39:34.327] result() for MulticoreFuture ...
[17:39:34.328] result() for MulticoreFuture ...
[17:39:34.328] result() for MulticoreFuture ... done
[17:39:34.328] result() for MulticoreFuture ... done
[17:39:34.328] result() for MulticoreFuture ...
[17:39:34.328] result() for MulticoreFuture ... done
[17:39:34.329] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:34.329] - nx: 6
[17:39:34.329] - relay: TRUE
[17:39:34.329] - stdout: TRUE
[17:39:34.329] - signal: TRUE
[17:39:34.329] - resignal: FALSE
[17:39:34.329] - force: TRUE
[17:39:34.329] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.329] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.330]  - until=3
[17:39:34.330]  - relaying element #3
[17:39:34.330] result() for MulticoreFuture ...
[17:39:34.330] result() for MulticoreFuture ... done
[17:39:34.330] result() for MulticoreFuture ...
[17:39:34.330] result() for MulticoreFuture ... done
[17:39:34.330] result() for MulticoreFuture ...
[17:39:34.330] result() for MulticoreFuture ... done
[17:39:34.330] result() for MulticoreFuture ...
[17:39:34.330] result() for MulticoreFuture ... done
[17:39:34.331] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.331] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.331] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:34.331]  length: 3 (resolved future 3)
[17:39:34.331] signalConditionsASAP(NULL, pos=4) ...
[17:39:34.331] - nx: 6
[17:39:34.331] - relay: TRUE
[17:39:34.331] - stdout: TRUE
[17:39:34.331] - signal: TRUE
[17:39:34.331] - resignal: FALSE
[17:39:34.332] - force: TRUE
[17:39:34.332] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.332] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.332]  - until=5
[17:39:34.332]  - relaying element #5
[17:39:34.332] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.332] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.332] signalConditionsASAP(NULL, pos=4) ... done
[17:39:34.332]  length: 2 (resolved future 4)
[17:39:34.333] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.333] - nx: 6
[17:39:34.333] - relay: TRUE
[17:39:34.333] - stdout: TRUE
[17:39:34.333] - signal: TRUE
[17:39:34.333] - resignal: FALSE
[17:39:34.333] - force: TRUE
[17:39:34.333] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.333] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.333]  - until=6
[17:39:34.333]  - relaying element #6
[17:39:34.334] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.334] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.334] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.334]  length: 1 (resolved future 5)
[17:39:34.334] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.334] - nx: 6
[17:39:34.334] - relay: TRUE
[17:39:34.334] - stdout: TRUE
[17:39:34.334] - signal: TRUE
[17:39:34.334] - resignal: FALSE
[17:39:34.334] - force: TRUE
[17:39:34.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.335] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.335]  - until=6
[17:39:34.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.335] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.335] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.335]  length: 0 (resolved future 6)
[17:39:34.335] Relaying remaining futures
[17:39:34.335] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.335] - nx: 6
[17:39:34.336] - relay: TRUE
[17:39:34.336] - stdout: TRUE
[17:39:34.336] - signal: TRUE
[17:39:34.336] - resignal: FALSE
[17:39:34.336] - force: TRUE
[17:39:34.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.336] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:34.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.336] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.336] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.337] resolve() on list ... DONE
[17:39:34.337] result() for MulticoreFuture ...
[17:39:34.337] result() for MulticoreFuture ... done
[17:39:34.337] result() for MulticoreFuture ...
[17:39:34.337] result() for MulticoreFuture ... done
[17:39:34.337] result() for MulticoreFuture ...
[17:39:34.337] result() for MulticoreFuture ... done
[17:39:34.337] result() for MulticoreFuture ...
[17:39:34.337] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:34.341] getGlobalsAndPackages() ...
[17:39:34.341] Searching for globals...
[17:39:34.341] 
[17:39:34.341] Searching for globals ... DONE
[17:39:34.342] - globals: [0] <none>
[17:39:34.342] getGlobalsAndPackages() ... DONE
[17:39:34.342] run() for ‘Future’ ...
[17:39:34.342] - state: ‘created’
[17:39:34.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.349]   - Field: ‘label’
[17:39:34.349]   - Field: ‘local’
[17:39:34.349]   - Field: ‘owner’
[17:39:34.349]   - Field: ‘envir’
[17:39:34.349]   - Field: ‘workers’
[17:39:34.349]   - Field: ‘packages’
[17:39:34.349]   - Field: ‘gc’
[17:39:34.350]   - Field: ‘job’
[17:39:34.350]   - Field: ‘conditions’
[17:39:34.350]   - Field: ‘expr’
[17:39:34.350]   - Field: ‘uuid’
[17:39:34.350]   - Field: ‘seed’
[17:39:34.350]   - Field: ‘version’
[17:39:34.350]   - Field: ‘result’
[17:39:34.350]   - Field: ‘asynchronous’
[17:39:34.350]   - Field: ‘calls’
[17:39:34.350]   - Field: ‘globals’
[17:39:34.350]   - Field: ‘stdout’
[17:39:34.351]   - Field: ‘earlySignal’
[17:39:34.351]   - Field: ‘lazy’
[17:39:34.351]   - Field: ‘state’
[17:39:34.351] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.351] - Launch lazy future ...
[17:39:34.351] Packages needed by the future expression (n = 0): <none>
[17:39:34.351] Packages needed by future strategies (n = 0): <none>
[17:39:34.352] {
[17:39:34.352]     {
[17:39:34.352]         {
[17:39:34.352]             ...future.startTime <- base::Sys.time()
[17:39:34.352]             {
[17:39:34.352]                 {
[17:39:34.352]                   {
[17:39:34.352]                     {
[17:39:34.352]                       base::local({
[17:39:34.352]                         has_future <- base::requireNamespace("future", 
[17:39:34.352]                           quietly = TRUE)
[17:39:34.352]                         if (has_future) {
[17:39:34.352]                           ns <- base::getNamespace("future")
[17:39:34.352]                           version <- ns[[".package"]][["version"]]
[17:39:34.352]                           if (is.null(version)) 
[17:39:34.352]                             version <- utils::packageVersion("future")
[17:39:34.352]                         }
[17:39:34.352]                         else {
[17:39:34.352]                           version <- NULL
[17:39:34.352]                         }
[17:39:34.352]                         if (!has_future || version < "1.8.0") {
[17:39:34.352]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.352]                             "", base::R.version$version.string), 
[17:39:34.352]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.352]                               "release", "version")], collapse = " "), 
[17:39:34.352]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.352]                             info)
[17:39:34.352]                           info <- base::paste(info, collapse = "; ")
[17:39:34.352]                           if (!has_future) {
[17:39:34.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.352]                               info)
[17:39:34.352]                           }
[17:39:34.352]                           else {
[17:39:34.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.352]                               info, version)
[17:39:34.352]                           }
[17:39:34.352]                           base::stop(msg)
[17:39:34.352]                         }
[17:39:34.352]                       })
[17:39:34.352]                     }
[17:39:34.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.352]                     base::options(mc.cores = 1L)
[17:39:34.352]                   }
[17:39:34.352]                   ...future.strategy.old <- future::plan("list")
[17:39:34.352]                   options(future.plan = NULL)
[17:39:34.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.352]                 }
[17:39:34.352]                 ...future.workdir <- getwd()
[17:39:34.352]             }
[17:39:34.352]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.352]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.352]         }
[17:39:34.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.352]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.352]             base::names(...future.oldOptions))
[17:39:34.352]     }
[17:39:34.352]     if (FALSE) {
[17:39:34.352]     }
[17:39:34.352]     else {
[17:39:34.352]         if (TRUE) {
[17:39:34.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.352]                 open = "w")
[17:39:34.352]         }
[17:39:34.352]         else {
[17:39:34.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.352]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.352]         }
[17:39:34.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.352]             base::sink(type = "output", split = FALSE)
[17:39:34.352]             base::close(...future.stdout)
[17:39:34.352]         }, add = TRUE)
[17:39:34.352]     }
[17:39:34.352]     ...future.frame <- base::sys.nframe()
[17:39:34.352]     ...future.conditions <- base::list()
[17:39:34.352]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.352]     if (FALSE) {
[17:39:34.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.352]     }
[17:39:34.352]     ...future.result <- base::tryCatch({
[17:39:34.352]         base::withCallingHandlers({
[17:39:34.352]             ...future.value <- base::withVisible(base::local({
[17:39:34.352]                 withCallingHandlers({
[17:39:34.352]                   2
[17:39:34.352]                 }, immediateCondition = function(cond) {
[17:39:34.352]                   save_rds <- function (object, pathname, ...) 
[17:39:34.352]                   {
[17:39:34.352]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.352]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.352]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.352]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.352]                         fi_tmp[["mtime"]])
[17:39:34.352]                     }
[17:39:34.352]                     tryCatch({
[17:39:34.352]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.352]                     }, error = function(ex) {
[17:39:34.352]                       msg <- conditionMessage(ex)
[17:39:34.352]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.352]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.352]                         fi_tmp[["mtime"]], msg)
[17:39:34.352]                       ex$message <- msg
[17:39:34.352]                       stop(ex)
[17:39:34.352]                     })
[17:39:34.352]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.352]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.352]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.352]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.352]                       fi <- file.info(pathname)
[17:39:34.352]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.352]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.352]                         fi[["size"]], fi[["mtime"]])
[17:39:34.352]                       stop(msg)
[17:39:34.352]                     }
[17:39:34.352]                     invisible(pathname)
[17:39:34.352]                   }
[17:39:34.352]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.352]                     rootPath = tempdir()) 
[17:39:34.352]                   {
[17:39:34.352]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.352]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.352]                       tmpdir = path, fileext = ".rds")
[17:39:34.352]                     save_rds(obj, file)
[17:39:34.352]                   }
[17:39:34.352]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.352]                   {
[17:39:34.352]                     inherits <- base::inherits
[17:39:34.352]                     invokeRestart <- base::invokeRestart
[17:39:34.352]                     is.null <- base::is.null
[17:39:34.352]                     muffled <- FALSE
[17:39:34.352]                     if (inherits(cond, "message")) {
[17:39:34.352]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.352]                       if (muffled) 
[17:39:34.352]                         invokeRestart("muffleMessage")
[17:39:34.352]                     }
[17:39:34.352]                     else if (inherits(cond, "warning")) {
[17:39:34.352]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.352]                       if (muffled) 
[17:39:34.352]                         invokeRestart("muffleWarning")
[17:39:34.352]                     }
[17:39:34.352]                     else if (inherits(cond, "condition")) {
[17:39:34.352]                       if (!is.null(pattern)) {
[17:39:34.352]                         computeRestarts <- base::computeRestarts
[17:39:34.352]                         grepl <- base::grepl
[17:39:34.352]                         restarts <- computeRestarts(cond)
[17:39:34.352]                         for (restart in restarts) {
[17:39:34.352]                           name <- restart$name
[17:39:34.352]                           if (is.null(name)) 
[17:39:34.352]                             next
[17:39:34.352]                           if (!grepl(pattern, name)) 
[17:39:34.352]                             next
[17:39:34.352]                           invokeRestart(restart)
[17:39:34.352]                           muffled <- TRUE
[17:39:34.352]                           break
[17:39:34.352]                         }
[17:39:34.352]                       }
[17:39:34.352]                     }
[17:39:34.352]                     invisible(muffled)
[17:39:34.352]                   }
[17:39:34.352]                   muffleCondition(cond)
[17:39:34.352]                 })
[17:39:34.352]             }))
[17:39:34.352]             future::FutureResult(value = ...future.value$value, 
[17:39:34.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.352]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.352]                     ...future.globalenv.names))
[17:39:34.352]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.352]         }, condition = base::local({
[17:39:34.352]             c <- base::c
[17:39:34.352]             inherits <- base::inherits
[17:39:34.352]             invokeRestart <- base::invokeRestart
[17:39:34.352]             length <- base::length
[17:39:34.352]             list <- base::list
[17:39:34.352]             seq.int <- base::seq.int
[17:39:34.352]             signalCondition <- base::signalCondition
[17:39:34.352]             sys.calls <- base::sys.calls
[17:39:34.352]             `[[` <- base::`[[`
[17:39:34.352]             `+` <- base::`+`
[17:39:34.352]             `<<-` <- base::`<<-`
[17:39:34.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.352]                   3L)]
[17:39:34.352]             }
[17:39:34.352]             function(cond) {
[17:39:34.352]                 is_error <- inherits(cond, "error")
[17:39:34.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.352]                   NULL)
[17:39:34.352]                 if (is_error) {
[17:39:34.352]                   sessionInformation <- function() {
[17:39:34.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.352]                       search = base::search(), system = base::Sys.info())
[17:39:34.352]                   }
[17:39:34.352]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.352]                     cond$call), session = sessionInformation(), 
[17:39:34.352]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.352]                   signalCondition(cond)
[17:39:34.352]                 }
[17:39:34.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.352]                 "immediateCondition"))) {
[17:39:34.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.352]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.352]                   if (TRUE && !signal) {
[17:39:34.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.352]                     {
[17:39:34.352]                       inherits <- base::inherits
[17:39:34.352]                       invokeRestart <- base::invokeRestart
[17:39:34.352]                       is.null <- base::is.null
[17:39:34.352]                       muffled <- FALSE
[17:39:34.352]                       if (inherits(cond, "message")) {
[17:39:34.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.352]                         if (muffled) 
[17:39:34.352]                           invokeRestart("muffleMessage")
[17:39:34.352]                       }
[17:39:34.352]                       else if (inherits(cond, "warning")) {
[17:39:34.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.352]                         if (muffled) 
[17:39:34.352]                           invokeRestart("muffleWarning")
[17:39:34.352]                       }
[17:39:34.352]                       else if (inherits(cond, "condition")) {
[17:39:34.352]                         if (!is.null(pattern)) {
[17:39:34.352]                           computeRestarts <- base::computeRestarts
[17:39:34.352]                           grepl <- base::grepl
[17:39:34.352]                           restarts <- computeRestarts(cond)
[17:39:34.352]                           for (restart in restarts) {
[17:39:34.352]                             name <- restart$name
[17:39:34.352]                             if (is.null(name)) 
[17:39:34.352]                               next
[17:39:34.352]                             if (!grepl(pattern, name)) 
[17:39:34.352]                               next
[17:39:34.352]                             invokeRestart(restart)
[17:39:34.352]                             muffled <- TRUE
[17:39:34.352]                             break
[17:39:34.352]                           }
[17:39:34.352]                         }
[17:39:34.352]                       }
[17:39:34.352]                       invisible(muffled)
[17:39:34.352]                     }
[17:39:34.352]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.352]                   }
[17:39:34.352]                 }
[17:39:34.352]                 else {
[17:39:34.352]                   if (TRUE) {
[17:39:34.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.352]                     {
[17:39:34.352]                       inherits <- base::inherits
[17:39:34.352]                       invokeRestart <- base::invokeRestart
[17:39:34.352]                       is.null <- base::is.null
[17:39:34.352]                       muffled <- FALSE
[17:39:34.352]                       if (inherits(cond, "message")) {
[17:39:34.352]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.352]                         if (muffled) 
[17:39:34.352]                           invokeRestart("muffleMessage")
[17:39:34.352]                       }
[17:39:34.352]                       else if (inherits(cond, "warning")) {
[17:39:34.352]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.352]                         if (muffled) 
[17:39:34.352]                           invokeRestart("muffleWarning")
[17:39:34.352]                       }
[17:39:34.352]                       else if (inherits(cond, "condition")) {
[17:39:34.352]                         if (!is.null(pattern)) {
[17:39:34.352]                           computeRestarts <- base::computeRestarts
[17:39:34.352]                           grepl <- base::grepl
[17:39:34.352]                           restarts <- computeRestarts(cond)
[17:39:34.352]                           for (restart in restarts) {
[17:39:34.352]                             name <- restart$name
[17:39:34.352]                             if (is.null(name)) 
[17:39:34.352]                               next
[17:39:34.352]                             if (!grepl(pattern, name)) 
[17:39:34.352]                               next
[17:39:34.352]                             invokeRestart(restart)
[17:39:34.352]                             muffled <- TRUE
[17:39:34.352]                             break
[17:39:34.352]                           }
[17:39:34.352]                         }
[17:39:34.352]                       }
[17:39:34.352]                       invisible(muffled)
[17:39:34.352]                     }
[17:39:34.352]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.352]                   }
[17:39:34.352]                 }
[17:39:34.352]             }
[17:39:34.352]         }))
[17:39:34.352]     }, error = function(ex) {
[17:39:34.352]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.352]                 ...future.rng), started = ...future.startTime, 
[17:39:34.352]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.352]             version = "1.8"), class = "FutureResult")
[17:39:34.352]     }, finally = {
[17:39:34.352]         if (!identical(...future.workdir, getwd())) 
[17:39:34.352]             setwd(...future.workdir)
[17:39:34.352]         {
[17:39:34.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.352]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.352]             }
[17:39:34.352]             base::options(...future.oldOptions)
[17:39:34.352]             if (.Platform$OS.type == "windows") {
[17:39:34.352]                 old_names <- names(...future.oldEnvVars)
[17:39:34.352]                 envs <- base::Sys.getenv()
[17:39:34.352]                 names <- names(envs)
[17:39:34.352]                 common <- intersect(names, old_names)
[17:39:34.352]                 added <- setdiff(names, old_names)
[17:39:34.352]                 removed <- setdiff(old_names, names)
[17:39:34.352]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.352]                   envs[common]]
[17:39:34.352]                 NAMES <- toupper(changed)
[17:39:34.352]                 args <- list()
[17:39:34.352]                 for (kk in seq_along(NAMES)) {
[17:39:34.352]                   name <- changed[[kk]]
[17:39:34.352]                   NAME <- NAMES[[kk]]
[17:39:34.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.352]                     next
[17:39:34.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.352]                 }
[17:39:34.352]                 NAMES <- toupper(added)
[17:39:34.352]                 for (kk in seq_along(NAMES)) {
[17:39:34.352]                   name <- added[[kk]]
[17:39:34.352]                   NAME <- NAMES[[kk]]
[17:39:34.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.352]                     next
[17:39:34.352]                   args[[name]] <- ""
[17:39:34.352]                 }
[17:39:34.352]                 NAMES <- toupper(removed)
[17:39:34.352]                 for (kk in seq_along(NAMES)) {
[17:39:34.352]                   name <- removed[[kk]]
[17:39:34.352]                   NAME <- NAMES[[kk]]
[17:39:34.352]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.352]                     next
[17:39:34.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.352]                 }
[17:39:34.352]                 if (length(args) > 0) 
[17:39:34.352]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.352]             }
[17:39:34.352]             else {
[17:39:34.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.352]             }
[17:39:34.352]             {
[17:39:34.352]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.352]                   0L) {
[17:39:34.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.352]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.352]                   base::options(opts)
[17:39:34.352]                 }
[17:39:34.352]                 {
[17:39:34.352]                   {
[17:39:34.352]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.352]                     NULL
[17:39:34.352]                   }
[17:39:34.352]                   options(future.plan = NULL)
[17:39:34.352]                   if (is.na(NA_character_)) 
[17:39:34.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.352]                     .init = FALSE)
[17:39:34.352]                 }
[17:39:34.352]             }
[17:39:34.352]         }
[17:39:34.352]     })
[17:39:34.352]     if (TRUE) {
[17:39:34.352]         base::sink(type = "output", split = FALSE)
[17:39:34.352]         if (TRUE) {
[17:39:34.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.352]         }
[17:39:34.352]         else {
[17:39:34.352]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.352]         }
[17:39:34.352]         base::close(...future.stdout)
[17:39:34.352]         ...future.stdout <- NULL
[17:39:34.352]     }
[17:39:34.352]     ...future.result$conditions <- ...future.conditions
[17:39:34.352]     ...future.result$finished <- base::Sys.time()
[17:39:34.352]     ...future.result
[17:39:34.352] }
[17:39:34.354] requestCore(): workers = 2
[17:39:34.356] MulticoreFuture started
[17:39:34.356] - Launch lazy future ... done
[17:39:34.357] run() for ‘MulticoreFuture’ ... done
[17:39:34.357] getGlobalsAndPackages() ...
[17:39:34.357] plan(): Setting new future strategy stack:
[17:39:34.357] Searching for globals...
[17:39:34.357] List of future strategies:
[17:39:34.357] 1. sequential:
[17:39:34.357]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.357]    - tweaked: FALSE
[17:39:34.357]    - call: NULL
[17:39:34.358] 
[17:39:34.359] plan(): nbrOfWorkers() = 1
[17:39:34.359] Searching for globals ... DONE
[17:39:34.359] - globals: [0] <none>
[17:39:34.359] getGlobalsAndPackages() ... DONE
[17:39:34.360] run() for ‘Future’ ...
[17:39:34.360] - state: ‘created’
[17:39:34.360] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.361] plan(): Setting new future strategy stack:
[17:39:34.361] List of future strategies:
[17:39:34.361] 1. multicore:
[17:39:34.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.361]    - tweaked: FALSE
[17:39:34.361]    - call: plan(strategy)
[17:39:34.366] plan(): nbrOfWorkers() = 2
[17:39:34.366] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.366]   - Field: ‘label’
[17:39:34.367]   - Field: ‘local’
[17:39:34.367]   - Field: ‘owner’
[17:39:34.367]   - Field: ‘envir’
[17:39:34.367]   - Field: ‘workers’
[17:39:34.367]   - Field: ‘packages’
[17:39:34.367]   - Field: ‘gc’
[17:39:34.368]   - Field: ‘job’
[17:39:34.368]   - Field: ‘conditions’
[17:39:34.368]   - Field: ‘expr’
[17:39:34.368]   - Field: ‘uuid’
[17:39:34.368]   - Field: ‘seed’
[17:39:34.368]   - Field: ‘version’
[17:39:34.369]   - Field: ‘result’
[17:39:34.369]   - Field: ‘asynchronous’
[17:39:34.369]   - Field: ‘calls’
[17:39:34.369]   - Field: ‘globals’
[17:39:34.369]   - Field: ‘stdout’
[17:39:34.369]   - Field: ‘earlySignal’
[17:39:34.370]   - Field: ‘lazy’
[17:39:34.370]   - Field: ‘state’
[17:39:34.370] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.370] - Launch lazy future ...
[17:39:34.370] Packages needed by the future expression (n = 0): <none>
[17:39:34.371] Packages needed by future strategies (n = 0): <none>
[17:39:34.371] {
[17:39:34.371]     {
[17:39:34.371]         {
[17:39:34.371]             ...future.startTime <- base::Sys.time()
[17:39:34.371]             {
[17:39:34.371]                 {
[17:39:34.371]                   {
[17:39:34.371]                     {
[17:39:34.371]                       base::local({
[17:39:34.371]                         has_future <- base::requireNamespace("future", 
[17:39:34.371]                           quietly = TRUE)
[17:39:34.371]                         if (has_future) {
[17:39:34.371]                           ns <- base::getNamespace("future")
[17:39:34.371]                           version <- ns[[".package"]][["version"]]
[17:39:34.371]                           if (is.null(version)) 
[17:39:34.371]                             version <- utils::packageVersion("future")
[17:39:34.371]                         }
[17:39:34.371]                         else {
[17:39:34.371]                           version <- NULL
[17:39:34.371]                         }
[17:39:34.371]                         if (!has_future || version < "1.8.0") {
[17:39:34.371]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.371]                             "", base::R.version$version.string), 
[17:39:34.371]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.371]                               "release", "version")], collapse = " "), 
[17:39:34.371]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.371]                             info)
[17:39:34.371]                           info <- base::paste(info, collapse = "; ")
[17:39:34.371]                           if (!has_future) {
[17:39:34.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.371]                               info)
[17:39:34.371]                           }
[17:39:34.371]                           else {
[17:39:34.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.371]                               info, version)
[17:39:34.371]                           }
[17:39:34.371]                           base::stop(msg)
[17:39:34.371]                         }
[17:39:34.371]                       })
[17:39:34.371]                     }
[17:39:34.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.371]                     base::options(mc.cores = 1L)
[17:39:34.371]                   }
[17:39:34.371]                   ...future.strategy.old <- future::plan("list")
[17:39:34.371]                   options(future.plan = NULL)
[17:39:34.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.371]                 }
[17:39:34.371]                 ...future.workdir <- getwd()
[17:39:34.371]             }
[17:39:34.371]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.371]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.371]         }
[17:39:34.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.371]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.371]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.371]             base::names(...future.oldOptions))
[17:39:34.371]     }
[17:39:34.371]     if (FALSE) {
[17:39:34.371]     }
[17:39:34.371]     else {
[17:39:34.371]         if (TRUE) {
[17:39:34.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.371]                 open = "w")
[17:39:34.371]         }
[17:39:34.371]         else {
[17:39:34.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.371]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.371]         }
[17:39:34.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.371]             base::sink(type = "output", split = FALSE)
[17:39:34.371]             base::close(...future.stdout)
[17:39:34.371]         }, add = TRUE)
[17:39:34.371]     }
[17:39:34.371]     ...future.frame <- base::sys.nframe()
[17:39:34.371]     ...future.conditions <- base::list()
[17:39:34.371]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.371]     if (FALSE) {
[17:39:34.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.371]     }
[17:39:34.371]     ...future.result <- base::tryCatch({
[17:39:34.371]         base::withCallingHandlers({
[17:39:34.371]             ...future.value <- base::withVisible(base::local({
[17:39:34.371]                 withCallingHandlers({
[17:39:34.371]                   NULL
[17:39:34.371]                 }, immediateCondition = function(cond) {
[17:39:34.371]                   save_rds <- function (object, pathname, ...) 
[17:39:34.371]                   {
[17:39:34.371]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.371]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.371]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.371]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.371]                         fi_tmp[["mtime"]])
[17:39:34.371]                     }
[17:39:34.371]                     tryCatch({
[17:39:34.371]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.371]                     }, error = function(ex) {
[17:39:34.371]                       msg <- conditionMessage(ex)
[17:39:34.371]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.371]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.371]                         fi_tmp[["mtime"]], msg)
[17:39:34.371]                       ex$message <- msg
[17:39:34.371]                       stop(ex)
[17:39:34.371]                     })
[17:39:34.371]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.371]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.371]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.371]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.371]                       fi <- file.info(pathname)
[17:39:34.371]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.371]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.371]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.371]                         fi[["size"]], fi[["mtime"]])
[17:39:34.371]                       stop(msg)
[17:39:34.371]                     }
[17:39:34.371]                     invisible(pathname)
[17:39:34.371]                   }
[17:39:34.371]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.371]                     rootPath = tempdir()) 
[17:39:34.371]                   {
[17:39:34.371]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.371]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.371]                       tmpdir = path, fileext = ".rds")
[17:39:34.371]                     save_rds(obj, file)
[17:39:34.371]                   }
[17:39:34.371]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.371]                   {
[17:39:34.371]                     inherits <- base::inherits
[17:39:34.371]                     invokeRestart <- base::invokeRestart
[17:39:34.371]                     is.null <- base::is.null
[17:39:34.371]                     muffled <- FALSE
[17:39:34.371]                     if (inherits(cond, "message")) {
[17:39:34.371]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.371]                       if (muffled) 
[17:39:34.371]                         invokeRestart("muffleMessage")
[17:39:34.371]                     }
[17:39:34.371]                     else if (inherits(cond, "warning")) {
[17:39:34.371]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.371]                       if (muffled) 
[17:39:34.371]                         invokeRestart("muffleWarning")
[17:39:34.371]                     }
[17:39:34.371]                     else if (inherits(cond, "condition")) {
[17:39:34.371]                       if (!is.null(pattern)) {
[17:39:34.371]                         computeRestarts <- base::computeRestarts
[17:39:34.371]                         grepl <- base::grepl
[17:39:34.371]                         restarts <- computeRestarts(cond)
[17:39:34.371]                         for (restart in restarts) {
[17:39:34.371]                           name <- restart$name
[17:39:34.371]                           if (is.null(name)) 
[17:39:34.371]                             next
[17:39:34.371]                           if (!grepl(pattern, name)) 
[17:39:34.371]                             next
[17:39:34.371]                           invokeRestart(restart)
[17:39:34.371]                           muffled <- TRUE
[17:39:34.371]                           break
[17:39:34.371]                         }
[17:39:34.371]                       }
[17:39:34.371]                     }
[17:39:34.371]                     invisible(muffled)
[17:39:34.371]                   }
[17:39:34.371]                   muffleCondition(cond)
[17:39:34.371]                 })
[17:39:34.371]             }))
[17:39:34.371]             future::FutureResult(value = ...future.value$value, 
[17:39:34.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.371]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.371]                     ...future.globalenv.names))
[17:39:34.371]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.371]         }, condition = base::local({
[17:39:34.371]             c <- base::c
[17:39:34.371]             inherits <- base::inherits
[17:39:34.371]             invokeRestart <- base::invokeRestart
[17:39:34.371]             length <- base::length
[17:39:34.371]             list <- base::list
[17:39:34.371]             seq.int <- base::seq.int
[17:39:34.371]             signalCondition <- base::signalCondition
[17:39:34.371]             sys.calls <- base::sys.calls
[17:39:34.371]             `[[` <- base::`[[`
[17:39:34.371]             `+` <- base::`+`
[17:39:34.371]             `<<-` <- base::`<<-`
[17:39:34.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.371]                   3L)]
[17:39:34.371]             }
[17:39:34.371]             function(cond) {
[17:39:34.371]                 is_error <- inherits(cond, "error")
[17:39:34.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.371]                   NULL)
[17:39:34.371]                 if (is_error) {
[17:39:34.371]                   sessionInformation <- function() {
[17:39:34.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.371]                       search = base::search(), system = base::Sys.info())
[17:39:34.371]                   }
[17:39:34.371]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.371]                     cond$call), session = sessionInformation(), 
[17:39:34.371]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.371]                   signalCondition(cond)
[17:39:34.371]                 }
[17:39:34.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.371]                 "immediateCondition"))) {
[17:39:34.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.371]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.371]                   if (TRUE && !signal) {
[17:39:34.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.371]                     {
[17:39:34.371]                       inherits <- base::inherits
[17:39:34.371]                       invokeRestart <- base::invokeRestart
[17:39:34.371]                       is.null <- base::is.null
[17:39:34.371]                       muffled <- FALSE
[17:39:34.371]                       if (inherits(cond, "message")) {
[17:39:34.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.371]                         if (muffled) 
[17:39:34.371]                           invokeRestart("muffleMessage")
[17:39:34.371]                       }
[17:39:34.371]                       else if (inherits(cond, "warning")) {
[17:39:34.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.371]                         if (muffled) 
[17:39:34.371]                           invokeRestart("muffleWarning")
[17:39:34.371]                       }
[17:39:34.371]                       else if (inherits(cond, "condition")) {
[17:39:34.371]                         if (!is.null(pattern)) {
[17:39:34.371]                           computeRestarts <- base::computeRestarts
[17:39:34.371]                           grepl <- base::grepl
[17:39:34.371]                           restarts <- computeRestarts(cond)
[17:39:34.371]                           for (restart in restarts) {
[17:39:34.371]                             name <- restart$name
[17:39:34.371]                             if (is.null(name)) 
[17:39:34.371]                               next
[17:39:34.371]                             if (!grepl(pattern, name)) 
[17:39:34.371]                               next
[17:39:34.371]                             invokeRestart(restart)
[17:39:34.371]                             muffled <- TRUE
[17:39:34.371]                             break
[17:39:34.371]                           }
[17:39:34.371]                         }
[17:39:34.371]                       }
[17:39:34.371]                       invisible(muffled)
[17:39:34.371]                     }
[17:39:34.371]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.371]                   }
[17:39:34.371]                 }
[17:39:34.371]                 else {
[17:39:34.371]                   if (TRUE) {
[17:39:34.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.371]                     {
[17:39:34.371]                       inherits <- base::inherits
[17:39:34.371]                       invokeRestart <- base::invokeRestart
[17:39:34.371]                       is.null <- base::is.null
[17:39:34.371]                       muffled <- FALSE
[17:39:34.371]                       if (inherits(cond, "message")) {
[17:39:34.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.371]                         if (muffled) 
[17:39:34.371]                           invokeRestart("muffleMessage")
[17:39:34.371]                       }
[17:39:34.371]                       else if (inherits(cond, "warning")) {
[17:39:34.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.371]                         if (muffled) 
[17:39:34.371]                           invokeRestart("muffleWarning")
[17:39:34.371]                       }
[17:39:34.371]                       else if (inherits(cond, "condition")) {
[17:39:34.371]                         if (!is.null(pattern)) {
[17:39:34.371]                           computeRestarts <- base::computeRestarts
[17:39:34.371]                           grepl <- base::grepl
[17:39:34.371]                           restarts <- computeRestarts(cond)
[17:39:34.371]                           for (restart in restarts) {
[17:39:34.371]                             name <- restart$name
[17:39:34.371]                             if (is.null(name)) 
[17:39:34.371]                               next
[17:39:34.371]                             if (!grepl(pattern, name)) 
[17:39:34.371]                               next
[17:39:34.371]                             invokeRestart(restart)
[17:39:34.371]                             muffled <- TRUE
[17:39:34.371]                             break
[17:39:34.371]                           }
[17:39:34.371]                         }
[17:39:34.371]                       }
[17:39:34.371]                       invisible(muffled)
[17:39:34.371]                     }
[17:39:34.371]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.371]                   }
[17:39:34.371]                 }
[17:39:34.371]             }
[17:39:34.371]         }))
[17:39:34.371]     }, error = function(ex) {
[17:39:34.371]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.371]                 ...future.rng), started = ...future.startTime, 
[17:39:34.371]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.371]             version = "1.8"), class = "FutureResult")
[17:39:34.371]     }, finally = {
[17:39:34.371]         if (!identical(...future.workdir, getwd())) 
[17:39:34.371]             setwd(...future.workdir)
[17:39:34.371]         {
[17:39:34.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.371]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.371]             }
[17:39:34.371]             base::options(...future.oldOptions)
[17:39:34.371]             if (.Platform$OS.type == "windows") {
[17:39:34.371]                 old_names <- names(...future.oldEnvVars)
[17:39:34.371]                 envs <- base::Sys.getenv()
[17:39:34.371]                 names <- names(envs)
[17:39:34.371]                 common <- intersect(names, old_names)
[17:39:34.371]                 added <- setdiff(names, old_names)
[17:39:34.371]                 removed <- setdiff(old_names, names)
[17:39:34.371]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.371]                   envs[common]]
[17:39:34.371]                 NAMES <- toupper(changed)
[17:39:34.371]                 args <- list()
[17:39:34.371]                 for (kk in seq_along(NAMES)) {
[17:39:34.371]                   name <- changed[[kk]]
[17:39:34.371]                   NAME <- NAMES[[kk]]
[17:39:34.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.371]                     next
[17:39:34.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.371]                 }
[17:39:34.371]                 NAMES <- toupper(added)
[17:39:34.371]                 for (kk in seq_along(NAMES)) {
[17:39:34.371]                   name <- added[[kk]]
[17:39:34.371]                   NAME <- NAMES[[kk]]
[17:39:34.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.371]                     next
[17:39:34.371]                   args[[name]] <- ""
[17:39:34.371]                 }
[17:39:34.371]                 NAMES <- toupper(removed)
[17:39:34.371]                 for (kk in seq_along(NAMES)) {
[17:39:34.371]                   name <- removed[[kk]]
[17:39:34.371]                   NAME <- NAMES[[kk]]
[17:39:34.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.371]                     next
[17:39:34.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.371]                 }
[17:39:34.371]                 if (length(args) > 0) 
[17:39:34.371]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.371]             }
[17:39:34.371]             else {
[17:39:34.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.371]             }
[17:39:34.371]             {
[17:39:34.371]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.371]                   0L) {
[17:39:34.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.371]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.371]                   base::options(opts)
[17:39:34.371]                 }
[17:39:34.371]                 {
[17:39:34.371]                   {
[17:39:34.371]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.371]                     NULL
[17:39:34.371]                   }
[17:39:34.371]                   options(future.plan = NULL)
[17:39:34.371]                   if (is.na(NA_character_)) 
[17:39:34.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.371]                     .init = FALSE)
[17:39:34.371]                 }
[17:39:34.371]             }
[17:39:34.371]         }
[17:39:34.371]     })
[17:39:34.371]     if (TRUE) {
[17:39:34.371]         base::sink(type = "output", split = FALSE)
[17:39:34.371]         if (TRUE) {
[17:39:34.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.371]         }
[17:39:34.371]         else {
[17:39:34.371]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.371]         }
[17:39:34.371]         base::close(...future.stdout)
[17:39:34.371]         ...future.stdout <- NULL
[17:39:34.371]     }
[17:39:34.371]     ...future.result$conditions <- ...future.conditions
[17:39:34.371]     ...future.result$finished <- base::Sys.time()
[17:39:34.371]     ...future.result
[17:39:34.371] }
[17:39:34.375] requestCore(): workers = 2
[17:39:34.378] MulticoreFuture started
[17:39:34.378] - Launch lazy future ... done
[17:39:34.378] run() for ‘MulticoreFuture’ ... done
List of 6
[17:39:34.379] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[17:39:34.379] List of future strategies:
[17:39:34.379] 1. sequential:
[17:39:34.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.379]    - tweaked: FALSE
[17:39:34.379]    - call: NULL
[17:39:34.380] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf088daa8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adedeabdb0> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:39:34.382] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:39:34.382] List of future strategies:
[17:39:34.382] 1. multicore:
[17:39:34.382]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.382]    - tweaked: FALSE
[17:39:34.382]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf088daa8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adedeabdb0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:34.388] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:34.391] resolve() on list ...
[17:39:34.392]  recursive: 0
[17:39:34.392]  length: 6
[17:39:34.392]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:34.392] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.392] - nx: 6
[17:39:34.392] - relay: TRUE
[17:39:34.393] - stdout: TRUE
[17:39:34.393] - signal: TRUE
[17:39:34.393] - resignal: FALSE
[17:39:34.393] - force: TRUE
[17:39:34.393] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.393] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.393]  - until=2
[17:39:34.394]  - relaying element #2
[17:39:34.394] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.394] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.394] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.394]  length: 5 (resolved future 1)
[17:39:34.394] Future #2
[17:39:34.395] result() for MulticoreFuture ...
[17:39:34.396] result() for MulticoreFuture ...
[17:39:34.396] result() for MulticoreFuture ... done
[17:39:34.396] result() for MulticoreFuture ... done
[17:39:34.396] result() for MulticoreFuture ...
[17:39:34.396] result() for MulticoreFuture ... done
[17:39:34.396] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:34.396] - nx: 6
[17:39:34.397] - relay: TRUE
[17:39:34.397] - stdout: TRUE
[17:39:34.397] - signal: TRUE
[17:39:34.397] - resignal: FALSE
[17:39:34.397] - force: TRUE
[17:39:34.397] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.397] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.397]  - until=2
[17:39:34.398]  - relaying element #2
[17:39:34.398] result() for MulticoreFuture ...
[17:39:34.398] result() for MulticoreFuture ... done
[17:39:34.398] result() for MulticoreFuture ...
[17:39:34.398] result() for MulticoreFuture ... done
[17:39:34.398] result() for MulticoreFuture ...
[17:39:34.398] result() for MulticoreFuture ... done
[17:39:34.399] result() for MulticoreFuture ...
[17:39:34.399] result() for MulticoreFuture ... done
[17:39:34.399] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.399] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.399] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:34.399]  length: 4 (resolved future 2)
[17:39:34.400] Future #3
[17:39:34.400] result() for MulticoreFuture ...
[17:39:34.400] result() for MulticoreFuture ...
[17:39:34.401] result() for MulticoreFuture ... done
[17:39:34.401] result() for MulticoreFuture ... done
[17:39:34.401] result() for MulticoreFuture ...
[17:39:34.401] result() for MulticoreFuture ... done
[17:39:34.401] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:34.402] - nx: 6
[17:39:34.402] - relay: TRUE
[17:39:34.402] - stdout: TRUE
[17:39:34.405] - signal: TRUE
[17:39:34.405] - resignal: FALSE
[17:39:34.406] - force: TRUE
[17:39:34.406] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.406] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.406]  - until=3
[17:39:34.406]  - relaying element #3
[17:39:34.407] result() for MulticoreFuture ...
[17:39:34.407] result() for MulticoreFuture ... done
[17:39:34.407] result() for MulticoreFuture ...
[17:39:34.407] result() for MulticoreFuture ... done
[17:39:34.407] result() for MulticoreFuture ...
[17:39:34.407] result() for MulticoreFuture ... done
[17:39:34.408] result() for MulticoreFuture ...
[17:39:34.408] result() for MulticoreFuture ... done
[17:39:34.408] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.408] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.408] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:34.408]  length: 3 (resolved future 3)
[17:39:34.408] signalConditionsASAP(NULL, pos=4) ...
[17:39:34.408] - nx: 6
[17:39:34.409] - relay: TRUE
[17:39:34.409] - stdout: TRUE
[17:39:34.409] - signal: TRUE
[17:39:34.409] - resignal: FALSE
[17:39:34.409] - force: TRUE
[17:39:34.409] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.409] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.409]  - until=5
[17:39:34.409]  - relaying element #5
[17:39:34.410] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.410] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.410] signalConditionsASAP(NULL, pos=4) ... done
[17:39:34.410]  length: 2 (resolved future 4)
[17:39:34.410] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.410] - nx: 6
[17:39:34.410] - relay: TRUE
[17:39:34.410] - stdout: TRUE
[17:39:34.410] - signal: TRUE
[17:39:34.411] - resignal: FALSE
[17:39:34.411] - force: TRUE
[17:39:34.411] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.411] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.411]  - until=6
[17:39:34.411]  - relaying element #6
[17:39:34.411] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.411] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.411] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.412]  length: 1 (resolved future 5)
[17:39:34.412] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.412] - nx: 6
[17:39:34.412] - relay: TRUE
[17:39:34.412] - stdout: TRUE
[17:39:34.412] - signal: TRUE
[17:39:34.412] - resignal: FALSE
[17:39:34.412] - force: TRUE
[17:39:34.412] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.412] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.413]  - until=6
[17:39:34.413] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.413] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.413] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.413]  length: 0 (resolved future 6)
[17:39:34.413] Relaying remaining futures
[17:39:34.413] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.413] - nx: 6
[17:39:34.413] - relay: TRUE
[17:39:34.413] - stdout: TRUE
[17:39:34.414] - signal: TRUE
[17:39:34.414] - resignal: FALSE
[17:39:34.414] - force: TRUE
[17:39:34.414] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.414] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:34.414] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.414] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.414] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.414] resolve() on list ... DONE
[17:39:34.415] result() for MulticoreFuture ...
[17:39:34.415] result() for MulticoreFuture ... done
[17:39:34.415] result() for MulticoreFuture ...
[17:39:34.415] result() for MulticoreFuture ... done
[17:39:34.415] result() for MulticoreFuture ...
[17:39:34.415] result() for MulticoreFuture ... done
[17:39:34.415] result() for MulticoreFuture ...
[17:39:34.415] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:34.419] getGlobalsAndPackages() ...
[17:39:34.419] Searching for globals...
[17:39:34.420] 
[17:39:34.420] Searching for globals ... DONE
[17:39:34.420] - globals: [0] <none>
[17:39:34.420] getGlobalsAndPackages() ... DONE
[17:39:34.420] run() for ‘Future’ ...
[17:39:34.420] - state: ‘created’
[17:39:34.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.424] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.424]   - Field: ‘label’
[17:39:34.425]   - Field: ‘local’
[17:39:34.425]   - Field: ‘owner’
[17:39:34.425]   - Field: ‘envir’
[17:39:34.425]   - Field: ‘workers’
[17:39:34.425]   - Field: ‘packages’
[17:39:34.425]   - Field: ‘gc’
[17:39:34.425]   - Field: ‘job’
[17:39:34.425]   - Field: ‘conditions’
[17:39:34.425]   - Field: ‘expr’
[17:39:34.425]   - Field: ‘uuid’
[17:39:34.426]   - Field: ‘seed’
[17:39:34.426]   - Field: ‘version’
[17:39:34.426]   - Field: ‘result’
[17:39:34.426]   - Field: ‘asynchronous’
[17:39:34.426]   - Field: ‘calls’
[17:39:34.426]   - Field: ‘globals’
[17:39:34.426]   - Field: ‘stdout’
[17:39:34.426]   - Field: ‘earlySignal’
[17:39:34.426]   - Field: ‘lazy’
[17:39:34.426]   - Field: ‘state’
[17:39:34.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.427] - Launch lazy future ...
[17:39:34.427] Packages needed by the future expression (n = 0): <none>
[17:39:34.427] Packages needed by future strategies (n = 0): <none>
[17:39:34.427] {
[17:39:34.427]     {
[17:39:34.427]         {
[17:39:34.427]             ...future.startTime <- base::Sys.time()
[17:39:34.427]             {
[17:39:34.427]                 {
[17:39:34.427]                   {
[17:39:34.427]                     {
[17:39:34.427]                       base::local({
[17:39:34.427]                         has_future <- base::requireNamespace("future", 
[17:39:34.427]                           quietly = TRUE)
[17:39:34.427]                         if (has_future) {
[17:39:34.427]                           ns <- base::getNamespace("future")
[17:39:34.427]                           version <- ns[[".package"]][["version"]]
[17:39:34.427]                           if (is.null(version)) 
[17:39:34.427]                             version <- utils::packageVersion("future")
[17:39:34.427]                         }
[17:39:34.427]                         else {
[17:39:34.427]                           version <- NULL
[17:39:34.427]                         }
[17:39:34.427]                         if (!has_future || version < "1.8.0") {
[17:39:34.427]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.427]                             "", base::R.version$version.string), 
[17:39:34.427]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.427]                               "release", "version")], collapse = " "), 
[17:39:34.427]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.427]                             info)
[17:39:34.427]                           info <- base::paste(info, collapse = "; ")
[17:39:34.427]                           if (!has_future) {
[17:39:34.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.427]                               info)
[17:39:34.427]                           }
[17:39:34.427]                           else {
[17:39:34.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.427]                               info, version)
[17:39:34.427]                           }
[17:39:34.427]                           base::stop(msg)
[17:39:34.427]                         }
[17:39:34.427]                       })
[17:39:34.427]                     }
[17:39:34.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.427]                     base::options(mc.cores = 1L)
[17:39:34.427]                   }
[17:39:34.427]                   ...future.strategy.old <- future::plan("list")
[17:39:34.427]                   options(future.plan = NULL)
[17:39:34.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.427]                 }
[17:39:34.427]                 ...future.workdir <- getwd()
[17:39:34.427]             }
[17:39:34.427]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.427]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.427]         }
[17:39:34.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.427]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.427]             base::names(...future.oldOptions))
[17:39:34.427]     }
[17:39:34.427]     if (FALSE) {
[17:39:34.427]     }
[17:39:34.427]     else {
[17:39:34.427]         if (TRUE) {
[17:39:34.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.427]                 open = "w")
[17:39:34.427]         }
[17:39:34.427]         else {
[17:39:34.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.427]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.427]         }
[17:39:34.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.427]             base::sink(type = "output", split = FALSE)
[17:39:34.427]             base::close(...future.stdout)
[17:39:34.427]         }, add = TRUE)
[17:39:34.427]     }
[17:39:34.427]     ...future.frame <- base::sys.nframe()
[17:39:34.427]     ...future.conditions <- base::list()
[17:39:34.427]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.427]     if (FALSE) {
[17:39:34.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.427]     }
[17:39:34.427]     ...future.result <- base::tryCatch({
[17:39:34.427]         base::withCallingHandlers({
[17:39:34.427]             ...future.value <- base::withVisible(base::local({
[17:39:34.427]                 withCallingHandlers({
[17:39:34.427]                   2
[17:39:34.427]                 }, immediateCondition = function(cond) {
[17:39:34.427]                   save_rds <- function (object, pathname, ...) 
[17:39:34.427]                   {
[17:39:34.427]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.427]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.427]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.427]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.427]                         fi_tmp[["mtime"]])
[17:39:34.427]                     }
[17:39:34.427]                     tryCatch({
[17:39:34.427]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.427]                     }, error = function(ex) {
[17:39:34.427]                       msg <- conditionMessage(ex)
[17:39:34.427]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.427]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.427]                         fi_tmp[["mtime"]], msg)
[17:39:34.427]                       ex$message <- msg
[17:39:34.427]                       stop(ex)
[17:39:34.427]                     })
[17:39:34.427]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.427]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.427]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.427]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.427]                       fi <- file.info(pathname)
[17:39:34.427]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.427]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.427]                         fi[["size"]], fi[["mtime"]])
[17:39:34.427]                       stop(msg)
[17:39:34.427]                     }
[17:39:34.427]                     invisible(pathname)
[17:39:34.427]                   }
[17:39:34.427]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.427]                     rootPath = tempdir()) 
[17:39:34.427]                   {
[17:39:34.427]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.427]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.427]                       tmpdir = path, fileext = ".rds")
[17:39:34.427]                     save_rds(obj, file)
[17:39:34.427]                   }
[17:39:34.427]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.427]                   {
[17:39:34.427]                     inherits <- base::inherits
[17:39:34.427]                     invokeRestart <- base::invokeRestart
[17:39:34.427]                     is.null <- base::is.null
[17:39:34.427]                     muffled <- FALSE
[17:39:34.427]                     if (inherits(cond, "message")) {
[17:39:34.427]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.427]                       if (muffled) 
[17:39:34.427]                         invokeRestart("muffleMessage")
[17:39:34.427]                     }
[17:39:34.427]                     else if (inherits(cond, "warning")) {
[17:39:34.427]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.427]                       if (muffled) 
[17:39:34.427]                         invokeRestart("muffleWarning")
[17:39:34.427]                     }
[17:39:34.427]                     else if (inherits(cond, "condition")) {
[17:39:34.427]                       if (!is.null(pattern)) {
[17:39:34.427]                         computeRestarts <- base::computeRestarts
[17:39:34.427]                         grepl <- base::grepl
[17:39:34.427]                         restarts <- computeRestarts(cond)
[17:39:34.427]                         for (restart in restarts) {
[17:39:34.427]                           name <- restart$name
[17:39:34.427]                           if (is.null(name)) 
[17:39:34.427]                             next
[17:39:34.427]                           if (!grepl(pattern, name)) 
[17:39:34.427]                             next
[17:39:34.427]                           invokeRestart(restart)
[17:39:34.427]                           muffled <- TRUE
[17:39:34.427]                           break
[17:39:34.427]                         }
[17:39:34.427]                       }
[17:39:34.427]                     }
[17:39:34.427]                     invisible(muffled)
[17:39:34.427]                   }
[17:39:34.427]                   muffleCondition(cond)
[17:39:34.427]                 })
[17:39:34.427]             }))
[17:39:34.427]             future::FutureResult(value = ...future.value$value, 
[17:39:34.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.427]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.427]                     ...future.globalenv.names))
[17:39:34.427]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.427]         }, condition = base::local({
[17:39:34.427]             c <- base::c
[17:39:34.427]             inherits <- base::inherits
[17:39:34.427]             invokeRestart <- base::invokeRestart
[17:39:34.427]             length <- base::length
[17:39:34.427]             list <- base::list
[17:39:34.427]             seq.int <- base::seq.int
[17:39:34.427]             signalCondition <- base::signalCondition
[17:39:34.427]             sys.calls <- base::sys.calls
[17:39:34.427]             `[[` <- base::`[[`
[17:39:34.427]             `+` <- base::`+`
[17:39:34.427]             `<<-` <- base::`<<-`
[17:39:34.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.427]                   3L)]
[17:39:34.427]             }
[17:39:34.427]             function(cond) {
[17:39:34.427]                 is_error <- inherits(cond, "error")
[17:39:34.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.427]                   NULL)
[17:39:34.427]                 if (is_error) {
[17:39:34.427]                   sessionInformation <- function() {
[17:39:34.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.427]                       search = base::search(), system = base::Sys.info())
[17:39:34.427]                   }
[17:39:34.427]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.427]                     cond$call), session = sessionInformation(), 
[17:39:34.427]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.427]                   signalCondition(cond)
[17:39:34.427]                 }
[17:39:34.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.427]                 "immediateCondition"))) {
[17:39:34.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.427]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.427]                   if (TRUE && !signal) {
[17:39:34.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.427]                     {
[17:39:34.427]                       inherits <- base::inherits
[17:39:34.427]                       invokeRestart <- base::invokeRestart
[17:39:34.427]                       is.null <- base::is.null
[17:39:34.427]                       muffled <- FALSE
[17:39:34.427]                       if (inherits(cond, "message")) {
[17:39:34.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.427]                         if (muffled) 
[17:39:34.427]                           invokeRestart("muffleMessage")
[17:39:34.427]                       }
[17:39:34.427]                       else if (inherits(cond, "warning")) {
[17:39:34.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.427]                         if (muffled) 
[17:39:34.427]                           invokeRestart("muffleWarning")
[17:39:34.427]                       }
[17:39:34.427]                       else if (inherits(cond, "condition")) {
[17:39:34.427]                         if (!is.null(pattern)) {
[17:39:34.427]                           computeRestarts <- base::computeRestarts
[17:39:34.427]                           grepl <- base::grepl
[17:39:34.427]                           restarts <- computeRestarts(cond)
[17:39:34.427]                           for (restart in restarts) {
[17:39:34.427]                             name <- restart$name
[17:39:34.427]                             if (is.null(name)) 
[17:39:34.427]                               next
[17:39:34.427]                             if (!grepl(pattern, name)) 
[17:39:34.427]                               next
[17:39:34.427]                             invokeRestart(restart)
[17:39:34.427]                             muffled <- TRUE
[17:39:34.427]                             break
[17:39:34.427]                           }
[17:39:34.427]                         }
[17:39:34.427]                       }
[17:39:34.427]                       invisible(muffled)
[17:39:34.427]                     }
[17:39:34.427]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.427]                   }
[17:39:34.427]                 }
[17:39:34.427]                 else {
[17:39:34.427]                   if (TRUE) {
[17:39:34.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.427]                     {
[17:39:34.427]                       inherits <- base::inherits
[17:39:34.427]                       invokeRestart <- base::invokeRestart
[17:39:34.427]                       is.null <- base::is.null
[17:39:34.427]                       muffled <- FALSE
[17:39:34.427]                       if (inherits(cond, "message")) {
[17:39:34.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.427]                         if (muffled) 
[17:39:34.427]                           invokeRestart("muffleMessage")
[17:39:34.427]                       }
[17:39:34.427]                       else if (inherits(cond, "warning")) {
[17:39:34.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.427]                         if (muffled) 
[17:39:34.427]                           invokeRestart("muffleWarning")
[17:39:34.427]                       }
[17:39:34.427]                       else if (inherits(cond, "condition")) {
[17:39:34.427]                         if (!is.null(pattern)) {
[17:39:34.427]                           computeRestarts <- base::computeRestarts
[17:39:34.427]                           grepl <- base::grepl
[17:39:34.427]                           restarts <- computeRestarts(cond)
[17:39:34.427]                           for (restart in restarts) {
[17:39:34.427]                             name <- restart$name
[17:39:34.427]                             if (is.null(name)) 
[17:39:34.427]                               next
[17:39:34.427]                             if (!grepl(pattern, name)) 
[17:39:34.427]                               next
[17:39:34.427]                             invokeRestart(restart)
[17:39:34.427]                             muffled <- TRUE
[17:39:34.427]                             break
[17:39:34.427]                           }
[17:39:34.427]                         }
[17:39:34.427]                       }
[17:39:34.427]                       invisible(muffled)
[17:39:34.427]                     }
[17:39:34.427]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.427]                   }
[17:39:34.427]                 }
[17:39:34.427]             }
[17:39:34.427]         }))
[17:39:34.427]     }, error = function(ex) {
[17:39:34.427]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.427]                 ...future.rng), started = ...future.startTime, 
[17:39:34.427]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.427]             version = "1.8"), class = "FutureResult")
[17:39:34.427]     }, finally = {
[17:39:34.427]         if (!identical(...future.workdir, getwd())) 
[17:39:34.427]             setwd(...future.workdir)
[17:39:34.427]         {
[17:39:34.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.427]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.427]             }
[17:39:34.427]             base::options(...future.oldOptions)
[17:39:34.427]             if (.Platform$OS.type == "windows") {
[17:39:34.427]                 old_names <- names(...future.oldEnvVars)
[17:39:34.427]                 envs <- base::Sys.getenv()
[17:39:34.427]                 names <- names(envs)
[17:39:34.427]                 common <- intersect(names, old_names)
[17:39:34.427]                 added <- setdiff(names, old_names)
[17:39:34.427]                 removed <- setdiff(old_names, names)
[17:39:34.427]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.427]                   envs[common]]
[17:39:34.427]                 NAMES <- toupper(changed)
[17:39:34.427]                 args <- list()
[17:39:34.427]                 for (kk in seq_along(NAMES)) {
[17:39:34.427]                   name <- changed[[kk]]
[17:39:34.427]                   NAME <- NAMES[[kk]]
[17:39:34.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.427]                     next
[17:39:34.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.427]                 }
[17:39:34.427]                 NAMES <- toupper(added)
[17:39:34.427]                 for (kk in seq_along(NAMES)) {
[17:39:34.427]                   name <- added[[kk]]
[17:39:34.427]                   NAME <- NAMES[[kk]]
[17:39:34.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.427]                     next
[17:39:34.427]                   args[[name]] <- ""
[17:39:34.427]                 }
[17:39:34.427]                 NAMES <- toupper(removed)
[17:39:34.427]                 for (kk in seq_along(NAMES)) {
[17:39:34.427]                   name <- removed[[kk]]
[17:39:34.427]                   NAME <- NAMES[[kk]]
[17:39:34.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.427]                     next
[17:39:34.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.427]                 }
[17:39:34.427]                 if (length(args) > 0) 
[17:39:34.427]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.427]             }
[17:39:34.427]             else {
[17:39:34.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.427]             }
[17:39:34.427]             {
[17:39:34.427]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.427]                   0L) {
[17:39:34.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.427]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.427]                   base::options(opts)
[17:39:34.427]                 }
[17:39:34.427]                 {
[17:39:34.427]                   {
[17:39:34.427]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.427]                     NULL
[17:39:34.427]                   }
[17:39:34.427]                   options(future.plan = NULL)
[17:39:34.427]                   if (is.na(NA_character_)) 
[17:39:34.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.427]                     .init = FALSE)
[17:39:34.427]                 }
[17:39:34.427]             }
[17:39:34.427]         }
[17:39:34.427]     })
[17:39:34.427]     if (TRUE) {
[17:39:34.427]         base::sink(type = "output", split = FALSE)
[17:39:34.427]         if (TRUE) {
[17:39:34.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.427]         }
[17:39:34.427]         else {
[17:39:34.427]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.427]         }
[17:39:34.427]         base::close(...future.stdout)
[17:39:34.427]         ...future.stdout <- NULL
[17:39:34.427]     }
[17:39:34.427]     ...future.result$conditions <- ...future.conditions
[17:39:34.427]     ...future.result$finished <- base::Sys.time()
[17:39:34.427]     ...future.result
[17:39:34.427] }
[17:39:34.430] requestCore(): workers = 2
[17:39:34.432] MulticoreFuture started
[17:39:34.432] - Launch lazy future ... done
[17:39:34.432] run() for ‘MulticoreFuture’ ... done
[17:39:34.433] getGlobalsAndPackages() ...
[17:39:34.433] Searching for globals...
[17:39:34.433] plan(): Setting new future strategy stack:
[17:39:34.434] 
[17:39:34.434] Searching for globals ... DONE
[17:39:34.433] List of future strategies:
[17:39:34.433] 1. sequential:
[17:39:34.433]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.433]    - tweaked: FALSE
[17:39:34.433]    - call: NULL
[17:39:34.434] - globals: [0] <none>
[17:39:34.434] getGlobalsAndPackages() ... DONE
[17:39:34.434] plan(): nbrOfWorkers() = 1
[17:39:34.435] run() for ‘Future’ ...
[17:39:34.435] - state: ‘created’
[17:39:34.435] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:34.436] plan(): Setting new future strategy stack:
[17:39:34.436] List of future strategies:
[17:39:34.436] 1. multicore:
[17:39:34.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.436]    - tweaked: FALSE
[17:39:34.436]    - call: plan(strategy)
[17:39:34.441] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:34.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:34.441] plan(): nbrOfWorkers() = 2
[17:39:34.441]   - Field: ‘label’
[17:39:34.441]   - Field: ‘local’
[17:39:34.441]   - Field: ‘owner’
[17:39:34.442]   - Field: ‘envir’
[17:39:34.442]   - Field: ‘workers’
[17:39:34.442]   - Field: ‘packages’
[17:39:34.442]   - Field: ‘gc’
[17:39:34.442]   - Field: ‘job’
[17:39:34.442]   - Field: ‘conditions’
[17:39:34.443]   - Field: ‘expr’
[17:39:34.443]   - Field: ‘uuid’
[17:39:34.443]   - Field: ‘seed’
[17:39:34.443]   - Field: ‘version’
[17:39:34.443]   - Field: ‘result’
[17:39:34.443]   - Field: ‘asynchronous’
[17:39:34.443]   - Field: ‘calls’
[17:39:34.444]   - Field: ‘globals’
[17:39:34.444]   - Field: ‘stdout’
[17:39:34.444]   - Field: ‘earlySignal’
[17:39:34.444]   - Field: ‘lazy’
[17:39:34.444]   - Field: ‘state’
[17:39:34.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:34.444] - Launch lazy future ...
[17:39:34.445] Packages needed by the future expression (n = 0): <none>
[17:39:34.445] Packages needed by future strategies (n = 0): <none>
[17:39:34.446] {
[17:39:34.446]     {
[17:39:34.446]         {
[17:39:34.446]             ...future.startTime <- base::Sys.time()
[17:39:34.446]             {
[17:39:34.446]                 {
[17:39:34.446]                   {
[17:39:34.446]                     {
[17:39:34.446]                       base::local({
[17:39:34.446]                         has_future <- base::requireNamespace("future", 
[17:39:34.446]                           quietly = TRUE)
[17:39:34.446]                         if (has_future) {
[17:39:34.446]                           ns <- base::getNamespace("future")
[17:39:34.446]                           version <- ns[[".package"]][["version"]]
[17:39:34.446]                           if (is.null(version)) 
[17:39:34.446]                             version <- utils::packageVersion("future")
[17:39:34.446]                         }
[17:39:34.446]                         else {
[17:39:34.446]                           version <- NULL
[17:39:34.446]                         }
[17:39:34.446]                         if (!has_future || version < "1.8.0") {
[17:39:34.446]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:34.446]                             "", base::R.version$version.string), 
[17:39:34.446]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:34.446]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:34.446]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:34.446]                               "release", "version")], collapse = " "), 
[17:39:34.446]                             hostname = base::Sys.info()[["nodename"]])
[17:39:34.446]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:34.446]                             info)
[17:39:34.446]                           info <- base::paste(info, collapse = "; ")
[17:39:34.446]                           if (!has_future) {
[17:39:34.446]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:34.446]                               info)
[17:39:34.446]                           }
[17:39:34.446]                           else {
[17:39:34.446]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:34.446]                               info, version)
[17:39:34.446]                           }
[17:39:34.446]                           base::stop(msg)
[17:39:34.446]                         }
[17:39:34.446]                       })
[17:39:34.446]                     }
[17:39:34.446]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:34.446]                     base::options(mc.cores = 1L)
[17:39:34.446]                   }
[17:39:34.446]                   ...future.strategy.old <- future::plan("list")
[17:39:34.446]                   options(future.plan = NULL)
[17:39:34.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:34.446]                 }
[17:39:34.446]                 ...future.workdir <- getwd()
[17:39:34.446]             }
[17:39:34.446]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:34.446]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:34.446]         }
[17:39:34.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:34.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:34.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:34.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:34.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:34.446]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:34.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:34.446]             base::names(...future.oldOptions))
[17:39:34.446]     }
[17:39:34.446]     if (FALSE) {
[17:39:34.446]     }
[17:39:34.446]     else {
[17:39:34.446]         if (TRUE) {
[17:39:34.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:34.446]                 open = "w")
[17:39:34.446]         }
[17:39:34.446]         else {
[17:39:34.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:34.446]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:34.446]         }
[17:39:34.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:34.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:34.446]             base::sink(type = "output", split = FALSE)
[17:39:34.446]             base::close(...future.stdout)
[17:39:34.446]         }, add = TRUE)
[17:39:34.446]     }
[17:39:34.446]     ...future.frame <- base::sys.nframe()
[17:39:34.446]     ...future.conditions <- base::list()
[17:39:34.446]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:34.446]     if (FALSE) {
[17:39:34.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:34.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:34.446]     }
[17:39:34.446]     ...future.result <- base::tryCatch({
[17:39:34.446]         base::withCallingHandlers({
[17:39:34.446]             ...future.value <- base::withVisible(base::local({
[17:39:34.446]                 withCallingHandlers({
[17:39:34.446]                   NULL
[17:39:34.446]                 }, immediateCondition = function(cond) {
[17:39:34.446]                   save_rds <- function (object, pathname, ...) 
[17:39:34.446]                   {
[17:39:34.446]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:34.446]                     if (file_test("-f", pathname_tmp)) {
[17:39:34.446]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.446]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.446]                         fi_tmp[["mtime"]])
[17:39:34.446]                     }
[17:39:34.446]                     tryCatch({
[17:39:34.446]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:34.446]                     }, error = function(ex) {
[17:39:34.446]                       msg <- conditionMessage(ex)
[17:39:34.446]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.446]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.446]                         fi_tmp[["mtime"]], msg)
[17:39:34.446]                       ex$message <- msg
[17:39:34.446]                       stop(ex)
[17:39:34.446]                     })
[17:39:34.446]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:34.446]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:34.446]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:34.446]                       fi_tmp <- file.info(pathname_tmp)
[17:39:34.446]                       fi <- file.info(pathname)
[17:39:34.446]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:34.446]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:34.446]                         fi[["size"]], fi[["mtime"]])
[17:39:34.446]                       stop(msg)
[17:39:34.446]                     }
[17:39:34.446]                     invisible(pathname)
[17:39:34.446]                   }
[17:39:34.446]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:34.446]                     rootPath = tempdir()) 
[17:39:34.446]                   {
[17:39:34.446]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:34.446]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:34.446]                       tmpdir = path, fileext = ".rds")
[17:39:34.446]                     save_rds(obj, file)
[17:39:34.446]                   }
[17:39:34.446]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:34.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.446]                   {
[17:39:34.446]                     inherits <- base::inherits
[17:39:34.446]                     invokeRestart <- base::invokeRestart
[17:39:34.446]                     is.null <- base::is.null
[17:39:34.446]                     muffled <- FALSE
[17:39:34.446]                     if (inherits(cond, "message")) {
[17:39:34.446]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:34.446]                       if (muffled) 
[17:39:34.446]                         invokeRestart("muffleMessage")
[17:39:34.446]                     }
[17:39:34.446]                     else if (inherits(cond, "warning")) {
[17:39:34.446]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:34.446]                       if (muffled) 
[17:39:34.446]                         invokeRestart("muffleWarning")
[17:39:34.446]                     }
[17:39:34.446]                     else if (inherits(cond, "condition")) {
[17:39:34.446]                       if (!is.null(pattern)) {
[17:39:34.446]                         computeRestarts <- base::computeRestarts
[17:39:34.446]                         grepl <- base::grepl
[17:39:34.446]                         restarts <- computeRestarts(cond)
[17:39:34.446]                         for (restart in restarts) {
[17:39:34.446]                           name <- restart$name
[17:39:34.446]                           if (is.null(name)) 
[17:39:34.446]                             next
[17:39:34.446]                           if (!grepl(pattern, name)) 
[17:39:34.446]                             next
[17:39:34.446]                           invokeRestart(restart)
[17:39:34.446]                           muffled <- TRUE
[17:39:34.446]                           break
[17:39:34.446]                         }
[17:39:34.446]                       }
[17:39:34.446]                     }
[17:39:34.446]                     invisible(muffled)
[17:39:34.446]                   }
[17:39:34.446]                   muffleCondition(cond)
[17:39:34.446]                 })
[17:39:34.446]             }))
[17:39:34.446]             future::FutureResult(value = ...future.value$value, 
[17:39:34.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.446]                   ...future.rng), globalenv = if (FALSE) 
[17:39:34.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:34.446]                     ...future.globalenv.names))
[17:39:34.446]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:34.446]         }, condition = base::local({
[17:39:34.446]             c <- base::c
[17:39:34.446]             inherits <- base::inherits
[17:39:34.446]             invokeRestart <- base::invokeRestart
[17:39:34.446]             length <- base::length
[17:39:34.446]             list <- base::list
[17:39:34.446]             seq.int <- base::seq.int
[17:39:34.446]             signalCondition <- base::signalCondition
[17:39:34.446]             sys.calls <- base::sys.calls
[17:39:34.446]             `[[` <- base::`[[`
[17:39:34.446]             `+` <- base::`+`
[17:39:34.446]             `<<-` <- base::`<<-`
[17:39:34.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:34.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:34.446]                   3L)]
[17:39:34.446]             }
[17:39:34.446]             function(cond) {
[17:39:34.446]                 is_error <- inherits(cond, "error")
[17:39:34.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:34.446]                   NULL)
[17:39:34.446]                 if (is_error) {
[17:39:34.446]                   sessionInformation <- function() {
[17:39:34.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:34.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:34.446]                       search = base::search(), system = base::Sys.info())
[17:39:34.446]                   }
[17:39:34.446]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:34.446]                     cond$call), session = sessionInformation(), 
[17:39:34.446]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:34.446]                   signalCondition(cond)
[17:39:34.446]                 }
[17:39:34.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:34.446]                 "immediateCondition"))) {
[17:39:34.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:34.446]                   ...future.conditions[[length(...future.conditions) + 
[17:39:34.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:34.446]                   if (TRUE && !signal) {
[17:39:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.446]                     {
[17:39:34.446]                       inherits <- base::inherits
[17:39:34.446]                       invokeRestart <- base::invokeRestart
[17:39:34.446]                       is.null <- base::is.null
[17:39:34.446]                       muffled <- FALSE
[17:39:34.446]                       if (inherits(cond, "message")) {
[17:39:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.446]                         if (muffled) 
[17:39:34.446]                           invokeRestart("muffleMessage")
[17:39:34.446]                       }
[17:39:34.446]                       else if (inherits(cond, "warning")) {
[17:39:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.446]                         if (muffled) 
[17:39:34.446]                           invokeRestart("muffleWarning")
[17:39:34.446]                       }
[17:39:34.446]                       else if (inherits(cond, "condition")) {
[17:39:34.446]                         if (!is.null(pattern)) {
[17:39:34.446]                           computeRestarts <- base::computeRestarts
[17:39:34.446]                           grepl <- base::grepl
[17:39:34.446]                           restarts <- computeRestarts(cond)
[17:39:34.446]                           for (restart in restarts) {
[17:39:34.446]                             name <- restart$name
[17:39:34.446]                             if (is.null(name)) 
[17:39:34.446]                               next
[17:39:34.446]                             if (!grepl(pattern, name)) 
[17:39:34.446]                               next
[17:39:34.446]                             invokeRestart(restart)
[17:39:34.446]                             muffled <- TRUE
[17:39:34.446]                             break
[17:39:34.446]                           }
[17:39:34.446]                         }
[17:39:34.446]                       }
[17:39:34.446]                       invisible(muffled)
[17:39:34.446]                     }
[17:39:34.446]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.446]                   }
[17:39:34.446]                 }
[17:39:34.446]                 else {
[17:39:34.446]                   if (TRUE) {
[17:39:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:34.446]                     {
[17:39:34.446]                       inherits <- base::inherits
[17:39:34.446]                       invokeRestart <- base::invokeRestart
[17:39:34.446]                       is.null <- base::is.null
[17:39:34.446]                       muffled <- FALSE
[17:39:34.446]                       if (inherits(cond, "message")) {
[17:39:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:34.446]                         if (muffled) 
[17:39:34.446]                           invokeRestart("muffleMessage")
[17:39:34.446]                       }
[17:39:34.446]                       else if (inherits(cond, "warning")) {
[17:39:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:34.446]                         if (muffled) 
[17:39:34.446]                           invokeRestart("muffleWarning")
[17:39:34.446]                       }
[17:39:34.446]                       else if (inherits(cond, "condition")) {
[17:39:34.446]                         if (!is.null(pattern)) {
[17:39:34.446]                           computeRestarts <- base::computeRestarts
[17:39:34.446]                           grepl <- base::grepl
[17:39:34.446]                           restarts <- computeRestarts(cond)
[17:39:34.446]                           for (restart in restarts) {
[17:39:34.446]                             name <- restart$name
[17:39:34.446]                             if (is.null(name)) 
[17:39:34.446]                               next
[17:39:34.446]                             if (!grepl(pattern, name)) 
[17:39:34.446]                               next
[17:39:34.446]                             invokeRestart(restart)
[17:39:34.446]                             muffled <- TRUE
[17:39:34.446]                             break
[17:39:34.446]                           }
[17:39:34.446]                         }
[17:39:34.446]                       }
[17:39:34.446]                       invisible(muffled)
[17:39:34.446]                     }
[17:39:34.446]                     muffleCondition(cond, pattern = "^muffle")
[17:39:34.446]                   }
[17:39:34.446]                 }
[17:39:34.446]             }
[17:39:34.446]         }))
[17:39:34.446]     }, error = function(ex) {
[17:39:34.446]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:34.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:34.446]                 ...future.rng), started = ...future.startTime, 
[17:39:34.446]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:34.446]             version = "1.8"), class = "FutureResult")
[17:39:34.446]     }, finally = {
[17:39:34.446]         if (!identical(...future.workdir, getwd())) 
[17:39:34.446]             setwd(...future.workdir)
[17:39:34.446]         {
[17:39:34.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:34.446]                 ...future.oldOptions$nwarnings <- NULL
[17:39:34.446]             }
[17:39:34.446]             base::options(...future.oldOptions)
[17:39:34.446]             if (.Platform$OS.type == "windows") {
[17:39:34.446]                 old_names <- names(...future.oldEnvVars)
[17:39:34.446]                 envs <- base::Sys.getenv()
[17:39:34.446]                 names <- names(envs)
[17:39:34.446]                 common <- intersect(names, old_names)
[17:39:34.446]                 added <- setdiff(names, old_names)
[17:39:34.446]                 removed <- setdiff(old_names, names)
[17:39:34.446]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:34.446]                   envs[common]]
[17:39:34.446]                 NAMES <- toupper(changed)
[17:39:34.446]                 args <- list()
[17:39:34.446]                 for (kk in seq_along(NAMES)) {
[17:39:34.446]                   name <- changed[[kk]]
[17:39:34.446]                   NAME <- NAMES[[kk]]
[17:39:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.446]                     next
[17:39:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.446]                 }
[17:39:34.446]                 NAMES <- toupper(added)
[17:39:34.446]                 for (kk in seq_along(NAMES)) {
[17:39:34.446]                   name <- added[[kk]]
[17:39:34.446]                   NAME <- NAMES[[kk]]
[17:39:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.446]                     next
[17:39:34.446]                   args[[name]] <- ""
[17:39:34.446]                 }
[17:39:34.446]                 NAMES <- toupper(removed)
[17:39:34.446]                 for (kk in seq_along(NAMES)) {
[17:39:34.446]                   name <- removed[[kk]]
[17:39:34.446]                   NAME <- NAMES[[kk]]
[17:39:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:34.446]                     next
[17:39:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:34.446]                 }
[17:39:34.446]                 if (length(args) > 0) 
[17:39:34.446]                   base::do.call(base::Sys.setenv, args = args)
[17:39:34.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:34.446]             }
[17:39:34.446]             else {
[17:39:34.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:34.446]             }
[17:39:34.446]             {
[17:39:34.446]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:34.446]                   0L) {
[17:39:34.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:34.446]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:34.446]                   base::options(opts)
[17:39:34.446]                 }
[17:39:34.446]                 {
[17:39:34.446]                   {
[17:39:34.446]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:34.446]                     NULL
[17:39:34.446]                   }
[17:39:34.446]                   options(future.plan = NULL)
[17:39:34.446]                   if (is.na(NA_character_)) 
[17:39:34.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:34.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:34.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:34.446]                     .init = FALSE)
[17:39:34.446]                 }
[17:39:34.446]             }
[17:39:34.446]         }
[17:39:34.446]     })
[17:39:34.446]     if (TRUE) {
[17:39:34.446]         base::sink(type = "output", split = FALSE)
[17:39:34.446]         if (TRUE) {
[17:39:34.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:34.446]         }
[17:39:34.446]         else {
[17:39:34.446]             ...future.result["stdout"] <- base::list(NULL)
[17:39:34.446]         }
[17:39:34.446]         base::close(...future.stdout)
[17:39:34.446]         ...future.stdout <- NULL
[17:39:34.446]     }
[17:39:34.446]     ...future.result$conditions <- ...future.conditions
[17:39:34.446]     ...future.result$finished <- base::Sys.time()
[17:39:34.446]     ...future.result
[17:39:34.446] }
[17:39:34.449] requestCore(): workers = 2
[17:39:34.457] MulticoreFuture started
[17:39:34.457] - Launch lazy future ... done
[17:39:34.458] plan(): Setting new future strategy stack:
[17:39:34.458] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[17:39:34.458] List of future strategies:
[17:39:34.458] 1. sequential:
[17:39:34.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:34.458]    - tweaked: FALSE
[17:39:34.458]    - call: NULL
[17:39:34.460] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefd532b8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf03071e8> 
 $  : NULL
 $  :[17:39:34.463] plan(): Setting new future strategy stack:
 NULL
 $  :[17:39:34.463] List of future strategies:
[17:39:34.463] 1. multicore:
[17:39:34.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:34.463]    - tweaked: FALSE
[17:39:34.463]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adefd532b8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf03071e8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=[17:39:34.468] plan(): nbrOfWorkers() = 2
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:34.474] resolve() on list ...
[17:39:34.474]  recursive: 0
[17:39:34.474]  length: 6
[17:39:34.474]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:34.475] signalConditionsASAP(numeric, pos=1) ...
[17:39:34.475] - nx: 6
[17:39:34.475] - relay: TRUE
[17:39:34.475] - stdout: TRUE
[17:39:34.475] - signal: TRUE
[17:39:34.475] - resignal: FALSE
[17:39:34.475] - force: TRUE
[17:39:34.476] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.476] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.476]  - until=2
[17:39:34.476]  - relaying element #2
[17:39:34.476] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.476] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.476] signalConditionsASAP(NULL, pos=1) ... done
[17:39:34.476]  length: 5 (resolved future 1)
[17:39:34.477] Future #2
[17:39:34.477] result() for MulticoreFuture ...
[17:39:34.478] result() for MulticoreFuture ...
[17:39:34.478] result() for MulticoreFuture ... done
[17:39:34.478] result() for MulticoreFuture ... done
[17:39:34.478] result() for MulticoreFuture ...
[17:39:34.478] result() for MulticoreFuture ... done
[17:39:34.478] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:34.479] - nx: 6
[17:39:34.479] - relay: TRUE
[17:39:34.479] - stdout: TRUE
[17:39:34.479] - signal: TRUE
[17:39:34.479] - resignal: FALSE
[17:39:34.479] - force: TRUE
[17:39:34.479] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.479] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:34.479]  - until=2
[17:39:34.480]  - relaying element #2
[17:39:34.480] result() for MulticoreFuture ...
[17:39:34.480] result() for MulticoreFuture ... done
[17:39:34.480] result() for MulticoreFuture ...
[17:39:34.480] result() for MulticoreFuture ... done
[17:39:34.480] result() for MulticoreFuture ...
[17:39:34.480] result() for MulticoreFuture ... done
[17:39:34.481] result() for MulticoreFuture ...
[17:39:34.481] result() for MulticoreFuture ... done
[17:39:34.481] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.481] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.481] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:34.481]  length: 4 (resolved future 2)
[17:39:34.481] Future #3
[17:39:34.482] result() for MulticoreFuture ...
[17:39:34.482] result() for MulticoreFuture ...
[17:39:34.482] result() for MulticoreFuture ... done
[17:39:34.482] result() for MulticoreFuture ... done
[17:39:34.483] result() for MulticoreFuture ...
[17:39:34.483] result() for MulticoreFuture ... done
[17:39:34.483] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:34.483] - nx: 6
[17:39:34.483] - relay: TRUE
[17:39:34.483] - stdout: TRUE
[17:39:34.483] - signal: TRUE
[17:39:34.483] - resignal: FALSE
[17:39:34.483] - force: TRUE
[17:39:34.484] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.484] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:34.484]  - until=3
[17:39:34.484]  - relaying element #3
[17:39:34.484] result() for MulticoreFuture ...
[17:39:34.484] result() for MulticoreFuture ... done
[17:39:34.484] result() for MulticoreFuture ...
[17:39:34.484] result() for MulticoreFuture ... done
[17:39:34.484] result() for MulticoreFuture ...
[17:39:34.485] result() for MulticoreFuture ... done
[17:39:34.485] result() for MulticoreFuture ...
[17:39:34.485] result() for MulticoreFuture ... done
[17:39:34.485] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.485] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:34.485]  length: 3 (resolved future 3)
[17:39:34.485] signalConditionsASAP(NULL, pos=4) ...
[17:39:34.485] - nx: 6
[17:39:34.486] - relay: TRUE
[17:39:34.486] - stdout: TRUE
[17:39:34.486] - signal: TRUE
[17:39:34.486] - resignal: FALSE
[17:39:34.486] - force: TRUE
[17:39:34.486] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.486] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.486]  - until=5
[17:39:34.486]  - relaying element #5
[17:39:34.486] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.487] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.487] signalConditionsASAP(NULL, pos=4) ... done
[17:39:34.487]  length: 2 (resolved future 4)
[17:39:34.487] signalConditionsASAP(NULL, pos=5) ...
[17:39:34.487] - nx: 6
[17:39:34.487] - relay: TRUE
[17:39:34.487] - stdout: TRUE
[17:39:34.487] - signal: TRUE
[17:39:34.487] - resignal: FALSE
[17:39:34.487] - force: TRUE
[17:39:34.487] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:34.488] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.488]  - until=6
[17:39:34.488]  - relaying element #6
[17:39:34.488] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.488] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.488] signalConditionsASAP(NULL, pos=5) ... done
[17:39:34.488]  length: 1 (resolved future 5)
[17:39:34.488] signalConditionsASAP(numeric, pos=6) ...
[17:39:34.488] - nx: 6
[17:39:34.489] - relay: TRUE
[17:39:34.489] - stdout: TRUE
[17:39:34.489] - signal: TRUE
[17:39:34.489] - resignal: FALSE
[17:39:34.489] - force: TRUE
[17:39:34.489] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:34.489] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.489]  - until=6
[17:39:34.489] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.489] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.489] signalConditionsASAP(numeric, pos=6) ... done
[17:39:34.490]  length: 0 (resolved future 6)
[17:39:34.490] Relaying remaining futures
[17:39:34.490] signalConditionsASAP(NULL, pos=0) ...
[17:39:34.490] - nx: 6
[17:39:34.490] - relay: TRUE
[17:39:34.490] - stdout: TRUE
[17:39:34.490] - signal: TRUE
[17:39:34.490] - resignal: FALSE
[17:39:34.490] - force: TRUE
[17:39:34.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.490] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:34.491] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:34.491] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:34.491] signalConditionsASAP(NULL, pos=0) ... done
[17:39:34.491] resolve() on list ... DONE
[17:39:34.491] result() for MulticoreFuture ...
[17:39:34.491] result() for MulticoreFuture ... done
[17:39:34.491] result() for MulticoreFuture ...
[17:39:34.491] result() for MulticoreFuture ... done
[17:39:34.491] result() for MulticoreFuture ...
[17:39:34.492] result() for MulticoreFuture ... done
[17:39:34.492] result() for MulticoreFuture ...
[17:39:34.492] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:39:34.498] plan(): Setting new future strategy stack:
[17:39:34.498] List of future strategies:
[17:39:34.498] 1. multisession:
[17:39:34.498]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:34.498]    - tweaked: FALSE
[17:39:34.498]    - call: plan(strategy)
[17:39:34.499] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:34.499] multisession:
[17:39:34.499] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:34.499] - tweaked: FALSE
[17:39:34.499] - call: plan(strategy)
[17:39:34.505] getGlobalsAndPackages() ...
[17:39:34.506] Not searching for globals
[17:39:34.506] - globals: [0] <none>
[17:39:34.506] getGlobalsAndPackages() ... DONE
[17:39:34.506] [local output] makeClusterPSOCK() ...
[17:39:34.553] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:34.554] [local output] Base port: 11167
[17:39:34.554] [local output] Getting setup options for 2 cluster nodes ...
[17:39:34.555] [local output]  - Node 1 of 2 ...
[17:39:34.555] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:34.556] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476476072de.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476476072de.pid")'’
[17:39:34.746] - Possible to infer worker's PID: TRUE
[17:39:34.746] [local output] Rscript port: 11167

[17:39:34.746] [local output]  - Node 2 of 2 ...
[17:39:34.747] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:34.747] [local output] Rscript port: 11167

[17:39:34.748] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:34.748] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:34.748] [local output] Setting up PSOCK nodes in parallel
[17:39:34.749] List of 36
[17:39:34.749]  $ worker          : chr "localhost"
[17:39:34.749]   ..- attr(*, "localhost")= logi TRUE
[17:39:34.749]  $ master          : chr "localhost"
[17:39:34.749]  $ port            : int 11167
[17:39:34.749]  $ connectTimeout  : num 120
[17:39:34.749]  $ timeout         : num 2592000
[17:39:34.749]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:34.749]  $ homogeneous     : logi TRUE
[17:39:34.749]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:34.749]  $ rscript_envs    : NULL
[17:39:34.749]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:34.749]  $ rscript_startup : NULL
[17:39:34.749]  $ rscript_sh      : chr "sh"
[17:39:34.749]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:34.749]  $ methods         : logi TRUE
[17:39:34.749]  $ socketOptions   : chr "no-delay"
[17:39:34.749]  $ useXDR          : logi FALSE
[17:39:34.749]  $ outfile         : chr "/dev/null"
[17:39:34.749]  $ renice          : int NA
[17:39:34.749]  $ rshcmd          : NULL
[17:39:34.749]  $ user            : chr(0) 
[17:39:34.749]  $ revtunnel       : logi FALSE
[17:39:34.749]  $ rshlogfile      : NULL
[17:39:34.749]  $ rshopts         : chr(0) 
[17:39:34.749]  $ rank            : int 1
[17:39:34.749]  $ manual          : logi FALSE
[17:39:34.749]  $ dryrun          : logi FALSE
[17:39:34.749]  $ quiet           : logi FALSE
[17:39:34.749]  $ setup_strategy  : chr "parallel"
[17:39:34.749]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:34.749]  $ pidfile         : chr "/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476476072de.pid"
[17:39:34.749]  $ rshcmd_label    : NULL
[17:39:34.749]  $ rsh_call        : NULL
[17:39:34.749]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:34.749]  $ localMachine    : logi TRUE
[17:39:34.749]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:34.749]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:34.749]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:34.749]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:34.749]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:34.749]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:34.749]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:34.749]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:34.749]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:34.749]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:34.749]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:34.749]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:34.749]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:34.749]  $ arguments       :List of 28
[17:39:34.749]   ..$ worker          : chr "localhost"
[17:39:34.749]   ..$ master          : NULL
[17:39:34.749]   ..$ port            : int 11167
[17:39:34.749]   ..$ connectTimeout  : num 120
[17:39:34.749]   ..$ timeout         : num 2592000
[17:39:34.749]   ..$ rscript         : NULL
[17:39:34.749]   ..$ homogeneous     : NULL
[17:39:34.749]   ..$ rscript_args    : NULL
[17:39:34.749]   ..$ rscript_envs    : NULL
[17:39:34.749]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:34.749]   ..$ rscript_startup : NULL
[17:39:34.749]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:34.749]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:34.749]   ..$ methods         : logi TRUE
[17:39:34.749]   ..$ socketOptions   : chr "no-delay"
[17:39:34.749]   ..$ useXDR          : logi FALSE
[17:39:34.749]   ..$ outfile         : chr "/dev/null"
[17:39:34.749]   ..$ renice          : int NA
[17:39:34.749]   ..$ rshcmd          : NULL
[17:39:34.749]   ..$ user            : NULL
[17:39:34.749]   ..$ revtunnel       : logi NA
[17:39:34.749]   ..$ rshlogfile      : NULL
[17:39:34.749]   ..$ rshopts         : NULL
[17:39:34.749]   ..$ rank            : int 1
[17:39:34.749]   ..$ manual          : logi FALSE
[17:39:34.749]   ..$ dryrun          : logi FALSE
[17:39:34.749]   ..$ quiet           : logi FALSE
[17:39:34.749]   ..$ setup_strategy  : chr "parallel"
[17:39:34.749]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:34.765] [local output] System call to launch all workers:
[17:39:34.765] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476476072de.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11167 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:34.765] [local output] Starting PSOCK main server
[17:39:34.771] [local output] Workers launched
[17:39:34.771] [local output] Waiting for workers to connect back
[17:39:34.771]  - [local output] 0 workers out of 2 ready
[17:39:35.039]  - [local output] 0 workers out of 2 ready
[17:39:35.040]  - [local output] 1 workers out of 2 ready
[17:39:35.040]  - [local output] 2 workers out of 2 ready
[17:39:35.040] [local output] Launching of workers completed
[17:39:35.040] [local output] Collecting session information from workers
[17:39:35.041] [local output]  - Worker #1 of 2
[17:39:35.042] [local output]  - Worker #2 of 2
[17:39:35.042] [local output] makeClusterPSOCK() ... done
[17:39:35.053] Packages needed by the future expression (n = 0): <none>
[17:39:35.053] Packages needed by future strategies (n = 0): <none>
[17:39:35.053] {
[17:39:35.053]     {
[17:39:35.053]         {
[17:39:35.053]             ...future.startTime <- base::Sys.time()
[17:39:35.053]             {
[17:39:35.053]                 {
[17:39:35.053]                   {
[17:39:35.053]                     {
[17:39:35.053]                       base::local({
[17:39:35.053]                         has_future <- base::requireNamespace("future", 
[17:39:35.053]                           quietly = TRUE)
[17:39:35.053]                         if (has_future) {
[17:39:35.053]                           ns <- base::getNamespace("future")
[17:39:35.053]                           version <- ns[[".package"]][["version"]]
[17:39:35.053]                           if (is.null(version)) 
[17:39:35.053]                             version <- utils::packageVersion("future")
[17:39:35.053]                         }
[17:39:35.053]                         else {
[17:39:35.053]                           version <- NULL
[17:39:35.053]                         }
[17:39:35.053]                         if (!has_future || version < "1.8.0") {
[17:39:35.053]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.053]                             "", base::R.version$version.string), 
[17:39:35.053]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.053]                               "release", "version")], collapse = " "), 
[17:39:35.053]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.053]                             info)
[17:39:35.053]                           info <- base::paste(info, collapse = "; ")
[17:39:35.053]                           if (!has_future) {
[17:39:35.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.053]                               info)
[17:39:35.053]                           }
[17:39:35.053]                           else {
[17:39:35.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.053]                               info, version)
[17:39:35.053]                           }
[17:39:35.053]                           base::stop(msg)
[17:39:35.053]                         }
[17:39:35.053]                       })
[17:39:35.053]                     }
[17:39:35.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.053]                     base::options(mc.cores = 1L)
[17:39:35.053]                   }
[17:39:35.053]                   ...future.strategy.old <- future::plan("list")
[17:39:35.053]                   options(future.plan = NULL)
[17:39:35.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.053]                 }
[17:39:35.053]                 ...future.workdir <- getwd()
[17:39:35.053]             }
[17:39:35.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.053]         }
[17:39:35.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.053]             base::names(...future.oldOptions))
[17:39:35.053]     }
[17:39:35.053]     if (FALSE) {
[17:39:35.053]     }
[17:39:35.053]     else {
[17:39:35.053]         if (TRUE) {
[17:39:35.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.053]                 open = "w")
[17:39:35.053]         }
[17:39:35.053]         else {
[17:39:35.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.053]         }
[17:39:35.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.053]             base::sink(type = "output", split = FALSE)
[17:39:35.053]             base::close(...future.stdout)
[17:39:35.053]         }, add = TRUE)
[17:39:35.053]     }
[17:39:35.053]     ...future.frame <- base::sys.nframe()
[17:39:35.053]     ...future.conditions <- base::list()
[17:39:35.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.053]     if (FALSE) {
[17:39:35.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.053]     }
[17:39:35.053]     ...future.result <- base::tryCatch({
[17:39:35.053]         base::withCallingHandlers({
[17:39:35.053]             ...future.value <- base::withVisible(base::local({
[17:39:35.053]                 ...future.makeSendCondition <- base::local({
[17:39:35.053]                   sendCondition <- NULL
[17:39:35.053]                   function(frame = 1L) {
[17:39:35.053]                     if (is.function(sendCondition)) 
[17:39:35.053]                       return(sendCondition)
[17:39:35.053]                     ns <- getNamespace("parallel")
[17:39:35.053]                     if (exists("sendData", mode = "function", 
[17:39:35.053]                       envir = ns)) {
[17:39:35.053]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.053]                         envir = ns)
[17:39:35.053]                       envir <- sys.frame(frame)
[17:39:35.053]                       master <- NULL
[17:39:35.053]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.053]                         !identical(envir, emptyenv())) {
[17:39:35.053]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.053]                           inherits = FALSE)) {
[17:39:35.053]                           master <- get("master", mode = "list", 
[17:39:35.053]                             envir = envir, inherits = FALSE)
[17:39:35.053]                           if (inherits(master, c("SOCKnode", 
[17:39:35.053]                             "SOCK0node"))) {
[17:39:35.053]                             sendCondition <<- function(cond) {
[17:39:35.053]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.053]                                 success = TRUE)
[17:39:35.053]                               parallel_sendData(master, data)
[17:39:35.053]                             }
[17:39:35.053]                             return(sendCondition)
[17:39:35.053]                           }
[17:39:35.053]                         }
[17:39:35.053]                         frame <- frame + 1L
[17:39:35.053]                         envir <- sys.frame(frame)
[17:39:35.053]                       }
[17:39:35.053]                     }
[17:39:35.053]                     sendCondition <<- function(cond) NULL
[17:39:35.053]                   }
[17:39:35.053]                 })
[17:39:35.053]                 withCallingHandlers({
[17:39:35.053]                   NA
[17:39:35.053]                 }, immediateCondition = function(cond) {
[17:39:35.053]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.053]                   sendCondition(cond)
[17:39:35.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.053]                   {
[17:39:35.053]                     inherits <- base::inherits
[17:39:35.053]                     invokeRestart <- base::invokeRestart
[17:39:35.053]                     is.null <- base::is.null
[17:39:35.053]                     muffled <- FALSE
[17:39:35.053]                     if (inherits(cond, "message")) {
[17:39:35.053]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.053]                       if (muffled) 
[17:39:35.053]                         invokeRestart("muffleMessage")
[17:39:35.053]                     }
[17:39:35.053]                     else if (inherits(cond, "warning")) {
[17:39:35.053]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.053]                       if (muffled) 
[17:39:35.053]                         invokeRestart("muffleWarning")
[17:39:35.053]                     }
[17:39:35.053]                     else if (inherits(cond, "condition")) {
[17:39:35.053]                       if (!is.null(pattern)) {
[17:39:35.053]                         computeRestarts <- base::computeRestarts
[17:39:35.053]                         grepl <- base::grepl
[17:39:35.053]                         restarts <- computeRestarts(cond)
[17:39:35.053]                         for (restart in restarts) {
[17:39:35.053]                           name <- restart$name
[17:39:35.053]                           if (is.null(name)) 
[17:39:35.053]                             next
[17:39:35.053]                           if (!grepl(pattern, name)) 
[17:39:35.053]                             next
[17:39:35.053]                           invokeRestart(restart)
[17:39:35.053]                           muffled <- TRUE
[17:39:35.053]                           break
[17:39:35.053]                         }
[17:39:35.053]                       }
[17:39:35.053]                     }
[17:39:35.053]                     invisible(muffled)
[17:39:35.053]                   }
[17:39:35.053]                   muffleCondition(cond)
[17:39:35.053]                 })
[17:39:35.053]             }))
[17:39:35.053]             future::FutureResult(value = ...future.value$value, 
[17:39:35.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.053]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.053]                     ...future.globalenv.names))
[17:39:35.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.053]         }, condition = base::local({
[17:39:35.053]             c <- base::c
[17:39:35.053]             inherits <- base::inherits
[17:39:35.053]             invokeRestart <- base::invokeRestart
[17:39:35.053]             length <- base::length
[17:39:35.053]             list <- base::list
[17:39:35.053]             seq.int <- base::seq.int
[17:39:35.053]             signalCondition <- base::signalCondition
[17:39:35.053]             sys.calls <- base::sys.calls
[17:39:35.053]             `[[` <- base::`[[`
[17:39:35.053]             `+` <- base::`+`
[17:39:35.053]             `<<-` <- base::`<<-`
[17:39:35.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.053]                   3L)]
[17:39:35.053]             }
[17:39:35.053]             function(cond) {
[17:39:35.053]                 is_error <- inherits(cond, "error")
[17:39:35.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.053]                   NULL)
[17:39:35.053]                 if (is_error) {
[17:39:35.053]                   sessionInformation <- function() {
[17:39:35.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.053]                       search = base::search(), system = base::Sys.info())
[17:39:35.053]                   }
[17:39:35.053]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.053]                     cond$call), session = sessionInformation(), 
[17:39:35.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.053]                   signalCondition(cond)
[17:39:35.053]                 }
[17:39:35.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.053]                 "immediateCondition"))) {
[17:39:35.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.053]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.053]                   if (TRUE && !signal) {
[17:39:35.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.053]                     {
[17:39:35.053]                       inherits <- base::inherits
[17:39:35.053]                       invokeRestart <- base::invokeRestart
[17:39:35.053]                       is.null <- base::is.null
[17:39:35.053]                       muffled <- FALSE
[17:39:35.053]                       if (inherits(cond, "message")) {
[17:39:35.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.053]                         if (muffled) 
[17:39:35.053]                           invokeRestart("muffleMessage")
[17:39:35.053]                       }
[17:39:35.053]                       else if (inherits(cond, "warning")) {
[17:39:35.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.053]                         if (muffled) 
[17:39:35.053]                           invokeRestart("muffleWarning")
[17:39:35.053]                       }
[17:39:35.053]                       else if (inherits(cond, "condition")) {
[17:39:35.053]                         if (!is.null(pattern)) {
[17:39:35.053]                           computeRestarts <- base::computeRestarts
[17:39:35.053]                           grepl <- base::grepl
[17:39:35.053]                           restarts <- computeRestarts(cond)
[17:39:35.053]                           for (restart in restarts) {
[17:39:35.053]                             name <- restart$name
[17:39:35.053]                             if (is.null(name)) 
[17:39:35.053]                               next
[17:39:35.053]                             if (!grepl(pattern, name)) 
[17:39:35.053]                               next
[17:39:35.053]                             invokeRestart(restart)
[17:39:35.053]                             muffled <- TRUE
[17:39:35.053]                             break
[17:39:35.053]                           }
[17:39:35.053]                         }
[17:39:35.053]                       }
[17:39:35.053]                       invisible(muffled)
[17:39:35.053]                     }
[17:39:35.053]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.053]                   }
[17:39:35.053]                 }
[17:39:35.053]                 else {
[17:39:35.053]                   if (TRUE) {
[17:39:35.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.053]                     {
[17:39:35.053]                       inherits <- base::inherits
[17:39:35.053]                       invokeRestart <- base::invokeRestart
[17:39:35.053]                       is.null <- base::is.null
[17:39:35.053]                       muffled <- FALSE
[17:39:35.053]                       if (inherits(cond, "message")) {
[17:39:35.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.053]                         if (muffled) 
[17:39:35.053]                           invokeRestart("muffleMessage")
[17:39:35.053]                       }
[17:39:35.053]                       else if (inherits(cond, "warning")) {
[17:39:35.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.053]                         if (muffled) 
[17:39:35.053]                           invokeRestart("muffleWarning")
[17:39:35.053]                       }
[17:39:35.053]                       else if (inherits(cond, "condition")) {
[17:39:35.053]                         if (!is.null(pattern)) {
[17:39:35.053]                           computeRestarts <- base::computeRestarts
[17:39:35.053]                           grepl <- base::grepl
[17:39:35.053]                           restarts <- computeRestarts(cond)
[17:39:35.053]                           for (restart in restarts) {
[17:39:35.053]                             name <- restart$name
[17:39:35.053]                             if (is.null(name)) 
[17:39:35.053]                               next
[17:39:35.053]                             if (!grepl(pattern, name)) 
[17:39:35.053]                               next
[17:39:35.053]                             invokeRestart(restart)
[17:39:35.053]                             muffled <- TRUE
[17:39:35.053]                             break
[17:39:35.053]                           }
[17:39:35.053]                         }
[17:39:35.053]                       }
[17:39:35.053]                       invisible(muffled)
[17:39:35.053]                     }
[17:39:35.053]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.053]                   }
[17:39:35.053]                 }
[17:39:35.053]             }
[17:39:35.053]         }))
[17:39:35.053]     }, error = function(ex) {
[17:39:35.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.053]                 ...future.rng), started = ...future.startTime, 
[17:39:35.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.053]             version = "1.8"), class = "FutureResult")
[17:39:35.053]     }, finally = {
[17:39:35.053]         if (!identical(...future.workdir, getwd())) 
[17:39:35.053]             setwd(...future.workdir)
[17:39:35.053]         {
[17:39:35.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.053]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.053]             }
[17:39:35.053]             base::options(...future.oldOptions)
[17:39:35.053]             if (.Platform$OS.type == "windows") {
[17:39:35.053]                 old_names <- names(...future.oldEnvVars)
[17:39:35.053]                 envs <- base::Sys.getenv()
[17:39:35.053]                 names <- names(envs)
[17:39:35.053]                 common <- intersect(names, old_names)
[17:39:35.053]                 added <- setdiff(names, old_names)
[17:39:35.053]                 removed <- setdiff(old_names, names)
[17:39:35.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.053]                   envs[common]]
[17:39:35.053]                 NAMES <- toupper(changed)
[17:39:35.053]                 args <- list()
[17:39:35.053]                 for (kk in seq_along(NAMES)) {
[17:39:35.053]                   name <- changed[[kk]]
[17:39:35.053]                   NAME <- NAMES[[kk]]
[17:39:35.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.053]                     next
[17:39:35.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.053]                 }
[17:39:35.053]                 NAMES <- toupper(added)
[17:39:35.053]                 for (kk in seq_along(NAMES)) {
[17:39:35.053]                   name <- added[[kk]]
[17:39:35.053]                   NAME <- NAMES[[kk]]
[17:39:35.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.053]                     next
[17:39:35.053]                   args[[name]] <- ""
[17:39:35.053]                 }
[17:39:35.053]                 NAMES <- toupper(removed)
[17:39:35.053]                 for (kk in seq_along(NAMES)) {
[17:39:35.053]                   name <- removed[[kk]]
[17:39:35.053]                   NAME <- NAMES[[kk]]
[17:39:35.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.053]                     next
[17:39:35.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.053]                 }
[17:39:35.053]                 if (length(args) > 0) 
[17:39:35.053]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.053]             }
[17:39:35.053]             else {
[17:39:35.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.053]             }
[17:39:35.053]             {
[17:39:35.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.053]                   0L) {
[17:39:35.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.053]                   base::options(opts)
[17:39:35.053]                 }
[17:39:35.053]                 {
[17:39:35.053]                   {
[17:39:35.053]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.053]                     NULL
[17:39:35.053]                   }
[17:39:35.053]                   options(future.plan = NULL)
[17:39:35.053]                   if (is.na(NA_character_)) 
[17:39:35.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.053]                     .init = FALSE)
[17:39:35.053]                 }
[17:39:35.053]             }
[17:39:35.053]         }
[17:39:35.053]     })
[17:39:35.053]     if (TRUE) {
[17:39:35.053]         base::sink(type = "output", split = FALSE)
[17:39:35.053]         if (TRUE) {
[17:39:35.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.053]         }
[17:39:35.053]         else {
[17:39:35.053]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.053]         }
[17:39:35.053]         base::close(...future.stdout)
[17:39:35.053]         ...future.stdout <- NULL
[17:39:35.053]     }
[17:39:35.053]     ...future.result$conditions <- ...future.conditions
[17:39:35.053]     ...future.result$finished <- base::Sys.time()
[17:39:35.053]     ...future.result
[17:39:35.053] }
[17:39:35.106] MultisessionFuture started
[17:39:35.106] result() for ClusterFuture ...
[17:39:35.107] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.107] - Validating connection of MultisessionFuture
[17:39:35.139] - received message: FutureResult
[17:39:35.140] - Received FutureResult
[17:39:35.140] - Erased future from FutureRegistry
[17:39:35.140] result() for ClusterFuture ...
[17:39:35.140] - result already collected: FutureResult
[17:39:35.140] result() for ClusterFuture ... done
[17:39:35.140] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.140] result() for ClusterFuture ... done
[17:39:35.140] result() for ClusterFuture ...
[17:39:35.141] - result already collected: FutureResult
[17:39:35.141] result() for ClusterFuture ... done
[17:39:35.141] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:35.145] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:35.145] getGlobalsAndPackages() ...
[17:39:35.145] Searching for globals...
[17:39:35.146] 
[17:39:35.146] Searching for globals ... DONE
[17:39:35.146] - globals: [0] <none>
[17:39:35.146] getGlobalsAndPackages() ... DONE
[17:39:35.146] run() for ‘Future’ ...
[17:39:35.146] - state: ‘created’
[17:39:35.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.161]   - Field: ‘node’
[17:39:35.161]   - Field: ‘label’
[17:39:35.161]   - Field: ‘local’
[17:39:35.162]   - Field: ‘owner’
[17:39:35.162]   - Field: ‘envir’
[17:39:35.162]   - Field: ‘workers’
[17:39:35.162]   - Field: ‘packages’
[17:39:35.162]   - Field: ‘gc’
[17:39:35.162]   - Field: ‘conditions’
[17:39:35.162]   - Field: ‘persistent’
[17:39:35.162]   - Field: ‘expr’
[17:39:35.162]   - Field: ‘uuid’
[17:39:35.162]   - Field: ‘seed’
[17:39:35.163]   - Field: ‘version’
[17:39:35.163]   - Field: ‘result’
[17:39:35.163]   - Field: ‘asynchronous’
[17:39:35.163]   - Field: ‘calls’
[17:39:35.163]   - Field: ‘globals’
[17:39:35.163]   - Field: ‘stdout’
[17:39:35.163]   - Field: ‘earlySignal’
[17:39:35.163]   - Field: ‘lazy’
[17:39:35.163]   - Field: ‘state’
[17:39:35.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.164] - Launch lazy future ...
[17:39:35.164] Packages needed by the future expression (n = 0): <none>
[17:39:35.164] Packages needed by future strategies (n = 0): <none>
[17:39:35.165] {
[17:39:35.165]     {
[17:39:35.165]         {
[17:39:35.165]             ...future.startTime <- base::Sys.time()
[17:39:35.165]             {
[17:39:35.165]                 {
[17:39:35.165]                   {
[17:39:35.165]                     {
[17:39:35.165]                       base::local({
[17:39:35.165]                         has_future <- base::requireNamespace("future", 
[17:39:35.165]                           quietly = TRUE)
[17:39:35.165]                         if (has_future) {
[17:39:35.165]                           ns <- base::getNamespace("future")
[17:39:35.165]                           version <- ns[[".package"]][["version"]]
[17:39:35.165]                           if (is.null(version)) 
[17:39:35.165]                             version <- utils::packageVersion("future")
[17:39:35.165]                         }
[17:39:35.165]                         else {
[17:39:35.165]                           version <- NULL
[17:39:35.165]                         }
[17:39:35.165]                         if (!has_future || version < "1.8.0") {
[17:39:35.165]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.165]                             "", base::R.version$version.string), 
[17:39:35.165]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.165]                               "release", "version")], collapse = " "), 
[17:39:35.165]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.165]                             info)
[17:39:35.165]                           info <- base::paste(info, collapse = "; ")
[17:39:35.165]                           if (!has_future) {
[17:39:35.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.165]                               info)
[17:39:35.165]                           }
[17:39:35.165]                           else {
[17:39:35.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.165]                               info, version)
[17:39:35.165]                           }
[17:39:35.165]                           base::stop(msg)
[17:39:35.165]                         }
[17:39:35.165]                       })
[17:39:35.165]                     }
[17:39:35.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.165]                     base::options(mc.cores = 1L)
[17:39:35.165]                   }
[17:39:35.165]                   ...future.strategy.old <- future::plan("list")
[17:39:35.165]                   options(future.plan = NULL)
[17:39:35.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.165]                 }
[17:39:35.165]                 ...future.workdir <- getwd()
[17:39:35.165]             }
[17:39:35.165]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.165]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.165]         }
[17:39:35.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.165]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.165]             base::names(...future.oldOptions))
[17:39:35.165]     }
[17:39:35.165]     if (FALSE) {
[17:39:35.165]     }
[17:39:35.165]     else {
[17:39:35.165]         if (TRUE) {
[17:39:35.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.165]                 open = "w")
[17:39:35.165]         }
[17:39:35.165]         else {
[17:39:35.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.165]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.165]         }
[17:39:35.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.165]             base::sink(type = "output", split = FALSE)
[17:39:35.165]             base::close(...future.stdout)
[17:39:35.165]         }, add = TRUE)
[17:39:35.165]     }
[17:39:35.165]     ...future.frame <- base::sys.nframe()
[17:39:35.165]     ...future.conditions <- base::list()
[17:39:35.165]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.165]     if (FALSE) {
[17:39:35.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.165]     }
[17:39:35.165]     ...future.result <- base::tryCatch({
[17:39:35.165]         base::withCallingHandlers({
[17:39:35.165]             ...future.value <- base::withVisible(base::local({
[17:39:35.165]                 ...future.makeSendCondition <- base::local({
[17:39:35.165]                   sendCondition <- NULL
[17:39:35.165]                   function(frame = 1L) {
[17:39:35.165]                     if (is.function(sendCondition)) 
[17:39:35.165]                       return(sendCondition)
[17:39:35.165]                     ns <- getNamespace("parallel")
[17:39:35.165]                     if (exists("sendData", mode = "function", 
[17:39:35.165]                       envir = ns)) {
[17:39:35.165]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.165]                         envir = ns)
[17:39:35.165]                       envir <- sys.frame(frame)
[17:39:35.165]                       master <- NULL
[17:39:35.165]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.165]                         !identical(envir, emptyenv())) {
[17:39:35.165]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.165]                           inherits = FALSE)) {
[17:39:35.165]                           master <- get("master", mode = "list", 
[17:39:35.165]                             envir = envir, inherits = FALSE)
[17:39:35.165]                           if (inherits(master, c("SOCKnode", 
[17:39:35.165]                             "SOCK0node"))) {
[17:39:35.165]                             sendCondition <<- function(cond) {
[17:39:35.165]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.165]                                 success = TRUE)
[17:39:35.165]                               parallel_sendData(master, data)
[17:39:35.165]                             }
[17:39:35.165]                             return(sendCondition)
[17:39:35.165]                           }
[17:39:35.165]                         }
[17:39:35.165]                         frame <- frame + 1L
[17:39:35.165]                         envir <- sys.frame(frame)
[17:39:35.165]                       }
[17:39:35.165]                     }
[17:39:35.165]                     sendCondition <<- function(cond) NULL
[17:39:35.165]                   }
[17:39:35.165]                 })
[17:39:35.165]                 withCallingHandlers({
[17:39:35.165]                   2
[17:39:35.165]                 }, immediateCondition = function(cond) {
[17:39:35.165]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.165]                   sendCondition(cond)
[17:39:35.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.165]                   {
[17:39:35.165]                     inherits <- base::inherits
[17:39:35.165]                     invokeRestart <- base::invokeRestart
[17:39:35.165]                     is.null <- base::is.null
[17:39:35.165]                     muffled <- FALSE
[17:39:35.165]                     if (inherits(cond, "message")) {
[17:39:35.165]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.165]                       if (muffled) 
[17:39:35.165]                         invokeRestart("muffleMessage")
[17:39:35.165]                     }
[17:39:35.165]                     else if (inherits(cond, "warning")) {
[17:39:35.165]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.165]                       if (muffled) 
[17:39:35.165]                         invokeRestart("muffleWarning")
[17:39:35.165]                     }
[17:39:35.165]                     else if (inherits(cond, "condition")) {
[17:39:35.165]                       if (!is.null(pattern)) {
[17:39:35.165]                         computeRestarts <- base::computeRestarts
[17:39:35.165]                         grepl <- base::grepl
[17:39:35.165]                         restarts <- computeRestarts(cond)
[17:39:35.165]                         for (restart in restarts) {
[17:39:35.165]                           name <- restart$name
[17:39:35.165]                           if (is.null(name)) 
[17:39:35.165]                             next
[17:39:35.165]                           if (!grepl(pattern, name)) 
[17:39:35.165]                             next
[17:39:35.165]                           invokeRestart(restart)
[17:39:35.165]                           muffled <- TRUE
[17:39:35.165]                           break
[17:39:35.165]                         }
[17:39:35.165]                       }
[17:39:35.165]                     }
[17:39:35.165]                     invisible(muffled)
[17:39:35.165]                   }
[17:39:35.165]                   muffleCondition(cond)
[17:39:35.165]                 })
[17:39:35.165]             }))
[17:39:35.165]             future::FutureResult(value = ...future.value$value, 
[17:39:35.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.165]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.165]                     ...future.globalenv.names))
[17:39:35.165]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.165]         }, condition = base::local({
[17:39:35.165]             c <- base::c
[17:39:35.165]             inherits <- base::inherits
[17:39:35.165]             invokeRestart <- base::invokeRestart
[17:39:35.165]             length <- base::length
[17:39:35.165]             list <- base::list
[17:39:35.165]             seq.int <- base::seq.int
[17:39:35.165]             signalCondition <- base::signalCondition
[17:39:35.165]             sys.calls <- base::sys.calls
[17:39:35.165]             `[[` <- base::`[[`
[17:39:35.165]             `+` <- base::`+`
[17:39:35.165]             `<<-` <- base::`<<-`
[17:39:35.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.165]                   3L)]
[17:39:35.165]             }
[17:39:35.165]             function(cond) {
[17:39:35.165]                 is_error <- inherits(cond, "error")
[17:39:35.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.165]                   NULL)
[17:39:35.165]                 if (is_error) {
[17:39:35.165]                   sessionInformation <- function() {
[17:39:35.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.165]                       search = base::search(), system = base::Sys.info())
[17:39:35.165]                   }
[17:39:35.165]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.165]                     cond$call), session = sessionInformation(), 
[17:39:35.165]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.165]                   signalCondition(cond)
[17:39:35.165]                 }
[17:39:35.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.165]                 "immediateCondition"))) {
[17:39:35.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.165]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.165]                   if (TRUE && !signal) {
[17:39:35.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.165]                     {
[17:39:35.165]                       inherits <- base::inherits
[17:39:35.165]                       invokeRestart <- base::invokeRestart
[17:39:35.165]                       is.null <- base::is.null
[17:39:35.165]                       muffled <- FALSE
[17:39:35.165]                       if (inherits(cond, "message")) {
[17:39:35.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.165]                         if (muffled) 
[17:39:35.165]                           invokeRestart("muffleMessage")
[17:39:35.165]                       }
[17:39:35.165]                       else if (inherits(cond, "warning")) {
[17:39:35.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.165]                         if (muffled) 
[17:39:35.165]                           invokeRestart("muffleWarning")
[17:39:35.165]                       }
[17:39:35.165]                       else if (inherits(cond, "condition")) {
[17:39:35.165]                         if (!is.null(pattern)) {
[17:39:35.165]                           computeRestarts <- base::computeRestarts
[17:39:35.165]                           grepl <- base::grepl
[17:39:35.165]                           restarts <- computeRestarts(cond)
[17:39:35.165]                           for (restart in restarts) {
[17:39:35.165]                             name <- restart$name
[17:39:35.165]                             if (is.null(name)) 
[17:39:35.165]                               next
[17:39:35.165]                             if (!grepl(pattern, name)) 
[17:39:35.165]                               next
[17:39:35.165]                             invokeRestart(restart)
[17:39:35.165]                             muffled <- TRUE
[17:39:35.165]                             break
[17:39:35.165]                           }
[17:39:35.165]                         }
[17:39:35.165]                       }
[17:39:35.165]                       invisible(muffled)
[17:39:35.165]                     }
[17:39:35.165]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.165]                   }
[17:39:35.165]                 }
[17:39:35.165]                 else {
[17:39:35.165]                   if (TRUE) {
[17:39:35.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.165]                     {
[17:39:35.165]                       inherits <- base::inherits
[17:39:35.165]                       invokeRestart <- base::invokeRestart
[17:39:35.165]                       is.null <- base::is.null
[17:39:35.165]                       muffled <- FALSE
[17:39:35.165]                       if (inherits(cond, "message")) {
[17:39:35.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.165]                         if (muffled) 
[17:39:35.165]                           invokeRestart("muffleMessage")
[17:39:35.165]                       }
[17:39:35.165]                       else if (inherits(cond, "warning")) {
[17:39:35.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.165]                         if (muffled) 
[17:39:35.165]                           invokeRestart("muffleWarning")
[17:39:35.165]                       }
[17:39:35.165]                       else if (inherits(cond, "condition")) {
[17:39:35.165]                         if (!is.null(pattern)) {
[17:39:35.165]                           computeRestarts <- base::computeRestarts
[17:39:35.165]                           grepl <- base::grepl
[17:39:35.165]                           restarts <- computeRestarts(cond)
[17:39:35.165]                           for (restart in restarts) {
[17:39:35.165]                             name <- restart$name
[17:39:35.165]                             if (is.null(name)) 
[17:39:35.165]                               next
[17:39:35.165]                             if (!grepl(pattern, name)) 
[17:39:35.165]                               next
[17:39:35.165]                             invokeRestart(restart)
[17:39:35.165]                             muffled <- TRUE
[17:39:35.165]                             break
[17:39:35.165]                           }
[17:39:35.165]                         }
[17:39:35.165]                       }
[17:39:35.165]                       invisible(muffled)
[17:39:35.165]                     }
[17:39:35.165]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.165]                   }
[17:39:35.165]                 }
[17:39:35.165]             }
[17:39:35.165]         }))
[17:39:35.165]     }, error = function(ex) {
[17:39:35.165]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.165]                 ...future.rng), started = ...future.startTime, 
[17:39:35.165]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.165]             version = "1.8"), class = "FutureResult")
[17:39:35.165]     }, finally = {
[17:39:35.165]         if (!identical(...future.workdir, getwd())) 
[17:39:35.165]             setwd(...future.workdir)
[17:39:35.165]         {
[17:39:35.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.165]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.165]             }
[17:39:35.165]             base::options(...future.oldOptions)
[17:39:35.165]             if (.Platform$OS.type == "windows") {
[17:39:35.165]                 old_names <- names(...future.oldEnvVars)
[17:39:35.165]                 envs <- base::Sys.getenv()
[17:39:35.165]                 names <- names(envs)
[17:39:35.165]                 common <- intersect(names, old_names)
[17:39:35.165]                 added <- setdiff(names, old_names)
[17:39:35.165]                 removed <- setdiff(old_names, names)
[17:39:35.165]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.165]                   envs[common]]
[17:39:35.165]                 NAMES <- toupper(changed)
[17:39:35.165]                 args <- list()
[17:39:35.165]                 for (kk in seq_along(NAMES)) {
[17:39:35.165]                   name <- changed[[kk]]
[17:39:35.165]                   NAME <- NAMES[[kk]]
[17:39:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.165]                     next
[17:39:35.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.165]                 }
[17:39:35.165]                 NAMES <- toupper(added)
[17:39:35.165]                 for (kk in seq_along(NAMES)) {
[17:39:35.165]                   name <- added[[kk]]
[17:39:35.165]                   NAME <- NAMES[[kk]]
[17:39:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.165]                     next
[17:39:35.165]                   args[[name]] <- ""
[17:39:35.165]                 }
[17:39:35.165]                 NAMES <- toupper(removed)
[17:39:35.165]                 for (kk in seq_along(NAMES)) {
[17:39:35.165]                   name <- removed[[kk]]
[17:39:35.165]                   NAME <- NAMES[[kk]]
[17:39:35.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.165]                     next
[17:39:35.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.165]                 }
[17:39:35.165]                 if (length(args) > 0) 
[17:39:35.165]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.165]             }
[17:39:35.165]             else {
[17:39:35.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.165]             }
[17:39:35.165]             {
[17:39:35.165]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.165]                   0L) {
[17:39:35.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.165]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.165]                   base::options(opts)
[17:39:35.165]                 }
[17:39:35.165]                 {
[17:39:35.165]                   {
[17:39:35.165]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.165]                     NULL
[17:39:35.165]                   }
[17:39:35.165]                   options(future.plan = NULL)
[17:39:35.165]                   if (is.na(NA_character_)) 
[17:39:35.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.165]                     .init = FALSE)
[17:39:35.165]                 }
[17:39:35.165]             }
[17:39:35.165]         }
[17:39:35.165]     })
[17:39:35.165]     if (TRUE) {
[17:39:35.165]         base::sink(type = "output", split = FALSE)
[17:39:35.165]         if (TRUE) {
[17:39:35.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.165]         }
[17:39:35.165]         else {
[17:39:35.165]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.165]         }
[17:39:35.165]         base::close(...future.stdout)
[17:39:35.165]         ...future.stdout <- NULL
[17:39:35.165]     }
[17:39:35.165]     ...future.result$conditions <- ...future.conditions
[17:39:35.165]     ...future.result$finished <- base::Sys.time()
[17:39:35.165]     ...future.result
[17:39:35.165] }
[17:39:35.168] MultisessionFuture started
[17:39:35.168] - Launch lazy future ... done
[17:39:35.168] run() for ‘MultisessionFuture’ ... done
[17:39:35.169] getGlobalsAndPackages() ...
[17:39:35.169] Searching for globals...
[17:39:35.169] 
[17:39:35.170] Searching for globals ... DONE
[17:39:35.170] - globals: [0] <none>
[17:39:35.170] getGlobalsAndPackages() ... DONE
[17:39:35.170] run() for ‘Future’ ...
[17:39:35.171] - state: ‘created’
[17:39:35.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.186]   - Field: ‘node’
[17:39:35.186]   - Field: ‘label’
[17:39:35.186]   - Field: ‘local’
[17:39:35.186]   - Field: ‘owner’
[17:39:35.186]   - Field: ‘envir’
[17:39:35.186]   - Field: ‘workers’
[17:39:35.186]   - Field: ‘packages’
[17:39:35.186]   - Field: ‘gc’
[17:39:35.186]   - Field: ‘conditions’
[17:39:35.187]   - Field: ‘persistent’
[17:39:35.187]   - Field: ‘expr’
[17:39:35.187]   - Field: ‘uuid’
[17:39:35.187]   - Field: ‘seed’
[17:39:35.187]   - Field: ‘version’
[17:39:35.187]   - Field: ‘result’
[17:39:35.187]   - Field: ‘asynchronous’
[17:39:35.187]   - Field: ‘calls’
[17:39:35.187]   - Field: ‘globals’
[17:39:35.188]   - Field: ‘stdout’
[17:39:35.188]   - Field: ‘earlySignal’
[17:39:35.188]   - Field: ‘lazy’
[17:39:35.188]   - Field: ‘state’
[17:39:35.188] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.188] - Launch lazy future ...
[17:39:35.188] Packages needed by the future expression (n = 0): <none>
[17:39:35.189] Packages needed by future strategies (n = 0): <none>
[17:39:35.189] {
[17:39:35.189]     {
[17:39:35.189]         {
[17:39:35.189]             ...future.startTime <- base::Sys.time()
[17:39:35.189]             {
[17:39:35.189]                 {
[17:39:35.189]                   {
[17:39:35.189]                     {
[17:39:35.189]                       base::local({
[17:39:35.189]                         has_future <- base::requireNamespace("future", 
[17:39:35.189]                           quietly = TRUE)
[17:39:35.189]                         if (has_future) {
[17:39:35.189]                           ns <- base::getNamespace("future")
[17:39:35.189]                           version <- ns[[".package"]][["version"]]
[17:39:35.189]                           if (is.null(version)) 
[17:39:35.189]                             version <- utils::packageVersion("future")
[17:39:35.189]                         }
[17:39:35.189]                         else {
[17:39:35.189]                           version <- NULL
[17:39:35.189]                         }
[17:39:35.189]                         if (!has_future || version < "1.8.0") {
[17:39:35.189]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.189]                             "", base::R.version$version.string), 
[17:39:35.189]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.189]                               "release", "version")], collapse = " "), 
[17:39:35.189]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.189]                             info)
[17:39:35.189]                           info <- base::paste(info, collapse = "; ")
[17:39:35.189]                           if (!has_future) {
[17:39:35.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.189]                               info)
[17:39:35.189]                           }
[17:39:35.189]                           else {
[17:39:35.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.189]                               info, version)
[17:39:35.189]                           }
[17:39:35.189]                           base::stop(msg)
[17:39:35.189]                         }
[17:39:35.189]                       })
[17:39:35.189]                     }
[17:39:35.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.189]                     base::options(mc.cores = 1L)
[17:39:35.189]                   }
[17:39:35.189]                   ...future.strategy.old <- future::plan("list")
[17:39:35.189]                   options(future.plan = NULL)
[17:39:35.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.189]                 }
[17:39:35.189]                 ...future.workdir <- getwd()
[17:39:35.189]             }
[17:39:35.189]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.189]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.189]         }
[17:39:35.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.189]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.189]             base::names(...future.oldOptions))
[17:39:35.189]     }
[17:39:35.189]     if (FALSE) {
[17:39:35.189]     }
[17:39:35.189]     else {
[17:39:35.189]         if (TRUE) {
[17:39:35.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.189]                 open = "w")
[17:39:35.189]         }
[17:39:35.189]         else {
[17:39:35.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.189]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.189]         }
[17:39:35.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.189]             base::sink(type = "output", split = FALSE)
[17:39:35.189]             base::close(...future.stdout)
[17:39:35.189]         }, add = TRUE)
[17:39:35.189]     }
[17:39:35.189]     ...future.frame <- base::sys.nframe()
[17:39:35.189]     ...future.conditions <- base::list()
[17:39:35.189]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.189]     if (FALSE) {
[17:39:35.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.189]     }
[17:39:35.189]     ...future.result <- base::tryCatch({
[17:39:35.189]         base::withCallingHandlers({
[17:39:35.189]             ...future.value <- base::withVisible(base::local({
[17:39:35.189]                 ...future.makeSendCondition <- base::local({
[17:39:35.189]                   sendCondition <- NULL
[17:39:35.189]                   function(frame = 1L) {
[17:39:35.189]                     if (is.function(sendCondition)) 
[17:39:35.189]                       return(sendCondition)
[17:39:35.189]                     ns <- getNamespace("parallel")
[17:39:35.189]                     if (exists("sendData", mode = "function", 
[17:39:35.189]                       envir = ns)) {
[17:39:35.189]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.189]                         envir = ns)
[17:39:35.189]                       envir <- sys.frame(frame)
[17:39:35.189]                       master <- NULL
[17:39:35.189]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.189]                         !identical(envir, emptyenv())) {
[17:39:35.189]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.189]                           inherits = FALSE)) {
[17:39:35.189]                           master <- get("master", mode = "list", 
[17:39:35.189]                             envir = envir, inherits = FALSE)
[17:39:35.189]                           if (inherits(master, c("SOCKnode", 
[17:39:35.189]                             "SOCK0node"))) {
[17:39:35.189]                             sendCondition <<- function(cond) {
[17:39:35.189]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.189]                                 success = TRUE)
[17:39:35.189]                               parallel_sendData(master, data)
[17:39:35.189]                             }
[17:39:35.189]                             return(sendCondition)
[17:39:35.189]                           }
[17:39:35.189]                         }
[17:39:35.189]                         frame <- frame + 1L
[17:39:35.189]                         envir <- sys.frame(frame)
[17:39:35.189]                       }
[17:39:35.189]                     }
[17:39:35.189]                     sendCondition <<- function(cond) NULL
[17:39:35.189]                   }
[17:39:35.189]                 })
[17:39:35.189]                 withCallingHandlers({
[17:39:35.189]                   NULL
[17:39:35.189]                 }, immediateCondition = function(cond) {
[17:39:35.189]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.189]                   sendCondition(cond)
[17:39:35.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.189]                   {
[17:39:35.189]                     inherits <- base::inherits
[17:39:35.189]                     invokeRestart <- base::invokeRestart
[17:39:35.189]                     is.null <- base::is.null
[17:39:35.189]                     muffled <- FALSE
[17:39:35.189]                     if (inherits(cond, "message")) {
[17:39:35.189]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.189]                       if (muffled) 
[17:39:35.189]                         invokeRestart("muffleMessage")
[17:39:35.189]                     }
[17:39:35.189]                     else if (inherits(cond, "warning")) {
[17:39:35.189]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.189]                       if (muffled) 
[17:39:35.189]                         invokeRestart("muffleWarning")
[17:39:35.189]                     }
[17:39:35.189]                     else if (inherits(cond, "condition")) {
[17:39:35.189]                       if (!is.null(pattern)) {
[17:39:35.189]                         computeRestarts <- base::computeRestarts
[17:39:35.189]                         grepl <- base::grepl
[17:39:35.189]                         restarts <- computeRestarts(cond)
[17:39:35.189]                         for (restart in restarts) {
[17:39:35.189]                           name <- restart$name
[17:39:35.189]                           if (is.null(name)) 
[17:39:35.189]                             next
[17:39:35.189]                           if (!grepl(pattern, name)) 
[17:39:35.189]                             next
[17:39:35.189]                           invokeRestart(restart)
[17:39:35.189]                           muffled <- TRUE
[17:39:35.189]                           break
[17:39:35.189]                         }
[17:39:35.189]                       }
[17:39:35.189]                     }
[17:39:35.189]                     invisible(muffled)
[17:39:35.189]                   }
[17:39:35.189]                   muffleCondition(cond)
[17:39:35.189]                 })
[17:39:35.189]             }))
[17:39:35.189]             future::FutureResult(value = ...future.value$value, 
[17:39:35.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.189]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.189]                     ...future.globalenv.names))
[17:39:35.189]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.189]         }, condition = base::local({
[17:39:35.189]             c <- base::c
[17:39:35.189]             inherits <- base::inherits
[17:39:35.189]             invokeRestart <- base::invokeRestart
[17:39:35.189]             length <- base::length
[17:39:35.189]             list <- base::list
[17:39:35.189]             seq.int <- base::seq.int
[17:39:35.189]             signalCondition <- base::signalCondition
[17:39:35.189]             sys.calls <- base::sys.calls
[17:39:35.189]             `[[` <- base::`[[`
[17:39:35.189]             `+` <- base::`+`
[17:39:35.189]             `<<-` <- base::`<<-`
[17:39:35.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.189]                   3L)]
[17:39:35.189]             }
[17:39:35.189]             function(cond) {
[17:39:35.189]                 is_error <- inherits(cond, "error")
[17:39:35.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.189]                   NULL)
[17:39:35.189]                 if (is_error) {
[17:39:35.189]                   sessionInformation <- function() {
[17:39:35.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.189]                       search = base::search(), system = base::Sys.info())
[17:39:35.189]                   }
[17:39:35.189]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.189]                     cond$call), session = sessionInformation(), 
[17:39:35.189]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.189]                   signalCondition(cond)
[17:39:35.189]                 }
[17:39:35.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.189]                 "immediateCondition"))) {
[17:39:35.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.189]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.189]                   if (TRUE && !signal) {
[17:39:35.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.189]                     {
[17:39:35.189]                       inherits <- base::inherits
[17:39:35.189]                       invokeRestart <- base::invokeRestart
[17:39:35.189]                       is.null <- base::is.null
[17:39:35.189]                       muffled <- FALSE
[17:39:35.189]                       if (inherits(cond, "message")) {
[17:39:35.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.189]                         if (muffled) 
[17:39:35.189]                           invokeRestart("muffleMessage")
[17:39:35.189]                       }
[17:39:35.189]                       else if (inherits(cond, "warning")) {
[17:39:35.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.189]                         if (muffled) 
[17:39:35.189]                           invokeRestart("muffleWarning")
[17:39:35.189]                       }
[17:39:35.189]                       else if (inherits(cond, "condition")) {
[17:39:35.189]                         if (!is.null(pattern)) {
[17:39:35.189]                           computeRestarts <- base::computeRestarts
[17:39:35.189]                           grepl <- base::grepl
[17:39:35.189]                           restarts <- computeRestarts(cond)
[17:39:35.189]                           for (restart in restarts) {
[17:39:35.189]                             name <- restart$name
[17:39:35.189]                             if (is.null(name)) 
[17:39:35.189]                               next
[17:39:35.189]                             if (!grepl(pattern, name)) 
[17:39:35.189]                               next
[17:39:35.189]                             invokeRestart(restart)
[17:39:35.189]                             muffled <- TRUE
[17:39:35.189]                             break
[17:39:35.189]                           }
[17:39:35.189]                         }
[17:39:35.189]                       }
[17:39:35.189]                       invisible(muffled)
[17:39:35.189]                     }
[17:39:35.189]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.189]                   }
[17:39:35.189]                 }
[17:39:35.189]                 else {
[17:39:35.189]                   if (TRUE) {
[17:39:35.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.189]                     {
[17:39:35.189]                       inherits <- base::inherits
[17:39:35.189]                       invokeRestart <- base::invokeRestart
[17:39:35.189]                       is.null <- base::is.null
[17:39:35.189]                       muffled <- FALSE
[17:39:35.189]                       if (inherits(cond, "message")) {
[17:39:35.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.189]                         if (muffled) 
[17:39:35.189]                           invokeRestart("muffleMessage")
[17:39:35.189]                       }
[17:39:35.189]                       else if (inherits(cond, "warning")) {
[17:39:35.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.189]                         if (muffled) 
[17:39:35.189]                           invokeRestart("muffleWarning")
[17:39:35.189]                       }
[17:39:35.189]                       else if (inherits(cond, "condition")) {
[17:39:35.189]                         if (!is.null(pattern)) {
[17:39:35.189]                           computeRestarts <- base::computeRestarts
[17:39:35.189]                           grepl <- base::grepl
[17:39:35.189]                           restarts <- computeRestarts(cond)
[17:39:35.189]                           for (restart in restarts) {
[17:39:35.189]                             name <- restart$name
[17:39:35.189]                             if (is.null(name)) 
[17:39:35.189]                               next
[17:39:35.189]                             if (!grepl(pattern, name)) 
[17:39:35.189]                               next
[17:39:35.189]                             invokeRestart(restart)
[17:39:35.189]                             muffled <- TRUE
[17:39:35.189]                             break
[17:39:35.189]                           }
[17:39:35.189]                         }
[17:39:35.189]                       }
[17:39:35.189]                       invisible(muffled)
[17:39:35.189]                     }
[17:39:35.189]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.189]                   }
[17:39:35.189]                 }
[17:39:35.189]             }
[17:39:35.189]         }))
[17:39:35.189]     }, error = function(ex) {
[17:39:35.189]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.189]                 ...future.rng), started = ...future.startTime, 
[17:39:35.189]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.189]             version = "1.8"), class = "FutureResult")
[17:39:35.189]     }, finally = {
[17:39:35.189]         if (!identical(...future.workdir, getwd())) 
[17:39:35.189]             setwd(...future.workdir)
[17:39:35.189]         {
[17:39:35.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.189]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.189]             }
[17:39:35.189]             base::options(...future.oldOptions)
[17:39:35.189]             if (.Platform$OS.type == "windows") {
[17:39:35.189]                 old_names <- names(...future.oldEnvVars)
[17:39:35.189]                 envs <- base::Sys.getenv()
[17:39:35.189]                 names <- names(envs)
[17:39:35.189]                 common <- intersect(names, old_names)
[17:39:35.189]                 added <- setdiff(names, old_names)
[17:39:35.189]                 removed <- setdiff(old_names, names)
[17:39:35.189]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.189]                   envs[common]]
[17:39:35.189]                 NAMES <- toupper(changed)
[17:39:35.189]                 args <- list()
[17:39:35.189]                 for (kk in seq_along(NAMES)) {
[17:39:35.189]                   name <- changed[[kk]]
[17:39:35.189]                   NAME <- NAMES[[kk]]
[17:39:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.189]                     next
[17:39:35.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.189]                 }
[17:39:35.189]                 NAMES <- toupper(added)
[17:39:35.189]                 for (kk in seq_along(NAMES)) {
[17:39:35.189]                   name <- added[[kk]]
[17:39:35.189]                   NAME <- NAMES[[kk]]
[17:39:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.189]                     next
[17:39:35.189]                   args[[name]] <- ""
[17:39:35.189]                 }
[17:39:35.189]                 NAMES <- toupper(removed)
[17:39:35.189]                 for (kk in seq_along(NAMES)) {
[17:39:35.189]                   name <- removed[[kk]]
[17:39:35.189]                   NAME <- NAMES[[kk]]
[17:39:35.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.189]                     next
[17:39:35.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.189]                 }
[17:39:35.189]                 if (length(args) > 0) 
[17:39:35.189]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.189]             }
[17:39:35.189]             else {
[17:39:35.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.189]             }
[17:39:35.189]             {
[17:39:35.189]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.189]                   0L) {
[17:39:35.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.189]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.189]                   base::options(opts)
[17:39:35.189]                 }
[17:39:35.189]                 {
[17:39:35.189]                   {
[17:39:35.189]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.189]                     NULL
[17:39:35.189]                   }
[17:39:35.189]                   options(future.plan = NULL)
[17:39:35.189]                   if (is.na(NA_character_)) 
[17:39:35.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.189]                     .init = FALSE)
[17:39:35.189]                 }
[17:39:35.189]             }
[17:39:35.189]         }
[17:39:35.189]     })
[17:39:35.189]     if (TRUE) {
[17:39:35.189]         base::sink(type = "output", split = FALSE)
[17:39:35.189]         if (TRUE) {
[17:39:35.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.189]         }
[17:39:35.189]         else {
[17:39:35.189]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.189]         }
[17:39:35.189]         base::close(...future.stdout)
[17:39:35.189]         ...future.stdout <- NULL
[17:39:35.189]     }
[17:39:35.189]     ...future.result$conditions <- ...future.conditions
[17:39:35.189]     ...future.result$finished <- base::Sys.time()
[17:39:35.189]     ...future.result
[17:39:35.189] }
[17:39:35.244] MultisessionFuture started
[17:39:35.244] - Launch lazy future ... done
[17:39:35.244] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1350b38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf17b2d48> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1350b38> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf17b2d48> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:39:35.253] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.253] - Validating connection of MultisessionFuture
[17:39:35.253] - received message: FutureResult
[17:39:35.254] - Received FutureResult
[17:39:35.254] - Erased future from FutureRegistry
[17:39:35.254] result() for ClusterFuture ...
[17:39:35.254] - result already collected: FutureResult
[17:39:35.254] result() for ClusterFuture ... done
[17:39:35.254] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:35.266] resolve() on list ...
[17:39:35.266]  recursive: 0
[17:39:35.267]  length: 6
[17:39:35.267]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:35.267] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.267] - nx: 6
[17:39:35.267] - relay: TRUE
[17:39:35.268] - stdout: TRUE
[17:39:35.268] - signal: TRUE
[17:39:35.268] - resignal: FALSE
[17:39:35.268] - force: TRUE
[17:39:35.268] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.269]  - until=2
[17:39:35.269]  - relaying element #2
[17:39:35.269] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.269] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.270]  length: 5 (resolved future 1)
[17:39:35.270] Future #2
[17:39:35.270] result() for ClusterFuture ...
[17:39:35.270] - result already collected: FutureResult
[17:39:35.270] result() for ClusterFuture ... done
[17:39:35.271] result() for ClusterFuture ...
[17:39:35.271] - result already collected: FutureResult
[17:39:35.271] result() for ClusterFuture ... done
[17:39:35.271] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:35.272] - nx: 6
[17:39:35.272] - relay: TRUE
[17:39:35.272] - stdout: TRUE
[17:39:35.272] - signal: TRUE
[17:39:35.272] - resignal: FALSE
[17:39:35.272] - force: TRUE
[17:39:35.273] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.273] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.273]  - until=2
[17:39:35.273]  - relaying element #2
[17:39:35.273] result() for ClusterFuture ...
[17:39:35.274] - result already collected: FutureResult
[17:39:35.274] result() for ClusterFuture ... done
[17:39:35.274] result() for ClusterFuture ...
[17:39:35.274] - result already collected: FutureResult
[17:39:35.274] result() for ClusterFuture ... done
[17:39:35.274] result() for ClusterFuture ...
[17:39:35.275] - result already collected: FutureResult
[17:39:35.275] result() for ClusterFuture ... done
[17:39:35.275] result() for ClusterFuture ...
[17:39:35.275] - result already collected: FutureResult
[17:39:35.275] result() for ClusterFuture ... done
[17:39:35.276] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.276] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.276] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:35.276]  length: 4 (resolved future 2)
[17:39:35.287] signalConditionsASAP(NULL, pos=4) ...
[17:39:35.287] - nx: 6
[17:39:35.287] - relay: TRUE
[17:39:35.288] - stdout: TRUE
[17:39:35.288] - signal: TRUE
[17:39:35.288] - resignal: FALSE
[17:39:35.288] - force: TRUE
[17:39:35.288] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.288] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.288]  - until=5
[17:39:35.288]  - relaying element #3
[17:39:35.289]  - relaying element #5
[17:39:35.289] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:39:35.289] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.289] signalConditionsASAP(NULL, pos=4) ... done
[17:39:35.289]  length: 3 (resolved future 4)
[17:39:35.289] signalConditionsASAP(NULL, pos=5) ...
[17:39:35.289] - nx: 6
[17:39:35.289] - relay: TRUE
[17:39:35.289] - stdout: TRUE
[17:39:35.289] - signal: TRUE
[17:39:35.290] - resignal: FALSE
[17:39:35.290] - force: TRUE
[17:39:35.290] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:39:35.290] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.290]  - until=6
[17:39:35.290]  - relaying element #3
[17:39:35.290]  - relaying element #6
[17:39:35.290] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:39:35.290] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.291] signalConditionsASAP(NULL, pos=5) ... done
[17:39:35.291]  length: 2 (resolved future 5)
[17:39:35.291] signalConditionsASAP(numeric, pos=6) ...
[17:39:35.291] - nx: 6
[17:39:35.291] - relay: TRUE
[17:39:35.291] - stdout: TRUE
[17:39:35.291] - signal: TRUE
[17:39:35.291] - resignal: FALSE
[17:39:35.291] - force: TRUE
[17:39:35.292] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:39:35.292] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.292]  - until=6
[17:39:35.292]  - relaying element #3
[17:39:35.292] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:39:35.292] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.292] signalConditionsASAP(NULL, pos=6) ... done
[17:39:35.292]  length: 1 (resolved future 6)
[17:39:35.303] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.303] - Validating connection of MultisessionFuture
[17:39:35.304] - received message: FutureResult
[17:39:35.304] - Received FutureResult
[17:39:35.304] - Erased future from FutureRegistry
[17:39:35.304] result() for ClusterFuture ...
[17:39:35.304] - result already collected: FutureResult
[17:39:35.304] result() for ClusterFuture ... done
[17:39:35.304] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.304] Future #3
[17:39:35.305] result() for ClusterFuture ...
[17:39:35.305] - result already collected: FutureResult
[17:39:35.305] result() for ClusterFuture ... done
[17:39:35.305] result() for ClusterFuture ...
[17:39:35.305] - result already collected: FutureResult
[17:39:35.305] result() for ClusterFuture ... done
[17:39:35.305] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:35.305] - nx: 6
[17:39:35.305] - relay: TRUE
[17:39:35.306] - stdout: TRUE
[17:39:35.306] - signal: TRUE
[17:39:35.306] - resignal: FALSE
[17:39:35.306] - force: TRUE
[17:39:35.306] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:39:35.306] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.306]  - until=6
[17:39:35.306]  - relaying element #3
[17:39:35.306] result() for ClusterFuture ...
[17:39:35.307] - result already collected: FutureResult
[17:39:35.307] result() for ClusterFuture ... done
[17:39:35.307] result() for ClusterFuture ...
[17:39:35.307] - result already collected: FutureResult
[17:39:35.307] result() for ClusterFuture ... done
[17:39:35.307] result() for ClusterFuture ...
[17:39:35.307] - result already collected: FutureResult
[17:39:35.307] result() for ClusterFuture ... done
[17:39:35.307] result() for ClusterFuture ...
[17:39:35.308] - result already collected: FutureResult
[17:39:35.308] result() for ClusterFuture ... done
[17:39:35.308] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.308] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.308] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:35.308]  length: 0 (resolved future 3)
[17:39:35.308] Relaying remaining futures
[17:39:35.308] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.308] - nx: 6
[17:39:35.309] - relay: TRUE
[17:39:35.309] - stdout: TRUE
[17:39:35.309] - signal: TRUE
[17:39:35.309] - resignal: FALSE
[17:39:35.309] - force: TRUE
[17:39:35.309] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.309] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:35.309] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.312] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.312] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.312] resolve() on list ... DONE
[17:39:35.312] result() for ClusterFuture ...
[17:39:35.312] - result already collected: FutureResult
[17:39:35.312] result() for ClusterFuture ... done
[17:39:35.312] result() for ClusterFuture ...
[17:39:35.313] - result already collected: FutureResult
[17:39:35.313] result() for ClusterFuture ... done
[17:39:35.313] result() for ClusterFuture ...
[17:39:35.313] - result already collected: FutureResult
[17:39:35.313] result() for ClusterFuture ... done
[17:39:35.313] result() for ClusterFuture ...
[17:39:35.313] - result already collected: FutureResult
[17:39:35.313] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:39:35.315] getGlobalsAndPackages() ...
[17:39:35.315] Searching for globals...
[17:39:35.316] 
[17:39:35.316] Searching for globals ... DONE
[17:39:35.316] - globals: [0] <none>
[17:39:35.316] getGlobalsAndPackages() ... DONE
[17:39:35.316] run() for ‘Future’ ...
[17:39:35.316] - state: ‘created’
[17:39:35.316] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.330] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.330]   - Field: ‘node’
[17:39:35.331]   - Field: ‘label’
[17:39:35.331]   - Field: ‘local’
[17:39:35.331]   - Field: ‘owner’
[17:39:35.331]   - Field: ‘envir’
[17:39:35.331]   - Field: ‘workers’
[17:39:35.331]   - Field: ‘packages’
[17:39:35.331]   - Field: ‘gc’
[17:39:35.331]   - Field: ‘conditions’
[17:39:35.331]   - Field: ‘persistent’
[17:39:35.331]   - Field: ‘expr’
[17:39:35.331]   - Field: ‘uuid’
[17:39:35.332]   - Field: ‘seed’
[17:39:35.332]   - Field: ‘version’
[17:39:35.332]   - Field: ‘result’
[17:39:35.332]   - Field: ‘asynchronous’
[17:39:35.332]   - Field: ‘calls’
[17:39:35.332]   - Field: ‘globals’
[17:39:35.332]   - Field: ‘stdout’
[17:39:35.332]   - Field: ‘earlySignal’
[17:39:35.332]   - Field: ‘lazy’
[17:39:35.332]   - Field: ‘state’
[17:39:35.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.333] - Launch lazy future ...
[17:39:35.333] Packages needed by the future expression (n = 0): <none>
[17:39:35.333] Packages needed by future strategies (n = 0): <none>
[17:39:35.333] {
[17:39:35.333]     {
[17:39:35.333]         {
[17:39:35.333]             ...future.startTime <- base::Sys.time()
[17:39:35.333]             {
[17:39:35.333]                 {
[17:39:35.333]                   {
[17:39:35.333]                     {
[17:39:35.333]                       base::local({
[17:39:35.333]                         has_future <- base::requireNamespace("future", 
[17:39:35.333]                           quietly = TRUE)
[17:39:35.333]                         if (has_future) {
[17:39:35.333]                           ns <- base::getNamespace("future")
[17:39:35.333]                           version <- ns[[".package"]][["version"]]
[17:39:35.333]                           if (is.null(version)) 
[17:39:35.333]                             version <- utils::packageVersion("future")
[17:39:35.333]                         }
[17:39:35.333]                         else {
[17:39:35.333]                           version <- NULL
[17:39:35.333]                         }
[17:39:35.333]                         if (!has_future || version < "1.8.0") {
[17:39:35.333]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.333]                             "", base::R.version$version.string), 
[17:39:35.333]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.333]                               "release", "version")], collapse = " "), 
[17:39:35.333]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.333]                             info)
[17:39:35.333]                           info <- base::paste(info, collapse = "; ")
[17:39:35.333]                           if (!has_future) {
[17:39:35.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.333]                               info)
[17:39:35.333]                           }
[17:39:35.333]                           else {
[17:39:35.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.333]                               info, version)
[17:39:35.333]                           }
[17:39:35.333]                           base::stop(msg)
[17:39:35.333]                         }
[17:39:35.333]                       })
[17:39:35.333]                     }
[17:39:35.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.333]                     base::options(mc.cores = 1L)
[17:39:35.333]                   }
[17:39:35.333]                   ...future.strategy.old <- future::plan("list")
[17:39:35.333]                   options(future.plan = NULL)
[17:39:35.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.333]                 }
[17:39:35.333]                 ...future.workdir <- getwd()
[17:39:35.333]             }
[17:39:35.333]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.333]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.333]         }
[17:39:35.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.333]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.333]             base::names(...future.oldOptions))
[17:39:35.333]     }
[17:39:35.333]     if (FALSE) {
[17:39:35.333]     }
[17:39:35.333]     else {
[17:39:35.333]         if (TRUE) {
[17:39:35.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.333]                 open = "w")
[17:39:35.333]         }
[17:39:35.333]         else {
[17:39:35.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.333]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.333]         }
[17:39:35.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.333]             base::sink(type = "output", split = FALSE)
[17:39:35.333]             base::close(...future.stdout)
[17:39:35.333]         }, add = TRUE)
[17:39:35.333]     }
[17:39:35.333]     ...future.frame <- base::sys.nframe()
[17:39:35.333]     ...future.conditions <- base::list()
[17:39:35.333]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.333]     if (FALSE) {
[17:39:35.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.333]     }
[17:39:35.333]     ...future.result <- base::tryCatch({
[17:39:35.333]         base::withCallingHandlers({
[17:39:35.333]             ...future.value <- base::withVisible(base::local({
[17:39:35.333]                 ...future.makeSendCondition <- base::local({
[17:39:35.333]                   sendCondition <- NULL
[17:39:35.333]                   function(frame = 1L) {
[17:39:35.333]                     if (is.function(sendCondition)) 
[17:39:35.333]                       return(sendCondition)
[17:39:35.333]                     ns <- getNamespace("parallel")
[17:39:35.333]                     if (exists("sendData", mode = "function", 
[17:39:35.333]                       envir = ns)) {
[17:39:35.333]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.333]                         envir = ns)
[17:39:35.333]                       envir <- sys.frame(frame)
[17:39:35.333]                       master <- NULL
[17:39:35.333]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.333]                         !identical(envir, emptyenv())) {
[17:39:35.333]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.333]                           inherits = FALSE)) {
[17:39:35.333]                           master <- get("master", mode = "list", 
[17:39:35.333]                             envir = envir, inherits = FALSE)
[17:39:35.333]                           if (inherits(master, c("SOCKnode", 
[17:39:35.333]                             "SOCK0node"))) {
[17:39:35.333]                             sendCondition <<- function(cond) {
[17:39:35.333]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.333]                                 success = TRUE)
[17:39:35.333]                               parallel_sendData(master, data)
[17:39:35.333]                             }
[17:39:35.333]                             return(sendCondition)
[17:39:35.333]                           }
[17:39:35.333]                         }
[17:39:35.333]                         frame <- frame + 1L
[17:39:35.333]                         envir <- sys.frame(frame)
[17:39:35.333]                       }
[17:39:35.333]                     }
[17:39:35.333]                     sendCondition <<- function(cond) NULL
[17:39:35.333]                   }
[17:39:35.333]                 })
[17:39:35.333]                 withCallingHandlers({
[17:39:35.333]                   2
[17:39:35.333]                 }, immediateCondition = function(cond) {
[17:39:35.333]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.333]                   sendCondition(cond)
[17:39:35.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.333]                   {
[17:39:35.333]                     inherits <- base::inherits
[17:39:35.333]                     invokeRestart <- base::invokeRestart
[17:39:35.333]                     is.null <- base::is.null
[17:39:35.333]                     muffled <- FALSE
[17:39:35.333]                     if (inherits(cond, "message")) {
[17:39:35.333]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.333]                       if (muffled) 
[17:39:35.333]                         invokeRestart("muffleMessage")
[17:39:35.333]                     }
[17:39:35.333]                     else if (inherits(cond, "warning")) {
[17:39:35.333]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.333]                       if (muffled) 
[17:39:35.333]                         invokeRestart("muffleWarning")
[17:39:35.333]                     }
[17:39:35.333]                     else if (inherits(cond, "condition")) {
[17:39:35.333]                       if (!is.null(pattern)) {
[17:39:35.333]                         computeRestarts <- base::computeRestarts
[17:39:35.333]                         grepl <- base::grepl
[17:39:35.333]                         restarts <- computeRestarts(cond)
[17:39:35.333]                         for (restart in restarts) {
[17:39:35.333]                           name <- restart$name
[17:39:35.333]                           if (is.null(name)) 
[17:39:35.333]                             next
[17:39:35.333]                           if (!grepl(pattern, name)) 
[17:39:35.333]                             next
[17:39:35.333]                           invokeRestart(restart)
[17:39:35.333]                           muffled <- TRUE
[17:39:35.333]                           break
[17:39:35.333]                         }
[17:39:35.333]                       }
[17:39:35.333]                     }
[17:39:35.333]                     invisible(muffled)
[17:39:35.333]                   }
[17:39:35.333]                   muffleCondition(cond)
[17:39:35.333]                 })
[17:39:35.333]             }))
[17:39:35.333]             future::FutureResult(value = ...future.value$value, 
[17:39:35.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.333]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.333]                     ...future.globalenv.names))
[17:39:35.333]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.333]         }, condition = base::local({
[17:39:35.333]             c <- base::c
[17:39:35.333]             inherits <- base::inherits
[17:39:35.333]             invokeRestart <- base::invokeRestart
[17:39:35.333]             length <- base::length
[17:39:35.333]             list <- base::list
[17:39:35.333]             seq.int <- base::seq.int
[17:39:35.333]             signalCondition <- base::signalCondition
[17:39:35.333]             sys.calls <- base::sys.calls
[17:39:35.333]             `[[` <- base::`[[`
[17:39:35.333]             `+` <- base::`+`
[17:39:35.333]             `<<-` <- base::`<<-`
[17:39:35.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.333]                   3L)]
[17:39:35.333]             }
[17:39:35.333]             function(cond) {
[17:39:35.333]                 is_error <- inherits(cond, "error")
[17:39:35.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.333]                   NULL)
[17:39:35.333]                 if (is_error) {
[17:39:35.333]                   sessionInformation <- function() {
[17:39:35.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.333]                       search = base::search(), system = base::Sys.info())
[17:39:35.333]                   }
[17:39:35.333]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.333]                     cond$call), session = sessionInformation(), 
[17:39:35.333]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.333]                   signalCondition(cond)
[17:39:35.333]                 }
[17:39:35.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.333]                 "immediateCondition"))) {
[17:39:35.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.333]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.333]                   if (TRUE && !signal) {
[17:39:35.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.333]                     {
[17:39:35.333]                       inherits <- base::inherits
[17:39:35.333]                       invokeRestart <- base::invokeRestart
[17:39:35.333]                       is.null <- base::is.null
[17:39:35.333]                       muffled <- FALSE
[17:39:35.333]                       if (inherits(cond, "message")) {
[17:39:35.333]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.333]                         if (muffled) 
[17:39:35.333]                           invokeRestart("muffleMessage")
[17:39:35.333]                       }
[17:39:35.333]                       else if (inherits(cond, "warning")) {
[17:39:35.333]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.333]                         if (muffled) 
[17:39:35.333]                           invokeRestart("muffleWarning")
[17:39:35.333]                       }
[17:39:35.333]                       else if (inherits(cond, "condition")) {
[17:39:35.333]                         if (!is.null(pattern)) {
[17:39:35.333]                           computeRestarts <- base::computeRestarts
[17:39:35.333]                           grepl <- base::grepl
[17:39:35.333]                           restarts <- computeRestarts(cond)
[17:39:35.333]                           for (restart in restarts) {
[17:39:35.333]                             name <- restart$name
[17:39:35.333]                             if (is.null(name)) 
[17:39:35.333]                               next
[17:39:35.333]                             if (!grepl(pattern, name)) 
[17:39:35.333]                               next
[17:39:35.333]                             invokeRestart(restart)
[17:39:35.333]                             muffled <- TRUE
[17:39:35.333]                             break
[17:39:35.333]                           }
[17:39:35.333]                         }
[17:39:35.333]                       }
[17:39:35.333]                       invisible(muffled)
[17:39:35.333]                     }
[17:39:35.333]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.333]                   }
[17:39:35.333]                 }
[17:39:35.333]                 else {
[17:39:35.333]                   if (TRUE) {
[17:39:35.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.333]                     {
[17:39:35.333]                       inherits <- base::inherits
[17:39:35.333]                       invokeRestart <- base::invokeRestart
[17:39:35.333]                       is.null <- base::is.null
[17:39:35.333]                       muffled <- FALSE
[17:39:35.333]                       if (inherits(cond, "message")) {
[17:39:35.333]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.333]                         if (muffled) 
[17:39:35.333]                           invokeRestart("muffleMessage")
[17:39:35.333]                       }
[17:39:35.333]                       else if (inherits(cond, "warning")) {
[17:39:35.333]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.333]                         if (muffled) 
[17:39:35.333]                           invokeRestart("muffleWarning")
[17:39:35.333]                       }
[17:39:35.333]                       else if (inherits(cond, "condition")) {
[17:39:35.333]                         if (!is.null(pattern)) {
[17:39:35.333]                           computeRestarts <- base::computeRestarts
[17:39:35.333]                           grepl <- base::grepl
[17:39:35.333]                           restarts <- computeRestarts(cond)
[17:39:35.333]                           for (restart in restarts) {
[17:39:35.333]                             name <- restart$name
[17:39:35.333]                             if (is.null(name)) 
[17:39:35.333]                               next
[17:39:35.333]                             if (!grepl(pattern, name)) 
[17:39:35.333]                               next
[17:39:35.333]                             invokeRestart(restart)
[17:39:35.333]                             muffled <- TRUE
[17:39:35.333]                             break
[17:39:35.333]                           }
[17:39:35.333]                         }
[17:39:35.333]                       }
[17:39:35.333]                       invisible(muffled)
[17:39:35.333]                     }
[17:39:35.333]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.333]                   }
[17:39:35.333]                 }
[17:39:35.333]             }
[17:39:35.333]         }))
[17:39:35.333]     }, error = function(ex) {
[17:39:35.333]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.333]                 ...future.rng), started = ...future.startTime, 
[17:39:35.333]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.333]             version = "1.8"), class = "FutureResult")
[17:39:35.333]     }, finally = {
[17:39:35.333]         if (!identical(...future.workdir, getwd())) 
[17:39:35.333]             setwd(...future.workdir)
[17:39:35.333]         {
[17:39:35.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.333]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.333]             }
[17:39:35.333]             base::options(...future.oldOptions)
[17:39:35.333]             if (.Platform$OS.type == "windows") {
[17:39:35.333]                 old_names <- names(...future.oldEnvVars)
[17:39:35.333]                 envs <- base::Sys.getenv()
[17:39:35.333]                 names <- names(envs)
[17:39:35.333]                 common <- intersect(names, old_names)
[17:39:35.333]                 added <- setdiff(names, old_names)
[17:39:35.333]                 removed <- setdiff(old_names, names)
[17:39:35.333]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.333]                   envs[common]]
[17:39:35.333]                 NAMES <- toupper(changed)
[17:39:35.333]                 args <- list()
[17:39:35.333]                 for (kk in seq_along(NAMES)) {
[17:39:35.333]                   name <- changed[[kk]]
[17:39:35.333]                   NAME <- NAMES[[kk]]
[17:39:35.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.333]                     next
[17:39:35.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.333]                 }
[17:39:35.333]                 NAMES <- toupper(added)
[17:39:35.333]                 for (kk in seq_along(NAMES)) {
[17:39:35.333]                   name <- added[[kk]]
[17:39:35.333]                   NAME <- NAMES[[kk]]
[17:39:35.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.333]                     next
[17:39:35.333]                   args[[name]] <- ""
[17:39:35.333]                 }
[17:39:35.333]                 NAMES <- toupper(removed)
[17:39:35.333]                 for (kk in seq_along(NAMES)) {
[17:39:35.333]                   name <- removed[[kk]]
[17:39:35.333]                   NAME <- NAMES[[kk]]
[17:39:35.333]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.333]                     next
[17:39:35.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.333]                 }
[17:39:35.333]                 if (length(args) > 0) 
[17:39:35.333]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.333]             }
[17:39:35.333]             else {
[17:39:35.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.333]             }
[17:39:35.333]             {
[17:39:35.333]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.333]                   0L) {
[17:39:35.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.333]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.333]                   base::options(opts)
[17:39:35.333]                 }
[17:39:35.333]                 {
[17:39:35.333]                   {
[17:39:35.333]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.333]                     NULL
[17:39:35.333]                   }
[17:39:35.333]                   options(future.plan = NULL)
[17:39:35.333]                   if (is.na(NA_character_)) 
[17:39:35.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.333]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.333]                     .init = FALSE)
[17:39:35.333]                 }
[17:39:35.333]             }
[17:39:35.333]         }
[17:39:35.333]     })
[17:39:35.333]     if (TRUE) {
[17:39:35.333]         base::sink(type = "output", split = FALSE)
[17:39:35.333]         if (TRUE) {
[17:39:35.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.333]         }
[17:39:35.333]         else {
[17:39:35.333]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.333]         }
[17:39:35.333]         base::close(...future.stdout)
[17:39:35.333]         ...future.stdout <- NULL
[17:39:35.333]     }
[17:39:35.333]     ...future.result$conditions <- ...future.conditions
[17:39:35.333]     ...future.result$finished <- base::Sys.time()
[17:39:35.333]     ...future.result
[17:39:35.333] }
[17:39:35.336] MultisessionFuture started
[17:39:35.336] - Launch lazy future ... done
[17:39:35.336] run() for ‘MultisessionFuture’ ... done
[17:39:35.337] getGlobalsAndPackages() ...
[17:39:35.337] Searching for globals...
[17:39:35.337] 
[17:39:35.337] Searching for globals ... DONE
[17:39:35.337] - globals: [0] <none>
[17:39:35.337] getGlobalsAndPackages() ... DONE
[17:39:35.337] run() for ‘Future’ ...
[17:39:35.338] - state: ‘created’
[17:39:35.338] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.352] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.352]   - Field: ‘node’
[17:39:35.352]   - Field: ‘label’
[17:39:35.352]   - Field: ‘local’
[17:39:35.352]   - Field: ‘owner’
[17:39:35.353]   - Field: ‘envir’
[17:39:35.353]   - Field: ‘workers’
[17:39:35.353]   - Field: ‘packages’
[17:39:35.353]   - Field: ‘gc’
[17:39:35.353]   - Field: ‘conditions’
[17:39:35.353]   - Field: ‘persistent’
[17:39:35.353]   - Field: ‘expr’
[17:39:35.353]   - Field: ‘uuid’
[17:39:35.353]   - Field: ‘seed’
[17:39:35.353]   - Field: ‘version’
[17:39:35.353]   - Field: ‘result’
[17:39:35.354]   - Field: ‘asynchronous’
[17:39:35.354]   - Field: ‘calls’
[17:39:35.354]   - Field: ‘globals’
[17:39:35.354]   - Field: ‘stdout’
[17:39:35.354]   - Field: ‘earlySignal’
[17:39:35.354]   - Field: ‘lazy’
[17:39:35.354]   - Field: ‘state’
[17:39:35.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.354] - Launch lazy future ...
[17:39:35.354] Packages needed by the future expression (n = 0): <none>
[17:39:35.355] Packages needed by future strategies (n = 0): <none>
[17:39:35.355] {
[17:39:35.355]     {
[17:39:35.355]         {
[17:39:35.355]             ...future.startTime <- base::Sys.time()
[17:39:35.355]             {
[17:39:35.355]                 {
[17:39:35.355]                   {
[17:39:35.355]                     {
[17:39:35.355]                       base::local({
[17:39:35.355]                         has_future <- base::requireNamespace("future", 
[17:39:35.355]                           quietly = TRUE)
[17:39:35.355]                         if (has_future) {
[17:39:35.355]                           ns <- base::getNamespace("future")
[17:39:35.355]                           version <- ns[[".package"]][["version"]]
[17:39:35.355]                           if (is.null(version)) 
[17:39:35.355]                             version <- utils::packageVersion("future")
[17:39:35.355]                         }
[17:39:35.355]                         else {
[17:39:35.355]                           version <- NULL
[17:39:35.355]                         }
[17:39:35.355]                         if (!has_future || version < "1.8.0") {
[17:39:35.355]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.355]                             "", base::R.version$version.string), 
[17:39:35.355]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.355]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.355]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.355]                               "release", "version")], collapse = " "), 
[17:39:35.355]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.355]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.355]                             info)
[17:39:35.355]                           info <- base::paste(info, collapse = "; ")
[17:39:35.355]                           if (!has_future) {
[17:39:35.355]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.355]                               info)
[17:39:35.355]                           }
[17:39:35.355]                           else {
[17:39:35.355]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.355]                               info, version)
[17:39:35.355]                           }
[17:39:35.355]                           base::stop(msg)
[17:39:35.355]                         }
[17:39:35.355]                       })
[17:39:35.355]                     }
[17:39:35.355]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.355]                     base::options(mc.cores = 1L)
[17:39:35.355]                   }
[17:39:35.355]                   ...future.strategy.old <- future::plan("list")
[17:39:35.355]                   options(future.plan = NULL)
[17:39:35.355]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.355]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.355]                 }
[17:39:35.355]                 ...future.workdir <- getwd()
[17:39:35.355]             }
[17:39:35.355]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.355]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.355]         }
[17:39:35.355]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.355]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.355]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.355]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.355]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.355]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.355]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.355]             base::names(...future.oldOptions))
[17:39:35.355]     }
[17:39:35.355]     if (FALSE) {
[17:39:35.355]     }
[17:39:35.355]     else {
[17:39:35.355]         if (TRUE) {
[17:39:35.355]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.355]                 open = "w")
[17:39:35.355]         }
[17:39:35.355]         else {
[17:39:35.355]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.355]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.355]         }
[17:39:35.355]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.355]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.355]             base::sink(type = "output", split = FALSE)
[17:39:35.355]             base::close(...future.stdout)
[17:39:35.355]         }, add = TRUE)
[17:39:35.355]     }
[17:39:35.355]     ...future.frame <- base::sys.nframe()
[17:39:35.355]     ...future.conditions <- base::list()
[17:39:35.355]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.355]     if (FALSE) {
[17:39:35.355]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.355]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.355]     }
[17:39:35.355]     ...future.result <- base::tryCatch({
[17:39:35.355]         base::withCallingHandlers({
[17:39:35.355]             ...future.value <- base::withVisible(base::local({
[17:39:35.355]                 ...future.makeSendCondition <- base::local({
[17:39:35.355]                   sendCondition <- NULL
[17:39:35.355]                   function(frame = 1L) {
[17:39:35.355]                     if (is.function(sendCondition)) 
[17:39:35.355]                       return(sendCondition)
[17:39:35.355]                     ns <- getNamespace("parallel")
[17:39:35.355]                     if (exists("sendData", mode = "function", 
[17:39:35.355]                       envir = ns)) {
[17:39:35.355]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.355]                         envir = ns)
[17:39:35.355]                       envir <- sys.frame(frame)
[17:39:35.355]                       master <- NULL
[17:39:35.355]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.355]                         !identical(envir, emptyenv())) {
[17:39:35.355]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.355]                           inherits = FALSE)) {
[17:39:35.355]                           master <- get("master", mode = "list", 
[17:39:35.355]                             envir = envir, inherits = FALSE)
[17:39:35.355]                           if (inherits(master, c("SOCKnode", 
[17:39:35.355]                             "SOCK0node"))) {
[17:39:35.355]                             sendCondition <<- function(cond) {
[17:39:35.355]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.355]                                 success = TRUE)
[17:39:35.355]                               parallel_sendData(master, data)
[17:39:35.355]                             }
[17:39:35.355]                             return(sendCondition)
[17:39:35.355]                           }
[17:39:35.355]                         }
[17:39:35.355]                         frame <- frame + 1L
[17:39:35.355]                         envir <- sys.frame(frame)
[17:39:35.355]                       }
[17:39:35.355]                     }
[17:39:35.355]                     sendCondition <<- function(cond) NULL
[17:39:35.355]                   }
[17:39:35.355]                 })
[17:39:35.355]                 withCallingHandlers({
[17:39:35.355]                   NULL
[17:39:35.355]                 }, immediateCondition = function(cond) {
[17:39:35.355]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.355]                   sendCondition(cond)
[17:39:35.355]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.355]                   {
[17:39:35.355]                     inherits <- base::inherits
[17:39:35.355]                     invokeRestart <- base::invokeRestart
[17:39:35.355]                     is.null <- base::is.null
[17:39:35.355]                     muffled <- FALSE
[17:39:35.355]                     if (inherits(cond, "message")) {
[17:39:35.355]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.355]                       if (muffled) 
[17:39:35.355]                         invokeRestart("muffleMessage")
[17:39:35.355]                     }
[17:39:35.355]                     else if (inherits(cond, "warning")) {
[17:39:35.355]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.355]                       if (muffled) 
[17:39:35.355]                         invokeRestart("muffleWarning")
[17:39:35.355]                     }
[17:39:35.355]                     else if (inherits(cond, "condition")) {
[17:39:35.355]                       if (!is.null(pattern)) {
[17:39:35.355]                         computeRestarts <- base::computeRestarts
[17:39:35.355]                         grepl <- base::grepl
[17:39:35.355]                         restarts <- computeRestarts(cond)
[17:39:35.355]                         for (restart in restarts) {
[17:39:35.355]                           name <- restart$name
[17:39:35.355]                           if (is.null(name)) 
[17:39:35.355]                             next
[17:39:35.355]                           if (!grepl(pattern, name)) 
[17:39:35.355]                             next
[17:39:35.355]                           invokeRestart(restart)
[17:39:35.355]                           muffled <- TRUE
[17:39:35.355]                           break
[17:39:35.355]                         }
[17:39:35.355]                       }
[17:39:35.355]                     }
[17:39:35.355]                     invisible(muffled)
[17:39:35.355]                   }
[17:39:35.355]                   muffleCondition(cond)
[17:39:35.355]                 })
[17:39:35.355]             }))
[17:39:35.355]             future::FutureResult(value = ...future.value$value, 
[17:39:35.355]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.355]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.355]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.355]                     ...future.globalenv.names))
[17:39:35.355]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.355]         }, condition = base::local({
[17:39:35.355]             c <- base::c
[17:39:35.355]             inherits <- base::inherits
[17:39:35.355]             invokeRestart <- base::invokeRestart
[17:39:35.355]             length <- base::length
[17:39:35.355]             list <- base::list
[17:39:35.355]             seq.int <- base::seq.int
[17:39:35.355]             signalCondition <- base::signalCondition
[17:39:35.355]             sys.calls <- base::sys.calls
[17:39:35.355]             `[[` <- base::`[[`
[17:39:35.355]             `+` <- base::`+`
[17:39:35.355]             `<<-` <- base::`<<-`
[17:39:35.355]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.355]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.355]                   3L)]
[17:39:35.355]             }
[17:39:35.355]             function(cond) {
[17:39:35.355]                 is_error <- inherits(cond, "error")
[17:39:35.355]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.355]                   NULL)
[17:39:35.355]                 if (is_error) {
[17:39:35.355]                   sessionInformation <- function() {
[17:39:35.355]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.355]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.355]                       search = base::search(), system = base::Sys.info())
[17:39:35.355]                   }
[17:39:35.355]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.355]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.355]                     cond$call), session = sessionInformation(), 
[17:39:35.355]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.355]                   signalCondition(cond)
[17:39:35.355]                 }
[17:39:35.355]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.355]                 "immediateCondition"))) {
[17:39:35.355]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.355]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.355]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.355]                   if (TRUE && !signal) {
[17:39:35.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.355]                     {
[17:39:35.355]                       inherits <- base::inherits
[17:39:35.355]                       invokeRestart <- base::invokeRestart
[17:39:35.355]                       is.null <- base::is.null
[17:39:35.355]                       muffled <- FALSE
[17:39:35.355]                       if (inherits(cond, "message")) {
[17:39:35.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.355]                         if (muffled) 
[17:39:35.355]                           invokeRestart("muffleMessage")
[17:39:35.355]                       }
[17:39:35.355]                       else if (inherits(cond, "warning")) {
[17:39:35.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.355]                         if (muffled) 
[17:39:35.355]                           invokeRestart("muffleWarning")
[17:39:35.355]                       }
[17:39:35.355]                       else if (inherits(cond, "condition")) {
[17:39:35.355]                         if (!is.null(pattern)) {
[17:39:35.355]                           computeRestarts <- base::computeRestarts
[17:39:35.355]                           grepl <- base::grepl
[17:39:35.355]                           restarts <- computeRestarts(cond)
[17:39:35.355]                           for (restart in restarts) {
[17:39:35.355]                             name <- restart$name
[17:39:35.355]                             if (is.null(name)) 
[17:39:35.355]                               next
[17:39:35.355]                             if (!grepl(pattern, name)) 
[17:39:35.355]                               next
[17:39:35.355]                             invokeRestart(restart)
[17:39:35.355]                             muffled <- TRUE
[17:39:35.355]                             break
[17:39:35.355]                           }
[17:39:35.355]                         }
[17:39:35.355]                       }
[17:39:35.355]                       invisible(muffled)
[17:39:35.355]                     }
[17:39:35.355]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.355]                   }
[17:39:35.355]                 }
[17:39:35.355]                 else {
[17:39:35.355]                   if (TRUE) {
[17:39:35.355]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.355]                     {
[17:39:35.355]                       inherits <- base::inherits
[17:39:35.355]                       invokeRestart <- base::invokeRestart
[17:39:35.355]                       is.null <- base::is.null
[17:39:35.355]                       muffled <- FALSE
[17:39:35.355]                       if (inherits(cond, "message")) {
[17:39:35.355]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.355]                         if (muffled) 
[17:39:35.355]                           invokeRestart("muffleMessage")
[17:39:35.355]                       }
[17:39:35.355]                       else if (inherits(cond, "warning")) {
[17:39:35.355]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.355]                         if (muffled) 
[17:39:35.355]                           invokeRestart("muffleWarning")
[17:39:35.355]                       }
[17:39:35.355]                       else if (inherits(cond, "condition")) {
[17:39:35.355]                         if (!is.null(pattern)) {
[17:39:35.355]                           computeRestarts <- base::computeRestarts
[17:39:35.355]                           grepl <- base::grepl
[17:39:35.355]                           restarts <- computeRestarts(cond)
[17:39:35.355]                           for (restart in restarts) {
[17:39:35.355]                             name <- restart$name
[17:39:35.355]                             if (is.null(name)) 
[17:39:35.355]                               next
[17:39:35.355]                             if (!grepl(pattern, name)) 
[17:39:35.355]                               next
[17:39:35.355]                             invokeRestart(restart)
[17:39:35.355]                             muffled <- TRUE
[17:39:35.355]                             break
[17:39:35.355]                           }
[17:39:35.355]                         }
[17:39:35.355]                       }
[17:39:35.355]                       invisible(muffled)
[17:39:35.355]                     }
[17:39:35.355]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.355]                   }
[17:39:35.355]                 }
[17:39:35.355]             }
[17:39:35.355]         }))
[17:39:35.355]     }, error = function(ex) {
[17:39:35.355]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.355]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.355]                 ...future.rng), started = ...future.startTime, 
[17:39:35.355]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.355]             version = "1.8"), class = "FutureResult")
[17:39:35.355]     }, finally = {
[17:39:35.355]         if (!identical(...future.workdir, getwd())) 
[17:39:35.355]             setwd(...future.workdir)
[17:39:35.355]         {
[17:39:35.355]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.355]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.355]             }
[17:39:35.355]             base::options(...future.oldOptions)
[17:39:35.355]             if (.Platform$OS.type == "windows") {
[17:39:35.355]                 old_names <- names(...future.oldEnvVars)
[17:39:35.355]                 envs <- base::Sys.getenv()
[17:39:35.355]                 names <- names(envs)
[17:39:35.355]                 common <- intersect(names, old_names)
[17:39:35.355]                 added <- setdiff(names, old_names)
[17:39:35.355]                 removed <- setdiff(old_names, names)
[17:39:35.355]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.355]                   envs[common]]
[17:39:35.355]                 NAMES <- toupper(changed)
[17:39:35.355]                 args <- list()
[17:39:35.355]                 for (kk in seq_along(NAMES)) {
[17:39:35.355]                   name <- changed[[kk]]
[17:39:35.355]                   NAME <- NAMES[[kk]]
[17:39:35.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.355]                     next
[17:39:35.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.355]                 }
[17:39:35.355]                 NAMES <- toupper(added)
[17:39:35.355]                 for (kk in seq_along(NAMES)) {
[17:39:35.355]                   name <- added[[kk]]
[17:39:35.355]                   NAME <- NAMES[[kk]]
[17:39:35.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.355]                     next
[17:39:35.355]                   args[[name]] <- ""
[17:39:35.355]                 }
[17:39:35.355]                 NAMES <- toupper(removed)
[17:39:35.355]                 for (kk in seq_along(NAMES)) {
[17:39:35.355]                   name <- removed[[kk]]
[17:39:35.355]                   NAME <- NAMES[[kk]]
[17:39:35.355]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.355]                     next
[17:39:35.355]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.355]                 }
[17:39:35.355]                 if (length(args) > 0) 
[17:39:35.355]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.355]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.355]             }
[17:39:35.355]             else {
[17:39:35.355]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.355]             }
[17:39:35.355]             {
[17:39:35.355]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.355]                   0L) {
[17:39:35.355]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.355]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.355]                   base::options(opts)
[17:39:35.355]                 }
[17:39:35.355]                 {
[17:39:35.355]                   {
[17:39:35.355]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.355]                     NULL
[17:39:35.355]                   }
[17:39:35.355]                   options(future.plan = NULL)
[17:39:35.355]                   if (is.na(NA_character_)) 
[17:39:35.355]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.355]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.355]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.355]                     .init = FALSE)
[17:39:35.355]                 }
[17:39:35.355]             }
[17:39:35.355]         }
[17:39:35.355]     })
[17:39:35.355]     if (TRUE) {
[17:39:35.355]         base::sink(type = "output", split = FALSE)
[17:39:35.355]         if (TRUE) {
[17:39:35.355]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.355]         }
[17:39:35.355]         else {
[17:39:35.355]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.355]         }
[17:39:35.355]         base::close(...future.stdout)
[17:39:35.355]         ...future.stdout <- NULL
[17:39:35.355]     }
[17:39:35.355]     ...future.result$conditions <- ...future.conditions
[17:39:35.355]     ...future.result$finished <- base::Sys.time()
[17:39:35.355]     ...future.result
[17:39:35.355] }
[17:39:35.358] MultisessionFuture started
[17:39:35.358] - Launch lazy future ... done
[17:39:35.358] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf08774c0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0019288> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf08774c0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0019288> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:35.364] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.365] - Validating connection of MultisessionFuture
[17:39:35.365] - received message: FutureResult
[17:39:35.365] - Received FutureResult
[17:39:35.365] - Erased future from FutureRegistry
[17:39:35.365] result() for ClusterFuture ...
[17:39:35.365] - result already collected: FutureResult
[17:39:35.365] result() for ClusterFuture ... done
[17:39:35.365] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.366] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.366] - Validating connection of MultisessionFuture
[17:39:35.366] - received message: FutureResult
[17:39:35.366] - Received FutureResult
[17:39:35.366] - Erased future from FutureRegistry
[17:39:35.366] result() for ClusterFuture ...
[17:39:35.366] - result already collected: FutureResult
[17:39:35.367] result() for ClusterFuture ... done
[17:39:35.367] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:35.368] resolve() on list ...
[17:39:35.368]  recursive: 0
[17:39:35.368]  length: 6
[17:39:35.368]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:35.369] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.369] - nx: 6
[17:39:35.369] - relay: TRUE
[17:39:35.369] - stdout: TRUE
[17:39:35.369] - signal: TRUE
[17:39:35.369] - resignal: FALSE
[17:39:35.369] - force: TRUE
[17:39:35.369] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.369] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.369]  - until=2
[17:39:35.369]  - relaying element #2
[17:39:35.369] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.370] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.370] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.370]  length: 5 (resolved future 1)
[17:39:35.370] Future #2
[17:39:35.370] result() for ClusterFuture ...
[17:39:35.370] - result already collected: FutureResult
[17:39:35.370] result() for ClusterFuture ... done
[17:39:35.370] result() for ClusterFuture ...
[17:39:35.370] - result already collected: FutureResult
[17:39:35.370] result() for ClusterFuture ... done
[17:39:35.370] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:35.371] - nx: 6
[17:39:35.371] - relay: TRUE
[17:39:35.371] - stdout: TRUE
[17:39:35.371] - signal: TRUE
[17:39:35.371] - resignal: FALSE
[17:39:35.371] - force: TRUE
[17:39:35.371] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.371] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.371]  - until=2
[17:39:35.371]  - relaying element #2
[17:39:35.371] result() for ClusterFuture ...
[17:39:35.372] - result already collected: FutureResult
[17:39:35.372] result() for ClusterFuture ... done
[17:39:35.372] result() for ClusterFuture ...
[17:39:35.372] - result already collected: FutureResult
[17:39:35.372] result() for ClusterFuture ... done
[17:39:35.372] result() for ClusterFuture ...
[17:39:35.372] - result already collected: FutureResult
[17:39:35.372] result() for ClusterFuture ... done
[17:39:35.372] result() for ClusterFuture ...
[17:39:35.372] - result already collected: FutureResult
[17:39:35.372] result() for ClusterFuture ... done
[17:39:35.372] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.373] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.373] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:35.373]  length: 4 (resolved future 2)
[17:39:35.373] Future #3
[17:39:35.373] result() for ClusterFuture ...
[17:39:35.373] - result already collected: FutureResult
[17:39:35.373] result() for ClusterFuture ... done
[17:39:35.373] result() for ClusterFuture ...
[17:39:35.373] - result already collected: FutureResult
[17:39:35.373] result() for ClusterFuture ... done
[17:39:35.374] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:35.374] - nx: 6
[17:39:35.374] - relay: TRUE
[17:39:35.374] - stdout: TRUE
[17:39:35.374] - signal: TRUE
[17:39:35.374] - resignal: FALSE
[17:39:35.374] - force: TRUE
[17:39:35.374] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.374] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.374]  - until=3
[17:39:35.374]  - relaying element #3
[17:39:35.374] result() for ClusterFuture ...
[17:39:35.375] - result already collected: FutureResult
[17:39:35.375] result() for ClusterFuture ... done
[17:39:35.375] result() for ClusterFuture ...
[17:39:35.375] - result already collected: FutureResult
[17:39:35.375] result() for ClusterFuture ... done
[17:39:35.375] result() for ClusterFuture ...
[17:39:35.375] - result already collected: FutureResult
[17:39:35.375] result() for ClusterFuture ... done
[17:39:35.375] result() for ClusterFuture ...
[17:39:35.375] - result already collected: FutureResult
[17:39:35.375] result() for ClusterFuture ... done
[17:39:35.375] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.376] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.376] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:35.376]  length: 3 (resolved future 3)
[17:39:35.376] signalConditionsASAP(NULL, pos=4) ...
[17:39:35.376] - nx: 6
[17:39:35.376] - relay: TRUE
[17:39:35.376] - stdout: TRUE
[17:39:35.376] - signal: TRUE
[17:39:35.376] - resignal: FALSE
[17:39:35.376] - force: TRUE
[17:39:35.376] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.376] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.377]  - until=5
[17:39:35.377]  - relaying element #5
[17:39:35.377] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.377] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.377] signalConditionsASAP(NULL, pos=4) ... done
[17:39:35.377]  length: 2 (resolved future 4)
[17:39:35.377] signalConditionsASAP(NULL, pos=5) ...
[17:39:35.377] - nx: 6
[17:39:35.377] - relay: TRUE
[17:39:35.377] - stdout: TRUE
[17:39:35.377] - signal: TRUE
[17:39:35.377] - resignal: FALSE
[17:39:35.378] - force: TRUE
[17:39:35.378] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.378] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.378]  - until=6
[17:39:35.378]  - relaying element #6
[17:39:35.378] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.378] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.378] signalConditionsASAP(NULL, pos=5) ... done
[17:39:35.378]  length: 1 (resolved future 5)
[17:39:35.378] signalConditionsASAP(numeric, pos=6) ...
[17:39:35.378] - nx: 6
[17:39:35.378] - relay: TRUE
[17:39:35.379] - stdout: TRUE
[17:39:35.379] - signal: TRUE
[17:39:35.379] - resignal: FALSE
[17:39:35.379] - force: TRUE
[17:39:35.379] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.379] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.379]  - until=6
[17:39:35.379] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.379] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.379] signalConditionsASAP(numeric, pos=6) ... done
[17:39:35.379]  length: 0 (resolved future 6)
[17:39:35.379] Relaying remaining futures
[17:39:35.380] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.380] - nx: 6
[17:39:35.380] - relay: TRUE
[17:39:35.380] - stdout: TRUE
[17:39:35.380] - signal: TRUE
[17:39:35.380] - resignal: FALSE
[17:39:35.380] - force: TRUE
[17:39:35.380] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.380] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:35.380] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.380] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.380] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.381] resolve() on list ... DONE
[17:39:35.381] result() for ClusterFuture ...
[17:39:35.381] - result already collected: FutureResult
[17:39:35.381] result() for ClusterFuture ... done
[17:39:35.381] result() for ClusterFuture ...
[17:39:35.381] - result already collected: FutureResult
[17:39:35.381] result() for ClusterFuture ... done
[17:39:35.381] result() for ClusterFuture ...
[17:39:35.381] - result already collected: FutureResult
[17:39:35.381] result() for ClusterFuture ... done
[17:39:35.381] result() for ClusterFuture ...
[17:39:35.381] - result already collected: FutureResult
[17:39:35.382] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:35.385] getGlobalsAndPackages() ...
[17:39:35.385] Searching for globals...
[17:39:35.385] 
[17:39:35.385] Searching for globals ... DONE
[17:39:35.385] - globals: [0] <none>
[17:39:35.385] getGlobalsAndPackages() ... DONE
[17:39:35.386] run() for ‘Future’ ...
[17:39:35.386] - state: ‘created’
[17:39:35.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.400]   - Field: ‘node’
[17:39:35.400]   - Field: ‘label’
[17:39:35.400]   - Field: ‘local’
[17:39:35.400]   - Field: ‘owner’
[17:39:35.400]   - Field: ‘envir’
[17:39:35.400]   - Field: ‘workers’
[17:39:35.400]   - Field: ‘packages’
[17:39:35.401]   - Field: ‘gc’
[17:39:35.401]   - Field: ‘conditions’
[17:39:35.401]   - Field: ‘persistent’
[17:39:35.401]   - Field: ‘expr’
[17:39:35.401]   - Field: ‘uuid’
[17:39:35.401]   - Field: ‘seed’
[17:39:35.401]   - Field: ‘version’
[17:39:35.401]   - Field: ‘result’
[17:39:35.401]   - Field: ‘asynchronous’
[17:39:35.401]   - Field: ‘calls’
[17:39:35.401]   - Field: ‘globals’
[17:39:35.401]   - Field: ‘stdout’
[17:39:35.402]   - Field: ‘earlySignal’
[17:39:35.402]   - Field: ‘lazy’
[17:39:35.402]   - Field: ‘state’
[17:39:35.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.402] - Launch lazy future ...
[17:39:35.402] Packages needed by the future expression (n = 0): <none>
[17:39:35.402] Packages needed by future strategies (n = 0): <none>
[17:39:35.403] {
[17:39:35.403]     {
[17:39:35.403]         {
[17:39:35.403]             ...future.startTime <- base::Sys.time()
[17:39:35.403]             {
[17:39:35.403]                 {
[17:39:35.403]                   {
[17:39:35.403]                     {
[17:39:35.403]                       base::local({
[17:39:35.403]                         has_future <- base::requireNamespace("future", 
[17:39:35.403]                           quietly = TRUE)
[17:39:35.403]                         if (has_future) {
[17:39:35.403]                           ns <- base::getNamespace("future")
[17:39:35.403]                           version <- ns[[".package"]][["version"]]
[17:39:35.403]                           if (is.null(version)) 
[17:39:35.403]                             version <- utils::packageVersion("future")
[17:39:35.403]                         }
[17:39:35.403]                         else {
[17:39:35.403]                           version <- NULL
[17:39:35.403]                         }
[17:39:35.403]                         if (!has_future || version < "1.8.0") {
[17:39:35.403]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.403]                             "", base::R.version$version.string), 
[17:39:35.403]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.403]                               "release", "version")], collapse = " "), 
[17:39:35.403]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.403]                             info)
[17:39:35.403]                           info <- base::paste(info, collapse = "; ")
[17:39:35.403]                           if (!has_future) {
[17:39:35.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.403]                               info)
[17:39:35.403]                           }
[17:39:35.403]                           else {
[17:39:35.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.403]                               info, version)
[17:39:35.403]                           }
[17:39:35.403]                           base::stop(msg)
[17:39:35.403]                         }
[17:39:35.403]                       })
[17:39:35.403]                     }
[17:39:35.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.403]                     base::options(mc.cores = 1L)
[17:39:35.403]                   }
[17:39:35.403]                   ...future.strategy.old <- future::plan("list")
[17:39:35.403]                   options(future.plan = NULL)
[17:39:35.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.403]                 }
[17:39:35.403]                 ...future.workdir <- getwd()
[17:39:35.403]             }
[17:39:35.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.403]         }
[17:39:35.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.403]             base::names(...future.oldOptions))
[17:39:35.403]     }
[17:39:35.403]     if (FALSE) {
[17:39:35.403]     }
[17:39:35.403]     else {
[17:39:35.403]         if (TRUE) {
[17:39:35.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.403]                 open = "w")
[17:39:35.403]         }
[17:39:35.403]         else {
[17:39:35.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.403]         }
[17:39:35.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.403]             base::sink(type = "output", split = FALSE)
[17:39:35.403]             base::close(...future.stdout)
[17:39:35.403]         }, add = TRUE)
[17:39:35.403]     }
[17:39:35.403]     ...future.frame <- base::sys.nframe()
[17:39:35.403]     ...future.conditions <- base::list()
[17:39:35.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.403]     if (FALSE) {
[17:39:35.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.403]     }
[17:39:35.403]     ...future.result <- base::tryCatch({
[17:39:35.403]         base::withCallingHandlers({
[17:39:35.403]             ...future.value <- base::withVisible(base::local({
[17:39:35.403]                 ...future.makeSendCondition <- base::local({
[17:39:35.403]                   sendCondition <- NULL
[17:39:35.403]                   function(frame = 1L) {
[17:39:35.403]                     if (is.function(sendCondition)) 
[17:39:35.403]                       return(sendCondition)
[17:39:35.403]                     ns <- getNamespace("parallel")
[17:39:35.403]                     if (exists("sendData", mode = "function", 
[17:39:35.403]                       envir = ns)) {
[17:39:35.403]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.403]                         envir = ns)
[17:39:35.403]                       envir <- sys.frame(frame)
[17:39:35.403]                       master <- NULL
[17:39:35.403]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.403]                         !identical(envir, emptyenv())) {
[17:39:35.403]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.403]                           inherits = FALSE)) {
[17:39:35.403]                           master <- get("master", mode = "list", 
[17:39:35.403]                             envir = envir, inherits = FALSE)
[17:39:35.403]                           if (inherits(master, c("SOCKnode", 
[17:39:35.403]                             "SOCK0node"))) {
[17:39:35.403]                             sendCondition <<- function(cond) {
[17:39:35.403]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.403]                                 success = TRUE)
[17:39:35.403]                               parallel_sendData(master, data)
[17:39:35.403]                             }
[17:39:35.403]                             return(sendCondition)
[17:39:35.403]                           }
[17:39:35.403]                         }
[17:39:35.403]                         frame <- frame + 1L
[17:39:35.403]                         envir <- sys.frame(frame)
[17:39:35.403]                       }
[17:39:35.403]                     }
[17:39:35.403]                     sendCondition <<- function(cond) NULL
[17:39:35.403]                   }
[17:39:35.403]                 })
[17:39:35.403]                 withCallingHandlers({
[17:39:35.403]                   2
[17:39:35.403]                 }, immediateCondition = function(cond) {
[17:39:35.403]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.403]                   sendCondition(cond)
[17:39:35.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.403]                   {
[17:39:35.403]                     inherits <- base::inherits
[17:39:35.403]                     invokeRestart <- base::invokeRestart
[17:39:35.403]                     is.null <- base::is.null
[17:39:35.403]                     muffled <- FALSE
[17:39:35.403]                     if (inherits(cond, "message")) {
[17:39:35.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.403]                       if (muffled) 
[17:39:35.403]                         invokeRestart("muffleMessage")
[17:39:35.403]                     }
[17:39:35.403]                     else if (inherits(cond, "warning")) {
[17:39:35.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.403]                       if (muffled) 
[17:39:35.403]                         invokeRestart("muffleWarning")
[17:39:35.403]                     }
[17:39:35.403]                     else if (inherits(cond, "condition")) {
[17:39:35.403]                       if (!is.null(pattern)) {
[17:39:35.403]                         computeRestarts <- base::computeRestarts
[17:39:35.403]                         grepl <- base::grepl
[17:39:35.403]                         restarts <- computeRestarts(cond)
[17:39:35.403]                         for (restart in restarts) {
[17:39:35.403]                           name <- restart$name
[17:39:35.403]                           if (is.null(name)) 
[17:39:35.403]                             next
[17:39:35.403]                           if (!grepl(pattern, name)) 
[17:39:35.403]                             next
[17:39:35.403]                           invokeRestart(restart)
[17:39:35.403]                           muffled <- TRUE
[17:39:35.403]                           break
[17:39:35.403]                         }
[17:39:35.403]                       }
[17:39:35.403]                     }
[17:39:35.403]                     invisible(muffled)
[17:39:35.403]                   }
[17:39:35.403]                   muffleCondition(cond)
[17:39:35.403]                 })
[17:39:35.403]             }))
[17:39:35.403]             future::FutureResult(value = ...future.value$value, 
[17:39:35.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.403]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.403]                     ...future.globalenv.names))
[17:39:35.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.403]         }, condition = base::local({
[17:39:35.403]             c <- base::c
[17:39:35.403]             inherits <- base::inherits
[17:39:35.403]             invokeRestart <- base::invokeRestart
[17:39:35.403]             length <- base::length
[17:39:35.403]             list <- base::list
[17:39:35.403]             seq.int <- base::seq.int
[17:39:35.403]             signalCondition <- base::signalCondition
[17:39:35.403]             sys.calls <- base::sys.calls
[17:39:35.403]             `[[` <- base::`[[`
[17:39:35.403]             `+` <- base::`+`
[17:39:35.403]             `<<-` <- base::`<<-`
[17:39:35.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.403]                   3L)]
[17:39:35.403]             }
[17:39:35.403]             function(cond) {
[17:39:35.403]                 is_error <- inherits(cond, "error")
[17:39:35.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.403]                   NULL)
[17:39:35.403]                 if (is_error) {
[17:39:35.403]                   sessionInformation <- function() {
[17:39:35.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.403]                       search = base::search(), system = base::Sys.info())
[17:39:35.403]                   }
[17:39:35.403]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.403]                     cond$call), session = sessionInformation(), 
[17:39:35.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.403]                   signalCondition(cond)
[17:39:35.403]                 }
[17:39:35.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.403]                 "immediateCondition"))) {
[17:39:35.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.403]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.403]                   if (TRUE && !signal) {
[17:39:35.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.403]                     {
[17:39:35.403]                       inherits <- base::inherits
[17:39:35.403]                       invokeRestart <- base::invokeRestart
[17:39:35.403]                       is.null <- base::is.null
[17:39:35.403]                       muffled <- FALSE
[17:39:35.403]                       if (inherits(cond, "message")) {
[17:39:35.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.403]                         if (muffled) 
[17:39:35.403]                           invokeRestart("muffleMessage")
[17:39:35.403]                       }
[17:39:35.403]                       else if (inherits(cond, "warning")) {
[17:39:35.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.403]                         if (muffled) 
[17:39:35.403]                           invokeRestart("muffleWarning")
[17:39:35.403]                       }
[17:39:35.403]                       else if (inherits(cond, "condition")) {
[17:39:35.403]                         if (!is.null(pattern)) {
[17:39:35.403]                           computeRestarts <- base::computeRestarts
[17:39:35.403]                           grepl <- base::grepl
[17:39:35.403]                           restarts <- computeRestarts(cond)
[17:39:35.403]                           for (restart in restarts) {
[17:39:35.403]                             name <- restart$name
[17:39:35.403]                             if (is.null(name)) 
[17:39:35.403]                               next
[17:39:35.403]                             if (!grepl(pattern, name)) 
[17:39:35.403]                               next
[17:39:35.403]                             invokeRestart(restart)
[17:39:35.403]                             muffled <- TRUE
[17:39:35.403]                             break
[17:39:35.403]                           }
[17:39:35.403]                         }
[17:39:35.403]                       }
[17:39:35.403]                       invisible(muffled)
[17:39:35.403]                     }
[17:39:35.403]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.403]                   }
[17:39:35.403]                 }
[17:39:35.403]                 else {
[17:39:35.403]                   if (TRUE) {
[17:39:35.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.403]                     {
[17:39:35.403]                       inherits <- base::inherits
[17:39:35.403]                       invokeRestart <- base::invokeRestart
[17:39:35.403]                       is.null <- base::is.null
[17:39:35.403]                       muffled <- FALSE
[17:39:35.403]                       if (inherits(cond, "message")) {
[17:39:35.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.403]                         if (muffled) 
[17:39:35.403]                           invokeRestart("muffleMessage")
[17:39:35.403]                       }
[17:39:35.403]                       else if (inherits(cond, "warning")) {
[17:39:35.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.403]                         if (muffled) 
[17:39:35.403]                           invokeRestart("muffleWarning")
[17:39:35.403]                       }
[17:39:35.403]                       else if (inherits(cond, "condition")) {
[17:39:35.403]                         if (!is.null(pattern)) {
[17:39:35.403]                           computeRestarts <- base::computeRestarts
[17:39:35.403]                           grepl <- base::grepl
[17:39:35.403]                           restarts <- computeRestarts(cond)
[17:39:35.403]                           for (restart in restarts) {
[17:39:35.403]                             name <- restart$name
[17:39:35.403]                             if (is.null(name)) 
[17:39:35.403]                               next
[17:39:35.403]                             if (!grepl(pattern, name)) 
[17:39:35.403]                               next
[17:39:35.403]                             invokeRestart(restart)
[17:39:35.403]                             muffled <- TRUE
[17:39:35.403]                             break
[17:39:35.403]                           }
[17:39:35.403]                         }
[17:39:35.403]                       }
[17:39:35.403]                       invisible(muffled)
[17:39:35.403]                     }
[17:39:35.403]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.403]                   }
[17:39:35.403]                 }
[17:39:35.403]             }
[17:39:35.403]         }))
[17:39:35.403]     }, error = function(ex) {
[17:39:35.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.403]                 ...future.rng), started = ...future.startTime, 
[17:39:35.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.403]             version = "1.8"), class = "FutureResult")
[17:39:35.403]     }, finally = {
[17:39:35.403]         if (!identical(...future.workdir, getwd())) 
[17:39:35.403]             setwd(...future.workdir)
[17:39:35.403]         {
[17:39:35.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.403]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.403]             }
[17:39:35.403]             base::options(...future.oldOptions)
[17:39:35.403]             if (.Platform$OS.type == "windows") {
[17:39:35.403]                 old_names <- names(...future.oldEnvVars)
[17:39:35.403]                 envs <- base::Sys.getenv()
[17:39:35.403]                 names <- names(envs)
[17:39:35.403]                 common <- intersect(names, old_names)
[17:39:35.403]                 added <- setdiff(names, old_names)
[17:39:35.403]                 removed <- setdiff(old_names, names)
[17:39:35.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.403]                   envs[common]]
[17:39:35.403]                 NAMES <- toupper(changed)
[17:39:35.403]                 args <- list()
[17:39:35.403]                 for (kk in seq_along(NAMES)) {
[17:39:35.403]                   name <- changed[[kk]]
[17:39:35.403]                   NAME <- NAMES[[kk]]
[17:39:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.403]                     next
[17:39:35.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.403]                 }
[17:39:35.403]                 NAMES <- toupper(added)
[17:39:35.403]                 for (kk in seq_along(NAMES)) {
[17:39:35.403]                   name <- added[[kk]]
[17:39:35.403]                   NAME <- NAMES[[kk]]
[17:39:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.403]                     next
[17:39:35.403]                   args[[name]] <- ""
[17:39:35.403]                 }
[17:39:35.403]                 NAMES <- toupper(removed)
[17:39:35.403]                 for (kk in seq_along(NAMES)) {
[17:39:35.403]                   name <- removed[[kk]]
[17:39:35.403]                   NAME <- NAMES[[kk]]
[17:39:35.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.403]                     next
[17:39:35.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.403]                 }
[17:39:35.403]                 if (length(args) > 0) 
[17:39:35.403]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.403]             }
[17:39:35.403]             else {
[17:39:35.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.403]             }
[17:39:35.403]             {
[17:39:35.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.403]                   0L) {
[17:39:35.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.403]                   base::options(opts)
[17:39:35.403]                 }
[17:39:35.403]                 {
[17:39:35.403]                   {
[17:39:35.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.403]                     NULL
[17:39:35.403]                   }
[17:39:35.403]                   options(future.plan = NULL)
[17:39:35.403]                   if (is.na(NA_character_)) 
[17:39:35.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.403]                     .init = FALSE)
[17:39:35.403]                 }
[17:39:35.403]             }
[17:39:35.403]         }
[17:39:35.403]     })
[17:39:35.403]     if (TRUE) {
[17:39:35.403]         base::sink(type = "output", split = FALSE)
[17:39:35.403]         if (TRUE) {
[17:39:35.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.403]         }
[17:39:35.403]         else {
[17:39:35.403]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.403]         }
[17:39:35.403]         base::close(...future.stdout)
[17:39:35.403]         ...future.stdout <- NULL
[17:39:35.403]     }
[17:39:35.403]     ...future.result$conditions <- ...future.conditions
[17:39:35.403]     ...future.result$finished <- base::Sys.time()
[17:39:35.403]     ...future.result
[17:39:35.403] }
[17:39:35.406] MultisessionFuture started
[17:39:35.406] - Launch lazy future ... done
[17:39:35.406] run() for ‘MultisessionFuture’ ... done
[17:39:35.406] getGlobalsAndPackages() ...
[17:39:35.407] Searching for globals...
[17:39:35.407] 
[17:39:35.407] Searching for globals ... DONE
[17:39:35.407] - globals: [0] <none>
[17:39:35.407] getGlobalsAndPackages() ... DONE
[17:39:35.408] run() for ‘Future’ ...
[17:39:35.408] - state: ‘created’
[17:39:35.408] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.422]   - Field: ‘node’
[17:39:35.422]   - Field: ‘label’
[17:39:35.422]   - Field: ‘local’
[17:39:35.422]   - Field: ‘owner’
[17:39:35.423]   - Field: ‘envir’
[17:39:35.423]   - Field: ‘workers’
[17:39:35.423]   - Field: ‘packages’
[17:39:35.423]   - Field: ‘gc’
[17:39:35.423]   - Field: ‘conditions’
[17:39:35.423]   - Field: ‘persistent’
[17:39:35.423]   - Field: ‘expr’
[17:39:35.423]   - Field: ‘uuid’
[17:39:35.423]   - Field: ‘seed’
[17:39:35.423]   - Field: ‘version’
[17:39:35.423]   - Field: ‘result’
[17:39:35.423]   - Field: ‘asynchronous’
[17:39:35.424]   - Field: ‘calls’
[17:39:35.424]   - Field: ‘globals’
[17:39:35.424]   - Field: ‘stdout’
[17:39:35.424]   - Field: ‘earlySignal’
[17:39:35.424]   - Field: ‘lazy’
[17:39:35.424]   - Field: ‘state’
[17:39:35.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.424] - Launch lazy future ...
[17:39:35.424] Packages needed by the future expression (n = 0): <none>
[17:39:35.425] Packages needed by future strategies (n = 0): <none>
[17:39:35.425] {
[17:39:35.425]     {
[17:39:35.425]         {
[17:39:35.425]             ...future.startTime <- base::Sys.time()
[17:39:35.425]             {
[17:39:35.425]                 {
[17:39:35.425]                   {
[17:39:35.425]                     {
[17:39:35.425]                       base::local({
[17:39:35.425]                         has_future <- base::requireNamespace("future", 
[17:39:35.425]                           quietly = TRUE)
[17:39:35.425]                         if (has_future) {
[17:39:35.425]                           ns <- base::getNamespace("future")
[17:39:35.425]                           version <- ns[[".package"]][["version"]]
[17:39:35.425]                           if (is.null(version)) 
[17:39:35.425]                             version <- utils::packageVersion("future")
[17:39:35.425]                         }
[17:39:35.425]                         else {
[17:39:35.425]                           version <- NULL
[17:39:35.425]                         }
[17:39:35.425]                         if (!has_future || version < "1.8.0") {
[17:39:35.425]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.425]                             "", base::R.version$version.string), 
[17:39:35.425]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.425]                               "release", "version")], collapse = " "), 
[17:39:35.425]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.425]                             info)
[17:39:35.425]                           info <- base::paste(info, collapse = "; ")
[17:39:35.425]                           if (!has_future) {
[17:39:35.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.425]                               info)
[17:39:35.425]                           }
[17:39:35.425]                           else {
[17:39:35.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.425]                               info, version)
[17:39:35.425]                           }
[17:39:35.425]                           base::stop(msg)
[17:39:35.425]                         }
[17:39:35.425]                       })
[17:39:35.425]                     }
[17:39:35.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.425]                     base::options(mc.cores = 1L)
[17:39:35.425]                   }
[17:39:35.425]                   ...future.strategy.old <- future::plan("list")
[17:39:35.425]                   options(future.plan = NULL)
[17:39:35.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.425]                 }
[17:39:35.425]                 ...future.workdir <- getwd()
[17:39:35.425]             }
[17:39:35.425]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.425]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.425]         }
[17:39:35.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.425]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.425]             base::names(...future.oldOptions))
[17:39:35.425]     }
[17:39:35.425]     if (FALSE) {
[17:39:35.425]     }
[17:39:35.425]     else {
[17:39:35.425]         if (TRUE) {
[17:39:35.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.425]                 open = "w")
[17:39:35.425]         }
[17:39:35.425]         else {
[17:39:35.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.425]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.425]         }
[17:39:35.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.425]             base::sink(type = "output", split = FALSE)
[17:39:35.425]             base::close(...future.stdout)
[17:39:35.425]         }, add = TRUE)
[17:39:35.425]     }
[17:39:35.425]     ...future.frame <- base::sys.nframe()
[17:39:35.425]     ...future.conditions <- base::list()
[17:39:35.425]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.425]     if (FALSE) {
[17:39:35.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.425]     }
[17:39:35.425]     ...future.result <- base::tryCatch({
[17:39:35.425]         base::withCallingHandlers({
[17:39:35.425]             ...future.value <- base::withVisible(base::local({
[17:39:35.425]                 ...future.makeSendCondition <- base::local({
[17:39:35.425]                   sendCondition <- NULL
[17:39:35.425]                   function(frame = 1L) {
[17:39:35.425]                     if (is.function(sendCondition)) 
[17:39:35.425]                       return(sendCondition)
[17:39:35.425]                     ns <- getNamespace("parallel")
[17:39:35.425]                     if (exists("sendData", mode = "function", 
[17:39:35.425]                       envir = ns)) {
[17:39:35.425]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.425]                         envir = ns)
[17:39:35.425]                       envir <- sys.frame(frame)
[17:39:35.425]                       master <- NULL
[17:39:35.425]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.425]                         !identical(envir, emptyenv())) {
[17:39:35.425]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.425]                           inherits = FALSE)) {
[17:39:35.425]                           master <- get("master", mode = "list", 
[17:39:35.425]                             envir = envir, inherits = FALSE)
[17:39:35.425]                           if (inherits(master, c("SOCKnode", 
[17:39:35.425]                             "SOCK0node"))) {
[17:39:35.425]                             sendCondition <<- function(cond) {
[17:39:35.425]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.425]                                 success = TRUE)
[17:39:35.425]                               parallel_sendData(master, data)
[17:39:35.425]                             }
[17:39:35.425]                             return(sendCondition)
[17:39:35.425]                           }
[17:39:35.425]                         }
[17:39:35.425]                         frame <- frame + 1L
[17:39:35.425]                         envir <- sys.frame(frame)
[17:39:35.425]                       }
[17:39:35.425]                     }
[17:39:35.425]                     sendCondition <<- function(cond) NULL
[17:39:35.425]                   }
[17:39:35.425]                 })
[17:39:35.425]                 withCallingHandlers({
[17:39:35.425]                   NULL
[17:39:35.425]                 }, immediateCondition = function(cond) {
[17:39:35.425]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.425]                   sendCondition(cond)
[17:39:35.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.425]                   {
[17:39:35.425]                     inherits <- base::inherits
[17:39:35.425]                     invokeRestart <- base::invokeRestart
[17:39:35.425]                     is.null <- base::is.null
[17:39:35.425]                     muffled <- FALSE
[17:39:35.425]                     if (inherits(cond, "message")) {
[17:39:35.425]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.425]                       if (muffled) 
[17:39:35.425]                         invokeRestart("muffleMessage")
[17:39:35.425]                     }
[17:39:35.425]                     else if (inherits(cond, "warning")) {
[17:39:35.425]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.425]                       if (muffled) 
[17:39:35.425]                         invokeRestart("muffleWarning")
[17:39:35.425]                     }
[17:39:35.425]                     else if (inherits(cond, "condition")) {
[17:39:35.425]                       if (!is.null(pattern)) {
[17:39:35.425]                         computeRestarts <- base::computeRestarts
[17:39:35.425]                         grepl <- base::grepl
[17:39:35.425]                         restarts <- computeRestarts(cond)
[17:39:35.425]                         for (restart in restarts) {
[17:39:35.425]                           name <- restart$name
[17:39:35.425]                           if (is.null(name)) 
[17:39:35.425]                             next
[17:39:35.425]                           if (!grepl(pattern, name)) 
[17:39:35.425]                             next
[17:39:35.425]                           invokeRestart(restart)
[17:39:35.425]                           muffled <- TRUE
[17:39:35.425]                           break
[17:39:35.425]                         }
[17:39:35.425]                       }
[17:39:35.425]                     }
[17:39:35.425]                     invisible(muffled)
[17:39:35.425]                   }
[17:39:35.425]                   muffleCondition(cond)
[17:39:35.425]                 })
[17:39:35.425]             }))
[17:39:35.425]             future::FutureResult(value = ...future.value$value, 
[17:39:35.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.425]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.425]                     ...future.globalenv.names))
[17:39:35.425]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.425]         }, condition = base::local({
[17:39:35.425]             c <- base::c
[17:39:35.425]             inherits <- base::inherits
[17:39:35.425]             invokeRestart <- base::invokeRestart
[17:39:35.425]             length <- base::length
[17:39:35.425]             list <- base::list
[17:39:35.425]             seq.int <- base::seq.int
[17:39:35.425]             signalCondition <- base::signalCondition
[17:39:35.425]             sys.calls <- base::sys.calls
[17:39:35.425]             `[[` <- base::`[[`
[17:39:35.425]             `+` <- base::`+`
[17:39:35.425]             `<<-` <- base::`<<-`
[17:39:35.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.425]                   3L)]
[17:39:35.425]             }
[17:39:35.425]             function(cond) {
[17:39:35.425]                 is_error <- inherits(cond, "error")
[17:39:35.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.425]                   NULL)
[17:39:35.425]                 if (is_error) {
[17:39:35.425]                   sessionInformation <- function() {
[17:39:35.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.425]                       search = base::search(), system = base::Sys.info())
[17:39:35.425]                   }
[17:39:35.425]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.425]                     cond$call), session = sessionInformation(), 
[17:39:35.425]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.425]                   signalCondition(cond)
[17:39:35.425]                 }
[17:39:35.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.425]                 "immediateCondition"))) {
[17:39:35.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.425]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.425]                   if (TRUE && !signal) {
[17:39:35.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.425]                     {
[17:39:35.425]                       inherits <- base::inherits
[17:39:35.425]                       invokeRestart <- base::invokeRestart
[17:39:35.425]                       is.null <- base::is.null
[17:39:35.425]                       muffled <- FALSE
[17:39:35.425]                       if (inherits(cond, "message")) {
[17:39:35.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.425]                         if (muffled) 
[17:39:35.425]                           invokeRestart("muffleMessage")
[17:39:35.425]                       }
[17:39:35.425]                       else if (inherits(cond, "warning")) {
[17:39:35.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.425]                         if (muffled) 
[17:39:35.425]                           invokeRestart("muffleWarning")
[17:39:35.425]                       }
[17:39:35.425]                       else if (inherits(cond, "condition")) {
[17:39:35.425]                         if (!is.null(pattern)) {
[17:39:35.425]                           computeRestarts <- base::computeRestarts
[17:39:35.425]                           grepl <- base::grepl
[17:39:35.425]                           restarts <- computeRestarts(cond)
[17:39:35.425]                           for (restart in restarts) {
[17:39:35.425]                             name <- restart$name
[17:39:35.425]                             if (is.null(name)) 
[17:39:35.425]                               next
[17:39:35.425]                             if (!grepl(pattern, name)) 
[17:39:35.425]                               next
[17:39:35.425]                             invokeRestart(restart)
[17:39:35.425]                             muffled <- TRUE
[17:39:35.425]                             break
[17:39:35.425]                           }
[17:39:35.425]                         }
[17:39:35.425]                       }
[17:39:35.425]                       invisible(muffled)
[17:39:35.425]                     }
[17:39:35.425]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.425]                   }
[17:39:35.425]                 }
[17:39:35.425]                 else {
[17:39:35.425]                   if (TRUE) {
[17:39:35.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.425]                     {
[17:39:35.425]                       inherits <- base::inherits
[17:39:35.425]                       invokeRestart <- base::invokeRestart
[17:39:35.425]                       is.null <- base::is.null
[17:39:35.425]                       muffled <- FALSE
[17:39:35.425]                       if (inherits(cond, "message")) {
[17:39:35.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.425]                         if (muffled) 
[17:39:35.425]                           invokeRestart("muffleMessage")
[17:39:35.425]                       }
[17:39:35.425]                       else if (inherits(cond, "warning")) {
[17:39:35.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.425]                         if (muffled) 
[17:39:35.425]                           invokeRestart("muffleWarning")
[17:39:35.425]                       }
[17:39:35.425]                       else if (inherits(cond, "condition")) {
[17:39:35.425]                         if (!is.null(pattern)) {
[17:39:35.425]                           computeRestarts <- base::computeRestarts
[17:39:35.425]                           grepl <- base::grepl
[17:39:35.425]                           restarts <- computeRestarts(cond)
[17:39:35.425]                           for (restart in restarts) {
[17:39:35.425]                             name <- restart$name
[17:39:35.425]                             if (is.null(name)) 
[17:39:35.425]                               next
[17:39:35.425]                             if (!grepl(pattern, name)) 
[17:39:35.425]                               next
[17:39:35.425]                             invokeRestart(restart)
[17:39:35.425]                             muffled <- TRUE
[17:39:35.425]                             break
[17:39:35.425]                           }
[17:39:35.425]                         }
[17:39:35.425]                       }
[17:39:35.425]                       invisible(muffled)
[17:39:35.425]                     }
[17:39:35.425]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.425]                   }
[17:39:35.425]                 }
[17:39:35.425]             }
[17:39:35.425]         }))
[17:39:35.425]     }, error = function(ex) {
[17:39:35.425]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.425]                 ...future.rng), started = ...future.startTime, 
[17:39:35.425]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.425]             version = "1.8"), class = "FutureResult")
[17:39:35.425]     }, finally = {
[17:39:35.425]         if (!identical(...future.workdir, getwd())) 
[17:39:35.425]             setwd(...future.workdir)
[17:39:35.425]         {
[17:39:35.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.425]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.425]             }
[17:39:35.425]             base::options(...future.oldOptions)
[17:39:35.425]             if (.Platform$OS.type == "windows") {
[17:39:35.425]                 old_names <- names(...future.oldEnvVars)
[17:39:35.425]                 envs <- base::Sys.getenv()
[17:39:35.425]                 names <- names(envs)
[17:39:35.425]                 common <- intersect(names, old_names)
[17:39:35.425]                 added <- setdiff(names, old_names)
[17:39:35.425]                 removed <- setdiff(old_names, names)
[17:39:35.425]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.425]                   envs[common]]
[17:39:35.425]                 NAMES <- toupper(changed)
[17:39:35.425]                 args <- list()
[17:39:35.425]                 for (kk in seq_along(NAMES)) {
[17:39:35.425]                   name <- changed[[kk]]
[17:39:35.425]                   NAME <- NAMES[[kk]]
[17:39:35.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.425]                     next
[17:39:35.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.425]                 }
[17:39:35.425]                 NAMES <- toupper(added)
[17:39:35.425]                 for (kk in seq_along(NAMES)) {
[17:39:35.425]                   name <- added[[kk]]
[17:39:35.425]                   NAME <- NAMES[[kk]]
[17:39:35.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.425]                     next
[17:39:35.425]                   args[[name]] <- ""
[17:39:35.425]                 }
[17:39:35.425]                 NAMES <- toupper(removed)
[17:39:35.425]                 for (kk in seq_along(NAMES)) {
[17:39:35.425]                   name <- removed[[kk]]
[17:39:35.425]                   NAME <- NAMES[[kk]]
[17:39:35.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.425]                     next
[17:39:35.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.425]                 }
[17:39:35.425]                 if (length(args) > 0) 
[17:39:35.425]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.425]             }
[17:39:35.425]             else {
[17:39:35.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.425]             }
[17:39:35.425]             {
[17:39:35.425]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.425]                   0L) {
[17:39:35.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.425]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.425]                   base::options(opts)
[17:39:35.425]                 }
[17:39:35.425]                 {
[17:39:35.425]                   {
[17:39:35.425]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.425]                     NULL
[17:39:35.425]                   }
[17:39:35.425]                   options(future.plan = NULL)
[17:39:35.425]                   if (is.na(NA_character_)) 
[17:39:35.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.425]                     .init = FALSE)
[17:39:35.425]                 }
[17:39:35.425]             }
[17:39:35.425]         }
[17:39:35.425]     })
[17:39:35.425]     if (TRUE) {
[17:39:35.425]         base::sink(type = "output", split = FALSE)
[17:39:35.425]         if (TRUE) {
[17:39:35.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.425]         }
[17:39:35.425]         else {
[17:39:35.425]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.425]         }
[17:39:35.425]         base::close(...future.stdout)
[17:39:35.425]         ...future.stdout <- NULL
[17:39:35.425]     }
[17:39:35.425]     ...future.result$conditions <- ...future.conditions
[17:39:35.425]     ...future.result$finished <- base::Sys.time()
[17:39:35.425]     ...future.result
[17:39:35.425] }
[17:39:35.428] MultisessionFuture started
[17:39:35.428] - Launch lazy future ... done
[17:39:35.428] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1a8e4c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1ea0de8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1a8e4c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf1ea0de8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:39:35.434] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.434] - Validating connection of MultisessionFuture
[17:39:35.434] - received message: FutureResult
[17:39:35.434] - Received FutureResult
[17:39:35.434] - Erased future from FutureRegistry
[17:39:35.434] result() for ClusterFuture ...
[17:39:35.434] - result already collected: FutureResult
[17:39:35.434] result() for ClusterFuture ... done
[17:39:35.434] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.435] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.435] - Validating connection of MultisessionFuture
[17:39:35.435] - received message: FutureResult
[17:39:35.435] - Received FutureResult
[17:39:35.435] - Erased future from FutureRegistry
[17:39:35.438] result() for ClusterFuture ...
[17:39:35.438] - result already collected: FutureResult
[17:39:35.438] result() for ClusterFuture ... done
[17:39:35.438] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:35.440] resolve() on list ...
[17:39:35.440]  recursive: 0
[17:39:35.440]  length: 6
[17:39:35.440]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:35.440] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.440] - nx: 6
[17:39:35.440] - relay: TRUE
[17:39:35.440] - stdout: TRUE
[17:39:35.440] - signal: TRUE
[17:39:35.440] - resignal: FALSE
[17:39:35.440] - force: TRUE
[17:39:35.441] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.441] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.441]  - until=2
[17:39:35.441]  - relaying element #2
[17:39:35.441] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.441] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.441] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.441]  length: 5 (resolved future 1)
[17:39:35.441] Future #2
[17:39:35.441] result() for ClusterFuture ...
[17:39:35.441] - result already collected: FutureResult
[17:39:35.442] result() for ClusterFuture ... done
[17:39:35.442] result() for ClusterFuture ...
[17:39:35.442] - result already collected: FutureResult
[17:39:35.442] result() for ClusterFuture ... done
[17:39:35.442] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:35.442] - nx: 6
[17:39:35.442] - relay: TRUE
[17:39:35.442] - stdout: TRUE
[17:39:35.442] - signal: TRUE
[17:39:35.442] - resignal: FALSE
[17:39:35.442] - force: TRUE
[17:39:35.442] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.442] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.443]  - until=2
[17:39:35.443]  - relaying element #2
[17:39:35.443] result() for ClusterFuture ...
[17:39:35.443] - result already collected: FutureResult
[17:39:35.443] result() for ClusterFuture ... done
[17:39:35.443] result() for ClusterFuture ...
[17:39:35.443] - result already collected: FutureResult
[17:39:35.443] result() for ClusterFuture ... done
[17:39:35.443] result() for ClusterFuture ...
[17:39:35.443] - result already collected: FutureResult
[17:39:35.443] result() for ClusterFuture ... done
[17:39:35.444] result() for ClusterFuture ...
[17:39:35.444] - result already collected: FutureResult
[17:39:35.444] result() for ClusterFuture ... done
[17:39:35.444] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.444] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.444] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:35.444]  length: 4 (resolved future 2)
[17:39:35.444] Future #3
[17:39:35.444] result() for ClusterFuture ...
[17:39:35.444] - result already collected: FutureResult
[17:39:35.445] result() for ClusterFuture ... done
[17:39:35.445] result() for ClusterFuture ...
[17:39:35.445] - result already collected: FutureResult
[17:39:35.445] result() for ClusterFuture ... done
[17:39:35.445] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:35.445] - nx: 6
[17:39:35.445] - relay: TRUE
[17:39:35.445] - stdout: TRUE
[17:39:35.445] - signal: TRUE
[17:39:35.445] - resignal: FALSE
[17:39:35.445] - force: TRUE
[17:39:35.445] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.445] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.446]  - until=3
[17:39:35.446]  - relaying element #3
[17:39:35.446] result() for ClusterFuture ...
[17:39:35.446] - result already collected: FutureResult
[17:39:35.446] result() for ClusterFuture ... done
[17:39:35.446] result() for ClusterFuture ...
[17:39:35.446] - result already collected: FutureResult
[17:39:35.446] result() for ClusterFuture ... done
[17:39:35.446] result() for ClusterFuture ...
[17:39:35.446] - result already collected: FutureResult
[17:39:35.446] result() for ClusterFuture ... done
[17:39:35.447] result() for ClusterFuture ...
[17:39:35.447] - result already collected: FutureResult
[17:39:35.447] result() for ClusterFuture ... done
[17:39:35.447] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.447] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.447] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:35.447]  length: 3 (resolved future 3)
[17:39:35.447] signalConditionsASAP(NULL, pos=4) ...
[17:39:35.447] - nx: 6
[17:39:35.447] - relay: TRUE
[17:39:35.447] - stdout: TRUE
[17:39:35.447] - signal: TRUE
[17:39:35.448] - resignal: FALSE
[17:39:35.448] - force: TRUE
[17:39:35.448] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.448] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.448]  - until=5
[17:39:35.448]  - relaying element #5
[17:39:35.448] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.448] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.448] signalConditionsASAP(NULL, pos=4) ... done
[17:39:35.448]  length: 2 (resolved future 4)
[17:39:35.448] signalConditionsASAP(NULL, pos=5) ...
[17:39:35.448] - nx: 6
[17:39:35.449] - relay: TRUE
[17:39:35.449] - stdout: TRUE
[17:39:35.449] - signal: TRUE
[17:39:35.449] - resignal: FALSE
[17:39:35.449] - force: TRUE
[17:39:35.449] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.449] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.449]  - until=6
[17:39:35.449]  - relaying element #6
[17:39:35.449] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.449] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.449] signalConditionsASAP(NULL, pos=5) ... done
[17:39:35.450]  length: 1 (resolved future 5)
[17:39:35.450] signalConditionsASAP(numeric, pos=6) ...
[17:39:35.450] - nx: 6
[17:39:35.450] - relay: TRUE
[17:39:35.450] - stdout: TRUE
[17:39:35.450] - signal: TRUE
[17:39:35.450] - resignal: FALSE
[17:39:35.450] - force: TRUE
[17:39:35.450] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.450] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.450]  - until=6
[17:39:35.450] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.450] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.451] signalConditionsASAP(numeric, pos=6) ... done
[17:39:35.451]  length: 0 (resolved future 6)
[17:39:35.451] Relaying remaining futures
[17:39:35.451] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.451] - nx: 6
[17:39:35.451] - relay: TRUE
[17:39:35.451] - stdout: TRUE
[17:39:35.451] - signal: TRUE
[17:39:35.451] - resignal: FALSE
[17:39:35.451] - force: TRUE
[17:39:35.451] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.451] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:35.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.452] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.452] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.452] resolve() on list ... DONE
[17:39:35.452] result() for ClusterFuture ...
[17:39:35.452] - result already collected: FutureResult
[17:39:35.452] result() for ClusterFuture ... done
[17:39:35.452] result() for ClusterFuture ...
[17:39:35.452] - result already collected: FutureResult
[17:39:35.452] result() for ClusterFuture ... done
[17:39:35.452] result() for ClusterFuture ...
[17:39:35.453] - result already collected: FutureResult
[17:39:35.453] result() for ClusterFuture ... done
[17:39:35.453] result() for ClusterFuture ...
[17:39:35.453] - result already collected: FutureResult
[17:39:35.453] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:35.456] getGlobalsAndPackages() ...
[17:39:35.456] Searching for globals...
[17:39:35.456] 
[17:39:35.456] Searching for globals ... DONE
[17:39:35.457] - globals: [0] <none>
[17:39:35.457] getGlobalsAndPackages() ... DONE
[17:39:35.457] run() for ‘Future’ ...
[17:39:35.457] - state: ‘created’
[17:39:35.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.471] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.472]   - Field: ‘node’
[17:39:35.472]   - Field: ‘label’
[17:39:35.472]   - Field: ‘local’
[17:39:35.472]   - Field: ‘owner’
[17:39:35.472]   - Field: ‘envir’
[17:39:35.472]   - Field: ‘workers’
[17:39:35.472]   - Field: ‘packages’
[17:39:35.472]   - Field: ‘gc’
[17:39:35.472]   - Field: ‘conditions’
[17:39:35.473]   - Field: ‘persistent’
[17:39:35.473]   - Field: ‘expr’
[17:39:35.473]   - Field: ‘uuid’
[17:39:35.473]   - Field: ‘seed’
[17:39:35.473]   - Field: ‘version’
[17:39:35.473]   - Field: ‘result’
[17:39:35.473]   - Field: ‘asynchronous’
[17:39:35.473]   - Field: ‘calls’
[17:39:35.473]   - Field: ‘globals’
[17:39:35.473]   - Field: ‘stdout’
[17:39:35.473]   - Field: ‘earlySignal’
[17:39:35.474]   - Field: ‘lazy’
[17:39:35.474]   - Field: ‘state’
[17:39:35.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.474] - Launch lazy future ...
[17:39:35.474] Packages needed by the future expression (n = 0): <none>
[17:39:35.474] Packages needed by future strategies (n = 0): <none>
[17:39:35.475] {
[17:39:35.475]     {
[17:39:35.475]         {
[17:39:35.475]             ...future.startTime <- base::Sys.time()
[17:39:35.475]             {
[17:39:35.475]                 {
[17:39:35.475]                   {
[17:39:35.475]                     {
[17:39:35.475]                       base::local({
[17:39:35.475]                         has_future <- base::requireNamespace("future", 
[17:39:35.475]                           quietly = TRUE)
[17:39:35.475]                         if (has_future) {
[17:39:35.475]                           ns <- base::getNamespace("future")
[17:39:35.475]                           version <- ns[[".package"]][["version"]]
[17:39:35.475]                           if (is.null(version)) 
[17:39:35.475]                             version <- utils::packageVersion("future")
[17:39:35.475]                         }
[17:39:35.475]                         else {
[17:39:35.475]                           version <- NULL
[17:39:35.475]                         }
[17:39:35.475]                         if (!has_future || version < "1.8.0") {
[17:39:35.475]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.475]                             "", base::R.version$version.string), 
[17:39:35.475]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.475]                               "release", "version")], collapse = " "), 
[17:39:35.475]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.475]                             info)
[17:39:35.475]                           info <- base::paste(info, collapse = "; ")
[17:39:35.475]                           if (!has_future) {
[17:39:35.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.475]                               info)
[17:39:35.475]                           }
[17:39:35.475]                           else {
[17:39:35.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.475]                               info, version)
[17:39:35.475]                           }
[17:39:35.475]                           base::stop(msg)
[17:39:35.475]                         }
[17:39:35.475]                       })
[17:39:35.475]                     }
[17:39:35.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.475]                     base::options(mc.cores = 1L)
[17:39:35.475]                   }
[17:39:35.475]                   ...future.strategy.old <- future::plan("list")
[17:39:35.475]                   options(future.plan = NULL)
[17:39:35.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.475]                 }
[17:39:35.475]                 ...future.workdir <- getwd()
[17:39:35.475]             }
[17:39:35.475]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.475]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.475]         }
[17:39:35.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.475]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.475]             base::names(...future.oldOptions))
[17:39:35.475]     }
[17:39:35.475]     if (FALSE) {
[17:39:35.475]     }
[17:39:35.475]     else {
[17:39:35.475]         if (TRUE) {
[17:39:35.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.475]                 open = "w")
[17:39:35.475]         }
[17:39:35.475]         else {
[17:39:35.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.475]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.475]         }
[17:39:35.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.475]             base::sink(type = "output", split = FALSE)
[17:39:35.475]             base::close(...future.stdout)
[17:39:35.475]         }, add = TRUE)
[17:39:35.475]     }
[17:39:35.475]     ...future.frame <- base::sys.nframe()
[17:39:35.475]     ...future.conditions <- base::list()
[17:39:35.475]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.475]     if (FALSE) {
[17:39:35.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.475]     }
[17:39:35.475]     ...future.result <- base::tryCatch({
[17:39:35.475]         base::withCallingHandlers({
[17:39:35.475]             ...future.value <- base::withVisible(base::local({
[17:39:35.475]                 ...future.makeSendCondition <- base::local({
[17:39:35.475]                   sendCondition <- NULL
[17:39:35.475]                   function(frame = 1L) {
[17:39:35.475]                     if (is.function(sendCondition)) 
[17:39:35.475]                       return(sendCondition)
[17:39:35.475]                     ns <- getNamespace("parallel")
[17:39:35.475]                     if (exists("sendData", mode = "function", 
[17:39:35.475]                       envir = ns)) {
[17:39:35.475]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.475]                         envir = ns)
[17:39:35.475]                       envir <- sys.frame(frame)
[17:39:35.475]                       master <- NULL
[17:39:35.475]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.475]                         !identical(envir, emptyenv())) {
[17:39:35.475]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.475]                           inherits = FALSE)) {
[17:39:35.475]                           master <- get("master", mode = "list", 
[17:39:35.475]                             envir = envir, inherits = FALSE)
[17:39:35.475]                           if (inherits(master, c("SOCKnode", 
[17:39:35.475]                             "SOCK0node"))) {
[17:39:35.475]                             sendCondition <<- function(cond) {
[17:39:35.475]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.475]                                 success = TRUE)
[17:39:35.475]                               parallel_sendData(master, data)
[17:39:35.475]                             }
[17:39:35.475]                             return(sendCondition)
[17:39:35.475]                           }
[17:39:35.475]                         }
[17:39:35.475]                         frame <- frame + 1L
[17:39:35.475]                         envir <- sys.frame(frame)
[17:39:35.475]                       }
[17:39:35.475]                     }
[17:39:35.475]                     sendCondition <<- function(cond) NULL
[17:39:35.475]                   }
[17:39:35.475]                 })
[17:39:35.475]                 withCallingHandlers({
[17:39:35.475]                   2
[17:39:35.475]                 }, immediateCondition = function(cond) {
[17:39:35.475]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.475]                   sendCondition(cond)
[17:39:35.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.475]                   {
[17:39:35.475]                     inherits <- base::inherits
[17:39:35.475]                     invokeRestart <- base::invokeRestart
[17:39:35.475]                     is.null <- base::is.null
[17:39:35.475]                     muffled <- FALSE
[17:39:35.475]                     if (inherits(cond, "message")) {
[17:39:35.475]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.475]                       if (muffled) 
[17:39:35.475]                         invokeRestart("muffleMessage")
[17:39:35.475]                     }
[17:39:35.475]                     else if (inherits(cond, "warning")) {
[17:39:35.475]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.475]                       if (muffled) 
[17:39:35.475]                         invokeRestart("muffleWarning")
[17:39:35.475]                     }
[17:39:35.475]                     else if (inherits(cond, "condition")) {
[17:39:35.475]                       if (!is.null(pattern)) {
[17:39:35.475]                         computeRestarts <- base::computeRestarts
[17:39:35.475]                         grepl <- base::grepl
[17:39:35.475]                         restarts <- computeRestarts(cond)
[17:39:35.475]                         for (restart in restarts) {
[17:39:35.475]                           name <- restart$name
[17:39:35.475]                           if (is.null(name)) 
[17:39:35.475]                             next
[17:39:35.475]                           if (!grepl(pattern, name)) 
[17:39:35.475]                             next
[17:39:35.475]                           invokeRestart(restart)
[17:39:35.475]                           muffled <- TRUE
[17:39:35.475]                           break
[17:39:35.475]                         }
[17:39:35.475]                       }
[17:39:35.475]                     }
[17:39:35.475]                     invisible(muffled)
[17:39:35.475]                   }
[17:39:35.475]                   muffleCondition(cond)
[17:39:35.475]                 })
[17:39:35.475]             }))
[17:39:35.475]             future::FutureResult(value = ...future.value$value, 
[17:39:35.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.475]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.475]                     ...future.globalenv.names))
[17:39:35.475]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.475]         }, condition = base::local({
[17:39:35.475]             c <- base::c
[17:39:35.475]             inherits <- base::inherits
[17:39:35.475]             invokeRestart <- base::invokeRestart
[17:39:35.475]             length <- base::length
[17:39:35.475]             list <- base::list
[17:39:35.475]             seq.int <- base::seq.int
[17:39:35.475]             signalCondition <- base::signalCondition
[17:39:35.475]             sys.calls <- base::sys.calls
[17:39:35.475]             `[[` <- base::`[[`
[17:39:35.475]             `+` <- base::`+`
[17:39:35.475]             `<<-` <- base::`<<-`
[17:39:35.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.475]                   3L)]
[17:39:35.475]             }
[17:39:35.475]             function(cond) {
[17:39:35.475]                 is_error <- inherits(cond, "error")
[17:39:35.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.475]                   NULL)
[17:39:35.475]                 if (is_error) {
[17:39:35.475]                   sessionInformation <- function() {
[17:39:35.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.475]                       search = base::search(), system = base::Sys.info())
[17:39:35.475]                   }
[17:39:35.475]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.475]                     cond$call), session = sessionInformation(), 
[17:39:35.475]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.475]                   signalCondition(cond)
[17:39:35.475]                 }
[17:39:35.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.475]                 "immediateCondition"))) {
[17:39:35.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.475]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.475]                   if (TRUE && !signal) {
[17:39:35.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.475]                     {
[17:39:35.475]                       inherits <- base::inherits
[17:39:35.475]                       invokeRestart <- base::invokeRestart
[17:39:35.475]                       is.null <- base::is.null
[17:39:35.475]                       muffled <- FALSE
[17:39:35.475]                       if (inherits(cond, "message")) {
[17:39:35.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.475]                         if (muffled) 
[17:39:35.475]                           invokeRestart("muffleMessage")
[17:39:35.475]                       }
[17:39:35.475]                       else if (inherits(cond, "warning")) {
[17:39:35.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.475]                         if (muffled) 
[17:39:35.475]                           invokeRestart("muffleWarning")
[17:39:35.475]                       }
[17:39:35.475]                       else if (inherits(cond, "condition")) {
[17:39:35.475]                         if (!is.null(pattern)) {
[17:39:35.475]                           computeRestarts <- base::computeRestarts
[17:39:35.475]                           grepl <- base::grepl
[17:39:35.475]                           restarts <- computeRestarts(cond)
[17:39:35.475]                           for (restart in restarts) {
[17:39:35.475]                             name <- restart$name
[17:39:35.475]                             if (is.null(name)) 
[17:39:35.475]                               next
[17:39:35.475]                             if (!grepl(pattern, name)) 
[17:39:35.475]                               next
[17:39:35.475]                             invokeRestart(restart)
[17:39:35.475]                             muffled <- TRUE
[17:39:35.475]                             break
[17:39:35.475]                           }
[17:39:35.475]                         }
[17:39:35.475]                       }
[17:39:35.475]                       invisible(muffled)
[17:39:35.475]                     }
[17:39:35.475]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.475]                   }
[17:39:35.475]                 }
[17:39:35.475]                 else {
[17:39:35.475]                   if (TRUE) {
[17:39:35.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.475]                     {
[17:39:35.475]                       inherits <- base::inherits
[17:39:35.475]                       invokeRestart <- base::invokeRestart
[17:39:35.475]                       is.null <- base::is.null
[17:39:35.475]                       muffled <- FALSE
[17:39:35.475]                       if (inherits(cond, "message")) {
[17:39:35.475]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.475]                         if (muffled) 
[17:39:35.475]                           invokeRestart("muffleMessage")
[17:39:35.475]                       }
[17:39:35.475]                       else if (inherits(cond, "warning")) {
[17:39:35.475]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.475]                         if (muffled) 
[17:39:35.475]                           invokeRestart("muffleWarning")
[17:39:35.475]                       }
[17:39:35.475]                       else if (inherits(cond, "condition")) {
[17:39:35.475]                         if (!is.null(pattern)) {
[17:39:35.475]                           computeRestarts <- base::computeRestarts
[17:39:35.475]                           grepl <- base::grepl
[17:39:35.475]                           restarts <- computeRestarts(cond)
[17:39:35.475]                           for (restart in restarts) {
[17:39:35.475]                             name <- restart$name
[17:39:35.475]                             if (is.null(name)) 
[17:39:35.475]                               next
[17:39:35.475]                             if (!grepl(pattern, name)) 
[17:39:35.475]                               next
[17:39:35.475]                             invokeRestart(restart)
[17:39:35.475]                             muffled <- TRUE
[17:39:35.475]                             break
[17:39:35.475]                           }
[17:39:35.475]                         }
[17:39:35.475]                       }
[17:39:35.475]                       invisible(muffled)
[17:39:35.475]                     }
[17:39:35.475]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.475]                   }
[17:39:35.475]                 }
[17:39:35.475]             }
[17:39:35.475]         }))
[17:39:35.475]     }, error = function(ex) {
[17:39:35.475]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.475]                 ...future.rng), started = ...future.startTime, 
[17:39:35.475]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.475]             version = "1.8"), class = "FutureResult")
[17:39:35.475]     }, finally = {
[17:39:35.475]         if (!identical(...future.workdir, getwd())) 
[17:39:35.475]             setwd(...future.workdir)
[17:39:35.475]         {
[17:39:35.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.475]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.475]             }
[17:39:35.475]             base::options(...future.oldOptions)
[17:39:35.475]             if (.Platform$OS.type == "windows") {
[17:39:35.475]                 old_names <- names(...future.oldEnvVars)
[17:39:35.475]                 envs <- base::Sys.getenv()
[17:39:35.475]                 names <- names(envs)
[17:39:35.475]                 common <- intersect(names, old_names)
[17:39:35.475]                 added <- setdiff(names, old_names)
[17:39:35.475]                 removed <- setdiff(old_names, names)
[17:39:35.475]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.475]                   envs[common]]
[17:39:35.475]                 NAMES <- toupper(changed)
[17:39:35.475]                 args <- list()
[17:39:35.475]                 for (kk in seq_along(NAMES)) {
[17:39:35.475]                   name <- changed[[kk]]
[17:39:35.475]                   NAME <- NAMES[[kk]]
[17:39:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.475]                     next
[17:39:35.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.475]                 }
[17:39:35.475]                 NAMES <- toupper(added)
[17:39:35.475]                 for (kk in seq_along(NAMES)) {
[17:39:35.475]                   name <- added[[kk]]
[17:39:35.475]                   NAME <- NAMES[[kk]]
[17:39:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.475]                     next
[17:39:35.475]                   args[[name]] <- ""
[17:39:35.475]                 }
[17:39:35.475]                 NAMES <- toupper(removed)
[17:39:35.475]                 for (kk in seq_along(NAMES)) {
[17:39:35.475]                   name <- removed[[kk]]
[17:39:35.475]                   NAME <- NAMES[[kk]]
[17:39:35.475]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.475]                     next
[17:39:35.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.475]                 }
[17:39:35.475]                 if (length(args) > 0) 
[17:39:35.475]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.475]             }
[17:39:35.475]             else {
[17:39:35.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.475]             }
[17:39:35.475]             {
[17:39:35.475]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.475]                   0L) {
[17:39:35.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.475]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.475]                   base::options(opts)
[17:39:35.475]                 }
[17:39:35.475]                 {
[17:39:35.475]                   {
[17:39:35.475]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.475]                     NULL
[17:39:35.475]                   }
[17:39:35.475]                   options(future.plan = NULL)
[17:39:35.475]                   if (is.na(NA_character_)) 
[17:39:35.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.475]                     .init = FALSE)
[17:39:35.475]                 }
[17:39:35.475]             }
[17:39:35.475]         }
[17:39:35.475]     })
[17:39:35.475]     if (TRUE) {
[17:39:35.475]         base::sink(type = "output", split = FALSE)
[17:39:35.475]         if (TRUE) {
[17:39:35.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.475]         }
[17:39:35.475]         else {
[17:39:35.475]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.475]         }
[17:39:35.475]         base::close(...future.stdout)
[17:39:35.475]         ...future.stdout <- NULL
[17:39:35.475]     }
[17:39:35.475]     ...future.result$conditions <- ...future.conditions
[17:39:35.475]     ...future.result$finished <- base::Sys.time()
[17:39:35.475]     ...future.result
[17:39:35.475] }
[17:39:35.478] MultisessionFuture started
[17:39:35.478] - Launch lazy future ... done
[17:39:35.478] run() for ‘MultisessionFuture’ ... done
[17:39:35.478] getGlobalsAndPackages() ...
[17:39:35.478] Searching for globals...
[17:39:35.479] 
[17:39:35.479] Searching for globals ... DONE
[17:39:35.479] - globals: [0] <none>
[17:39:35.479] getGlobalsAndPackages() ... DONE
[17:39:35.480] run() for ‘Future’ ...
[17:39:35.480] - state: ‘created’
[17:39:35.480] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.494]   - Field: ‘node’
[17:39:35.494]   - Field: ‘label’
[17:39:35.494]   - Field: ‘local’
[17:39:35.494]   - Field: ‘owner’
[17:39:35.494]   - Field: ‘envir’
[17:39:35.494]   - Field: ‘workers’
[17:39:35.494]   - Field: ‘packages’
[17:39:35.495]   - Field: ‘gc’
[17:39:35.495]   - Field: ‘conditions’
[17:39:35.495]   - Field: ‘persistent’
[17:39:35.495]   - Field: ‘expr’
[17:39:35.495]   - Field: ‘uuid’
[17:39:35.495]   - Field: ‘seed’
[17:39:35.495]   - Field: ‘version’
[17:39:35.495]   - Field: ‘result’
[17:39:35.495]   - Field: ‘asynchronous’
[17:39:35.495]   - Field: ‘calls’
[17:39:35.495]   - Field: ‘globals’
[17:39:35.496]   - Field: ‘stdout’
[17:39:35.496]   - Field: ‘earlySignal’
[17:39:35.496]   - Field: ‘lazy’
[17:39:35.496]   - Field: ‘state’
[17:39:35.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.496] - Launch lazy future ...
[17:39:35.496] Packages needed by the future expression (n = 0): <none>
[17:39:35.496] Packages needed by future strategies (n = 0): <none>
[17:39:35.497] {
[17:39:35.497]     {
[17:39:35.497]         {
[17:39:35.497]             ...future.startTime <- base::Sys.time()
[17:39:35.497]             {
[17:39:35.497]                 {
[17:39:35.497]                   {
[17:39:35.497]                     {
[17:39:35.497]                       base::local({
[17:39:35.497]                         has_future <- base::requireNamespace("future", 
[17:39:35.497]                           quietly = TRUE)
[17:39:35.497]                         if (has_future) {
[17:39:35.497]                           ns <- base::getNamespace("future")
[17:39:35.497]                           version <- ns[[".package"]][["version"]]
[17:39:35.497]                           if (is.null(version)) 
[17:39:35.497]                             version <- utils::packageVersion("future")
[17:39:35.497]                         }
[17:39:35.497]                         else {
[17:39:35.497]                           version <- NULL
[17:39:35.497]                         }
[17:39:35.497]                         if (!has_future || version < "1.8.0") {
[17:39:35.497]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.497]                             "", base::R.version$version.string), 
[17:39:35.497]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.497]                               "release", "version")], collapse = " "), 
[17:39:35.497]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.497]                             info)
[17:39:35.497]                           info <- base::paste(info, collapse = "; ")
[17:39:35.497]                           if (!has_future) {
[17:39:35.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.497]                               info)
[17:39:35.497]                           }
[17:39:35.497]                           else {
[17:39:35.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.497]                               info, version)
[17:39:35.497]                           }
[17:39:35.497]                           base::stop(msg)
[17:39:35.497]                         }
[17:39:35.497]                       })
[17:39:35.497]                     }
[17:39:35.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.497]                     base::options(mc.cores = 1L)
[17:39:35.497]                   }
[17:39:35.497]                   ...future.strategy.old <- future::plan("list")
[17:39:35.497]                   options(future.plan = NULL)
[17:39:35.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.497]                 }
[17:39:35.497]                 ...future.workdir <- getwd()
[17:39:35.497]             }
[17:39:35.497]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.497]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.497]         }
[17:39:35.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.497]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.497]             base::names(...future.oldOptions))
[17:39:35.497]     }
[17:39:35.497]     if (FALSE) {
[17:39:35.497]     }
[17:39:35.497]     else {
[17:39:35.497]         if (TRUE) {
[17:39:35.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.497]                 open = "w")
[17:39:35.497]         }
[17:39:35.497]         else {
[17:39:35.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.497]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.497]         }
[17:39:35.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.497]             base::sink(type = "output", split = FALSE)
[17:39:35.497]             base::close(...future.stdout)
[17:39:35.497]         }, add = TRUE)
[17:39:35.497]     }
[17:39:35.497]     ...future.frame <- base::sys.nframe()
[17:39:35.497]     ...future.conditions <- base::list()
[17:39:35.497]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.497]     if (FALSE) {
[17:39:35.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.497]     }
[17:39:35.497]     ...future.result <- base::tryCatch({
[17:39:35.497]         base::withCallingHandlers({
[17:39:35.497]             ...future.value <- base::withVisible(base::local({
[17:39:35.497]                 ...future.makeSendCondition <- base::local({
[17:39:35.497]                   sendCondition <- NULL
[17:39:35.497]                   function(frame = 1L) {
[17:39:35.497]                     if (is.function(sendCondition)) 
[17:39:35.497]                       return(sendCondition)
[17:39:35.497]                     ns <- getNamespace("parallel")
[17:39:35.497]                     if (exists("sendData", mode = "function", 
[17:39:35.497]                       envir = ns)) {
[17:39:35.497]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.497]                         envir = ns)
[17:39:35.497]                       envir <- sys.frame(frame)
[17:39:35.497]                       master <- NULL
[17:39:35.497]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.497]                         !identical(envir, emptyenv())) {
[17:39:35.497]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.497]                           inherits = FALSE)) {
[17:39:35.497]                           master <- get("master", mode = "list", 
[17:39:35.497]                             envir = envir, inherits = FALSE)
[17:39:35.497]                           if (inherits(master, c("SOCKnode", 
[17:39:35.497]                             "SOCK0node"))) {
[17:39:35.497]                             sendCondition <<- function(cond) {
[17:39:35.497]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.497]                                 success = TRUE)
[17:39:35.497]                               parallel_sendData(master, data)
[17:39:35.497]                             }
[17:39:35.497]                             return(sendCondition)
[17:39:35.497]                           }
[17:39:35.497]                         }
[17:39:35.497]                         frame <- frame + 1L
[17:39:35.497]                         envir <- sys.frame(frame)
[17:39:35.497]                       }
[17:39:35.497]                     }
[17:39:35.497]                     sendCondition <<- function(cond) NULL
[17:39:35.497]                   }
[17:39:35.497]                 })
[17:39:35.497]                 withCallingHandlers({
[17:39:35.497]                   NULL
[17:39:35.497]                 }, immediateCondition = function(cond) {
[17:39:35.497]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.497]                   sendCondition(cond)
[17:39:35.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.497]                   {
[17:39:35.497]                     inherits <- base::inherits
[17:39:35.497]                     invokeRestart <- base::invokeRestart
[17:39:35.497]                     is.null <- base::is.null
[17:39:35.497]                     muffled <- FALSE
[17:39:35.497]                     if (inherits(cond, "message")) {
[17:39:35.497]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.497]                       if (muffled) 
[17:39:35.497]                         invokeRestart("muffleMessage")
[17:39:35.497]                     }
[17:39:35.497]                     else if (inherits(cond, "warning")) {
[17:39:35.497]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.497]                       if (muffled) 
[17:39:35.497]                         invokeRestart("muffleWarning")
[17:39:35.497]                     }
[17:39:35.497]                     else if (inherits(cond, "condition")) {
[17:39:35.497]                       if (!is.null(pattern)) {
[17:39:35.497]                         computeRestarts <- base::computeRestarts
[17:39:35.497]                         grepl <- base::grepl
[17:39:35.497]                         restarts <- computeRestarts(cond)
[17:39:35.497]                         for (restart in restarts) {
[17:39:35.497]                           name <- restart$name
[17:39:35.497]                           if (is.null(name)) 
[17:39:35.497]                             next
[17:39:35.497]                           if (!grepl(pattern, name)) 
[17:39:35.497]                             next
[17:39:35.497]                           invokeRestart(restart)
[17:39:35.497]                           muffled <- TRUE
[17:39:35.497]                           break
[17:39:35.497]                         }
[17:39:35.497]                       }
[17:39:35.497]                     }
[17:39:35.497]                     invisible(muffled)
[17:39:35.497]                   }
[17:39:35.497]                   muffleCondition(cond)
[17:39:35.497]                 })
[17:39:35.497]             }))
[17:39:35.497]             future::FutureResult(value = ...future.value$value, 
[17:39:35.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.497]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.497]                     ...future.globalenv.names))
[17:39:35.497]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.497]         }, condition = base::local({
[17:39:35.497]             c <- base::c
[17:39:35.497]             inherits <- base::inherits
[17:39:35.497]             invokeRestart <- base::invokeRestart
[17:39:35.497]             length <- base::length
[17:39:35.497]             list <- base::list
[17:39:35.497]             seq.int <- base::seq.int
[17:39:35.497]             signalCondition <- base::signalCondition
[17:39:35.497]             sys.calls <- base::sys.calls
[17:39:35.497]             `[[` <- base::`[[`
[17:39:35.497]             `+` <- base::`+`
[17:39:35.497]             `<<-` <- base::`<<-`
[17:39:35.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.497]                   3L)]
[17:39:35.497]             }
[17:39:35.497]             function(cond) {
[17:39:35.497]                 is_error <- inherits(cond, "error")
[17:39:35.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.497]                   NULL)
[17:39:35.497]                 if (is_error) {
[17:39:35.497]                   sessionInformation <- function() {
[17:39:35.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.497]                       search = base::search(), system = base::Sys.info())
[17:39:35.497]                   }
[17:39:35.497]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.497]                     cond$call), session = sessionInformation(), 
[17:39:35.497]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.497]                   signalCondition(cond)
[17:39:35.497]                 }
[17:39:35.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.497]                 "immediateCondition"))) {
[17:39:35.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.497]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.497]                   if (TRUE && !signal) {
[17:39:35.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.497]                     {
[17:39:35.497]                       inherits <- base::inherits
[17:39:35.497]                       invokeRestart <- base::invokeRestart
[17:39:35.497]                       is.null <- base::is.null
[17:39:35.497]                       muffled <- FALSE
[17:39:35.497]                       if (inherits(cond, "message")) {
[17:39:35.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.497]                         if (muffled) 
[17:39:35.497]                           invokeRestart("muffleMessage")
[17:39:35.497]                       }
[17:39:35.497]                       else if (inherits(cond, "warning")) {
[17:39:35.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.497]                         if (muffled) 
[17:39:35.497]                           invokeRestart("muffleWarning")
[17:39:35.497]                       }
[17:39:35.497]                       else if (inherits(cond, "condition")) {
[17:39:35.497]                         if (!is.null(pattern)) {
[17:39:35.497]                           computeRestarts <- base::computeRestarts
[17:39:35.497]                           grepl <- base::grepl
[17:39:35.497]                           restarts <- computeRestarts(cond)
[17:39:35.497]                           for (restart in restarts) {
[17:39:35.497]                             name <- restart$name
[17:39:35.497]                             if (is.null(name)) 
[17:39:35.497]                               next
[17:39:35.497]                             if (!grepl(pattern, name)) 
[17:39:35.497]                               next
[17:39:35.497]                             invokeRestart(restart)
[17:39:35.497]                             muffled <- TRUE
[17:39:35.497]                             break
[17:39:35.497]                           }
[17:39:35.497]                         }
[17:39:35.497]                       }
[17:39:35.497]                       invisible(muffled)
[17:39:35.497]                     }
[17:39:35.497]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.497]                   }
[17:39:35.497]                 }
[17:39:35.497]                 else {
[17:39:35.497]                   if (TRUE) {
[17:39:35.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.497]                     {
[17:39:35.497]                       inherits <- base::inherits
[17:39:35.497]                       invokeRestart <- base::invokeRestart
[17:39:35.497]                       is.null <- base::is.null
[17:39:35.497]                       muffled <- FALSE
[17:39:35.497]                       if (inherits(cond, "message")) {
[17:39:35.497]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.497]                         if (muffled) 
[17:39:35.497]                           invokeRestart("muffleMessage")
[17:39:35.497]                       }
[17:39:35.497]                       else if (inherits(cond, "warning")) {
[17:39:35.497]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.497]                         if (muffled) 
[17:39:35.497]                           invokeRestart("muffleWarning")
[17:39:35.497]                       }
[17:39:35.497]                       else if (inherits(cond, "condition")) {
[17:39:35.497]                         if (!is.null(pattern)) {
[17:39:35.497]                           computeRestarts <- base::computeRestarts
[17:39:35.497]                           grepl <- base::grepl
[17:39:35.497]                           restarts <- computeRestarts(cond)
[17:39:35.497]                           for (restart in restarts) {
[17:39:35.497]                             name <- restart$name
[17:39:35.497]                             if (is.null(name)) 
[17:39:35.497]                               next
[17:39:35.497]                             if (!grepl(pattern, name)) 
[17:39:35.497]                               next
[17:39:35.497]                             invokeRestart(restart)
[17:39:35.497]                             muffled <- TRUE
[17:39:35.497]                             break
[17:39:35.497]                           }
[17:39:35.497]                         }
[17:39:35.497]                       }
[17:39:35.497]                       invisible(muffled)
[17:39:35.497]                     }
[17:39:35.497]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.497]                   }
[17:39:35.497]                 }
[17:39:35.497]             }
[17:39:35.497]         }))
[17:39:35.497]     }, error = function(ex) {
[17:39:35.497]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.497]                 ...future.rng), started = ...future.startTime, 
[17:39:35.497]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.497]             version = "1.8"), class = "FutureResult")
[17:39:35.497]     }, finally = {
[17:39:35.497]         if (!identical(...future.workdir, getwd())) 
[17:39:35.497]             setwd(...future.workdir)
[17:39:35.497]         {
[17:39:35.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.497]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.497]             }
[17:39:35.497]             base::options(...future.oldOptions)
[17:39:35.497]             if (.Platform$OS.type == "windows") {
[17:39:35.497]                 old_names <- names(...future.oldEnvVars)
[17:39:35.497]                 envs <- base::Sys.getenv()
[17:39:35.497]                 names <- names(envs)
[17:39:35.497]                 common <- intersect(names, old_names)
[17:39:35.497]                 added <- setdiff(names, old_names)
[17:39:35.497]                 removed <- setdiff(old_names, names)
[17:39:35.497]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.497]                   envs[common]]
[17:39:35.497]                 NAMES <- toupper(changed)
[17:39:35.497]                 args <- list()
[17:39:35.497]                 for (kk in seq_along(NAMES)) {
[17:39:35.497]                   name <- changed[[kk]]
[17:39:35.497]                   NAME <- NAMES[[kk]]
[17:39:35.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.497]                     next
[17:39:35.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.497]                 }
[17:39:35.497]                 NAMES <- toupper(added)
[17:39:35.497]                 for (kk in seq_along(NAMES)) {
[17:39:35.497]                   name <- added[[kk]]
[17:39:35.497]                   NAME <- NAMES[[kk]]
[17:39:35.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.497]                     next
[17:39:35.497]                   args[[name]] <- ""
[17:39:35.497]                 }
[17:39:35.497]                 NAMES <- toupper(removed)
[17:39:35.497]                 for (kk in seq_along(NAMES)) {
[17:39:35.497]                   name <- removed[[kk]]
[17:39:35.497]                   NAME <- NAMES[[kk]]
[17:39:35.497]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.497]                     next
[17:39:35.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.497]                 }
[17:39:35.497]                 if (length(args) > 0) 
[17:39:35.497]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.497]             }
[17:39:35.497]             else {
[17:39:35.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.497]             }
[17:39:35.497]             {
[17:39:35.497]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.497]                   0L) {
[17:39:35.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.497]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.497]                   base::options(opts)
[17:39:35.497]                 }
[17:39:35.497]                 {
[17:39:35.497]                   {
[17:39:35.497]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.497]                     NULL
[17:39:35.497]                   }
[17:39:35.497]                   options(future.plan = NULL)
[17:39:35.497]                   if (is.na(NA_character_)) 
[17:39:35.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.497]                     .init = FALSE)
[17:39:35.497]                 }
[17:39:35.497]             }
[17:39:35.497]         }
[17:39:35.497]     })
[17:39:35.497]     if (TRUE) {
[17:39:35.497]         base::sink(type = "output", split = FALSE)
[17:39:35.497]         if (TRUE) {
[17:39:35.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.497]         }
[17:39:35.497]         else {
[17:39:35.497]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.497]         }
[17:39:35.497]         base::close(...future.stdout)
[17:39:35.497]         ...future.stdout <- NULL
[17:39:35.497]     }
[17:39:35.497]     ...future.result$conditions <- ...future.conditions
[17:39:35.497]     ...future.result$finished <- base::Sys.time()
[17:39:35.497]     ...future.result
[17:39:35.497] }
[17:39:35.500] MultisessionFuture started
[17:39:35.500] - Launch lazy future ... done
[17:39:35.500] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adee1c2098> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0d7f928> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adee1c2098> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0d7f928> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:35.506] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.506] - Validating connection of MultisessionFuture
[17:39:35.506] - received message: FutureResult
[17:39:35.506] - Received FutureResult
[17:39:35.506] - Erased future from FutureRegistry
[17:39:35.506] result() for ClusterFuture ...
[17:39:35.506] - result already collected: FutureResult
[17:39:35.506] result() for ClusterFuture ... done
[17:39:35.506] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.507] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.507] - Validating connection of MultisessionFuture
[17:39:35.507] - received message: FutureResult
[17:39:35.507] - Received FutureResult
[17:39:35.507] - Erased future from FutureRegistry
[17:39:35.507] result() for ClusterFuture ...
[17:39:35.508] - result already collected: FutureResult
[17:39:35.508] result() for ClusterFuture ... done
[17:39:35.508] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:35.509] resolve() on list ...
[17:39:35.510]  recursive: 0
[17:39:35.510]  length: 6
[17:39:35.510]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:35.510] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.510] - nx: 6
[17:39:35.510] - relay: TRUE
[17:39:35.510] - stdout: TRUE
[17:39:35.510] - signal: TRUE
[17:39:35.510] - resignal: FALSE
[17:39:35.510] - force: TRUE
[17:39:35.510] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.510] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.511]  - until=2
[17:39:35.511]  - relaying element #2
[17:39:35.511] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.511] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.511] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.511]  length: 5 (resolved future 1)
[17:39:35.511] Future #2
[17:39:35.511] result() for ClusterFuture ...
[17:39:35.511] - result already collected: FutureResult
[17:39:35.511] result() for ClusterFuture ... done
[17:39:35.512] result() for ClusterFuture ...
[17:39:35.512] - result already collected: FutureResult
[17:39:35.512] result() for ClusterFuture ... done
[17:39:35.512] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:35.512] - nx: 6
[17:39:35.512] - relay: TRUE
[17:39:35.512] - stdout: TRUE
[17:39:35.512] - signal: TRUE
[17:39:35.512] - resignal: FALSE
[17:39:35.512] - force: TRUE
[17:39:35.512] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.512] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.513]  - until=2
[17:39:35.513]  - relaying element #2
[17:39:35.513] result() for ClusterFuture ...
[17:39:35.513] - result already collected: FutureResult
[17:39:35.513] result() for ClusterFuture ... done
[17:39:35.513] result() for ClusterFuture ...
[17:39:35.513] - result already collected: FutureResult
[17:39:35.513] result() for ClusterFuture ... done
[17:39:35.513] result() for ClusterFuture ...
[17:39:35.513] - result already collected: FutureResult
[17:39:35.513] result() for ClusterFuture ... done
[17:39:35.514] result() for ClusterFuture ...
[17:39:35.514] - result already collected: FutureResult
[17:39:35.514] result() for ClusterFuture ... done
[17:39:35.514] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.514] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.514] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:35.514]  length: 4 (resolved future 2)
[17:39:35.514] Future #3
[17:39:35.514] result() for ClusterFuture ...
[17:39:35.514] - result already collected: FutureResult
[17:39:35.514] result() for ClusterFuture ... done
[17:39:35.515] result() for ClusterFuture ...
[17:39:35.515] - result already collected: FutureResult
[17:39:35.515] result() for ClusterFuture ... done
[17:39:35.515] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:35.515] - nx: 6
[17:39:35.515] - relay: TRUE
[17:39:35.515] - stdout: TRUE
[17:39:35.515] - signal: TRUE
[17:39:35.515] - resignal: FALSE
[17:39:35.515] - force: TRUE
[17:39:35.515] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.515] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.516]  - until=3
[17:39:35.516]  - relaying element #3
[17:39:35.516] result() for ClusterFuture ...
[17:39:35.516] - result already collected: FutureResult
[17:39:35.516] result() for ClusterFuture ... done
[17:39:35.516] result() for ClusterFuture ...
[17:39:35.516] - result already collected: FutureResult
[17:39:35.516] result() for ClusterFuture ... done
[17:39:35.516] result() for ClusterFuture ...
[17:39:35.516] - result already collected: FutureResult
[17:39:35.516] result() for ClusterFuture ... done
[17:39:35.517] result() for ClusterFuture ...
[17:39:35.517] - result already collected: FutureResult
[17:39:35.517] result() for ClusterFuture ... done
[17:39:35.517] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.517] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.517] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:35.517]  length: 3 (resolved future 3)
[17:39:35.517] signalConditionsASAP(NULL, pos=4) ...
[17:39:35.517] - nx: 6
[17:39:35.517] - relay: TRUE
[17:39:35.517] - stdout: TRUE
[17:39:35.517] - signal: TRUE
[17:39:35.518] - resignal: FALSE
[17:39:35.518] - force: TRUE
[17:39:35.518] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.518] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.518]  - until=5
[17:39:35.518]  - relaying element #5
[17:39:35.518] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.518] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.518] signalConditionsASAP(NULL, pos=4) ... done
[17:39:35.518]  length: 2 (resolved future 4)
[17:39:35.518] signalConditionsASAP(NULL, pos=5) ...
[17:39:35.518] - nx: 6
[17:39:35.519] - relay: TRUE
[17:39:35.519] - stdout: TRUE
[17:39:35.519] - signal: TRUE
[17:39:35.519] - resignal: FALSE
[17:39:35.519] - force: TRUE
[17:39:35.519] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.519] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.519]  - until=6
[17:39:35.519]  - relaying element #6
[17:39:35.519] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.519] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.519] signalConditionsASAP(NULL, pos=5) ... done
[17:39:35.520]  length: 1 (resolved future 5)
[17:39:35.520] signalConditionsASAP(numeric, pos=6) ...
[17:39:35.520] - nx: 6
[17:39:35.520] - relay: TRUE
[17:39:35.520] - stdout: TRUE
[17:39:35.520] - signal: TRUE
[17:39:35.520] - resignal: FALSE
[17:39:35.520] - force: TRUE
[17:39:35.520] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.520] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.520]  - until=6
[17:39:35.520] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.521] signalConditionsASAP(numeric, pos=6) ... done
[17:39:35.521]  length: 0 (resolved future 6)
[17:39:35.521] Relaying remaining futures
[17:39:35.521] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.521] - nx: 6
[17:39:35.521] - relay: TRUE
[17:39:35.521] - stdout: TRUE
[17:39:35.521] - signal: TRUE
[17:39:35.521] - resignal: FALSE
[17:39:35.521] - force: TRUE
[17:39:35.521] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:35.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.522] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.522] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.522] resolve() on list ... DONE
[17:39:35.522] result() for ClusterFuture ...
[17:39:35.522] - result already collected: FutureResult
[17:39:35.522] result() for ClusterFuture ... done
[17:39:35.522] result() for ClusterFuture ...
[17:39:35.522] - result already collected: FutureResult
[17:39:35.522] result() for ClusterFuture ... done
[17:39:35.523] result() for ClusterFuture ...
[17:39:35.523] - result already collected: FutureResult
[17:39:35.523] result() for ClusterFuture ... done
[17:39:35.523] result() for ClusterFuture ...
[17:39:35.523] - result already collected: FutureResult
[17:39:35.523] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:35.526] getGlobalsAndPackages() ...
[17:39:35.526] Searching for globals...
[17:39:35.527] 
[17:39:35.527] Searching for globals ... DONE
[17:39:35.527] - globals: [0] <none>
[17:39:35.527] getGlobalsAndPackages() ... DONE
[17:39:35.527] run() for ‘Future’ ...
[17:39:35.527] - state: ‘created’
[17:39:35.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.541] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.541]   - Field: ‘node’
[17:39:35.541]   - Field: ‘label’
[17:39:35.541]   - Field: ‘local’
[17:39:35.542]   - Field: ‘owner’
[17:39:35.542]   - Field: ‘envir’
[17:39:35.542]   - Field: ‘workers’
[17:39:35.542]   - Field: ‘packages’
[17:39:35.542]   - Field: ‘gc’
[17:39:35.542]   - Field: ‘conditions’
[17:39:35.542]   - Field: ‘persistent’
[17:39:35.542]   - Field: ‘expr’
[17:39:35.544]   - Field: ‘uuid’
[17:39:35.544]   - Field: ‘seed’
[17:39:35.544]   - Field: ‘version’
[17:39:35.545]   - Field: ‘result’
[17:39:35.545]   - Field: ‘asynchronous’
[17:39:35.545]   - Field: ‘calls’
[17:39:35.545]   - Field: ‘globals’
[17:39:35.545]   - Field: ‘stdout’
[17:39:35.545]   - Field: ‘earlySignal’
[17:39:35.545]   - Field: ‘lazy’
[17:39:35.545]   - Field: ‘state’
[17:39:35.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.545] - Launch lazy future ...
[17:39:35.546] Packages needed by the future expression (n = 0): <none>
[17:39:35.546] Packages needed by future strategies (n = 0): <none>
[17:39:35.546] {
[17:39:35.546]     {
[17:39:35.546]         {
[17:39:35.546]             ...future.startTime <- base::Sys.time()
[17:39:35.546]             {
[17:39:35.546]                 {
[17:39:35.546]                   {
[17:39:35.546]                     {
[17:39:35.546]                       base::local({
[17:39:35.546]                         has_future <- base::requireNamespace("future", 
[17:39:35.546]                           quietly = TRUE)
[17:39:35.546]                         if (has_future) {
[17:39:35.546]                           ns <- base::getNamespace("future")
[17:39:35.546]                           version <- ns[[".package"]][["version"]]
[17:39:35.546]                           if (is.null(version)) 
[17:39:35.546]                             version <- utils::packageVersion("future")
[17:39:35.546]                         }
[17:39:35.546]                         else {
[17:39:35.546]                           version <- NULL
[17:39:35.546]                         }
[17:39:35.546]                         if (!has_future || version < "1.8.0") {
[17:39:35.546]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.546]                             "", base::R.version$version.string), 
[17:39:35.546]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.546]                               "release", "version")], collapse = " "), 
[17:39:35.546]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.546]                             info)
[17:39:35.546]                           info <- base::paste(info, collapse = "; ")
[17:39:35.546]                           if (!has_future) {
[17:39:35.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.546]                               info)
[17:39:35.546]                           }
[17:39:35.546]                           else {
[17:39:35.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.546]                               info, version)
[17:39:35.546]                           }
[17:39:35.546]                           base::stop(msg)
[17:39:35.546]                         }
[17:39:35.546]                       })
[17:39:35.546]                     }
[17:39:35.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.546]                     base::options(mc.cores = 1L)
[17:39:35.546]                   }
[17:39:35.546]                   ...future.strategy.old <- future::plan("list")
[17:39:35.546]                   options(future.plan = NULL)
[17:39:35.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.546]                 }
[17:39:35.546]                 ...future.workdir <- getwd()
[17:39:35.546]             }
[17:39:35.546]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.546]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.546]         }
[17:39:35.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.546]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.546]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.546]             base::names(...future.oldOptions))
[17:39:35.546]     }
[17:39:35.546]     if (FALSE) {
[17:39:35.546]     }
[17:39:35.546]     else {
[17:39:35.546]         if (TRUE) {
[17:39:35.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.546]                 open = "w")
[17:39:35.546]         }
[17:39:35.546]         else {
[17:39:35.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.546]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.546]         }
[17:39:35.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.546]             base::sink(type = "output", split = FALSE)
[17:39:35.546]             base::close(...future.stdout)
[17:39:35.546]         }, add = TRUE)
[17:39:35.546]     }
[17:39:35.546]     ...future.frame <- base::sys.nframe()
[17:39:35.546]     ...future.conditions <- base::list()
[17:39:35.546]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.546]     if (FALSE) {
[17:39:35.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.546]     }
[17:39:35.546]     ...future.result <- base::tryCatch({
[17:39:35.546]         base::withCallingHandlers({
[17:39:35.546]             ...future.value <- base::withVisible(base::local({
[17:39:35.546]                 ...future.makeSendCondition <- base::local({
[17:39:35.546]                   sendCondition <- NULL
[17:39:35.546]                   function(frame = 1L) {
[17:39:35.546]                     if (is.function(sendCondition)) 
[17:39:35.546]                       return(sendCondition)
[17:39:35.546]                     ns <- getNamespace("parallel")
[17:39:35.546]                     if (exists("sendData", mode = "function", 
[17:39:35.546]                       envir = ns)) {
[17:39:35.546]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.546]                         envir = ns)
[17:39:35.546]                       envir <- sys.frame(frame)
[17:39:35.546]                       master <- NULL
[17:39:35.546]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.546]                         !identical(envir, emptyenv())) {
[17:39:35.546]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.546]                           inherits = FALSE)) {
[17:39:35.546]                           master <- get("master", mode = "list", 
[17:39:35.546]                             envir = envir, inherits = FALSE)
[17:39:35.546]                           if (inherits(master, c("SOCKnode", 
[17:39:35.546]                             "SOCK0node"))) {
[17:39:35.546]                             sendCondition <<- function(cond) {
[17:39:35.546]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.546]                                 success = TRUE)
[17:39:35.546]                               parallel_sendData(master, data)
[17:39:35.546]                             }
[17:39:35.546]                             return(sendCondition)
[17:39:35.546]                           }
[17:39:35.546]                         }
[17:39:35.546]                         frame <- frame + 1L
[17:39:35.546]                         envir <- sys.frame(frame)
[17:39:35.546]                       }
[17:39:35.546]                     }
[17:39:35.546]                     sendCondition <<- function(cond) NULL
[17:39:35.546]                   }
[17:39:35.546]                 })
[17:39:35.546]                 withCallingHandlers({
[17:39:35.546]                   2
[17:39:35.546]                 }, immediateCondition = function(cond) {
[17:39:35.546]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.546]                   sendCondition(cond)
[17:39:35.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.546]                   {
[17:39:35.546]                     inherits <- base::inherits
[17:39:35.546]                     invokeRestart <- base::invokeRestart
[17:39:35.546]                     is.null <- base::is.null
[17:39:35.546]                     muffled <- FALSE
[17:39:35.546]                     if (inherits(cond, "message")) {
[17:39:35.546]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.546]                       if (muffled) 
[17:39:35.546]                         invokeRestart("muffleMessage")
[17:39:35.546]                     }
[17:39:35.546]                     else if (inherits(cond, "warning")) {
[17:39:35.546]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.546]                       if (muffled) 
[17:39:35.546]                         invokeRestart("muffleWarning")
[17:39:35.546]                     }
[17:39:35.546]                     else if (inherits(cond, "condition")) {
[17:39:35.546]                       if (!is.null(pattern)) {
[17:39:35.546]                         computeRestarts <- base::computeRestarts
[17:39:35.546]                         grepl <- base::grepl
[17:39:35.546]                         restarts <- computeRestarts(cond)
[17:39:35.546]                         for (restart in restarts) {
[17:39:35.546]                           name <- restart$name
[17:39:35.546]                           if (is.null(name)) 
[17:39:35.546]                             next
[17:39:35.546]                           if (!grepl(pattern, name)) 
[17:39:35.546]                             next
[17:39:35.546]                           invokeRestart(restart)
[17:39:35.546]                           muffled <- TRUE
[17:39:35.546]                           break
[17:39:35.546]                         }
[17:39:35.546]                       }
[17:39:35.546]                     }
[17:39:35.546]                     invisible(muffled)
[17:39:35.546]                   }
[17:39:35.546]                   muffleCondition(cond)
[17:39:35.546]                 })
[17:39:35.546]             }))
[17:39:35.546]             future::FutureResult(value = ...future.value$value, 
[17:39:35.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.546]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.546]                     ...future.globalenv.names))
[17:39:35.546]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.546]         }, condition = base::local({
[17:39:35.546]             c <- base::c
[17:39:35.546]             inherits <- base::inherits
[17:39:35.546]             invokeRestart <- base::invokeRestart
[17:39:35.546]             length <- base::length
[17:39:35.546]             list <- base::list
[17:39:35.546]             seq.int <- base::seq.int
[17:39:35.546]             signalCondition <- base::signalCondition
[17:39:35.546]             sys.calls <- base::sys.calls
[17:39:35.546]             `[[` <- base::`[[`
[17:39:35.546]             `+` <- base::`+`
[17:39:35.546]             `<<-` <- base::`<<-`
[17:39:35.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.546]                   3L)]
[17:39:35.546]             }
[17:39:35.546]             function(cond) {
[17:39:35.546]                 is_error <- inherits(cond, "error")
[17:39:35.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.546]                   NULL)
[17:39:35.546]                 if (is_error) {
[17:39:35.546]                   sessionInformation <- function() {
[17:39:35.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.546]                       search = base::search(), system = base::Sys.info())
[17:39:35.546]                   }
[17:39:35.546]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.546]                     cond$call), session = sessionInformation(), 
[17:39:35.546]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.546]                   signalCondition(cond)
[17:39:35.546]                 }
[17:39:35.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.546]                 "immediateCondition"))) {
[17:39:35.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.546]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.546]                   if (TRUE && !signal) {
[17:39:35.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.546]                     {
[17:39:35.546]                       inherits <- base::inherits
[17:39:35.546]                       invokeRestart <- base::invokeRestart
[17:39:35.546]                       is.null <- base::is.null
[17:39:35.546]                       muffled <- FALSE
[17:39:35.546]                       if (inherits(cond, "message")) {
[17:39:35.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.546]                         if (muffled) 
[17:39:35.546]                           invokeRestart("muffleMessage")
[17:39:35.546]                       }
[17:39:35.546]                       else if (inherits(cond, "warning")) {
[17:39:35.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.546]                         if (muffled) 
[17:39:35.546]                           invokeRestart("muffleWarning")
[17:39:35.546]                       }
[17:39:35.546]                       else if (inherits(cond, "condition")) {
[17:39:35.546]                         if (!is.null(pattern)) {
[17:39:35.546]                           computeRestarts <- base::computeRestarts
[17:39:35.546]                           grepl <- base::grepl
[17:39:35.546]                           restarts <- computeRestarts(cond)
[17:39:35.546]                           for (restart in restarts) {
[17:39:35.546]                             name <- restart$name
[17:39:35.546]                             if (is.null(name)) 
[17:39:35.546]                               next
[17:39:35.546]                             if (!grepl(pattern, name)) 
[17:39:35.546]                               next
[17:39:35.546]                             invokeRestart(restart)
[17:39:35.546]                             muffled <- TRUE
[17:39:35.546]                             break
[17:39:35.546]                           }
[17:39:35.546]                         }
[17:39:35.546]                       }
[17:39:35.546]                       invisible(muffled)
[17:39:35.546]                     }
[17:39:35.546]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.546]                   }
[17:39:35.546]                 }
[17:39:35.546]                 else {
[17:39:35.546]                   if (TRUE) {
[17:39:35.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.546]                     {
[17:39:35.546]                       inherits <- base::inherits
[17:39:35.546]                       invokeRestart <- base::invokeRestart
[17:39:35.546]                       is.null <- base::is.null
[17:39:35.546]                       muffled <- FALSE
[17:39:35.546]                       if (inherits(cond, "message")) {
[17:39:35.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.546]                         if (muffled) 
[17:39:35.546]                           invokeRestart("muffleMessage")
[17:39:35.546]                       }
[17:39:35.546]                       else if (inherits(cond, "warning")) {
[17:39:35.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.546]                         if (muffled) 
[17:39:35.546]                           invokeRestart("muffleWarning")
[17:39:35.546]                       }
[17:39:35.546]                       else if (inherits(cond, "condition")) {
[17:39:35.546]                         if (!is.null(pattern)) {
[17:39:35.546]                           computeRestarts <- base::computeRestarts
[17:39:35.546]                           grepl <- base::grepl
[17:39:35.546]                           restarts <- computeRestarts(cond)
[17:39:35.546]                           for (restart in restarts) {
[17:39:35.546]                             name <- restart$name
[17:39:35.546]                             if (is.null(name)) 
[17:39:35.546]                               next
[17:39:35.546]                             if (!grepl(pattern, name)) 
[17:39:35.546]                               next
[17:39:35.546]                             invokeRestart(restart)
[17:39:35.546]                             muffled <- TRUE
[17:39:35.546]                             break
[17:39:35.546]                           }
[17:39:35.546]                         }
[17:39:35.546]                       }
[17:39:35.546]                       invisible(muffled)
[17:39:35.546]                     }
[17:39:35.546]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.546]                   }
[17:39:35.546]                 }
[17:39:35.546]             }
[17:39:35.546]         }))
[17:39:35.546]     }, error = function(ex) {
[17:39:35.546]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.546]                 ...future.rng), started = ...future.startTime, 
[17:39:35.546]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.546]             version = "1.8"), class = "FutureResult")
[17:39:35.546]     }, finally = {
[17:39:35.546]         if (!identical(...future.workdir, getwd())) 
[17:39:35.546]             setwd(...future.workdir)
[17:39:35.546]         {
[17:39:35.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.546]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.546]             }
[17:39:35.546]             base::options(...future.oldOptions)
[17:39:35.546]             if (.Platform$OS.type == "windows") {
[17:39:35.546]                 old_names <- names(...future.oldEnvVars)
[17:39:35.546]                 envs <- base::Sys.getenv()
[17:39:35.546]                 names <- names(envs)
[17:39:35.546]                 common <- intersect(names, old_names)
[17:39:35.546]                 added <- setdiff(names, old_names)
[17:39:35.546]                 removed <- setdiff(old_names, names)
[17:39:35.546]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.546]                   envs[common]]
[17:39:35.546]                 NAMES <- toupper(changed)
[17:39:35.546]                 args <- list()
[17:39:35.546]                 for (kk in seq_along(NAMES)) {
[17:39:35.546]                   name <- changed[[kk]]
[17:39:35.546]                   NAME <- NAMES[[kk]]
[17:39:35.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.546]                     next
[17:39:35.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.546]                 }
[17:39:35.546]                 NAMES <- toupper(added)
[17:39:35.546]                 for (kk in seq_along(NAMES)) {
[17:39:35.546]                   name <- added[[kk]]
[17:39:35.546]                   NAME <- NAMES[[kk]]
[17:39:35.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.546]                     next
[17:39:35.546]                   args[[name]] <- ""
[17:39:35.546]                 }
[17:39:35.546]                 NAMES <- toupper(removed)
[17:39:35.546]                 for (kk in seq_along(NAMES)) {
[17:39:35.546]                   name <- removed[[kk]]
[17:39:35.546]                   NAME <- NAMES[[kk]]
[17:39:35.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.546]                     next
[17:39:35.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.546]                 }
[17:39:35.546]                 if (length(args) > 0) 
[17:39:35.546]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.546]             }
[17:39:35.546]             else {
[17:39:35.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.546]             }
[17:39:35.546]             {
[17:39:35.546]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.546]                   0L) {
[17:39:35.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.546]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.546]                   base::options(opts)
[17:39:35.546]                 }
[17:39:35.546]                 {
[17:39:35.546]                   {
[17:39:35.546]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.546]                     NULL
[17:39:35.546]                   }
[17:39:35.546]                   options(future.plan = NULL)
[17:39:35.546]                   if (is.na(NA_character_)) 
[17:39:35.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.546]                     .init = FALSE)
[17:39:35.546]                 }
[17:39:35.546]             }
[17:39:35.546]         }
[17:39:35.546]     })
[17:39:35.546]     if (TRUE) {
[17:39:35.546]         base::sink(type = "output", split = FALSE)
[17:39:35.546]         if (TRUE) {
[17:39:35.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.546]         }
[17:39:35.546]         else {
[17:39:35.546]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.546]         }
[17:39:35.546]         base::close(...future.stdout)
[17:39:35.546]         ...future.stdout <- NULL
[17:39:35.546]     }
[17:39:35.546]     ...future.result$conditions <- ...future.conditions
[17:39:35.546]     ...future.result$finished <- base::Sys.time()
[17:39:35.546]     ...future.result
[17:39:35.546] }
[17:39:35.549] MultisessionFuture started
[17:39:35.549] - Launch lazy future ... done
[17:39:35.549] run() for ‘MultisessionFuture’ ... done
[17:39:35.550] getGlobalsAndPackages() ...
[17:39:35.550] Searching for globals...
[17:39:35.550] 
[17:39:35.550] Searching for globals ... DONE
[17:39:35.550] - globals: [0] <none>
[17:39:35.551] getGlobalsAndPackages() ... DONE
[17:39:35.551] run() for ‘Future’ ...
[17:39:35.551] - state: ‘created’
[17:39:35.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.565] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:35.566]   - Field: ‘node’
[17:39:35.566]   - Field: ‘label’
[17:39:35.566]   - Field: ‘local’
[17:39:35.566]   - Field: ‘owner’
[17:39:35.566]   - Field: ‘envir’
[17:39:35.566]   - Field: ‘workers’
[17:39:35.566]   - Field: ‘packages’
[17:39:35.566]   - Field: ‘gc’
[17:39:35.566]   - Field: ‘conditions’
[17:39:35.567]   - Field: ‘persistent’
[17:39:35.567]   - Field: ‘expr’
[17:39:35.567]   - Field: ‘uuid’
[17:39:35.567]   - Field: ‘seed’
[17:39:35.567]   - Field: ‘version’
[17:39:35.567]   - Field: ‘result’
[17:39:35.567]   - Field: ‘asynchronous’
[17:39:35.567]   - Field: ‘calls’
[17:39:35.567]   - Field: ‘globals’
[17:39:35.567]   - Field: ‘stdout’
[17:39:35.567]   - Field: ‘earlySignal’
[17:39:35.567]   - Field: ‘lazy’
[17:39:35.568]   - Field: ‘state’
[17:39:35.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:35.568] - Launch lazy future ...
[17:39:35.568] Packages needed by the future expression (n = 0): <none>
[17:39:35.568] Packages needed by future strategies (n = 0): <none>
[17:39:35.569] {
[17:39:35.569]     {
[17:39:35.569]         {
[17:39:35.569]             ...future.startTime <- base::Sys.time()
[17:39:35.569]             {
[17:39:35.569]                 {
[17:39:35.569]                   {
[17:39:35.569]                     {
[17:39:35.569]                       base::local({
[17:39:35.569]                         has_future <- base::requireNamespace("future", 
[17:39:35.569]                           quietly = TRUE)
[17:39:35.569]                         if (has_future) {
[17:39:35.569]                           ns <- base::getNamespace("future")
[17:39:35.569]                           version <- ns[[".package"]][["version"]]
[17:39:35.569]                           if (is.null(version)) 
[17:39:35.569]                             version <- utils::packageVersion("future")
[17:39:35.569]                         }
[17:39:35.569]                         else {
[17:39:35.569]                           version <- NULL
[17:39:35.569]                         }
[17:39:35.569]                         if (!has_future || version < "1.8.0") {
[17:39:35.569]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.569]                             "", base::R.version$version.string), 
[17:39:35.569]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.569]                               "release", "version")], collapse = " "), 
[17:39:35.569]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.569]                             info)
[17:39:35.569]                           info <- base::paste(info, collapse = "; ")
[17:39:35.569]                           if (!has_future) {
[17:39:35.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.569]                               info)
[17:39:35.569]                           }
[17:39:35.569]                           else {
[17:39:35.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.569]                               info, version)
[17:39:35.569]                           }
[17:39:35.569]                           base::stop(msg)
[17:39:35.569]                         }
[17:39:35.569]                       })
[17:39:35.569]                     }
[17:39:35.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.569]                     base::options(mc.cores = 1L)
[17:39:35.569]                   }
[17:39:35.569]                   ...future.strategy.old <- future::plan("list")
[17:39:35.569]                   options(future.plan = NULL)
[17:39:35.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.569]                 }
[17:39:35.569]                 ...future.workdir <- getwd()
[17:39:35.569]             }
[17:39:35.569]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.569]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.569]         }
[17:39:35.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.569]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.569]             base::names(...future.oldOptions))
[17:39:35.569]     }
[17:39:35.569]     if (FALSE) {
[17:39:35.569]     }
[17:39:35.569]     else {
[17:39:35.569]         if (TRUE) {
[17:39:35.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.569]                 open = "w")
[17:39:35.569]         }
[17:39:35.569]         else {
[17:39:35.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.569]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.569]         }
[17:39:35.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.569]             base::sink(type = "output", split = FALSE)
[17:39:35.569]             base::close(...future.stdout)
[17:39:35.569]         }, add = TRUE)
[17:39:35.569]     }
[17:39:35.569]     ...future.frame <- base::sys.nframe()
[17:39:35.569]     ...future.conditions <- base::list()
[17:39:35.569]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.569]     if (FALSE) {
[17:39:35.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.569]     }
[17:39:35.569]     ...future.result <- base::tryCatch({
[17:39:35.569]         base::withCallingHandlers({
[17:39:35.569]             ...future.value <- base::withVisible(base::local({
[17:39:35.569]                 ...future.makeSendCondition <- base::local({
[17:39:35.569]                   sendCondition <- NULL
[17:39:35.569]                   function(frame = 1L) {
[17:39:35.569]                     if (is.function(sendCondition)) 
[17:39:35.569]                       return(sendCondition)
[17:39:35.569]                     ns <- getNamespace("parallel")
[17:39:35.569]                     if (exists("sendData", mode = "function", 
[17:39:35.569]                       envir = ns)) {
[17:39:35.569]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:35.569]                         envir = ns)
[17:39:35.569]                       envir <- sys.frame(frame)
[17:39:35.569]                       master <- NULL
[17:39:35.569]                       while (!identical(envir, .GlobalEnv) && 
[17:39:35.569]                         !identical(envir, emptyenv())) {
[17:39:35.569]                         if (exists("master", mode = "list", envir = envir, 
[17:39:35.569]                           inherits = FALSE)) {
[17:39:35.569]                           master <- get("master", mode = "list", 
[17:39:35.569]                             envir = envir, inherits = FALSE)
[17:39:35.569]                           if (inherits(master, c("SOCKnode", 
[17:39:35.569]                             "SOCK0node"))) {
[17:39:35.569]                             sendCondition <<- function(cond) {
[17:39:35.569]                               data <- list(type = "VALUE", value = cond, 
[17:39:35.569]                                 success = TRUE)
[17:39:35.569]                               parallel_sendData(master, data)
[17:39:35.569]                             }
[17:39:35.569]                             return(sendCondition)
[17:39:35.569]                           }
[17:39:35.569]                         }
[17:39:35.569]                         frame <- frame + 1L
[17:39:35.569]                         envir <- sys.frame(frame)
[17:39:35.569]                       }
[17:39:35.569]                     }
[17:39:35.569]                     sendCondition <<- function(cond) NULL
[17:39:35.569]                   }
[17:39:35.569]                 })
[17:39:35.569]                 withCallingHandlers({
[17:39:35.569]                   NULL
[17:39:35.569]                 }, immediateCondition = function(cond) {
[17:39:35.569]                   sendCondition <- ...future.makeSendCondition()
[17:39:35.569]                   sendCondition(cond)
[17:39:35.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.569]                   {
[17:39:35.569]                     inherits <- base::inherits
[17:39:35.569]                     invokeRestart <- base::invokeRestart
[17:39:35.569]                     is.null <- base::is.null
[17:39:35.569]                     muffled <- FALSE
[17:39:35.569]                     if (inherits(cond, "message")) {
[17:39:35.569]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.569]                       if (muffled) 
[17:39:35.569]                         invokeRestart("muffleMessage")
[17:39:35.569]                     }
[17:39:35.569]                     else if (inherits(cond, "warning")) {
[17:39:35.569]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.569]                       if (muffled) 
[17:39:35.569]                         invokeRestart("muffleWarning")
[17:39:35.569]                     }
[17:39:35.569]                     else if (inherits(cond, "condition")) {
[17:39:35.569]                       if (!is.null(pattern)) {
[17:39:35.569]                         computeRestarts <- base::computeRestarts
[17:39:35.569]                         grepl <- base::grepl
[17:39:35.569]                         restarts <- computeRestarts(cond)
[17:39:35.569]                         for (restart in restarts) {
[17:39:35.569]                           name <- restart$name
[17:39:35.569]                           if (is.null(name)) 
[17:39:35.569]                             next
[17:39:35.569]                           if (!grepl(pattern, name)) 
[17:39:35.569]                             next
[17:39:35.569]                           invokeRestart(restart)
[17:39:35.569]                           muffled <- TRUE
[17:39:35.569]                           break
[17:39:35.569]                         }
[17:39:35.569]                       }
[17:39:35.569]                     }
[17:39:35.569]                     invisible(muffled)
[17:39:35.569]                   }
[17:39:35.569]                   muffleCondition(cond)
[17:39:35.569]                 })
[17:39:35.569]             }))
[17:39:35.569]             future::FutureResult(value = ...future.value$value, 
[17:39:35.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.569]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.569]                     ...future.globalenv.names))
[17:39:35.569]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.569]         }, condition = base::local({
[17:39:35.569]             c <- base::c
[17:39:35.569]             inherits <- base::inherits
[17:39:35.569]             invokeRestart <- base::invokeRestart
[17:39:35.569]             length <- base::length
[17:39:35.569]             list <- base::list
[17:39:35.569]             seq.int <- base::seq.int
[17:39:35.569]             signalCondition <- base::signalCondition
[17:39:35.569]             sys.calls <- base::sys.calls
[17:39:35.569]             `[[` <- base::`[[`
[17:39:35.569]             `+` <- base::`+`
[17:39:35.569]             `<<-` <- base::`<<-`
[17:39:35.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.569]                   3L)]
[17:39:35.569]             }
[17:39:35.569]             function(cond) {
[17:39:35.569]                 is_error <- inherits(cond, "error")
[17:39:35.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.569]                   NULL)
[17:39:35.569]                 if (is_error) {
[17:39:35.569]                   sessionInformation <- function() {
[17:39:35.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.569]                       search = base::search(), system = base::Sys.info())
[17:39:35.569]                   }
[17:39:35.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.569]                     cond$call), session = sessionInformation(), 
[17:39:35.569]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.569]                   signalCondition(cond)
[17:39:35.569]                 }
[17:39:35.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.569]                 "immediateCondition"))) {
[17:39:35.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.569]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.569]                   if (TRUE && !signal) {
[17:39:35.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.569]                     {
[17:39:35.569]                       inherits <- base::inherits
[17:39:35.569]                       invokeRestart <- base::invokeRestart
[17:39:35.569]                       is.null <- base::is.null
[17:39:35.569]                       muffled <- FALSE
[17:39:35.569]                       if (inherits(cond, "message")) {
[17:39:35.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.569]                         if (muffled) 
[17:39:35.569]                           invokeRestart("muffleMessage")
[17:39:35.569]                       }
[17:39:35.569]                       else if (inherits(cond, "warning")) {
[17:39:35.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.569]                         if (muffled) 
[17:39:35.569]                           invokeRestart("muffleWarning")
[17:39:35.569]                       }
[17:39:35.569]                       else if (inherits(cond, "condition")) {
[17:39:35.569]                         if (!is.null(pattern)) {
[17:39:35.569]                           computeRestarts <- base::computeRestarts
[17:39:35.569]                           grepl <- base::grepl
[17:39:35.569]                           restarts <- computeRestarts(cond)
[17:39:35.569]                           for (restart in restarts) {
[17:39:35.569]                             name <- restart$name
[17:39:35.569]                             if (is.null(name)) 
[17:39:35.569]                               next
[17:39:35.569]                             if (!grepl(pattern, name)) 
[17:39:35.569]                               next
[17:39:35.569]                             invokeRestart(restart)
[17:39:35.569]                             muffled <- TRUE
[17:39:35.569]                             break
[17:39:35.569]                           }
[17:39:35.569]                         }
[17:39:35.569]                       }
[17:39:35.569]                       invisible(muffled)
[17:39:35.569]                     }
[17:39:35.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.569]                   }
[17:39:35.569]                 }
[17:39:35.569]                 else {
[17:39:35.569]                   if (TRUE) {
[17:39:35.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.569]                     {
[17:39:35.569]                       inherits <- base::inherits
[17:39:35.569]                       invokeRestart <- base::invokeRestart
[17:39:35.569]                       is.null <- base::is.null
[17:39:35.569]                       muffled <- FALSE
[17:39:35.569]                       if (inherits(cond, "message")) {
[17:39:35.569]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.569]                         if (muffled) 
[17:39:35.569]                           invokeRestart("muffleMessage")
[17:39:35.569]                       }
[17:39:35.569]                       else if (inherits(cond, "warning")) {
[17:39:35.569]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.569]                         if (muffled) 
[17:39:35.569]                           invokeRestart("muffleWarning")
[17:39:35.569]                       }
[17:39:35.569]                       else if (inherits(cond, "condition")) {
[17:39:35.569]                         if (!is.null(pattern)) {
[17:39:35.569]                           computeRestarts <- base::computeRestarts
[17:39:35.569]                           grepl <- base::grepl
[17:39:35.569]                           restarts <- computeRestarts(cond)
[17:39:35.569]                           for (restart in restarts) {
[17:39:35.569]                             name <- restart$name
[17:39:35.569]                             if (is.null(name)) 
[17:39:35.569]                               next
[17:39:35.569]                             if (!grepl(pattern, name)) 
[17:39:35.569]                               next
[17:39:35.569]                             invokeRestart(restart)
[17:39:35.569]                             muffled <- TRUE
[17:39:35.569]                             break
[17:39:35.569]                           }
[17:39:35.569]                         }
[17:39:35.569]                       }
[17:39:35.569]                       invisible(muffled)
[17:39:35.569]                     }
[17:39:35.569]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.569]                   }
[17:39:35.569]                 }
[17:39:35.569]             }
[17:39:35.569]         }))
[17:39:35.569]     }, error = function(ex) {
[17:39:35.569]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.569]                 ...future.rng), started = ...future.startTime, 
[17:39:35.569]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.569]             version = "1.8"), class = "FutureResult")
[17:39:35.569]     }, finally = {
[17:39:35.569]         if (!identical(...future.workdir, getwd())) 
[17:39:35.569]             setwd(...future.workdir)
[17:39:35.569]         {
[17:39:35.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.569]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.569]             }
[17:39:35.569]             base::options(...future.oldOptions)
[17:39:35.569]             if (.Platform$OS.type == "windows") {
[17:39:35.569]                 old_names <- names(...future.oldEnvVars)
[17:39:35.569]                 envs <- base::Sys.getenv()
[17:39:35.569]                 names <- names(envs)
[17:39:35.569]                 common <- intersect(names, old_names)
[17:39:35.569]                 added <- setdiff(names, old_names)
[17:39:35.569]                 removed <- setdiff(old_names, names)
[17:39:35.569]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.569]                   envs[common]]
[17:39:35.569]                 NAMES <- toupper(changed)
[17:39:35.569]                 args <- list()
[17:39:35.569]                 for (kk in seq_along(NAMES)) {
[17:39:35.569]                   name <- changed[[kk]]
[17:39:35.569]                   NAME <- NAMES[[kk]]
[17:39:35.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.569]                     next
[17:39:35.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.569]                 }
[17:39:35.569]                 NAMES <- toupper(added)
[17:39:35.569]                 for (kk in seq_along(NAMES)) {
[17:39:35.569]                   name <- added[[kk]]
[17:39:35.569]                   NAME <- NAMES[[kk]]
[17:39:35.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.569]                     next
[17:39:35.569]                   args[[name]] <- ""
[17:39:35.569]                 }
[17:39:35.569]                 NAMES <- toupper(removed)
[17:39:35.569]                 for (kk in seq_along(NAMES)) {
[17:39:35.569]                   name <- removed[[kk]]
[17:39:35.569]                   NAME <- NAMES[[kk]]
[17:39:35.569]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.569]                     next
[17:39:35.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.569]                 }
[17:39:35.569]                 if (length(args) > 0) 
[17:39:35.569]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.569]             }
[17:39:35.569]             else {
[17:39:35.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.569]             }
[17:39:35.569]             {
[17:39:35.569]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.569]                   0L) {
[17:39:35.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.569]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.569]                   base::options(opts)
[17:39:35.569]                 }
[17:39:35.569]                 {
[17:39:35.569]                   {
[17:39:35.569]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.569]                     NULL
[17:39:35.569]                   }
[17:39:35.569]                   options(future.plan = NULL)
[17:39:35.569]                   if (is.na(NA_character_)) 
[17:39:35.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.569]                     .init = FALSE)
[17:39:35.569]                 }
[17:39:35.569]             }
[17:39:35.569]         }
[17:39:35.569]     })
[17:39:35.569]     if (TRUE) {
[17:39:35.569]         base::sink(type = "output", split = FALSE)
[17:39:35.569]         if (TRUE) {
[17:39:35.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.569]         }
[17:39:35.569]         else {
[17:39:35.569]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.569]         }
[17:39:35.569]         base::close(...future.stdout)
[17:39:35.569]         ...future.stdout <- NULL
[17:39:35.569]     }
[17:39:35.569]     ...future.result$conditions <- ...future.conditions
[17:39:35.569]     ...future.result$finished <- base::Sys.time()
[17:39:35.569]     ...future.result
[17:39:35.569] }
[17:39:35.571] MultisessionFuture started
[17:39:35.571] - Launch lazy future ... done
[17:39:35.572] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf22d7e80> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0903c88> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf22d7e80> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55adf0903c88> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:35.577] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.577] - Validating connection of MultisessionFuture
[17:39:35.577] - received message: FutureResult
[17:39:35.578] - Received FutureResult
[17:39:35.578] - Erased future from FutureRegistry
[17:39:35.578] result() for ClusterFuture ...
[17:39:35.578] - result already collected: FutureResult
[17:39:35.578] result() for ClusterFuture ... done
[17:39:35.578] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:35.578] receiveMessageFromWorker() for ClusterFuture ...
[17:39:35.579] - Validating connection of MultisessionFuture
[17:39:35.579] - received message: FutureResult
[17:39:35.579] - Received FutureResult
[17:39:35.579] - Erased future from FutureRegistry
[17:39:35.579] result() for ClusterFuture ...
[17:39:35.579] - result already collected: FutureResult
[17:39:35.579] result() for ClusterFuture ... done
[17:39:35.579] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:39:35.581] resolve() on list ...
[17:39:35.581]  recursive: 0
[17:39:35.581]  length: 6
[17:39:35.582]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:39:35.582] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.582] - nx: 6
[17:39:35.582] - relay: TRUE
[17:39:35.582] - stdout: TRUE
[17:39:35.582] - signal: TRUE
[17:39:35.582] - resignal: FALSE
[17:39:35.582] - force: TRUE
[17:39:35.582] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.582] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.582]  - until=2
[17:39:35.583]  - relaying element #2
[17:39:35.583] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.583] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.583] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.583]  length: 5 (resolved future 1)
[17:39:35.583] Future #2
[17:39:35.583] result() for ClusterFuture ...
[17:39:35.583] - result already collected: FutureResult
[17:39:35.583] result() for ClusterFuture ... done
[17:39:35.583] result() for ClusterFuture ...
[17:39:35.583] - result already collected: FutureResult
[17:39:35.584] result() for ClusterFuture ... done
[17:39:35.584] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:35.584] - nx: 6
[17:39:35.584] - relay: TRUE
[17:39:35.584] - stdout: TRUE
[17:39:35.584] - signal: TRUE
[17:39:35.584] - resignal: FALSE
[17:39:35.584] - force: TRUE
[17:39:35.584] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.584] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:35.584]  - until=2
[17:39:35.585]  - relaying element #2
[17:39:35.585] result() for ClusterFuture ...
[17:39:35.585] - result already collected: FutureResult
[17:39:35.585] result() for ClusterFuture ... done
[17:39:35.585] result() for ClusterFuture ...
[17:39:35.585] - result already collected: FutureResult
[17:39:35.585] result() for ClusterFuture ... done
[17:39:35.585] result() for ClusterFuture ...
[17:39:35.585] - result already collected: FutureResult
[17:39:35.585] result() for ClusterFuture ... done
[17:39:35.585] result() for ClusterFuture ...
[17:39:35.586] - result already collected: FutureResult
[17:39:35.586] result() for ClusterFuture ... done
[17:39:35.586] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.586] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.586] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:35.586]  length: 4 (resolved future 2)
[17:39:35.586] Future #3
[17:39:35.586] result() for ClusterFuture ...
[17:39:35.586] - result already collected: FutureResult
[17:39:35.586] result() for ClusterFuture ... done
[17:39:35.586] result() for ClusterFuture ...
[17:39:35.587] - result already collected: FutureResult
[17:39:35.587] result() for ClusterFuture ... done
[17:39:35.587] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:35.587] - nx: 6
[17:39:35.587] - relay: TRUE
[17:39:35.587] - stdout: TRUE
[17:39:35.587] - signal: TRUE
[17:39:35.587] - resignal: FALSE
[17:39:35.587] - force: TRUE
[17:39:35.587] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.587] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:35.587]  - until=3
[17:39:35.587]  - relaying element #3
[17:39:35.588] result() for ClusterFuture ...
[17:39:35.588] - result already collected: FutureResult
[17:39:35.588] result() for ClusterFuture ... done
[17:39:35.588] result() for ClusterFuture ...
[17:39:35.588] - result already collected: FutureResult
[17:39:35.588] result() for ClusterFuture ... done
[17:39:35.588] result() for ClusterFuture ...
[17:39:35.588] - result already collected: FutureResult
[17:39:35.588] result() for ClusterFuture ... done
[17:39:35.588] result() for ClusterFuture ...
[17:39:35.588] - result already collected: FutureResult
[17:39:35.589] result() for ClusterFuture ... done
[17:39:35.589] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.589] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.589] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:35.589]  length: 3 (resolved future 3)
[17:39:35.589] signalConditionsASAP(NULL, pos=4) ...
[17:39:35.589] - nx: 6
[17:39:35.589] - relay: TRUE
[17:39:35.589] - stdout: TRUE
[17:39:35.589] - signal: TRUE
[17:39:35.589] - resignal: FALSE
[17:39:35.589] - force: TRUE
[17:39:35.590] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.590]  - until=5
[17:39:35.590]  - relaying element #5
[17:39:35.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.590] signalConditionsASAP(NULL, pos=4) ... done
[17:39:35.590]  length: 2 (resolved future 4)
[17:39:35.590] signalConditionsASAP(NULL, pos=5) ...
[17:39:35.590] - nx: 6
[17:39:35.590] - relay: TRUE
[17:39:35.590] - stdout: TRUE
[17:39:35.591] - signal: TRUE
[17:39:35.591] - resignal: FALSE
[17:39:35.591] - force: TRUE
[17:39:35.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:35.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.591]  - until=6
[17:39:35.591]  - relaying element #6
[17:39:35.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.591] signalConditionsASAP(NULL, pos=5) ... done
[17:39:35.591]  length: 1 (resolved future 5)
[17:39:35.591] signalConditionsASAP(numeric, pos=6) ...
[17:39:35.592] - nx: 6
[17:39:35.592] - relay: TRUE
[17:39:35.592] - stdout: TRUE
[17:39:35.592] - signal: TRUE
[17:39:35.592] - resignal: FALSE
[17:39:35.592] - force: TRUE
[17:39:35.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:35.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.592]  - until=6
[17:39:35.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.592] signalConditionsASAP(numeric, pos=6) ... done
[17:39:35.593]  length: 0 (resolved future 6)
[17:39:35.593] Relaying remaining futures
[17:39:35.593] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.593] - nx: 6
[17:39:35.593] - relay: TRUE
[17:39:35.593] - stdout: TRUE
[17:39:35.593] - signal: TRUE
[17:39:35.593] - resignal: FALSE
[17:39:35.593] - force: TRUE
[17:39:35.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:39:35.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:35.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:35.594] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.594] resolve() on list ... DONE
[17:39:35.594] result() for ClusterFuture ...
[17:39:35.594] - result already collected: FutureResult
[17:39:35.594] result() for ClusterFuture ... done
[17:39:35.594] result() for ClusterFuture ...
[17:39:35.594] - result already collected: FutureResult
[17:39:35.594] result() for ClusterFuture ... done
[17:39:35.594] result() for ClusterFuture ...
[17:39:35.594] - result already collected: FutureResult
[17:39:35.595] result() for ClusterFuture ... done
[17:39:35.595] result() for ClusterFuture ...
[17:39:35.595] - result already collected: FutureResult
[17:39:35.595] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[17:39:35.599] plan(): Setting new future strategy stack:
[17:39:35.599] List of future strategies:
[17:39:35.599] 1. multicore:
[17:39:35.599]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.599]    - tweaked: FALSE
[17:39:35.599]    - call: plan(strategy)
[17:39:35.607] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:35.608] getGlobalsAndPackages() ...
[17:39:35.608] Searching for globals...
[17:39:35.608] 
[17:39:35.608] Searching for globals ... DONE
[17:39:35.608] - globals: [0] <none>
[17:39:35.608] getGlobalsAndPackages() ... DONE
[17:39:35.609] run() for ‘Future’ ...
[17:39:35.609] - state: ‘created’
[17:39:35.609] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.612] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.612]   - Field: ‘label’
[17:39:35.613]   - Field: ‘local’
[17:39:35.613]   - Field: ‘owner’
[17:39:35.613]   - Field: ‘envir’
[17:39:35.613]   - Field: ‘workers’
[17:39:35.613]   - Field: ‘packages’
[17:39:35.613]   - Field: ‘gc’
[17:39:35.613]   - Field: ‘job’
[17:39:35.613]   - Field: ‘conditions’
[17:39:35.613]   - Field: ‘expr’
[17:39:35.613]   - Field: ‘uuid’
[17:39:35.613]   - Field: ‘seed’
[17:39:35.614]   - Field: ‘version’
[17:39:35.614]   - Field: ‘result’
[17:39:35.614]   - Field: ‘asynchronous’
[17:39:35.614]   - Field: ‘calls’
[17:39:35.614]   - Field: ‘globals’
[17:39:35.614]   - Field: ‘stdout’
[17:39:35.614]   - Field: ‘earlySignal’
[17:39:35.614]   - Field: ‘lazy’
[17:39:35.614]   - Field: ‘state’
[17:39:35.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.614] - Launch lazy future ...
[17:39:35.615] Packages needed by the future expression (n = 0): <none>
[17:39:35.615] Packages needed by future strategies (n = 0): <none>
[17:39:35.615] {
[17:39:35.615]     {
[17:39:35.615]         {
[17:39:35.615]             ...future.startTime <- base::Sys.time()
[17:39:35.615]             {
[17:39:35.615]                 {
[17:39:35.615]                   {
[17:39:35.615]                     {
[17:39:35.615]                       base::local({
[17:39:35.615]                         has_future <- base::requireNamespace("future", 
[17:39:35.615]                           quietly = TRUE)
[17:39:35.615]                         if (has_future) {
[17:39:35.615]                           ns <- base::getNamespace("future")
[17:39:35.615]                           version <- ns[[".package"]][["version"]]
[17:39:35.615]                           if (is.null(version)) 
[17:39:35.615]                             version <- utils::packageVersion("future")
[17:39:35.615]                         }
[17:39:35.615]                         else {
[17:39:35.615]                           version <- NULL
[17:39:35.615]                         }
[17:39:35.615]                         if (!has_future || version < "1.8.0") {
[17:39:35.615]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.615]                             "", base::R.version$version.string), 
[17:39:35.615]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.615]                               "release", "version")], collapse = " "), 
[17:39:35.615]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.615]                             info)
[17:39:35.615]                           info <- base::paste(info, collapse = "; ")
[17:39:35.615]                           if (!has_future) {
[17:39:35.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.615]                               info)
[17:39:35.615]                           }
[17:39:35.615]                           else {
[17:39:35.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.615]                               info, version)
[17:39:35.615]                           }
[17:39:35.615]                           base::stop(msg)
[17:39:35.615]                         }
[17:39:35.615]                       })
[17:39:35.615]                     }
[17:39:35.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.615]                     base::options(mc.cores = 1L)
[17:39:35.615]                   }
[17:39:35.615]                   ...future.strategy.old <- future::plan("list")
[17:39:35.615]                   options(future.plan = NULL)
[17:39:35.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.615]                 }
[17:39:35.615]                 ...future.workdir <- getwd()
[17:39:35.615]             }
[17:39:35.615]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.615]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.615]         }
[17:39:35.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.615]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.615]             base::names(...future.oldOptions))
[17:39:35.615]     }
[17:39:35.615]     if (FALSE) {
[17:39:35.615]     }
[17:39:35.615]     else {
[17:39:35.615]         if (TRUE) {
[17:39:35.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.615]                 open = "w")
[17:39:35.615]         }
[17:39:35.615]         else {
[17:39:35.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.615]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.615]         }
[17:39:35.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.615]             base::sink(type = "output", split = FALSE)
[17:39:35.615]             base::close(...future.stdout)
[17:39:35.615]         }, add = TRUE)
[17:39:35.615]     }
[17:39:35.615]     ...future.frame <- base::sys.nframe()
[17:39:35.615]     ...future.conditions <- base::list()
[17:39:35.615]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.615]     if (FALSE) {
[17:39:35.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.615]     }
[17:39:35.615]     ...future.result <- base::tryCatch({
[17:39:35.615]         base::withCallingHandlers({
[17:39:35.615]             ...future.value <- base::withVisible(base::local({
[17:39:35.615]                 withCallingHandlers({
[17:39:35.615]                   2
[17:39:35.615]                 }, immediateCondition = function(cond) {
[17:39:35.615]                   save_rds <- function (object, pathname, ...) 
[17:39:35.615]                   {
[17:39:35.615]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.615]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.615]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.615]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.615]                         fi_tmp[["mtime"]])
[17:39:35.615]                     }
[17:39:35.615]                     tryCatch({
[17:39:35.615]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.615]                     }, error = function(ex) {
[17:39:35.615]                       msg <- conditionMessage(ex)
[17:39:35.615]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.615]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.615]                         fi_tmp[["mtime"]], msg)
[17:39:35.615]                       ex$message <- msg
[17:39:35.615]                       stop(ex)
[17:39:35.615]                     })
[17:39:35.615]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.615]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.615]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.615]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.615]                       fi <- file.info(pathname)
[17:39:35.615]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.615]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.615]                         fi[["size"]], fi[["mtime"]])
[17:39:35.615]                       stop(msg)
[17:39:35.615]                     }
[17:39:35.615]                     invisible(pathname)
[17:39:35.615]                   }
[17:39:35.615]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.615]                     rootPath = tempdir()) 
[17:39:35.615]                   {
[17:39:35.615]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.615]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.615]                       tmpdir = path, fileext = ".rds")
[17:39:35.615]                     save_rds(obj, file)
[17:39:35.615]                   }
[17:39:35.615]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.615]                   {
[17:39:35.615]                     inherits <- base::inherits
[17:39:35.615]                     invokeRestart <- base::invokeRestart
[17:39:35.615]                     is.null <- base::is.null
[17:39:35.615]                     muffled <- FALSE
[17:39:35.615]                     if (inherits(cond, "message")) {
[17:39:35.615]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.615]                       if (muffled) 
[17:39:35.615]                         invokeRestart("muffleMessage")
[17:39:35.615]                     }
[17:39:35.615]                     else if (inherits(cond, "warning")) {
[17:39:35.615]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.615]                       if (muffled) 
[17:39:35.615]                         invokeRestart("muffleWarning")
[17:39:35.615]                     }
[17:39:35.615]                     else if (inherits(cond, "condition")) {
[17:39:35.615]                       if (!is.null(pattern)) {
[17:39:35.615]                         computeRestarts <- base::computeRestarts
[17:39:35.615]                         grepl <- base::grepl
[17:39:35.615]                         restarts <- computeRestarts(cond)
[17:39:35.615]                         for (restart in restarts) {
[17:39:35.615]                           name <- restart$name
[17:39:35.615]                           if (is.null(name)) 
[17:39:35.615]                             next
[17:39:35.615]                           if (!grepl(pattern, name)) 
[17:39:35.615]                             next
[17:39:35.615]                           invokeRestart(restart)
[17:39:35.615]                           muffled <- TRUE
[17:39:35.615]                           break
[17:39:35.615]                         }
[17:39:35.615]                       }
[17:39:35.615]                     }
[17:39:35.615]                     invisible(muffled)
[17:39:35.615]                   }
[17:39:35.615]                   muffleCondition(cond)
[17:39:35.615]                 })
[17:39:35.615]             }))
[17:39:35.615]             future::FutureResult(value = ...future.value$value, 
[17:39:35.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.615]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.615]                     ...future.globalenv.names))
[17:39:35.615]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.615]         }, condition = base::local({
[17:39:35.615]             c <- base::c
[17:39:35.615]             inherits <- base::inherits
[17:39:35.615]             invokeRestart <- base::invokeRestart
[17:39:35.615]             length <- base::length
[17:39:35.615]             list <- base::list
[17:39:35.615]             seq.int <- base::seq.int
[17:39:35.615]             signalCondition <- base::signalCondition
[17:39:35.615]             sys.calls <- base::sys.calls
[17:39:35.615]             `[[` <- base::`[[`
[17:39:35.615]             `+` <- base::`+`
[17:39:35.615]             `<<-` <- base::`<<-`
[17:39:35.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.615]                   3L)]
[17:39:35.615]             }
[17:39:35.615]             function(cond) {
[17:39:35.615]                 is_error <- inherits(cond, "error")
[17:39:35.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.615]                   NULL)
[17:39:35.615]                 if (is_error) {
[17:39:35.615]                   sessionInformation <- function() {
[17:39:35.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.615]                       search = base::search(), system = base::Sys.info())
[17:39:35.615]                   }
[17:39:35.615]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.615]                     cond$call), session = sessionInformation(), 
[17:39:35.615]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.615]                   signalCondition(cond)
[17:39:35.615]                 }
[17:39:35.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.615]                 "immediateCondition"))) {
[17:39:35.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.615]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.615]                   if (TRUE && !signal) {
[17:39:35.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.615]                     {
[17:39:35.615]                       inherits <- base::inherits
[17:39:35.615]                       invokeRestart <- base::invokeRestart
[17:39:35.615]                       is.null <- base::is.null
[17:39:35.615]                       muffled <- FALSE
[17:39:35.615]                       if (inherits(cond, "message")) {
[17:39:35.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.615]                         if (muffled) 
[17:39:35.615]                           invokeRestart("muffleMessage")
[17:39:35.615]                       }
[17:39:35.615]                       else if (inherits(cond, "warning")) {
[17:39:35.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.615]                         if (muffled) 
[17:39:35.615]                           invokeRestart("muffleWarning")
[17:39:35.615]                       }
[17:39:35.615]                       else if (inherits(cond, "condition")) {
[17:39:35.615]                         if (!is.null(pattern)) {
[17:39:35.615]                           computeRestarts <- base::computeRestarts
[17:39:35.615]                           grepl <- base::grepl
[17:39:35.615]                           restarts <- computeRestarts(cond)
[17:39:35.615]                           for (restart in restarts) {
[17:39:35.615]                             name <- restart$name
[17:39:35.615]                             if (is.null(name)) 
[17:39:35.615]                               next
[17:39:35.615]                             if (!grepl(pattern, name)) 
[17:39:35.615]                               next
[17:39:35.615]                             invokeRestart(restart)
[17:39:35.615]                             muffled <- TRUE
[17:39:35.615]                             break
[17:39:35.615]                           }
[17:39:35.615]                         }
[17:39:35.615]                       }
[17:39:35.615]                       invisible(muffled)
[17:39:35.615]                     }
[17:39:35.615]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.615]                   }
[17:39:35.615]                 }
[17:39:35.615]                 else {
[17:39:35.615]                   if (TRUE) {
[17:39:35.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.615]                     {
[17:39:35.615]                       inherits <- base::inherits
[17:39:35.615]                       invokeRestart <- base::invokeRestart
[17:39:35.615]                       is.null <- base::is.null
[17:39:35.615]                       muffled <- FALSE
[17:39:35.615]                       if (inherits(cond, "message")) {
[17:39:35.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.615]                         if (muffled) 
[17:39:35.615]                           invokeRestart("muffleMessage")
[17:39:35.615]                       }
[17:39:35.615]                       else if (inherits(cond, "warning")) {
[17:39:35.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.615]                         if (muffled) 
[17:39:35.615]                           invokeRestart("muffleWarning")
[17:39:35.615]                       }
[17:39:35.615]                       else if (inherits(cond, "condition")) {
[17:39:35.615]                         if (!is.null(pattern)) {
[17:39:35.615]                           computeRestarts <- base::computeRestarts
[17:39:35.615]                           grepl <- base::grepl
[17:39:35.615]                           restarts <- computeRestarts(cond)
[17:39:35.615]                           for (restart in restarts) {
[17:39:35.615]                             name <- restart$name
[17:39:35.615]                             if (is.null(name)) 
[17:39:35.615]                               next
[17:39:35.615]                             if (!grepl(pattern, name)) 
[17:39:35.615]                               next
[17:39:35.615]                             invokeRestart(restart)
[17:39:35.615]                             muffled <- TRUE
[17:39:35.615]                             break
[17:39:35.615]                           }
[17:39:35.615]                         }
[17:39:35.615]                       }
[17:39:35.615]                       invisible(muffled)
[17:39:35.615]                     }
[17:39:35.615]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.615]                   }
[17:39:35.615]                 }
[17:39:35.615]             }
[17:39:35.615]         }))
[17:39:35.615]     }, error = function(ex) {
[17:39:35.615]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.615]                 ...future.rng), started = ...future.startTime, 
[17:39:35.615]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.615]             version = "1.8"), class = "FutureResult")
[17:39:35.615]     }, finally = {
[17:39:35.615]         if (!identical(...future.workdir, getwd())) 
[17:39:35.615]             setwd(...future.workdir)
[17:39:35.615]         {
[17:39:35.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.615]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.615]             }
[17:39:35.615]             base::options(...future.oldOptions)
[17:39:35.615]             if (.Platform$OS.type == "windows") {
[17:39:35.615]                 old_names <- names(...future.oldEnvVars)
[17:39:35.615]                 envs <- base::Sys.getenv()
[17:39:35.615]                 names <- names(envs)
[17:39:35.615]                 common <- intersect(names, old_names)
[17:39:35.615]                 added <- setdiff(names, old_names)
[17:39:35.615]                 removed <- setdiff(old_names, names)
[17:39:35.615]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.615]                   envs[common]]
[17:39:35.615]                 NAMES <- toupper(changed)
[17:39:35.615]                 args <- list()
[17:39:35.615]                 for (kk in seq_along(NAMES)) {
[17:39:35.615]                   name <- changed[[kk]]
[17:39:35.615]                   NAME <- NAMES[[kk]]
[17:39:35.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.615]                     next
[17:39:35.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.615]                 }
[17:39:35.615]                 NAMES <- toupper(added)
[17:39:35.615]                 for (kk in seq_along(NAMES)) {
[17:39:35.615]                   name <- added[[kk]]
[17:39:35.615]                   NAME <- NAMES[[kk]]
[17:39:35.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.615]                     next
[17:39:35.615]                   args[[name]] <- ""
[17:39:35.615]                 }
[17:39:35.615]                 NAMES <- toupper(removed)
[17:39:35.615]                 for (kk in seq_along(NAMES)) {
[17:39:35.615]                   name <- removed[[kk]]
[17:39:35.615]                   NAME <- NAMES[[kk]]
[17:39:35.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.615]                     next
[17:39:35.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.615]                 }
[17:39:35.615]                 if (length(args) > 0) 
[17:39:35.615]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.615]             }
[17:39:35.615]             else {
[17:39:35.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.615]             }
[17:39:35.615]             {
[17:39:35.615]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.615]                   0L) {
[17:39:35.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.615]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.615]                   base::options(opts)
[17:39:35.615]                 }
[17:39:35.615]                 {
[17:39:35.615]                   {
[17:39:35.615]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.615]                     NULL
[17:39:35.615]                   }
[17:39:35.615]                   options(future.plan = NULL)
[17:39:35.615]                   if (is.na(NA_character_)) 
[17:39:35.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.615]                     .init = FALSE)
[17:39:35.615]                 }
[17:39:35.615]             }
[17:39:35.615]         }
[17:39:35.615]     })
[17:39:35.615]     if (TRUE) {
[17:39:35.615]         base::sink(type = "output", split = FALSE)
[17:39:35.615]         if (TRUE) {
[17:39:35.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.615]         }
[17:39:35.615]         else {
[17:39:35.615]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.615]         }
[17:39:35.615]         base::close(...future.stdout)
[17:39:35.615]         ...future.stdout <- NULL
[17:39:35.615]     }
[17:39:35.615]     ...future.result$conditions <- ...future.conditions
[17:39:35.615]     ...future.result$finished <- base::Sys.time()
[17:39:35.615]     ...future.result
[17:39:35.615] }
[17:39:35.618] requestCore(): workers = 2
[17:39:35.620] MulticoreFuture started
[17:39:35.620] - Launch lazy future ... done
[17:39:35.620] run() for ‘MulticoreFuture’ ... done
[17:39:35.621] getGlobalsAndPackages() ...
[17:39:35.621] Searching for globals...
[17:39:35.621] plan(): Setting new future strategy stack:
[17:39:35.622] 
[17:39:35.622] Searching for globals ... DONE
[17:39:35.622] - globals: [0] <none>
[17:39:35.621] List of future strategies:
[17:39:35.621] 1. sequential:
[17:39:35.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.621]    - tweaked: FALSE
[17:39:35.621]    - call: NULL
[17:39:35.622] getGlobalsAndPackages() ... DONE
[17:39:35.622] plan(): nbrOfWorkers() = 1
[17:39:35.623] run() for ‘Future’ ...
[17:39:35.623] - state: ‘created’
[17:39:35.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.624] plan(): Setting new future strategy stack:
[17:39:35.624] List of future strategies:
[17:39:35.624] 1. multicore:
[17:39:35.624]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.624]    - tweaked: FALSE
[17:39:35.624]    - call: plan(strategy)
[17:39:35.629] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.629] plan(): nbrOfWorkers() = 2
[17:39:35.629]   - Field: ‘label’
[17:39:35.629]   - Field: ‘local’
[17:39:35.630]   - Field: ‘owner’
[17:39:35.630]   - Field: ‘envir’
[17:39:35.630]   - Field: ‘workers’
[17:39:35.630]   - Field: ‘packages’
[17:39:35.630]   - Field: ‘gc’
[17:39:35.630]   - Field: ‘job’
[17:39:35.630]   - Field: ‘conditions’
[17:39:35.630]   - Field: ‘expr’
[17:39:35.631]   - Field: ‘uuid’
[17:39:35.631]   - Field: ‘seed’
[17:39:35.631]   - Field: ‘version’
[17:39:35.631]   - Field: ‘result’
[17:39:35.631]   - Field: ‘asynchronous’
[17:39:35.631]   - Field: ‘calls’
[17:39:35.631]   - Field: ‘globals’
[17:39:35.632]   - Field: ‘stdout’
[17:39:35.632]   - Field: ‘earlySignal’
[17:39:35.632]   - Field: ‘lazy’
[17:39:35.632]   - Field: ‘state’
[17:39:35.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.632] - Launch lazy future ...
[17:39:35.633] Packages needed by the future expression (n = 0): <none>
[17:39:35.633] Packages needed by future strategies (n = 0): <none>
[17:39:35.634] {
[17:39:35.634]     {
[17:39:35.634]         {
[17:39:35.634]             ...future.startTime <- base::Sys.time()
[17:39:35.634]             {
[17:39:35.634]                 {
[17:39:35.634]                   {
[17:39:35.634]                     {
[17:39:35.634]                       base::local({
[17:39:35.634]                         has_future <- base::requireNamespace("future", 
[17:39:35.634]                           quietly = TRUE)
[17:39:35.634]                         if (has_future) {
[17:39:35.634]                           ns <- base::getNamespace("future")
[17:39:35.634]                           version <- ns[[".package"]][["version"]]
[17:39:35.634]                           if (is.null(version)) 
[17:39:35.634]                             version <- utils::packageVersion("future")
[17:39:35.634]                         }
[17:39:35.634]                         else {
[17:39:35.634]                           version <- NULL
[17:39:35.634]                         }
[17:39:35.634]                         if (!has_future || version < "1.8.0") {
[17:39:35.634]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.634]                             "", base::R.version$version.string), 
[17:39:35.634]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.634]                               "release", "version")], collapse = " "), 
[17:39:35.634]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.634]                             info)
[17:39:35.634]                           info <- base::paste(info, collapse = "; ")
[17:39:35.634]                           if (!has_future) {
[17:39:35.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.634]                               info)
[17:39:35.634]                           }
[17:39:35.634]                           else {
[17:39:35.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.634]                               info, version)
[17:39:35.634]                           }
[17:39:35.634]                           base::stop(msg)
[17:39:35.634]                         }
[17:39:35.634]                       })
[17:39:35.634]                     }
[17:39:35.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.634]                     base::options(mc.cores = 1L)
[17:39:35.634]                   }
[17:39:35.634]                   ...future.strategy.old <- future::plan("list")
[17:39:35.634]                   options(future.plan = NULL)
[17:39:35.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.634]                 }
[17:39:35.634]                 ...future.workdir <- getwd()
[17:39:35.634]             }
[17:39:35.634]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.634]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.634]         }
[17:39:35.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.634]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.634]             base::names(...future.oldOptions))
[17:39:35.634]     }
[17:39:35.634]     if (FALSE) {
[17:39:35.634]     }
[17:39:35.634]     else {
[17:39:35.634]         if (TRUE) {
[17:39:35.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.634]                 open = "w")
[17:39:35.634]         }
[17:39:35.634]         else {
[17:39:35.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.634]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.634]         }
[17:39:35.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.634]             base::sink(type = "output", split = FALSE)
[17:39:35.634]             base::close(...future.stdout)
[17:39:35.634]         }, add = TRUE)
[17:39:35.634]     }
[17:39:35.634]     ...future.frame <- base::sys.nframe()
[17:39:35.634]     ...future.conditions <- base::list()
[17:39:35.634]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.634]     if (FALSE) {
[17:39:35.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.634]     }
[17:39:35.634]     ...future.result <- base::tryCatch({
[17:39:35.634]         base::withCallingHandlers({
[17:39:35.634]             ...future.value <- base::withVisible(base::local({
[17:39:35.634]                 withCallingHandlers({
[17:39:35.634]                   NULL
[17:39:35.634]                 }, immediateCondition = function(cond) {
[17:39:35.634]                   save_rds <- function (object, pathname, ...) 
[17:39:35.634]                   {
[17:39:35.634]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.634]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.634]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.634]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.634]                         fi_tmp[["mtime"]])
[17:39:35.634]                     }
[17:39:35.634]                     tryCatch({
[17:39:35.634]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.634]                     }, error = function(ex) {
[17:39:35.634]                       msg <- conditionMessage(ex)
[17:39:35.634]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.634]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.634]                         fi_tmp[["mtime"]], msg)
[17:39:35.634]                       ex$message <- msg
[17:39:35.634]                       stop(ex)
[17:39:35.634]                     })
[17:39:35.634]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.634]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.634]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.634]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.634]                       fi <- file.info(pathname)
[17:39:35.634]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.634]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.634]                         fi[["size"]], fi[["mtime"]])
[17:39:35.634]                       stop(msg)
[17:39:35.634]                     }
[17:39:35.634]                     invisible(pathname)
[17:39:35.634]                   }
[17:39:35.634]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.634]                     rootPath = tempdir()) 
[17:39:35.634]                   {
[17:39:35.634]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.634]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.634]                       tmpdir = path, fileext = ".rds")
[17:39:35.634]                     save_rds(obj, file)
[17:39:35.634]                   }
[17:39:35.634]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.634]                   {
[17:39:35.634]                     inherits <- base::inherits
[17:39:35.634]                     invokeRestart <- base::invokeRestart
[17:39:35.634]                     is.null <- base::is.null
[17:39:35.634]                     muffled <- FALSE
[17:39:35.634]                     if (inherits(cond, "message")) {
[17:39:35.634]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.634]                       if (muffled) 
[17:39:35.634]                         invokeRestart("muffleMessage")
[17:39:35.634]                     }
[17:39:35.634]                     else if (inherits(cond, "warning")) {
[17:39:35.634]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.634]                       if (muffled) 
[17:39:35.634]                         invokeRestart("muffleWarning")
[17:39:35.634]                     }
[17:39:35.634]                     else if (inherits(cond, "condition")) {
[17:39:35.634]                       if (!is.null(pattern)) {
[17:39:35.634]                         computeRestarts <- base::computeRestarts
[17:39:35.634]                         grepl <- base::grepl
[17:39:35.634]                         restarts <- computeRestarts(cond)
[17:39:35.634]                         for (restart in restarts) {
[17:39:35.634]                           name <- restart$name
[17:39:35.634]                           if (is.null(name)) 
[17:39:35.634]                             next
[17:39:35.634]                           if (!grepl(pattern, name)) 
[17:39:35.634]                             next
[17:39:35.634]                           invokeRestart(restart)
[17:39:35.634]                           muffled <- TRUE
[17:39:35.634]                           break
[17:39:35.634]                         }
[17:39:35.634]                       }
[17:39:35.634]                     }
[17:39:35.634]                     invisible(muffled)
[17:39:35.634]                   }
[17:39:35.634]                   muffleCondition(cond)
[17:39:35.634]                 })
[17:39:35.634]             }))
[17:39:35.634]             future::FutureResult(value = ...future.value$value, 
[17:39:35.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.634]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.634]                     ...future.globalenv.names))
[17:39:35.634]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.634]         }, condition = base::local({
[17:39:35.634]             c <- base::c
[17:39:35.634]             inherits <- base::inherits
[17:39:35.634]             invokeRestart <- base::invokeRestart
[17:39:35.634]             length <- base::length
[17:39:35.634]             list <- base::list
[17:39:35.634]             seq.int <- base::seq.int
[17:39:35.634]             signalCondition <- base::signalCondition
[17:39:35.634]             sys.calls <- base::sys.calls
[17:39:35.634]             `[[` <- base::`[[`
[17:39:35.634]             `+` <- base::`+`
[17:39:35.634]             `<<-` <- base::`<<-`
[17:39:35.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.634]                   3L)]
[17:39:35.634]             }
[17:39:35.634]             function(cond) {
[17:39:35.634]                 is_error <- inherits(cond, "error")
[17:39:35.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.634]                   NULL)
[17:39:35.634]                 if (is_error) {
[17:39:35.634]                   sessionInformation <- function() {
[17:39:35.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.634]                       search = base::search(), system = base::Sys.info())
[17:39:35.634]                   }
[17:39:35.634]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.634]                     cond$call), session = sessionInformation(), 
[17:39:35.634]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.634]                   signalCondition(cond)
[17:39:35.634]                 }
[17:39:35.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.634]                 "immediateCondition"))) {
[17:39:35.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.634]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.634]                   if (TRUE && !signal) {
[17:39:35.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.634]                     {
[17:39:35.634]                       inherits <- base::inherits
[17:39:35.634]                       invokeRestart <- base::invokeRestart
[17:39:35.634]                       is.null <- base::is.null
[17:39:35.634]                       muffled <- FALSE
[17:39:35.634]                       if (inherits(cond, "message")) {
[17:39:35.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.634]                         if (muffled) 
[17:39:35.634]                           invokeRestart("muffleMessage")
[17:39:35.634]                       }
[17:39:35.634]                       else if (inherits(cond, "warning")) {
[17:39:35.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.634]                         if (muffled) 
[17:39:35.634]                           invokeRestart("muffleWarning")
[17:39:35.634]                       }
[17:39:35.634]                       else if (inherits(cond, "condition")) {
[17:39:35.634]                         if (!is.null(pattern)) {
[17:39:35.634]                           computeRestarts <- base::computeRestarts
[17:39:35.634]                           grepl <- base::grepl
[17:39:35.634]                           restarts <- computeRestarts(cond)
[17:39:35.634]                           for (restart in restarts) {
[17:39:35.634]                             name <- restart$name
[17:39:35.634]                             if (is.null(name)) 
[17:39:35.634]                               next
[17:39:35.634]                             if (!grepl(pattern, name)) 
[17:39:35.634]                               next
[17:39:35.634]                             invokeRestart(restart)
[17:39:35.634]                             muffled <- TRUE
[17:39:35.634]                             break
[17:39:35.634]                           }
[17:39:35.634]                         }
[17:39:35.634]                       }
[17:39:35.634]                       invisible(muffled)
[17:39:35.634]                     }
[17:39:35.634]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.634]                   }
[17:39:35.634]                 }
[17:39:35.634]                 else {
[17:39:35.634]                   if (TRUE) {
[17:39:35.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.634]                     {
[17:39:35.634]                       inherits <- base::inherits
[17:39:35.634]                       invokeRestart <- base::invokeRestart
[17:39:35.634]                       is.null <- base::is.null
[17:39:35.634]                       muffled <- FALSE
[17:39:35.634]                       if (inherits(cond, "message")) {
[17:39:35.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.634]                         if (muffled) 
[17:39:35.634]                           invokeRestart("muffleMessage")
[17:39:35.634]                       }
[17:39:35.634]                       else if (inherits(cond, "warning")) {
[17:39:35.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.634]                         if (muffled) 
[17:39:35.634]                           invokeRestart("muffleWarning")
[17:39:35.634]                       }
[17:39:35.634]                       else if (inherits(cond, "condition")) {
[17:39:35.634]                         if (!is.null(pattern)) {
[17:39:35.634]                           computeRestarts <- base::computeRestarts
[17:39:35.634]                           grepl <- base::grepl
[17:39:35.634]                           restarts <- computeRestarts(cond)
[17:39:35.634]                           for (restart in restarts) {
[17:39:35.634]                             name <- restart$name
[17:39:35.634]                             if (is.null(name)) 
[17:39:35.634]                               next
[17:39:35.634]                             if (!grepl(pattern, name)) 
[17:39:35.634]                               next
[17:39:35.634]                             invokeRestart(restart)
[17:39:35.634]                             muffled <- TRUE
[17:39:35.634]                             break
[17:39:35.634]                           }
[17:39:35.634]                         }
[17:39:35.634]                       }
[17:39:35.634]                       invisible(muffled)
[17:39:35.634]                     }
[17:39:35.634]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.634]                   }
[17:39:35.634]                 }
[17:39:35.634]             }
[17:39:35.634]         }))
[17:39:35.634]     }, error = function(ex) {
[17:39:35.634]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.634]                 ...future.rng), started = ...future.startTime, 
[17:39:35.634]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.634]             version = "1.8"), class = "FutureResult")
[17:39:35.634]     }, finally = {
[17:39:35.634]         if (!identical(...future.workdir, getwd())) 
[17:39:35.634]             setwd(...future.workdir)
[17:39:35.634]         {
[17:39:35.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.634]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.634]             }
[17:39:35.634]             base::options(...future.oldOptions)
[17:39:35.634]             if (.Platform$OS.type == "windows") {
[17:39:35.634]                 old_names <- names(...future.oldEnvVars)
[17:39:35.634]                 envs <- base::Sys.getenv()
[17:39:35.634]                 names <- names(envs)
[17:39:35.634]                 common <- intersect(names, old_names)
[17:39:35.634]                 added <- setdiff(names, old_names)
[17:39:35.634]                 removed <- setdiff(old_names, names)
[17:39:35.634]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.634]                   envs[common]]
[17:39:35.634]                 NAMES <- toupper(changed)
[17:39:35.634]                 args <- list()
[17:39:35.634]                 for (kk in seq_along(NAMES)) {
[17:39:35.634]                   name <- changed[[kk]]
[17:39:35.634]                   NAME <- NAMES[[kk]]
[17:39:35.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.634]                     next
[17:39:35.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.634]                 }
[17:39:35.634]                 NAMES <- toupper(added)
[17:39:35.634]                 for (kk in seq_along(NAMES)) {
[17:39:35.634]                   name <- added[[kk]]
[17:39:35.634]                   NAME <- NAMES[[kk]]
[17:39:35.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.634]                     next
[17:39:35.634]                   args[[name]] <- ""
[17:39:35.634]                 }
[17:39:35.634]                 NAMES <- toupper(removed)
[17:39:35.634]                 for (kk in seq_along(NAMES)) {
[17:39:35.634]                   name <- removed[[kk]]
[17:39:35.634]                   NAME <- NAMES[[kk]]
[17:39:35.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.634]                     next
[17:39:35.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.634]                 }
[17:39:35.634]                 if (length(args) > 0) 
[17:39:35.634]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.634]             }
[17:39:35.634]             else {
[17:39:35.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.634]             }
[17:39:35.634]             {
[17:39:35.634]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.634]                   0L) {
[17:39:35.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.634]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.634]                   base::options(opts)
[17:39:35.634]                 }
[17:39:35.634]                 {
[17:39:35.634]                   {
[17:39:35.634]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.634]                     NULL
[17:39:35.634]                   }
[17:39:35.634]                   options(future.plan = NULL)
[17:39:35.634]                   if (is.na(NA_character_)) 
[17:39:35.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.634]                     .init = FALSE)
[17:39:35.634]                 }
[17:39:35.634]             }
[17:39:35.634]         }
[17:39:35.634]     })
[17:39:35.634]     if (TRUE) {
[17:39:35.634]         base::sink(type = "output", split = FALSE)
[17:39:35.634]         if (TRUE) {
[17:39:35.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.634]         }
[17:39:35.634]         else {
[17:39:35.634]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.634]         }
[17:39:35.634]         base::close(...future.stdout)
[17:39:35.634]         ...future.stdout <- NULL
[17:39:35.634]     }
[17:39:35.634]     ...future.result$conditions <- ...future.conditions
[17:39:35.634]     ...future.result$finished <- base::Sys.time()
[17:39:35.634]     ...future.result
[17:39:35.634] }
[17:39:35.637] requestCore(): workers = 2
[17:39:35.640] MulticoreFuture started
[17:39:35.640] - Launch lazy future ... done
[17:39:35.640] run() for ‘MulticoreFuture’ ... done
[17:39:35.641] plan(): Setting new future strategy stack:
[17:39:35.641] getGlobalsAndPackages() ...
[17:39:35.641] Searching for globals...
[17:39:35.641] List of future strategies:
[17:39:35.641] 1. sequential:
[17:39:35.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.641]    - tweaked: FALSE
[17:39:35.641]    - call: NULL
[17:39:35.642] plan(): nbrOfWorkers() = 1
[17:39:35.643] - globals found: [1] ‘{’
[17:39:35.643] Searching for globals ... DONE
[17:39:35.643] Resolving globals: FALSE
[17:39:35.643] 
[17:39:35.644] 
[17:39:35.644] getGlobalsAndPackages() ... DONE
[17:39:35.644] plan(): Setting new future strategy stack:
[17:39:35.644] run() for ‘Future’ ...
[17:39:35.644] - state: ‘created’
[17:39:35.644] List of future strategies:
[17:39:35.644] 1. multicore:
[17:39:35.644]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.644]    - tweaked: FALSE
[17:39:35.644]    - call: plan(strategy)
[17:39:35.645] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.650] plan(): nbrOfWorkers() = 2
[17:39:35.650] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.651]   - Field: ‘label’
[17:39:35.651]   - Field: ‘local’
[17:39:35.651]   - Field: ‘owner’
[17:39:35.651]   - Field: ‘envir’
[17:39:35.651]   - Field: ‘workers’
[17:39:35.651]   - Field: ‘packages’
[17:39:35.651]   - Field: ‘gc’
[17:39:35.652]   - Field: ‘job’
[17:39:35.652]   - Field: ‘conditions’
[17:39:35.652]   - Field: ‘expr’
[17:39:35.652]   - Field: ‘uuid’
[17:39:35.652]   - Field: ‘seed’
[17:39:35.652]   - Field: ‘version’
[17:39:35.652]   - Field: ‘result’
[17:39:35.653]   - Field: ‘asynchronous’
[17:39:35.653]   - Field: ‘calls’
[17:39:35.653]   - Field: ‘globals’
[17:39:35.653]   - Field: ‘stdout’
[17:39:35.653]   - Field: ‘earlySignal’
[17:39:35.653]   - Field: ‘lazy’
[17:39:35.653]   - Field: ‘state’
[17:39:35.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.654] - Launch lazy future ...
[17:39:35.654] Packages needed by the future expression (n = 0): <none>
[17:39:35.654] Packages needed by future strategies (n = 0): <none>
[17:39:35.655] {
[17:39:35.655]     {
[17:39:35.655]         {
[17:39:35.655]             ...future.startTime <- base::Sys.time()
[17:39:35.655]             {
[17:39:35.655]                 {
[17:39:35.655]                   {
[17:39:35.655]                     {
[17:39:35.655]                       base::local({
[17:39:35.655]                         has_future <- base::requireNamespace("future", 
[17:39:35.655]                           quietly = TRUE)
[17:39:35.655]                         if (has_future) {
[17:39:35.655]                           ns <- base::getNamespace("future")
[17:39:35.655]                           version <- ns[[".package"]][["version"]]
[17:39:35.655]                           if (is.null(version)) 
[17:39:35.655]                             version <- utils::packageVersion("future")
[17:39:35.655]                         }
[17:39:35.655]                         else {
[17:39:35.655]                           version <- NULL
[17:39:35.655]                         }
[17:39:35.655]                         if (!has_future || version < "1.8.0") {
[17:39:35.655]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.655]                             "", base::R.version$version.string), 
[17:39:35.655]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.655]                               "release", "version")], collapse = " "), 
[17:39:35.655]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.655]                             info)
[17:39:35.655]                           info <- base::paste(info, collapse = "; ")
[17:39:35.655]                           if (!has_future) {
[17:39:35.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.655]                               info)
[17:39:35.655]                           }
[17:39:35.655]                           else {
[17:39:35.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.655]                               info, version)
[17:39:35.655]                           }
[17:39:35.655]                           base::stop(msg)
[17:39:35.655]                         }
[17:39:35.655]                       })
[17:39:35.655]                     }
[17:39:35.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.655]                     base::options(mc.cores = 1L)
[17:39:35.655]                   }
[17:39:35.655]                   ...future.strategy.old <- future::plan("list")
[17:39:35.655]                   options(future.plan = NULL)
[17:39:35.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.655]                 }
[17:39:35.655]                 ...future.workdir <- getwd()
[17:39:35.655]             }
[17:39:35.655]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.655]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.655]         }
[17:39:35.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.655]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.655]             base::names(...future.oldOptions))
[17:39:35.655]     }
[17:39:35.655]     if (FALSE) {
[17:39:35.655]     }
[17:39:35.655]     else {
[17:39:35.655]         if (TRUE) {
[17:39:35.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.655]                 open = "w")
[17:39:35.655]         }
[17:39:35.655]         else {
[17:39:35.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.655]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.655]         }
[17:39:35.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.655]             base::sink(type = "output", split = FALSE)
[17:39:35.655]             base::close(...future.stdout)
[17:39:35.655]         }, add = TRUE)
[17:39:35.655]     }
[17:39:35.655]     ...future.frame <- base::sys.nframe()
[17:39:35.655]     ...future.conditions <- base::list()
[17:39:35.655]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.655]     if (FALSE) {
[17:39:35.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.655]     }
[17:39:35.655]     ...future.result <- base::tryCatch({
[17:39:35.655]         base::withCallingHandlers({
[17:39:35.655]             ...future.value <- base::withVisible(base::local({
[17:39:35.655]                 withCallingHandlers({
[17:39:35.655]                   {
[17:39:35.655]                     4
[17:39:35.655]                   }
[17:39:35.655]                 }, immediateCondition = function(cond) {
[17:39:35.655]                   save_rds <- function (object, pathname, ...) 
[17:39:35.655]                   {
[17:39:35.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.655]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.655]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.655]                         fi_tmp[["mtime"]])
[17:39:35.655]                     }
[17:39:35.655]                     tryCatch({
[17:39:35.655]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.655]                     }, error = function(ex) {
[17:39:35.655]                       msg <- conditionMessage(ex)
[17:39:35.655]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.655]                         fi_tmp[["mtime"]], msg)
[17:39:35.655]                       ex$message <- msg
[17:39:35.655]                       stop(ex)
[17:39:35.655]                     })
[17:39:35.655]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.655]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.655]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.655]                       fi <- file.info(pathname)
[17:39:35.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.655]                         fi[["size"]], fi[["mtime"]])
[17:39:35.655]                       stop(msg)
[17:39:35.655]                     }
[17:39:35.655]                     invisible(pathname)
[17:39:35.655]                   }
[17:39:35.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.655]                     rootPath = tempdir()) 
[17:39:35.655]                   {
[17:39:35.655]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.655]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.655]                       tmpdir = path, fileext = ".rds")
[17:39:35.655]                     save_rds(obj, file)
[17:39:35.655]                   }
[17:39:35.655]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.655]                   {
[17:39:35.655]                     inherits <- base::inherits
[17:39:35.655]                     invokeRestart <- base::invokeRestart
[17:39:35.655]                     is.null <- base::is.null
[17:39:35.655]                     muffled <- FALSE
[17:39:35.655]                     if (inherits(cond, "message")) {
[17:39:35.655]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.655]                       if (muffled) 
[17:39:35.655]                         invokeRestart("muffleMessage")
[17:39:35.655]                     }
[17:39:35.655]                     else if (inherits(cond, "warning")) {
[17:39:35.655]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.655]                       if (muffled) 
[17:39:35.655]                         invokeRestart("muffleWarning")
[17:39:35.655]                     }
[17:39:35.655]                     else if (inherits(cond, "condition")) {
[17:39:35.655]                       if (!is.null(pattern)) {
[17:39:35.655]                         computeRestarts <- base::computeRestarts
[17:39:35.655]                         grepl <- base::grepl
[17:39:35.655]                         restarts <- computeRestarts(cond)
[17:39:35.655]                         for (restart in restarts) {
[17:39:35.655]                           name <- restart$name
[17:39:35.655]                           if (is.null(name)) 
[17:39:35.655]                             next
[17:39:35.655]                           if (!grepl(pattern, name)) 
[17:39:35.655]                             next
[17:39:35.655]                           invokeRestart(restart)
[17:39:35.655]                           muffled <- TRUE
[17:39:35.655]                           break
[17:39:35.655]                         }
[17:39:35.655]                       }
[17:39:35.655]                     }
[17:39:35.655]                     invisible(muffled)
[17:39:35.655]                   }
[17:39:35.655]                   muffleCondition(cond)
[17:39:35.655]                 })
[17:39:35.655]             }))
[17:39:35.655]             future::FutureResult(value = ...future.value$value, 
[17:39:35.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.655]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.655]                     ...future.globalenv.names))
[17:39:35.655]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.655]         }, condition = base::local({
[17:39:35.655]             c <- base::c
[17:39:35.655]             inherits <- base::inherits
[17:39:35.655]             invokeRestart <- base::invokeRestart
[17:39:35.655]             length <- base::length
[17:39:35.655]             list <- base::list
[17:39:35.655]             seq.int <- base::seq.int
[17:39:35.655]             signalCondition <- base::signalCondition
[17:39:35.655]             sys.calls <- base::sys.calls
[17:39:35.655]             `[[` <- base::`[[`
[17:39:35.655]             `+` <- base::`+`
[17:39:35.655]             `<<-` <- base::`<<-`
[17:39:35.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.655]                   3L)]
[17:39:35.655]             }
[17:39:35.655]             function(cond) {
[17:39:35.655]                 is_error <- inherits(cond, "error")
[17:39:35.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.655]                   NULL)
[17:39:35.655]                 if (is_error) {
[17:39:35.655]                   sessionInformation <- function() {
[17:39:35.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.655]                       search = base::search(), system = base::Sys.info())
[17:39:35.655]                   }
[17:39:35.655]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.655]                     cond$call), session = sessionInformation(), 
[17:39:35.655]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.655]                   signalCondition(cond)
[17:39:35.655]                 }
[17:39:35.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.655]                 "immediateCondition"))) {
[17:39:35.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.655]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.655]                   if (TRUE && !signal) {
[17:39:35.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.655]                     {
[17:39:35.655]                       inherits <- base::inherits
[17:39:35.655]                       invokeRestart <- base::invokeRestart
[17:39:35.655]                       is.null <- base::is.null
[17:39:35.655]                       muffled <- FALSE
[17:39:35.655]                       if (inherits(cond, "message")) {
[17:39:35.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.655]                         if (muffled) 
[17:39:35.655]                           invokeRestart("muffleMessage")
[17:39:35.655]                       }
[17:39:35.655]                       else if (inherits(cond, "warning")) {
[17:39:35.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.655]                         if (muffled) 
[17:39:35.655]                           invokeRestart("muffleWarning")
[17:39:35.655]                       }
[17:39:35.655]                       else if (inherits(cond, "condition")) {
[17:39:35.655]                         if (!is.null(pattern)) {
[17:39:35.655]                           computeRestarts <- base::computeRestarts
[17:39:35.655]                           grepl <- base::grepl
[17:39:35.655]                           restarts <- computeRestarts(cond)
[17:39:35.655]                           for (restart in restarts) {
[17:39:35.655]                             name <- restart$name
[17:39:35.655]                             if (is.null(name)) 
[17:39:35.655]                               next
[17:39:35.655]                             if (!grepl(pattern, name)) 
[17:39:35.655]                               next
[17:39:35.655]                             invokeRestart(restart)
[17:39:35.655]                             muffled <- TRUE
[17:39:35.655]                             break
[17:39:35.655]                           }
[17:39:35.655]                         }
[17:39:35.655]                       }
[17:39:35.655]                       invisible(muffled)
[17:39:35.655]                     }
[17:39:35.655]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.655]                   }
[17:39:35.655]                 }
[17:39:35.655]                 else {
[17:39:35.655]                   if (TRUE) {
[17:39:35.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.655]                     {
[17:39:35.655]                       inherits <- base::inherits
[17:39:35.655]                       invokeRestart <- base::invokeRestart
[17:39:35.655]                       is.null <- base::is.null
[17:39:35.655]                       muffled <- FALSE
[17:39:35.655]                       if (inherits(cond, "message")) {
[17:39:35.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.655]                         if (muffled) 
[17:39:35.655]                           invokeRestart("muffleMessage")
[17:39:35.655]                       }
[17:39:35.655]                       else if (inherits(cond, "warning")) {
[17:39:35.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.655]                         if (muffled) 
[17:39:35.655]                           invokeRestart("muffleWarning")
[17:39:35.655]                       }
[17:39:35.655]                       else if (inherits(cond, "condition")) {
[17:39:35.655]                         if (!is.null(pattern)) {
[17:39:35.655]                           computeRestarts <- base::computeRestarts
[17:39:35.655]                           grepl <- base::grepl
[17:39:35.655]                           restarts <- computeRestarts(cond)
[17:39:35.655]                           for (restart in restarts) {
[17:39:35.655]                             name <- restart$name
[17:39:35.655]                             if (is.null(name)) 
[17:39:35.655]                               next
[17:39:35.655]                             if (!grepl(pattern, name)) 
[17:39:35.655]                               next
[17:39:35.655]                             invokeRestart(restart)
[17:39:35.655]                             muffled <- TRUE
[17:39:35.655]                             break
[17:39:35.655]                           }
[17:39:35.655]                         }
[17:39:35.655]                       }
[17:39:35.655]                       invisible(muffled)
[17:39:35.655]                     }
[17:39:35.655]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.655]                   }
[17:39:35.655]                 }
[17:39:35.655]             }
[17:39:35.655]         }))
[17:39:35.655]     }, error = function(ex) {
[17:39:35.655]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.655]                 ...future.rng), started = ...future.startTime, 
[17:39:35.655]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.655]             version = "1.8"), class = "FutureResult")
[17:39:35.655]     }, finally = {
[17:39:35.655]         if (!identical(...future.workdir, getwd())) 
[17:39:35.655]             setwd(...future.workdir)
[17:39:35.655]         {
[17:39:35.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.655]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.655]             }
[17:39:35.655]             base::options(...future.oldOptions)
[17:39:35.655]             if (.Platform$OS.type == "windows") {
[17:39:35.655]                 old_names <- names(...future.oldEnvVars)
[17:39:35.655]                 envs <- base::Sys.getenv()
[17:39:35.655]                 names <- names(envs)
[17:39:35.655]                 common <- intersect(names, old_names)
[17:39:35.655]                 added <- setdiff(names, old_names)
[17:39:35.655]                 removed <- setdiff(old_names, names)
[17:39:35.655]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.655]                   envs[common]]
[17:39:35.655]                 NAMES <- toupper(changed)
[17:39:35.655]                 args <- list()
[17:39:35.655]                 for (kk in seq_along(NAMES)) {
[17:39:35.655]                   name <- changed[[kk]]
[17:39:35.655]                   NAME <- NAMES[[kk]]
[17:39:35.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.655]                     next
[17:39:35.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.655]                 }
[17:39:35.655]                 NAMES <- toupper(added)
[17:39:35.655]                 for (kk in seq_along(NAMES)) {
[17:39:35.655]                   name <- added[[kk]]
[17:39:35.655]                   NAME <- NAMES[[kk]]
[17:39:35.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.655]                     next
[17:39:35.655]                   args[[name]] <- ""
[17:39:35.655]                 }
[17:39:35.655]                 NAMES <- toupper(removed)
[17:39:35.655]                 for (kk in seq_along(NAMES)) {
[17:39:35.655]                   name <- removed[[kk]]
[17:39:35.655]                   NAME <- NAMES[[kk]]
[17:39:35.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.655]                     next
[17:39:35.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.655]                 }
[17:39:35.655]                 if (length(args) > 0) 
[17:39:35.655]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.655]             }
[17:39:35.655]             else {
[17:39:35.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.655]             }
[17:39:35.655]             {
[17:39:35.655]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.655]                   0L) {
[17:39:35.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.655]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.655]                   base::options(opts)
[17:39:35.655]                 }
[17:39:35.655]                 {
[17:39:35.655]                   {
[17:39:35.655]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.655]                     NULL
[17:39:35.655]                   }
[17:39:35.655]                   options(future.plan = NULL)
[17:39:35.655]                   if (is.na(NA_character_)) 
[17:39:35.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.655]                     .init = FALSE)
[17:39:35.655]                 }
[17:39:35.655]             }
[17:39:35.655]         }
[17:39:35.655]     })
[17:39:35.655]     if (TRUE) {
[17:39:35.655]         base::sink(type = "output", split = FALSE)
[17:39:35.655]         if (TRUE) {
[17:39:35.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.655]         }
[17:39:35.655]         else {
[17:39:35.655]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.655]         }
[17:39:35.655]         base::close(...future.stdout)
[17:39:35.655]         ...future.stdout <- NULL
[17:39:35.655]     }
[17:39:35.655]     ...future.result$conditions <- ...future.conditions
[17:39:35.655]     ...future.result$finished <- base::Sys.time()
[17:39:35.655]     ...future.result
[17:39:35.655] }
[17:39:35.658] requestCore(): workers = 2
[17:39:35.658] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:35.669] result() for MulticoreFuture ...
[17:39:35.670] result() for MulticoreFuture ...
[17:39:35.670] result() for MulticoreFuture ... done
[17:39:35.670] result() for MulticoreFuture ... done
[17:39:35.670] result() for MulticoreFuture ...
[17:39:35.671] result() for MulticoreFuture ... done
[17:39:35.673] MulticoreFuture started
[17:39:35.674] - Launch lazy future ... done
[17:39:35.674] run() for ‘MulticoreFuture’ ... done
[17:39:35.675] plan(): Setting new future strategy stack:
<environment: 0x55adf17a21d8> 
[17:39:35.675] List of future strategies:
[17:39:35.675] 1. sequential:
[17:39:35.675]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.675]    - tweaked: FALSE
[17:39:35.675]    - call: NULL
[17:39:35.676] plan(): nbrOfWorkers() = 1
<environment: 0x55adf224b640> 
[17:39:35.679] plan(): Setting new future strategy stack:
[17:39:35.679] List of future strategies:
[17:39:35.679] 1. multicore:
[17:39:35.679]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.679]    - tweaked: FALSE
[17:39:35.679]    - call: plan(strategy)
[17:39:35.684] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:35.686] resolve() on environment ...
[17:39:35.687]  recursive: 0
[17:39:35.687]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:35.688] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.688] - nx: 4
[17:39:35.688] - relay: TRUE
[17:39:35.688] - stdout: TRUE
[17:39:35.688] - signal: TRUE
[17:39:35.688] - resignal: FALSE
[17:39:35.688] - force: TRUE
[17:39:35.689] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.689] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.689]  - until=2
[17:39:35.689]  - relaying element #2
[17:39:35.689] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.689] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.689] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.689]  length: 3 (resolved future 1)
[17:39:35.690] Future #2
[17:39:35.690] result() for MulticoreFuture ...
[17:39:35.690] result() for MulticoreFuture ... done
[17:39:35.690] result() for MulticoreFuture ...
[17:39:35.690] result() for MulticoreFuture ... done
[17:39:35.690] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:35.690] - nx: 4
[17:39:35.691] - relay: TRUE
[17:39:35.691] - stdout: TRUE
[17:39:35.691] - signal: TRUE
[17:39:35.691] - resignal: FALSE
[17:39:35.698] - force: TRUE
[17:39:35.698] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.698] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.698]  - until=2
[17:39:35.698]  - relaying element #2
[17:39:35.698] result() for MulticoreFuture ...
[17:39:35.698] result() for MulticoreFuture ... done
[17:39:35.698] result() for MulticoreFuture ...
[17:39:35.699] result() for MulticoreFuture ... done
[17:39:35.699] result() for MulticoreFuture ...
[17:39:35.699] result() for MulticoreFuture ... done
[17:39:35.699] result() for MulticoreFuture ...
[17:39:35.699] result() for MulticoreFuture ... done
[17:39:35.699] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.699] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.700] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:35.700]  length: 2 (resolved future 2)
[17:39:35.700] Future #3
[17:39:35.700] result() for MulticoreFuture ...
[17:39:35.701] result() for MulticoreFuture ...
[17:39:35.701] result() for MulticoreFuture ... done
[17:39:35.701] result() for MulticoreFuture ... done
[17:39:35.702] result() for MulticoreFuture ...
[17:39:35.702] result() for MulticoreFuture ... done
[17:39:35.702] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:35.702] - nx: 4
[17:39:35.702] - relay: TRUE
[17:39:35.702] - stdout: TRUE
[17:39:35.702] - signal: TRUE
[17:39:35.702] - resignal: FALSE
[17:39:35.703] - force: TRUE
[17:39:35.703] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.703] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.703]  - until=3
[17:39:35.703]  - relaying element #3
[17:39:35.703] result() for MulticoreFuture ...
[17:39:35.703] result() for MulticoreFuture ... done
[17:39:35.704] result() for MulticoreFuture ...
[17:39:35.704] result() for MulticoreFuture ... done
[17:39:35.704] result() for MulticoreFuture ...
[17:39:35.704] result() for MulticoreFuture ... done
[17:39:35.704] result() for MulticoreFuture ...
[17:39:35.704] result() for MulticoreFuture ... done
[17:39:35.704] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.705] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.705] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:35.705]  length: 1 (resolved future 3)
[17:39:35.705] Future #4
[17:39:35.705] result() for MulticoreFuture ...
[17:39:35.706] result() for MulticoreFuture ...
[17:39:35.706] result() for MulticoreFuture ... done
[17:39:35.707] result() for MulticoreFuture ... done
[17:39:35.707] result() for MulticoreFuture ...
[17:39:35.707] result() for MulticoreFuture ... done
[17:39:35.707] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:35.707] - nx: 4
[17:39:35.707] - relay: TRUE
[17:39:35.708] - stdout: TRUE
[17:39:35.708] - signal: TRUE
[17:39:35.708] - resignal: FALSE
[17:39:35.708] - force: TRUE
[17:39:35.708] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.708] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.709]  - until=4
[17:39:35.709]  - relaying element #4
[17:39:35.709] result() for MulticoreFuture ...
[17:39:35.709] result() for MulticoreFuture ... done
[17:39:35.709] result() for MulticoreFuture ...
[17:39:35.709] result() for MulticoreFuture ... done
[17:39:35.710] result() for MulticoreFuture ...
[17:39:35.710] result() for MulticoreFuture ... done
[17:39:35.710] result() for MulticoreFuture ...
[17:39:35.710] result() for MulticoreFuture ... done
[17:39:35.710] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.710] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.711] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:35.711]  length: 0 (resolved future 4)
[17:39:35.711] Relaying remaining futures
[17:39:35.711] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.711] - nx: 4
[17:39:35.711] - relay: TRUE
[17:39:35.711] - stdout: TRUE
[17:39:35.711] - signal: TRUE
[17:39:35.711] - resignal: FALSE
[17:39:35.711] - force: TRUE
[17:39:35.712] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.712] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:35.712] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.712] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.712] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.712] resolve() on environment ... DONE
[17:39:35.712] result() for MulticoreFuture ...
[17:39:35.712] result() for MulticoreFuture ... done
[17:39:35.713] result() for MulticoreFuture ...
[17:39:35.713] result() for MulticoreFuture ... done
[17:39:35.713] result() for MulticoreFuture ...
[17:39:35.713] result() for MulticoreFuture ... done
[17:39:35.713] result() for MulticoreFuture ...
[17:39:35.713] result() for MulticoreFuture ... done
[17:39:35.713] result() for MulticoreFuture ...
[17:39:35.713] result() for MulticoreFuture ... done
[17:39:35.713] result() for MulticoreFuture ...
[17:39:35.714] result() for MulticoreFuture ... done
<environment: 0x55adf23065b8> 
Dimensions: c(1, 6)
[17:39:35.714] getGlobalsAndPackages() ...
[17:39:35.714] Searching for globals...
[17:39:35.715] 
[17:39:35.715] Searching for globals ... DONE
[17:39:35.715] - globals: [0] <none>
[17:39:35.715] getGlobalsAndPackages() ... DONE
[17:39:35.715] run() for ‘Future’ ...
[17:39:35.715] - state: ‘created’
[17:39:35.716] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.720] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.720]   - Field: ‘label’
[17:39:35.720]   - Field: ‘local’
[17:39:35.720]   - Field: ‘owner’
[17:39:35.720]   - Field: ‘envir’
[17:39:35.720]   - Field: ‘workers’
[17:39:35.721]   - Field: ‘packages’
[17:39:35.721]   - Field: ‘gc’
[17:39:35.721]   - Field: ‘job’
[17:39:35.721]   - Field: ‘conditions’
[17:39:35.721]   - Field: ‘expr’
[17:39:35.721]   - Field: ‘uuid’
[17:39:35.721]   - Field: ‘seed’
[17:39:35.721]   - Field: ‘version’
[17:39:35.721]   - Field: ‘result’
[17:39:35.721]   - Field: ‘asynchronous’
[17:39:35.722]   - Field: ‘calls’
[17:39:35.722]   - Field: ‘globals’
[17:39:35.722]   - Field: ‘stdout’
[17:39:35.722]   - Field: ‘earlySignal’
[17:39:35.722]   - Field: ‘lazy’
[17:39:35.722]   - Field: ‘state’
[17:39:35.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.722] - Launch lazy future ...
[17:39:35.723] Packages needed by the future expression (n = 0): <none>
[17:39:35.723] Packages needed by future strategies (n = 0): <none>
[17:39:35.723] {
[17:39:35.723]     {
[17:39:35.723]         {
[17:39:35.723]             ...future.startTime <- base::Sys.time()
[17:39:35.723]             {
[17:39:35.723]                 {
[17:39:35.723]                   {
[17:39:35.723]                     {
[17:39:35.723]                       base::local({
[17:39:35.723]                         has_future <- base::requireNamespace("future", 
[17:39:35.723]                           quietly = TRUE)
[17:39:35.723]                         if (has_future) {
[17:39:35.723]                           ns <- base::getNamespace("future")
[17:39:35.723]                           version <- ns[[".package"]][["version"]]
[17:39:35.723]                           if (is.null(version)) 
[17:39:35.723]                             version <- utils::packageVersion("future")
[17:39:35.723]                         }
[17:39:35.723]                         else {
[17:39:35.723]                           version <- NULL
[17:39:35.723]                         }
[17:39:35.723]                         if (!has_future || version < "1.8.0") {
[17:39:35.723]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.723]                             "", base::R.version$version.string), 
[17:39:35.723]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.723]                               "release", "version")], collapse = " "), 
[17:39:35.723]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.723]                             info)
[17:39:35.723]                           info <- base::paste(info, collapse = "; ")
[17:39:35.723]                           if (!has_future) {
[17:39:35.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.723]                               info)
[17:39:35.723]                           }
[17:39:35.723]                           else {
[17:39:35.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.723]                               info, version)
[17:39:35.723]                           }
[17:39:35.723]                           base::stop(msg)
[17:39:35.723]                         }
[17:39:35.723]                       })
[17:39:35.723]                     }
[17:39:35.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.723]                     base::options(mc.cores = 1L)
[17:39:35.723]                   }
[17:39:35.723]                   ...future.strategy.old <- future::plan("list")
[17:39:35.723]                   options(future.plan = NULL)
[17:39:35.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.723]                 }
[17:39:35.723]                 ...future.workdir <- getwd()
[17:39:35.723]             }
[17:39:35.723]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.723]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.723]         }
[17:39:35.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.723]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.723]             base::names(...future.oldOptions))
[17:39:35.723]     }
[17:39:35.723]     if (FALSE) {
[17:39:35.723]     }
[17:39:35.723]     else {
[17:39:35.723]         if (TRUE) {
[17:39:35.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.723]                 open = "w")
[17:39:35.723]         }
[17:39:35.723]         else {
[17:39:35.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.723]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.723]         }
[17:39:35.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.723]             base::sink(type = "output", split = FALSE)
[17:39:35.723]             base::close(...future.stdout)
[17:39:35.723]         }, add = TRUE)
[17:39:35.723]     }
[17:39:35.723]     ...future.frame <- base::sys.nframe()
[17:39:35.723]     ...future.conditions <- base::list()
[17:39:35.723]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.723]     if (FALSE) {
[17:39:35.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.723]     }
[17:39:35.723]     ...future.result <- base::tryCatch({
[17:39:35.723]         base::withCallingHandlers({
[17:39:35.723]             ...future.value <- base::withVisible(base::local({
[17:39:35.723]                 withCallingHandlers({
[17:39:35.723]                   2
[17:39:35.723]                 }, immediateCondition = function(cond) {
[17:39:35.723]                   save_rds <- function (object, pathname, ...) 
[17:39:35.723]                   {
[17:39:35.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.723]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.723]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.723]                         fi_tmp[["mtime"]])
[17:39:35.723]                     }
[17:39:35.723]                     tryCatch({
[17:39:35.723]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.723]                     }, error = function(ex) {
[17:39:35.723]                       msg <- conditionMessage(ex)
[17:39:35.723]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.723]                         fi_tmp[["mtime"]], msg)
[17:39:35.723]                       ex$message <- msg
[17:39:35.723]                       stop(ex)
[17:39:35.723]                     })
[17:39:35.723]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.723]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.723]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.723]                       fi <- file.info(pathname)
[17:39:35.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.723]                         fi[["size"]], fi[["mtime"]])
[17:39:35.723]                       stop(msg)
[17:39:35.723]                     }
[17:39:35.723]                     invisible(pathname)
[17:39:35.723]                   }
[17:39:35.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.723]                     rootPath = tempdir()) 
[17:39:35.723]                   {
[17:39:35.723]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.723]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.723]                       tmpdir = path, fileext = ".rds")
[17:39:35.723]                     save_rds(obj, file)
[17:39:35.723]                   }
[17:39:35.723]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.723]                   {
[17:39:35.723]                     inherits <- base::inherits
[17:39:35.723]                     invokeRestart <- base::invokeRestart
[17:39:35.723]                     is.null <- base::is.null
[17:39:35.723]                     muffled <- FALSE
[17:39:35.723]                     if (inherits(cond, "message")) {
[17:39:35.723]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.723]                       if (muffled) 
[17:39:35.723]                         invokeRestart("muffleMessage")
[17:39:35.723]                     }
[17:39:35.723]                     else if (inherits(cond, "warning")) {
[17:39:35.723]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.723]                       if (muffled) 
[17:39:35.723]                         invokeRestart("muffleWarning")
[17:39:35.723]                     }
[17:39:35.723]                     else if (inherits(cond, "condition")) {
[17:39:35.723]                       if (!is.null(pattern)) {
[17:39:35.723]                         computeRestarts <- base::computeRestarts
[17:39:35.723]                         grepl <- base::grepl
[17:39:35.723]                         restarts <- computeRestarts(cond)
[17:39:35.723]                         for (restart in restarts) {
[17:39:35.723]                           name <- restart$name
[17:39:35.723]                           if (is.null(name)) 
[17:39:35.723]                             next
[17:39:35.723]                           if (!grepl(pattern, name)) 
[17:39:35.723]                             next
[17:39:35.723]                           invokeRestart(restart)
[17:39:35.723]                           muffled <- TRUE
[17:39:35.723]                           break
[17:39:35.723]                         }
[17:39:35.723]                       }
[17:39:35.723]                     }
[17:39:35.723]                     invisible(muffled)
[17:39:35.723]                   }
[17:39:35.723]                   muffleCondition(cond)
[17:39:35.723]                 })
[17:39:35.723]             }))
[17:39:35.723]             future::FutureResult(value = ...future.value$value, 
[17:39:35.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.723]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.723]                     ...future.globalenv.names))
[17:39:35.723]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.723]         }, condition = base::local({
[17:39:35.723]             c <- base::c
[17:39:35.723]             inherits <- base::inherits
[17:39:35.723]             invokeRestart <- base::invokeRestart
[17:39:35.723]             length <- base::length
[17:39:35.723]             list <- base::list
[17:39:35.723]             seq.int <- base::seq.int
[17:39:35.723]             signalCondition <- base::signalCondition
[17:39:35.723]             sys.calls <- base::sys.calls
[17:39:35.723]             `[[` <- base::`[[`
[17:39:35.723]             `+` <- base::`+`
[17:39:35.723]             `<<-` <- base::`<<-`
[17:39:35.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.723]                   3L)]
[17:39:35.723]             }
[17:39:35.723]             function(cond) {
[17:39:35.723]                 is_error <- inherits(cond, "error")
[17:39:35.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.723]                   NULL)
[17:39:35.723]                 if (is_error) {
[17:39:35.723]                   sessionInformation <- function() {
[17:39:35.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.723]                       search = base::search(), system = base::Sys.info())
[17:39:35.723]                   }
[17:39:35.723]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.723]                     cond$call), session = sessionInformation(), 
[17:39:35.723]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.723]                   signalCondition(cond)
[17:39:35.723]                 }
[17:39:35.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.723]                 "immediateCondition"))) {
[17:39:35.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.723]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.723]                   if (TRUE && !signal) {
[17:39:35.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.723]                     {
[17:39:35.723]                       inherits <- base::inherits
[17:39:35.723]                       invokeRestart <- base::invokeRestart
[17:39:35.723]                       is.null <- base::is.null
[17:39:35.723]                       muffled <- FALSE
[17:39:35.723]                       if (inherits(cond, "message")) {
[17:39:35.723]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.723]                         if (muffled) 
[17:39:35.723]                           invokeRestart("muffleMessage")
[17:39:35.723]                       }
[17:39:35.723]                       else if (inherits(cond, "warning")) {
[17:39:35.723]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.723]                         if (muffled) 
[17:39:35.723]                           invokeRestart("muffleWarning")
[17:39:35.723]                       }
[17:39:35.723]                       else if (inherits(cond, "condition")) {
[17:39:35.723]                         if (!is.null(pattern)) {
[17:39:35.723]                           computeRestarts <- base::computeRestarts
[17:39:35.723]                           grepl <- base::grepl
[17:39:35.723]                           restarts <- computeRestarts(cond)
[17:39:35.723]                           for (restart in restarts) {
[17:39:35.723]                             name <- restart$name
[17:39:35.723]                             if (is.null(name)) 
[17:39:35.723]                               next
[17:39:35.723]                             if (!grepl(pattern, name)) 
[17:39:35.723]                               next
[17:39:35.723]                             invokeRestart(restart)
[17:39:35.723]                             muffled <- TRUE
[17:39:35.723]                             break
[17:39:35.723]                           }
[17:39:35.723]                         }
[17:39:35.723]                       }
[17:39:35.723]                       invisible(muffled)
[17:39:35.723]                     }
[17:39:35.723]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.723]                   }
[17:39:35.723]                 }
[17:39:35.723]                 else {
[17:39:35.723]                   if (TRUE) {
[17:39:35.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.723]                     {
[17:39:35.723]                       inherits <- base::inherits
[17:39:35.723]                       invokeRestart <- base::invokeRestart
[17:39:35.723]                       is.null <- base::is.null
[17:39:35.723]                       muffled <- FALSE
[17:39:35.723]                       if (inherits(cond, "message")) {
[17:39:35.723]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.723]                         if (muffled) 
[17:39:35.723]                           invokeRestart("muffleMessage")
[17:39:35.723]                       }
[17:39:35.723]                       else if (inherits(cond, "warning")) {
[17:39:35.723]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.723]                         if (muffled) 
[17:39:35.723]                           invokeRestart("muffleWarning")
[17:39:35.723]                       }
[17:39:35.723]                       else if (inherits(cond, "condition")) {
[17:39:35.723]                         if (!is.null(pattern)) {
[17:39:35.723]                           computeRestarts <- base::computeRestarts
[17:39:35.723]                           grepl <- base::grepl
[17:39:35.723]                           restarts <- computeRestarts(cond)
[17:39:35.723]                           for (restart in restarts) {
[17:39:35.723]                             name <- restart$name
[17:39:35.723]                             if (is.null(name)) 
[17:39:35.723]                               next
[17:39:35.723]                             if (!grepl(pattern, name)) 
[17:39:35.723]                               next
[17:39:35.723]                             invokeRestart(restart)
[17:39:35.723]                             muffled <- TRUE
[17:39:35.723]                             break
[17:39:35.723]                           }
[17:39:35.723]                         }
[17:39:35.723]                       }
[17:39:35.723]                       invisible(muffled)
[17:39:35.723]                     }
[17:39:35.723]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.723]                   }
[17:39:35.723]                 }
[17:39:35.723]             }
[17:39:35.723]         }))
[17:39:35.723]     }, error = function(ex) {
[17:39:35.723]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.723]                 ...future.rng), started = ...future.startTime, 
[17:39:35.723]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.723]             version = "1.8"), class = "FutureResult")
[17:39:35.723]     }, finally = {
[17:39:35.723]         if (!identical(...future.workdir, getwd())) 
[17:39:35.723]             setwd(...future.workdir)
[17:39:35.723]         {
[17:39:35.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.723]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.723]             }
[17:39:35.723]             base::options(...future.oldOptions)
[17:39:35.723]             if (.Platform$OS.type == "windows") {
[17:39:35.723]                 old_names <- names(...future.oldEnvVars)
[17:39:35.723]                 envs <- base::Sys.getenv()
[17:39:35.723]                 names <- names(envs)
[17:39:35.723]                 common <- intersect(names, old_names)
[17:39:35.723]                 added <- setdiff(names, old_names)
[17:39:35.723]                 removed <- setdiff(old_names, names)
[17:39:35.723]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.723]                   envs[common]]
[17:39:35.723]                 NAMES <- toupper(changed)
[17:39:35.723]                 args <- list()
[17:39:35.723]                 for (kk in seq_along(NAMES)) {
[17:39:35.723]                   name <- changed[[kk]]
[17:39:35.723]                   NAME <- NAMES[[kk]]
[17:39:35.723]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.723]                     next
[17:39:35.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.723]                 }
[17:39:35.723]                 NAMES <- toupper(added)
[17:39:35.723]                 for (kk in seq_along(NAMES)) {
[17:39:35.723]                   name <- added[[kk]]
[17:39:35.723]                   NAME <- NAMES[[kk]]
[17:39:35.723]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.723]                     next
[17:39:35.723]                   args[[name]] <- ""
[17:39:35.723]                 }
[17:39:35.723]                 NAMES <- toupper(removed)
[17:39:35.723]                 for (kk in seq_along(NAMES)) {
[17:39:35.723]                   name <- removed[[kk]]
[17:39:35.723]                   NAME <- NAMES[[kk]]
[17:39:35.723]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.723]                     next
[17:39:35.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.723]                 }
[17:39:35.723]                 if (length(args) > 0) 
[17:39:35.723]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.723]             }
[17:39:35.723]             else {
[17:39:35.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.723]             }
[17:39:35.723]             {
[17:39:35.723]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.723]                   0L) {
[17:39:35.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.723]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.723]                   base::options(opts)
[17:39:35.723]                 }
[17:39:35.723]                 {
[17:39:35.723]                   {
[17:39:35.723]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.723]                     NULL
[17:39:35.723]                   }
[17:39:35.723]                   options(future.plan = NULL)
[17:39:35.723]                   if (is.na(NA_character_)) 
[17:39:35.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.723]                     .init = FALSE)
[17:39:35.723]                 }
[17:39:35.723]             }
[17:39:35.723]         }
[17:39:35.723]     })
[17:39:35.723]     if (TRUE) {
[17:39:35.723]         base::sink(type = "output", split = FALSE)
[17:39:35.723]         if (TRUE) {
[17:39:35.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.723]         }
[17:39:35.723]         else {
[17:39:35.723]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.723]         }
[17:39:35.723]         base::close(...future.stdout)
[17:39:35.723]         ...future.stdout <- NULL
[17:39:35.723]     }
[17:39:35.723]     ...future.result$conditions <- ...future.conditions
[17:39:35.723]     ...future.result$finished <- base::Sys.time()
[17:39:35.723]     ...future.result
[17:39:35.723] }
[17:39:35.726] requestCore(): workers = 2
[17:39:35.728] MulticoreFuture started
[17:39:35.729] - Launch lazy future ... done
[17:39:35.729] run() for ‘MulticoreFuture’ ... done
[17:39:35.729] getGlobalsAndPackages() ...
[17:39:35.729] Searching for globals...
[17:39:35.730] plan(): Setting new future strategy stack:
[17:39:35.730] 
[17:39:35.730] Searching for globals ... DONE
[17:39:35.731] - globals: [0] <none>
[17:39:35.730] List of future strategies:
[17:39:35.730] 1. sequential:
[17:39:35.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.730]    - tweaked: FALSE
[17:39:35.730]    - call: NULL
[17:39:35.731] getGlobalsAndPackages() ... DONE
[17:39:35.731] plan(): nbrOfWorkers() = 1
[17:39:35.731] run() for ‘Future’ ...
[17:39:35.732] - state: ‘created’
[17:39:35.732] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.733] plan(): Setting new future strategy stack:
[17:39:35.733] List of future strategies:
[17:39:35.733] 1. multicore:
[17:39:35.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.733]    - tweaked: FALSE
[17:39:35.733]    - call: plan(strategy)
[17:39:35.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.738] plan(): nbrOfWorkers() = 2
[17:39:35.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.739]   - Field: ‘label’
[17:39:35.739]   - Field: ‘local’
[17:39:35.739]   - Field: ‘owner’
[17:39:35.739]   - Field: ‘envir’
[17:39:35.739]   - Field: ‘workers’
[17:39:35.740]   - Field: ‘packages’
[17:39:35.740]   - Field: ‘gc’
[17:39:35.740]   - Field: ‘job’
[17:39:35.740]   - Field: ‘conditions’
[17:39:35.740]   - Field: ‘expr’
[17:39:35.741]   - Field: ‘uuid’
[17:39:35.741]   - Field: ‘seed’
[17:39:35.741]   - Field: ‘version’
[17:39:35.741]   - Field: ‘result’
[17:39:35.741]   - Field: ‘asynchronous’
[17:39:35.741]   - Field: ‘calls’
[17:39:35.742]   - Field: ‘globals’
[17:39:35.742]   - Field: ‘stdout’
[17:39:35.742]   - Field: ‘earlySignal’
[17:39:35.742]   - Field: ‘lazy’
[17:39:35.742]   - Field: ‘state’
[17:39:35.743] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.743] - Launch lazy future ...
[17:39:35.744] Packages needed by the future expression (n = 0): <none>
[17:39:35.744] Packages needed by future strategies (n = 0): <none>
[17:39:35.745] {
[17:39:35.745]     {
[17:39:35.745]         {
[17:39:35.745]             ...future.startTime <- base::Sys.time()
[17:39:35.745]             {
[17:39:35.745]                 {
[17:39:35.745]                   {
[17:39:35.745]                     {
[17:39:35.745]                       base::local({
[17:39:35.745]                         has_future <- base::requireNamespace("future", 
[17:39:35.745]                           quietly = TRUE)
[17:39:35.745]                         if (has_future) {
[17:39:35.745]                           ns <- base::getNamespace("future")
[17:39:35.745]                           version <- ns[[".package"]][["version"]]
[17:39:35.745]                           if (is.null(version)) 
[17:39:35.745]                             version <- utils::packageVersion("future")
[17:39:35.745]                         }
[17:39:35.745]                         else {
[17:39:35.745]                           version <- NULL
[17:39:35.745]                         }
[17:39:35.745]                         if (!has_future || version < "1.8.0") {
[17:39:35.745]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.745]                             "", base::R.version$version.string), 
[17:39:35.745]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.745]                               "release", "version")], collapse = " "), 
[17:39:35.745]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.745]                             info)
[17:39:35.745]                           info <- base::paste(info, collapse = "; ")
[17:39:35.745]                           if (!has_future) {
[17:39:35.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.745]                               info)
[17:39:35.745]                           }
[17:39:35.745]                           else {
[17:39:35.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.745]                               info, version)
[17:39:35.745]                           }
[17:39:35.745]                           base::stop(msg)
[17:39:35.745]                         }
[17:39:35.745]                       })
[17:39:35.745]                     }
[17:39:35.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.745]                     base::options(mc.cores = 1L)
[17:39:35.745]                   }
[17:39:35.745]                   ...future.strategy.old <- future::plan("list")
[17:39:35.745]                   options(future.plan = NULL)
[17:39:35.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.745]                 }
[17:39:35.745]                 ...future.workdir <- getwd()
[17:39:35.745]             }
[17:39:35.745]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.745]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.745]         }
[17:39:35.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.745]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.745]             base::names(...future.oldOptions))
[17:39:35.745]     }
[17:39:35.745]     if (FALSE) {
[17:39:35.745]     }
[17:39:35.745]     else {
[17:39:35.745]         if (TRUE) {
[17:39:35.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.745]                 open = "w")
[17:39:35.745]         }
[17:39:35.745]         else {
[17:39:35.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.745]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.745]         }
[17:39:35.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.745]             base::sink(type = "output", split = FALSE)
[17:39:35.745]             base::close(...future.stdout)
[17:39:35.745]         }, add = TRUE)
[17:39:35.745]     }
[17:39:35.745]     ...future.frame <- base::sys.nframe()
[17:39:35.745]     ...future.conditions <- base::list()
[17:39:35.745]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.745]     if (FALSE) {
[17:39:35.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.745]     }
[17:39:35.745]     ...future.result <- base::tryCatch({
[17:39:35.745]         base::withCallingHandlers({
[17:39:35.745]             ...future.value <- base::withVisible(base::local({
[17:39:35.745]                 withCallingHandlers({
[17:39:35.745]                   NULL
[17:39:35.745]                 }, immediateCondition = function(cond) {
[17:39:35.745]                   save_rds <- function (object, pathname, ...) 
[17:39:35.745]                   {
[17:39:35.745]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.745]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.745]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.745]                         fi_tmp[["mtime"]])
[17:39:35.745]                     }
[17:39:35.745]                     tryCatch({
[17:39:35.745]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.745]                     }, error = function(ex) {
[17:39:35.745]                       msg <- conditionMessage(ex)
[17:39:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.745]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.745]                         fi_tmp[["mtime"]], msg)
[17:39:35.745]                       ex$message <- msg
[17:39:35.745]                       stop(ex)
[17:39:35.745]                     })
[17:39:35.745]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.745]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.745]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.745]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.745]                       fi <- file.info(pathname)
[17:39:35.745]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.745]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.745]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.745]                         fi[["size"]], fi[["mtime"]])
[17:39:35.745]                       stop(msg)
[17:39:35.745]                     }
[17:39:35.745]                     invisible(pathname)
[17:39:35.745]                   }
[17:39:35.745]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.745]                     rootPath = tempdir()) 
[17:39:35.745]                   {
[17:39:35.745]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.745]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.745]                       tmpdir = path, fileext = ".rds")
[17:39:35.745]                     save_rds(obj, file)
[17:39:35.745]                   }
[17:39:35.745]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.745]                   {
[17:39:35.745]                     inherits <- base::inherits
[17:39:35.745]                     invokeRestart <- base::invokeRestart
[17:39:35.745]                     is.null <- base::is.null
[17:39:35.745]                     muffled <- FALSE
[17:39:35.745]                     if (inherits(cond, "message")) {
[17:39:35.745]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.745]                       if (muffled) 
[17:39:35.745]                         invokeRestart("muffleMessage")
[17:39:35.745]                     }
[17:39:35.745]                     else if (inherits(cond, "warning")) {
[17:39:35.745]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.745]                       if (muffled) 
[17:39:35.745]                         invokeRestart("muffleWarning")
[17:39:35.745]                     }
[17:39:35.745]                     else if (inherits(cond, "condition")) {
[17:39:35.745]                       if (!is.null(pattern)) {
[17:39:35.745]                         computeRestarts <- base::computeRestarts
[17:39:35.745]                         grepl <- base::grepl
[17:39:35.745]                         restarts <- computeRestarts(cond)
[17:39:35.745]                         for (restart in restarts) {
[17:39:35.745]                           name <- restart$name
[17:39:35.745]                           if (is.null(name)) 
[17:39:35.745]                             next
[17:39:35.745]                           if (!grepl(pattern, name)) 
[17:39:35.745]                             next
[17:39:35.745]                           invokeRestart(restart)
[17:39:35.745]                           muffled <- TRUE
[17:39:35.745]                           break
[17:39:35.745]                         }
[17:39:35.745]                       }
[17:39:35.745]                     }
[17:39:35.745]                     invisible(muffled)
[17:39:35.745]                   }
[17:39:35.745]                   muffleCondition(cond)
[17:39:35.745]                 })
[17:39:35.745]             }))
[17:39:35.745]             future::FutureResult(value = ...future.value$value, 
[17:39:35.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.745]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.745]                     ...future.globalenv.names))
[17:39:35.745]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.745]         }, condition = base::local({
[17:39:35.745]             c <- base::c
[17:39:35.745]             inherits <- base::inherits
[17:39:35.745]             invokeRestart <- base::invokeRestart
[17:39:35.745]             length <- base::length
[17:39:35.745]             list <- base::list
[17:39:35.745]             seq.int <- base::seq.int
[17:39:35.745]             signalCondition <- base::signalCondition
[17:39:35.745]             sys.calls <- base::sys.calls
[17:39:35.745]             `[[` <- base::`[[`
[17:39:35.745]             `+` <- base::`+`
[17:39:35.745]             `<<-` <- base::`<<-`
[17:39:35.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.745]                   3L)]
[17:39:35.745]             }
[17:39:35.745]             function(cond) {
[17:39:35.745]                 is_error <- inherits(cond, "error")
[17:39:35.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.745]                   NULL)
[17:39:35.745]                 if (is_error) {
[17:39:35.745]                   sessionInformation <- function() {
[17:39:35.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.745]                       search = base::search(), system = base::Sys.info())
[17:39:35.745]                   }
[17:39:35.745]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.745]                     cond$call), session = sessionInformation(), 
[17:39:35.745]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.745]                   signalCondition(cond)
[17:39:35.745]                 }
[17:39:35.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.745]                 "immediateCondition"))) {
[17:39:35.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.745]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.745]                   if (TRUE && !signal) {
[17:39:35.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.745]                     {
[17:39:35.745]                       inherits <- base::inherits
[17:39:35.745]                       invokeRestart <- base::invokeRestart
[17:39:35.745]                       is.null <- base::is.null
[17:39:35.745]                       muffled <- FALSE
[17:39:35.745]                       if (inherits(cond, "message")) {
[17:39:35.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.745]                         if (muffled) 
[17:39:35.745]                           invokeRestart("muffleMessage")
[17:39:35.745]                       }
[17:39:35.745]                       else if (inherits(cond, "warning")) {
[17:39:35.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.745]                         if (muffled) 
[17:39:35.745]                           invokeRestart("muffleWarning")
[17:39:35.745]                       }
[17:39:35.745]                       else if (inherits(cond, "condition")) {
[17:39:35.745]                         if (!is.null(pattern)) {
[17:39:35.745]                           computeRestarts <- base::computeRestarts
[17:39:35.745]                           grepl <- base::grepl
[17:39:35.745]                           restarts <- computeRestarts(cond)
[17:39:35.745]                           for (restart in restarts) {
[17:39:35.745]                             name <- restart$name
[17:39:35.745]                             if (is.null(name)) 
[17:39:35.745]                               next
[17:39:35.745]                             if (!grepl(pattern, name)) 
[17:39:35.745]                               next
[17:39:35.745]                             invokeRestart(restart)
[17:39:35.745]                             muffled <- TRUE
[17:39:35.745]                             break
[17:39:35.745]                           }
[17:39:35.745]                         }
[17:39:35.745]                       }
[17:39:35.745]                       invisible(muffled)
[17:39:35.745]                     }
[17:39:35.745]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.745]                   }
[17:39:35.745]                 }
[17:39:35.745]                 else {
[17:39:35.745]                   if (TRUE) {
[17:39:35.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.745]                     {
[17:39:35.745]                       inherits <- base::inherits
[17:39:35.745]                       invokeRestart <- base::invokeRestart
[17:39:35.745]                       is.null <- base::is.null
[17:39:35.745]                       muffled <- FALSE
[17:39:35.745]                       if (inherits(cond, "message")) {
[17:39:35.745]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.745]                         if (muffled) 
[17:39:35.745]                           invokeRestart("muffleMessage")
[17:39:35.745]                       }
[17:39:35.745]                       else if (inherits(cond, "warning")) {
[17:39:35.745]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.745]                         if (muffled) 
[17:39:35.745]                           invokeRestart("muffleWarning")
[17:39:35.745]                       }
[17:39:35.745]                       else if (inherits(cond, "condition")) {
[17:39:35.745]                         if (!is.null(pattern)) {
[17:39:35.745]                           computeRestarts <- base::computeRestarts
[17:39:35.745]                           grepl <- base::grepl
[17:39:35.745]                           restarts <- computeRestarts(cond)
[17:39:35.745]                           for (restart in restarts) {
[17:39:35.745]                             name <- restart$name
[17:39:35.745]                             if (is.null(name)) 
[17:39:35.745]                               next
[17:39:35.745]                             if (!grepl(pattern, name)) 
[17:39:35.745]                               next
[17:39:35.745]                             invokeRestart(restart)
[17:39:35.745]                             muffled <- TRUE
[17:39:35.745]                             break
[17:39:35.745]                           }
[17:39:35.745]                         }
[17:39:35.745]                       }
[17:39:35.745]                       invisible(muffled)
[17:39:35.745]                     }
[17:39:35.745]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.745]                   }
[17:39:35.745]                 }
[17:39:35.745]             }
[17:39:35.745]         }))
[17:39:35.745]     }, error = function(ex) {
[17:39:35.745]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.745]                 ...future.rng), started = ...future.startTime, 
[17:39:35.745]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.745]             version = "1.8"), class = "FutureResult")
[17:39:35.745]     }, finally = {
[17:39:35.745]         if (!identical(...future.workdir, getwd())) 
[17:39:35.745]             setwd(...future.workdir)
[17:39:35.745]         {
[17:39:35.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.745]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.745]             }
[17:39:35.745]             base::options(...future.oldOptions)
[17:39:35.745]             if (.Platform$OS.type == "windows") {
[17:39:35.745]                 old_names <- names(...future.oldEnvVars)
[17:39:35.745]                 envs <- base::Sys.getenv()
[17:39:35.745]                 names <- names(envs)
[17:39:35.745]                 common <- intersect(names, old_names)
[17:39:35.745]                 added <- setdiff(names, old_names)
[17:39:35.745]                 removed <- setdiff(old_names, names)
[17:39:35.745]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.745]                   envs[common]]
[17:39:35.745]                 NAMES <- toupper(changed)
[17:39:35.745]                 args <- list()
[17:39:35.745]                 for (kk in seq_along(NAMES)) {
[17:39:35.745]                   name <- changed[[kk]]
[17:39:35.745]                   NAME <- NAMES[[kk]]
[17:39:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.745]                     next
[17:39:35.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.745]                 }
[17:39:35.745]                 NAMES <- toupper(added)
[17:39:35.745]                 for (kk in seq_along(NAMES)) {
[17:39:35.745]                   name <- added[[kk]]
[17:39:35.745]                   NAME <- NAMES[[kk]]
[17:39:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.745]                     next
[17:39:35.745]                   args[[name]] <- ""
[17:39:35.745]                 }
[17:39:35.745]                 NAMES <- toupper(removed)
[17:39:35.745]                 for (kk in seq_along(NAMES)) {
[17:39:35.745]                   name <- removed[[kk]]
[17:39:35.745]                   NAME <- NAMES[[kk]]
[17:39:35.745]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.745]                     next
[17:39:35.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.745]                 }
[17:39:35.745]                 if (length(args) > 0) 
[17:39:35.745]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.745]             }
[17:39:35.745]             else {
[17:39:35.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.745]             }
[17:39:35.745]             {
[17:39:35.745]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.745]                   0L) {
[17:39:35.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.745]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.745]                   base::options(opts)
[17:39:35.745]                 }
[17:39:35.745]                 {
[17:39:35.745]                   {
[17:39:35.745]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.745]                     NULL
[17:39:35.745]                   }
[17:39:35.745]                   options(future.plan = NULL)
[17:39:35.745]                   if (is.na(NA_character_)) 
[17:39:35.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.745]                     .init = FALSE)
[17:39:35.745]                 }
[17:39:35.745]             }
[17:39:35.745]         }
[17:39:35.745]     })
[17:39:35.745]     if (TRUE) {
[17:39:35.745]         base::sink(type = "output", split = FALSE)
[17:39:35.745]         if (TRUE) {
[17:39:35.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.745]         }
[17:39:35.745]         else {
[17:39:35.745]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.745]         }
[17:39:35.745]         base::close(...future.stdout)
[17:39:35.745]         ...future.stdout <- NULL
[17:39:35.745]     }
[17:39:35.745]     ...future.result$conditions <- ...future.conditions
[17:39:35.745]     ...future.result$finished <- base::Sys.time()
[17:39:35.745]     ...future.result
[17:39:35.745] }
[17:39:35.748] requestCore(): workers = 2
[17:39:35.752] MulticoreFuture started
[17:39:35.752] - Launch lazy future ... done
[17:39:35.752] run() for ‘MulticoreFuture’ ... done
[17:39:35.753] plan(): Setting new future strategy stack:
[17:39:35.753] getGlobalsAndPackages() ...
[17:39:35.754] Searching for globals...
[17:39:35.753] List of future strategies:
[17:39:35.753] 1. sequential:
[17:39:35.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.753]    - tweaked: FALSE
[17:39:35.753]    - call: NULL
[17:39:35.755] plan(): nbrOfWorkers() = 1
[17:39:35.755] - globals found: [1] ‘{’
[17:39:35.755] Searching for globals ... DONE
[17:39:35.756] Resolving globals: FALSE
[17:39:35.756] 
[17:39:35.756] 
[17:39:35.757] getGlobalsAndPackages() ... DONE
[17:39:35.757] plan(): Setting new future strategy stack:
[17:39:35.757] run() for ‘Future’ ...
[17:39:35.757] - state: ‘created’
[17:39:35.757] List of future strategies:
[17:39:35.757] 1. multicore:
[17:39:35.757]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.757]    - tweaked: FALSE
[17:39:35.757]    - call: plan(strategy)
[17:39:35.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.762] plan(): nbrOfWorkers() = 2
[17:39:35.763] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.763] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.764]   - Field: ‘label’
[17:39:35.764]   - Field: ‘local’
[17:39:35.764]   - Field: ‘owner’
[17:39:35.764]   - Field: ‘envir’
[17:39:35.764]   - Field: ‘workers’
[17:39:35.764]   - Field: ‘packages’
[17:39:35.765]   - Field: ‘gc’
[17:39:35.765]   - Field: ‘job’
[17:39:35.765]   - Field: ‘conditions’
[17:39:35.765]   - Field: ‘expr’
[17:39:35.765]   - Field: ‘uuid’
[17:39:35.765]   - Field: ‘seed’
[17:39:35.766]   - Field: ‘version’
[17:39:35.766]   - Field: ‘result’
[17:39:35.766]   - Field: ‘asynchronous’
[17:39:35.766]   - Field: ‘calls’
[17:39:35.766]   - Field: ‘globals’
[17:39:35.766]   - Field: ‘stdout’
[17:39:35.766]   - Field: ‘earlySignal’
[17:39:35.767]   - Field: ‘lazy’
[17:39:35.767]   - Field: ‘state’
[17:39:35.767] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.767] - Launch lazy future ...
[17:39:35.768] Packages needed by the future expression (n = 0): <none>
[17:39:35.768] Packages needed by future strategies (n = 0): <none>
[17:39:35.769] {
[17:39:35.769]     {
[17:39:35.769]         {
[17:39:35.769]             ...future.startTime <- base::Sys.time()
[17:39:35.769]             {
[17:39:35.769]                 {
[17:39:35.769]                   {
[17:39:35.769]                     {
[17:39:35.769]                       base::local({
[17:39:35.769]                         has_future <- base::requireNamespace("future", 
[17:39:35.769]                           quietly = TRUE)
[17:39:35.769]                         if (has_future) {
[17:39:35.769]                           ns <- base::getNamespace("future")
[17:39:35.769]                           version <- ns[[".package"]][["version"]]
[17:39:35.769]                           if (is.null(version)) 
[17:39:35.769]                             version <- utils::packageVersion("future")
[17:39:35.769]                         }
[17:39:35.769]                         else {
[17:39:35.769]                           version <- NULL
[17:39:35.769]                         }
[17:39:35.769]                         if (!has_future || version < "1.8.0") {
[17:39:35.769]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.769]                             "", base::R.version$version.string), 
[17:39:35.769]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.769]                               "release", "version")], collapse = " "), 
[17:39:35.769]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.769]                             info)
[17:39:35.769]                           info <- base::paste(info, collapse = "; ")
[17:39:35.769]                           if (!has_future) {
[17:39:35.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.769]                               info)
[17:39:35.769]                           }
[17:39:35.769]                           else {
[17:39:35.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.769]                               info, version)
[17:39:35.769]                           }
[17:39:35.769]                           base::stop(msg)
[17:39:35.769]                         }
[17:39:35.769]                       })
[17:39:35.769]                     }
[17:39:35.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.769]                     base::options(mc.cores = 1L)
[17:39:35.769]                   }
[17:39:35.769]                   ...future.strategy.old <- future::plan("list")
[17:39:35.769]                   options(future.plan = NULL)
[17:39:35.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.769]                 }
[17:39:35.769]                 ...future.workdir <- getwd()
[17:39:35.769]             }
[17:39:35.769]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.769]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.769]         }
[17:39:35.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.769]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.769]             base::names(...future.oldOptions))
[17:39:35.769]     }
[17:39:35.769]     if (FALSE) {
[17:39:35.769]     }
[17:39:35.769]     else {
[17:39:35.769]         if (TRUE) {
[17:39:35.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.769]                 open = "w")
[17:39:35.769]         }
[17:39:35.769]         else {
[17:39:35.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.769]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.769]         }
[17:39:35.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.769]             base::sink(type = "output", split = FALSE)
[17:39:35.769]             base::close(...future.stdout)
[17:39:35.769]         }, add = TRUE)
[17:39:35.769]     }
[17:39:35.769]     ...future.frame <- base::sys.nframe()
[17:39:35.769]     ...future.conditions <- base::list()
[17:39:35.769]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.769]     if (FALSE) {
[17:39:35.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.769]     }
[17:39:35.769]     ...future.result <- base::tryCatch({
[17:39:35.769]         base::withCallingHandlers({
[17:39:35.769]             ...future.value <- base::withVisible(base::local({
[17:39:35.769]                 withCallingHandlers({
[17:39:35.769]                   {
[17:39:35.769]                     4
[17:39:35.769]                   }
[17:39:35.769]                 }, immediateCondition = function(cond) {
[17:39:35.769]                   save_rds <- function (object, pathname, ...) 
[17:39:35.769]                   {
[17:39:35.769]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.769]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.769]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.769]                         fi_tmp[["mtime"]])
[17:39:35.769]                     }
[17:39:35.769]                     tryCatch({
[17:39:35.769]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.769]                     }, error = function(ex) {
[17:39:35.769]                       msg <- conditionMessage(ex)
[17:39:35.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.769]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.769]                         fi_tmp[["mtime"]], msg)
[17:39:35.769]                       ex$message <- msg
[17:39:35.769]                       stop(ex)
[17:39:35.769]                     })
[17:39:35.769]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.769]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.769]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.769]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.769]                       fi <- file.info(pathname)
[17:39:35.769]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.769]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.769]                         fi[["size"]], fi[["mtime"]])
[17:39:35.769]                       stop(msg)
[17:39:35.769]                     }
[17:39:35.769]                     invisible(pathname)
[17:39:35.769]                   }
[17:39:35.769]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.769]                     rootPath = tempdir()) 
[17:39:35.769]                   {
[17:39:35.769]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.769]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.769]                       tmpdir = path, fileext = ".rds")
[17:39:35.769]                     save_rds(obj, file)
[17:39:35.769]                   }
[17:39:35.769]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.769]                   {
[17:39:35.769]                     inherits <- base::inherits
[17:39:35.769]                     invokeRestart <- base::invokeRestart
[17:39:35.769]                     is.null <- base::is.null
[17:39:35.769]                     muffled <- FALSE
[17:39:35.769]                     if (inherits(cond, "message")) {
[17:39:35.769]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.769]                       if (muffled) 
[17:39:35.769]                         invokeRestart("muffleMessage")
[17:39:35.769]                     }
[17:39:35.769]                     else if (inherits(cond, "warning")) {
[17:39:35.769]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.769]                       if (muffled) 
[17:39:35.769]                         invokeRestart("muffleWarning")
[17:39:35.769]                     }
[17:39:35.769]                     else if (inherits(cond, "condition")) {
[17:39:35.769]                       if (!is.null(pattern)) {
[17:39:35.769]                         computeRestarts <- base::computeRestarts
[17:39:35.769]                         grepl <- base::grepl
[17:39:35.769]                         restarts <- computeRestarts(cond)
[17:39:35.769]                         for (restart in restarts) {
[17:39:35.769]                           name <- restart$name
[17:39:35.769]                           if (is.null(name)) 
[17:39:35.769]                             next
[17:39:35.769]                           if (!grepl(pattern, name)) 
[17:39:35.769]                             next
[17:39:35.769]                           invokeRestart(restart)
[17:39:35.769]                           muffled <- TRUE
[17:39:35.769]                           break
[17:39:35.769]                         }
[17:39:35.769]                       }
[17:39:35.769]                     }
[17:39:35.769]                     invisible(muffled)
[17:39:35.769]                   }
[17:39:35.769]                   muffleCondition(cond)
[17:39:35.769]                 })
[17:39:35.769]             }))
[17:39:35.769]             future::FutureResult(value = ...future.value$value, 
[17:39:35.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.769]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.769]                     ...future.globalenv.names))
[17:39:35.769]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.769]         }, condition = base::local({
[17:39:35.769]             c <- base::c
[17:39:35.769]             inherits <- base::inherits
[17:39:35.769]             invokeRestart <- base::invokeRestart
[17:39:35.769]             length <- base::length
[17:39:35.769]             list <- base::list
[17:39:35.769]             seq.int <- base::seq.int
[17:39:35.769]             signalCondition <- base::signalCondition
[17:39:35.769]             sys.calls <- base::sys.calls
[17:39:35.769]             `[[` <- base::`[[`
[17:39:35.769]             `+` <- base::`+`
[17:39:35.769]             `<<-` <- base::`<<-`
[17:39:35.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.769]                   3L)]
[17:39:35.769]             }
[17:39:35.769]             function(cond) {
[17:39:35.769]                 is_error <- inherits(cond, "error")
[17:39:35.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.769]                   NULL)
[17:39:35.769]                 if (is_error) {
[17:39:35.769]                   sessionInformation <- function() {
[17:39:35.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.769]                       search = base::search(), system = base::Sys.info())
[17:39:35.769]                   }
[17:39:35.769]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.769]                     cond$call), session = sessionInformation(), 
[17:39:35.769]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.769]                   signalCondition(cond)
[17:39:35.769]                 }
[17:39:35.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.769]                 "immediateCondition"))) {
[17:39:35.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.769]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.769]                   if (TRUE && !signal) {
[17:39:35.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.769]                     {
[17:39:35.769]                       inherits <- base::inherits
[17:39:35.769]                       invokeRestart <- base::invokeRestart
[17:39:35.769]                       is.null <- base::is.null
[17:39:35.769]                       muffled <- FALSE
[17:39:35.769]                       if (inherits(cond, "message")) {
[17:39:35.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.769]                         if (muffled) 
[17:39:35.769]                           invokeRestart("muffleMessage")
[17:39:35.769]                       }
[17:39:35.769]                       else if (inherits(cond, "warning")) {
[17:39:35.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.769]                         if (muffled) 
[17:39:35.769]                           invokeRestart("muffleWarning")
[17:39:35.769]                       }
[17:39:35.769]                       else if (inherits(cond, "condition")) {
[17:39:35.769]                         if (!is.null(pattern)) {
[17:39:35.769]                           computeRestarts <- base::computeRestarts
[17:39:35.769]                           grepl <- base::grepl
[17:39:35.769]                           restarts <- computeRestarts(cond)
[17:39:35.769]                           for (restart in restarts) {
[17:39:35.769]                             name <- restart$name
[17:39:35.769]                             if (is.null(name)) 
[17:39:35.769]                               next
[17:39:35.769]                             if (!grepl(pattern, name)) 
[17:39:35.769]                               next
[17:39:35.769]                             invokeRestart(restart)
[17:39:35.769]                             muffled <- TRUE
[17:39:35.769]                             break
[17:39:35.769]                           }
[17:39:35.769]                         }
[17:39:35.769]                       }
[17:39:35.769]                       invisible(muffled)
[17:39:35.769]                     }
[17:39:35.769]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.769]                   }
[17:39:35.769]                 }
[17:39:35.769]                 else {
[17:39:35.769]                   if (TRUE) {
[17:39:35.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.769]                     {
[17:39:35.769]                       inherits <- base::inherits
[17:39:35.769]                       invokeRestart <- base::invokeRestart
[17:39:35.769]                       is.null <- base::is.null
[17:39:35.769]                       muffled <- FALSE
[17:39:35.769]                       if (inherits(cond, "message")) {
[17:39:35.769]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.769]                         if (muffled) 
[17:39:35.769]                           invokeRestart("muffleMessage")
[17:39:35.769]                       }
[17:39:35.769]                       else if (inherits(cond, "warning")) {
[17:39:35.769]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.769]                         if (muffled) 
[17:39:35.769]                           invokeRestart("muffleWarning")
[17:39:35.769]                       }
[17:39:35.769]                       else if (inherits(cond, "condition")) {
[17:39:35.769]                         if (!is.null(pattern)) {
[17:39:35.769]                           computeRestarts <- base::computeRestarts
[17:39:35.769]                           grepl <- base::grepl
[17:39:35.769]                           restarts <- computeRestarts(cond)
[17:39:35.769]                           for (restart in restarts) {
[17:39:35.769]                             name <- restart$name
[17:39:35.769]                             if (is.null(name)) 
[17:39:35.769]                               next
[17:39:35.769]                             if (!grepl(pattern, name)) 
[17:39:35.769]                               next
[17:39:35.769]                             invokeRestart(restart)
[17:39:35.769]                             muffled <- TRUE
[17:39:35.769]                             break
[17:39:35.769]                           }
[17:39:35.769]                         }
[17:39:35.769]                       }
[17:39:35.769]                       invisible(muffled)
[17:39:35.769]                     }
[17:39:35.769]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.769]                   }
[17:39:35.769]                 }
[17:39:35.769]             }
[17:39:35.769]         }))
[17:39:35.769]     }, error = function(ex) {
[17:39:35.769]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.769]                 ...future.rng), started = ...future.startTime, 
[17:39:35.769]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.769]             version = "1.8"), class = "FutureResult")
[17:39:35.769]     }, finally = {
[17:39:35.769]         if (!identical(...future.workdir, getwd())) 
[17:39:35.769]             setwd(...future.workdir)
[17:39:35.769]         {
[17:39:35.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.769]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.769]             }
[17:39:35.769]             base::options(...future.oldOptions)
[17:39:35.769]             if (.Platform$OS.type == "windows") {
[17:39:35.769]                 old_names <- names(...future.oldEnvVars)
[17:39:35.769]                 envs <- base::Sys.getenv()
[17:39:35.769]                 names <- names(envs)
[17:39:35.769]                 common <- intersect(names, old_names)
[17:39:35.769]                 added <- setdiff(names, old_names)
[17:39:35.769]                 removed <- setdiff(old_names, names)
[17:39:35.769]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.769]                   envs[common]]
[17:39:35.769]                 NAMES <- toupper(changed)
[17:39:35.769]                 args <- list()
[17:39:35.769]                 for (kk in seq_along(NAMES)) {
[17:39:35.769]                   name <- changed[[kk]]
[17:39:35.769]                   NAME <- NAMES[[kk]]
[17:39:35.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.769]                     next
[17:39:35.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.769]                 }
[17:39:35.769]                 NAMES <- toupper(added)
[17:39:35.769]                 for (kk in seq_along(NAMES)) {
[17:39:35.769]                   name <- added[[kk]]
[17:39:35.769]                   NAME <- NAMES[[kk]]
[17:39:35.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.769]                     next
[17:39:35.769]                   args[[name]] <- ""
[17:39:35.769]                 }
[17:39:35.769]                 NAMES <- toupper(removed)
[17:39:35.769]                 for (kk in seq_along(NAMES)) {
[17:39:35.769]                   name <- removed[[kk]]
[17:39:35.769]                   NAME <- NAMES[[kk]]
[17:39:35.769]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.769]                     next
[17:39:35.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.769]                 }
[17:39:35.769]                 if (length(args) > 0) 
[17:39:35.769]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.769]             }
[17:39:35.769]             else {
[17:39:35.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.769]             }
[17:39:35.769]             {
[17:39:35.769]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.769]                   0L) {
[17:39:35.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.769]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.769]                   base::options(opts)
[17:39:35.769]                 }
[17:39:35.769]                 {
[17:39:35.769]                   {
[17:39:35.769]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.769]                     NULL
[17:39:35.769]                   }
[17:39:35.769]                   options(future.plan = NULL)
[17:39:35.769]                   if (is.na(NA_character_)) 
[17:39:35.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.769]                     .init = FALSE)
[17:39:35.769]                 }
[17:39:35.769]             }
[17:39:35.769]         }
[17:39:35.769]     })
[17:39:35.769]     if (TRUE) {
[17:39:35.769]         base::sink(type = "output", split = FALSE)
[17:39:35.769]         if (TRUE) {
[17:39:35.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.769]         }
[17:39:35.769]         else {
[17:39:35.769]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.769]         }
[17:39:35.769]         base::close(...future.stdout)
[17:39:35.769]         ...future.stdout <- NULL
[17:39:35.769]     }
[17:39:35.769]     ...future.result$conditions <- ...future.conditions
[17:39:35.769]     ...future.result$finished <- base::Sys.time()
[17:39:35.769]     ...future.result
[17:39:35.769] }
[17:39:35.772] requestCore(): workers = 2
[17:39:35.772] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:35.795] result() for MulticoreFuture ...
[17:39:35.796] result() for MulticoreFuture ...
[17:39:35.797] result() for MulticoreFuture ... done
[17:39:35.797] result() for MulticoreFuture ... done
[17:39:35.797] result() for MulticoreFuture ...
[17:39:35.797] result() for MulticoreFuture ... done
[17:39:35.801] MulticoreFuture started
[17:39:35.801] - Launch lazy future ... done
[17:39:35.801] run() for ‘MulticoreFuture’ ... done
[17:39:35.802] plan(): Setting new future strategy stack:
<environment: 0x55adf007bdf8> 
[17:39:35.802] List of future strategies:
[17:39:35.802] 1. sequential:
[17:39:35.802]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.802]    - tweaked: FALSE
[17:39:35.802]    - call: NULL
[17:39:35.803] plan(): nbrOfWorkers() = 1
<environment: 0x55adf1880428> 
[17:39:35.805] plan(): Setting new future strategy stack:
[17:39:35.805] List of future strategies:
[17:39:35.805] 1. multicore:
[17:39:35.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.805]    - tweaked: FALSE
[17:39:35.805]    - call: plan(strategy)
[17:39:35.810] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:35.812] resolve() on environment ...
[17:39:35.813]  recursive: 0
[17:39:35.813]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:35.814] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.814] - nx: 4
[17:39:35.814] - relay: TRUE
[17:39:35.814] - stdout: TRUE
[17:39:35.814] - signal: TRUE
[17:39:35.814] - resignal: FALSE
[17:39:35.814] - force: TRUE
[17:39:35.814] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.815] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.815]  - until=2
[17:39:35.815]  - relaying element #2
[17:39:35.815] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.815] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.815] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.815]  length: 3 (resolved future 1)
[17:39:35.816] Future #2
[17:39:35.816] result() for MulticoreFuture ...
[17:39:35.816] result() for MulticoreFuture ... done
[17:39:35.816] result() for MulticoreFuture ...
[17:39:35.816] result() for MulticoreFuture ... done
[17:39:35.816] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:35.816] - nx: 4
[17:39:35.817] - relay: TRUE
[17:39:35.817] - stdout: TRUE
[17:39:35.817] - signal: TRUE
[17:39:35.817] - resignal: FALSE
[17:39:35.817] - force: TRUE
[17:39:35.817] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.817] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.817]  - until=2
[17:39:35.818]  - relaying element #2
[17:39:35.818] result() for MulticoreFuture ...
[17:39:35.818] result() for MulticoreFuture ... done
[17:39:35.818] result() for MulticoreFuture ...
[17:39:35.818] result() for MulticoreFuture ... done
[17:39:35.818] result() for MulticoreFuture ...
[17:39:35.818] result() for MulticoreFuture ... done
[17:39:35.818] result() for MulticoreFuture ...
[17:39:35.819] result() for MulticoreFuture ... done
[17:39:35.819] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.819] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.819] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:35.819]  length: 2 (resolved future 2)
[17:39:35.819] Future #3
[17:39:35.820] result() for MulticoreFuture ...
[17:39:35.820] result() for MulticoreFuture ...
[17:39:35.821] result() for MulticoreFuture ... done
[17:39:35.821] result() for MulticoreFuture ... done
[17:39:35.821] result() for MulticoreFuture ...
[17:39:35.821] result() for MulticoreFuture ... done
[17:39:35.821] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:35.821] - nx: 4
[17:39:35.821] - relay: TRUE
[17:39:35.821] - stdout: TRUE
[17:39:35.822] - signal: TRUE
[17:39:35.822] - resignal: FALSE
[17:39:35.822] - force: TRUE
[17:39:35.822] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.822] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.822]  - until=3
[17:39:35.822]  - relaying element #3
[17:39:35.822] result() for MulticoreFuture ...
[17:39:35.823] result() for MulticoreFuture ... done
[17:39:35.823] result() for MulticoreFuture ...
[17:39:35.823] result() for MulticoreFuture ... done
[17:39:35.823] result() for MulticoreFuture ...
[17:39:35.823] result() for MulticoreFuture ... done
[17:39:35.823] result() for MulticoreFuture ...
[17:39:35.823] result() for MulticoreFuture ... done
[17:39:35.823] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.824] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.824] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:35.824]  length: 1 (resolved future 3)
[17:39:35.824] Future #4
[17:39:35.824] result() for MulticoreFuture ...
[17:39:35.825] result() for MulticoreFuture ...
[17:39:35.825] result() for MulticoreFuture ... done
[17:39:35.825] result() for MulticoreFuture ... done
[17:39:35.825] result() for MulticoreFuture ...
[17:39:35.826] result() for MulticoreFuture ... done
[17:39:35.826] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:35.826] - nx: 4
[17:39:35.826] - relay: TRUE
[17:39:35.826] - stdout: TRUE
[17:39:35.826] - signal: TRUE
[17:39:35.826] - resignal: FALSE
[17:39:35.826] - force: TRUE
[17:39:35.827] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.827] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.827]  - until=4
[17:39:35.827]  - relaying element #4
[17:39:35.827] result() for MulticoreFuture ...
[17:39:35.827] result() for MulticoreFuture ... done
[17:39:35.827] result() for MulticoreFuture ...
[17:39:35.827] result() for MulticoreFuture ... done
[17:39:35.827] result() for MulticoreFuture ...
[17:39:35.828] result() for MulticoreFuture ... done
[17:39:35.828] result() for MulticoreFuture ...
[17:39:35.828] result() for MulticoreFuture ... done
[17:39:35.828] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.828] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.828] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:35.828]  length: 0 (resolved future 4)
[17:39:35.828] Relaying remaining futures
[17:39:35.829] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.829] - nx: 4
[17:39:35.829] - relay: TRUE
[17:39:35.829] - stdout: TRUE
[17:39:35.829] - signal: TRUE
[17:39:35.829] - resignal: FALSE
[17:39:35.829] - force: TRUE
[17:39:35.829] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.829] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:35.829] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.830] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.830] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.830] resolve() on environment ... DONE
[17:39:35.830] result() for MulticoreFuture ...
[17:39:35.830] result() for MulticoreFuture ... done
[17:39:35.830] result() for MulticoreFuture ...
[17:39:35.830] result() for MulticoreFuture ... done
[17:39:35.830] result() for MulticoreFuture ...
[17:39:35.830] result() for MulticoreFuture ... done
[17:39:35.831] result() for MulticoreFuture ...
[17:39:35.831] result() for MulticoreFuture ... done
[17:39:35.831] result() for MulticoreFuture ...
[17:39:35.831] result() for MulticoreFuture ... done
[17:39:35.831] result() for MulticoreFuture ...
[17:39:35.831] result() for MulticoreFuture ... done
<environment: 0x55adf1968840> 
Dimensions: c(2, 3)
[17:39:35.832] getGlobalsAndPackages() ...
[17:39:35.832] Searching for globals...
[17:39:35.832] 
[17:39:35.832] Searching for globals ... DONE
[17:39:35.832] - globals: [0] <none>
[17:39:35.833] getGlobalsAndPackages() ... DONE
[17:39:35.833] run() for ‘Future’ ...
[17:39:35.833] - state: ‘created’
[17:39:35.833] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.838]   - Field: ‘label’
[17:39:35.838]   - Field: ‘local’
[17:39:35.838]   - Field: ‘owner’
[17:39:35.838]   - Field: ‘envir’
[17:39:35.838]   - Field: ‘workers’
[17:39:35.838]   - Field: ‘packages’
[17:39:35.838]   - Field: ‘gc’
[17:39:35.838]   - Field: ‘job’
[17:39:35.839]   - Field: ‘conditions’
[17:39:35.839]   - Field: ‘expr’
[17:39:35.839]   - Field: ‘uuid’
[17:39:35.839]   - Field: ‘seed’
[17:39:35.839]   - Field: ‘version’
[17:39:35.839]   - Field: ‘result’
[17:39:35.839]   - Field: ‘asynchronous’
[17:39:35.839]   - Field: ‘calls’
[17:39:35.839]   - Field: ‘globals’
[17:39:35.839]   - Field: ‘stdout’
[17:39:35.840]   - Field: ‘earlySignal’
[17:39:35.840]   - Field: ‘lazy’
[17:39:35.840]   - Field: ‘state’
[17:39:35.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.840] - Launch lazy future ...
[17:39:35.840] Packages needed by the future expression (n = 0): <none>
[17:39:35.840] Packages needed by future strategies (n = 0): <none>
[17:39:35.841] {
[17:39:35.841]     {
[17:39:35.841]         {
[17:39:35.841]             ...future.startTime <- base::Sys.time()
[17:39:35.841]             {
[17:39:35.841]                 {
[17:39:35.841]                   {
[17:39:35.841]                     {
[17:39:35.841]                       base::local({
[17:39:35.841]                         has_future <- base::requireNamespace("future", 
[17:39:35.841]                           quietly = TRUE)
[17:39:35.841]                         if (has_future) {
[17:39:35.841]                           ns <- base::getNamespace("future")
[17:39:35.841]                           version <- ns[[".package"]][["version"]]
[17:39:35.841]                           if (is.null(version)) 
[17:39:35.841]                             version <- utils::packageVersion("future")
[17:39:35.841]                         }
[17:39:35.841]                         else {
[17:39:35.841]                           version <- NULL
[17:39:35.841]                         }
[17:39:35.841]                         if (!has_future || version < "1.8.0") {
[17:39:35.841]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.841]                             "", base::R.version$version.string), 
[17:39:35.841]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.841]                               "release", "version")], collapse = " "), 
[17:39:35.841]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.841]                             info)
[17:39:35.841]                           info <- base::paste(info, collapse = "; ")
[17:39:35.841]                           if (!has_future) {
[17:39:35.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.841]                               info)
[17:39:35.841]                           }
[17:39:35.841]                           else {
[17:39:35.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.841]                               info, version)
[17:39:35.841]                           }
[17:39:35.841]                           base::stop(msg)
[17:39:35.841]                         }
[17:39:35.841]                       })
[17:39:35.841]                     }
[17:39:35.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.841]                     base::options(mc.cores = 1L)
[17:39:35.841]                   }
[17:39:35.841]                   ...future.strategy.old <- future::plan("list")
[17:39:35.841]                   options(future.plan = NULL)
[17:39:35.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.841]                 }
[17:39:35.841]                 ...future.workdir <- getwd()
[17:39:35.841]             }
[17:39:35.841]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.841]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.841]         }
[17:39:35.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.841]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.841]             base::names(...future.oldOptions))
[17:39:35.841]     }
[17:39:35.841]     if (FALSE) {
[17:39:35.841]     }
[17:39:35.841]     else {
[17:39:35.841]         if (TRUE) {
[17:39:35.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.841]                 open = "w")
[17:39:35.841]         }
[17:39:35.841]         else {
[17:39:35.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.841]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.841]         }
[17:39:35.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.841]             base::sink(type = "output", split = FALSE)
[17:39:35.841]             base::close(...future.stdout)
[17:39:35.841]         }, add = TRUE)
[17:39:35.841]     }
[17:39:35.841]     ...future.frame <- base::sys.nframe()
[17:39:35.841]     ...future.conditions <- base::list()
[17:39:35.841]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.841]     if (FALSE) {
[17:39:35.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.841]     }
[17:39:35.841]     ...future.result <- base::tryCatch({
[17:39:35.841]         base::withCallingHandlers({
[17:39:35.841]             ...future.value <- base::withVisible(base::local({
[17:39:35.841]                 withCallingHandlers({
[17:39:35.841]                   2
[17:39:35.841]                 }, immediateCondition = function(cond) {
[17:39:35.841]                   save_rds <- function (object, pathname, ...) 
[17:39:35.841]                   {
[17:39:35.841]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.841]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.841]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.841]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.841]                         fi_tmp[["mtime"]])
[17:39:35.841]                     }
[17:39:35.841]                     tryCatch({
[17:39:35.841]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.841]                     }, error = function(ex) {
[17:39:35.841]                       msg <- conditionMessage(ex)
[17:39:35.841]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.841]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.841]                         fi_tmp[["mtime"]], msg)
[17:39:35.841]                       ex$message <- msg
[17:39:35.841]                       stop(ex)
[17:39:35.841]                     })
[17:39:35.841]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.841]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.841]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.841]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.841]                       fi <- file.info(pathname)
[17:39:35.841]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.841]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.841]                         fi[["size"]], fi[["mtime"]])
[17:39:35.841]                       stop(msg)
[17:39:35.841]                     }
[17:39:35.841]                     invisible(pathname)
[17:39:35.841]                   }
[17:39:35.841]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.841]                     rootPath = tempdir()) 
[17:39:35.841]                   {
[17:39:35.841]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.841]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.841]                       tmpdir = path, fileext = ".rds")
[17:39:35.841]                     save_rds(obj, file)
[17:39:35.841]                   }
[17:39:35.841]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.841]                   {
[17:39:35.841]                     inherits <- base::inherits
[17:39:35.841]                     invokeRestart <- base::invokeRestart
[17:39:35.841]                     is.null <- base::is.null
[17:39:35.841]                     muffled <- FALSE
[17:39:35.841]                     if (inherits(cond, "message")) {
[17:39:35.841]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.841]                       if (muffled) 
[17:39:35.841]                         invokeRestart("muffleMessage")
[17:39:35.841]                     }
[17:39:35.841]                     else if (inherits(cond, "warning")) {
[17:39:35.841]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.841]                       if (muffled) 
[17:39:35.841]                         invokeRestart("muffleWarning")
[17:39:35.841]                     }
[17:39:35.841]                     else if (inherits(cond, "condition")) {
[17:39:35.841]                       if (!is.null(pattern)) {
[17:39:35.841]                         computeRestarts <- base::computeRestarts
[17:39:35.841]                         grepl <- base::grepl
[17:39:35.841]                         restarts <- computeRestarts(cond)
[17:39:35.841]                         for (restart in restarts) {
[17:39:35.841]                           name <- restart$name
[17:39:35.841]                           if (is.null(name)) 
[17:39:35.841]                             next
[17:39:35.841]                           if (!grepl(pattern, name)) 
[17:39:35.841]                             next
[17:39:35.841]                           invokeRestart(restart)
[17:39:35.841]                           muffled <- TRUE
[17:39:35.841]                           break
[17:39:35.841]                         }
[17:39:35.841]                       }
[17:39:35.841]                     }
[17:39:35.841]                     invisible(muffled)
[17:39:35.841]                   }
[17:39:35.841]                   muffleCondition(cond)
[17:39:35.841]                 })
[17:39:35.841]             }))
[17:39:35.841]             future::FutureResult(value = ...future.value$value, 
[17:39:35.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.841]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.841]                     ...future.globalenv.names))
[17:39:35.841]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.841]         }, condition = base::local({
[17:39:35.841]             c <- base::c
[17:39:35.841]             inherits <- base::inherits
[17:39:35.841]             invokeRestart <- base::invokeRestart
[17:39:35.841]             length <- base::length
[17:39:35.841]             list <- base::list
[17:39:35.841]             seq.int <- base::seq.int
[17:39:35.841]             signalCondition <- base::signalCondition
[17:39:35.841]             sys.calls <- base::sys.calls
[17:39:35.841]             `[[` <- base::`[[`
[17:39:35.841]             `+` <- base::`+`
[17:39:35.841]             `<<-` <- base::`<<-`
[17:39:35.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.841]                   3L)]
[17:39:35.841]             }
[17:39:35.841]             function(cond) {
[17:39:35.841]                 is_error <- inherits(cond, "error")
[17:39:35.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.841]                   NULL)
[17:39:35.841]                 if (is_error) {
[17:39:35.841]                   sessionInformation <- function() {
[17:39:35.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.841]                       search = base::search(), system = base::Sys.info())
[17:39:35.841]                   }
[17:39:35.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.841]                     cond$call), session = sessionInformation(), 
[17:39:35.841]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.841]                   signalCondition(cond)
[17:39:35.841]                 }
[17:39:35.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.841]                 "immediateCondition"))) {
[17:39:35.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.841]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.841]                   if (TRUE && !signal) {
[17:39:35.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.841]                     {
[17:39:35.841]                       inherits <- base::inherits
[17:39:35.841]                       invokeRestart <- base::invokeRestart
[17:39:35.841]                       is.null <- base::is.null
[17:39:35.841]                       muffled <- FALSE
[17:39:35.841]                       if (inherits(cond, "message")) {
[17:39:35.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.841]                         if (muffled) 
[17:39:35.841]                           invokeRestart("muffleMessage")
[17:39:35.841]                       }
[17:39:35.841]                       else if (inherits(cond, "warning")) {
[17:39:35.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.841]                         if (muffled) 
[17:39:35.841]                           invokeRestart("muffleWarning")
[17:39:35.841]                       }
[17:39:35.841]                       else if (inherits(cond, "condition")) {
[17:39:35.841]                         if (!is.null(pattern)) {
[17:39:35.841]                           computeRestarts <- base::computeRestarts
[17:39:35.841]                           grepl <- base::grepl
[17:39:35.841]                           restarts <- computeRestarts(cond)
[17:39:35.841]                           for (restart in restarts) {
[17:39:35.841]                             name <- restart$name
[17:39:35.841]                             if (is.null(name)) 
[17:39:35.841]                               next
[17:39:35.841]                             if (!grepl(pattern, name)) 
[17:39:35.841]                               next
[17:39:35.841]                             invokeRestart(restart)
[17:39:35.841]                             muffled <- TRUE
[17:39:35.841]                             break
[17:39:35.841]                           }
[17:39:35.841]                         }
[17:39:35.841]                       }
[17:39:35.841]                       invisible(muffled)
[17:39:35.841]                     }
[17:39:35.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.841]                   }
[17:39:35.841]                 }
[17:39:35.841]                 else {
[17:39:35.841]                   if (TRUE) {
[17:39:35.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.841]                     {
[17:39:35.841]                       inherits <- base::inherits
[17:39:35.841]                       invokeRestart <- base::invokeRestart
[17:39:35.841]                       is.null <- base::is.null
[17:39:35.841]                       muffled <- FALSE
[17:39:35.841]                       if (inherits(cond, "message")) {
[17:39:35.841]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.841]                         if (muffled) 
[17:39:35.841]                           invokeRestart("muffleMessage")
[17:39:35.841]                       }
[17:39:35.841]                       else if (inherits(cond, "warning")) {
[17:39:35.841]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.841]                         if (muffled) 
[17:39:35.841]                           invokeRestart("muffleWarning")
[17:39:35.841]                       }
[17:39:35.841]                       else if (inherits(cond, "condition")) {
[17:39:35.841]                         if (!is.null(pattern)) {
[17:39:35.841]                           computeRestarts <- base::computeRestarts
[17:39:35.841]                           grepl <- base::grepl
[17:39:35.841]                           restarts <- computeRestarts(cond)
[17:39:35.841]                           for (restart in restarts) {
[17:39:35.841]                             name <- restart$name
[17:39:35.841]                             if (is.null(name)) 
[17:39:35.841]                               next
[17:39:35.841]                             if (!grepl(pattern, name)) 
[17:39:35.841]                               next
[17:39:35.841]                             invokeRestart(restart)
[17:39:35.841]                             muffled <- TRUE
[17:39:35.841]                             break
[17:39:35.841]                           }
[17:39:35.841]                         }
[17:39:35.841]                       }
[17:39:35.841]                       invisible(muffled)
[17:39:35.841]                     }
[17:39:35.841]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.841]                   }
[17:39:35.841]                 }
[17:39:35.841]             }
[17:39:35.841]         }))
[17:39:35.841]     }, error = function(ex) {
[17:39:35.841]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.841]                 ...future.rng), started = ...future.startTime, 
[17:39:35.841]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.841]             version = "1.8"), class = "FutureResult")
[17:39:35.841]     }, finally = {
[17:39:35.841]         if (!identical(...future.workdir, getwd())) 
[17:39:35.841]             setwd(...future.workdir)
[17:39:35.841]         {
[17:39:35.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.841]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.841]             }
[17:39:35.841]             base::options(...future.oldOptions)
[17:39:35.841]             if (.Platform$OS.type == "windows") {
[17:39:35.841]                 old_names <- names(...future.oldEnvVars)
[17:39:35.841]                 envs <- base::Sys.getenv()
[17:39:35.841]                 names <- names(envs)
[17:39:35.841]                 common <- intersect(names, old_names)
[17:39:35.841]                 added <- setdiff(names, old_names)
[17:39:35.841]                 removed <- setdiff(old_names, names)
[17:39:35.841]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.841]                   envs[common]]
[17:39:35.841]                 NAMES <- toupper(changed)
[17:39:35.841]                 args <- list()
[17:39:35.841]                 for (kk in seq_along(NAMES)) {
[17:39:35.841]                   name <- changed[[kk]]
[17:39:35.841]                   NAME <- NAMES[[kk]]
[17:39:35.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.841]                     next
[17:39:35.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.841]                 }
[17:39:35.841]                 NAMES <- toupper(added)
[17:39:35.841]                 for (kk in seq_along(NAMES)) {
[17:39:35.841]                   name <- added[[kk]]
[17:39:35.841]                   NAME <- NAMES[[kk]]
[17:39:35.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.841]                     next
[17:39:35.841]                   args[[name]] <- ""
[17:39:35.841]                 }
[17:39:35.841]                 NAMES <- toupper(removed)
[17:39:35.841]                 for (kk in seq_along(NAMES)) {
[17:39:35.841]                   name <- removed[[kk]]
[17:39:35.841]                   NAME <- NAMES[[kk]]
[17:39:35.841]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.841]                     next
[17:39:35.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.841]                 }
[17:39:35.841]                 if (length(args) > 0) 
[17:39:35.841]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.841]             }
[17:39:35.841]             else {
[17:39:35.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.841]             }
[17:39:35.841]             {
[17:39:35.841]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.841]                   0L) {
[17:39:35.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.841]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.841]                   base::options(opts)
[17:39:35.841]                 }
[17:39:35.841]                 {
[17:39:35.841]                   {
[17:39:35.841]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.841]                     NULL
[17:39:35.841]                   }
[17:39:35.841]                   options(future.plan = NULL)
[17:39:35.841]                   if (is.na(NA_character_)) 
[17:39:35.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.841]                     .init = FALSE)
[17:39:35.841]                 }
[17:39:35.841]             }
[17:39:35.841]         }
[17:39:35.841]     })
[17:39:35.841]     if (TRUE) {
[17:39:35.841]         base::sink(type = "output", split = FALSE)
[17:39:35.841]         if (TRUE) {
[17:39:35.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.841]         }
[17:39:35.841]         else {
[17:39:35.841]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.841]         }
[17:39:35.841]         base::close(...future.stdout)
[17:39:35.841]         ...future.stdout <- NULL
[17:39:35.841]     }
[17:39:35.841]     ...future.result$conditions <- ...future.conditions
[17:39:35.841]     ...future.result$finished <- base::Sys.time()
[17:39:35.841]     ...future.result
[17:39:35.841] }
[17:39:35.844] requestCore(): workers = 2
[17:39:35.846] MulticoreFuture started
[17:39:35.846] - Launch lazy future ... done
[17:39:35.846] run() for ‘MulticoreFuture’ ... done
[17:39:35.847] getGlobalsAndPackages() ...
[17:39:35.847] Searching for globals...
[17:39:35.847] plan(): Setting new future strategy stack:
[17:39:35.848] 
[17:39:35.847] List of future strategies:
[17:39:35.847] 1. sequential:
[17:39:35.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.847]    - tweaked: FALSE
[17:39:35.847]    - call: NULL
[17:39:35.848] Searching for globals ... DONE
[17:39:35.848] - globals: [0] <none>
[17:39:35.848] plan(): nbrOfWorkers() = 1
[17:39:35.848] getGlobalsAndPackages() ... DONE
[17:39:35.849] run() for ‘Future’ ...
[17:39:35.849] - state: ‘created’
[17:39:35.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.850] plan(): Setting new future strategy stack:
[17:39:35.850] List of future strategies:
[17:39:35.850] 1. multicore:
[17:39:35.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.850]    - tweaked: FALSE
[17:39:35.850]    - call: plan(strategy)
[17:39:35.859] plan(): nbrOfWorkers() = 2
[17:39:35.860] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.860]   - Field: ‘label’
[17:39:35.860]   - Field: ‘local’
[17:39:35.860]   - Field: ‘owner’
[17:39:35.861]   - Field: ‘envir’
[17:39:35.861]   - Field: ‘workers’
[17:39:35.861]   - Field: ‘packages’
[17:39:35.861]   - Field: ‘gc’
[17:39:35.861]   - Field: ‘job’
[17:39:35.861]   - Field: ‘conditions’
[17:39:35.861]   - Field: ‘expr’
[17:39:35.862]   - Field: ‘uuid’
[17:39:35.862]   - Field: ‘seed’
[17:39:35.862]   - Field: ‘version’
[17:39:35.862]   - Field: ‘result’
[17:39:35.862]   - Field: ‘asynchronous’
[17:39:35.862]   - Field: ‘calls’
[17:39:35.862]   - Field: ‘globals’
[17:39:35.863]   - Field: ‘stdout’
[17:39:35.863]   - Field: ‘earlySignal’
[17:39:35.863]   - Field: ‘lazy’
[17:39:35.863]   - Field: ‘state’
[17:39:35.863] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.863] - Launch lazy future ...
[17:39:35.864] Packages needed by the future expression (n = 0): <none>
[17:39:35.864] Packages needed by future strategies (n = 0): <none>
[17:39:35.865] {
[17:39:35.865]     {
[17:39:35.865]         {
[17:39:35.865]             ...future.startTime <- base::Sys.time()
[17:39:35.865]             {
[17:39:35.865]                 {
[17:39:35.865]                   {
[17:39:35.865]                     {
[17:39:35.865]                       base::local({
[17:39:35.865]                         has_future <- base::requireNamespace("future", 
[17:39:35.865]                           quietly = TRUE)
[17:39:35.865]                         if (has_future) {
[17:39:35.865]                           ns <- base::getNamespace("future")
[17:39:35.865]                           version <- ns[[".package"]][["version"]]
[17:39:35.865]                           if (is.null(version)) 
[17:39:35.865]                             version <- utils::packageVersion("future")
[17:39:35.865]                         }
[17:39:35.865]                         else {
[17:39:35.865]                           version <- NULL
[17:39:35.865]                         }
[17:39:35.865]                         if (!has_future || version < "1.8.0") {
[17:39:35.865]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.865]                             "", base::R.version$version.string), 
[17:39:35.865]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.865]                               "release", "version")], collapse = " "), 
[17:39:35.865]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.865]                             info)
[17:39:35.865]                           info <- base::paste(info, collapse = "; ")
[17:39:35.865]                           if (!has_future) {
[17:39:35.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.865]                               info)
[17:39:35.865]                           }
[17:39:35.865]                           else {
[17:39:35.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.865]                               info, version)
[17:39:35.865]                           }
[17:39:35.865]                           base::stop(msg)
[17:39:35.865]                         }
[17:39:35.865]                       })
[17:39:35.865]                     }
[17:39:35.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.865]                     base::options(mc.cores = 1L)
[17:39:35.865]                   }
[17:39:35.865]                   ...future.strategy.old <- future::plan("list")
[17:39:35.865]                   options(future.plan = NULL)
[17:39:35.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.865]                 }
[17:39:35.865]                 ...future.workdir <- getwd()
[17:39:35.865]             }
[17:39:35.865]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.865]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.865]         }
[17:39:35.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.865]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.865]             base::names(...future.oldOptions))
[17:39:35.865]     }
[17:39:35.865]     if (FALSE) {
[17:39:35.865]     }
[17:39:35.865]     else {
[17:39:35.865]         if (TRUE) {
[17:39:35.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.865]                 open = "w")
[17:39:35.865]         }
[17:39:35.865]         else {
[17:39:35.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.865]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.865]         }
[17:39:35.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.865]             base::sink(type = "output", split = FALSE)
[17:39:35.865]             base::close(...future.stdout)
[17:39:35.865]         }, add = TRUE)
[17:39:35.865]     }
[17:39:35.865]     ...future.frame <- base::sys.nframe()
[17:39:35.865]     ...future.conditions <- base::list()
[17:39:35.865]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.865]     if (FALSE) {
[17:39:35.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.865]     }
[17:39:35.865]     ...future.result <- base::tryCatch({
[17:39:35.865]         base::withCallingHandlers({
[17:39:35.865]             ...future.value <- base::withVisible(base::local({
[17:39:35.865]                 withCallingHandlers({
[17:39:35.865]                   NULL
[17:39:35.865]                 }, immediateCondition = function(cond) {
[17:39:35.865]                   save_rds <- function (object, pathname, ...) 
[17:39:35.865]                   {
[17:39:35.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.865]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.865]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.865]                         fi_tmp[["mtime"]])
[17:39:35.865]                     }
[17:39:35.865]                     tryCatch({
[17:39:35.865]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.865]                     }, error = function(ex) {
[17:39:35.865]                       msg <- conditionMessage(ex)
[17:39:35.865]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.865]                         fi_tmp[["mtime"]], msg)
[17:39:35.865]                       ex$message <- msg
[17:39:35.865]                       stop(ex)
[17:39:35.865]                     })
[17:39:35.865]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.865]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.865]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.865]                       fi <- file.info(pathname)
[17:39:35.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.865]                         fi[["size"]], fi[["mtime"]])
[17:39:35.865]                       stop(msg)
[17:39:35.865]                     }
[17:39:35.865]                     invisible(pathname)
[17:39:35.865]                   }
[17:39:35.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.865]                     rootPath = tempdir()) 
[17:39:35.865]                   {
[17:39:35.865]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.865]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.865]                       tmpdir = path, fileext = ".rds")
[17:39:35.865]                     save_rds(obj, file)
[17:39:35.865]                   }
[17:39:35.865]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.865]                   {
[17:39:35.865]                     inherits <- base::inherits
[17:39:35.865]                     invokeRestart <- base::invokeRestart
[17:39:35.865]                     is.null <- base::is.null
[17:39:35.865]                     muffled <- FALSE
[17:39:35.865]                     if (inherits(cond, "message")) {
[17:39:35.865]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.865]                       if (muffled) 
[17:39:35.865]                         invokeRestart("muffleMessage")
[17:39:35.865]                     }
[17:39:35.865]                     else if (inherits(cond, "warning")) {
[17:39:35.865]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.865]                       if (muffled) 
[17:39:35.865]                         invokeRestart("muffleWarning")
[17:39:35.865]                     }
[17:39:35.865]                     else if (inherits(cond, "condition")) {
[17:39:35.865]                       if (!is.null(pattern)) {
[17:39:35.865]                         computeRestarts <- base::computeRestarts
[17:39:35.865]                         grepl <- base::grepl
[17:39:35.865]                         restarts <- computeRestarts(cond)
[17:39:35.865]                         for (restart in restarts) {
[17:39:35.865]                           name <- restart$name
[17:39:35.865]                           if (is.null(name)) 
[17:39:35.865]                             next
[17:39:35.865]                           if (!grepl(pattern, name)) 
[17:39:35.865]                             next
[17:39:35.865]                           invokeRestart(restart)
[17:39:35.865]                           muffled <- TRUE
[17:39:35.865]                           break
[17:39:35.865]                         }
[17:39:35.865]                       }
[17:39:35.865]                     }
[17:39:35.865]                     invisible(muffled)
[17:39:35.865]                   }
[17:39:35.865]                   muffleCondition(cond)
[17:39:35.865]                 })
[17:39:35.865]             }))
[17:39:35.865]             future::FutureResult(value = ...future.value$value, 
[17:39:35.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.865]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.865]                     ...future.globalenv.names))
[17:39:35.865]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.865]         }, condition = base::local({
[17:39:35.865]             c <- base::c
[17:39:35.865]             inherits <- base::inherits
[17:39:35.865]             invokeRestart <- base::invokeRestart
[17:39:35.865]             length <- base::length
[17:39:35.865]             list <- base::list
[17:39:35.865]             seq.int <- base::seq.int
[17:39:35.865]             signalCondition <- base::signalCondition
[17:39:35.865]             sys.calls <- base::sys.calls
[17:39:35.865]             `[[` <- base::`[[`
[17:39:35.865]             `+` <- base::`+`
[17:39:35.865]             `<<-` <- base::`<<-`
[17:39:35.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.865]                   3L)]
[17:39:35.865]             }
[17:39:35.865]             function(cond) {
[17:39:35.865]                 is_error <- inherits(cond, "error")
[17:39:35.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.865]                   NULL)
[17:39:35.865]                 if (is_error) {
[17:39:35.865]                   sessionInformation <- function() {
[17:39:35.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.865]                       search = base::search(), system = base::Sys.info())
[17:39:35.865]                   }
[17:39:35.865]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.865]                     cond$call), session = sessionInformation(), 
[17:39:35.865]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.865]                   signalCondition(cond)
[17:39:35.865]                 }
[17:39:35.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.865]                 "immediateCondition"))) {
[17:39:35.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.865]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.865]                   if (TRUE && !signal) {
[17:39:35.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.865]                     {
[17:39:35.865]                       inherits <- base::inherits
[17:39:35.865]                       invokeRestart <- base::invokeRestart
[17:39:35.865]                       is.null <- base::is.null
[17:39:35.865]                       muffled <- FALSE
[17:39:35.865]                       if (inherits(cond, "message")) {
[17:39:35.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.865]                         if (muffled) 
[17:39:35.865]                           invokeRestart("muffleMessage")
[17:39:35.865]                       }
[17:39:35.865]                       else if (inherits(cond, "warning")) {
[17:39:35.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.865]                         if (muffled) 
[17:39:35.865]                           invokeRestart("muffleWarning")
[17:39:35.865]                       }
[17:39:35.865]                       else if (inherits(cond, "condition")) {
[17:39:35.865]                         if (!is.null(pattern)) {
[17:39:35.865]                           computeRestarts <- base::computeRestarts
[17:39:35.865]                           grepl <- base::grepl
[17:39:35.865]                           restarts <- computeRestarts(cond)
[17:39:35.865]                           for (restart in restarts) {
[17:39:35.865]                             name <- restart$name
[17:39:35.865]                             if (is.null(name)) 
[17:39:35.865]                               next
[17:39:35.865]                             if (!grepl(pattern, name)) 
[17:39:35.865]                               next
[17:39:35.865]                             invokeRestart(restart)
[17:39:35.865]                             muffled <- TRUE
[17:39:35.865]                             break
[17:39:35.865]                           }
[17:39:35.865]                         }
[17:39:35.865]                       }
[17:39:35.865]                       invisible(muffled)
[17:39:35.865]                     }
[17:39:35.865]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.865]                   }
[17:39:35.865]                 }
[17:39:35.865]                 else {
[17:39:35.865]                   if (TRUE) {
[17:39:35.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.865]                     {
[17:39:35.865]                       inherits <- base::inherits
[17:39:35.865]                       invokeRestart <- base::invokeRestart
[17:39:35.865]                       is.null <- base::is.null
[17:39:35.865]                       muffled <- FALSE
[17:39:35.865]                       if (inherits(cond, "message")) {
[17:39:35.865]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.865]                         if (muffled) 
[17:39:35.865]                           invokeRestart("muffleMessage")
[17:39:35.865]                       }
[17:39:35.865]                       else if (inherits(cond, "warning")) {
[17:39:35.865]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.865]                         if (muffled) 
[17:39:35.865]                           invokeRestart("muffleWarning")
[17:39:35.865]                       }
[17:39:35.865]                       else if (inherits(cond, "condition")) {
[17:39:35.865]                         if (!is.null(pattern)) {
[17:39:35.865]                           computeRestarts <- base::computeRestarts
[17:39:35.865]                           grepl <- base::grepl
[17:39:35.865]                           restarts <- computeRestarts(cond)
[17:39:35.865]                           for (restart in restarts) {
[17:39:35.865]                             name <- restart$name
[17:39:35.865]                             if (is.null(name)) 
[17:39:35.865]                               next
[17:39:35.865]                             if (!grepl(pattern, name)) 
[17:39:35.865]                               next
[17:39:35.865]                             invokeRestart(restart)
[17:39:35.865]                             muffled <- TRUE
[17:39:35.865]                             break
[17:39:35.865]                           }
[17:39:35.865]                         }
[17:39:35.865]                       }
[17:39:35.865]                       invisible(muffled)
[17:39:35.865]                     }
[17:39:35.865]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.865]                   }
[17:39:35.865]                 }
[17:39:35.865]             }
[17:39:35.865]         }))
[17:39:35.865]     }, error = function(ex) {
[17:39:35.865]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.865]                 ...future.rng), started = ...future.startTime, 
[17:39:35.865]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.865]             version = "1.8"), class = "FutureResult")
[17:39:35.865]     }, finally = {
[17:39:35.865]         if (!identical(...future.workdir, getwd())) 
[17:39:35.865]             setwd(...future.workdir)
[17:39:35.865]         {
[17:39:35.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.865]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.865]             }
[17:39:35.865]             base::options(...future.oldOptions)
[17:39:35.865]             if (.Platform$OS.type == "windows") {
[17:39:35.865]                 old_names <- names(...future.oldEnvVars)
[17:39:35.865]                 envs <- base::Sys.getenv()
[17:39:35.865]                 names <- names(envs)
[17:39:35.865]                 common <- intersect(names, old_names)
[17:39:35.865]                 added <- setdiff(names, old_names)
[17:39:35.865]                 removed <- setdiff(old_names, names)
[17:39:35.865]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.865]                   envs[common]]
[17:39:35.865]                 NAMES <- toupper(changed)
[17:39:35.865]                 args <- list()
[17:39:35.865]                 for (kk in seq_along(NAMES)) {
[17:39:35.865]                   name <- changed[[kk]]
[17:39:35.865]                   NAME <- NAMES[[kk]]
[17:39:35.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.865]                     next
[17:39:35.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.865]                 }
[17:39:35.865]                 NAMES <- toupper(added)
[17:39:35.865]                 for (kk in seq_along(NAMES)) {
[17:39:35.865]                   name <- added[[kk]]
[17:39:35.865]                   NAME <- NAMES[[kk]]
[17:39:35.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.865]                     next
[17:39:35.865]                   args[[name]] <- ""
[17:39:35.865]                 }
[17:39:35.865]                 NAMES <- toupper(removed)
[17:39:35.865]                 for (kk in seq_along(NAMES)) {
[17:39:35.865]                   name <- removed[[kk]]
[17:39:35.865]                   NAME <- NAMES[[kk]]
[17:39:35.865]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.865]                     next
[17:39:35.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.865]                 }
[17:39:35.865]                 if (length(args) > 0) 
[17:39:35.865]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.865]             }
[17:39:35.865]             else {
[17:39:35.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.865]             }
[17:39:35.865]             {
[17:39:35.865]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.865]                   0L) {
[17:39:35.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.865]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.865]                   base::options(opts)
[17:39:35.865]                 }
[17:39:35.865]                 {
[17:39:35.865]                   {
[17:39:35.865]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.865]                     NULL
[17:39:35.865]                   }
[17:39:35.865]                   options(future.plan = NULL)
[17:39:35.865]                   if (is.na(NA_character_)) 
[17:39:35.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.865]                     .init = FALSE)
[17:39:35.865]                 }
[17:39:35.865]             }
[17:39:35.865]         }
[17:39:35.865]     })
[17:39:35.865]     if (TRUE) {
[17:39:35.865]         base::sink(type = "output", split = FALSE)
[17:39:35.865]         if (TRUE) {
[17:39:35.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.865]         }
[17:39:35.865]         else {
[17:39:35.865]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.865]         }
[17:39:35.865]         base::close(...future.stdout)
[17:39:35.865]         ...future.stdout <- NULL
[17:39:35.865]     }
[17:39:35.865]     ...future.result$conditions <- ...future.conditions
[17:39:35.865]     ...future.result$finished <- base::Sys.time()
[17:39:35.865]     ...future.result
[17:39:35.865] }
[17:39:35.867] requestCore(): workers = 2
[17:39:35.870] MulticoreFuture started
[17:39:35.870] - Launch lazy future ... done
[17:39:35.871] run() for ‘MulticoreFuture’ ... done
[17:39:35.871] plan(): Setting new future strategy stack:
[17:39:35.871] getGlobalsAndPackages() ...
[17:39:35.872] Searching for globals...
[17:39:35.871] List of future strategies:
[17:39:35.871] 1. sequential:
[17:39:35.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.871]    - tweaked: FALSE
[17:39:35.871]    - call: NULL
[17:39:35.872] plan(): nbrOfWorkers() = 1
[17:39:35.873] - globals found: [1] ‘{’
[17:39:35.873] Searching for globals ... DONE
[17:39:35.873] Resolving globals: FALSE
[17:39:35.874] 
[17:39:35.874] 
[17:39:35.874] getGlobalsAndPackages() ... DONE
[17:39:35.874] plan(): Setting new future strategy stack:
[17:39:35.875] run() for ‘Future’ ...
[17:39:35.875] - state: ‘created’
[17:39:35.875] List of future strategies:
[17:39:35.875] 1. multicore:
[17:39:35.875]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.875]    - tweaked: FALSE
[17:39:35.875]    - call: plan(strategy)
[17:39:35.875] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.879] plan(): nbrOfWorkers() = 2
[17:39:35.880] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.881]   - Field: ‘label’
[17:39:35.881]   - Field: ‘local’
[17:39:35.881]   - Field: ‘owner’
[17:39:35.881]   - Field: ‘envir’
[17:39:35.881]   - Field: ‘workers’
[17:39:35.881]   - Field: ‘packages’
[17:39:35.882]   - Field: ‘gc’
[17:39:35.882]   - Field: ‘job’
[17:39:35.882]   - Field: ‘conditions’
[17:39:35.882]   - Field: ‘expr’
[17:39:35.882]   - Field: ‘uuid’
[17:39:35.882]   - Field: ‘seed’
[17:39:35.882]   - Field: ‘version’
[17:39:35.882]   - Field: ‘result’
[17:39:35.883]   - Field: ‘asynchronous’
[17:39:35.883]   - Field: ‘calls’
[17:39:35.883]   - Field: ‘globals’
[17:39:35.883]   - Field: ‘stdout’
[17:39:35.883]   - Field: ‘earlySignal’
[17:39:35.883]   - Field: ‘lazy’
[17:39:35.883]   - Field: ‘state’
[17:39:35.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.884] - Launch lazy future ...
[17:39:35.884] Packages needed by the future expression (n = 0): <none>
[17:39:35.884] Packages needed by future strategies (n = 0): <none>
[17:39:35.885] {
[17:39:35.885]     {
[17:39:35.885]         {
[17:39:35.885]             ...future.startTime <- base::Sys.time()
[17:39:35.885]             {
[17:39:35.885]                 {
[17:39:35.885]                   {
[17:39:35.885]                     {
[17:39:35.885]                       base::local({
[17:39:35.885]                         has_future <- base::requireNamespace("future", 
[17:39:35.885]                           quietly = TRUE)
[17:39:35.885]                         if (has_future) {
[17:39:35.885]                           ns <- base::getNamespace("future")
[17:39:35.885]                           version <- ns[[".package"]][["version"]]
[17:39:35.885]                           if (is.null(version)) 
[17:39:35.885]                             version <- utils::packageVersion("future")
[17:39:35.885]                         }
[17:39:35.885]                         else {
[17:39:35.885]                           version <- NULL
[17:39:35.885]                         }
[17:39:35.885]                         if (!has_future || version < "1.8.0") {
[17:39:35.885]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.885]                             "", base::R.version$version.string), 
[17:39:35.885]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.885]                               "release", "version")], collapse = " "), 
[17:39:35.885]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.885]                             info)
[17:39:35.885]                           info <- base::paste(info, collapse = "; ")
[17:39:35.885]                           if (!has_future) {
[17:39:35.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.885]                               info)
[17:39:35.885]                           }
[17:39:35.885]                           else {
[17:39:35.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.885]                               info, version)
[17:39:35.885]                           }
[17:39:35.885]                           base::stop(msg)
[17:39:35.885]                         }
[17:39:35.885]                       })
[17:39:35.885]                     }
[17:39:35.885]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.885]                     base::options(mc.cores = 1L)
[17:39:35.885]                   }
[17:39:35.885]                   ...future.strategy.old <- future::plan("list")
[17:39:35.885]                   options(future.plan = NULL)
[17:39:35.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.885]                 }
[17:39:35.885]                 ...future.workdir <- getwd()
[17:39:35.885]             }
[17:39:35.885]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.885]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.885]         }
[17:39:35.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.885]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.885]             base::names(...future.oldOptions))
[17:39:35.885]     }
[17:39:35.885]     if (FALSE) {
[17:39:35.885]     }
[17:39:35.885]     else {
[17:39:35.885]         if (TRUE) {
[17:39:35.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.885]                 open = "w")
[17:39:35.885]         }
[17:39:35.885]         else {
[17:39:35.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.885]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.885]         }
[17:39:35.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.885]             base::sink(type = "output", split = FALSE)
[17:39:35.885]             base::close(...future.stdout)
[17:39:35.885]         }, add = TRUE)
[17:39:35.885]     }
[17:39:35.885]     ...future.frame <- base::sys.nframe()
[17:39:35.885]     ...future.conditions <- base::list()
[17:39:35.885]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.885]     if (FALSE) {
[17:39:35.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.885]     }
[17:39:35.885]     ...future.result <- base::tryCatch({
[17:39:35.885]         base::withCallingHandlers({
[17:39:35.885]             ...future.value <- base::withVisible(base::local({
[17:39:35.885]                 withCallingHandlers({
[17:39:35.885]                   {
[17:39:35.885]                     4
[17:39:35.885]                   }
[17:39:35.885]                 }, immediateCondition = function(cond) {
[17:39:35.885]                   save_rds <- function (object, pathname, ...) 
[17:39:35.885]                   {
[17:39:35.885]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.885]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.885]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.885]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.885]                         fi_tmp[["mtime"]])
[17:39:35.885]                     }
[17:39:35.885]                     tryCatch({
[17:39:35.885]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.885]                     }, error = function(ex) {
[17:39:35.885]                       msg <- conditionMessage(ex)
[17:39:35.885]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.885]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.885]                         fi_tmp[["mtime"]], msg)
[17:39:35.885]                       ex$message <- msg
[17:39:35.885]                       stop(ex)
[17:39:35.885]                     })
[17:39:35.885]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.885]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.885]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.885]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.885]                       fi <- file.info(pathname)
[17:39:35.885]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.885]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.885]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.885]                         fi[["size"]], fi[["mtime"]])
[17:39:35.885]                       stop(msg)
[17:39:35.885]                     }
[17:39:35.885]                     invisible(pathname)
[17:39:35.885]                   }
[17:39:35.885]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.885]                     rootPath = tempdir()) 
[17:39:35.885]                   {
[17:39:35.885]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.885]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.885]                       tmpdir = path, fileext = ".rds")
[17:39:35.885]                     save_rds(obj, file)
[17:39:35.885]                   }
[17:39:35.885]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.885]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.885]                   {
[17:39:35.885]                     inherits <- base::inherits
[17:39:35.885]                     invokeRestart <- base::invokeRestart
[17:39:35.885]                     is.null <- base::is.null
[17:39:35.885]                     muffled <- FALSE
[17:39:35.885]                     if (inherits(cond, "message")) {
[17:39:35.885]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.885]                       if (muffled) 
[17:39:35.885]                         invokeRestart("muffleMessage")
[17:39:35.885]                     }
[17:39:35.885]                     else if (inherits(cond, "warning")) {
[17:39:35.885]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.885]                       if (muffled) 
[17:39:35.885]                         invokeRestart("muffleWarning")
[17:39:35.885]                     }
[17:39:35.885]                     else if (inherits(cond, "condition")) {
[17:39:35.885]                       if (!is.null(pattern)) {
[17:39:35.885]                         computeRestarts <- base::computeRestarts
[17:39:35.885]                         grepl <- base::grepl
[17:39:35.885]                         restarts <- computeRestarts(cond)
[17:39:35.885]                         for (restart in restarts) {
[17:39:35.885]                           name <- restart$name
[17:39:35.885]                           if (is.null(name)) 
[17:39:35.885]                             next
[17:39:35.885]                           if (!grepl(pattern, name)) 
[17:39:35.885]                             next
[17:39:35.885]                           invokeRestart(restart)
[17:39:35.885]                           muffled <- TRUE
[17:39:35.885]                           break
[17:39:35.885]                         }
[17:39:35.885]                       }
[17:39:35.885]                     }
[17:39:35.885]                     invisible(muffled)
[17:39:35.885]                   }
[17:39:35.885]                   muffleCondition(cond)
[17:39:35.885]                 })
[17:39:35.885]             }))
[17:39:35.885]             future::FutureResult(value = ...future.value$value, 
[17:39:35.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.885]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.885]                     ...future.globalenv.names))
[17:39:35.885]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.885]         }, condition = base::local({
[17:39:35.885]             c <- base::c
[17:39:35.885]             inherits <- base::inherits
[17:39:35.885]             invokeRestart <- base::invokeRestart
[17:39:35.885]             length <- base::length
[17:39:35.885]             list <- base::list
[17:39:35.885]             seq.int <- base::seq.int
[17:39:35.885]             signalCondition <- base::signalCondition
[17:39:35.885]             sys.calls <- base::sys.calls
[17:39:35.885]             `[[` <- base::`[[`
[17:39:35.885]             `+` <- base::`+`
[17:39:35.885]             `<<-` <- base::`<<-`
[17:39:35.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.885]                   3L)]
[17:39:35.885]             }
[17:39:35.885]             function(cond) {
[17:39:35.885]                 is_error <- inherits(cond, "error")
[17:39:35.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.885]                   NULL)
[17:39:35.885]                 if (is_error) {
[17:39:35.885]                   sessionInformation <- function() {
[17:39:35.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.885]                       search = base::search(), system = base::Sys.info())
[17:39:35.885]                   }
[17:39:35.885]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.885]                     cond$call), session = sessionInformation(), 
[17:39:35.885]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.885]                   signalCondition(cond)
[17:39:35.885]                 }
[17:39:35.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.885]                 "immediateCondition"))) {
[17:39:35.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.885]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.885]                   if (TRUE && !signal) {
[17:39:35.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.885]                     {
[17:39:35.885]                       inherits <- base::inherits
[17:39:35.885]                       invokeRestart <- base::invokeRestart
[17:39:35.885]                       is.null <- base::is.null
[17:39:35.885]                       muffled <- FALSE
[17:39:35.885]                       if (inherits(cond, "message")) {
[17:39:35.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.885]                         if (muffled) 
[17:39:35.885]                           invokeRestart("muffleMessage")
[17:39:35.885]                       }
[17:39:35.885]                       else if (inherits(cond, "warning")) {
[17:39:35.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.885]                         if (muffled) 
[17:39:35.885]                           invokeRestart("muffleWarning")
[17:39:35.885]                       }
[17:39:35.885]                       else if (inherits(cond, "condition")) {
[17:39:35.885]                         if (!is.null(pattern)) {
[17:39:35.885]                           computeRestarts <- base::computeRestarts
[17:39:35.885]                           grepl <- base::grepl
[17:39:35.885]                           restarts <- computeRestarts(cond)
[17:39:35.885]                           for (restart in restarts) {
[17:39:35.885]                             name <- restart$name
[17:39:35.885]                             if (is.null(name)) 
[17:39:35.885]                               next
[17:39:35.885]                             if (!grepl(pattern, name)) 
[17:39:35.885]                               next
[17:39:35.885]                             invokeRestart(restart)
[17:39:35.885]                             muffled <- TRUE
[17:39:35.885]                             break
[17:39:35.885]                           }
[17:39:35.885]                         }
[17:39:35.885]                       }
[17:39:35.885]                       invisible(muffled)
[17:39:35.885]                     }
[17:39:35.885]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.885]                   }
[17:39:35.885]                 }
[17:39:35.885]                 else {
[17:39:35.885]                   if (TRUE) {
[17:39:35.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.885]                     {
[17:39:35.885]                       inherits <- base::inherits
[17:39:35.885]                       invokeRestart <- base::invokeRestart
[17:39:35.885]                       is.null <- base::is.null
[17:39:35.885]                       muffled <- FALSE
[17:39:35.885]                       if (inherits(cond, "message")) {
[17:39:35.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.885]                         if (muffled) 
[17:39:35.885]                           invokeRestart("muffleMessage")
[17:39:35.885]                       }
[17:39:35.885]                       else if (inherits(cond, "warning")) {
[17:39:35.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.885]                         if (muffled) 
[17:39:35.885]                           invokeRestart("muffleWarning")
[17:39:35.885]                       }
[17:39:35.885]                       else if (inherits(cond, "condition")) {
[17:39:35.885]                         if (!is.null(pattern)) {
[17:39:35.885]                           computeRestarts <- base::computeRestarts
[17:39:35.885]                           grepl <- base::grepl
[17:39:35.885]                           restarts <- computeRestarts(cond)
[17:39:35.885]                           for (restart in restarts) {
[17:39:35.885]                             name <- restart$name
[17:39:35.885]                             if (is.null(name)) 
[17:39:35.885]                               next
[17:39:35.885]                             if (!grepl(pattern, name)) 
[17:39:35.885]                               next
[17:39:35.885]                             invokeRestart(restart)
[17:39:35.885]                             muffled <- TRUE
[17:39:35.885]                             break
[17:39:35.885]                           }
[17:39:35.885]                         }
[17:39:35.885]                       }
[17:39:35.885]                       invisible(muffled)
[17:39:35.885]                     }
[17:39:35.885]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.885]                   }
[17:39:35.885]                 }
[17:39:35.885]             }
[17:39:35.885]         }))
[17:39:35.885]     }, error = function(ex) {
[17:39:35.885]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.885]                 ...future.rng), started = ...future.startTime, 
[17:39:35.885]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.885]             version = "1.8"), class = "FutureResult")
[17:39:35.885]     }, finally = {
[17:39:35.885]         if (!identical(...future.workdir, getwd())) 
[17:39:35.885]             setwd(...future.workdir)
[17:39:35.885]         {
[17:39:35.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.885]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.885]             }
[17:39:35.885]             base::options(...future.oldOptions)
[17:39:35.885]             if (.Platform$OS.type == "windows") {
[17:39:35.885]                 old_names <- names(...future.oldEnvVars)
[17:39:35.885]                 envs <- base::Sys.getenv()
[17:39:35.885]                 names <- names(envs)
[17:39:35.885]                 common <- intersect(names, old_names)
[17:39:35.885]                 added <- setdiff(names, old_names)
[17:39:35.885]                 removed <- setdiff(old_names, names)
[17:39:35.885]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.885]                   envs[common]]
[17:39:35.885]                 NAMES <- toupper(changed)
[17:39:35.885]                 args <- list()
[17:39:35.885]                 for (kk in seq_along(NAMES)) {
[17:39:35.885]                   name <- changed[[kk]]
[17:39:35.885]                   NAME <- NAMES[[kk]]
[17:39:35.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.885]                     next
[17:39:35.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.885]                 }
[17:39:35.885]                 NAMES <- toupper(added)
[17:39:35.885]                 for (kk in seq_along(NAMES)) {
[17:39:35.885]                   name <- added[[kk]]
[17:39:35.885]                   NAME <- NAMES[[kk]]
[17:39:35.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.885]                     next
[17:39:35.885]                   args[[name]] <- ""
[17:39:35.885]                 }
[17:39:35.885]                 NAMES <- toupper(removed)
[17:39:35.885]                 for (kk in seq_along(NAMES)) {
[17:39:35.885]                   name <- removed[[kk]]
[17:39:35.885]                   NAME <- NAMES[[kk]]
[17:39:35.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.885]                     next
[17:39:35.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.885]                 }
[17:39:35.885]                 if (length(args) > 0) 
[17:39:35.885]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.885]             }
[17:39:35.885]             else {
[17:39:35.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.885]             }
[17:39:35.885]             {
[17:39:35.885]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.885]                   0L) {
[17:39:35.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.885]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.885]                   base::options(opts)
[17:39:35.885]                 }
[17:39:35.885]                 {
[17:39:35.885]                   {
[17:39:35.885]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.885]                     NULL
[17:39:35.885]                   }
[17:39:35.885]                   options(future.plan = NULL)
[17:39:35.885]                   if (is.na(NA_character_)) 
[17:39:35.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.885]                     .init = FALSE)
[17:39:35.885]                 }
[17:39:35.885]             }
[17:39:35.885]         }
[17:39:35.885]     })
[17:39:35.885]     if (TRUE) {
[17:39:35.885]         base::sink(type = "output", split = FALSE)
[17:39:35.885]         if (TRUE) {
[17:39:35.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.885]         }
[17:39:35.885]         else {
[17:39:35.885]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.885]         }
[17:39:35.885]         base::close(...future.stdout)
[17:39:35.885]         ...future.stdout <- NULL
[17:39:35.885]     }
[17:39:35.885]     ...future.result$conditions <- ...future.conditions
[17:39:35.885]     ...future.result$finished <- base::Sys.time()
[17:39:35.885]     ...future.result
[17:39:35.885] }
[17:39:35.889] requestCore(): workers = 2
[17:39:35.889] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:35.900] result() for MulticoreFuture ...
[17:39:35.901] result() for MulticoreFuture ...
[17:39:35.901] result() for MulticoreFuture ... done
[17:39:35.901] result() for MulticoreFuture ... done
[17:39:35.901] result() for MulticoreFuture ...
[17:39:35.901] result() for MulticoreFuture ... done
[17:39:35.904] MulticoreFuture started
[17:39:35.905] - Launch lazy future ... done
[17:39:35.905] run() for ‘MulticoreFuture’ ... done
[17:39:35.906] plan(): Setting new future strategy stack:
<environment: 0x55adf20a2800> 
[17:39:35.906] List of future strategies:
[17:39:35.906] 1. sequential:
[17:39:35.906]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.906]    - tweaked: FALSE
[17:39:35.906]    - call: NULL
[17:39:35.907] plan(): nbrOfWorkers() = 1
<environment: 0x55adeff21af0> 
[17:39:35.910] plan(): Setting new future strategy stack:
[17:39:35.910] List of future strategies:
[17:39:35.910] 1. multicore:
[17:39:35.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.910]    - tweaked: FALSE
[17:39:35.910]    - call: plan(strategy)
[17:39:35.916] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:35.918] resolve() on environment ...
[17:39:35.918]  recursive: 0
[17:39:35.919]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:35.919] signalConditionsASAP(numeric, pos=1) ...
[17:39:35.919] - nx: 4
[17:39:35.919] - relay: TRUE
[17:39:35.920] - stdout: TRUE
[17:39:35.920] - signal: TRUE
[17:39:35.920] - resignal: FALSE
[17:39:35.920] - force: TRUE
[17:39:35.920] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.920] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.920]  - until=2
[17:39:35.921]  - relaying element #2
[17:39:35.921] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.921] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.921] signalConditionsASAP(NULL, pos=1) ... done
[17:39:35.921]  length: 3 (resolved future 1)
[17:39:35.921] Future #2
[17:39:35.921] result() for MulticoreFuture ...
[17:39:35.922] result() for MulticoreFuture ... done
[17:39:35.922] result() for MulticoreFuture ...
[17:39:35.922] result() for MulticoreFuture ... done
[17:39:35.922] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:35.922] - nx: 4
[17:39:35.922] - relay: TRUE
[17:39:35.923] - stdout: TRUE
[17:39:35.923] - signal: TRUE
[17:39:35.923] - resignal: FALSE
[17:39:35.923] - force: TRUE
[17:39:35.923] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:35.923] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:35.923]  - until=2
[17:39:35.924]  - relaying element #2
[17:39:35.924] result() for MulticoreFuture ...
[17:39:35.924] result() for MulticoreFuture ... done
[17:39:35.924] result() for MulticoreFuture ...
[17:39:35.924] result() for MulticoreFuture ... done
[17:39:35.924] result() for MulticoreFuture ...
[17:39:35.924] result() for MulticoreFuture ... done
[17:39:35.925] result() for MulticoreFuture ...
[17:39:35.925] result() for MulticoreFuture ... done
[17:39:35.925] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.925] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.925] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:35.925]  length: 2 (resolved future 2)
[17:39:35.926] Future #3
[17:39:35.926] result() for MulticoreFuture ...
[17:39:35.927] result() for MulticoreFuture ...
[17:39:35.927] result() for MulticoreFuture ... done
[17:39:35.927] result() for MulticoreFuture ... done
[17:39:35.927] result() for MulticoreFuture ...
[17:39:35.927] result() for MulticoreFuture ... done
[17:39:35.928] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:35.928] - nx: 4
[17:39:35.928] - relay: TRUE
[17:39:35.928] - stdout: TRUE
[17:39:35.928] - signal: TRUE
[17:39:35.929] - resignal: FALSE
[17:39:35.929] - force: TRUE
[17:39:35.929] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:35.929] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:35.929]  - until=3
[17:39:35.929]  - relaying element #3
[17:39:35.930] result() for MulticoreFuture ...
[17:39:35.930] result() for MulticoreFuture ... done
[17:39:35.930] result() for MulticoreFuture ...
[17:39:35.930] result() for MulticoreFuture ... done
[17:39:35.931] result() for MulticoreFuture ...
[17:39:35.931] result() for MulticoreFuture ... done
[17:39:35.931] result() for MulticoreFuture ...
[17:39:35.931] result() for MulticoreFuture ... done
[17:39:35.931] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.931] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.932] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:35.932]  length: 1 (resolved future 3)
[17:39:35.932] Future #4
[17:39:35.932] result() for MulticoreFuture ...
[17:39:35.933] result() for MulticoreFuture ...
[17:39:35.933] result() for MulticoreFuture ... done
[17:39:35.934] result() for MulticoreFuture ... done
[17:39:35.934] result() for MulticoreFuture ...
[17:39:35.934] result() for MulticoreFuture ... done
[17:39:35.934] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:35.934] - nx: 4
[17:39:35.935] - relay: TRUE
[17:39:35.935] - stdout: TRUE
[17:39:35.935] - signal: TRUE
[17:39:35.935] - resignal: FALSE
[17:39:35.935] - force: TRUE
[17:39:35.935] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:35.935] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:35.936]  - until=4
[17:39:35.936]  - relaying element #4
[17:39:35.936] result() for MulticoreFuture ...
[17:39:35.936] result() for MulticoreFuture ... done
[17:39:35.936] result() for MulticoreFuture ...
[17:39:35.936] result() for MulticoreFuture ... done
[17:39:35.937] result() for MulticoreFuture ...
[17:39:35.937] result() for MulticoreFuture ... done
[17:39:35.937] result() for MulticoreFuture ...
[17:39:35.937] result() for MulticoreFuture ... done
[17:39:35.937] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.937] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.937] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:35.937]  length: 0 (resolved future 4)
[17:39:35.938] Relaying remaining futures
[17:39:35.938] signalConditionsASAP(NULL, pos=0) ...
[17:39:35.938] - nx: 4
[17:39:35.938] - relay: TRUE
[17:39:35.938] - stdout: TRUE
[17:39:35.938] - signal: TRUE
[17:39:35.938] - resignal: FALSE
[17:39:35.938] - force: TRUE
[17:39:35.938] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.938] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:35.939] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:35.939] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:35.939] signalConditionsASAP(NULL, pos=0) ... done
[17:39:35.939] resolve() on environment ... DONE
[17:39:35.939] result() for MulticoreFuture ...
[17:39:35.939] result() for MulticoreFuture ... done
[17:39:35.939] result() for MulticoreFuture ...
[17:39:35.939] result() for MulticoreFuture ... done
[17:39:35.940] result() for MulticoreFuture ...
[17:39:35.940] result() for MulticoreFuture ... done
[17:39:35.940] result() for MulticoreFuture ...
[17:39:35.940] result() for MulticoreFuture ... done
[17:39:35.940] result() for MulticoreFuture ...
[17:39:35.940] result() for MulticoreFuture ... done
[17:39:35.940] result() for MulticoreFuture ...
[17:39:35.941] result() for MulticoreFuture ... done
<environment: 0x55adefca5de0> 
Dimensions: c(2, 3, 1)
[17:39:35.941] getGlobalsAndPackages() ...
[17:39:35.941] Searching for globals...
[17:39:35.942] 
[17:39:35.942] Searching for globals ... DONE
[17:39:35.942] - globals: [0] <none>
[17:39:35.942] getGlobalsAndPackages() ... DONE
[17:39:35.942] run() for ‘Future’ ...
[17:39:35.942] - state: ‘created’
[17:39:35.943] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.947] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.947] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.947]   - Field: ‘label’
[17:39:35.947]   - Field: ‘local’
[17:39:35.947]   - Field: ‘owner’
[17:39:35.948]   - Field: ‘envir’
[17:39:35.948]   - Field: ‘workers’
[17:39:35.948]   - Field: ‘packages’
[17:39:35.948]   - Field: ‘gc’
[17:39:35.948]   - Field: ‘job’
[17:39:35.948]   - Field: ‘conditions’
[17:39:35.948]   - Field: ‘expr’
[17:39:35.948]   - Field: ‘uuid’
[17:39:35.948]   - Field: ‘seed’
[17:39:35.949]   - Field: ‘version’
[17:39:35.949]   - Field: ‘result’
[17:39:35.949]   - Field: ‘asynchronous’
[17:39:35.949]   - Field: ‘calls’
[17:39:35.949]   - Field: ‘globals’
[17:39:35.949]   - Field: ‘stdout’
[17:39:35.949]   - Field: ‘earlySignal’
[17:39:35.949]   - Field: ‘lazy’
[17:39:35.949]   - Field: ‘state’
[17:39:35.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.950] - Launch lazy future ...
[17:39:35.950] Packages needed by the future expression (n = 0): <none>
[17:39:35.950] Packages needed by future strategies (n = 0): <none>
[17:39:35.951] {
[17:39:35.951]     {
[17:39:35.951]         {
[17:39:35.951]             ...future.startTime <- base::Sys.time()
[17:39:35.951]             {
[17:39:35.951]                 {
[17:39:35.951]                   {
[17:39:35.951]                     {
[17:39:35.951]                       base::local({
[17:39:35.951]                         has_future <- base::requireNamespace("future", 
[17:39:35.951]                           quietly = TRUE)
[17:39:35.951]                         if (has_future) {
[17:39:35.951]                           ns <- base::getNamespace("future")
[17:39:35.951]                           version <- ns[[".package"]][["version"]]
[17:39:35.951]                           if (is.null(version)) 
[17:39:35.951]                             version <- utils::packageVersion("future")
[17:39:35.951]                         }
[17:39:35.951]                         else {
[17:39:35.951]                           version <- NULL
[17:39:35.951]                         }
[17:39:35.951]                         if (!has_future || version < "1.8.0") {
[17:39:35.951]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.951]                             "", base::R.version$version.string), 
[17:39:35.951]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.951]                               "release", "version")], collapse = " "), 
[17:39:35.951]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.951]                             info)
[17:39:35.951]                           info <- base::paste(info, collapse = "; ")
[17:39:35.951]                           if (!has_future) {
[17:39:35.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.951]                               info)
[17:39:35.951]                           }
[17:39:35.951]                           else {
[17:39:35.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.951]                               info, version)
[17:39:35.951]                           }
[17:39:35.951]                           base::stop(msg)
[17:39:35.951]                         }
[17:39:35.951]                       })
[17:39:35.951]                     }
[17:39:35.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.951]                     base::options(mc.cores = 1L)
[17:39:35.951]                   }
[17:39:35.951]                   ...future.strategy.old <- future::plan("list")
[17:39:35.951]                   options(future.plan = NULL)
[17:39:35.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.951]                 }
[17:39:35.951]                 ...future.workdir <- getwd()
[17:39:35.951]             }
[17:39:35.951]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.951]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.951]         }
[17:39:35.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.951]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.951]             base::names(...future.oldOptions))
[17:39:35.951]     }
[17:39:35.951]     if (FALSE) {
[17:39:35.951]     }
[17:39:35.951]     else {
[17:39:35.951]         if (TRUE) {
[17:39:35.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.951]                 open = "w")
[17:39:35.951]         }
[17:39:35.951]         else {
[17:39:35.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.951]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.951]         }
[17:39:35.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.951]             base::sink(type = "output", split = FALSE)
[17:39:35.951]             base::close(...future.stdout)
[17:39:35.951]         }, add = TRUE)
[17:39:35.951]     }
[17:39:35.951]     ...future.frame <- base::sys.nframe()
[17:39:35.951]     ...future.conditions <- base::list()
[17:39:35.951]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.951]     if (FALSE) {
[17:39:35.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.951]     }
[17:39:35.951]     ...future.result <- base::tryCatch({
[17:39:35.951]         base::withCallingHandlers({
[17:39:35.951]             ...future.value <- base::withVisible(base::local({
[17:39:35.951]                 withCallingHandlers({
[17:39:35.951]                   2
[17:39:35.951]                 }, immediateCondition = function(cond) {
[17:39:35.951]                   save_rds <- function (object, pathname, ...) 
[17:39:35.951]                   {
[17:39:35.951]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.951]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.951]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.951]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.951]                         fi_tmp[["mtime"]])
[17:39:35.951]                     }
[17:39:35.951]                     tryCatch({
[17:39:35.951]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.951]                     }, error = function(ex) {
[17:39:35.951]                       msg <- conditionMessage(ex)
[17:39:35.951]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.951]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.951]                         fi_tmp[["mtime"]], msg)
[17:39:35.951]                       ex$message <- msg
[17:39:35.951]                       stop(ex)
[17:39:35.951]                     })
[17:39:35.951]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.951]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.951]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.951]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.951]                       fi <- file.info(pathname)
[17:39:35.951]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.951]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.951]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.951]                         fi[["size"]], fi[["mtime"]])
[17:39:35.951]                       stop(msg)
[17:39:35.951]                     }
[17:39:35.951]                     invisible(pathname)
[17:39:35.951]                   }
[17:39:35.951]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.951]                     rootPath = tempdir()) 
[17:39:35.951]                   {
[17:39:35.951]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.951]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.951]                       tmpdir = path, fileext = ".rds")
[17:39:35.951]                     save_rds(obj, file)
[17:39:35.951]                   }
[17:39:35.951]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.951]                   {
[17:39:35.951]                     inherits <- base::inherits
[17:39:35.951]                     invokeRestart <- base::invokeRestart
[17:39:35.951]                     is.null <- base::is.null
[17:39:35.951]                     muffled <- FALSE
[17:39:35.951]                     if (inherits(cond, "message")) {
[17:39:35.951]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.951]                       if (muffled) 
[17:39:35.951]                         invokeRestart("muffleMessage")
[17:39:35.951]                     }
[17:39:35.951]                     else if (inherits(cond, "warning")) {
[17:39:35.951]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.951]                       if (muffled) 
[17:39:35.951]                         invokeRestart("muffleWarning")
[17:39:35.951]                     }
[17:39:35.951]                     else if (inherits(cond, "condition")) {
[17:39:35.951]                       if (!is.null(pattern)) {
[17:39:35.951]                         computeRestarts <- base::computeRestarts
[17:39:35.951]                         grepl <- base::grepl
[17:39:35.951]                         restarts <- computeRestarts(cond)
[17:39:35.951]                         for (restart in restarts) {
[17:39:35.951]                           name <- restart$name
[17:39:35.951]                           if (is.null(name)) 
[17:39:35.951]                             next
[17:39:35.951]                           if (!grepl(pattern, name)) 
[17:39:35.951]                             next
[17:39:35.951]                           invokeRestart(restart)
[17:39:35.951]                           muffled <- TRUE
[17:39:35.951]                           break
[17:39:35.951]                         }
[17:39:35.951]                       }
[17:39:35.951]                     }
[17:39:35.951]                     invisible(muffled)
[17:39:35.951]                   }
[17:39:35.951]                   muffleCondition(cond)
[17:39:35.951]                 })
[17:39:35.951]             }))
[17:39:35.951]             future::FutureResult(value = ...future.value$value, 
[17:39:35.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.951]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.951]                     ...future.globalenv.names))
[17:39:35.951]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.951]         }, condition = base::local({
[17:39:35.951]             c <- base::c
[17:39:35.951]             inherits <- base::inherits
[17:39:35.951]             invokeRestart <- base::invokeRestart
[17:39:35.951]             length <- base::length
[17:39:35.951]             list <- base::list
[17:39:35.951]             seq.int <- base::seq.int
[17:39:35.951]             signalCondition <- base::signalCondition
[17:39:35.951]             sys.calls <- base::sys.calls
[17:39:35.951]             `[[` <- base::`[[`
[17:39:35.951]             `+` <- base::`+`
[17:39:35.951]             `<<-` <- base::`<<-`
[17:39:35.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.951]                   3L)]
[17:39:35.951]             }
[17:39:35.951]             function(cond) {
[17:39:35.951]                 is_error <- inherits(cond, "error")
[17:39:35.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.951]                   NULL)
[17:39:35.951]                 if (is_error) {
[17:39:35.951]                   sessionInformation <- function() {
[17:39:35.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.951]                       search = base::search(), system = base::Sys.info())
[17:39:35.951]                   }
[17:39:35.951]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.951]                     cond$call), session = sessionInformation(), 
[17:39:35.951]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.951]                   signalCondition(cond)
[17:39:35.951]                 }
[17:39:35.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.951]                 "immediateCondition"))) {
[17:39:35.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.951]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.951]                   if (TRUE && !signal) {
[17:39:35.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.951]                     {
[17:39:35.951]                       inherits <- base::inherits
[17:39:35.951]                       invokeRestart <- base::invokeRestart
[17:39:35.951]                       is.null <- base::is.null
[17:39:35.951]                       muffled <- FALSE
[17:39:35.951]                       if (inherits(cond, "message")) {
[17:39:35.951]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.951]                         if (muffled) 
[17:39:35.951]                           invokeRestart("muffleMessage")
[17:39:35.951]                       }
[17:39:35.951]                       else if (inherits(cond, "warning")) {
[17:39:35.951]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.951]                         if (muffled) 
[17:39:35.951]                           invokeRestart("muffleWarning")
[17:39:35.951]                       }
[17:39:35.951]                       else if (inherits(cond, "condition")) {
[17:39:35.951]                         if (!is.null(pattern)) {
[17:39:35.951]                           computeRestarts <- base::computeRestarts
[17:39:35.951]                           grepl <- base::grepl
[17:39:35.951]                           restarts <- computeRestarts(cond)
[17:39:35.951]                           for (restart in restarts) {
[17:39:35.951]                             name <- restart$name
[17:39:35.951]                             if (is.null(name)) 
[17:39:35.951]                               next
[17:39:35.951]                             if (!grepl(pattern, name)) 
[17:39:35.951]                               next
[17:39:35.951]                             invokeRestart(restart)
[17:39:35.951]                             muffled <- TRUE
[17:39:35.951]                             break
[17:39:35.951]                           }
[17:39:35.951]                         }
[17:39:35.951]                       }
[17:39:35.951]                       invisible(muffled)
[17:39:35.951]                     }
[17:39:35.951]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.951]                   }
[17:39:35.951]                 }
[17:39:35.951]                 else {
[17:39:35.951]                   if (TRUE) {
[17:39:35.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.951]                     {
[17:39:35.951]                       inherits <- base::inherits
[17:39:35.951]                       invokeRestart <- base::invokeRestart
[17:39:35.951]                       is.null <- base::is.null
[17:39:35.951]                       muffled <- FALSE
[17:39:35.951]                       if (inherits(cond, "message")) {
[17:39:35.951]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.951]                         if (muffled) 
[17:39:35.951]                           invokeRestart("muffleMessage")
[17:39:35.951]                       }
[17:39:35.951]                       else if (inherits(cond, "warning")) {
[17:39:35.951]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.951]                         if (muffled) 
[17:39:35.951]                           invokeRestart("muffleWarning")
[17:39:35.951]                       }
[17:39:35.951]                       else if (inherits(cond, "condition")) {
[17:39:35.951]                         if (!is.null(pattern)) {
[17:39:35.951]                           computeRestarts <- base::computeRestarts
[17:39:35.951]                           grepl <- base::grepl
[17:39:35.951]                           restarts <- computeRestarts(cond)
[17:39:35.951]                           for (restart in restarts) {
[17:39:35.951]                             name <- restart$name
[17:39:35.951]                             if (is.null(name)) 
[17:39:35.951]                               next
[17:39:35.951]                             if (!grepl(pattern, name)) 
[17:39:35.951]                               next
[17:39:35.951]                             invokeRestart(restart)
[17:39:35.951]                             muffled <- TRUE
[17:39:35.951]                             break
[17:39:35.951]                           }
[17:39:35.951]                         }
[17:39:35.951]                       }
[17:39:35.951]                       invisible(muffled)
[17:39:35.951]                     }
[17:39:35.951]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.951]                   }
[17:39:35.951]                 }
[17:39:35.951]             }
[17:39:35.951]         }))
[17:39:35.951]     }, error = function(ex) {
[17:39:35.951]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.951]                 ...future.rng), started = ...future.startTime, 
[17:39:35.951]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.951]             version = "1.8"), class = "FutureResult")
[17:39:35.951]     }, finally = {
[17:39:35.951]         if (!identical(...future.workdir, getwd())) 
[17:39:35.951]             setwd(...future.workdir)
[17:39:35.951]         {
[17:39:35.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.951]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.951]             }
[17:39:35.951]             base::options(...future.oldOptions)
[17:39:35.951]             if (.Platform$OS.type == "windows") {
[17:39:35.951]                 old_names <- names(...future.oldEnvVars)
[17:39:35.951]                 envs <- base::Sys.getenv()
[17:39:35.951]                 names <- names(envs)
[17:39:35.951]                 common <- intersect(names, old_names)
[17:39:35.951]                 added <- setdiff(names, old_names)
[17:39:35.951]                 removed <- setdiff(old_names, names)
[17:39:35.951]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.951]                   envs[common]]
[17:39:35.951]                 NAMES <- toupper(changed)
[17:39:35.951]                 args <- list()
[17:39:35.951]                 for (kk in seq_along(NAMES)) {
[17:39:35.951]                   name <- changed[[kk]]
[17:39:35.951]                   NAME <- NAMES[[kk]]
[17:39:35.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.951]                     next
[17:39:35.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.951]                 }
[17:39:35.951]                 NAMES <- toupper(added)
[17:39:35.951]                 for (kk in seq_along(NAMES)) {
[17:39:35.951]                   name <- added[[kk]]
[17:39:35.951]                   NAME <- NAMES[[kk]]
[17:39:35.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.951]                     next
[17:39:35.951]                   args[[name]] <- ""
[17:39:35.951]                 }
[17:39:35.951]                 NAMES <- toupper(removed)
[17:39:35.951]                 for (kk in seq_along(NAMES)) {
[17:39:35.951]                   name <- removed[[kk]]
[17:39:35.951]                   NAME <- NAMES[[kk]]
[17:39:35.951]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.951]                     next
[17:39:35.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.951]                 }
[17:39:35.951]                 if (length(args) > 0) 
[17:39:35.951]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.951]             }
[17:39:35.951]             else {
[17:39:35.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.951]             }
[17:39:35.951]             {
[17:39:35.951]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.951]                   0L) {
[17:39:35.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.951]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.951]                   base::options(opts)
[17:39:35.951]                 }
[17:39:35.951]                 {
[17:39:35.951]                   {
[17:39:35.951]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.951]                     NULL
[17:39:35.951]                   }
[17:39:35.951]                   options(future.plan = NULL)
[17:39:35.951]                   if (is.na(NA_character_)) 
[17:39:35.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.951]                     .init = FALSE)
[17:39:35.951]                 }
[17:39:35.951]             }
[17:39:35.951]         }
[17:39:35.951]     })
[17:39:35.951]     if (TRUE) {
[17:39:35.951]         base::sink(type = "output", split = FALSE)
[17:39:35.951]         if (TRUE) {
[17:39:35.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.951]         }
[17:39:35.951]         else {
[17:39:35.951]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.951]         }
[17:39:35.951]         base::close(...future.stdout)
[17:39:35.951]         ...future.stdout <- NULL
[17:39:35.951]     }
[17:39:35.951]     ...future.result$conditions <- ...future.conditions
[17:39:35.951]     ...future.result$finished <- base::Sys.time()
[17:39:35.951]     ...future.result
[17:39:35.951] }
[17:39:35.953] requestCore(): workers = 2
[17:39:35.956] MulticoreFuture started
[17:39:35.957] - Launch lazy future ... done
[17:39:35.957] run() for ‘MulticoreFuture’ ... done
[17:39:35.957] getGlobalsAndPackages() ...
[17:39:35.957] Searching for globals...
[17:39:35.957] plan(): Setting new future strategy stack:
[17:39:35.958] 
[17:39:35.958] Searching for globals ... DONE
[17:39:35.958] - globals: [0] <none>
[17:39:35.958] List of future strategies:
[17:39:35.958] 1. sequential:
[17:39:35.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.958]    - tweaked: FALSE
[17:39:35.958]    - call: NULL
[17:39:35.958] getGlobalsAndPackages() ... DONE
[17:39:35.959] plan(): nbrOfWorkers() = 1
[17:39:35.959] run() for ‘Future’ ...
[17:39:35.959] - state: ‘created’
[17:39:35.959] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.961] plan(): Setting new future strategy stack:
[17:39:35.961] List of future strategies:
[17:39:35.961] 1. multicore:
[17:39:35.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.961]    - tweaked: FALSE
[17:39:35.961]    - call: plan(strategy)
[17:39:35.965] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.965]   - Field: ‘label’
[17:39:35.965]   - Field: ‘local’
[17:39:35.965] plan(): nbrOfWorkers() = 2
[17:39:35.966]   - Field: ‘owner’
[17:39:35.966]   - Field: ‘envir’
[17:39:35.966]   - Field: ‘workers’
[17:39:35.966]   - Field: ‘packages’
[17:39:35.966]   - Field: ‘gc’
[17:39:35.966]   - Field: ‘job’
[17:39:35.966]   - Field: ‘conditions’
[17:39:35.967]   - Field: ‘expr’
[17:39:35.967]   - Field: ‘uuid’
[17:39:35.967]   - Field: ‘seed’
[17:39:35.967]   - Field: ‘version’
[17:39:35.967]   - Field: ‘result’
[17:39:35.967]   - Field: ‘asynchronous’
[17:39:35.967]   - Field: ‘calls’
[17:39:35.967]   - Field: ‘globals’
[17:39:35.968]   - Field: ‘stdout’
[17:39:35.968]   - Field: ‘earlySignal’
[17:39:35.968]   - Field: ‘lazy’
[17:39:35.968]   - Field: ‘state’
[17:39:35.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.968] - Launch lazy future ...
[17:39:35.969] Packages needed by the future expression (n = 0): <none>
[17:39:35.969] Packages needed by future strategies (n = 0): <none>
[17:39:35.970] {
[17:39:35.970]     {
[17:39:35.970]         {
[17:39:35.970]             ...future.startTime <- base::Sys.time()
[17:39:35.970]             {
[17:39:35.970]                 {
[17:39:35.970]                   {
[17:39:35.970]                     {
[17:39:35.970]                       base::local({
[17:39:35.970]                         has_future <- base::requireNamespace("future", 
[17:39:35.970]                           quietly = TRUE)
[17:39:35.970]                         if (has_future) {
[17:39:35.970]                           ns <- base::getNamespace("future")
[17:39:35.970]                           version <- ns[[".package"]][["version"]]
[17:39:35.970]                           if (is.null(version)) 
[17:39:35.970]                             version <- utils::packageVersion("future")
[17:39:35.970]                         }
[17:39:35.970]                         else {
[17:39:35.970]                           version <- NULL
[17:39:35.970]                         }
[17:39:35.970]                         if (!has_future || version < "1.8.0") {
[17:39:35.970]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.970]                             "", base::R.version$version.string), 
[17:39:35.970]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.970]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.970]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.970]                               "release", "version")], collapse = " "), 
[17:39:35.970]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.970]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.970]                             info)
[17:39:35.970]                           info <- base::paste(info, collapse = "; ")
[17:39:35.970]                           if (!has_future) {
[17:39:35.970]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.970]                               info)
[17:39:35.970]                           }
[17:39:35.970]                           else {
[17:39:35.970]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.970]                               info, version)
[17:39:35.970]                           }
[17:39:35.970]                           base::stop(msg)
[17:39:35.970]                         }
[17:39:35.970]                       })
[17:39:35.970]                     }
[17:39:35.970]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.970]                     base::options(mc.cores = 1L)
[17:39:35.970]                   }
[17:39:35.970]                   ...future.strategy.old <- future::plan("list")
[17:39:35.970]                   options(future.plan = NULL)
[17:39:35.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.970]                 }
[17:39:35.970]                 ...future.workdir <- getwd()
[17:39:35.970]             }
[17:39:35.970]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.970]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.970]         }
[17:39:35.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.970]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.970]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.970]             base::names(...future.oldOptions))
[17:39:35.970]     }
[17:39:35.970]     if (FALSE) {
[17:39:35.970]     }
[17:39:35.970]     else {
[17:39:35.970]         if (TRUE) {
[17:39:35.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.970]                 open = "w")
[17:39:35.970]         }
[17:39:35.970]         else {
[17:39:35.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.970]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.970]         }
[17:39:35.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.970]             base::sink(type = "output", split = FALSE)
[17:39:35.970]             base::close(...future.stdout)
[17:39:35.970]         }, add = TRUE)
[17:39:35.970]     }
[17:39:35.970]     ...future.frame <- base::sys.nframe()
[17:39:35.970]     ...future.conditions <- base::list()
[17:39:35.970]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.970]     if (FALSE) {
[17:39:35.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.970]     }
[17:39:35.970]     ...future.result <- base::tryCatch({
[17:39:35.970]         base::withCallingHandlers({
[17:39:35.970]             ...future.value <- base::withVisible(base::local({
[17:39:35.970]                 withCallingHandlers({
[17:39:35.970]                   NULL
[17:39:35.970]                 }, immediateCondition = function(cond) {
[17:39:35.970]                   save_rds <- function (object, pathname, ...) 
[17:39:35.970]                   {
[17:39:35.970]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.970]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.970]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.970]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.970]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.970]                         fi_tmp[["mtime"]])
[17:39:35.970]                     }
[17:39:35.970]                     tryCatch({
[17:39:35.970]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.970]                     }, error = function(ex) {
[17:39:35.970]                       msg <- conditionMessage(ex)
[17:39:35.970]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.970]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.970]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.970]                         fi_tmp[["mtime"]], msg)
[17:39:35.970]                       ex$message <- msg
[17:39:35.970]                       stop(ex)
[17:39:35.970]                     })
[17:39:35.970]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.970]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.970]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.970]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.970]                       fi <- file.info(pathname)
[17:39:35.970]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.970]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.970]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.970]                         fi[["size"]], fi[["mtime"]])
[17:39:35.970]                       stop(msg)
[17:39:35.970]                     }
[17:39:35.970]                     invisible(pathname)
[17:39:35.970]                   }
[17:39:35.970]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.970]                     rootPath = tempdir()) 
[17:39:35.970]                   {
[17:39:35.970]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.970]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.970]                       tmpdir = path, fileext = ".rds")
[17:39:35.970]                     save_rds(obj, file)
[17:39:35.970]                   }
[17:39:35.970]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.970]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.970]                   {
[17:39:35.970]                     inherits <- base::inherits
[17:39:35.970]                     invokeRestart <- base::invokeRestart
[17:39:35.970]                     is.null <- base::is.null
[17:39:35.970]                     muffled <- FALSE
[17:39:35.970]                     if (inherits(cond, "message")) {
[17:39:35.970]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.970]                       if (muffled) 
[17:39:35.970]                         invokeRestart("muffleMessage")
[17:39:35.970]                     }
[17:39:35.970]                     else if (inherits(cond, "warning")) {
[17:39:35.970]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.970]                       if (muffled) 
[17:39:35.970]                         invokeRestart("muffleWarning")
[17:39:35.970]                     }
[17:39:35.970]                     else if (inherits(cond, "condition")) {
[17:39:35.970]                       if (!is.null(pattern)) {
[17:39:35.970]                         computeRestarts <- base::computeRestarts
[17:39:35.970]                         grepl <- base::grepl
[17:39:35.970]                         restarts <- computeRestarts(cond)
[17:39:35.970]                         for (restart in restarts) {
[17:39:35.970]                           name <- restart$name
[17:39:35.970]                           if (is.null(name)) 
[17:39:35.970]                             next
[17:39:35.970]                           if (!grepl(pattern, name)) 
[17:39:35.970]                             next
[17:39:35.970]                           invokeRestart(restart)
[17:39:35.970]                           muffled <- TRUE
[17:39:35.970]                           break
[17:39:35.970]                         }
[17:39:35.970]                       }
[17:39:35.970]                     }
[17:39:35.970]                     invisible(muffled)
[17:39:35.970]                   }
[17:39:35.970]                   muffleCondition(cond)
[17:39:35.970]                 })
[17:39:35.970]             }))
[17:39:35.970]             future::FutureResult(value = ...future.value$value, 
[17:39:35.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.970]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.970]                     ...future.globalenv.names))
[17:39:35.970]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.970]         }, condition = base::local({
[17:39:35.970]             c <- base::c
[17:39:35.970]             inherits <- base::inherits
[17:39:35.970]             invokeRestart <- base::invokeRestart
[17:39:35.970]             length <- base::length
[17:39:35.970]             list <- base::list
[17:39:35.970]             seq.int <- base::seq.int
[17:39:35.970]             signalCondition <- base::signalCondition
[17:39:35.970]             sys.calls <- base::sys.calls
[17:39:35.970]             `[[` <- base::`[[`
[17:39:35.970]             `+` <- base::`+`
[17:39:35.970]             `<<-` <- base::`<<-`
[17:39:35.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.970]                   3L)]
[17:39:35.970]             }
[17:39:35.970]             function(cond) {
[17:39:35.970]                 is_error <- inherits(cond, "error")
[17:39:35.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.970]                   NULL)
[17:39:35.970]                 if (is_error) {
[17:39:35.970]                   sessionInformation <- function() {
[17:39:35.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.970]                       search = base::search(), system = base::Sys.info())
[17:39:35.970]                   }
[17:39:35.970]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.970]                     cond$call), session = sessionInformation(), 
[17:39:35.970]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.970]                   signalCondition(cond)
[17:39:35.970]                 }
[17:39:35.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.970]                 "immediateCondition"))) {
[17:39:35.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.970]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.970]                   if (TRUE && !signal) {
[17:39:35.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.970]                     {
[17:39:35.970]                       inherits <- base::inherits
[17:39:35.970]                       invokeRestart <- base::invokeRestart
[17:39:35.970]                       is.null <- base::is.null
[17:39:35.970]                       muffled <- FALSE
[17:39:35.970]                       if (inherits(cond, "message")) {
[17:39:35.970]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.970]                         if (muffled) 
[17:39:35.970]                           invokeRestart("muffleMessage")
[17:39:35.970]                       }
[17:39:35.970]                       else if (inherits(cond, "warning")) {
[17:39:35.970]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.970]                         if (muffled) 
[17:39:35.970]                           invokeRestart("muffleWarning")
[17:39:35.970]                       }
[17:39:35.970]                       else if (inherits(cond, "condition")) {
[17:39:35.970]                         if (!is.null(pattern)) {
[17:39:35.970]                           computeRestarts <- base::computeRestarts
[17:39:35.970]                           grepl <- base::grepl
[17:39:35.970]                           restarts <- computeRestarts(cond)
[17:39:35.970]                           for (restart in restarts) {
[17:39:35.970]                             name <- restart$name
[17:39:35.970]                             if (is.null(name)) 
[17:39:35.970]                               next
[17:39:35.970]                             if (!grepl(pattern, name)) 
[17:39:35.970]                               next
[17:39:35.970]                             invokeRestart(restart)
[17:39:35.970]                             muffled <- TRUE
[17:39:35.970]                             break
[17:39:35.970]                           }
[17:39:35.970]                         }
[17:39:35.970]                       }
[17:39:35.970]                       invisible(muffled)
[17:39:35.970]                     }
[17:39:35.970]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.970]                   }
[17:39:35.970]                 }
[17:39:35.970]                 else {
[17:39:35.970]                   if (TRUE) {
[17:39:35.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.970]                     {
[17:39:35.970]                       inherits <- base::inherits
[17:39:35.970]                       invokeRestart <- base::invokeRestart
[17:39:35.970]                       is.null <- base::is.null
[17:39:35.970]                       muffled <- FALSE
[17:39:35.970]                       if (inherits(cond, "message")) {
[17:39:35.970]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.970]                         if (muffled) 
[17:39:35.970]                           invokeRestart("muffleMessage")
[17:39:35.970]                       }
[17:39:35.970]                       else if (inherits(cond, "warning")) {
[17:39:35.970]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.970]                         if (muffled) 
[17:39:35.970]                           invokeRestart("muffleWarning")
[17:39:35.970]                       }
[17:39:35.970]                       else if (inherits(cond, "condition")) {
[17:39:35.970]                         if (!is.null(pattern)) {
[17:39:35.970]                           computeRestarts <- base::computeRestarts
[17:39:35.970]                           grepl <- base::grepl
[17:39:35.970]                           restarts <- computeRestarts(cond)
[17:39:35.970]                           for (restart in restarts) {
[17:39:35.970]                             name <- restart$name
[17:39:35.970]                             if (is.null(name)) 
[17:39:35.970]                               next
[17:39:35.970]                             if (!grepl(pattern, name)) 
[17:39:35.970]                               next
[17:39:35.970]                             invokeRestart(restart)
[17:39:35.970]                             muffled <- TRUE
[17:39:35.970]                             break
[17:39:35.970]                           }
[17:39:35.970]                         }
[17:39:35.970]                       }
[17:39:35.970]                       invisible(muffled)
[17:39:35.970]                     }
[17:39:35.970]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.970]                   }
[17:39:35.970]                 }
[17:39:35.970]             }
[17:39:35.970]         }))
[17:39:35.970]     }, error = function(ex) {
[17:39:35.970]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.970]                 ...future.rng), started = ...future.startTime, 
[17:39:35.970]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.970]             version = "1.8"), class = "FutureResult")
[17:39:35.970]     }, finally = {
[17:39:35.970]         if (!identical(...future.workdir, getwd())) 
[17:39:35.970]             setwd(...future.workdir)
[17:39:35.970]         {
[17:39:35.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.970]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.970]             }
[17:39:35.970]             base::options(...future.oldOptions)
[17:39:35.970]             if (.Platform$OS.type == "windows") {
[17:39:35.970]                 old_names <- names(...future.oldEnvVars)
[17:39:35.970]                 envs <- base::Sys.getenv()
[17:39:35.970]                 names <- names(envs)
[17:39:35.970]                 common <- intersect(names, old_names)
[17:39:35.970]                 added <- setdiff(names, old_names)
[17:39:35.970]                 removed <- setdiff(old_names, names)
[17:39:35.970]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.970]                   envs[common]]
[17:39:35.970]                 NAMES <- toupper(changed)
[17:39:35.970]                 args <- list()
[17:39:35.970]                 for (kk in seq_along(NAMES)) {
[17:39:35.970]                   name <- changed[[kk]]
[17:39:35.970]                   NAME <- NAMES[[kk]]
[17:39:35.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.970]                     next
[17:39:35.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.970]                 }
[17:39:35.970]                 NAMES <- toupper(added)
[17:39:35.970]                 for (kk in seq_along(NAMES)) {
[17:39:35.970]                   name <- added[[kk]]
[17:39:35.970]                   NAME <- NAMES[[kk]]
[17:39:35.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.970]                     next
[17:39:35.970]                   args[[name]] <- ""
[17:39:35.970]                 }
[17:39:35.970]                 NAMES <- toupper(removed)
[17:39:35.970]                 for (kk in seq_along(NAMES)) {
[17:39:35.970]                   name <- removed[[kk]]
[17:39:35.970]                   NAME <- NAMES[[kk]]
[17:39:35.970]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.970]                     next
[17:39:35.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.970]                 }
[17:39:35.970]                 if (length(args) > 0) 
[17:39:35.970]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.970]             }
[17:39:35.970]             else {
[17:39:35.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.970]             }
[17:39:35.970]             {
[17:39:35.970]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.970]                   0L) {
[17:39:35.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.970]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.970]                   base::options(opts)
[17:39:35.970]                 }
[17:39:35.970]                 {
[17:39:35.970]                   {
[17:39:35.970]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.970]                     NULL
[17:39:35.970]                   }
[17:39:35.970]                   options(future.plan = NULL)
[17:39:35.970]                   if (is.na(NA_character_)) 
[17:39:35.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.970]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.970]                     .init = FALSE)
[17:39:35.970]                 }
[17:39:35.970]             }
[17:39:35.970]         }
[17:39:35.970]     })
[17:39:35.970]     if (TRUE) {
[17:39:35.970]         base::sink(type = "output", split = FALSE)
[17:39:35.970]         if (TRUE) {
[17:39:35.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.970]         }
[17:39:35.970]         else {
[17:39:35.970]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.970]         }
[17:39:35.970]         base::close(...future.stdout)
[17:39:35.970]         ...future.stdout <- NULL
[17:39:35.970]     }
[17:39:35.970]     ...future.result$conditions <- ...future.conditions
[17:39:35.970]     ...future.result$finished <- base::Sys.time()
[17:39:35.970]     ...future.result
[17:39:35.970] }
[17:39:35.973] requestCore(): workers = 2
[17:39:35.976] MulticoreFuture started
[17:39:35.976] - Launch lazy future ... done
[17:39:35.977] run() for ‘MulticoreFuture’ ... done
[17:39:35.977] plan(): Setting new future strategy stack:
[17:39:35.977] getGlobalsAndPackages() ...
[17:39:35.978] Searching for globals...
[17:39:35.977] List of future strategies:
[17:39:35.977] 1. sequential:
[17:39:35.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:35.977]    - tweaked: FALSE
[17:39:35.977]    - call: NULL
[17:39:35.978] plan(): nbrOfWorkers() = 1
[17:39:35.979] - globals found: [1] ‘{’
[17:39:35.979] Searching for globals ... DONE
[17:39:35.979] Resolving globals: FALSE
[17:39:35.980] 
[17:39:35.980] 
[17:39:35.980] getGlobalsAndPackages() ... DONE
[17:39:35.980] plan(): Setting new future strategy stack:
[17:39:35.981] run() for ‘Future’ ...
[17:39:35.981] - state: ‘created’
[17:39:35.981] List of future strategies:
[17:39:35.981] 1. multicore:
[17:39:35.981]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:35.981]    - tweaked: FALSE
[17:39:35.981]    - call: plan(strategy)
[17:39:35.981] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:35.986] plan(): nbrOfWorkers() = 2
[17:39:35.986] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:35.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:35.986]   - Field: ‘label’
[17:39:35.986]   - Field: ‘local’
[17:39:35.987]   - Field: ‘owner’
[17:39:35.987]   - Field: ‘envir’
[17:39:35.987]   - Field: ‘workers’
[17:39:35.987]   - Field: ‘packages’
[17:39:35.987]   - Field: ‘gc’
[17:39:35.987]   - Field: ‘job’
[17:39:35.987]   - Field: ‘conditions’
[17:39:35.988]   - Field: ‘expr’
[17:39:35.988]   - Field: ‘uuid’
[17:39:35.988]   - Field: ‘seed’
[17:39:35.988]   - Field: ‘version’
[17:39:35.988]   - Field: ‘result’
[17:39:35.988]   - Field: ‘asynchronous’
[17:39:35.988]   - Field: ‘calls’
[17:39:35.989]   - Field: ‘globals’
[17:39:35.989]   - Field: ‘stdout’
[17:39:35.989]   - Field: ‘earlySignal’
[17:39:35.989]   - Field: ‘lazy’
[17:39:35.989]   - Field: ‘state’
[17:39:35.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:35.989] - Launch lazy future ...
[17:39:35.990] Packages needed by the future expression (n = 0): <none>
[17:39:35.990] Packages needed by future strategies (n = 0): <none>
[17:39:35.991] {
[17:39:35.991]     {
[17:39:35.991]         {
[17:39:35.991]             ...future.startTime <- base::Sys.time()
[17:39:35.991]             {
[17:39:35.991]                 {
[17:39:35.991]                   {
[17:39:35.991]                     {
[17:39:35.991]                       base::local({
[17:39:35.991]                         has_future <- base::requireNamespace("future", 
[17:39:35.991]                           quietly = TRUE)
[17:39:35.991]                         if (has_future) {
[17:39:35.991]                           ns <- base::getNamespace("future")
[17:39:35.991]                           version <- ns[[".package"]][["version"]]
[17:39:35.991]                           if (is.null(version)) 
[17:39:35.991]                             version <- utils::packageVersion("future")
[17:39:35.991]                         }
[17:39:35.991]                         else {
[17:39:35.991]                           version <- NULL
[17:39:35.991]                         }
[17:39:35.991]                         if (!has_future || version < "1.8.0") {
[17:39:35.991]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:35.991]                             "", base::R.version$version.string), 
[17:39:35.991]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:35.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:35.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:35.991]                               "release", "version")], collapse = " "), 
[17:39:35.991]                             hostname = base::Sys.info()[["nodename"]])
[17:39:35.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:35.991]                             info)
[17:39:35.991]                           info <- base::paste(info, collapse = "; ")
[17:39:35.991]                           if (!has_future) {
[17:39:35.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:35.991]                               info)
[17:39:35.991]                           }
[17:39:35.991]                           else {
[17:39:35.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:35.991]                               info, version)
[17:39:35.991]                           }
[17:39:35.991]                           base::stop(msg)
[17:39:35.991]                         }
[17:39:35.991]                       })
[17:39:35.991]                     }
[17:39:35.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:35.991]                     base::options(mc.cores = 1L)
[17:39:35.991]                   }
[17:39:35.991]                   ...future.strategy.old <- future::plan("list")
[17:39:35.991]                   options(future.plan = NULL)
[17:39:35.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:35.991]                 }
[17:39:35.991]                 ...future.workdir <- getwd()
[17:39:35.991]             }
[17:39:35.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:35.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:35.991]         }
[17:39:35.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:35.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:35.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:35.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:35.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:35.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:35.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:35.991]             base::names(...future.oldOptions))
[17:39:35.991]     }
[17:39:35.991]     if (FALSE) {
[17:39:35.991]     }
[17:39:35.991]     else {
[17:39:35.991]         if (TRUE) {
[17:39:35.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:35.991]                 open = "w")
[17:39:35.991]         }
[17:39:35.991]         else {
[17:39:35.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:35.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:35.991]         }
[17:39:35.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:35.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:35.991]             base::sink(type = "output", split = FALSE)
[17:39:35.991]             base::close(...future.stdout)
[17:39:35.991]         }, add = TRUE)
[17:39:35.991]     }
[17:39:35.991]     ...future.frame <- base::sys.nframe()
[17:39:35.991]     ...future.conditions <- base::list()
[17:39:35.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:35.991]     if (FALSE) {
[17:39:35.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:35.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:35.991]     }
[17:39:35.991]     ...future.result <- base::tryCatch({
[17:39:35.991]         base::withCallingHandlers({
[17:39:35.991]             ...future.value <- base::withVisible(base::local({
[17:39:35.991]                 withCallingHandlers({
[17:39:35.991]                   {
[17:39:35.991]                     4
[17:39:35.991]                   }
[17:39:35.991]                 }, immediateCondition = function(cond) {
[17:39:35.991]                   save_rds <- function (object, pathname, ...) 
[17:39:35.991]                   {
[17:39:35.991]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:35.991]                     if (file_test("-f", pathname_tmp)) {
[17:39:35.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.991]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:35.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.991]                         fi_tmp[["mtime"]])
[17:39:35.991]                     }
[17:39:35.991]                     tryCatch({
[17:39:35.991]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:35.991]                     }, error = function(ex) {
[17:39:35.991]                       msg <- conditionMessage(ex)
[17:39:35.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.991]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:35.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.991]                         fi_tmp[["mtime"]], msg)
[17:39:35.991]                       ex$message <- msg
[17:39:35.991]                       stop(ex)
[17:39:35.991]                     })
[17:39:35.991]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:35.991]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:35.991]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:35.991]                       fi_tmp <- file.info(pathname_tmp)
[17:39:35.991]                       fi <- file.info(pathname)
[17:39:35.991]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:35.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:35.991]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:35.991]                         fi[["size"]], fi[["mtime"]])
[17:39:35.991]                       stop(msg)
[17:39:35.991]                     }
[17:39:35.991]                     invisible(pathname)
[17:39:35.991]                   }
[17:39:35.991]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:35.991]                     rootPath = tempdir()) 
[17:39:35.991]                   {
[17:39:35.991]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:35.991]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:35.991]                       tmpdir = path, fileext = ".rds")
[17:39:35.991]                     save_rds(obj, file)
[17:39:35.991]                   }
[17:39:35.991]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:35.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.991]                   {
[17:39:35.991]                     inherits <- base::inherits
[17:39:35.991]                     invokeRestart <- base::invokeRestart
[17:39:35.991]                     is.null <- base::is.null
[17:39:35.991]                     muffled <- FALSE
[17:39:35.991]                     if (inherits(cond, "message")) {
[17:39:35.991]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:35.991]                       if (muffled) 
[17:39:35.991]                         invokeRestart("muffleMessage")
[17:39:35.991]                     }
[17:39:35.991]                     else if (inherits(cond, "warning")) {
[17:39:35.991]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:35.991]                       if (muffled) 
[17:39:35.991]                         invokeRestart("muffleWarning")
[17:39:35.991]                     }
[17:39:35.991]                     else if (inherits(cond, "condition")) {
[17:39:35.991]                       if (!is.null(pattern)) {
[17:39:35.991]                         computeRestarts <- base::computeRestarts
[17:39:35.991]                         grepl <- base::grepl
[17:39:35.991]                         restarts <- computeRestarts(cond)
[17:39:35.991]                         for (restart in restarts) {
[17:39:35.991]                           name <- restart$name
[17:39:35.991]                           if (is.null(name)) 
[17:39:35.991]                             next
[17:39:35.991]                           if (!grepl(pattern, name)) 
[17:39:35.991]                             next
[17:39:35.991]                           invokeRestart(restart)
[17:39:35.991]                           muffled <- TRUE
[17:39:35.991]                           break
[17:39:35.991]                         }
[17:39:35.991]                       }
[17:39:35.991]                     }
[17:39:35.991]                     invisible(muffled)
[17:39:35.991]                   }
[17:39:35.991]                   muffleCondition(cond)
[17:39:35.991]                 })
[17:39:35.991]             }))
[17:39:35.991]             future::FutureResult(value = ...future.value$value, 
[17:39:35.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.991]                   ...future.rng), globalenv = if (FALSE) 
[17:39:35.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:35.991]                     ...future.globalenv.names))
[17:39:35.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:35.991]         }, condition = base::local({
[17:39:35.991]             c <- base::c
[17:39:35.991]             inherits <- base::inherits
[17:39:35.991]             invokeRestart <- base::invokeRestart
[17:39:35.991]             length <- base::length
[17:39:35.991]             list <- base::list
[17:39:35.991]             seq.int <- base::seq.int
[17:39:35.991]             signalCondition <- base::signalCondition
[17:39:35.991]             sys.calls <- base::sys.calls
[17:39:35.991]             `[[` <- base::`[[`
[17:39:35.991]             `+` <- base::`+`
[17:39:35.991]             `<<-` <- base::`<<-`
[17:39:35.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:35.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:35.991]                   3L)]
[17:39:35.991]             }
[17:39:35.991]             function(cond) {
[17:39:35.991]                 is_error <- inherits(cond, "error")
[17:39:35.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:35.991]                   NULL)
[17:39:35.991]                 if (is_error) {
[17:39:35.991]                   sessionInformation <- function() {
[17:39:35.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:35.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:35.991]                       search = base::search(), system = base::Sys.info())
[17:39:35.991]                   }
[17:39:35.991]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:35.991]                     cond$call), session = sessionInformation(), 
[17:39:35.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:35.991]                   signalCondition(cond)
[17:39:35.991]                 }
[17:39:35.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:35.991]                 "immediateCondition"))) {
[17:39:35.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:35.991]                   ...future.conditions[[length(...future.conditions) + 
[17:39:35.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:35.991]                   if (TRUE && !signal) {
[17:39:35.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.991]                     {
[17:39:35.991]                       inherits <- base::inherits
[17:39:35.991]                       invokeRestart <- base::invokeRestart
[17:39:35.991]                       is.null <- base::is.null
[17:39:35.991]                       muffled <- FALSE
[17:39:35.991]                       if (inherits(cond, "message")) {
[17:39:35.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.991]                         if (muffled) 
[17:39:35.991]                           invokeRestart("muffleMessage")
[17:39:35.991]                       }
[17:39:35.991]                       else if (inherits(cond, "warning")) {
[17:39:35.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.991]                         if (muffled) 
[17:39:35.991]                           invokeRestart("muffleWarning")
[17:39:35.991]                       }
[17:39:35.991]                       else if (inherits(cond, "condition")) {
[17:39:35.991]                         if (!is.null(pattern)) {
[17:39:35.991]                           computeRestarts <- base::computeRestarts
[17:39:35.991]                           grepl <- base::grepl
[17:39:35.991]                           restarts <- computeRestarts(cond)
[17:39:35.991]                           for (restart in restarts) {
[17:39:35.991]                             name <- restart$name
[17:39:35.991]                             if (is.null(name)) 
[17:39:35.991]                               next
[17:39:35.991]                             if (!grepl(pattern, name)) 
[17:39:35.991]                               next
[17:39:35.991]                             invokeRestart(restart)
[17:39:35.991]                             muffled <- TRUE
[17:39:35.991]                             break
[17:39:35.991]                           }
[17:39:35.991]                         }
[17:39:35.991]                       }
[17:39:35.991]                       invisible(muffled)
[17:39:35.991]                     }
[17:39:35.991]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.991]                   }
[17:39:35.991]                 }
[17:39:35.991]                 else {
[17:39:35.991]                   if (TRUE) {
[17:39:35.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:35.991]                     {
[17:39:35.991]                       inherits <- base::inherits
[17:39:35.991]                       invokeRestart <- base::invokeRestart
[17:39:35.991]                       is.null <- base::is.null
[17:39:35.991]                       muffled <- FALSE
[17:39:35.991]                       if (inherits(cond, "message")) {
[17:39:35.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:35.991]                         if (muffled) 
[17:39:35.991]                           invokeRestart("muffleMessage")
[17:39:35.991]                       }
[17:39:35.991]                       else if (inherits(cond, "warning")) {
[17:39:35.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:35.991]                         if (muffled) 
[17:39:35.991]                           invokeRestart("muffleWarning")
[17:39:35.991]                       }
[17:39:35.991]                       else if (inherits(cond, "condition")) {
[17:39:35.991]                         if (!is.null(pattern)) {
[17:39:35.991]                           computeRestarts <- base::computeRestarts
[17:39:35.991]                           grepl <- base::grepl
[17:39:35.991]                           restarts <- computeRestarts(cond)
[17:39:35.991]                           for (restart in restarts) {
[17:39:35.991]                             name <- restart$name
[17:39:35.991]                             if (is.null(name)) 
[17:39:35.991]                               next
[17:39:35.991]                             if (!grepl(pattern, name)) 
[17:39:35.991]                               next
[17:39:35.991]                             invokeRestart(restart)
[17:39:35.991]                             muffled <- TRUE
[17:39:35.991]                             break
[17:39:35.991]                           }
[17:39:35.991]                         }
[17:39:35.991]                       }
[17:39:35.991]                       invisible(muffled)
[17:39:35.991]                     }
[17:39:35.991]                     muffleCondition(cond, pattern = "^muffle")
[17:39:35.991]                   }
[17:39:35.991]                 }
[17:39:35.991]             }
[17:39:35.991]         }))
[17:39:35.991]     }, error = function(ex) {
[17:39:35.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:35.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:35.991]                 ...future.rng), started = ...future.startTime, 
[17:39:35.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:35.991]             version = "1.8"), class = "FutureResult")
[17:39:35.991]     }, finally = {
[17:39:35.991]         if (!identical(...future.workdir, getwd())) 
[17:39:35.991]             setwd(...future.workdir)
[17:39:35.991]         {
[17:39:35.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:35.991]                 ...future.oldOptions$nwarnings <- NULL
[17:39:35.991]             }
[17:39:35.991]             base::options(...future.oldOptions)
[17:39:35.991]             if (.Platform$OS.type == "windows") {
[17:39:35.991]                 old_names <- names(...future.oldEnvVars)
[17:39:35.991]                 envs <- base::Sys.getenv()
[17:39:35.991]                 names <- names(envs)
[17:39:35.991]                 common <- intersect(names, old_names)
[17:39:35.991]                 added <- setdiff(names, old_names)
[17:39:35.991]                 removed <- setdiff(old_names, names)
[17:39:35.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:35.991]                   envs[common]]
[17:39:35.991]                 NAMES <- toupper(changed)
[17:39:35.991]                 args <- list()
[17:39:35.991]                 for (kk in seq_along(NAMES)) {
[17:39:35.991]                   name <- changed[[kk]]
[17:39:35.991]                   NAME <- NAMES[[kk]]
[17:39:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.991]                     next
[17:39:35.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.991]                 }
[17:39:35.991]                 NAMES <- toupper(added)
[17:39:35.991]                 for (kk in seq_along(NAMES)) {
[17:39:35.991]                   name <- added[[kk]]
[17:39:35.991]                   NAME <- NAMES[[kk]]
[17:39:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.991]                     next
[17:39:35.991]                   args[[name]] <- ""
[17:39:35.991]                 }
[17:39:35.991]                 NAMES <- toupper(removed)
[17:39:35.991]                 for (kk in seq_along(NAMES)) {
[17:39:35.991]                   name <- removed[[kk]]
[17:39:35.991]                   NAME <- NAMES[[kk]]
[17:39:35.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:35.991]                     next
[17:39:35.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:35.991]                 }
[17:39:35.991]                 if (length(args) > 0) 
[17:39:35.991]                   base::do.call(base::Sys.setenv, args = args)
[17:39:35.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:35.991]             }
[17:39:35.991]             else {
[17:39:35.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:35.991]             }
[17:39:35.991]             {
[17:39:35.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:35.991]                   0L) {
[17:39:35.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:35.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:35.991]                   base::options(opts)
[17:39:35.991]                 }
[17:39:35.991]                 {
[17:39:35.991]                   {
[17:39:35.991]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:35.991]                     NULL
[17:39:35.991]                   }
[17:39:35.991]                   options(future.plan = NULL)
[17:39:35.991]                   if (is.na(NA_character_)) 
[17:39:35.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:35.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:35.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:35.991]                     .init = FALSE)
[17:39:35.991]                 }
[17:39:35.991]             }
[17:39:35.991]         }
[17:39:35.991]     })
[17:39:35.991]     if (TRUE) {
[17:39:35.991]         base::sink(type = "output", split = FALSE)
[17:39:35.991]         if (TRUE) {
[17:39:35.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:35.991]         }
[17:39:35.991]         else {
[17:39:35.991]             ...future.result["stdout"] <- base::list(NULL)
[17:39:35.991]         }
[17:39:35.991]         base::close(...future.stdout)
[17:39:35.991]         ...future.stdout <- NULL
[17:39:35.991]     }
[17:39:35.991]     ...future.result$conditions <- ...future.conditions
[17:39:35.991]     ...future.result$finished <- base::Sys.time()
[17:39:35.991]     ...future.result
[17:39:35.991] }
[17:39:35.994] requestCore(): workers = 2
[17:39:35.994] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:36.005] result() for MulticoreFuture ...
[17:39:36.006] result() for MulticoreFuture ...
[17:39:36.006] result() for MulticoreFuture ... done
[17:39:36.006] result() for MulticoreFuture ... done
[17:39:36.006] result() for MulticoreFuture ...
[17:39:36.006] result() for MulticoreFuture ... done
[17:39:36.009] MulticoreFuture started
[17:39:36.010] - Launch lazy future ... done
[17:39:36.010] run() for ‘MulticoreFuture’ ... done
[17:39:36.010] plan(): Setting new future strategy stack:
<environment: 0x55adf0ee8278> 
[17:39:36.011] List of future strategies:
[17:39:36.011] 1. sequential:
[17:39:36.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:36.011]    - tweaked: FALSE
[17:39:36.011]    - call: NULL
[17:39:36.012] plan(): nbrOfWorkers() = 1
<environment: 0x55adf1d0e570> 
[17:39:36.015] plan(): Setting new future strategy stack:
[17:39:36.015] List of future strategies:
[17:39:36.015] 1. multicore:
[17:39:36.015]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:36.015]    - tweaked: FALSE
[17:39:36.015]    - call: plan(strategy)
[17:39:36.020] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.022] resolve() on environment ...
[17:39:36.022]  recursive: 0
[17:39:36.023]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.023] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.023] - nx: 4
[17:39:36.024] - relay: TRUE
[17:39:36.024] - stdout: TRUE
[17:39:36.024] - signal: TRUE
[17:39:36.024] - resignal: FALSE
[17:39:36.024] - force: TRUE
[17:39:36.024] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.024] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.024]  - until=2
[17:39:36.025]  - relaying element #2
[17:39:36.025] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.025] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.025] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.025]  length: 3 (resolved future 1)
[17:39:36.025] Future #2
[17:39:36.025] result() for MulticoreFuture ...
[17:39:36.026] result() for MulticoreFuture ... done
[17:39:36.026] result() for MulticoreFuture ...
[17:39:36.026] result() for MulticoreFuture ... done
[17:39:36.026] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:36.026] - nx: 4
[17:39:36.026] - relay: TRUE
[17:39:36.026] - stdout: TRUE
[17:39:36.027] - signal: TRUE
[17:39:36.027] - resignal: FALSE
[17:39:36.027] - force: TRUE
[17:39:36.027] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.027] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.027]  - until=2
[17:39:36.027]  - relaying element #2
[17:39:36.027] result() for MulticoreFuture ...
[17:39:36.028] result() for MulticoreFuture ... done
[17:39:36.028] result() for MulticoreFuture ...
[17:39:36.028] result() for MulticoreFuture ... done
[17:39:36.028] result() for MulticoreFuture ...
[17:39:36.028] result() for MulticoreFuture ... done
[17:39:36.028] result() for MulticoreFuture ...
[17:39:36.028] result() for MulticoreFuture ... done
[17:39:36.029] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.029] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.029] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:36.029]  length: 2 (resolved future 2)
[17:39:36.029] Future #3
[17:39:36.029] result() for MulticoreFuture ...
[17:39:36.030] result() for MulticoreFuture ...
[17:39:36.031] result() for MulticoreFuture ... done
[17:39:36.031] result() for MulticoreFuture ... done
[17:39:36.031] result() for MulticoreFuture ...
[17:39:36.031] result() for MulticoreFuture ... done
[17:39:36.031] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:36.031] - nx: 4
[17:39:36.032] - relay: TRUE
[17:39:36.032] - stdout: TRUE
[17:39:36.032] - signal: TRUE
[17:39:36.032] - resignal: FALSE
[17:39:36.032] - force: TRUE
[17:39:36.032] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.033] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.033]  - until=3
[17:39:36.033]  - relaying element #3
[17:39:36.033] result() for MulticoreFuture ...
[17:39:36.033] result() for MulticoreFuture ... done
[17:39:36.033] result() for MulticoreFuture ...
[17:39:36.034] result() for MulticoreFuture ... done
[17:39:36.034] result() for MulticoreFuture ...
[17:39:36.034] result() for MulticoreFuture ... done
[17:39:36.034] result() for MulticoreFuture ...
[17:39:36.034] result() for MulticoreFuture ... done
[17:39:36.034] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.035] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.035] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:36.035]  length: 1 (resolved future 3)
[17:39:36.035] Future #4
[17:39:36.036] result() for MulticoreFuture ...
[17:39:36.036] result() for MulticoreFuture ...
[17:39:36.036] result() for MulticoreFuture ... done
[17:39:36.037] result() for MulticoreFuture ... done
[17:39:36.037] result() for MulticoreFuture ...
[17:39:36.037] result() for MulticoreFuture ... done
[17:39:36.037] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:36.037] - nx: 4
[17:39:36.037] - relay: TRUE
[17:39:36.037] - stdout: TRUE
[17:39:36.037] - signal: TRUE
[17:39:36.038] - resignal: FALSE
[17:39:36.038] - force: TRUE
[17:39:36.038] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.038] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.038]  - until=4
[17:39:36.038]  - relaying element #4
[17:39:36.038] result() for MulticoreFuture ...
[17:39:36.038] result() for MulticoreFuture ... done
[17:39:36.038] result() for MulticoreFuture ...
[17:39:36.038] result() for MulticoreFuture ... done
[17:39:36.039] result() for MulticoreFuture ...
[17:39:36.039] result() for MulticoreFuture ... done
[17:39:36.039] result() for MulticoreFuture ...
[17:39:36.039] result() for MulticoreFuture ... done
[17:39:36.039] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.039] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.039] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:36.039]  length: 0 (resolved future 4)
[17:39:36.040] Relaying remaining futures
[17:39:36.040] signalConditionsASAP(NULL, pos=0) ...
[17:39:36.040] - nx: 4
[17:39:36.040] - relay: TRUE
[17:39:36.040] - stdout: TRUE
[17:39:36.040] - signal: TRUE
[17:39:36.040] - resignal: FALSE
[17:39:36.040] - force: TRUE
[17:39:36.040] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.040] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:36.041] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.041] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.041] signalConditionsASAP(NULL, pos=0) ... done
[17:39:36.041] resolve() on environment ... DONE
[17:39:36.041] result() for MulticoreFuture ...
[17:39:36.041] result() for MulticoreFuture ... done
[17:39:36.041] result() for MulticoreFuture ...
[17:39:36.041] result() for MulticoreFuture ... done
[17:39:36.041] result() for MulticoreFuture ...
[17:39:36.042] result() for MulticoreFuture ... done
[17:39:36.042] result() for MulticoreFuture ...
[17:39:36.042] result() for MulticoreFuture ... done
[17:39:36.042] result() for MulticoreFuture ...
[17:39:36.042] result() for MulticoreFuture ... done
[17:39:36.042] result() for MulticoreFuture ...
[17:39:36.042] result() for MulticoreFuture ... done
<environment: 0x55adf1de0a80> 
Dimensions: c(2, 1, 3, 1)
[17:39:36.046] getGlobalsAndPackages() ...
[17:39:36.046] Searching for globals...
[17:39:36.047] 
[17:39:36.047] Searching for globals ... DONE
[17:39:36.047] - globals: [0] <none>
[17:39:36.047] getGlobalsAndPackages() ... DONE
[17:39:36.048] run() for ‘Future’ ...
[17:39:36.048] - state: ‘created’
[17:39:36.048] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.052] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:36.053]   - Field: ‘label’
[17:39:36.053]   - Field: ‘local’
[17:39:36.053]   - Field: ‘owner’
[17:39:36.053]   - Field: ‘envir’
[17:39:36.053]   - Field: ‘workers’
[17:39:36.053]   - Field: ‘packages’
[17:39:36.054]   - Field: ‘gc’
[17:39:36.054]   - Field: ‘job’
[17:39:36.054]   - Field: ‘conditions’
[17:39:36.054]   - Field: ‘expr’
[17:39:36.054]   - Field: ‘uuid’
[17:39:36.054]   - Field: ‘seed’
[17:39:36.054]   - Field: ‘version’
[17:39:36.054]   - Field: ‘result’
[17:39:36.054]   - Field: ‘asynchronous’
[17:39:36.055]   - Field: ‘calls’
[17:39:36.055]   - Field: ‘globals’
[17:39:36.055]   - Field: ‘stdout’
[17:39:36.055]   - Field: ‘earlySignal’
[17:39:36.055]   - Field: ‘lazy’
[17:39:36.055]   - Field: ‘state’
[17:39:36.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:36.055] - Launch lazy future ...
[17:39:36.056] Packages needed by the future expression (n = 0): <none>
[17:39:36.056] Packages needed by future strategies (n = 0): <none>
[17:39:36.056] {
[17:39:36.056]     {
[17:39:36.056]         {
[17:39:36.056]             ...future.startTime <- base::Sys.time()
[17:39:36.056]             {
[17:39:36.056]                 {
[17:39:36.056]                   {
[17:39:36.056]                     {
[17:39:36.056]                       base::local({
[17:39:36.056]                         has_future <- base::requireNamespace("future", 
[17:39:36.056]                           quietly = TRUE)
[17:39:36.056]                         if (has_future) {
[17:39:36.056]                           ns <- base::getNamespace("future")
[17:39:36.056]                           version <- ns[[".package"]][["version"]]
[17:39:36.056]                           if (is.null(version)) 
[17:39:36.056]                             version <- utils::packageVersion("future")
[17:39:36.056]                         }
[17:39:36.056]                         else {
[17:39:36.056]                           version <- NULL
[17:39:36.056]                         }
[17:39:36.056]                         if (!has_future || version < "1.8.0") {
[17:39:36.056]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.056]                             "", base::R.version$version.string), 
[17:39:36.056]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.056]                               "release", "version")], collapse = " "), 
[17:39:36.056]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.056]                             info)
[17:39:36.056]                           info <- base::paste(info, collapse = "; ")
[17:39:36.056]                           if (!has_future) {
[17:39:36.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.056]                               info)
[17:39:36.056]                           }
[17:39:36.056]                           else {
[17:39:36.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.056]                               info, version)
[17:39:36.056]                           }
[17:39:36.056]                           base::stop(msg)
[17:39:36.056]                         }
[17:39:36.056]                       })
[17:39:36.056]                     }
[17:39:36.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.056]                     base::options(mc.cores = 1L)
[17:39:36.056]                   }
[17:39:36.056]                   ...future.strategy.old <- future::plan("list")
[17:39:36.056]                   options(future.plan = NULL)
[17:39:36.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.056]                 }
[17:39:36.056]                 ...future.workdir <- getwd()
[17:39:36.056]             }
[17:39:36.056]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.056]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.056]         }
[17:39:36.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.056]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.056]             base::names(...future.oldOptions))
[17:39:36.056]     }
[17:39:36.056]     if (FALSE) {
[17:39:36.056]     }
[17:39:36.056]     else {
[17:39:36.056]         if (TRUE) {
[17:39:36.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.056]                 open = "w")
[17:39:36.056]         }
[17:39:36.056]         else {
[17:39:36.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.056]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.056]         }
[17:39:36.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.056]             base::sink(type = "output", split = FALSE)
[17:39:36.056]             base::close(...future.stdout)
[17:39:36.056]         }, add = TRUE)
[17:39:36.056]     }
[17:39:36.056]     ...future.frame <- base::sys.nframe()
[17:39:36.056]     ...future.conditions <- base::list()
[17:39:36.056]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.056]     if (FALSE) {
[17:39:36.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.056]     }
[17:39:36.056]     ...future.result <- base::tryCatch({
[17:39:36.056]         base::withCallingHandlers({
[17:39:36.056]             ...future.value <- base::withVisible(base::local({
[17:39:36.056]                 withCallingHandlers({
[17:39:36.056]                   2
[17:39:36.056]                 }, immediateCondition = function(cond) {
[17:39:36.056]                   save_rds <- function (object, pathname, ...) 
[17:39:36.056]                   {
[17:39:36.056]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:36.056]                     if (file_test("-f", pathname_tmp)) {
[17:39:36.056]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.056]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:36.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.056]                         fi_tmp[["mtime"]])
[17:39:36.056]                     }
[17:39:36.056]                     tryCatch({
[17:39:36.056]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:36.056]                     }, error = function(ex) {
[17:39:36.056]                       msg <- conditionMessage(ex)
[17:39:36.056]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.056]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:36.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.056]                         fi_tmp[["mtime"]], msg)
[17:39:36.056]                       ex$message <- msg
[17:39:36.056]                       stop(ex)
[17:39:36.056]                     })
[17:39:36.056]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:36.056]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:36.056]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:36.056]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.056]                       fi <- file.info(pathname)
[17:39:36.056]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:36.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.056]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:36.056]                         fi[["size"]], fi[["mtime"]])
[17:39:36.056]                       stop(msg)
[17:39:36.056]                     }
[17:39:36.056]                     invisible(pathname)
[17:39:36.056]                   }
[17:39:36.056]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:36.056]                     rootPath = tempdir()) 
[17:39:36.056]                   {
[17:39:36.056]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:36.056]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:36.056]                       tmpdir = path, fileext = ".rds")
[17:39:36.056]                     save_rds(obj, file)
[17:39:36.056]                   }
[17:39:36.056]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:36.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.056]                   {
[17:39:36.056]                     inherits <- base::inherits
[17:39:36.056]                     invokeRestart <- base::invokeRestart
[17:39:36.056]                     is.null <- base::is.null
[17:39:36.056]                     muffled <- FALSE
[17:39:36.056]                     if (inherits(cond, "message")) {
[17:39:36.056]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.056]                       if (muffled) 
[17:39:36.056]                         invokeRestart("muffleMessage")
[17:39:36.056]                     }
[17:39:36.056]                     else if (inherits(cond, "warning")) {
[17:39:36.056]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.056]                       if (muffled) 
[17:39:36.056]                         invokeRestart("muffleWarning")
[17:39:36.056]                     }
[17:39:36.056]                     else if (inherits(cond, "condition")) {
[17:39:36.056]                       if (!is.null(pattern)) {
[17:39:36.056]                         computeRestarts <- base::computeRestarts
[17:39:36.056]                         grepl <- base::grepl
[17:39:36.056]                         restarts <- computeRestarts(cond)
[17:39:36.056]                         for (restart in restarts) {
[17:39:36.056]                           name <- restart$name
[17:39:36.056]                           if (is.null(name)) 
[17:39:36.056]                             next
[17:39:36.056]                           if (!grepl(pattern, name)) 
[17:39:36.056]                             next
[17:39:36.056]                           invokeRestart(restart)
[17:39:36.056]                           muffled <- TRUE
[17:39:36.056]                           break
[17:39:36.056]                         }
[17:39:36.056]                       }
[17:39:36.056]                     }
[17:39:36.056]                     invisible(muffled)
[17:39:36.056]                   }
[17:39:36.056]                   muffleCondition(cond)
[17:39:36.056]                 })
[17:39:36.056]             }))
[17:39:36.056]             future::FutureResult(value = ...future.value$value, 
[17:39:36.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.056]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.056]                     ...future.globalenv.names))
[17:39:36.056]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.056]         }, condition = base::local({
[17:39:36.056]             c <- base::c
[17:39:36.056]             inherits <- base::inherits
[17:39:36.056]             invokeRestart <- base::invokeRestart
[17:39:36.056]             length <- base::length
[17:39:36.056]             list <- base::list
[17:39:36.056]             seq.int <- base::seq.int
[17:39:36.056]             signalCondition <- base::signalCondition
[17:39:36.056]             sys.calls <- base::sys.calls
[17:39:36.056]             `[[` <- base::`[[`
[17:39:36.056]             `+` <- base::`+`
[17:39:36.056]             `<<-` <- base::`<<-`
[17:39:36.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.056]                   3L)]
[17:39:36.056]             }
[17:39:36.056]             function(cond) {
[17:39:36.056]                 is_error <- inherits(cond, "error")
[17:39:36.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.056]                   NULL)
[17:39:36.056]                 if (is_error) {
[17:39:36.056]                   sessionInformation <- function() {
[17:39:36.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.056]                       search = base::search(), system = base::Sys.info())
[17:39:36.056]                   }
[17:39:36.056]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.056]                     cond$call), session = sessionInformation(), 
[17:39:36.056]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.056]                   signalCondition(cond)
[17:39:36.056]                 }
[17:39:36.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.056]                 "immediateCondition"))) {
[17:39:36.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.056]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.056]                   if (TRUE && !signal) {
[17:39:36.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.056]                     {
[17:39:36.056]                       inherits <- base::inherits
[17:39:36.056]                       invokeRestart <- base::invokeRestart
[17:39:36.056]                       is.null <- base::is.null
[17:39:36.056]                       muffled <- FALSE
[17:39:36.056]                       if (inherits(cond, "message")) {
[17:39:36.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.056]                         if (muffled) 
[17:39:36.056]                           invokeRestart("muffleMessage")
[17:39:36.056]                       }
[17:39:36.056]                       else if (inherits(cond, "warning")) {
[17:39:36.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.056]                         if (muffled) 
[17:39:36.056]                           invokeRestart("muffleWarning")
[17:39:36.056]                       }
[17:39:36.056]                       else if (inherits(cond, "condition")) {
[17:39:36.056]                         if (!is.null(pattern)) {
[17:39:36.056]                           computeRestarts <- base::computeRestarts
[17:39:36.056]                           grepl <- base::grepl
[17:39:36.056]                           restarts <- computeRestarts(cond)
[17:39:36.056]                           for (restart in restarts) {
[17:39:36.056]                             name <- restart$name
[17:39:36.056]                             if (is.null(name)) 
[17:39:36.056]                               next
[17:39:36.056]                             if (!grepl(pattern, name)) 
[17:39:36.056]                               next
[17:39:36.056]                             invokeRestart(restart)
[17:39:36.056]                             muffled <- TRUE
[17:39:36.056]                             break
[17:39:36.056]                           }
[17:39:36.056]                         }
[17:39:36.056]                       }
[17:39:36.056]                       invisible(muffled)
[17:39:36.056]                     }
[17:39:36.056]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.056]                   }
[17:39:36.056]                 }
[17:39:36.056]                 else {
[17:39:36.056]                   if (TRUE) {
[17:39:36.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.056]                     {
[17:39:36.056]                       inherits <- base::inherits
[17:39:36.056]                       invokeRestart <- base::invokeRestart
[17:39:36.056]                       is.null <- base::is.null
[17:39:36.056]                       muffled <- FALSE
[17:39:36.056]                       if (inherits(cond, "message")) {
[17:39:36.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.056]                         if (muffled) 
[17:39:36.056]                           invokeRestart("muffleMessage")
[17:39:36.056]                       }
[17:39:36.056]                       else if (inherits(cond, "warning")) {
[17:39:36.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.056]                         if (muffled) 
[17:39:36.056]                           invokeRestart("muffleWarning")
[17:39:36.056]                       }
[17:39:36.056]                       else if (inherits(cond, "condition")) {
[17:39:36.056]                         if (!is.null(pattern)) {
[17:39:36.056]                           computeRestarts <- base::computeRestarts
[17:39:36.056]                           grepl <- base::grepl
[17:39:36.056]                           restarts <- computeRestarts(cond)
[17:39:36.056]                           for (restart in restarts) {
[17:39:36.056]                             name <- restart$name
[17:39:36.056]                             if (is.null(name)) 
[17:39:36.056]                               next
[17:39:36.056]                             if (!grepl(pattern, name)) 
[17:39:36.056]                               next
[17:39:36.056]                             invokeRestart(restart)
[17:39:36.056]                             muffled <- TRUE
[17:39:36.056]                             break
[17:39:36.056]                           }
[17:39:36.056]                         }
[17:39:36.056]                       }
[17:39:36.056]                       invisible(muffled)
[17:39:36.056]                     }
[17:39:36.056]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.056]                   }
[17:39:36.056]                 }
[17:39:36.056]             }
[17:39:36.056]         }))
[17:39:36.056]     }, error = function(ex) {
[17:39:36.056]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.056]                 ...future.rng), started = ...future.startTime, 
[17:39:36.056]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.056]             version = "1.8"), class = "FutureResult")
[17:39:36.056]     }, finally = {
[17:39:36.056]         if (!identical(...future.workdir, getwd())) 
[17:39:36.056]             setwd(...future.workdir)
[17:39:36.056]         {
[17:39:36.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.056]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.056]             }
[17:39:36.056]             base::options(...future.oldOptions)
[17:39:36.056]             if (.Platform$OS.type == "windows") {
[17:39:36.056]                 old_names <- names(...future.oldEnvVars)
[17:39:36.056]                 envs <- base::Sys.getenv()
[17:39:36.056]                 names <- names(envs)
[17:39:36.056]                 common <- intersect(names, old_names)
[17:39:36.056]                 added <- setdiff(names, old_names)
[17:39:36.056]                 removed <- setdiff(old_names, names)
[17:39:36.056]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.056]                   envs[common]]
[17:39:36.056]                 NAMES <- toupper(changed)
[17:39:36.056]                 args <- list()
[17:39:36.056]                 for (kk in seq_along(NAMES)) {
[17:39:36.056]                   name <- changed[[kk]]
[17:39:36.056]                   NAME <- NAMES[[kk]]
[17:39:36.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.056]                     next
[17:39:36.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.056]                 }
[17:39:36.056]                 NAMES <- toupper(added)
[17:39:36.056]                 for (kk in seq_along(NAMES)) {
[17:39:36.056]                   name <- added[[kk]]
[17:39:36.056]                   NAME <- NAMES[[kk]]
[17:39:36.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.056]                     next
[17:39:36.056]                   args[[name]] <- ""
[17:39:36.056]                 }
[17:39:36.056]                 NAMES <- toupper(removed)
[17:39:36.056]                 for (kk in seq_along(NAMES)) {
[17:39:36.056]                   name <- removed[[kk]]
[17:39:36.056]                   NAME <- NAMES[[kk]]
[17:39:36.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.056]                     next
[17:39:36.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.056]                 }
[17:39:36.056]                 if (length(args) > 0) 
[17:39:36.056]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.056]             }
[17:39:36.056]             else {
[17:39:36.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.056]             }
[17:39:36.056]             {
[17:39:36.056]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.056]                   0L) {
[17:39:36.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.056]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.056]                   base::options(opts)
[17:39:36.056]                 }
[17:39:36.056]                 {
[17:39:36.056]                   {
[17:39:36.056]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.056]                     NULL
[17:39:36.056]                   }
[17:39:36.056]                   options(future.plan = NULL)
[17:39:36.056]                   if (is.na(NA_character_)) 
[17:39:36.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.056]                     .init = FALSE)
[17:39:36.056]                 }
[17:39:36.056]             }
[17:39:36.056]         }
[17:39:36.056]     })
[17:39:36.056]     if (TRUE) {
[17:39:36.056]         base::sink(type = "output", split = FALSE)
[17:39:36.056]         if (TRUE) {
[17:39:36.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.056]         }
[17:39:36.056]         else {
[17:39:36.056]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.056]         }
[17:39:36.056]         base::close(...future.stdout)
[17:39:36.056]         ...future.stdout <- NULL
[17:39:36.056]     }
[17:39:36.056]     ...future.result$conditions <- ...future.conditions
[17:39:36.056]     ...future.result$finished <- base::Sys.time()
[17:39:36.056]     ...future.result
[17:39:36.056] }
[17:39:36.059] requestCore(): workers = 2
[17:39:36.061] MulticoreFuture started
[17:39:36.061] - Launch lazy future ... done
[17:39:36.062] run() for ‘MulticoreFuture’ ... done
[17:39:36.062] getGlobalsAndPackages() ...
[17:39:36.062] Searching for globals...
[17:39:36.062] plan(): Setting new future strategy stack:
[17:39:36.063] 
[17:39:36.062] List of future strategies:
[17:39:36.062] 1. sequential:
[17:39:36.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:36.062]    - tweaked: FALSE
[17:39:36.062]    - call: NULL
[17:39:36.063] Searching for globals ... DONE
[17:39:36.063] - globals: [0] <none>
[17:39:36.063] plan(): nbrOfWorkers() = 1
[17:39:36.063] getGlobalsAndPackages() ... DONE
[17:39:36.064] run() for ‘Future’ ...
[17:39:36.064] - state: ‘created’
[17:39:36.064] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.065] plan(): Setting new future strategy stack:
[17:39:36.065] List of future strategies:
[17:39:36.065] 1. multicore:
[17:39:36.065]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:36.065]    - tweaked: FALSE
[17:39:36.065]    - call: plan(strategy)
[17:39:36.070] plan(): nbrOfWorkers() = 2
[17:39:36.070] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:36.070]   - Field: ‘label’
[17:39:36.070]   - Field: ‘local’
[17:39:36.071]   - Field: ‘owner’
[17:39:36.071]   - Field: ‘envir’
[17:39:36.071]   - Field: ‘workers’
[17:39:36.071]   - Field: ‘packages’
[17:39:36.071]   - Field: ‘gc’
[17:39:36.071]   - Field: ‘job’
[17:39:36.072]   - Field: ‘conditions’
[17:39:36.072]   - Field: ‘expr’
[17:39:36.072]   - Field: ‘uuid’
[17:39:36.072]   - Field: ‘seed’
[17:39:36.072]   - Field: ‘version’
[17:39:36.072]   - Field: ‘result’
[17:39:36.072]   - Field: ‘asynchronous’
[17:39:36.073]   - Field: ‘calls’
[17:39:36.073]   - Field: ‘globals’
[17:39:36.073]   - Field: ‘stdout’
[17:39:36.073]   - Field: ‘earlySignal’
[17:39:36.073]   - Field: ‘lazy’
[17:39:36.073]   - Field: ‘state’
[17:39:36.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:36.074] - Launch lazy future ...
[17:39:36.074] Packages needed by the future expression (n = 0): <none>
[17:39:36.074] Packages needed by future strategies (n = 0): <none>
[17:39:36.075] {
[17:39:36.075]     {
[17:39:36.075]         {
[17:39:36.075]             ...future.startTime <- base::Sys.time()
[17:39:36.075]             {
[17:39:36.075]                 {
[17:39:36.075]                   {
[17:39:36.075]                     {
[17:39:36.075]                       base::local({
[17:39:36.075]                         has_future <- base::requireNamespace("future", 
[17:39:36.075]                           quietly = TRUE)
[17:39:36.075]                         if (has_future) {
[17:39:36.075]                           ns <- base::getNamespace("future")
[17:39:36.075]                           version <- ns[[".package"]][["version"]]
[17:39:36.075]                           if (is.null(version)) 
[17:39:36.075]                             version <- utils::packageVersion("future")
[17:39:36.075]                         }
[17:39:36.075]                         else {
[17:39:36.075]                           version <- NULL
[17:39:36.075]                         }
[17:39:36.075]                         if (!has_future || version < "1.8.0") {
[17:39:36.075]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.075]                             "", base::R.version$version.string), 
[17:39:36.075]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.075]                               "release", "version")], collapse = " "), 
[17:39:36.075]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.075]                             info)
[17:39:36.075]                           info <- base::paste(info, collapse = "; ")
[17:39:36.075]                           if (!has_future) {
[17:39:36.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.075]                               info)
[17:39:36.075]                           }
[17:39:36.075]                           else {
[17:39:36.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.075]                               info, version)
[17:39:36.075]                           }
[17:39:36.075]                           base::stop(msg)
[17:39:36.075]                         }
[17:39:36.075]                       })
[17:39:36.075]                     }
[17:39:36.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.075]                     base::options(mc.cores = 1L)
[17:39:36.075]                   }
[17:39:36.075]                   ...future.strategy.old <- future::plan("list")
[17:39:36.075]                   options(future.plan = NULL)
[17:39:36.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.075]                 }
[17:39:36.075]                 ...future.workdir <- getwd()
[17:39:36.075]             }
[17:39:36.075]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.075]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.075]         }
[17:39:36.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.075]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.075]             base::names(...future.oldOptions))
[17:39:36.075]     }
[17:39:36.075]     if (FALSE) {
[17:39:36.075]     }
[17:39:36.075]     else {
[17:39:36.075]         if (TRUE) {
[17:39:36.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.075]                 open = "w")
[17:39:36.075]         }
[17:39:36.075]         else {
[17:39:36.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.075]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.075]         }
[17:39:36.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.075]             base::sink(type = "output", split = FALSE)
[17:39:36.075]             base::close(...future.stdout)
[17:39:36.075]         }, add = TRUE)
[17:39:36.075]     }
[17:39:36.075]     ...future.frame <- base::sys.nframe()
[17:39:36.075]     ...future.conditions <- base::list()
[17:39:36.075]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.075]     if (FALSE) {
[17:39:36.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.075]     }
[17:39:36.075]     ...future.result <- base::tryCatch({
[17:39:36.075]         base::withCallingHandlers({
[17:39:36.075]             ...future.value <- base::withVisible(base::local({
[17:39:36.075]                 withCallingHandlers({
[17:39:36.075]                   NULL
[17:39:36.075]                 }, immediateCondition = function(cond) {
[17:39:36.075]                   save_rds <- function (object, pathname, ...) 
[17:39:36.075]                   {
[17:39:36.075]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:36.075]                     if (file_test("-f", pathname_tmp)) {
[17:39:36.075]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.075]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:36.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.075]                         fi_tmp[["mtime"]])
[17:39:36.075]                     }
[17:39:36.075]                     tryCatch({
[17:39:36.075]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:36.075]                     }, error = function(ex) {
[17:39:36.075]                       msg <- conditionMessage(ex)
[17:39:36.075]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.075]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:36.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.075]                         fi_tmp[["mtime"]], msg)
[17:39:36.075]                       ex$message <- msg
[17:39:36.075]                       stop(ex)
[17:39:36.075]                     })
[17:39:36.075]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:36.075]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:36.075]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:36.075]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.075]                       fi <- file.info(pathname)
[17:39:36.075]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:36.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.075]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:36.075]                         fi[["size"]], fi[["mtime"]])
[17:39:36.075]                       stop(msg)
[17:39:36.075]                     }
[17:39:36.075]                     invisible(pathname)
[17:39:36.075]                   }
[17:39:36.075]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:36.075]                     rootPath = tempdir()) 
[17:39:36.075]                   {
[17:39:36.075]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:36.075]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:36.075]                       tmpdir = path, fileext = ".rds")
[17:39:36.075]                     save_rds(obj, file)
[17:39:36.075]                   }
[17:39:36.075]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:36.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.075]                   {
[17:39:36.075]                     inherits <- base::inherits
[17:39:36.075]                     invokeRestart <- base::invokeRestart
[17:39:36.075]                     is.null <- base::is.null
[17:39:36.075]                     muffled <- FALSE
[17:39:36.075]                     if (inherits(cond, "message")) {
[17:39:36.075]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.075]                       if (muffled) 
[17:39:36.075]                         invokeRestart("muffleMessage")
[17:39:36.075]                     }
[17:39:36.075]                     else if (inherits(cond, "warning")) {
[17:39:36.075]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.075]                       if (muffled) 
[17:39:36.075]                         invokeRestart("muffleWarning")
[17:39:36.075]                     }
[17:39:36.075]                     else if (inherits(cond, "condition")) {
[17:39:36.075]                       if (!is.null(pattern)) {
[17:39:36.075]                         computeRestarts <- base::computeRestarts
[17:39:36.075]                         grepl <- base::grepl
[17:39:36.075]                         restarts <- computeRestarts(cond)
[17:39:36.075]                         for (restart in restarts) {
[17:39:36.075]                           name <- restart$name
[17:39:36.075]                           if (is.null(name)) 
[17:39:36.075]                             next
[17:39:36.075]                           if (!grepl(pattern, name)) 
[17:39:36.075]                             next
[17:39:36.075]                           invokeRestart(restart)
[17:39:36.075]                           muffled <- TRUE
[17:39:36.075]                           break
[17:39:36.075]                         }
[17:39:36.075]                       }
[17:39:36.075]                     }
[17:39:36.075]                     invisible(muffled)
[17:39:36.075]                   }
[17:39:36.075]                   muffleCondition(cond)
[17:39:36.075]                 })
[17:39:36.075]             }))
[17:39:36.075]             future::FutureResult(value = ...future.value$value, 
[17:39:36.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.075]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.075]                     ...future.globalenv.names))
[17:39:36.075]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.075]         }, condition = base::local({
[17:39:36.075]             c <- base::c
[17:39:36.075]             inherits <- base::inherits
[17:39:36.075]             invokeRestart <- base::invokeRestart
[17:39:36.075]             length <- base::length
[17:39:36.075]             list <- base::list
[17:39:36.075]             seq.int <- base::seq.int
[17:39:36.075]             signalCondition <- base::signalCondition
[17:39:36.075]             sys.calls <- base::sys.calls
[17:39:36.075]             `[[` <- base::`[[`
[17:39:36.075]             `+` <- base::`+`
[17:39:36.075]             `<<-` <- base::`<<-`
[17:39:36.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.075]                   3L)]
[17:39:36.075]             }
[17:39:36.075]             function(cond) {
[17:39:36.075]                 is_error <- inherits(cond, "error")
[17:39:36.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.075]                   NULL)
[17:39:36.075]                 if (is_error) {
[17:39:36.075]                   sessionInformation <- function() {
[17:39:36.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.075]                       search = base::search(), system = base::Sys.info())
[17:39:36.075]                   }
[17:39:36.075]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.075]                     cond$call), session = sessionInformation(), 
[17:39:36.075]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.075]                   signalCondition(cond)
[17:39:36.075]                 }
[17:39:36.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.075]                 "immediateCondition"))) {
[17:39:36.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.075]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.075]                   if (TRUE && !signal) {
[17:39:36.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.075]                     {
[17:39:36.075]                       inherits <- base::inherits
[17:39:36.075]                       invokeRestart <- base::invokeRestart
[17:39:36.075]                       is.null <- base::is.null
[17:39:36.075]                       muffled <- FALSE
[17:39:36.075]                       if (inherits(cond, "message")) {
[17:39:36.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.075]                         if (muffled) 
[17:39:36.075]                           invokeRestart("muffleMessage")
[17:39:36.075]                       }
[17:39:36.075]                       else if (inherits(cond, "warning")) {
[17:39:36.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.075]                         if (muffled) 
[17:39:36.075]                           invokeRestart("muffleWarning")
[17:39:36.075]                       }
[17:39:36.075]                       else if (inherits(cond, "condition")) {
[17:39:36.075]                         if (!is.null(pattern)) {
[17:39:36.075]                           computeRestarts <- base::computeRestarts
[17:39:36.075]                           grepl <- base::grepl
[17:39:36.075]                           restarts <- computeRestarts(cond)
[17:39:36.075]                           for (restart in restarts) {
[17:39:36.075]                             name <- restart$name
[17:39:36.075]                             if (is.null(name)) 
[17:39:36.075]                               next
[17:39:36.075]                             if (!grepl(pattern, name)) 
[17:39:36.075]                               next
[17:39:36.075]                             invokeRestart(restart)
[17:39:36.075]                             muffled <- TRUE
[17:39:36.075]                             break
[17:39:36.075]                           }
[17:39:36.075]                         }
[17:39:36.075]                       }
[17:39:36.075]                       invisible(muffled)
[17:39:36.075]                     }
[17:39:36.075]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.075]                   }
[17:39:36.075]                 }
[17:39:36.075]                 else {
[17:39:36.075]                   if (TRUE) {
[17:39:36.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.075]                     {
[17:39:36.075]                       inherits <- base::inherits
[17:39:36.075]                       invokeRestart <- base::invokeRestart
[17:39:36.075]                       is.null <- base::is.null
[17:39:36.075]                       muffled <- FALSE
[17:39:36.075]                       if (inherits(cond, "message")) {
[17:39:36.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.075]                         if (muffled) 
[17:39:36.075]                           invokeRestart("muffleMessage")
[17:39:36.075]                       }
[17:39:36.075]                       else if (inherits(cond, "warning")) {
[17:39:36.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.075]                         if (muffled) 
[17:39:36.075]                           invokeRestart("muffleWarning")
[17:39:36.075]                       }
[17:39:36.075]                       else if (inherits(cond, "condition")) {
[17:39:36.075]                         if (!is.null(pattern)) {
[17:39:36.075]                           computeRestarts <- base::computeRestarts
[17:39:36.075]                           grepl <- base::grepl
[17:39:36.075]                           restarts <- computeRestarts(cond)
[17:39:36.075]                           for (restart in restarts) {
[17:39:36.075]                             name <- restart$name
[17:39:36.075]                             if (is.null(name)) 
[17:39:36.075]                               next
[17:39:36.075]                             if (!grepl(pattern, name)) 
[17:39:36.075]                               next
[17:39:36.075]                             invokeRestart(restart)
[17:39:36.075]                             muffled <- TRUE
[17:39:36.075]                             break
[17:39:36.075]                           }
[17:39:36.075]                         }
[17:39:36.075]                       }
[17:39:36.075]                       invisible(muffled)
[17:39:36.075]                     }
[17:39:36.075]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.075]                   }
[17:39:36.075]                 }
[17:39:36.075]             }
[17:39:36.075]         }))
[17:39:36.075]     }, error = function(ex) {
[17:39:36.075]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.075]                 ...future.rng), started = ...future.startTime, 
[17:39:36.075]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.075]             version = "1.8"), class = "FutureResult")
[17:39:36.075]     }, finally = {
[17:39:36.075]         if (!identical(...future.workdir, getwd())) 
[17:39:36.075]             setwd(...future.workdir)
[17:39:36.075]         {
[17:39:36.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.075]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.075]             }
[17:39:36.075]             base::options(...future.oldOptions)
[17:39:36.075]             if (.Platform$OS.type == "windows") {
[17:39:36.075]                 old_names <- names(...future.oldEnvVars)
[17:39:36.075]                 envs <- base::Sys.getenv()
[17:39:36.075]                 names <- names(envs)
[17:39:36.075]                 common <- intersect(names, old_names)
[17:39:36.075]                 added <- setdiff(names, old_names)
[17:39:36.075]                 removed <- setdiff(old_names, names)
[17:39:36.075]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.075]                   envs[common]]
[17:39:36.075]                 NAMES <- toupper(changed)
[17:39:36.075]                 args <- list()
[17:39:36.075]                 for (kk in seq_along(NAMES)) {
[17:39:36.075]                   name <- changed[[kk]]
[17:39:36.075]                   NAME <- NAMES[[kk]]
[17:39:36.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.075]                     next
[17:39:36.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.075]                 }
[17:39:36.075]                 NAMES <- toupper(added)
[17:39:36.075]                 for (kk in seq_along(NAMES)) {
[17:39:36.075]                   name <- added[[kk]]
[17:39:36.075]                   NAME <- NAMES[[kk]]
[17:39:36.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.075]                     next
[17:39:36.075]                   args[[name]] <- ""
[17:39:36.075]                 }
[17:39:36.075]                 NAMES <- toupper(removed)
[17:39:36.075]                 for (kk in seq_along(NAMES)) {
[17:39:36.075]                   name <- removed[[kk]]
[17:39:36.075]                   NAME <- NAMES[[kk]]
[17:39:36.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.075]                     next
[17:39:36.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.075]                 }
[17:39:36.075]                 if (length(args) > 0) 
[17:39:36.075]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.075]             }
[17:39:36.075]             else {
[17:39:36.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.075]             }
[17:39:36.075]             {
[17:39:36.075]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.075]                   0L) {
[17:39:36.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.075]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.075]                   base::options(opts)
[17:39:36.075]                 }
[17:39:36.075]                 {
[17:39:36.075]                   {
[17:39:36.075]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.075]                     NULL
[17:39:36.075]                   }
[17:39:36.075]                   options(future.plan = NULL)
[17:39:36.075]                   if (is.na(NA_character_)) 
[17:39:36.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.075]                     .init = FALSE)
[17:39:36.075]                 }
[17:39:36.075]             }
[17:39:36.075]         }
[17:39:36.075]     })
[17:39:36.075]     if (TRUE) {
[17:39:36.075]         base::sink(type = "output", split = FALSE)
[17:39:36.075]         if (TRUE) {
[17:39:36.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.075]         }
[17:39:36.075]         else {
[17:39:36.075]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.075]         }
[17:39:36.075]         base::close(...future.stdout)
[17:39:36.075]         ...future.stdout <- NULL
[17:39:36.075]     }
[17:39:36.075]     ...future.result$conditions <- ...future.conditions
[17:39:36.075]     ...future.result$finished <- base::Sys.time()
[17:39:36.075]     ...future.result
[17:39:36.075] }
[17:39:36.079] requestCore(): workers = 2
[17:39:36.082] MulticoreFuture started
[17:39:36.082] - Launch lazy future ... done
[17:39:36.082] run() for ‘MulticoreFuture’ ... done
[17:39:36.083] plan(): Setting new future strategy stack:
[17:39:36.083] getGlobalsAndPackages() ...
[17:39:36.083] Searching for globals...
[17:39:36.083] List of future strategies:
[17:39:36.083] 1. sequential:
[17:39:36.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:36.083]    - tweaked: FALSE
[17:39:36.083]    - call: NULL
[17:39:36.084] plan(): nbrOfWorkers() = 1
[17:39:36.085] - globals found: [1] ‘{’
[17:39:36.085] Searching for globals ... DONE
[17:39:36.085] Resolving globals: FALSE
[17:39:36.086] 
[17:39:36.086] 
[17:39:36.086] getGlobalsAndPackages() ... DONE
[17:39:36.086] plan(): Setting new future strategy stack:
[17:39:36.086] run() for ‘Future’ ...
[17:39:36.086] List of future strategies:
[17:39:36.086] 1. multicore:
[17:39:36.086]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:36.086]    - tweaked: FALSE
[17:39:36.086]    - call: plan(strategy)
[17:39:36.087] - state: ‘created’
[17:39:36.087] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.091] plan(): nbrOfWorkers() = 2
[17:39:36.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:36.093]   - Field: ‘label’
[17:39:36.093]   - Field: ‘local’
[17:39:36.093]   - Field: ‘owner’
[17:39:36.093]   - Field: ‘envir’
[17:39:36.093]   - Field: ‘workers’
[17:39:36.093]   - Field: ‘packages’
[17:39:36.094]   - Field: ‘gc’
[17:39:36.094]   - Field: ‘job’
[17:39:36.094]   - Field: ‘conditions’
[17:39:36.094]   - Field: ‘expr’
[17:39:36.094]   - Field: ‘uuid’
[17:39:36.094]   - Field: ‘seed’
[17:39:36.094]   - Field: ‘version’
[17:39:36.095]   - Field: ‘result’
[17:39:36.095]   - Field: ‘asynchronous’
[17:39:36.095]   - Field: ‘calls’
[17:39:36.095]   - Field: ‘globals’
[17:39:36.095]   - Field: ‘stdout’
[17:39:36.095]   - Field: ‘earlySignal’
[17:39:36.096]   - Field: ‘lazy’
[17:39:36.096]   - Field: ‘state’
[17:39:36.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:36.096] - Launch lazy future ...
[17:39:36.097] Packages needed by the future expression (n = 0): <none>
[17:39:36.097] Packages needed by future strategies (n = 0): <none>
[17:39:36.098] {
[17:39:36.098]     {
[17:39:36.098]         {
[17:39:36.098]             ...future.startTime <- base::Sys.time()
[17:39:36.098]             {
[17:39:36.098]                 {
[17:39:36.098]                   {
[17:39:36.098]                     {
[17:39:36.098]                       base::local({
[17:39:36.098]                         has_future <- base::requireNamespace("future", 
[17:39:36.098]                           quietly = TRUE)
[17:39:36.098]                         if (has_future) {
[17:39:36.098]                           ns <- base::getNamespace("future")
[17:39:36.098]                           version <- ns[[".package"]][["version"]]
[17:39:36.098]                           if (is.null(version)) 
[17:39:36.098]                             version <- utils::packageVersion("future")
[17:39:36.098]                         }
[17:39:36.098]                         else {
[17:39:36.098]                           version <- NULL
[17:39:36.098]                         }
[17:39:36.098]                         if (!has_future || version < "1.8.0") {
[17:39:36.098]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.098]                             "", base::R.version$version.string), 
[17:39:36.098]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.098]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.098]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.098]                               "release", "version")], collapse = " "), 
[17:39:36.098]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.098]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.098]                             info)
[17:39:36.098]                           info <- base::paste(info, collapse = "; ")
[17:39:36.098]                           if (!has_future) {
[17:39:36.098]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.098]                               info)
[17:39:36.098]                           }
[17:39:36.098]                           else {
[17:39:36.098]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.098]                               info, version)
[17:39:36.098]                           }
[17:39:36.098]                           base::stop(msg)
[17:39:36.098]                         }
[17:39:36.098]                       })
[17:39:36.098]                     }
[17:39:36.098]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.098]                     base::options(mc.cores = 1L)
[17:39:36.098]                   }
[17:39:36.098]                   ...future.strategy.old <- future::plan("list")
[17:39:36.098]                   options(future.plan = NULL)
[17:39:36.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.098]                 }
[17:39:36.098]                 ...future.workdir <- getwd()
[17:39:36.098]             }
[17:39:36.098]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.098]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.098]         }
[17:39:36.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.098]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.098]             base::names(...future.oldOptions))
[17:39:36.098]     }
[17:39:36.098]     if (FALSE) {
[17:39:36.098]     }
[17:39:36.098]     else {
[17:39:36.098]         if (TRUE) {
[17:39:36.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.098]                 open = "w")
[17:39:36.098]         }
[17:39:36.098]         else {
[17:39:36.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.098]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.098]         }
[17:39:36.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.098]             base::sink(type = "output", split = FALSE)
[17:39:36.098]             base::close(...future.stdout)
[17:39:36.098]         }, add = TRUE)
[17:39:36.098]     }
[17:39:36.098]     ...future.frame <- base::sys.nframe()
[17:39:36.098]     ...future.conditions <- base::list()
[17:39:36.098]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.098]     if (FALSE) {
[17:39:36.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.098]     }
[17:39:36.098]     ...future.result <- base::tryCatch({
[17:39:36.098]         base::withCallingHandlers({
[17:39:36.098]             ...future.value <- base::withVisible(base::local({
[17:39:36.098]                 withCallingHandlers({
[17:39:36.098]                   {
[17:39:36.098]                     4
[17:39:36.098]                   }
[17:39:36.098]                 }, immediateCondition = function(cond) {
[17:39:36.098]                   save_rds <- function (object, pathname, ...) 
[17:39:36.098]                   {
[17:39:36.098]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:36.098]                     if (file_test("-f", pathname_tmp)) {
[17:39:36.098]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.098]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:36.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.098]                         fi_tmp[["mtime"]])
[17:39:36.098]                     }
[17:39:36.098]                     tryCatch({
[17:39:36.098]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:36.098]                     }, error = function(ex) {
[17:39:36.098]                       msg <- conditionMessage(ex)
[17:39:36.098]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.098]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:36.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.098]                         fi_tmp[["mtime"]], msg)
[17:39:36.098]                       ex$message <- msg
[17:39:36.098]                       stop(ex)
[17:39:36.098]                     })
[17:39:36.098]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:36.098]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:36.098]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:36.098]                       fi_tmp <- file.info(pathname_tmp)
[17:39:36.098]                       fi <- file.info(pathname)
[17:39:36.098]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:36.098]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:36.098]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:36.098]                         fi[["size"]], fi[["mtime"]])
[17:39:36.098]                       stop(msg)
[17:39:36.098]                     }
[17:39:36.098]                     invisible(pathname)
[17:39:36.098]                   }
[17:39:36.098]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:36.098]                     rootPath = tempdir()) 
[17:39:36.098]                   {
[17:39:36.098]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:36.098]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:36.098]                       tmpdir = path, fileext = ".rds")
[17:39:36.098]                     save_rds(obj, file)
[17:39:36.098]                   }
[17:39:36.098]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:36.098]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.098]                   {
[17:39:36.098]                     inherits <- base::inherits
[17:39:36.098]                     invokeRestart <- base::invokeRestart
[17:39:36.098]                     is.null <- base::is.null
[17:39:36.098]                     muffled <- FALSE
[17:39:36.098]                     if (inherits(cond, "message")) {
[17:39:36.098]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.098]                       if (muffled) 
[17:39:36.098]                         invokeRestart("muffleMessage")
[17:39:36.098]                     }
[17:39:36.098]                     else if (inherits(cond, "warning")) {
[17:39:36.098]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.098]                       if (muffled) 
[17:39:36.098]                         invokeRestart("muffleWarning")
[17:39:36.098]                     }
[17:39:36.098]                     else if (inherits(cond, "condition")) {
[17:39:36.098]                       if (!is.null(pattern)) {
[17:39:36.098]                         computeRestarts <- base::computeRestarts
[17:39:36.098]                         grepl <- base::grepl
[17:39:36.098]                         restarts <- computeRestarts(cond)
[17:39:36.098]                         for (restart in restarts) {
[17:39:36.098]                           name <- restart$name
[17:39:36.098]                           if (is.null(name)) 
[17:39:36.098]                             next
[17:39:36.098]                           if (!grepl(pattern, name)) 
[17:39:36.098]                             next
[17:39:36.098]                           invokeRestart(restart)
[17:39:36.098]                           muffled <- TRUE
[17:39:36.098]                           break
[17:39:36.098]                         }
[17:39:36.098]                       }
[17:39:36.098]                     }
[17:39:36.098]                     invisible(muffled)
[17:39:36.098]                   }
[17:39:36.098]                   muffleCondition(cond)
[17:39:36.098]                 })
[17:39:36.098]             }))
[17:39:36.098]             future::FutureResult(value = ...future.value$value, 
[17:39:36.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.098]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.098]                     ...future.globalenv.names))
[17:39:36.098]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.098]         }, condition = base::local({
[17:39:36.098]             c <- base::c
[17:39:36.098]             inherits <- base::inherits
[17:39:36.098]             invokeRestart <- base::invokeRestart
[17:39:36.098]             length <- base::length
[17:39:36.098]             list <- base::list
[17:39:36.098]             seq.int <- base::seq.int
[17:39:36.098]             signalCondition <- base::signalCondition
[17:39:36.098]             sys.calls <- base::sys.calls
[17:39:36.098]             `[[` <- base::`[[`
[17:39:36.098]             `+` <- base::`+`
[17:39:36.098]             `<<-` <- base::`<<-`
[17:39:36.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.098]                   3L)]
[17:39:36.098]             }
[17:39:36.098]             function(cond) {
[17:39:36.098]                 is_error <- inherits(cond, "error")
[17:39:36.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.098]                   NULL)
[17:39:36.098]                 if (is_error) {
[17:39:36.098]                   sessionInformation <- function() {
[17:39:36.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.098]                       search = base::search(), system = base::Sys.info())
[17:39:36.098]                   }
[17:39:36.098]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.098]                     cond$call), session = sessionInformation(), 
[17:39:36.098]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.098]                   signalCondition(cond)
[17:39:36.098]                 }
[17:39:36.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.098]                 "immediateCondition"))) {
[17:39:36.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.098]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.098]                   if (TRUE && !signal) {
[17:39:36.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.098]                     {
[17:39:36.098]                       inherits <- base::inherits
[17:39:36.098]                       invokeRestart <- base::invokeRestart
[17:39:36.098]                       is.null <- base::is.null
[17:39:36.098]                       muffled <- FALSE
[17:39:36.098]                       if (inherits(cond, "message")) {
[17:39:36.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.098]                         if (muffled) 
[17:39:36.098]                           invokeRestart("muffleMessage")
[17:39:36.098]                       }
[17:39:36.098]                       else if (inherits(cond, "warning")) {
[17:39:36.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.098]                         if (muffled) 
[17:39:36.098]                           invokeRestart("muffleWarning")
[17:39:36.098]                       }
[17:39:36.098]                       else if (inherits(cond, "condition")) {
[17:39:36.098]                         if (!is.null(pattern)) {
[17:39:36.098]                           computeRestarts <- base::computeRestarts
[17:39:36.098]                           grepl <- base::grepl
[17:39:36.098]                           restarts <- computeRestarts(cond)
[17:39:36.098]                           for (restart in restarts) {
[17:39:36.098]                             name <- restart$name
[17:39:36.098]                             if (is.null(name)) 
[17:39:36.098]                               next
[17:39:36.098]                             if (!grepl(pattern, name)) 
[17:39:36.098]                               next
[17:39:36.098]                             invokeRestart(restart)
[17:39:36.098]                             muffled <- TRUE
[17:39:36.098]                             break
[17:39:36.098]                           }
[17:39:36.098]                         }
[17:39:36.098]                       }
[17:39:36.098]                       invisible(muffled)
[17:39:36.098]                     }
[17:39:36.098]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.098]                   }
[17:39:36.098]                 }
[17:39:36.098]                 else {
[17:39:36.098]                   if (TRUE) {
[17:39:36.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.098]                     {
[17:39:36.098]                       inherits <- base::inherits
[17:39:36.098]                       invokeRestart <- base::invokeRestart
[17:39:36.098]                       is.null <- base::is.null
[17:39:36.098]                       muffled <- FALSE
[17:39:36.098]                       if (inherits(cond, "message")) {
[17:39:36.098]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.098]                         if (muffled) 
[17:39:36.098]                           invokeRestart("muffleMessage")
[17:39:36.098]                       }
[17:39:36.098]                       else if (inherits(cond, "warning")) {
[17:39:36.098]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.098]                         if (muffled) 
[17:39:36.098]                           invokeRestart("muffleWarning")
[17:39:36.098]                       }
[17:39:36.098]                       else if (inherits(cond, "condition")) {
[17:39:36.098]                         if (!is.null(pattern)) {
[17:39:36.098]                           computeRestarts <- base::computeRestarts
[17:39:36.098]                           grepl <- base::grepl
[17:39:36.098]                           restarts <- computeRestarts(cond)
[17:39:36.098]                           for (restart in restarts) {
[17:39:36.098]                             name <- restart$name
[17:39:36.098]                             if (is.null(name)) 
[17:39:36.098]                               next
[17:39:36.098]                             if (!grepl(pattern, name)) 
[17:39:36.098]                               next
[17:39:36.098]                             invokeRestart(restart)
[17:39:36.098]                             muffled <- TRUE
[17:39:36.098]                             break
[17:39:36.098]                           }
[17:39:36.098]                         }
[17:39:36.098]                       }
[17:39:36.098]                       invisible(muffled)
[17:39:36.098]                     }
[17:39:36.098]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.098]                   }
[17:39:36.098]                 }
[17:39:36.098]             }
[17:39:36.098]         }))
[17:39:36.098]     }, error = function(ex) {
[17:39:36.098]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.098]                 ...future.rng), started = ...future.startTime, 
[17:39:36.098]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.098]             version = "1.8"), class = "FutureResult")
[17:39:36.098]     }, finally = {
[17:39:36.098]         if (!identical(...future.workdir, getwd())) 
[17:39:36.098]             setwd(...future.workdir)
[17:39:36.098]         {
[17:39:36.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.098]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.098]             }
[17:39:36.098]             base::options(...future.oldOptions)
[17:39:36.098]             if (.Platform$OS.type == "windows") {
[17:39:36.098]                 old_names <- names(...future.oldEnvVars)
[17:39:36.098]                 envs <- base::Sys.getenv()
[17:39:36.098]                 names <- names(envs)
[17:39:36.098]                 common <- intersect(names, old_names)
[17:39:36.098]                 added <- setdiff(names, old_names)
[17:39:36.098]                 removed <- setdiff(old_names, names)
[17:39:36.098]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.098]                   envs[common]]
[17:39:36.098]                 NAMES <- toupper(changed)
[17:39:36.098]                 args <- list()
[17:39:36.098]                 for (kk in seq_along(NAMES)) {
[17:39:36.098]                   name <- changed[[kk]]
[17:39:36.098]                   NAME <- NAMES[[kk]]
[17:39:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.098]                     next
[17:39:36.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.098]                 }
[17:39:36.098]                 NAMES <- toupper(added)
[17:39:36.098]                 for (kk in seq_along(NAMES)) {
[17:39:36.098]                   name <- added[[kk]]
[17:39:36.098]                   NAME <- NAMES[[kk]]
[17:39:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.098]                     next
[17:39:36.098]                   args[[name]] <- ""
[17:39:36.098]                 }
[17:39:36.098]                 NAMES <- toupper(removed)
[17:39:36.098]                 for (kk in seq_along(NAMES)) {
[17:39:36.098]                   name <- removed[[kk]]
[17:39:36.098]                   NAME <- NAMES[[kk]]
[17:39:36.098]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.098]                     next
[17:39:36.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.098]                 }
[17:39:36.098]                 if (length(args) > 0) 
[17:39:36.098]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.098]             }
[17:39:36.098]             else {
[17:39:36.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.098]             }
[17:39:36.098]             {
[17:39:36.098]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.098]                   0L) {
[17:39:36.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.098]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.098]                   base::options(opts)
[17:39:36.098]                 }
[17:39:36.098]                 {
[17:39:36.098]                   {
[17:39:36.098]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.098]                     NULL
[17:39:36.098]                   }
[17:39:36.098]                   options(future.plan = NULL)
[17:39:36.098]                   if (is.na(NA_character_)) 
[17:39:36.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.098]                     .init = FALSE)
[17:39:36.098]                 }
[17:39:36.098]             }
[17:39:36.098]         }
[17:39:36.098]     })
[17:39:36.098]     if (TRUE) {
[17:39:36.098]         base::sink(type = "output", split = FALSE)
[17:39:36.098]         if (TRUE) {
[17:39:36.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.098]         }
[17:39:36.098]         else {
[17:39:36.098]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.098]         }
[17:39:36.098]         base::close(...future.stdout)
[17:39:36.098]         ...future.stdout <- NULL
[17:39:36.098]     }
[17:39:36.098]     ...future.result$conditions <- ...future.conditions
[17:39:36.098]     ...future.result$finished <- base::Sys.time()
[17:39:36.098]     ...future.result
[17:39:36.098] }
[17:39:36.101] requestCore(): workers = 2
[17:39:36.102] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:36.112] result() for MulticoreFuture ...
[17:39:36.113] result() for MulticoreFuture ...
[17:39:36.114] result() for MulticoreFuture ... done
[17:39:36.114] result() for MulticoreFuture ... done
[17:39:36.114] result() for MulticoreFuture ...
[17:39:36.114] result() for MulticoreFuture ... done
[17:39:36.117] MulticoreFuture started
[17:39:36.117] - Launch lazy future ... done
[17:39:36.118] run() for ‘MulticoreFuture’ ... done
[17:39:36.118] plan(): Setting new future strategy stack:
<environment: 0x55adf0c78fa0> 
[17:39:36.118] List of future strategies:
[17:39:36.118] 1. sequential:
[17:39:36.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:36.118]    - tweaked: FALSE
[17:39:36.118]    - call: NULL
[17:39:36.120] plan(): nbrOfWorkers() = 1
<environment: 0x55adeea79780> 
[17:39:36.123] plan(): Setting new future strategy stack:
[17:39:36.123] List of future strategies:
[17:39:36.123] 1. multicore:
[17:39:36.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:36.123]    - tweaked: FALSE
[17:39:36.123]    - call: plan(strategy)
[17:39:36.129] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.132] resolve() on environment ...
[17:39:36.132]  recursive: 0
[17:39:36.133]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.133] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.133] - nx: 4
[17:39:36.133] - relay: TRUE
[17:39:36.134] - stdout: TRUE
[17:39:36.134] - signal: TRUE
[17:39:36.134] - resignal: FALSE
[17:39:36.134] - force: TRUE
[17:39:36.134] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.134] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.134]  - until=2
[17:39:36.135]  - relaying element #2
[17:39:36.135] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.135] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.135] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.135]  length: 3 (resolved future 1)
[17:39:36.135] Future #2
[17:39:36.136] result() for MulticoreFuture ...
[17:39:36.136] result() for MulticoreFuture ... done
[17:39:36.136] result() for MulticoreFuture ...
[17:39:36.136] result() for MulticoreFuture ... done
[17:39:36.136] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:36.136] - nx: 4
[17:39:36.137] - relay: TRUE
[17:39:36.137] - stdout: TRUE
[17:39:36.137] - signal: TRUE
[17:39:36.137] - resignal: FALSE
[17:39:36.137] - force: TRUE
[17:39:36.137] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.137] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.137]  - until=2
[17:39:36.138]  - relaying element #2
[17:39:36.138] result() for MulticoreFuture ...
[17:39:36.138] result() for MulticoreFuture ... done
[17:39:36.138] result() for MulticoreFuture ...
[17:39:36.138] result() for MulticoreFuture ... done
[17:39:36.138] result() for MulticoreFuture ...
[17:39:36.138] result() for MulticoreFuture ... done
[17:39:36.139] result() for MulticoreFuture ...
[17:39:36.139] result() for MulticoreFuture ... done
[17:39:36.139] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.139] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.139] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:36.139]  length: 2 (resolved future 2)
[17:39:36.140] Future #3
[17:39:36.140] result() for MulticoreFuture ...
[17:39:36.141] result() for MulticoreFuture ...
[17:39:36.141] result() for MulticoreFuture ... done
[17:39:36.141] result() for MulticoreFuture ... done
[17:39:36.141] result() for MulticoreFuture ...
[17:39:36.141] result() for MulticoreFuture ... done
[17:39:36.141] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:36.142] - nx: 4
[17:39:36.142] - relay: TRUE
[17:39:36.142] - stdout: TRUE
[17:39:36.142] - signal: TRUE
[17:39:36.142] - resignal: FALSE
[17:39:36.142] - force: TRUE
[17:39:36.142] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.142] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.143]  - until=3
[17:39:36.143]  - relaying element #3
[17:39:36.143] result() for MulticoreFuture ...
[17:39:36.143] result() for MulticoreFuture ... done
[17:39:36.143] result() for MulticoreFuture ...
[17:39:36.143] result() for MulticoreFuture ... done
[17:39:36.144] result() for MulticoreFuture ...
[17:39:36.144] result() for MulticoreFuture ... done
[17:39:36.144] result() for MulticoreFuture ...
[17:39:36.144] result() for MulticoreFuture ... done
[17:39:36.144] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.144] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.144] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:36.145]  length: 1 (resolved future 3)
[17:39:36.145] Future #4
[17:39:36.145] result() for MulticoreFuture ...
[17:39:36.146] result() for MulticoreFuture ...
[17:39:36.146] result() for MulticoreFuture ... done
[17:39:36.146] result() for MulticoreFuture ... done
[17:39:36.146] result() for MulticoreFuture ...
[17:39:36.146] result() for MulticoreFuture ... done
[17:39:36.147] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:36.147] - nx: 4
[17:39:36.147] - relay: TRUE
[17:39:36.147] - stdout: TRUE
[17:39:36.147] - signal: TRUE
[17:39:36.147] - resignal: FALSE
[17:39:36.148] - force: TRUE
[17:39:36.148] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.148] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.148]  - until=4
[17:39:36.148]  - relaying element #4
[17:39:36.148] result() for MulticoreFuture ...
[17:39:36.149] result() for MulticoreFuture ... done
[17:39:36.149] result() for MulticoreFuture ...
[17:39:36.149] result() for MulticoreFuture ... done
[17:39:36.149] result() for MulticoreFuture ...
[17:39:36.149] result() for MulticoreFuture ... done
[17:39:36.149] result() for MulticoreFuture ...
[17:39:36.149] result() for MulticoreFuture ... done
[17:39:36.150] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.150] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.150] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:36.150]  length: 0 (resolved future 4)
[17:39:36.150] Relaying remaining futures
[17:39:36.150] signalConditionsASAP(NULL, pos=0) ...
[17:39:36.150] - nx: 4
[17:39:36.150] - relay: TRUE
[17:39:36.150] - stdout: TRUE
[17:39:36.150] - signal: TRUE
[17:39:36.151] - resignal: FALSE
[17:39:36.151] - force: TRUE
[17:39:36.151] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.151] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:36.151] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.151] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.151] signalConditionsASAP(NULL, pos=0) ... done
[17:39:36.151] resolve() on environment ... DONE
[17:39:36.151] result() for MulticoreFuture ...
[17:39:36.152] result() for MulticoreFuture ... done
[17:39:36.152] result() for MulticoreFuture ...
[17:39:36.152] result() for MulticoreFuture ... done
[17:39:36.152] result() for MulticoreFuture ...
[17:39:36.152] result() for MulticoreFuture ... done
[17:39:36.152] result() for MulticoreFuture ...
[17:39:36.152] result() for MulticoreFuture ... done
[17:39:36.152] result() for MulticoreFuture ...
[17:39:36.153] result() for MulticoreFuture ... done
[17:39:36.153] result() for MulticoreFuture ...
[17:39:36.153] result() for MulticoreFuture ... done
<environment: 0x55adee66ac48> 
Type of future: multisession
[17:39:36.153] plan(): Setting new future strategy stack:
[17:39:36.153] List of future strategies:
[17:39:36.153] 1. multisession:
[17:39:36.153]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:36.153]    - tweaked: FALSE
[17:39:36.153]    - call: plan(strategy)
[17:39:36.154] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:36.154] multisession:
[17:39:36.154] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:36.154] - tweaked: FALSE
[17:39:36.154] - call: plan(strategy)
[17:39:36.158] getGlobalsAndPackages() ...
[17:39:36.158] Not searching for globals
[17:39:36.158] - globals: [0] <none>
[17:39:36.158] getGlobalsAndPackages() ... DONE
[17:39:36.159] [local output] makeClusterPSOCK() ...
[17:39:36.162] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:36.163] [local output] Base port: 11084
[17:39:36.163] [local output] Getting setup options for 2 cluster nodes ...
[17:39:36.163] [local output]  - Node 1 of 2 ...
[17:39:36.164] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:36.164] [local output] Rscript port: 11084

[17:39:36.165] [local output]  - Node 2 of 2 ...
[17:39:36.165] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:36.166] [local output] Rscript port: 11084

[17:39:36.166] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:36.166] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:36.166] [local output] Setting up PSOCK nodes in parallel
[17:39:36.166] List of 36
[17:39:36.166]  $ worker          : chr "localhost"
[17:39:36.166]   ..- attr(*, "localhost")= logi TRUE
[17:39:36.166]  $ master          : chr "localhost"
[17:39:36.166]  $ port            : int 11084
[17:39:36.166]  $ connectTimeout  : num 120
[17:39:36.166]  $ timeout         : num 2592000
[17:39:36.166]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:36.166]  $ homogeneous     : logi TRUE
[17:39:36.166]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:36.166]  $ rscript_envs    : NULL
[17:39:36.166]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:36.166]  $ rscript_startup : NULL
[17:39:36.166]  $ rscript_sh      : chr "sh"
[17:39:36.166]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:36.166]  $ methods         : logi TRUE
[17:39:36.166]  $ socketOptions   : chr "no-delay"
[17:39:36.166]  $ useXDR          : logi FALSE
[17:39:36.166]  $ outfile         : chr "/dev/null"
[17:39:36.166]  $ renice          : int NA
[17:39:36.166]  $ rshcmd          : NULL
[17:39:36.166]  $ user            : chr(0) 
[17:39:36.166]  $ revtunnel       : logi FALSE
[17:39:36.166]  $ rshlogfile      : NULL
[17:39:36.166]  $ rshopts         : chr(0) 
[17:39:36.166]  $ rank            : int 1
[17:39:36.166]  $ manual          : logi FALSE
[17:39:36.166]  $ dryrun          : logi FALSE
[17:39:36.166]  $ quiet           : logi FALSE
[17:39:36.166]  $ setup_strategy  : chr "parallel"
[17:39:36.166]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:36.166]  $ pidfile         : chr "/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a4767443241a.pid"
[17:39:36.166]  $ rshcmd_label    : NULL
[17:39:36.166]  $ rsh_call        : NULL
[17:39:36.166]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:36.166]  $ localMachine    : logi TRUE
[17:39:36.166]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:36.166]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:36.166]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:36.166]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:36.166]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:36.166]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:36.166]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:36.166]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:36.166]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:36.166]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:36.166]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:36.166]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:36.166]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:36.166]  $ arguments       :List of 28
[17:39:36.166]   ..$ worker          : chr "localhost"
[17:39:36.166]   ..$ master          : NULL
[17:39:36.166]   ..$ port            : int 11084
[17:39:36.166]   ..$ connectTimeout  : num 120
[17:39:36.166]   ..$ timeout         : num 2592000
[17:39:36.166]   ..$ rscript         : NULL
[17:39:36.166]   ..$ homogeneous     : NULL
[17:39:36.166]   ..$ rscript_args    : NULL
[17:39:36.166]   ..$ rscript_envs    : NULL
[17:39:36.166]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:36.166]   ..$ rscript_startup : NULL
[17:39:36.166]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:36.166]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:36.166]   ..$ methods         : logi TRUE
[17:39:36.166]   ..$ socketOptions   : chr "no-delay"
[17:39:36.166]   ..$ useXDR          : logi FALSE
[17:39:36.166]   ..$ outfile         : chr "/dev/null"
[17:39:36.166]   ..$ renice          : int NA
[17:39:36.166]   ..$ rshcmd          : NULL
[17:39:36.166]   ..$ user            : NULL
[17:39:36.166]   ..$ revtunnel       : logi NA
[17:39:36.166]   ..$ rshlogfile      : NULL
[17:39:36.166]   ..$ rshopts         : NULL
[17:39:36.166]   ..$ rank            : int 1
[17:39:36.166]   ..$ manual          : logi FALSE
[17:39:36.166]   ..$ dryrun          : logi FALSE
[17:39:36.166]   ..$ quiet           : logi FALSE
[17:39:36.166]   ..$ setup_strategy  : chr "parallel"
[17:39:36.166]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:36.186] [local output] System call to launch all workers:
[17:39:36.186] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a4767443241a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11084 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:36.186] [local output] Starting PSOCK main server
[17:39:36.188] [local output] Workers launched
[17:39:36.188] [local output] Waiting for workers to connect back
[17:39:36.188]  - [local output] 0 workers out of 2 ready
[17:39:36.426]  - [local output] 0 workers out of 2 ready
[17:39:36.426]  - [local output] 1 workers out of 2 ready
[17:39:36.440]  - [local output] 1 workers out of 2 ready
[17:39:36.440]  - [local output] 2 workers out of 2 ready
[17:39:36.440] [local output] Launching of workers completed
[17:39:36.440] [local output] Collecting session information from workers
[17:39:36.441] [local output]  - Worker #1 of 2
[17:39:36.442] [local output]  - Worker #2 of 2
[17:39:36.442] [local output] makeClusterPSOCK() ... done
[17:39:36.456] Packages needed by the future expression (n = 0): <none>
[17:39:36.456] Packages needed by future strategies (n = 0): <none>
[17:39:36.457] {
[17:39:36.457]     {
[17:39:36.457]         {
[17:39:36.457]             ...future.startTime <- base::Sys.time()
[17:39:36.457]             {
[17:39:36.457]                 {
[17:39:36.457]                   {
[17:39:36.457]                     {
[17:39:36.457]                       base::local({
[17:39:36.457]                         has_future <- base::requireNamespace("future", 
[17:39:36.457]                           quietly = TRUE)
[17:39:36.457]                         if (has_future) {
[17:39:36.457]                           ns <- base::getNamespace("future")
[17:39:36.457]                           version <- ns[[".package"]][["version"]]
[17:39:36.457]                           if (is.null(version)) 
[17:39:36.457]                             version <- utils::packageVersion("future")
[17:39:36.457]                         }
[17:39:36.457]                         else {
[17:39:36.457]                           version <- NULL
[17:39:36.457]                         }
[17:39:36.457]                         if (!has_future || version < "1.8.0") {
[17:39:36.457]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.457]                             "", base::R.version$version.string), 
[17:39:36.457]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.457]                               "release", "version")], collapse = " "), 
[17:39:36.457]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.457]                             info)
[17:39:36.457]                           info <- base::paste(info, collapse = "; ")
[17:39:36.457]                           if (!has_future) {
[17:39:36.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.457]                               info)
[17:39:36.457]                           }
[17:39:36.457]                           else {
[17:39:36.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.457]                               info, version)
[17:39:36.457]                           }
[17:39:36.457]                           base::stop(msg)
[17:39:36.457]                         }
[17:39:36.457]                       })
[17:39:36.457]                     }
[17:39:36.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.457]                     base::options(mc.cores = 1L)
[17:39:36.457]                   }
[17:39:36.457]                   ...future.strategy.old <- future::plan("list")
[17:39:36.457]                   options(future.plan = NULL)
[17:39:36.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.457]                 }
[17:39:36.457]                 ...future.workdir <- getwd()
[17:39:36.457]             }
[17:39:36.457]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.457]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.457]         }
[17:39:36.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.457]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.457]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.457]             base::names(...future.oldOptions))
[17:39:36.457]     }
[17:39:36.457]     if (FALSE) {
[17:39:36.457]     }
[17:39:36.457]     else {
[17:39:36.457]         if (TRUE) {
[17:39:36.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.457]                 open = "w")
[17:39:36.457]         }
[17:39:36.457]         else {
[17:39:36.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.457]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.457]         }
[17:39:36.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.457]             base::sink(type = "output", split = FALSE)
[17:39:36.457]             base::close(...future.stdout)
[17:39:36.457]         }, add = TRUE)
[17:39:36.457]     }
[17:39:36.457]     ...future.frame <- base::sys.nframe()
[17:39:36.457]     ...future.conditions <- base::list()
[17:39:36.457]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.457]     if (FALSE) {
[17:39:36.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.457]     }
[17:39:36.457]     ...future.result <- base::tryCatch({
[17:39:36.457]         base::withCallingHandlers({
[17:39:36.457]             ...future.value <- base::withVisible(base::local({
[17:39:36.457]                 ...future.makeSendCondition <- base::local({
[17:39:36.457]                   sendCondition <- NULL
[17:39:36.457]                   function(frame = 1L) {
[17:39:36.457]                     if (is.function(sendCondition)) 
[17:39:36.457]                       return(sendCondition)
[17:39:36.457]                     ns <- getNamespace("parallel")
[17:39:36.457]                     if (exists("sendData", mode = "function", 
[17:39:36.457]                       envir = ns)) {
[17:39:36.457]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.457]                         envir = ns)
[17:39:36.457]                       envir <- sys.frame(frame)
[17:39:36.457]                       master <- NULL
[17:39:36.457]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.457]                         !identical(envir, emptyenv())) {
[17:39:36.457]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.457]                           inherits = FALSE)) {
[17:39:36.457]                           master <- get("master", mode = "list", 
[17:39:36.457]                             envir = envir, inherits = FALSE)
[17:39:36.457]                           if (inherits(master, c("SOCKnode", 
[17:39:36.457]                             "SOCK0node"))) {
[17:39:36.457]                             sendCondition <<- function(cond) {
[17:39:36.457]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.457]                                 success = TRUE)
[17:39:36.457]                               parallel_sendData(master, data)
[17:39:36.457]                             }
[17:39:36.457]                             return(sendCondition)
[17:39:36.457]                           }
[17:39:36.457]                         }
[17:39:36.457]                         frame <- frame + 1L
[17:39:36.457]                         envir <- sys.frame(frame)
[17:39:36.457]                       }
[17:39:36.457]                     }
[17:39:36.457]                     sendCondition <<- function(cond) NULL
[17:39:36.457]                   }
[17:39:36.457]                 })
[17:39:36.457]                 withCallingHandlers({
[17:39:36.457]                   NA
[17:39:36.457]                 }, immediateCondition = function(cond) {
[17:39:36.457]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.457]                   sendCondition(cond)
[17:39:36.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.457]                   {
[17:39:36.457]                     inherits <- base::inherits
[17:39:36.457]                     invokeRestart <- base::invokeRestart
[17:39:36.457]                     is.null <- base::is.null
[17:39:36.457]                     muffled <- FALSE
[17:39:36.457]                     if (inherits(cond, "message")) {
[17:39:36.457]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.457]                       if (muffled) 
[17:39:36.457]                         invokeRestart("muffleMessage")
[17:39:36.457]                     }
[17:39:36.457]                     else if (inherits(cond, "warning")) {
[17:39:36.457]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.457]                       if (muffled) 
[17:39:36.457]                         invokeRestart("muffleWarning")
[17:39:36.457]                     }
[17:39:36.457]                     else if (inherits(cond, "condition")) {
[17:39:36.457]                       if (!is.null(pattern)) {
[17:39:36.457]                         computeRestarts <- base::computeRestarts
[17:39:36.457]                         grepl <- base::grepl
[17:39:36.457]                         restarts <- computeRestarts(cond)
[17:39:36.457]                         for (restart in restarts) {
[17:39:36.457]                           name <- restart$name
[17:39:36.457]                           if (is.null(name)) 
[17:39:36.457]                             next
[17:39:36.457]                           if (!grepl(pattern, name)) 
[17:39:36.457]                             next
[17:39:36.457]                           invokeRestart(restart)
[17:39:36.457]                           muffled <- TRUE
[17:39:36.457]                           break
[17:39:36.457]                         }
[17:39:36.457]                       }
[17:39:36.457]                     }
[17:39:36.457]                     invisible(muffled)
[17:39:36.457]                   }
[17:39:36.457]                   muffleCondition(cond)
[17:39:36.457]                 })
[17:39:36.457]             }))
[17:39:36.457]             future::FutureResult(value = ...future.value$value, 
[17:39:36.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.457]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.457]                     ...future.globalenv.names))
[17:39:36.457]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.457]         }, condition = base::local({
[17:39:36.457]             c <- base::c
[17:39:36.457]             inherits <- base::inherits
[17:39:36.457]             invokeRestart <- base::invokeRestart
[17:39:36.457]             length <- base::length
[17:39:36.457]             list <- base::list
[17:39:36.457]             seq.int <- base::seq.int
[17:39:36.457]             signalCondition <- base::signalCondition
[17:39:36.457]             sys.calls <- base::sys.calls
[17:39:36.457]             `[[` <- base::`[[`
[17:39:36.457]             `+` <- base::`+`
[17:39:36.457]             `<<-` <- base::`<<-`
[17:39:36.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.457]                   3L)]
[17:39:36.457]             }
[17:39:36.457]             function(cond) {
[17:39:36.457]                 is_error <- inherits(cond, "error")
[17:39:36.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.457]                   NULL)
[17:39:36.457]                 if (is_error) {
[17:39:36.457]                   sessionInformation <- function() {
[17:39:36.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.457]                       search = base::search(), system = base::Sys.info())
[17:39:36.457]                   }
[17:39:36.457]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.457]                     cond$call), session = sessionInformation(), 
[17:39:36.457]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.457]                   signalCondition(cond)
[17:39:36.457]                 }
[17:39:36.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.457]                 "immediateCondition"))) {
[17:39:36.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.457]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.457]                   if (TRUE && !signal) {
[17:39:36.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.457]                     {
[17:39:36.457]                       inherits <- base::inherits
[17:39:36.457]                       invokeRestart <- base::invokeRestart
[17:39:36.457]                       is.null <- base::is.null
[17:39:36.457]                       muffled <- FALSE
[17:39:36.457]                       if (inherits(cond, "message")) {
[17:39:36.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.457]                         if (muffled) 
[17:39:36.457]                           invokeRestart("muffleMessage")
[17:39:36.457]                       }
[17:39:36.457]                       else if (inherits(cond, "warning")) {
[17:39:36.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.457]                         if (muffled) 
[17:39:36.457]                           invokeRestart("muffleWarning")
[17:39:36.457]                       }
[17:39:36.457]                       else if (inherits(cond, "condition")) {
[17:39:36.457]                         if (!is.null(pattern)) {
[17:39:36.457]                           computeRestarts <- base::computeRestarts
[17:39:36.457]                           grepl <- base::grepl
[17:39:36.457]                           restarts <- computeRestarts(cond)
[17:39:36.457]                           for (restart in restarts) {
[17:39:36.457]                             name <- restart$name
[17:39:36.457]                             if (is.null(name)) 
[17:39:36.457]                               next
[17:39:36.457]                             if (!grepl(pattern, name)) 
[17:39:36.457]                               next
[17:39:36.457]                             invokeRestart(restart)
[17:39:36.457]                             muffled <- TRUE
[17:39:36.457]                             break
[17:39:36.457]                           }
[17:39:36.457]                         }
[17:39:36.457]                       }
[17:39:36.457]                       invisible(muffled)
[17:39:36.457]                     }
[17:39:36.457]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.457]                   }
[17:39:36.457]                 }
[17:39:36.457]                 else {
[17:39:36.457]                   if (TRUE) {
[17:39:36.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.457]                     {
[17:39:36.457]                       inherits <- base::inherits
[17:39:36.457]                       invokeRestart <- base::invokeRestart
[17:39:36.457]                       is.null <- base::is.null
[17:39:36.457]                       muffled <- FALSE
[17:39:36.457]                       if (inherits(cond, "message")) {
[17:39:36.457]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.457]                         if (muffled) 
[17:39:36.457]                           invokeRestart("muffleMessage")
[17:39:36.457]                       }
[17:39:36.457]                       else if (inherits(cond, "warning")) {
[17:39:36.457]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.457]                         if (muffled) 
[17:39:36.457]                           invokeRestart("muffleWarning")
[17:39:36.457]                       }
[17:39:36.457]                       else if (inherits(cond, "condition")) {
[17:39:36.457]                         if (!is.null(pattern)) {
[17:39:36.457]                           computeRestarts <- base::computeRestarts
[17:39:36.457]                           grepl <- base::grepl
[17:39:36.457]                           restarts <- computeRestarts(cond)
[17:39:36.457]                           for (restart in restarts) {
[17:39:36.457]                             name <- restart$name
[17:39:36.457]                             if (is.null(name)) 
[17:39:36.457]                               next
[17:39:36.457]                             if (!grepl(pattern, name)) 
[17:39:36.457]                               next
[17:39:36.457]                             invokeRestart(restart)
[17:39:36.457]                             muffled <- TRUE
[17:39:36.457]                             break
[17:39:36.457]                           }
[17:39:36.457]                         }
[17:39:36.457]                       }
[17:39:36.457]                       invisible(muffled)
[17:39:36.457]                     }
[17:39:36.457]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.457]                   }
[17:39:36.457]                 }
[17:39:36.457]             }
[17:39:36.457]         }))
[17:39:36.457]     }, error = function(ex) {
[17:39:36.457]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.457]                 ...future.rng), started = ...future.startTime, 
[17:39:36.457]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.457]             version = "1.8"), class = "FutureResult")
[17:39:36.457]     }, finally = {
[17:39:36.457]         if (!identical(...future.workdir, getwd())) 
[17:39:36.457]             setwd(...future.workdir)
[17:39:36.457]         {
[17:39:36.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.457]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.457]             }
[17:39:36.457]             base::options(...future.oldOptions)
[17:39:36.457]             if (.Platform$OS.type == "windows") {
[17:39:36.457]                 old_names <- names(...future.oldEnvVars)
[17:39:36.457]                 envs <- base::Sys.getenv()
[17:39:36.457]                 names <- names(envs)
[17:39:36.457]                 common <- intersect(names, old_names)
[17:39:36.457]                 added <- setdiff(names, old_names)
[17:39:36.457]                 removed <- setdiff(old_names, names)
[17:39:36.457]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.457]                   envs[common]]
[17:39:36.457]                 NAMES <- toupper(changed)
[17:39:36.457]                 args <- list()
[17:39:36.457]                 for (kk in seq_along(NAMES)) {
[17:39:36.457]                   name <- changed[[kk]]
[17:39:36.457]                   NAME <- NAMES[[kk]]
[17:39:36.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.457]                     next
[17:39:36.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.457]                 }
[17:39:36.457]                 NAMES <- toupper(added)
[17:39:36.457]                 for (kk in seq_along(NAMES)) {
[17:39:36.457]                   name <- added[[kk]]
[17:39:36.457]                   NAME <- NAMES[[kk]]
[17:39:36.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.457]                     next
[17:39:36.457]                   args[[name]] <- ""
[17:39:36.457]                 }
[17:39:36.457]                 NAMES <- toupper(removed)
[17:39:36.457]                 for (kk in seq_along(NAMES)) {
[17:39:36.457]                   name <- removed[[kk]]
[17:39:36.457]                   NAME <- NAMES[[kk]]
[17:39:36.457]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.457]                     next
[17:39:36.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.457]                 }
[17:39:36.457]                 if (length(args) > 0) 
[17:39:36.457]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.457]             }
[17:39:36.457]             else {
[17:39:36.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.457]             }
[17:39:36.457]             {
[17:39:36.457]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.457]                   0L) {
[17:39:36.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.457]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.457]                   base::options(opts)
[17:39:36.457]                 }
[17:39:36.457]                 {
[17:39:36.457]                   {
[17:39:36.457]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.457]                     NULL
[17:39:36.457]                   }
[17:39:36.457]                   options(future.plan = NULL)
[17:39:36.457]                   if (is.na(NA_character_)) 
[17:39:36.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.457]                     .init = FALSE)
[17:39:36.457]                 }
[17:39:36.457]             }
[17:39:36.457]         }
[17:39:36.457]     })
[17:39:36.457]     if (TRUE) {
[17:39:36.457]         base::sink(type = "output", split = FALSE)
[17:39:36.457]         if (TRUE) {
[17:39:36.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.457]         }
[17:39:36.457]         else {
[17:39:36.457]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.457]         }
[17:39:36.457]         base::close(...future.stdout)
[17:39:36.457]         ...future.stdout <- NULL
[17:39:36.457]     }
[17:39:36.457]     ...future.result$conditions <- ...future.conditions
[17:39:36.457]     ...future.result$finished <- base::Sys.time()
[17:39:36.457]     ...future.result
[17:39:36.457] }
[17:39:36.509] MultisessionFuture started
[17:39:36.509] result() for ClusterFuture ...
[17:39:36.510] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.510] - Validating connection of MultisessionFuture
[17:39:36.542] - received message: FutureResult
[17:39:36.542] - Received FutureResult
[17:39:36.542] - Erased future from FutureRegistry
[17:39:36.542] result() for ClusterFuture ...
[17:39:36.542] - result already collected: FutureResult
[17:39:36.542] result() for ClusterFuture ... done
[17:39:36.543] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.543] result() for ClusterFuture ... done
[17:39:36.543] result() for ClusterFuture ...
[17:39:36.543] - result already collected: FutureResult
[17:39:36.543] result() for ClusterFuture ... done
[17:39:36.543] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:36.547] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:36.547] getGlobalsAndPackages() ...
[17:39:36.547] Searching for globals...
[17:39:36.548] 
[17:39:36.548] Searching for globals ... DONE
[17:39:36.548] - globals: [0] <none>
[17:39:36.548] getGlobalsAndPackages() ... DONE
[17:39:36.548] run() for ‘Future’ ...
[17:39:36.548] - state: ‘created’
[17:39:36.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.562] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.562]   - Field: ‘node’
[17:39:36.562]   - Field: ‘label’
[17:39:36.563]   - Field: ‘local’
[17:39:36.563]   - Field: ‘owner’
[17:39:36.563]   - Field: ‘envir’
[17:39:36.563]   - Field: ‘workers’
[17:39:36.563]   - Field: ‘packages’
[17:39:36.563]   - Field: ‘gc’
[17:39:36.563]   - Field: ‘conditions’
[17:39:36.563]   - Field: ‘persistent’
[17:39:36.563]   - Field: ‘expr’
[17:39:36.564]   - Field: ‘uuid’
[17:39:36.564]   - Field: ‘seed’
[17:39:36.564]   - Field: ‘version’
[17:39:36.564]   - Field: ‘result’
[17:39:36.564]   - Field: ‘asynchronous’
[17:39:36.564]   - Field: ‘calls’
[17:39:36.564]   - Field: ‘globals’
[17:39:36.564]   - Field: ‘stdout’
[17:39:36.564]   - Field: ‘earlySignal’
[17:39:36.565]   - Field: ‘lazy’
[17:39:36.565]   - Field: ‘state’
[17:39:36.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.565] - Launch lazy future ...
[17:39:36.565] Packages needed by the future expression (n = 0): <none>
[17:39:36.565] Packages needed by future strategies (n = 0): <none>
[17:39:36.566] {
[17:39:36.566]     {
[17:39:36.566]         {
[17:39:36.566]             ...future.startTime <- base::Sys.time()
[17:39:36.566]             {
[17:39:36.566]                 {
[17:39:36.566]                   {
[17:39:36.566]                     {
[17:39:36.566]                       base::local({
[17:39:36.566]                         has_future <- base::requireNamespace("future", 
[17:39:36.566]                           quietly = TRUE)
[17:39:36.566]                         if (has_future) {
[17:39:36.566]                           ns <- base::getNamespace("future")
[17:39:36.566]                           version <- ns[[".package"]][["version"]]
[17:39:36.566]                           if (is.null(version)) 
[17:39:36.566]                             version <- utils::packageVersion("future")
[17:39:36.566]                         }
[17:39:36.566]                         else {
[17:39:36.566]                           version <- NULL
[17:39:36.566]                         }
[17:39:36.566]                         if (!has_future || version < "1.8.0") {
[17:39:36.566]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.566]                             "", base::R.version$version.string), 
[17:39:36.566]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.566]                               "release", "version")], collapse = " "), 
[17:39:36.566]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.566]                             info)
[17:39:36.566]                           info <- base::paste(info, collapse = "; ")
[17:39:36.566]                           if (!has_future) {
[17:39:36.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.566]                               info)
[17:39:36.566]                           }
[17:39:36.566]                           else {
[17:39:36.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.566]                               info, version)
[17:39:36.566]                           }
[17:39:36.566]                           base::stop(msg)
[17:39:36.566]                         }
[17:39:36.566]                       })
[17:39:36.566]                     }
[17:39:36.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.566]                     base::options(mc.cores = 1L)
[17:39:36.566]                   }
[17:39:36.566]                   ...future.strategy.old <- future::plan("list")
[17:39:36.566]                   options(future.plan = NULL)
[17:39:36.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.566]                 }
[17:39:36.566]                 ...future.workdir <- getwd()
[17:39:36.566]             }
[17:39:36.566]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.566]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.566]         }
[17:39:36.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.566]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.566]             base::names(...future.oldOptions))
[17:39:36.566]     }
[17:39:36.566]     if (FALSE) {
[17:39:36.566]     }
[17:39:36.566]     else {
[17:39:36.566]         if (TRUE) {
[17:39:36.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.566]                 open = "w")
[17:39:36.566]         }
[17:39:36.566]         else {
[17:39:36.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.566]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.566]         }
[17:39:36.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.566]             base::sink(type = "output", split = FALSE)
[17:39:36.566]             base::close(...future.stdout)
[17:39:36.566]         }, add = TRUE)
[17:39:36.566]     }
[17:39:36.566]     ...future.frame <- base::sys.nframe()
[17:39:36.566]     ...future.conditions <- base::list()
[17:39:36.566]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.566]     if (FALSE) {
[17:39:36.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.566]     }
[17:39:36.566]     ...future.result <- base::tryCatch({
[17:39:36.566]         base::withCallingHandlers({
[17:39:36.566]             ...future.value <- base::withVisible(base::local({
[17:39:36.566]                 ...future.makeSendCondition <- base::local({
[17:39:36.566]                   sendCondition <- NULL
[17:39:36.566]                   function(frame = 1L) {
[17:39:36.566]                     if (is.function(sendCondition)) 
[17:39:36.566]                       return(sendCondition)
[17:39:36.566]                     ns <- getNamespace("parallel")
[17:39:36.566]                     if (exists("sendData", mode = "function", 
[17:39:36.566]                       envir = ns)) {
[17:39:36.566]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.566]                         envir = ns)
[17:39:36.566]                       envir <- sys.frame(frame)
[17:39:36.566]                       master <- NULL
[17:39:36.566]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.566]                         !identical(envir, emptyenv())) {
[17:39:36.566]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.566]                           inherits = FALSE)) {
[17:39:36.566]                           master <- get("master", mode = "list", 
[17:39:36.566]                             envir = envir, inherits = FALSE)
[17:39:36.566]                           if (inherits(master, c("SOCKnode", 
[17:39:36.566]                             "SOCK0node"))) {
[17:39:36.566]                             sendCondition <<- function(cond) {
[17:39:36.566]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.566]                                 success = TRUE)
[17:39:36.566]                               parallel_sendData(master, data)
[17:39:36.566]                             }
[17:39:36.566]                             return(sendCondition)
[17:39:36.566]                           }
[17:39:36.566]                         }
[17:39:36.566]                         frame <- frame + 1L
[17:39:36.566]                         envir <- sys.frame(frame)
[17:39:36.566]                       }
[17:39:36.566]                     }
[17:39:36.566]                     sendCondition <<- function(cond) NULL
[17:39:36.566]                   }
[17:39:36.566]                 })
[17:39:36.566]                 withCallingHandlers({
[17:39:36.566]                   2
[17:39:36.566]                 }, immediateCondition = function(cond) {
[17:39:36.566]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.566]                   sendCondition(cond)
[17:39:36.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.566]                   {
[17:39:36.566]                     inherits <- base::inherits
[17:39:36.566]                     invokeRestart <- base::invokeRestart
[17:39:36.566]                     is.null <- base::is.null
[17:39:36.566]                     muffled <- FALSE
[17:39:36.566]                     if (inherits(cond, "message")) {
[17:39:36.566]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.566]                       if (muffled) 
[17:39:36.566]                         invokeRestart("muffleMessage")
[17:39:36.566]                     }
[17:39:36.566]                     else if (inherits(cond, "warning")) {
[17:39:36.566]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.566]                       if (muffled) 
[17:39:36.566]                         invokeRestart("muffleWarning")
[17:39:36.566]                     }
[17:39:36.566]                     else if (inherits(cond, "condition")) {
[17:39:36.566]                       if (!is.null(pattern)) {
[17:39:36.566]                         computeRestarts <- base::computeRestarts
[17:39:36.566]                         grepl <- base::grepl
[17:39:36.566]                         restarts <- computeRestarts(cond)
[17:39:36.566]                         for (restart in restarts) {
[17:39:36.566]                           name <- restart$name
[17:39:36.566]                           if (is.null(name)) 
[17:39:36.566]                             next
[17:39:36.566]                           if (!grepl(pattern, name)) 
[17:39:36.566]                             next
[17:39:36.566]                           invokeRestart(restart)
[17:39:36.566]                           muffled <- TRUE
[17:39:36.566]                           break
[17:39:36.566]                         }
[17:39:36.566]                       }
[17:39:36.566]                     }
[17:39:36.566]                     invisible(muffled)
[17:39:36.566]                   }
[17:39:36.566]                   muffleCondition(cond)
[17:39:36.566]                 })
[17:39:36.566]             }))
[17:39:36.566]             future::FutureResult(value = ...future.value$value, 
[17:39:36.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.566]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.566]                     ...future.globalenv.names))
[17:39:36.566]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.566]         }, condition = base::local({
[17:39:36.566]             c <- base::c
[17:39:36.566]             inherits <- base::inherits
[17:39:36.566]             invokeRestart <- base::invokeRestart
[17:39:36.566]             length <- base::length
[17:39:36.566]             list <- base::list
[17:39:36.566]             seq.int <- base::seq.int
[17:39:36.566]             signalCondition <- base::signalCondition
[17:39:36.566]             sys.calls <- base::sys.calls
[17:39:36.566]             `[[` <- base::`[[`
[17:39:36.566]             `+` <- base::`+`
[17:39:36.566]             `<<-` <- base::`<<-`
[17:39:36.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.566]                   3L)]
[17:39:36.566]             }
[17:39:36.566]             function(cond) {
[17:39:36.566]                 is_error <- inherits(cond, "error")
[17:39:36.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.566]                   NULL)
[17:39:36.566]                 if (is_error) {
[17:39:36.566]                   sessionInformation <- function() {
[17:39:36.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.566]                       search = base::search(), system = base::Sys.info())
[17:39:36.566]                   }
[17:39:36.566]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.566]                     cond$call), session = sessionInformation(), 
[17:39:36.566]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.566]                   signalCondition(cond)
[17:39:36.566]                 }
[17:39:36.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.566]                 "immediateCondition"))) {
[17:39:36.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.566]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.566]                   if (TRUE && !signal) {
[17:39:36.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.566]                     {
[17:39:36.566]                       inherits <- base::inherits
[17:39:36.566]                       invokeRestart <- base::invokeRestart
[17:39:36.566]                       is.null <- base::is.null
[17:39:36.566]                       muffled <- FALSE
[17:39:36.566]                       if (inherits(cond, "message")) {
[17:39:36.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.566]                         if (muffled) 
[17:39:36.566]                           invokeRestart("muffleMessage")
[17:39:36.566]                       }
[17:39:36.566]                       else if (inherits(cond, "warning")) {
[17:39:36.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.566]                         if (muffled) 
[17:39:36.566]                           invokeRestart("muffleWarning")
[17:39:36.566]                       }
[17:39:36.566]                       else if (inherits(cond, "condition")) {
[17:39:36.566]                         if (!is.null(pattern)) {
[17:39:36.566]                           computeRestarts <- base::computeRestarts
[17:39:36.566]                           grepl <- base::grepl
[17:39:36.566]                           restarts <- computeRestarts(cond)
[17:39:36.566]                           for (restart in restarts) {
[17:39:36.566]                             name <- restart$name
[17:39:36.566]                             if (is.null(name)) 
[17:39:36.566]                               next
[17:39:36.566]                             if (!grepl(pattern, name)) 
[17:39:36.566]                               next
[17:39:36.566]                             invokeRestart(restart)
[17:39:36.566]                             muffled <- TRUE
[17:39:36.566]                             break
[17:39:36.566]                           }
[17:39:36.566]                         }
[17:39:36.566]                       }
[17:39:36.566]                       invisible(muffled)
[17:39:36.566]                     }
[17:39:36.566]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.566]                   }
[17:39:36.566]                 }
[17:39:36.566]                 else {
[17:39:36.566]                   if (TRUE) {
[17:39:36.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.566]                     {
[17:39:36.566]                       inherits <- base::inherits
[17:39:36.566]                       invokeRestart <- base::invokeRestart
[17:39:36.566]                       is.null <- base::is.null
[17:39:36.566]                       muffled <- FALSE
[17:39:36.566]                       if (inherits(cond, "message")) {
[17:39:36.566]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.566]                         if (muffled) 
[17:39:36.566]                           invokeRestart("muffleMessage")
[17:39:36.566]                       }
[17:39:36.566]                       else if (inherits(cond, "warning")) {
[17:39:36.566]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.566]                         if (muffled) 
[17:39:36.566]                           invokeRestart("muffleWarning")
[17:39:36.566]                       }
[17:39:36.566]                       else if (inherits(cond, "condition")) {
[17:39:36.566]                         if (!is.null(pattern)) {
[17:39:36.566]                           computeRestarts <- base::computeRestarts
[17:39:36.566]                           grepl <- base::grepl
[17:39:36.566]                           restarts <- computeRestarts(cond)
[17:39:36.566]                           for (restart in restarts) {
[17:39:36.566]                             name <- restart$name
[17:39:36.566]                             if (is.null(name)) 
[17:39:36.566]                               next
[17:39:36.566]                             if (!grepl(pattern, name)) 
[17:39:36.566]                               next
[17:39:36.566]                             invokeRestart(restart)
[17:39:36.566]                             muffled <- TRUE
[17:39:36.566]                             break
[17:39:36.566]                           }
[17:39:36.566]                         }
[17:39:36.566]                       }
[17:39:36.566]                       invisible(muffled)
[17:39:36.566]                     }
[17:39:36.566]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.566]                   }
[17:39:36.566]                 }
[17:39:36.566]             }
[17:39:36.566]         }))
[17:39:36.566]     }, error = function(ex) {
[17:39:36.566]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.566]                 ...future.rng), started = ...future.startTime, 
[17:39:36.566]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.566]             version = "1.8"), class = "FutureResult")
[17:39:36.566]     }, finally = {
[17:39:36.566]         if (!identical(...future.workdir, getwd())) 
[17:39:36.566]             setwd(...future.workdir)
[17:39:36.566]         {
[17:39:36.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.566]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.566]             }
[17:39:36.566]             base::options(...future.oldOptions)
[17:39:36.566]             if (.Platform$OS.type == "windows") {
[17:39:36.566]                 old_names <- names(...future.oldEnvVars)
[17:39:36.566]                 envs <- base::Sys.getenv()
[17:39:36.566]                 names <- names(envs)
[17:39:36.566]                 common <- intersect(names, old_names)
[17:39:36.566]                 added <- setdiff(names, old_names)
[17:39:36.566]                 removed <- setdiff(old_names, names)
[17:39:36.566]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.566]                   envs[common]]
[17:39:36.566]                 NAMES <- toupper(changed)
[17:39:36.566]                 args <- list()
[17:39:36.566]                 for (kk in seq_along(NAMES)) {
[17:39:36.566]                   name <- changed[[kk]]
[17:39:36.566]                   NAME <- NAMES[[kk]]
[17:39:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.566]                     next
[17:39:36.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.566]                 }
[17:39:36.566]                 NAMES <- toupper(added)
[17:39:36.566]                 for (kk in seq_along(NAMES)) {
[17:39:36.566]                   name <- added[[kk]]
[17:39:36.566]                   NAME <- NAMES[[kk]]
[17:39:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.566]                     next
[17:39:36.566]                   args[[name]] <- ""
[17:39:36.566]                 }
[17:39:36.566]                 NAMES <- toupper(removed)
[17:39:36.566]                 for (kk in seq_along(NAMES)) {
[17:39:36.566]                   name <- removed[[kk]]
[17:39:36.566]                   NAME <- NAMES[[kk]]
[17:39:36.566]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.566]                     next
[17:39:36.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.566]                 }
[17:39:36.566]                 if (length(args) > 0) 
[17:39:36.566]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.566]             }
[17:39:36.566]             else {
[17:39:36.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.566]             }
[17:39:36.566]             {
[17:39:36.566]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.566]                   0L) {
[17:39:36.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.566]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.566]                   base::options(opts)
[17:39:36.566]                 }
[17:39:36.566]                 {
[17:39:36.566]                   {
[17:39:36.566]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.566]                     NULL
[17:39:36.566]                   }
[17:39:36.566]                   options(future.plan = NULL)
[17:39:36.566]                   if (is.na(NA_character_)) 
[17:39:36.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.566]                     .init = FALSE)
[17:39:36.566]                 }
[17:39:36.566]             }
[17:39:36.566]         }
[17:39:36.566]     })
[17:39:36.566]     if (TRUE) {
[17:39:36.566]         base::sink(type = "output", split = FALSE)
[17:39:36.566]         if (TRUE) {
[17:39:36.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.566]         }
[17:39:36.566]         else {
[17:39:36.566]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.566]         }
[17:39:36.566]         base::close(...future.stdout)
[17:39:36.566]         ...future.stdout <- NULL
[17:39:36.566]     }
[17:39:36.566]     ...future.result$conditions <- ...future.conditions
[17:39:36.566]     ...future.result$finished <- base::Sys.time()
[17:39:36.566]     ...future.result
[17:39:36.566] }
[17:39:36.569] MultisessionFuture started
[17:39:36.569] - Launch lazy future ... done
[17:39:36.569] run() for ‘MultisessionFuture’ ... done
[17:39:36.569] getGlobalsAndPackages() ...
[17:39:36.569] Searching for globals...
[17:39:36.570] 
[17:39:36.570] Searching for globals ... DONE
[17:39:36.570] - globals: [0] <none>
[17:39:36.570] getGlobalsAndPackages() ... DONE
[17:39:36.570] run() for ‘Future’ ...
[17:39:36.570] - state: ‘created’
[17:39:36.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.585]   - Field: ‘node’
[17:39:36.585]   - Field: ‘label’
[17:39:36.586]   - Field: ‘local’
[17:39:36.586]   - Field: ‘owner’
[17:39:36.586]   - Field: ‘envir’
[17:39:36.586]   - Field: ‘workers’
[17:39:36.586]   - Field: ‘packages’
[17:39:36.586]   - Field: ‘gc’
[17:39:36.586]   - Field: ‘conditions’
[17:39:36.586]   - Field: ‘persistent’
[17:39:36.586]   - Field: ‘expr’
[17:39:36.587]   - Field: ‘uuid’
[17:39:36.587]   - Field: ‘seed’
[17:39:36.587]   - Field: ‘version’
[17:39:36.587]   - Field: ‘result’
[17:39:36.587]   - Field: ‘asynchronous’
[17:39:36.587]   - Field: ‘calls’
[17:39:36.587]   - Field: ‘globals’
[17:39:36.587]   - Field: ‘stdout’
[17:39:36.587]   - Field: ‘earlySignal’
[17:39:36.588]   - Field: ‘lazy’
[17:39:36.588]   - Field: ‘state’
[17:39:36.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.588] - Launch lazy future ...
[17:39:36.588] Packages needed by the future expression (n = 0): <none>
[17:39:36.588] Packages needed by future strategies (n = 0): <none>
[17:39:36.589] {
[17:39:36.589]     {
[17:39:36.589]         {
[17:39:36.589]             ...future.startTime <- base::Sys.time()
[17:39:36.589]             {
[17:39:36.589]                 {
[17:39:36.589]                   {
[17:39:36.589]                     {
[17:39:36.589]                       base::local({
[17:39:36.589]                         has_future <- base::requireNamespace("future", 
[17:39:36.589]                           quietly = TRUE)
[17:39:36.589]                         if (has_future) {
[17:39:36.589]                           ns <- base::getNamespace("future")
[17:39:36.589]                           version <- ns[[".package"]][["version"]]
[17:39:36.589]                           if (is.null(version)) 
[17:39:36.589]                             version <- utils::packageVersion("future")
[17:39:36.589]                         }
[17:39:36.589]                         else {
[17:39:36.589]                           version <- NULL
[17:39:36.589]                         }
[17:39:36.589]                         if (!has_future || version < "1.8.0") {
[17:39:36.589]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.589]                             "", base::R.version$version.string), 
[17:39:36.589]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.589]                               "release", "version")], collapse = " "), 
[17:39:36.589]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.589]                             info)
[17:39:36.589]                           info <- base::paste(info, collapse = "; ")
[17:39:36.589]                           if (!has_future) {
[17:39:36.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.589]                               info)
[17:39:36.589]                           }
[17:39:36.589]                           else {
[17:39:36.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.589]                               info, version)
[17:39:36.589]                           }
[17:39:36.589]                           base::stop(msg)
[17:39:36.589]                         }
[17:39:36.589]                       })
[17:39:36.589]                     }
[17:39:36.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.589]                     base::options(mc.cores = 1L)
[17:39:36.589]                   }
[17:39:36.589]                   ...future.strategy.old <- future::plan("list")
[17:39:36.589]                   options(future.plan = NULL)
[17:39:36.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.589]                 }
[17:39:36.589]                 ...future.workdir <- getwd()
[17:39:36.589]             }
[17:39:36.589]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.589]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.589]         }
[17:39:36.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.589]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.589]             base::names(...future.oldOptions))
[17:39:36.589]     }
[17:39:36.589]     if (FALSE) {
[17:39:36.589]     }
[17:39:36.589]     else {
[17:39:36.589]         if (TRUE) {
[17:39:36.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.589]                 open = "w")
[17:39:36.589]         }
[17:39:36.589]         else {
[17:39:36.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.589]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.589]         }
[17:39:36.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.589]             base::sink(type = "output", split = FALSE)
[17:39:36.589]             base::close(...future.stdout)
[17:39:36.589]         }, add = TRUE)
[17:39:36.589]     }
[17:39:36.589]     ...future.frame <- base::sys.nframe()
[17:39:36.589]     ...future.conditions <- base::list()
[17:39:36.589]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.589]     if (FALSE) {
[17:39:36.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.589]     }
[17:39:36.589]     ...future.result <- base::tryCatch({
[17:39:36.589]         base::withCallingHandlers({
[17:39:36.589]             ...future.value <- base::withVisible(base::local({
[17:39:36.589]                 ...future.makeSendCondition <- base::local({
[17:39:36.589]                   sendCondition <- NULL
[17:39:36.589]                   function(frame = 1L) {
[17:39:36.589]                     if (is.function(sendCondition)) 
[17:39:36.589]                       return(sendCondition)
[17:39:36.589]                     ns <- getNamespace("parallel")
[17:39:36.589]                     if (exists("sendData", mode = "function", 
[17:39:36.589]                       envir = ns)) {
[17:39:36.589]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.589]                         envir = ns)
[17:39:36.589]                       envir <- sys.frame(frame)
[17:39:36.589]                       master <- NULL
[17:39:36.589]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.589]                         !identical(envir, emptyenv())) {
[17:39:36.589]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.589]                           inherits = FALSE)) {
[17:39:36.589]                           master <- get("master", mode = "list", 
[17:39:36.589]                             envir = envir, inherits = FALSE)
[17:39:36.589]                           if (inherits(master, c("SOCKnode", 
[17:39:36.589]                             "SOCK0node"))) {
[17:39:36.589]                             sendCondition <<- function(cond) {
[17:39:36.589]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.589]                                 success = TRUE)
[17:39:36.589]                               parallel_sendData(master, data)
[17:39:36.589]                             }
[17:39:36.589]                             return(sendCondition)
[17:39:36.589]                           }
[17:39:36.589]                         }
[17:39:36.589]                         frame <- frame + 1L
[17:39:36.589]                         envir <- sys.frame(frame)
[17:39:36.589]                       }
[17:39:36.589]                     }
[17:39:36.589]                     sendCondition <<- function(cond) NULL
[17:39:36.589]                   }
[17:39:36.589]                 })
[17:39:36.589]                 withCallingHandlers({
[17:39:36.589]                   NULL
[17:39:36.589]                 }, immediateCondition = function(cond) {
[17:39:36.589]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.589]                   sendCondition(cond)
[17:39:36.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.589]                   {
[17:39:36.589]                     inherits <- base::inherits
[17:39:36.589]                     invokeRestart <- base::invokeRestart
[17:39:36.589]                     is.null <- base::is.null
[17:39:36.589]                     muffled <- FALSE
[17:39:36.589]                     if (inherits(cond, "message")) {
[17:39:36.589]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.589]                       if (muffled) 
[17:39:36.589]                         invokeRestart("muffleMessage")
[17:39:36.589]                     }
[17:39:36.589]                     else if (inherits(cond, "warning")) {
[17:39:36.589]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.589]                       if (muffled) 
[17:39:36.589]                         invokeRestart("muffleWarning")
[17:39:36.589]                     }
[17:39:36.589]                     else if (inherits(cond, "condition")) {
[17:39:36.589]                       if (!is.null(pattern)) {
[17:39:36.589]                         computeRestarts <- base::computeRestarts
[17:39:36.589]                         grepl <- base::grepl
[17:39:36.589]                         restarts <- computeRestarts(cond)
[17:39:36.589]                         for (restart in restarts) {
[17:39:36.589]                           name <- restart$name
[17:39:36.589]                           if (is.null(name)) 
[17:39:36.589]                             next
[17:39:36.589]                           if (!grepl(pattern, name)) 
[17:39:36.589]                             next
[17:39:36.589]                           invokeRestart(restart)
[17:39:36.589]                           muffled <- TRUE
[17:39:36.589]                           break
[17:39:36.589]                         }
[17:39:36.589]                       }
[17:39:36.589]                     }
[17:39:36.589]                     invisible(muffled)
[17:39:36.589]                   }
[17:39:36.589]                   muffleCondition(cond)
[17:39:36.589]                 })
[17:39:36.589]             }))
[17:39:36.589]             future::FutureResult(value = ...future.value$value, 
[17:39:36.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.589]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.589]                     ...future.globalenv.names))
[17:39:36.589]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.589]         }, condition = base::local({
[17:39:36.589]             c <- base::c
[17:39:36.589]             inherits <- base::inherits
[17:39:36.589]             invokeRestart <- base::invokeRestart
[17:39:36.589]             length <- base::length
[17:39:36.589]             list <- base::list
[17:39:36.589]             seq.int <- base::seq.int
[17:39:36.589]             signalCondition <- base::signalCondition
[17:39:36.589]             sys.calls <- base::sys.calls
[17:39:36.589]             `[[` <- base::`[[`
[17:39:36.589]             `+` <- base::`+`
[17:39:36.589]             `<<-` <- base::`<<-`
[17:39:36.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.589]                   3L)]
[17:39:36.589]             }
[17:39:36.589]             function(cond) {
[17:39:36.589]                 is_error <- inherits(cond, "error")
[17:39:36.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.589]                   NULL)
[17:39:36.589]                 if (is_error) {
[17:39:36.589]                   sessionInformation <- function() {
[17:39:36.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.589]                       search = base::search(), system = base::Sys.info())
[17:39:36.589]                   }
[17:39:36.589]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.589]                     cond$call), session = sessionInformation(), 
[17:39:36.589]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.589]                   signalCondition(cond)
[17:39:36.589]                 }
[17:39:36.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.589]                 "immediateCondition"))) {
[17:39:36.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.589]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.589]                   if (TRUE && !signal) {
[17:39:36.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.589]                     {
[17:39:36.589]                       inherits <- base::inherits
[17:39:36.589]                       invokeRestart <- base::invokeRestart
[17:39:36.589]                       is.null <- base::is.null
[17:39:36.589]                       muffled <- FALSE
[17:39:36.589]                       if (inherits(cond, "message")) {
[17:39:36.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.589]                         if (muffled) 
[17:39:36.589]                           invokeRestart("muffleMessage")
[17:39:36.589]                       }
[17:39:36.589]                       else if (inherits(cond, "warning")) {
[17:39:36.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.589]                         if (muffled) 
[17:39:36.589]                           invokeRestart("muffleWarning")
[17:39:36.589]                       }
[17:39:36.589]                       else if (inherits(cond, "condition")) {
[17:39:36.589]                         if (!is.null(pattern)) {
[17:39:36.589]                           computeRestarts <- base::computeRestarts
[17:39:36.589]                           grepl <- base::grepl
[17:39:36.589]                           restarts <- computeRestarts(cond)
[17:39:36.589]                           for (restart in restarts) {
[17:39:36.589]                             name <- restart$name
[17:39:36.589]                             if (is.null(name)) 
[17:39:36.589]                               next
[17:39:36.589]                             if (!grepl(pattern, name)) 
[17:39:36.589]                               next
[17:39:36.589]                             invokeRestart(restart)
[17:39:36.589]                             muffled <- TRUE
[17:39:36.589]                             break
[17:39:36.589]                           }
[17:39:36.589]                         }
[17:39:36.589]                       }
[17:39:36.589]                       invisible(muffled)
[17:39:36.589]                     }
[17:39:36.589]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.589]                   }
[17:39:36.589]                 }
[17:39:36.589]                 else {
[17:39:36.589]                   if (TRUE) {
[17:39:36.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.589]                     {
[17:39:36.589]                       inherits <- base::inherits
[17:39:36.589]                       invokeRestart <- base::invokeRestart
[17:39:36.589]                       is.null <- base::is.null
[17:39:36.589]                       muffled <- FALSE
[17:39:36.589]                       if (inherits(cond, "message")) {
[17:39:36.589]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.589]                         if (muffled) 
[17:39:36.589]                           invokeRestart("muffleMessage")
[17:39:36.589]                       }
[17:39:36.589]                       else if (inherits(cond, "warning")) {
[17:39:36.589]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.589]                         if (muffled) 
[17:39:36.589]                           invokeRestart("muffleWarning")
[17:39:36.589]                       }
[17:39:36.589]                       else if (inherits(cond, "condition")) {
[17:39:36.589]                         if (!is.null(pattern)) {
[17:39:36.589]                           computeRestarts <- base::computeRestarts
[17:39:36.589]                           grepl <- base::grepl
[17:39:36.589]                           restarts <- computeRestarts(cond)
[17:39:36.589]                           for (restart in restarts) {
[17:39:36.589]                             name <- restart$name
[17:39:36.589]                             if (is.null(name)) 
[17:39:36.589]                               next
[17:39:36.589]                             if (!grepl(pattern, name)) 
[17:39:36.589]                               next
[17:39:36.589]                             invokeRestart(restart)
[17:39:36.589]                             muffled <- TRUE
[17:39:36.589]                             break
[17:39:36.589]                           }
[17:39:36.589]                         }
[17:39:36.589]                       }
[17:39:36.589]                       invisible(muffled)
[17:39:36.589]                     }
[17:39:36.589]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.589]                   }
[17:39:36.589]                 }
[17:39:36.589]             }
[17:39:36.589]         }))
[17:39:36.589]     }, error = function(ex) {
[17:39:36.589]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.589]                 ...future.rng), started = ...future.startTime, 
[17:39:36.589]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.589]             version = "1.8"), class = "FutureResult")
[17:39:36.589]     }, finally = {
[17:39:36.589]         if (!identical(...future.workdir, getwd())) 
[17:39:36.589]             setwd(...future.workdir)
[17:39:36.589]         {
[17:39:36.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.589]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.589]             }
[17:39:36.589]             base::options(...future.oldOptions)
[17:39:36.589]             if (.Platform$OS.type == "windows") {
[17:39:36.589]                 old_names <- names(...future.oldEnvVars)
[17:39:36.589]                 envs <- base::Sys.getenv()
[17:39:36.589]                 names <- names(envs)
[17:39:36.589]                 common <- intersect(names, old_names)
[17:39:36.589]                 added <- setdiff(names, old_names)
[17:39:36.589]                 removed <- setdiff(old_names, names)
[17:39:36.589]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.589]                   envs[common]]
[17:39:36.589]                 NAMES <- toupper(changed)
[17:39:36.589]                 args <- list()
[17:39:36.589]                 for (kk in seq_along(NAMES)) {
[17:39:36.589]                   name <- changed[[kk]]
[17:39:36.589]                   NAME <- NAMES[[kk]]
[17:39:36.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.589]                     next
[17:39:36.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.589]                 }
[17:39:36.589]                 NAMES <- toupper(added)
[17:39:36.589]                 for (kk in seq_along(NAMES)) {
[17:39:36.589]                   name <- added[[kk]]
[17:39:36.589]                   NAME <- NAMES[[kk]]
[17:39:36.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.589]                     next
[17:39:36.589]                   args[[name]] <- ""
[17:39:36.589]                 }
[17:39:36.589]                 NAMES <- toupper(removed)
[17:39:36.589]                 for (kk in seq_along(NAMES)) {
[17:39:36.589]                   name <- removed[[kk]]
[17:39:36.589]                   NAME <- NAMES[[kk]]
[17:39:36.589]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.589]                     next
[17:39:36.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.589]                 }
[17:39:36.589]                 if (length(args) > 0) 
[17:39:36.589]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.589]             }
[17:39:36.589]             else {
[17:39:36.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.589]             }
[17:39:36.589]             {
[17:39:36.589]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.589]                   0L) {
[17:39:36.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.589]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.589]                   base::options(opts)
[17:39:36.589]                 }
[17:39:36.589]                 {
[17:39:36.589]                   {
[17:39:36.589]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.589]                     NULL
[17:39:36.589]                   }
[17:39:36.589]                   options(future.plan = NULL)
[17:39:36.589]                   if (is.na(NA_character_)) 
[17:39:36.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.589]                     .init = FALSE)
[17:39:36.589]                 }
[17:39:36.589]             }
[17:39:36.589]         }
[17:39:36.589]     })
[17:39:36.589]     if (TRUE) {
[17:39:36.589]         base::sink(type = "output", split = FALSE)
[17:39:36.589]         if (TRUE) {
[17:39:36.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.589]         }
[17:39:36.589]         else {
[17:39:36.589]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.589]         }
[17:39:36.589]         base::close(...future.stdout)
[17:39:36.589]         ...future.stdout <- NULL
[17:39:36.589]     }
[17:39:36.589]     ...future.result$conditions <- ...future.conditions
[17:39:36.589]     ...future.result$finished <- base::Sys.time()
[17:39:36.589]     ...future.result
[17:39:36.589] }
[17:39:36.641] MultisessionFuture started
[17:39:36.641] - Launch lazy future ... done
[17:39:36.642] run() for ‘MultisessionFuture’ ... done
[17:39:36.642] getGlobalsAndPackages() ...
[17:39:36.642] Searching for globals...
[17:39:36.643] - globals found: [1] ‘{’
[17:39:36.644] Searching for globals ... DONE
[17:39:36.644] Resolving globals: FALSE
[17:39:36.644] 
[17:39:36.645] 
[17:39:36.645] getGlobalsAndPackages() ... DONE
[17:39:36.645] run() for ‘Future’ ...
[17:39:36.645] - state: ‘created’
[17:39:36.646] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.666] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.666]   - Field: ‘node’
[17:39:36.667]   - Field: ‘label’
[17:39:36.667]   - Field: ‘local’
[17:39:36.667]   - Field: ‘owner’
[17:39:36.667]   - Field: ‘envir’
[17:39:36.667]   - Field: ‘workers’
[17:39:36.667]   - Field: ‘packages’
[17:39:36.668]   - Field: ‘gc’
[17:39:36.668]   - Field: ‘conditions’
[17:39:36.668]   - Field: ‘persistent’
[17:39:36.668]   - Field: ‘expr’
[17:39:36.668]   - Field: ‘uuid’
[17:39:36.668]   - Field: ‘seed’
[17:39:36.669]   - Field: ‘version’
[17:39:36.669]   - Field: ‘result’
[17:39:36.669]   - Field: ‘asynchronous’
[17:39:36.669]   - Field: ‘calls’
[17:39:36.669]   - Field: ‘globals’
[17:39:36.669]   - Field: ‘stdout’
[17:39:36.670]   - Field: ‘earlySignal’
[17:39:36.670]   - Field: ‘lazy’
[17:39:36.670]   - Field: ‘state’
[17:39:36.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.670] - Launch lazy future ...
[17:39:36.671] Packages needed by the future expression (n = 0): <none>
[17:39:36.671] Packages needed by future strategies (n = 0): <none>
[17:39:36.672] {
[17:39:36.672]     {
[17:39:36.672]         {
[17:39:36.672]             ...future.startTime <- base::Sys.time()
[17:39:36.672]             {
[17:39:36.672]                 {
[17:39:36.672]                   {
[17:39:36.672]                     {
[17:39:36.672]                       base::local({
[17:39:36.672]                         has_future <- base::requireNamespace("future", 
[17:39:36.672]                           quietly = TRUE)
[17:39:36.672]                         if (has_future) {
[17:39:36.672]                           ns <- base::getNamespace("future")
[17:39:36.672]                           version <- ns[[".package"]][["version"]]
[17:39:36.672]                           if (is.null(version)) 
[17:39:36.672]                             version <- utils::packageVersion("future")
[17:39:36.672]                         }
[17:39:36.672]                         else {
[17:39:36.672]                           version <- NULL
[17:39:36.672]                         }
[17:39:36.672]                         if (!has_future || version < "1.8.0") {
[17:39:36.672]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.672]                             "", base::R.version$version.string), 
[17:39:36.672]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.672]                               "release", "version")], collapse = " "), 
[17:39:36.672]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.672]                             info)
[17:39:36.672]                           info <- base::paste(info, collapse = "; ")
[17:39:36.672]                           if (!has_future) {
[17:39:36.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.672]                               info)
[17:39:36.672]                           }
[17:39:36.672]                           else {
[17:39:36.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.672]                               info, version)
[17:39:36.672]                           }
[17:39:36.672]                           base::stop(msg)
[17:39:36.672]                         }
[17:39:36.672]                       })
[17:39:36.672]                     }
[17:39:36.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.672]                     base::options(mc.cores = 1L)
[17:39:36.672]                   }
[17:39:36.672]                   ...future.strategy.old <- future::plan("list")
[17:39:36.672]                   options(future.plan = NULL)
[17:39:36.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.672]                 }
[17:39:36.672]                 ...future.workdir <- getwd()
[17:39:36.672]             }
[17:39:36.672]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.672]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.672]         }
[17:39:36.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.672]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.672]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.672]             base::names(...future.oldOptions))
[17:39:36.672]     }
[17:39:36.672]     if (FALSE) {
[17:39:36.672]     }
[17:39:36.672]     else {
[17:39:36.672]         if (TRUE) {
[17:39:36.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.672]                 open = "w")
[17:39:36.672]         }
[17:39:36.672]         else {
[17:39:36.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.672]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.672]         }
[17:39:36.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.672]             base::sink(type = "output", split = FALSE)
[17:39:36.672]             base::close(...future.stdout)
[17:39:36.672]         }, add = TRUE)
[17:39:36.672]     }
[17:39:36.672]     ...future.frame <- base::sys.nframe()
[17:39:36.672]     ...future.conditions <- base::list()
[17:39:36.672]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.672]     if (FALSE) {
[17:39:36.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.672]     }
[17:39:36.672]     ...future.result <- base::tryCatch({
[17:39:36.672]         base::withCallingHandlers({
[17:39:36.672]             ...future.value <- base::withVisible(base::local({
[17:39:36.672]                 ...future.makeSendCondition <- base::local({
[17:39:36.672]                   sendCondition <- NULL
[17:39:36.672]                   function(frame = 1L) {
[17:39:36.672]                     if (is.function(sendCondition)) 
[17:39:36.672]                       return(sendCondition)
[17:39:36.672]                     ns <- getNamespace("parallel")
[17:39:36.672]                     if (exists("sendData", mode = "function", 
[17:39:36.672]                       envir = ns)) {
[17:39:36.672]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.672]                         envir = ns)
[17:39:36.672]                       envir <- sys.frame(frame)
[17:39:36.672]                       master <- NULL
[17:39:36.672]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.672]                         !identical(envir, emptyenv())) {
[17:39:36.672]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.672]                           inherits = FALSE)) {
[17:39:36.672]                           master <- get("master", mode = "list", 
[17:39:36.672]                             envir = envir, inherits = FALSE)
[17:39:36.672]                           if (inherits(master, c("SOCKnode", 
[17:39:36.672]                             "SOCK0node"))) {
[17:39:36.672]                             sendCondition <<- function(cond) {
[17:39:36.672]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.672]                                 success = TRUE)
[17:39:36.672]                               parallel_sendData(master, data)
[17:39:36.672]                             }
[17:39:36.672]                             return(sendCondition)
[17:39:36.672]                           }
[17:39:36.672]                         }
[17:39:36.672]                         frame <- frame + 1L
[17:39:36.672]                         envir <- sys.frame(frame)
[17:39:36.672]                       }
[17:39:36.672]                     }
[17:39:36.672]                     sendCondition <<- function(cond) NULL
[17:39:36.672]                   }
[17:39:36.672]                 })
[17:39:36.672]                 withCallingHandlers({
[17:39:36.672]                   {
[17:39:36.672]                     4
[17:39:36.672]                   }
[17:39:36.672]                 }, immediateCondition = function(cond) {
[17:39:36.672]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.672]                   sendCondition(cond)
[17:39:36.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.672]                   {
[17:39:36.672]                     inherits <- base::inherits
[17:39:36.672]                     invokeRestart <- base::invokeRestart
[17:39:36.672]                     is.null <- base::is.null
[17:39:36.672]                     muffled <- FALSE
[17:39:36.672]                     if (inherits(cond, "message")) {
[17:39:36.672]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.672]                       if (muffled) 
[17:39:36.672]                         invokeRestart("muffleMessage")
[17:39:36.672]                     }
[17:39:36.672]                     else if (inherits(cond, "warning")) {
[17:39:36.672]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.672]                       if (muffled) 
[17:39:36.672]                         invokeRestart("muffleWarning")
[17:39:36.672]                     }
[17:39:36.672]                     else if (inherits(cond, "condition")) {
[17:39:36.672]                       if (!is.null(pattern)) {
[17:39:36.672]                         computeRestarts <- base::computeRestarts
[17:39:36.672]                         grepl <- base::grepl
[17:39:36.672]                         restarts <- computeRestarts(cond)
[17:39:36.672]                         for (restart in restarts) {
[17:39:36.672]                           name <- restart$name
[17:39:36.672]                           if (is.null(name)) 
[17:39:36.672]                             next
[17:39:36.672]                           if (!grepl(pattern, name)) 
[17:39:36.672]                             next
[17:39:36.672]                           invokeRestart(restart)
[17:39:36.672]                           muffled <- TRUE
[17:39:36.672]                           break
[17:39:36.672]                         }
[17:39:36.672]                       }
[17:39:36.672]                     }
[17:39:36.672]                     invisible(muffled)
[17:39:36.672]                   }
[17:39:36.672]                   muffleCondition(cond)
[17:39:36.672]                 })
[17:39:36.672]             }))
[17:39:36.672]             future::FutureResult(value = ...future.value$value, 
[17:39:36.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.672]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.672]                     ...future.globalenv.names))
[17:39:36.672]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.672]         }, condition = base::local({
[17:39:36.672]             c <- base::c
[17:39:36.672]             inherits <- base::inherits
[17:39:36.672]             invokeRestart <- base::invokeRestart
[17:39:36.672]             length <- base::length
[17:39:36.672]             list <- base::list
[17:39:36.672]             seq.int <- base::seq.int
[17:39:36.672]             signalCondition <- base::signalCondition
[17:39:36.672]             sys.calls <- base::sys.calls
[17:39:36.672]             `[[` <- base::`[[`
[17:39:36.672]             `+` <- base::`+`
[17:39:36.672]             `<<-` <- base::`<<-`
[17:39:36.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.672]                   3L)]
[17:39:36.672]             }
[17:39:36.672]             function(cond) {
[17:39:36.672]                 is_error <- inherits(cond, "error")
[17:39:36.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.672]                   NULL)
[17:39:36.672]                 if (is_error) {
[17:39:36.672]                   sessionInformation <- function() {
[17:39:36.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.672]                       search = base::search(), system = base::Sys.info())
[17:39:36.672]                   }
[17:39:36.672]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.672]                     cond$call), session = sessionInformation(), 
[17:39:36.672]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.672]                   signalCondition(cond)
[17:39:36.672]                 }
[17:39:36.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.672]                 "immediateCondition"))) {
[17:39:36.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.672]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.672]                   if (TRUE && !signal) {
[17:39:36.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.672]                     {
[17:39:36.672]                       inherits <- base::inherits
[17:39:36.672]                       invokeRestart <- base::invokeRestart
[17:39:36.672]                       is.null <- base::is.null
[17:39:36.672]                       muffled <- FALSE
[17:39:36.672]                       if (inherits(cond, "message")) {
[17:39:36.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.672]                         if (muffled) 
[17:39:36.672]                           invokeRestart("muffleMessage")
[17:39:36.672]                       }
[17:39:36.672]                       else if (inherits(cond, "warning")) {
[17:39:36.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.672]                         if (muffled) 
[17:39:36.672]                           invokeRestart("muffleWarning")
[17:39:36.672]                       }
[17:39:36.672]                       else if (inherits(cond, "condition")) {
[17:39:36.672]                         if (!is.null(pattern)) {
[17:39:36.672]                           computeRestarts <- base::computeRestarts
[17:39:36.672]                           grepl <- base::grepl
[17:39:36.672]                           restarts <- computeRestarts(cond)
[17:39:36.672]                           for (restart in restarts) {
[17:39:36.672]                             name <- restart$name
[17:39:36.672]                             if (is.null(name)) 
[17:39:36.672]                               next
[17:39:36.672]                             if (!grepl(pattern, name)) 
[17:39:36.672]                               next
[17:39:36.672]                             invokeRestart(restart)
[17:39:36.672]                             muffled <- TRUE
[17:39:36.672]                             break
[17:39:36.672]                           }
[17:39:36.672]                         }
[17:39:36.672]                       }
[17:39:36.672]                       invisible(muffled)
[17:39:36.672]                     }
[17:39:36.672]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.672]                   }
[17:39:36.672]                 }
[17:39:36.672]                 else {
[17:39:36.672]                   if (TRUE) {
[17:39:36.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.672]                     {
[17:39:36.672]                       inherits <- base::inherits
[17:39:36.672]                       invokeRestart <- base::invokeRestart
[17:39:36.672]                       is.null <- base::is.null
[17:39:36.672]                       muffled <- FALSE
[17:39:36.672]                       if (inherits(cond, "message")) {
[17:39:36.672]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.672]                         if (muffled) 
[17:39:36.672]                           invokeRestart("muffleMessage")
[17:39:36.672]                       }
[17:39:36.672]                       else if (inherits(cond, "warning")) {
[17:39:36.672]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.672]                         if (muffled) 
[17:39:36.672]                           invokeRestart("muffleWarning")
[17:39:36.672]                       }
[17:39:36.672]                       else if (inherits(cond, "condition")) {
[17:39:36.672]                         if (!is.null(pattern)) {
[17:39:36.672]                           computeRestarts <- base::computeRestarts
[17:39:36.672]                           grepl <- base::grepl
[17:39:36.672]                           restarts <- computeRestarts(cond)
[17:39:36.672]                           for (restart in restarts) {
[17:39:36.672]                             name <- restart$name
[17:39:36.672]                             if (is.null(name)) 
[17:39:36.672]                               next
[17:39:36.672]                             if (!grepl(pattern, name)) 
[17:39:36.672]                               next
[17:39:36.672]                             invokeRestart(restart)
[17:39:36.672]                             muffled <- TRUE
[17:39:36.672]                             break
[17:39:36.672]                           }
[17:39:36.672]                         }
[17:39:36.672]                       }
[17:39:36.672]                       invisible(muffled)
[17:39:36.672]                     }
[17:39:36.672]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.672]                   }
[17:39:36.672]                 }
[17:39:36.672]             }
[17:39:36.672]         }))
[17:39:36.672]     }, error = function(ex) {
[17:39:36.672]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.672]                 ...future.rng), started = ...future.startTime, 
[17:39:36.672]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.672]             version = "1.8"), class = "FutureResult")
[17:39:36.672]     }, finally = {
[17:39:36.672]         if (!identical(...future.workdir, getwd())) 
[17:39:36.672]             setwd(...future.workdir)
[17:39:36.672]         {
[17:39:36.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.672]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.672]             }
[17:39:36.672]             base::options(...future.oldOptions)
[17:39:36.672]             if (.Platform$OS.type == "windows") {
[17:39:36.672]                 old_names <- names(...future.oldEnvVars)
[17:39:36.672]                 envs <- base::Sys.getenv()
[17:39:36.672]                 names <- names(envs)
[17:39:36.672]                 common <- intersect(names, old_names)
[17:39:36.672]                 added <- setdiff(names, old_names)
[17:39:36.672]                 removed <- setdiff(old_names, names)
[17:39:36.672]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.672]                   envs[common]]
[17:39:36.672]                 NAMES <- toupper(changed)
[17:39:36.672]                 args <- list()
[17:39:36.672]                 for (kk in seq_along(NAMES)) {
[17:39:36.672]                   name <- changed[[kk]]
[17:39:36.672]                   NAME <- NAMES[[kk]]
[17:39:36.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.672]                     next
[17:39:36.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.672]                 }
[17:39:36.672]                 NAMES <- toupper(added)
[17:39:36.672]                 for (kk in seq_along(NAMES)) {
[17:39:36.672]                   name <- added[[kk]]
[17:39:36.672]                   NAME <- NAMES[[kk]]
[17:39:36.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.672]                     next
[17:39:36.672]                   args[[name]] <- ""
[17:39:36.672]                 }
[17:39:36.672]                 NAMES <- toupper(removed)
[17:39:36.672]                 for (kk in seq_along(NAMES)) {
[17:39:36.672]                   name <- removed[[kk]]
[17:39:36.672]                   NAME <- NAMES[[kk]]
[17:39:36.672]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.672]                     next
[17:39:36.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.672]                 }
[17:39:36.672]                 if (length(args) > 0) 
[17:39:36.672]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.672]             }
[17:39:36.672]             else {
[17:39:36.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.672]             }
[17:39:36.672]             {
[17:39:36.672]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.672]                   0L) {
[17:39:36.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.672]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.672]                   base::options(opts)
[17:39:36.672]                 }
[17:39:36.672]                 {
[17:39:36.672]                   {
[17:39:36.672]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.672]                     NULL
[17:39:36.672]                   }
[17:39:36.672]                   options(future.plan = NULL)
[17:39:36.672]                   if (is.na(NA_character_)) 
[17:39:36.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.672]                     .init = FALSE)
[17:39:36.672]                 }
[17:39:36.672]             }
[17:39:36.672]         }
[17:39:36.672]     })
[17:39:36.672]     if (TRUE) {
[17:39:36.672]         base::sink(type = "output", split = FALSE)
[17:39:36.672]         if (TRUE) {
[17:39:36.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.672]         }
[17:39:36.672]         else {
[17:39:36.672]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.672]         }
[17:39:36.672]         base::close(...future.stdout)
[17:39:36.672]         ...future.stdout <- NULL
[17:39:36.672]     }
[17:39:36.672]     ...future.result$conditions <- ...future.conditions
[17:39:36.672]     ...future.result$finished <- base::Sys.time()
[17:39:36.672]     ...future.result
[17:39:36.672] }
[17:39:36.676] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:36.687] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.687] - Validating connection of MultisessionFuture
[17:39:36.687] - received message: FutureResult
[17:39:36.688] - Received FutureResult
[17:39:36.688] - Erased future from FutureRegistry
[17:39:36.688] result() for ClusterFuture ...
[17:39:36.688] - result already collected: FutureResult
[17:39:36.688] result() for ClusterFuture ... done
[17:39:36.688] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.689] result() for ClusterFuture ...
[17:39:36.689] - result already collected: FutureResult
[17:39:36.689] result() for ClusterFuture ... done
[17:39:36.689] result() for ClusterFuture ...
[17:39:36.689] - result already collected: FutureResult
[17:39:36.689] result() for ClusterFuture ... done
[17:39:36.690] MultisessionFuture started
[17:39:36.690] - Launch lazy future ... done
[17:39:36.690] run() for ‘MultisessionFuture’ ... done
<environment: 0x55adf08b4768> 
<environment: 0x55adf11ac6c8> 
[17:39:36.692] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.692] - Validating connection of MultisessionFuture
[17:39:36.692] - received message: FutureResult
[17:39:36.693] - Received FutureResult
[17:39:36.693] - Erased future from FutureRegistry
[17:39:36.693] result() for ClusterFuture ...
[17:39:36.693] - result already collected: FutureResult
[17:39:36.693] result() for ClusterFuture ... done
[17:39:36.693] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.695] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.695] - Validating connection of MultisessionFuture
[17:39:36.696] - received message: FutureResult
[17:39:36.696] - Received FutureResult
[17:39:36.696] - Erased future from FutureRegistry
[17:39:36.696] result() for ClusterFuture ...
[17:39:36.696] - result already collected: FutureResult
[17:39:36.696] result() for ClusterFuture ... done
[17:39:36.696] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.697] resolve() on environment ...
[17:39:36.698]  recursive: 0
[17:39:36.698]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.698] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.698] - nx: 4
[17:39:36.698] - relay: TRUE
[17:39:36.698] - stdout: TRUE
[17:39:36.698] - signal: TRUE
[17:39:36.699] - resignal: FALSE
[17:39:36.699] - force: TRUE
[17:39:36.699] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.699] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.699]  - until=2
[17:39:36.699]  - relaying element #2
[17:39:36.699] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.699] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.699] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.699]  length: 3 (resolved future 1)
[17:39:36.699] Future #2
[17:39:36.700] result() for ClusterFuture ...
[17:39:36.700] - result already collected: FutureResult
[17:39:36.700] result() for ClusterFuture ... done
[17:39:36.700] result() for ClusterFuture ...
[17:39:36.700] - result already collected: FutureResult
[17:39:36.700] result() for ClusterFuture ... done
[17:39:36.700] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:36.700] - nx: 4
[17:39:36.700] - relay: TRUE
[17:39:36.700] - stdout: TRUE
[17:39:36.700] - signal: TRUE
[17:39:36.701] - resignal: FALSE
[17:39:36.701] - force: TRUE
[17:39:36.701] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.701] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.701]  - until=2
[17:39:36.701]  - relaying element #2
[17:39:36.701] result() for ClusterFuture ...
[17:39:36.701] - result already collected: FutureResult
[17:39:36.701] result() for ClusterFuture ... done
[17:39:36.701] result() for ClusterFuture ...
[17:39:36.701] - result already collected: FutureResult
[17:39:36.701] result() for ClusterFuture ... done
[17:39:36.702] result() for ClusterFuture ...
[17:39:36.702] - result already collected: FutureResult
[17:39:36.702] result() for ClusterFuture ... done
[17:39:36.702] result() for ClusterFuture ...
[17:39:36.702] - result already collected: FutureResult
[17:39:36.702] result() for ClusterFuture ... done
[17:39:36.702] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.702] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.702] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:36.702]  length: 2 (resolved future 2)
[17:39:36.703] Future #3
[17:39:36.703] result() for ClusterFuture ...
[17:39:36.703] - result already collected: FutureResult
[17:39:36.703] result() for ClusterFuture ... done
[17:39:36.703] result() for ClusterFuture ...
[17:39:36.703] - result already collected: FutureResult
[17:39:36.703] result() for ClusterFuture ... done
[17:39:36.703] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:36.703] - nx: 4
[17:39:36.703] - relay: TRUE
[17:39:36.703] - stdout: TRUE
[17:39:36.703] - signal: TRUE
[17:39:36.704] - resignal: FALSE
[17:39:36.704] - force: TRUE
[17:39:36.704] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.704] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.704]  - until=3
[17:39:36.704]  - relaying element #3
[17:39:36.704] result() for ClusterFuture ...
[17:39:36.704] - result already collected: FutureResult
[17:39:36.704] result() for ClusterFuture ... done
[17:39:36.704] result() for ClusterFuture ...
[17:39:36.704] - result already collected: FutureResult
[17:39:36.704] result() for ClusterFuture ... done
[17:39:36.705] result() for ClusterFuture ...
[17:39:36.705] - result already collected: FutureResult
[17:39:36.705] result() for ClusterFuture ... done
[17:39:36.705] result() for ClusterFuture ...
[17:39:36.705] - result already collected: FutureResult
[17:39:36.705] result() for ClusterFuture ... done
[17:39:36.705] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.705] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.705] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:36.705]  length: 1 (resolved future 3)
[17:39:36.705] Future #4
[17:39:36.706] result() for ClusterFuture ...
[17:39:36.706] - result already collected: FutureResult
[17:39:36.706] result() for ClusterFuture ... done
[17:39:36.706] result() for ClusterFuture ...
[17:39:36.706] - result already collected: FutureResult
[17:39:36.706] result() for ClusterFuture ... done
[17:39:36.706] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:36.706] - nx: 4
[17:39:36.706] - relay: TRUE
[17:39:36.706] - stdout: TRUE
[17:39:36.706] - signal: TRUE
[17:39:36.706] - resignal: FALSE
[17:39:36.707] - force: TRUE
[17:39:36.707] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.707] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.707]  - until=4
[17:39:36.707]  - relaying element #4
[17:39:36.707] result() for ClusterFuture ...
[17:39:36.707] - result already collected: FutureResult
[17:39:36.707] result() for ClusterFuture ... done
[17:39:36.707] result() for ClusterFuture ...
[17:39:36.707] - result already collected: FutureResult
[17:39:36.707] result() for ClusterFuture ... done
[17:39:36.708] result() for ClusterFuture ...
[17:39:36.708] - result already collected: FutureResult
[17:39:36.708] result() for ClusterFuture ... done
[17:39:36.708] result() for ClusterFuture ...
[17:39:36.708] - result already collected: FutureResult
[17:39:36.708] result() for ClusterFuture ... done
[17:39:36.708] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.708] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.708] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:36.708]  length: 0 (resolved future 4)
[17:39:36.708] Relaying remaining futures
[17:39:36.708] signalConditionsASAP(NULL, pos=0) ...
[17:39:36.709] - nx: 4
[17:39:36.709] - relay: TRUE
[17:39:36.709] - stdout: TRUE
[17:39:36.709] - signal: TRUE
[17:39:36.709] - resignal: FALSE
[17:39:36.709] - force: TRUE
[17:39:36.709] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.709] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:36.709] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.709] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.709] signalConditionsASAP(NULL, pos=0) ... done
[17:39:36.710] resolve() on environment ... DONE
[17:39:36.710] result() for ClusterFuture ...
[17:39:36.710] - result already collected: FutureResult
[17:39:36.710] result() for ClusterFuture ... done
[17:39:36.710] result() for ClusterFuture ...
[17:39:36.710] - result already collected: FutureResult
[17:39:36.710] result() for ClusterFuture ... done
[17:39:36.710] result() for ClusterFuture ...
[17:39:36.710] - result already collected: FutureResult
[17:39:36.710] result() for ClusterFuture ... done
[17:39:36.710] result() for ClusterFuture ...
[17:39:36.710] - result already collected: FutureResult
[17:39:36.711] result() for ClusterFuture ... done
[17:39:36.711] result() for ClusterFuture ...
[17:39:36.711] - result already collected: FutureResult
[17:39:36.711] result() for ClusterFuture ... done
[17:39:36.711] result() for ClusterFuture ...
[17:39:36.711] - result already collected: FutureResult
[17:39:36.711] result() for ClusterFuture ... done
<environment: 0x55adf13a7e88> 
Dimensions: c(1, 6)
[17:39:36.711] getGlobalsAndPackages() ...
[17:39:36.712] Searching for globals...
[17:39:36.712] 
[17:39:36.712] Searching for globals ... DONE
[17:39:36.712] - globals: [0] <none>
[17:39:36.712] getGlobalsAndPackages() ... DONE
[17:39:36.712] run() for ‘Future’ ...
[17:39:36.713] - state: ‘created’
[17:39:36.713] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.727]   - Field: ‘node’
[17:39:36.727]   - Field: ‘label’
[17:39:36.728]   - Field: ‘local’
[17:39:36.728]   - Field: ‘owner’
[17:39:36.728]   - Field: ‘envir’
[17:39:36.728]   - Field: ‘workers’
[17:39:36.728]   - Field: ‘packages’
[17:39:36.728]   - Field: ‘gc’
[17:39:36.728]   - Field: ‘conditions’
[17:39:36.728]   - Field: ‘persistent’
[17:39:36.728]   - Field: ‘expr’
[17:39:36.728]   - Field: ‘uuid’
[17:39:36.729]   - Field: ‘seed’
[17:39:36.729]   - Field: ‘version’
[17:39:36.729]   - Field: ‘result’
[17:39:36.729]   - Field: ‘asynchronous’
[17:39:36.729]   - Field: ‘calls’
[17:39:36.729]   - Field: ‘globals’
[17:39:36.729]   - Field: ‘stdout’
[17:39:36.729]   - Field: ‘earlySignal’
[17:39:36.729]   - Field: ‘lazy’
[17:39:36.729]   - Field: ‘state’
[17:39:36.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.730] - Launch lazy future ...
[17:39:36.730] Packages needed by the future expression (n = 0): <none>
[17:39:36.730] Packages needed by future strategies (n = 0): <none>
[17:39:36.730] {
[17:39:36.730]     {
[17:39:36.730]         {
[17:39:36.730]             ...future.startTime <- base::Sys.time()
[17:39:36.730]             {
[17:39:36.730]                 {
[17:39:36.730]                   {
[17:39:36.730]                     {
[17:39:36.730]                       base::local({
[17:39:36.730]                         has_future <- base::requireNamespace("future", 
[17:39:36.730]                           quietly = TRUE)
[17:39:36.730]                         if (has_future) {
[17:39:36.730]                           ns <- base::getNamespace("future")
[17:39:36.730]                           version <- ns[[".package"]][["version"]]
[17:39:36.730]                           if (is.null(version)) 
[17:39:36.730]                             version <- utils::packageVersion("future")
[17:39:36.730]                         }
[17:39:36.730]                         else {
[17:39:36.730]                           version <- NULL
[17:39:36.730]                         }
[17:39:36.730]                         if (!has_future || version < "1.8.0") {
[17:39:36.730]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.730]                             "", base::R.version$version.string), 
[17:39:36.730]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.730]                               "release", "version")], collapse = " "), 
[17:39:36.730]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.730]                             info)
[17:39:36.730]                           info <- base::paste(info, collapse = "; ")
[17:39:36.730]                           if (!has_future) {
[17:39:36.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.730]                               info)
[17:39:36.730]                           }
[17:39:36.730]                           else {
[17:39:36.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.730]                               info, version)
[17:39:36.730]                           }
[17:39:36.730]                           base::stop(msg)
[17:39:36.730]                         }
[17:39:36.730]                       })
[17:39:36.730]                     }
[17:39:36.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.730]                     base::options(mc.cores = 1L)
[17:39:36.730]                   }
[17:39:36.730]                   ...future.strategy.old <- future::plan("list")
[17:39:36.730]                   options(future.plan = NULL)
[17:39:36.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.730]                 }
[17:39:36.730]                 ...future.workdir <- getwd()
[17:39:36.730]             }
[17:39:36.730]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.730]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.730]         }
[17:39:36.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.730]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.730]             base::names(...future.oldOptions))
[17:39:36.730]     }
[17:39:36.730]     if (FALSE) {
[17:39:36.730]     }
[17:39:36.730]     else {
[17:39:36.730]         if (TRUE) {
[17:39:36.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.730]                 open = "w")
[17:39:36.730]         }
[17:39:36.730]         else {
[17:39:36.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.730]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.730]         }
[17:39:36.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.730]             base::sink(type = "output", split = FALSE)
[17:39:36.730]             base::close(...future.stdout)
[17:39:36.730]         }, add = TRUE)
[17:39:36.730]     }
[17:39:36.730]     ...future.frame <- base::sys.nframe()
[17:39:36.730]     ...future.conditions <- base::list()
[17:39:36.730]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.730]     if (FALSE) {
[17:39:36.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.730]     }
[17:39:36.730]     ...future.result <- base::tryCatch({
[17:39:36.730]         base::withCallingHandlers({
[17:39:36.730]             ...future.value <- base::withVisible(base::local({
[17:39:36.730]                 ...future.makeSendCondition <- base::local({
[17:39:36.730]                   sendCondition <- NULL
[17:39:36.730]                   function(frame = 1L) {
[17:39:36.730]                     if (is.function(sendCondition)) 
[17:39:36.730]                       return(sendCondition)
[17:39:36.730]                     ns <- getNamespace("parallel")
[17:39:36.730]                     if (exists("sendData", mode = "function", 
[17:39:36.730]                       envir = ns)) {
[17:39:36.730]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.730]                         envir = ns)
[17:39:36.730]                       envir <- sys.frame(frame)
[17:39:36.730]                       master <- NULL
[17:39:36.730]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.730]                         !identical(envir, emptyenv())) {
[17:39:36.730]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.730]                           inherits = FALSE)) {
[17:39:36.730]                           master <- get("master", mode = "list", 
[17:39:36.730]                             envir = envir, inherits = FALSE)
[17:39:36.730]                           if (inherits(master, c("SOCKnode", 
[17:39:36.730]                             "SOCK0node"))) {
[17:39:36.730]                             sendCondition <<- function(cond) {
[17:39:36.730]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.730]                                 success = TRUE)
[17:39:36.730]                               parallel_sendData(master, data)
[17:39:36.730]                             }
[17:39:36.730]                             return(sendCondition)
[17:39:36.730]                           }
[17:39:36.730]                         }
[17:39:36.730]                         frame <- frame + 1L
[17:39:36.730]                         envir <- sys.frame(frame)
[17:39:36.730]                       }
[17:39:36.730]                     }
[17:39:36.730]                     sendCondition <<- function(cond) NULL
[17:39:36.730]                   }
[17:39:36.730]                 })
[17:39:36.730]                 withCallingHandlers({
[17:39:36.730]                   2
[17:39:36.730]                 }, immediateCondition = function(cond) {
[17:39:36.730]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.730]                   sendCondition(cond)
[17:39:36.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.730]                   {
[17:39:36.730]                     inherits <- base::inherits
[17:39:36.730]                     invokeRestart <- base::invokeRestart
[17:39:36.730]                     is.null <- base::is.null
[17:39:36.730]                     muffled <- FALSE
[17:39:36.730]                     if (inherits(cond, "message")) {
[17:39:36.730]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.730]                       if (muffled) 
[17:39:36.730]                         invokeRestart("muffleMessage")
[17:39:36.730]                     }
[17:39:36.730]                     else if (inherits(cond, "warning")) {
[17:39:36.730]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.730]                       if (muffled) 
[17:39:36.730]                         invokeRestart("muffleWarning")
[17:39:36.730]                     }
[17:39:36.730]                     else if (inherits(cond, "condition")) {
[17:39:36.730]                       if (!is.null(pattern)) {
[17:39:36.730]                         computeRestarts <- base::computeRestarts
[17:39:36.730]                         grepl <- base::grepl
[17:39:36.730]                         restarts <- computeRestarts(cond)
[17:39:36.730]                         for (restart in restarts) {
[17:39:36.730]                           name <- restart$name
[17:39:36.730]                           if (is.null(name)) 
[17:39:36.730]                             next
[17:39:36.730]                           if (!grepl(pattern, name)) 
[17:39:36.730]                             next
[17:39:36.730]                           invokeRestart(restart)
[17:39:36.730]                           muffled <- TRUE
[17:39:36.730]                           break
[17:39:36.730]                         }
[17:39:36.730]                       }
[17:39:36.730]                     }
[17:39:36.730]                     invisible(muffled)
[17:39:36.730]                   }
[17:39:36.730]                   muffleCondition(cond)
[17:39:36.730]                 })
[17:39:36.730]             }))
[17:39:36.730]             future::FutureResult(value = ...future.value$value, 
[17:39:36.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.730]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.730]                     ...future.globalenv.names))
[17:39:36.730]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.730]         }, condition = base::local({
[17:39:36.730]             c <- base::c
[17:39:36.730]             inherits <- base::inherits
[17:39:36.730]             invokeRestart <- base::invokeRestart
[17:39:36.730]             length <- base::length
[17:39:36.730]             list <- base::list
[17:39:36.730]             seq.int <- base::seq.int
[17:39:36.730]             signalCondition <- base::signalCondition
[17:39:36.730]             sys.calls <- base::sys.calls
[17:39:36.730]             `[[` <- base::`[[`
[17:39:36.730]             `+` <- base::`+`
[17:39:36.730]             `<<-` <- base::`<<-`
[17:39:36.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.730]                   3L)]
[17:39:36.730]             }
[17:39:36.730]             function(cond) {
[17:39:36.730]                 is_error <- inherits(cond, "error")
[17:39:36.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.730]                   NULL)
[17:39:36.730]                 if (is_error) {
[17:39:36.730]                   sessionInformation <- function() {
[17:39:36.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.730]                       search = base::search(), system = base::Sys.info())
[17:39:36.730]                   }
[17:39:36.730]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.730]                     cond$call), session = sessionInformation(), 
[17:39:36.730]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.730]                   signalCondition(cond)
[17:39:36.730]                 }
[17:39:36.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.730]                 "immediateCondition"))) {
[17:39:36.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.730]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.730]                   if (TRUE && !signal) {
[17:39:36.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.730]                     {
[17:39:36.730]                       inherits <- base::inherits
[17:39:36.730]                       invokeRestart <- base::invokeRestart
[17:39:36.730]                       is.null <- base::is.null
[17:39:36.730]                       muffled <- FALSE
[17:39:36.730]                       if (inherits(cond, "message")) {
[17:39:36.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.730]                         if (muffled) 
[17:39:36.730]                           invokeRestart("muffleMessage")
[17:39:36.730]                       }
[17:39:36.730]                       else if (inherits(cond, "warning")) {
[17:39:36.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.730]                         if (muffled) 
[17:39:36.730]                           invokeRestart("muffleWarning")
[17:39:36.730]                       }
[17:39:36.730]                       else if (inherits(cond, "condition")) {
[17:39:36.730]                         if (!is.null(pattern)) {
[17:39:36.730]                           computeRestarts <- base::computeRestarts
[17:39:36.730]                           grepl <- base::grepl
[17:39:36.730]                           restarts <- computeRestarts(cond)
[17:39:36.730]                           for (restart in restarts) {
[17:39:36.730]                             name <- restart$name
[17:39:36.730]                             if (is.null(name)) 
[17:39:36.730]                               next
[17:39:36.730]                             if (!grepl(pattern, name)) 
[17:39:36.730]                               next
[17:39:36.730]                             invokeRestart(restart)
[17:39:36.730]                             muffled <- TRUE
[17:39:36.730]                             break
[17:39:36.730]                           }
[17:39:36.730]                         }
[17:39:36.730]                       }
[17:39:36.730]                       invisible(muffled)
[17:39:36.730]                     }
[17:39:36.730]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.730]                   }
[17:39:36.730]                 }
[17:39:36.730]                 else {
[17:39:36.730]                   if (TRUE) {
[17:39:36.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.730]                     {
[17:39:36.730]                       inherits <- base::inherits
[17:39:36.730]                       invokeRestart <- base::invokeRestart
[17:39:36.730]                       is.null <- base::is.null
[17:39:36.730]                       muffled <- FALSE
[17:39:36.730]                       if (inherits(cond, "message")) {
[17:39:36.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.730]                         if (muffled) 
[17:39:36.730]                           invokeRestart("muffleMessage")
[17:39:36.730]                       }
[17:39:36.730]                       else if (inherits(cond, "warning")) {
[17:39:36.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.730]                         if (muffled) 
[17:39:36.730]                           invokeRestart("muffleWarning")
[17:39:36.730]                       }
[17:39:36.730]                       else if (inherits(cond, "condition")) {
[17:39:36.730]                         if (!is.null(pattern)) {
[17:39:36.730]                           computeRestarts <- base::computeRestarts
[17:39:36.730]                           grepl <- base::grepl
[17:39:36.730]                           restarts <- computeRestarts(cond)
[17:39:36.730]                           for (restart in restarts) {
[17:39:36.730]                             name <- restart$name
[17:39:36.730]                             if (is.null(name)) 
[17:39:36.730]                               next
[17:39:36.730]                             if (!grepl(pattern, name)) 
[17:39:36.730]                               next
[17:39:36.730]                             invokeRestart(restart)
[17:39:36.730]                             muffled <- TRUE
[17:39:36.730]                             break
[17:39:36.730]                           }
[17:39:36.730]                         }
[17:39:36.730]                       }
[17:39:36.730]                       invisible(muffled)
[17:39:36.730]                     }
[17:39:36.730]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.730]                   }
[17:39:36.730]                 }
[17:39:36.730]             }
[17:39:36.730]         }))
[17:39:36.730]     }, error = function(ex) {
[17:39:36.730]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.730]                 ...future.rng), started = ...future.startTime, 
[17:39:36.730]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.730]             version = "1.8"), class = "FutureResult")
[17:39:36.730]     }, finally = {
[17:39:36.730]         if (!identical(...future.workdir, getwd())) 
[17:39:36.730]             setwd(...future.workdir)
[17:39:36.730]         {
[17:39:36.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.730]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.730]             }
[17:39:36.730]             base::options(...future.oldOptions)
[17:39:36.730]             if (.Platform$OS.type == "windows") {
[17:39:36.730]                 old_names <- names(...future.oldEnvVars)
[17:39:36.730]                 envs <- base::Sys.getenv()
[17:39:36.730]                 names <- names(envs)
[17:39:36.730]                 common <- intersect(names, old_names)
[17:39:36.730]                 added <- setdiff(names, old_names)
[17:39:36.730]                 removed <- setdiff(old_names, names)
[17:39:36.730]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.730]                   envs[common]]
[17:39:36.730]                 NAMES <- toupper(changed)
[17:39:36.730]                 args <- list()
[17:39:36.730]                 for (kk in seq_along(NAMES)) {
[17:39:36.730]                   name <- changed[[kk]]
[17:39:36.730]                   NAME <- NAMES[[kk]]
[17:39:36.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.730]                     next
[17:39:36.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.730]                 }
[17:39:36.730]                 NAMES <- toupper(added)
[17:39:36.730]                 for (kk in seq_along(NAMES)) {
[17:39:36.730]                   name <- added[[kk]]
[17:39:36.730]                   NAME <- NAMES[[kk]]
[17:39:36.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.730]                     next
[17:39:36.730]                   args[[name]] <- ""
[17:39:36.730]                 }
[17:39:36.730]                 NAMES <- toupper(removed)
[17:39:36.730]                 for (kk in seq_along(NAMES)) {
[17:39:36.730]                   name <- removed[[kk]]
[17:39:36.730]                   NAME <- NAMES[[kk]]
[17:39:36.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.730]                     next
[17:39:36.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.730]                 }
[17:39:36.730]                 if (length(args) > 0) 
[17:39:36.730]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.730]             }
[17:39:36.730]             else {
[17:39:36.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.730]             }
[17:39:36.730]             {
[17:39:36.730]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.730]                   0L) {
[17:39:36.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.730]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.730]                   base::options(opts)
[17:39:36.730]                 }
[17:39:36.730]                 {
[17:39:36.730]                   {
[17:39:36.730]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.730]                     NULL
[17:39:36.730]                   }
[17:39:36.730]                   options(future.plan = NULL)
[17:39:36.730]                   if (is.na(NA_character_)) 
[17:39:36.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.730]                     .init = FALSE)
[17:39:36.730]                 }
[17:39:36.730]             }
[17:39:36.730]         }
[17:39:36.730]     })
[17:39:36.730]     if (TRUE) {
[17:39:36.730]         base::sink(type = "output", split = FALSE)
[17:39:36.730]         if (TRUE) {
[17:39:36.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.730]         }
[17:39:36.730]         else {
[17:39:36.730]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.730]         }
[17:39:36.730]         base::close(...future.stdout)
[17:39:36.730]         ...future.stdout <- NULL
[17:39:36.730]     }
[17:39:36.730]     ...future.result$conditions <- ...future.conditions
[17:39:36.730]     ...future.result$finished <- base::Sys.time()
[17:39:36.730]     ...future.result
[17:39:36.730] }
[17:39:36.734] MultisessionFuture started
[17:39:36.734] - Launch lazy future ... done
[17:39:36.734] run() for ‘MultisessionFuture’ ... done
[17:39:36.734] getGlobalsAndPackages() ...
[17:39:36.734] Searching for globals...
[17:39:36.734] 
[17:39:36.734] Searching for globals ... DONE
[17:39:36.735] - globals: [0] <none>
[17:39:36.735] getGlobalsAndPackages() ... DONE
[17:39:36.735] run() for ‘Future’ ...
[17:39:36.735] - state: ‘created’
[17:39:36.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.749]   - Field: ‘node’
[17:39:36.749]   - Field: ‘label’
[17:39:36.749]   - Field: ‘local’
[17:39:36.749]   - Field: ‘owner’
[17:39:36.749]   - Field: ‘envir’
[17:39:36.749]   - Field: ‘workers’
[17:39:36.750]   - Field: ‘packages’
[17:39:36.750]   - Field: ‘gc’
[17:39:36.750]   - Field: ‘conditions’
[17:39:36.750]   - Field: ‘persistent’
[17:39:36.750]   - Field: ‘expr’
[17:39:36.750]   - Field: ‘uuid’
[17:39:36.750]   - Field: ‘seed’
[17:39:36.750]   - Field: ‘version’
[17:39:36.750]   - Field: ‘result’
[17:39:36.750]   - Field: ‘asynchronous’
[17:39:36.750]   - Field: ‘calls’
[17:39:36.750]   - Field: ‘globals’
[17:39:36.751]   - Field: ‘stdout’
[17:39:36.751]   - Field: ‘earlySignal’
[17:39:36.751]   - Field: ‘lazy’
[17:39:36.751]   - Field: ‘state’
[17:39:36.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.751] - Launch lazy future ...
[17:39:36.751] Packages needed by the future expression (n = 0): <none>
[17:39:36.751] Packages needed by future strategies (n = 0): <none>
[17:39:36.752] {
[17:39:36.752]     {
[17:39:36.752]         {
[17:39:36.752]             ...future.startTime <- base::Sys.time()
[17:39:36.752]             {
[17:39:36.752]                 {
[17:39:36.752]                   {
[17:39:36.752]                     {
[17:39:36.752]                       base::local({
[17:39:36.752]                         has_future <- base::requireNamespace("future", 
[17:39:36.752]                           quietly = TRUE)
[17:39:36.752]                         if (has_future) {
[17:39:36.752]                           ns <- base::getNamespace("future")
[17:39:36.752]                           version <- ns[[".package"]][["version"]]
[17:39:36.752]                           if (is.null(version)) 
[17:39:36.752]                             version <- utils::packageVersion("future")
[17:39:36.752]                         }
[17:39:36.752]                         else {
[17:39:36.752]                           version <- NULL
[17:39:36.752]                         }
[17:39:36.752]                         if (!has_future || version < "1.8.0") {
[17:39:36.752]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.752]                             "", base::R.version$version.string), 
[17:39:36.752]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.752]                               "release", "version")], collapse = " "), 
[17:39:36.752]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.752]                             info)
[17:39:36.752]                           info <- base::paste(info, collapse = "; ")
[17:39:36.752]                           if (!has_future) {
[17:39:36.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.752]                               info)
[17:39:36.752]                           }
[17:39:36.752]                           else {
[17:39:36.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.752]                               info, version)
[17:39:36.752]                           }
[17:39:36.752]                           base::stop(msg)
[17:39:36.752]                         }
[17:39:36.752]                       })
[17:39:36.752]                     }
[17:39:36.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.752]                     base::options(mc.cores = 1L)
[17:39:36.752]                   }
[17:39:36.752]                   ...future.strategy.old <- future::plan("list")
[17:39:36.752]                   options(future.plan = NULL)
[17:39:36.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.752]                 }
[17:39:36.752]                 ...future.workdir <- getwd()
[17:39:36.752]             }
[17:39:36.752]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.752]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.752]         }
[17:39:36.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.752]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.752]             base::names(...future.oldOptions))
[17:39:36.752]     }
[17:39:36.752]     if (FALSE) {
[17:39:36.752]     }
[17:39:36.752]     else {
[17:39:36.752]         if (TRUE) {
[17:39:36.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.752]                 open = "w")
[17:39:36.752]         }
[17:39:36.752]         else {
[17:39:36.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.752]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.752]         }
[17:39:36.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.752]             base::sink(type = "output", split = FALSE)
[17:39:36.752]             base::close(...future.stdout)
[17:39:36.752]         }, add = TRUE)
[17:39:36.752]     }
[17:39:36.752]     ...future.frame <- base::sys.nframe()
[17:39:36.752]     ...future.conditions <- base::list()
[17:39:36.752]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.752]     if (FALSE) {
[17:39:36.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.752]     }
[17:39:36.752]     ...future.result <- base::tryCatch({
[17:39:36.752]         base::withCallingHandlers({
[17:39:36.752]             ...future.value <- base::withVisible(base::local({
[17:39:36.752]                 ...future.makeSendCondition <- base::local({
[17:39:36.752]                   sendCondition <- NULL
[17:39:36.752]                   function(frame = 1L) {
[17:39:36.752]                     if (is.function(sendCondition)) 
[17:39:36.752]                       return(sendCondition)
[17:39:36.752]                     ns <- getNamespace("parallel")
[17:39:36.752]                     if (exists("sendData", mode = "function", 
[17:39:36.752]                       envir = ns)) {
[17:39:36.752]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.752]                         envir = ns)
[17:39:36.752]                       envir <- sys.frame(frame)
[17:39:36.752]                       master <- NULL
[17:39:36.752]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.752]                         !identical(envir, emptyenv())) {
[17:39:36.752]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.752]                           inherits = FALSE)) {
[17:39:36.752]                           master <- get("master", mode = "list", 
[17:39:36.752]                             envir = envir, inherits = FALSE)
[17:39:36.752]                           if (inherits(master, c("SOCKnode", 
[17:39:36.752]                             "SOCK0node"))) {
[17:39:36.752]                             sendCondition <<- function(cond) {
[17:39:36.752]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.752]                                 success = TRUE)
[17:39:36.752]                               parallel_sendData(master, data)
[17:39:36.752]                             }
[17:39:36.752]                             return(sendCondition)
[17:39:36.752]                           }
[17:39:36.752]                         }
[17:39:36.752]                         frame <- frame + 1L
[17:39:36.752]                         envir <- sys.frame(frame)
[17:39:36.752]                       }
[17:39:36.752]                     }
[17:39:36.752]                     sendCondition <<- function(cond) NULL
[17:39:36.752]                   }
[17:39:36.752]                 })
[17:39:36.752]                 withCallingHandlers({
[17:39:36.752]                   NULL
[17:39:36.752]                 }, immediateCondition = function(cond) {
[17:39:36.752]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.752]                   sendCondition(cond)
[17:39:36.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.752]                   {
[17:39:36.752]                     inherits <- base::inherits
[17:39:36.752]                     invokeRestart <- base::invokeRestart
[17:39:36.752]                     is.null <- base::is.null
[17:39:36.752]                     muffled <- FALSE
[17:39:36.752]                     if (inherits(cond, "message")) {
[17:39:36.752]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.752]                       if (muffled) 
[17:39:36.752]                         invokeRestart("muffleMessage")
[17:39:36.752]                     }
[17:39:36.752]                     else if (inherits(cond, "warning")) {
[17:39:36.752]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.752]                       if (muffled) 
[17:39:36.752]                         invokeRestart("muffleWarning")
[17:39:36.752]                     }
[17:39:36.752]                     else if (inherits(cond, "condition")) {
[17:39:36.752]                       if (!is.null(pattern)) {
[17:39:36.752]                         computeRestarts <- base::computeRestarts
[17:39:36.752]                         grepl <- base::grepl
[17:39:36.752]                         restarts <- computeRestarts(cond)
[17:39:36.752]                         for (restart in restarts) {
[17:39:36.752]                           name <- restart$name
[17:39:36.752]                           if (is.null(name)) 
[17:39:36.752]                             next
[17:39:36.752]                           if (!grepl(pattern, name)) 
[17:39:36.752]                             next
[17:39:36.752]                           invokeRestart(restart)
[17:39:36.752]                           muffled <- TRUE
[17:39:36.752]                           break
[17:39:36.752]                         }
[17:39:36.752]                       }
[17:39:36.752]                     }
[17:39:36.752]                     invisible(muffled)
[17:39:36.752]                   }
[17:39:36.752]                   muffleCondition(cond)
[17:39:36.752]                 })
[17:39:36.752]             }))
[17:39:36.752]             future::FutureResult(value = ...future.value$value, 
[17:39:36.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.752]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.752]                     ...future.globalenv.names))
[17:39:36.752]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.752]         }, condition = base::local({
[17:39:36.752]             c <- base::c
[17:39:36.752]             inherits <- base::inherits
[17:39:36.752]             invokeRestart <- base::invokeRestart
[17:39:36.752]             length <- base::length
[17:39:36.752]             list <- base::list
[17:39:36.752]             seq.int <- base::seq.int
[17:39:36.752]             signalCondition <- base::signalCondition
[17:39:36.752]             sys.calls <- base::sys.calls
[17:39:36.752]             `[[` <- base::`[[`
[17:39:36.752]             `+` <- base::`+`
[17:39:36.752]             `<<-` <- base::`<<-`
[17:39:36.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.752]                   3L)]
[17:39:36.752]             }
[17:39:36.752]             function(cond) {
[17:39:36.752]                 is_error <- inherits(cond, "error")
[17:39:36.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.752]                   NULL)
[17:39:36.752]                 if (is_error) {
[17:39:36.752]                   sessionInformation <- function() {
[17:39:36.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.752]                       search = base::search(), system = base::Sys.info())
[17:39:36.752]                   }
[17:39:36.752]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.752]                     cond$call), session = sessionInformation(), 
[17:39:36.752]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.752]                   signalCondition(cond)
[17:39:36.752]                 }
[17:39:36.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.752]                 "immediateCondition"))) {
[17:39:36.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.752]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.752]                   if (TRUE && !signal) {
[17:39:36.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.752]                     {
[17:39:36.752]                       inherits <- base::inherits
[17:39:36.752]                       invokeRestart <- base::invokeRestart
[17:39:36.752]                       is.null <- base::is.null
[17:39:36.752]                       muffled <- FALSE
[17:39:36.752]                       if (inherits(cond, "message")) {
[17:39:36.752]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.752]                         if (muffled) 
[17:39:36.752]                           invokeRestart("muffleMessage")
[17:39:36.752]                       }
[17:39:36.752]                       else if (inherits(cond, "warning")) {
[17:39:36.752]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.752]                         if (muffled) 
[17:39:36.752]                           invokeRestart("muffleWarning")
[17:39:36.752]                       }
[17:39:36.752]                       else if (inherits(cond, "condition")) {
[17:39:36.752]                         if (!is.null(pattern)) {
[17:39:36.752]                           computeRestarts <- base::computeRestarts
[17:39:36.752]                           grepl <- base::grepl
[17:39:36.752]                           restarts <- computeRestarts(cond)
[17:39:36.752]                           for (restart in restarts) {
[17:39:36.752]                             name <- restart$name
[17:39:36.752]                             if (is.null(name)) 
[17:39:36.752]                               next
[17:39:36.752]                             if (!grepl(pattern, name)) 
[17:39:36.752]                               next
[17:39:36.752]                             invokeRestart(restart)
[17:39:36.752]                             muffled <- TRUE
[17:39:36.752]                             break
[17:39:36.752]                           }
[17:39:36.752]                         }
[17:39:36.752]                       }
[17:39:36.752]                       invisible(muffled)
[17:39:36.752]                     }
[17:39:36.752]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.752]                   }
[17:39:36.752]                 }
[17:39:36.752]                 else {
[17:39:36.752]                   if (TRUE) {
[17:39:36.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.752]                     {
[17:39:36.752]                       inherits <- base::inherits
[17:39:36.752]                       invokeRestart <- base::invokeRestart
[17:39:36.752]                       is.null <- base::is.null
[17:39:36.752]                       muffled <- FALSE
[17:39:36.752]                       if (inherits(cond, "message")) {
[17:39:36.752]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.752]                         if (muffled) 
[17:39:36.752]                           invokeRestart("muffleMessage")
[17:39:36.752]                       }
[17:39:36.752]                       else if (inherits(cond, "warning")) {
[17:39:36.752]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.752]                         if (muffled) 
[17:39:36.752]                           invokeRestart("muffleWarning")
[17:39:36.752]                       }
[17:39:36.752]                       else if (inherits(cond, "condition")) {
[17:39:36.752]                         if (!is.null(pattern)) {
[17:39:36.752]                           computeRestarts <- base::computeRestarts
[17:39:36.752]                           grepl <- base::grepl
[17:39:36.752]                           restarts <- computeRestarts(cond)
[17:39:36.752]                           for (restart in restarts) {
[17:39:36.752]                             name <- restart$name
[17:39:36.752]                             if (is.null(name)) 
[17:39:36.752]                               next
[17:39:36.752]                             if (!grepl(pattern, name)) 
[17:39:36.752]                               next
[17:39:36.752]                             invokeRestart(restart)
[17:39:36.752]                             muffled <- TRUE
[17:39:36.752]                             break
[17:39:36.752]                           }
[17:39:36.752]                         }
[17:39:36.752]                       }
[17:39:36.752]                       invisible(muffled)
[17:39:36.752]                     }
[17:39:36.752]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.752]                   }
[17:39:36.752]                 }
[17:39:36.752]             }
[17:39:36.752]         }))
[17:39:36.752]     }, error = function(ex) {
[17:39:36.752]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.752]                 ...future.rng), started = ...future.startTime, 
[17:39:36.752]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.752]             version = "1.8"), class = "FutureResult")
[17:39:36.752]     }, finally = {
[17:39:36.752]         if (!identical(...future.workdir, getwd())) 
[17:39:36.752]             setwd(...future.workdir)
[17:39:36.752]         {
[17:39:36.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.752]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.752]             }
[17:39:36.752]             base::options(...future.oldOptions)
[17:39:36.752]             if (.Platform$OS.type == "windows") {
[17:39:36.752]                 old_names <- names(...future.oldEnvVars)
[17:39:36.752]                 envs <- base::Sys.getenv()
[17:39:36.752]                 names <- names(envs)
[17:39:36.752]                 common <- intersect(names, old_names)
[17:39:36.752]                 added <- setdiff(names, old_names)
[17:39:36.752]                 removed <- setdiff(old_names, names)
[17:39:36.752]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.752]                   envs[common]]
[17:39:36.752]                 NAMES <- toupper(changed)
[17:39:36.752]                 args <- list()
[17:39:36.752]                 for (kk in seq_along(NAMES)) {
[17:39:36.752]                   name <- changed[[kk]]
[17:39:36.752]                   NAME <- NAMES[[kk]]
[17:39:36.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.752]                     next
[17:39:36.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.752]                 }
[17:39:36.752]                 NAMES <- toupper(added)
[17:39:36.752]                 for (kk in seq_along(NAMES)) {
[17:39:36.752]                   name <- added[[kk]]
[17:39:36.752]                   NAME <- NAMES[[kk]]
[17:39:36.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.752]                     next
[17:39:36.752]                   args[[name]] <- ""
[17:39:36.752]                 }
[17:39:36.752]                 NAMES <- toupper(removed)
[17:39:36.752]                 for (kk in seq_along(NAMES)) {
[17:39:36.752]                   name <- removed[[kk]]
[17:39:36.752]                   NAME <- NAMES[[kk]]
[17:39:36.752]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.752]                     next
[17:39:36.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.752]                 }
[17:39:36.752]                 if (length(args) > 0) 
[17:39:36.752]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.752]             }
[17:39:36.752]             else {
[17:39:36.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.752]             }
[17:39:36.752]             {
[17:39:36.752]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.752]                   0L) {
[17:39:36.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.752]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.752]                   base::options(opts)
[17:39:36.752]                 }
[17:39:36.752]                 {
[17:39:36.752]                   {
[17:39:36.752]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.752]                     NULL
[17:39:36.752]                   }
[17:39:36.752]                   options(future.plan = NULL)
[17:39:36.752]                   if (is.na(NA_character_)) 
[17:39:36.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.752]                     .init = FALSE)
[17:39:36.752]                 }
[17:39:36.752]             }
[17:39:36.752]         }
[17:39:36.752]     })
[17:39:36.752]     if (TRUE) {
[17:39:36.752]         base::sink(type = "output", split = FALSE)
[17:39:36.752]         if (TRUE) {
[17:39:36.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.752]         }
[17:39:36.752]         else {
[17:39:36.752]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.752]         }
[17:39:36.752]         base::close(...future.stdout)
[17:39:36.752]         ...future.stdout <- NULL
[17:39:36.752]     }
[17:39:36.752]     ...future.result$conditions <- ...future.conditions
[17:39:36.752]     ...future.result$finished <- base::Sys.time()
[17:39:36.752]     ...future.result
[17:39:36.752] }
[17:39:36.755] MultisessionFuture started
[17:39:36.755] - Launch lazy future ... done
[17:39:36.755] run() for ‘MultisessionFuture’ ... done
[17:39:36.761] getGlobalsAndPackages() ...
[17:39:36.761] Searching for globals...
[17:39:36.762] - globals found: [1] ‘{’
[17:39:36.762] Searching for globals ... DONE
[17:39:36.762] Resolving globals: FALSE
[17:39:36.762] 
[17:39:36.762] 
[17:39:36.763] getGlobalsAndPackages() ... DONE
[17:39:36.763] run() for ‘Future’ ...
[17:39:36.763] - state: ‘created’
[17:39:36.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.777] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.777]   - Field: ‘node’
[17:39:36.777]   - Field: ‘label’
[17:39:36.777]   - Field: ‘local’
[17:39:36.777]   - Field: ‘owner’
[17:39:36.777]   - Field: ‘envir’
[17:39:36.778]   - Field: ‘workers’
[17:39:36.778]   - Field: ‘packages’
[17:39:36.778]   - Field: ‘gc’
[17:39:36.778]   - Field: ‘conditions’
[17:39:36.778]   - Field: ‘persistent’
[17:39:36.778]   - Field: ‘expr’
[17:39:36.778]   - Field: ‘uuid’
[17:39:36.778]   - Field: ‘seed’
[17:39:36.778]   - Field: ‘version’
[17:39:36.778]   - Field: ‘result’
[17:39:36.778]   - Field: ‘asynchronous’
[17:39:36.779]   - Field: ‘calls’
[17:39:36.779]   - Field: ‘globals’
[17:39:36.779]   - Field: ‘stdout’
[17:39:36.779]   - Field: ‘earlySignal’
[17:39:36.779]   - Field: ‘lazy’
[17:39:36.779]   - Field: ‘state’
[17:39:36.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.779] - Launch lazy future ...
[17:39:36.779] Packages needed by the future expression (n = 0): <none>
[17:39:36.780] Packages needed by future strategies (n = 0): <none>
[17:39:36.780] {
[17:39:36.780]     {
[17:39:36.780]         {
[17:39:36.780]             ...future.startTime <- base::Sys.time()
[17:39:36.780]             {
[17:39:36.780]                 {
[17:39:36.780]                   {
[17:39:36.780]                     {
[17:39:36.780]                       base::local({
[17:39:36.780]                         has_future <- base::requireNamespace("future", 
[17:39:36.780]                           quietly = TRUE)
[17:39:36.780]                         if (has_future) {
[17:39:36.780]                           ns <- base::getNamespace("future")
[17:39:36.780]                           version <- ns[[".package"]][["version"]]
[17:39:36.780]                           if (is.null(version)) 
[17:39:36.780]                             version <- utils::packageVersion("future")
[17:39:36.780]                         }
[17:39:36.780]                         else {
[17:39:36.780]                           version <- NULL
[17:39:36.780]                         }
[17:39:36.780]                         if (!has_future || version < "1.8.0") {
[17:39:36.780]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.780]                             "", base::R.version$version.string), 
[17:39:36.780]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.780]                               "release", "version")], collapse = " "), 
[17:39:36.780]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.780]                             info)
[17:39:36.780]                           info <- base::paste(info, collapse = "; ")
[17:39:36.780]                           if (!has_future) {
[17:39:36.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.780]                               info)
[17:39:36.780]                           }
[17:39:36.780]                           else {
[17:39:36.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.780]                               info, version)
[17:39:36.780]                           }
[17:39:36.780]                           base::stop(msg)
[17:39:36.780]                         }
[17:39:36.780]                       })
[17:39:36.780]                     }
[17:39:36.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.780]                     base::options(mc.cores = 1L)
[17:39:36.780]                   }
[17:39:36.780]                   ...future.strategy.old <- future::plan("list")
[17:39:36.780]                   options(future.plan = NULL)
[17:39:36.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.780]                 }
[17:39:36.780]                 ...future.workdir <- getwd()
[17:39:36.780]             }
[17:39:36.780]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.780]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.780]         }
[17:39:36.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.780]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.780]             base::names(...future.oldOptions))
[17:39:36.780]     }
[17:39:36.780]     if (FALSE) {
[17:39:36.780]     }
[17:39:36.780]     else {
[17:39:36.780]         if (TRUE) {
[17:39:36.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.780]                 open = "w")
[17:39:36.780]         }
[17:39:36.780]         else {
[17:39:36.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.780]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.780]         }
[17:39:36.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.780]             base::sink(type = "output", split = FALSE)
[17:39:36.780]             base::close(...future.stdout)
[17:39:36.780]         }, add = TRUE)
[17:39:36.780]     }
[17:39:36.780]     ...future.frame <- base::sys.nframe()
[17:39:36.780]     ...future.conditions <- base::list()
[17:39:36.780]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.780]     if (FALSE) {
[17:39:36.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.780]     }
[17:39:36.780]     ...future.result <- base::tryCatch({
[17:39:36.780]         base::withCallingHandlers({
[17:39:36.780]             ...future.value <- base::withVisible(base::local({
[17:39:36.780]                 ...future.makeSendCondition <- base::local({
[17:39:36.780]                   sendCondition <- NULL
[17:39:36.780]                   function(frame = 1L) {
[17:39:36.780]                     if (is.function(sendCondition)) 
[17:39:36.780]                       return(sendCondition)
[17:39:36.780]                     ns <- getNamespace("parallel")
[17:39:36.780]                     if (exists("sendData", mode = "function", 
[17:39:36.780]                       envir = ns)) {
[17:39:36.780]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.780]                         envir = ns)
[17:39:36.780]                       envir <- sys.frame(frame)
[17:39:36.780]                       master <- NULL
[17:39:36.780]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.780]                         !identical(envir, emptyenv())) {
[17:39:36.780]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.780]                           inherits = FALSE)) {
[17:39:36.780]                           master <- get("master", mode = "list", 
[17:39:36.780]                             envir = envir, inherits = FALSE)
[17:39:36.780]                           if (inherits(master, c("SOCKnode", 
[17:39:36.780]                             "SOCK0node"))) {
[17:39:36.780]                             sendCondition <<- function(cond) {
[17:39:36.780]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.780]                                 success = TRUE)
[17:39:36.780]                               parallel_sendData(master, data)
[17:39:36.780]                             }
[17:39:36.780]                             return(sendCondition)
[17:39:36.780]                           }
[17:39:36.780]                         }
[17:39:36.780]                         frame <- frame + 1L
[17:39:36.780]                         envir <- sys.frame(frame)
[17:39:36.780]                       }
[17:39:36.780]                     }
[17:39:36.780]                     sendCondition <<- function(cond) NULL
[17:39:36.780]                   }
[17:39:36.780]                 })
[17:39:36.780]                 withCallingHandlers({
[17:39:36.780]                   {
[17:39:36.780]                     4
[17:39:36.780]                   }
[17:39:36.780]                 }, immediateCondition = function(cond) {
[17:39:36.780]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.780]                   sendCondition(cond)
[17:39:36.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.780]                   {
[17:39:36.780]                     inherits <- base::inherits
[17:39:36.780]                     invokeRestart <- base::invokeRestart
[17:39:36.780]                     is.null <- base::is.null
[17:39:36.780]                     muffled <- FALSE
[17:39:36.780]                     if (inherits(cond, "message")) {
[17:39:36.780]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.780]                       if (muffled) 
[17:39:36.780]                         invokeRestart("muffleMessage")
[17:39:36.780]                     }
[17:39:36.780]                     else if (inherits(cond, "warning")) {
[17:39:36.780]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.780]                       if (muffled) 
[17:39:36.780]                         invokeRestart("muffleWarning")
[17:39:36.780]                     }
[17:39:36.780]                     else if (inherits(cond, "condition")) {
[17:39:36.780]                       if (!is.null(pattern)) {
[17:39:36.780]                         computeRestarts <- base::computeRestarts
[17:39:36.780]                         grepl <- base::grepl
[17:39:36.780]                         restarts <- computeRestarts(cond)
[17:39:36.780]                         for (restart in restarts) {
[17:39:36.780]                           name <- restart$name
[17:39:36.780]                           if (is.null(name)) 
[17:39:36.780]                             next
[17:39:36.780]                           if (!grepl(pattern, name)) 
[17:39:36.780]                             next
[17:39:36.780]                           invokeRestart(restart)
[17:39:36.780]                           muffled <- TRUE
[17:39:36.780]                           break
[17:39:36.780]                         }
[17:39:36.780]                       }
[17:39:36.780]                     }
[17:39:36.780]                     invisible(muffled)
[17:39:36.780]                   }
[17:39:36.780]                   muffleCondition(cond)
[17:39:36.780]                 })
[17:39:36.780]             }))
[17:39:36.780]             future::FutureResult(value = ...future.value$value, 
[17:39:36.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.780]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.780]                     ...future.globalenv.names))
[17:39:36.780]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.780]         }, condition = base::local({
[17:39:36.780]             c <- base::c
[17:39:36.780]             inherits <- base::inherits
[17:39:36.780]             invokeRestart <- base::invokeRestart
[17:39:36.780]             length <- base::length
[17:39:36.780]             list <- base::list
[17:39:36.780]             seq.int <- base::seq.int
[17:39:36.780]             signalCondition <- base::signalCondition
[17:39:36.780]             sys.calls <- base::sys.calls
[17:39:36.780]             `[[` <- base::`[[`
[17:39:36.780]             `+` <- base::`+`
[17:39:36.780]             `<<-` <- base::`<<-`
[17:39:36.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.780]                   3L)]
[17:39:36.780]             }
[17:39:36.780]             function(cond) {
[17:39:36.780]                 is_error <- inherits(cond, "error")
[17:39:36.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.780]                   NULL)
[17:39:36.780]                 if (is_error) {
[17:39:36.780]                   sessionInformation <- function() {
[17:39:36.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.780]                       search = base::search(), system = base::Sys.info())
[17:39:36.780]                   }
[17:39:36.780]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.780]                     cond$call), session = sessionInformation(), 
[17:39:36.780]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.780]                   signalCondition(cond)
[17:39:36.780]                 }
[17:39:36.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.780]                 "immediateCondition"))) {
[17:39:36.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.780]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.780]                   if (TRUE && !signal) {
[17:39:36.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.780]                     {
[17:39:36.780]                       inherits <- base::inherits
[17:39:36.780]                       invokeRestart <- base::invokeRestart
[17:39:36.780]                       is.null <- base::is.null
[17:39:36.780]                       muffled <- FALSE
[17:39:36.780]                       if (inherits(cond, "message")) {
[17:39:36.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.780]                         if (muffled) 
[17:39:36.780]                           invokeRestart("muffleMessage")
[17:39:36.780]                       }
[17:39:36.780]                       else if (inherits(cond, "warning")) {
[17:39:36.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.780]                         if (muffled) 
[17:39:36.780]                           invokeRestart("muffleWarning")
[17:39:36.780]                       }
[17:39:36.780]                       else if (inherits(cond, "condition")) {
[17:39:36.780]                         if (!is.null(pattern)) {
[17:39:36.780]                           computeRestarts <- base::computeRestarts
[17:39:36.780]                           grepl <- base::grepl
[17:39:36.780]                           restarts <- computeRestarts(cond)
[17:39:36.780]                           for (restart in restarts) {
[17:39:36.780]                             name <- restart$name
[17:39:36.780]                             if (is.null(name)) 
[17:39:36.780]                               next
[17:39:36.780]                             if (!grepl(pattern, name)) 
[17:39:36.780]                               next
[17:39:36.780]                             invokeRestart(restart)
[17:39:36.780]                             muffled <- TRUE
[17:39:36.780]                             break
[17:39:36.780]                           }
[17:39:36.780]                         }
[17:39:36.780]                       }
[17:39:36.780]                       invisible(muffled)
[17:39:36.780]                     }
[17:39:36.780]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.780]                   }
[17:39:36.780]                 }
[17:39:36.780]                 else {
[17:39:36.780]                   if (TRUE) {
[17:39:36.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.780]                     {
[17:39:36.780]                       inherits <- base::inherits
[17:39:36.780]                       invokeRestart <- base::invokeRestart
[17:39:36.780]                       is.null <- base::is.null
[17:39:36.780]                       muffled <- FALSE
[17:39:36.780]                       if (inherits(cond, "message")) {
[17:39:36.780]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.780]                         if (muffled) 
[17:39:36.780]                           invokeRestart("muffleMessage")
[17:39:36.780]                       }
[17:39:36.780]                       else if (inherits(cond, "warning")) {
[17:39:36.780]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.780]                         if (muffled) 
[17:39:36.780]                           invokeRestart("muffleWarning")
[17:39:36.780]                       }
[17:39:36.780]                       else if (inherits(cond, "condition")) {
[17:39:36.780]                         if (!is.null(pattern)) {
[17:39:36.780]                           computeRestarts <- base::computeRestarts
[17:39:36.780]                           grepl <- base::grepl
[17:39:36.780]                           restarts <- computeRestarts(cond)
[17:39:36.780]                           for (restart in restarts) {
[17:39:36.780]                             name <- restart$name
[17:39:36.780]                             if (is.null(name)) 
[17:39:36.780]                               next
[17:39:36.780]                             if (!grepl(pattern, name)) 
[17:39:36.780]                               next
[17:39:36.780]                             invokeRestart(restart)
[17:39:36.780]                             muffled <- TRUE
[17:39:36.780]                             break
[17:39:36.780]                           }
[17:39:36.780]                         }
[17:39:36.780]                       }
[17:39:36.780]                       invisible(muffled)
[17:39:36.780]                     }
[17:39:36.780]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.780]                   }
[17:39:36.780]                 }
[17:39:36.780]             }
[17:39:36.780]         }))
[17:39:36.780]     }, error = function(ex) {
[17:39:36.780]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.780]                 ...future.rng), started = ...future.startTime, 
[17:39:36.780]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.780]             version = "1.8"), class = "FutureResult")
[17:39:36.780]     }, finally = {
[17:39:36.780]         if (!identical(...future.workdir, getwd())) 
[17:39:36.780]             setwd(...future.workdir)
[17:39:36.780]         {
[17:39:36.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.780]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.780]             }
[17:39:36.780]             base::options(...future.oldOptions)
[17:39:36.780]             if (.Platform$OS.type == "windows") {
[17:39:36.780]                 old_names <- names(...future.oldEnvVars)
[17:39:36.780]                 envs <- base::Sys.getenv()
[17:39:36.780]                 names <- names(envs)
[17:39:36.780]                 common <- intersect(names, old_names)
[17:39:36.780]                 added <- setdiff(names, old_names)
[17:39:36.780]                 removed <- setdiff(old_names, names)
[17:39:36.780]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.780]                   envs[common]]
[17:39:36.780]                 NAMES <- toupper(changed)
[17:39:36.780]                 args <- list()
[17:39:36.780]                 for (kk in seq_along(NAMES)) {
[17:39:36.780]                   name <- changed[[kk]]
[17:39:36.780]                   NAME <- NAMES[[kk]]
[17:39:36.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.780]                     next
[17:39:36.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.780]                 }
[17:39:36.780]                 NAMES <- toupper(added)
[17:39:36.780]                 for (kk in seq_along(NAMES)) {
[17:39:36.780]                   name <- added[[kk]]
[17:39:36.780]                   NAME <- NAMES[[kk]]
[17:39:36.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.780]                     next
[17:39:36.780]                   args[[name]] <- ""
[17:39:36.780]                 }
[17:39:36.780]                 NAMES <- toupper(removed)
[17:39:36.780]                 for (kk in seq_along(NAMES)) {
[17:39:36.780]                   name <- removed[[kk]]
[17:39:36.780]                   NAME <- NAMES[[kk]]
[17:39:36.780]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.780]                     next
[17:39:36.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.780]                 }
[17:39:36.780]                 if (length(args) > 0) 
[17:39:36.780]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.780]             }
[17:39:36.780]             else {
[17:39:36.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.780]             }
[17:39:36.780]             {
[17:39:36.780]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.780]                   0L) {
[17:39:36.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.780]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.780]                   base::options(opts)
[17:39:36.780]                 }
[17:39:36.780]                 {
[17:39:36.780]                   {
[17:39:36.780]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.780]                     NULL
[17:39:36.780]                   }
[17:39:36.780]                   options(future.plan = NULL)
[17:39:36.780]                   if (is.na(NA_character_)) 
[17:39:36.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.780]                     .init = FALSE)
[17:39:36.780]                 }
[17:39:36.780]             }
[17:39:36.780]         }
[17:39:36.780]     })
[17:39:36.780]     if (TRUE) {
[17:39:36.780]         base::sink(type = "output", split = FALSE)
[17:39:36.780]         if (TRUE) {
[17:39:36.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.780]         }
[17:39:36.780]         else {
[17:39:36.780]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.780]         }
[17:39:36.780]         base::close(...future.stdout)
[17:39:36.780]         ...future.stdout <- NULL
[17:39:36.780]     }
[17:39:36.780]     ...future.result$conditions <- ...future.conditions
[17:39:36.780]     ...future.result$finished <- base::Sys.time()
[17:39:36.780]     ...future.result
[17:39:36.780] }
[17:39:36.782] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:36.793] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.793] - Validating connection of MultisessionFuture
[17:39:36.793] - received message: FutureResult
[17:39:36.793] - Received FutureResult
[17:39:36.793] - Erased future from FutureRegistry
[17:39:36.794] result() for ClusterFuture ...
[17:39:36.794] - result already collected: FutureResult
[17:39:36.794] result() for ClusterFuture ... done
[17:39:36.794] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.794] result() for ClusterFuture ...
[17:39:36.794] - result already collected: FutureResult
[17:39:36.794] result() for ClusterFuture ... done
[17:39:36.794] result() for ClusterFuture ...
[17:39:36.794] - result already collected: FutureResult
[17:39:36.794] result() for ClusterFuture ... done
[17:39:36.795] MultisessionFuture started
[17:39:36.795] - Launch lazy future ... done
[17:39:36.795] run() for ‘MultisessionFuture’ ... done
<environment: 0x55adf1c8ea50> 
<environment: 0x55adf0188f40> 
[17:39:36.797] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.797] - Validating connection of MultisessionFuture
[17:39:36.797] - received message: FutureResult
[17:39:36.798] - Received FutureResult
[17:39:36.798] - Erased future from FutureRegistry
[17:39:36.798] result() for ClusterFuture ...
[17:39:36.798] - result already collected: FutureResult
[17:39:36.798] result() for ClusterFuture ... done
[17:39:36.798] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.798] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.799] - Validating connection of MultisessionFuture
[17:39:36.799] - received message: FutureResult
[17:39:36.799] - Received FutureResult
[17:39:36.799] - Erased future from FutureRegistry
[17:39:36.799] result() for ClusterFuture ...
[17:39:36.799] - result already collected: FutureResult
[17:39:36.799] result() for ClusterFuture ... done
[17:39:36.799] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.800] resolve() on environment ...
[17:39:36.800]  recursive: 0
[17:39:36.801]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.801] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.801] - nx: 4
[17:39:36.801] - relay: TRUE
[17:39:36.801] - stdout: TRUE
[17:39:36.801] - signal: TRUE
[17:39:36.801] - resignal: FALSE
[17:39:36.802] - force: TRUE
[17:39:36.802] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.802] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.802]  - until=2
[17:39:36.802]  - relaying element #2
[17:39:36.802] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.802] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.802] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.802]  length: 3 (resolved future 1)
[17:39:36.802] Future #2
[17:39:36.802] result() for ClusterFuture ...
[17:39:36.803] - result already collected: FutureResult
[17:39:36.803] result() for ClusterFuture ... done
[17:39:36.803] result() for ClusterFuture ...
[17:39:36.803] - result already collected: FutureResult
[17:39:36.803] result() for ClusterFuture ... done
[17:39:36.803] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:36.803] - nx: 4
[17:39:36.803] - relay: TRUE
[17:39:36.803] - stdout: TRUE
[17:39:36.803] - signal: TRUE
[17:39:36.803] - resignal: FALSE
[17:39:36.803] - force: TRUE
[17:39:36.804] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.804] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.804]  - until=2
[17:39:36.804]  - relaying element #2
[17:39:36.804] result() for ClusterFuture ...
[17:39:36.804] - result already collected: FutureResult
[17:39:36.804] result() for ClusterFuture ... done
[17:39:36.804] result() for ClusterFuture ...
[17:39:36.804] - result already collected: FutureResult
[17:39:36.804] result() for ClusterFuture ... done
[17:39:36.804] result() for ClusterFuture ...
[17:39:36.805] - result already collected: FutureResult
[17:39:36.805] result() for ClusterFuture ... done
[17:39:36.805] result() for ClusterFuture ...
[17:39:36.805] - result already collected: FutureResult
[17:39:36.805] result() for ClusterFuture ... done
[17:39:36.805] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.805] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.805] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:36.805]  length: 2 (resolved future 2)
[17:39:36.805] Future #3
[17:39:36.805] result() for ClusterFuture ...
[17:39:36.806] - result already collected: FutureResult
[17:39:36.806] result() for ClusterFuture ... done
[17:39:36.806] result() for ClusterFuture ...
[17:39:36.806] - result already collected: FutureResult
[17:39:36.806] result() for ClusterFuture ... done
[17:39:36.806] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:36.806] - nx: 4
[17:39:36.806] - relay: TRUE
[17:39:36.806] - stdout: TRUE
[17:39:36.806] - signal: TRUE
[17:39:36.806] - resignal: FALSE
[17:39:36.806] - force: TRUE
[17:39:36.807] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.807] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.807]  - until=3
[17:39:36.807]  - relaying element #3
[17:39:36.807] result() for ClusterFuture ...
[17:39:36.807] - result already collected: FutureResult
[17:39:36.807] result() for ClusterFuture ... done
[17:39:36.807] result() for ClusterFuture ...
[17:39:36.807] - result already collected: FutureResult
[17:39:36.807] result() for ClusterFuture ... done
[17:39:36.807] result() for ClusterFuture ...
[17:39:36.807] - result already collected: FutureResult
[17:39:36.808] result() for ClusterFuture ... done
[17:39:36.808] result() for ClusterFuture ...
[17:39:36.808] - result already collected: FutureResult
[17:39:36.808] result() for ClusterFuture ... done
[17:39:36.808] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.808] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.808] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:36.808]  length: 1 (resolved future 3)
[17:39:36.808] Future #4
[17:39:36.808] result() for ClusterFuture ...
[17:39:36.809] - result already collected: FutureResult
[17:39:36.809] result() for ClusterFuture ... done
[17:39:36.809] result() for ClusterFuture ...
[17:39:36.809] - result already collected: FutureResult
[17:39:36.809] result() for ClusterFuture ... done
[17:39:36.809] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:36.809] - nx: 4
[17:39:36.809] - relay: TRUE
[17:39:36.809] - stdout: TRUE
[17:39:36.809] - signal: TRUE
[17:39:36.809] - resignal: FALSE
[17:39:36.809] - force: TRUE
[17:39:36.810] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.810] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.810]  - until=4
[17:39:36.810]  - relaying element #4
[17:39:36.810] result() for ClusterFuture ...
[17:39:36.810] - result already collected: FutureResult
[17:39:36.810] result() for ClusterFuture ... done
[17:39:36.810] result() for ClusterFuture ...
[17:39:36.810] - result already collected: FutureResult
[17:39:36.810] result() for ClusterFuture ... done
[17:39:36.810] result() for ClusterFuture ...
[17:39:36.810] - result already collected: FutureResult
[17:39:36.811] result() for ClusterFuture ... done
[17:39:36.811] result() for ClusterFuture ...
[17:39:36.811] - result already collected: FutureResult
[17:39:36.811] result() for ClusterFuture ... done
[17:39:36.811] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.811] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.811] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:36.811]  length: 0 (resolved future 4)
[17:39:36.811] Relaying remaining futures
[17:39:36.811] signalConditionsASAP(NULL, pos=0) ...
[17:39:36.811] - nx: 4
[17:39:36.811] - relay: TRUE
[17:39:36.812] - stdout: TRUE
[17:39:36.812] - signal: TRUE
[17:39:36.812] - resignal: FALSE
[17:39:36.812] - force: TRUE
[17:39:36.812] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.812] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:36.812] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.812] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.812] signalConditionsASAP(NULL, pos=0) ... done
[17:39:36.812] resolve() on environment ... DONE
[17:39:36.812] result() for ClusterFuture ...
[17:39:36.813] - result already collected: FutureResult
[17:39:36.813] result() for ClusterFuture ... done
[17:39:36.813] result() for ClusterFuture ...
[17:39:36.813] - result already collected: FutureResult
[17:39:36.813] result() for ClusterFuture ... done
[17:39:36.813] result() for ClusterFuture ...
[17:39:36.813] - result already collected: FutureResult
[17:39:36.813] result() for ClusterFuture ... done
[17:39:36.813] result() for ClusterFuture ...
[17:39:36.813] - result already collected: FutureResult
[17:39:36.813] result() for ClusterFuture ... done
[17:39:36.814] result() for ClusterFuture ...
[17:39:36.814] - result already collected: FutureResult
[17:39:36.814] result() for ClusterFuture ... done
[17:39:36.814] result() for ClusterFuture ...
[17:39:36.814] - result already collected: FutureResult
[17:39:36.814] result() for ClusterFuture ... done
<environment: 0x55adefe15858> 
Dimensions: c(2, 3)
[17:39:36.814] getGlobalsAndPackages() ...
[17:39:36.814] Searching for globals...
[17:39:36.815] 
[17:39:36.815] Searching for globals ... DONE
[17:39:36.815] - globals: [0] <none>
[17:39:36.815] getGlobalsAndPackages() ... DONE
[17:39:36.815] run() for ‘Future’ ...
[17:39:36.815] - state: ‘created’
[17:39:36.815] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.829]   - Field: ‘node’
[17:39:36.830]   - Field: ‘label’
[17:39:36.830]   - Field: ‘local’
[17:39:36.830]   - Field: ‘owner’
[17:39:36.830]   - Field: ‘envir’
[17:39:36.830]   - Field: ‘workers’
[17:39:36.830]   - Field: ‘packages’
[17:39:36.830]   - Field: ‘gc’
[17:39:36.830]   - Field: ‘conditions’
[17:39:36.830]   - Field: ‘persistent’
[17:39:36.830]   - Field: ‘expr’
[17:39:36.830]   - Field: ‘uuid’
[17:39:36.831]   - Field: ‘seed’
[17:39:36.831]   - Field: ‘version’
[17:39:36.831]   - Field: ‘result’
[17:39:36.831]   - Field: ‘asynchronous’
[17:39:36.831]   - Field: ‘calls’
[17:39:36.831]   - Field: ‘globals’
[17:39:36.831]   - Field: ‘stdout’
[17:39:36.831]   - Field: ‘earlySignal’
[17:39:36.831]   - Field: ‘lazy’
[17:39:36.831]   - Field: ‘state’
[17:39:36.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.832] - Launch lazy future ...
[17:39:36.832] Packages needed by the future expression (n = 0): <none>
[17:39:36.832] Packages needed by future strategies (n = 0): <none>
[17:39:36.832] {
[17:39:36.832]     {
[17:39:36.832]         {
[17:39:36.832]             ...future.startTime <- base::Sys.time()
[17:39:36.832]             {
[17:39:36.832]                 {
[17:39:36.832]                   {
[17:39:36.832]                     {
[17:39:36.832]                       base::local({
[17:39:36.832]                         has_future <- base::requireNamespace("future", 
[17:39:36.832]                           quietly = TRUE)
[17:39:36.832]                         if (has_future) {
[17:39:36.832]                           ns <- base::getNamespace("future")
[17:39:36.832]                           version <- ns[[".package"]][["version"]]
[17:39:36.832]                           if (is.null(version)) 
[17:39:36.832]                             version <- utils::packageVersion("future")
[17:39:36.832]                         }
[17:39:36.832]                         else {
[17:39:36.832]                           version <- NULL
[17:39:36.832]                         }
[17:39:36.832]                         if (!has_future || version < "1.8.0") {
[17:39:36.832]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.832]                             "", base::R.version$version.string), 
[17:39:36.832]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.832]                               "release", "version")], collapse = " "), 
[17:39:36.832]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.832]                             info)
[17:39:36.832]                           info <- base::paste(info, collapse = "; ")
[17:39:36.832]                           if (!has_future) {
[17:39:36.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.832]                               info)
[17:39:36.832]                           }
[17:39:36.832]                           else {
[17:39:36.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.832]                               info, version)
[17:39:36.832]                           }
[17:39:36.832]                           base::stop(msg)
[17:39:36.832]                         }
[17:39:36.832]                       })
[17:39:36.832]                     }
[17:39:36.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.832]                     base::options(mc.cores = 1L)
[17:39:36.832]                   }
[17:39:36.832]                   ...future.strategy.old <- future::plan("list")
[17:39:36.832]                   options(future.plan = NULL)
[17:39:36.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.832]                 }
[17:39:36.832]                 ...future.workdir <- getwd()
[17:39:36.832]             }
[17:39:36.832]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.832]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.832]         }
[17:39:36.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.832]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.832]             base::names(...future.oldOptions))
[17:39:36.832]     }
[17:39:36.832]     if (FALSE) {
[17:39:36.832]     }
[17:39:36.832]     else {
[17:39:36.832]         if (TRUE) {
[17:39:36.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.832]                 open = "w")
[17:39:36.832]         }
[17:39:36.832]         else {
[17:39:36.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.832]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.832]         }
[17:39:36.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.832]             base::sink(type = "output", split = FALSE)
[17:39:36.832]             base::close(...future.stdout)
[17:39:36.832]         }, add = TRUE)
[17:39:36.832]     }
[17:39:36.832]     ...future.frame <- base::sys.nframe()
[17:39:36.832]     ...future.conditions <- base::list()
[17:39:36.832]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.832]     if (FALSE) {
[17:39:36.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.832]     }
[17:39:36.832]     ...future.result <- base::tryCatch({
[17:39:36.832]         base::withCallingHandlers({
[17:39:36.832]             ...future.value <- base::withVisible(base::local({
[17:39:36.832]                 ...future.makeSendCondition <- base::local({
[17:39:36.832]                   sendCondition <- NULL
[17:39:36.832]                   function(frame = 1L) {
[17:39:36.832]                     if (is.function(sendCondition)) 
[17:39:36.832]                       return(sendCondition)
[17:39:36.832]                     ns <- getNamespace("parallel")
[17:39:36.832]                     if (exists("sendData", mode = "function", 
[17:39:36.832]                       envir = ns)) {
[17:39:36.832]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.832]                         envir = ns)
[17:39:36.832]                       envir <- sys.frame(frame)
[17:39:36.832]                       master <- NULL
[17:39:36.832]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.832]                         !identical(envir, emptyenv())) {
[17:39:36.832]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.832]                           inherits = FALSE)) {
[17:39:36.832]                           master <- get("master", mode = "list", 
[17:39:36.832]                             envir = envir, inherits = FALSE)
[17:39:36.832]                           if (inherits(master, c("SOCKnode", 
[17:39:36.832]                             "SOCK0node"))) {
[17:39:36.832]                             sendCondition <<- function(cond) {
[17:39:36.832]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.832]                                 success = TRUE)
[17:39:36.832]                               parallel_sendData(master, data)
[17:39:36.832]                             }
[17:39:36.832]                             return(sendCondition)
[17:39:36.832]                           }
[17:39:36.832]                         }
[17:39:36.832]                         frame <- frame + 1L
[17:39:36.832]                         envir <- sys.frame(frame)
[17:39:36.832]                       }
[17:39:36.832]                     }
[17:39:36.832]                     sendCondition <<- function(cond) NULL
[17:39:36.832]                   }
[17:39:36.832]                 })
[17:39:36.832]                 withCallingHandlers({
[17:39:36.832]                   2
[17:39:36.832]                 }, immediateCondition = function(cond) {
[17:39:36.832]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.832]                   sendCondition(cond)
[17:39:36.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.832]                   {
[17:39:36.832]                     inherits <- base::inherits
[17:39:36.832]                     invokeRestart <- base::invokeRestart
[17:39:36.832]                     is.null <- base::is.null
[17:39:36.832]                     muffled <- FALSE
[17:39:36.832]                     if (inherits(cond, "message")) {
[17:39:36.832]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.832]                       if (muffled) 
[17:39:36.832]                         invokeRestart("muffleMessage")
[17:39:36.832]                     }
[17:39:36.832]                     else if (inherits(cond, "warning")) {
[17:39:36.832]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.832]                       if (muffled) 
[17:39:36.832]                         invokeRestart("muffleWarning")
[17:39:36.832]                     }
[17:39:36.832]                     else if (inherits(cond, "condition")) {
[17:39:36.832]                       if (!is.null(pattern)) {
[17:39:36.832]                         computeRestarts <- base::computeRestarts
[17:39:36.832]                         grepl <- base::grepl
[17:39:36.832]                         restarts <- computeRestarts(cond)
[17:39:36.832]                         for (restart in restarts) {
[17:39:36.832]                           name <- restart$name
[17:39:36.832]                           if (is.null(name)) 
[17:39:36.832]                             next
[17:39:36.832]                           if (!grepl(pattern, name)) 
[17:39:36.832]                             next
[17:39:36.832]                           invokeRestart(restart)
[17:39:36.832]                           muffled <- TRUE
[17:39:36.832]                           break
[17:39:36.832]                         }
[17:39:36.832]                       }
[17:39:36.832]                     }
[17:39:36.832]                     invisible(muffled)
[17:39:36.832]                   }
[17:39:36.832]                   muffleCondition(cond)
[17:39:36.832]                 })
[17:39:36.832]             }))
[17:39:36.832]             future::FutureResult(value = ...future.value$value, 
[17:39:36.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.832]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.832]                     ...future.globalenv.names))
[17:39:36.832]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.832]         }, condition = base::local({
[17:39:36.832]             c <- base::c
[17:39:36.832]             inherits <- base::inherits
[17:39:36.832]             invokeRestart <- base::invokeRestart
[17:39:36.832]             length <- base::length
[17:39:36.832]             list <- base::list
[17:39:36.832]             seq.int <- base::seq.int
[17:39:36.832]             signalCondition <- base::signalCondition
[17:39:36.832]             sys.calls <- base::sys.calls
[17:39:36.832]             `[[` <- base::`[[`
[17:39:36.832]             `+` <- base::`+`
[17:39:36.832]             `<<-` <- base::`<<-`
[17:39:36.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.832]                   3L)]
[17:39:36.832]             }
[17:39:36.832]             function(cond) {
[17:39:36.832]                 is_error <- inherits(cond, "error")
[17:39:36.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.832]                   NULL)
[17:39:36.832]                 if (is_error) {
[17:39:36.832]                   sessionInformation <- function() {
[17:39:36.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.832]                       search = base::search(), system = base::Sys.info())
[17:39:36.832]                   }
[17:39:36.832]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.832]                     cond$call), session = sessionInformation(), 
[17:39:36.832]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.832]                   signalCondition(cond)
[17:39:36.832]                 }
[17:39:36.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.832]                 "immediateCondition"))) {
[17:39:36.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.832]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.832]                   if (TRUE && !signal) {
[17:39:36.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.832]                     {
[17:39:36.832]                       inherits <- base::inherits
[17:39:36.832]                       invokeRestart <- base::invokeRestart
[17:39:36.832]                       is.null <- base::is.null
[17:39:36.832]                       muffled <- FALSE
[17:39:36.832]                       if (inherits(cond, "message")) {
[17:39:36.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.832]                         if (muffled) 
[17:39:36.832]                           invokeRestart("muffleMessage")
[17:39:36.832]                       }
[17:39:36.832]                       else if (inherits(cond, "warning")) {
[17:39:36.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.832]                         if (muffled) 
[17:39:36.832]                           invokeRestart("muffleWarning")
[17:39:36.832]                       }
[17:39:36.832]                       else if (inherits(cond, "condition")) {
[17:39:36.832]                         if (!is.null(pattern)) {
[17:39:36.832]                           computeRestarts <- base::computeRestarts
[17:39:36.832]                           grepl <- base::grepl
[17:39:36.832]                           restarts <- computeRestarts(cond)
[17:39:36.832]                           for (restart in restarts) {
[17:39:36.832]                             name <- restart$name
[17:39:36.832]                             if (is.null(name)) 
[17:39:36.832]                               next
[17:39:36.832]                             if (!grepl(pattern, name)) 
[17:39:36.832]                               next
[17:39:36.832]                             invokeRestart(restart)
[17:39:36.832]                             muffled <- TRUE
[17:39:36.832]                             break
[17:39:36.832]                           }
[17:39:36.832]                         }
[17:39:36.832]                       }
[17:39:36.832]                       invisible(muffled)
[17:39:36.832]                     }
[17:39:36.832]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.832]                   }
[17:39:36.832]                 }
[17:39:36.832]                 else {
[17:39:36.832]                   if (TRUE) {
[17:39:36.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.832]                     {
[17:39:36.832]                       inherits <- base::inherits
[17:39:36.832]                       invokeRestart <- base::invokeRestart
[17:39:36.832]                       is.null <- base::is.null
[17:39:36.832]                       muffled <- FALSE
[17:39:36.832]                       if (inherits(cond, "message")) {
[17:39:36.832]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.832]                         if (muffled) 
[17:39:36.832]                           invokeRestart("muffleMessage")
[17:39:36.832]                       }
[17:39:36.832]                       else if (inherits(cond, "warning")) {
[17:39:36.832]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.832]                         if (muffled) 
[17:39:36.832]                           invokeRestart("muffleWarning")
[17:39:36.832]                       }
[17:39:36.832]                       else if (inherits(cond, "condition")) {
[17:39:36.832]                         if (!is.null(pattern)) {
[17:39:36.832]                           computeRestarts <- base::computeRestarts
[17:39:36.832]                           grepl <- base::grepl
[17:39:36.832]                           restarts <- computeRestarts(cond)
[17:39:36.832]                           for (restart in restarts) {
[17:39:36.832]                             name <- restart$name
[17:39:36.832]                             if (is.null(name)) 
[17:39:36.832]                               next
[17:39:36.832]                             if (!grepl(pattern, name)) 
[17:39:36.832]                               next
[17:39:36.832]                             invokeRestart(restart)
[17:39:36.832]                             muffled <- TRUE
[17:39:36.832]                             break
[17:39:36.832]                           }
[17:39:36.832]                         }
[17:39:36.832]                       }
[17:39:36.832]                       invisible(muffled)
[17:39:36.832]                     }
[17:39:36.832]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.832]                   }
[17:39:36.832]                 }
[17:39:36.832]             }
[17:39:36.832]         }))
[17:39:36.832]     }, error = function(ex) {
[17:39:36.832]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.832]                 ...future.rng), started = ...future.startTime, 
[17:39:36.832]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.832]             version = "1.8"), class = "FutureResult")
[17:39:36.832]     }, finally = {
[17:39:36.832]         if (!identical(...future.workdir, getwd())) 
[17:39:36.832]             setwd(...future.workdir)
[17:39:36.832]         {
[17:39:36.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.832]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.832]             }
[17:39:36.832]             base::options(...future.oldOptions)
[17:39:36.832]             if (.Platform$OS.type == "windows") {
[17:39:36.832]                 old_names <- names(...future.oldEnvVars)
[17:39:36.832]                 envs <- base::Sys.getenv()
[17:39:36.832]                 names <- names(envs)
[17:39:36.832]                 common <- intersect(names, old_names)
[17:39:36.832]                 added <- setdiff(names, old_names)
[17:39:36.832]                 removed <- setdiff(old_names, names)
[17:39:36.832]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.832]                   envs[common]]
[17:39:36.832]                 NAMES <- toupper(changed)
[17:39:36.832]                 args <- list()
[17:39:36.832]                 for (kk in seq_along(NAMES)) {
[17:39:36.832]                   name <- changed[[kk]]
[17:39:36.832]                   NAME <- NAMES[[kk]]
[17:39:36.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.832]                     next
[17:39:36.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.832]                 }
[17:39:36.832]                 NAMES <- toupper(added)
[17:39:36.832]                 for (kk in seq_along(NAMES)) {
[17:39:36.832]                   name <- added[[kk]]
[17:39:36.832]                   NAME <- NAMES[[kk]]
[17:39:36.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.832]                     next
[17:39:36.832]                   args[[name]] <- ""
[17:39:36.832]                 }
[17:39:36.832]                 NAMES <- toupper(removed)
[17:39:36.832]                 for (kk in seq_along(NAMES)) {
[17:39:36.832]                   name <- removed[[kk]]
[17:39:36.832]                   NAME <- NAMES[[kk]]
[17:39:36.832]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.832]                     next
[17:39:36.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.832]                 }
[17:39:36.832]                 if (length(args) > 0) 
[17:39:36.832]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.832]             }
[17:39:36.832]             else {
[17:39:36.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.832]             }
[17:39:36.832]             {
[17:39:36.832]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.832]                   0L) {
[17:39:36.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.832]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.832]                   base::options(opts)
[17:39:36.832]                 }
[17:39:36.832]                 {
[17:39:36.832]                   {
[17:39:36.832]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.832]                     NULL
[17:39:36.832]                   }
[17:39:36.832]                   options(future.plan = NULL)
[17:39:36.832]                   if (is.na(NA_character_)) 
[17:39:36.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.832]                     .init = FALSE)
[17:39:36.832]                 }
[17:39:36.832]             }
[17:39:36.832]         }
[17:39:36.832]     })
[17:39:36.832]     if (TRUE) {
[17:39:36.832]         base::sink(type = "output", split = FALSE)
[17:39:36.832]         if (TRUE) {
[17:39:36.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.832]         }
[17:39:36.832]         else {
[17:39:36.832]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.832]         }
[17:39:36.832]         base::close(...future.stdout)
[17:39:36.832]         ...future.stdout <- NULL
[17:39:36.832]     }
[17:39:36.832]     ...future.result$conditions <- ...future.conditions
[17:39:36.832]     ...future.result$finished <- base::Sys.time()
[17:39:36.832]     ...future.result
[17:39:36.832] }
[17:39:36.835] MultisessionFuture started
[17:39:36.835] - Launch lazy future ... done
[17:39:36.835] run() for ‘MultisessionFuture’ ... done
[17:39:36.836] getGlobalsAndPackages() ...
[17:39:36.836] Searching for globals...
[17:39:36.836] 
[17:39:36.836] Searching for globals ... DONE
[17:39:36.836] - globals: [0] <none>
[17:39:36.836] getGlobalsAndPackages() ... DONE
[17:39:36.837] run() for ‘Future’ ...
[17:39:36.837] - state: ‘created’
[17:39:36.837] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.851]   - Field: ‘node’
[17:39:36.851]   - Field: ‘label’
[17:39:36.851]   - Field: ‘local’
[17:39:36.851]   - Field: ‘owner’
[17:39:36.851]   - Field: ‘envir’
[17:39:36.851]   - Field: ‘workers’
[17:39:36.851]   - Field: ‘packages’
[17:39:36.851]   - Field: ‘gc’
[17:39:36.851]   - Field: ‘conditions’
[17:39:36.852]   - Field: ‘persistent’
[17:39:36.852]   - Field: ‘expr’
[17:39:36.852]   - Field: ‘uuid’
[17:39:36.852]   - Field: ‘seed’
[17:39:36.852]   - Field: ‘version’
[17:39:36.852]   - Field: ‘result’
[17:39:36.852]   - Field: ‘asynchronous’
[17:39:36.852]   - Field: ‘calls’
[17:39:36.852]   - Field: ‘globals’
[17:39:36.852]   - Field: ‘stdout’
[17:39:36.853]   - Field: ‘earlySignal’
[17:39:36.853]   - Field: ‘lazy’
[17:39:36.853]   - Field: ‘state’
[17:39:36.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.853] - Launch lazy future ...
[17:39:36.853] Packages needed by the future expression (n = 0): <none>
[17:39:36.853] Packages needed by future strategies (n = 0): <none>
[17:39:36.854] {
[17:39:36.854]     {
[17:39:36.854]         {
[17:39:36.854]             ...future.startTime <- base::Sys.time()
[17:39:36.854]             {
[17:39:36.854]                 {
[17:39:36.854]                   {
[17:39:36.854]                     {
[17:39:36.854]                       base::local({
[17:39:36.854]                         has_future <- base::requireNamespace("future", 
[17:39:36.854]                           quietly = TRUE)
[17:39:36.854]                         if (has_future) {
[17:39:36.854]                           ns <- base::getNamespace("future")
[17:39:36.854]                           version <- ns[[".package"]][["version"]]
[17:39:36.854]                           if (is.null(version)) 
[17:39:36.854]                             version <- utils::packageVersion("future")
[17:39:36.854]                         }
[17:39:36.854]                         else {
[17:39:36.854]                           version <- NULL
[17:39:36.854]                         }
[17:39:36.854]                         if (!has_future || version < "1.8.0") {
[17:39:36.854]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.854]                             "", base::R.version$version.string), 
[17:39:36.854]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.854]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.854]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.854]                               "release", "version")], collapse = " "), 
[17:39:36.854]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.854]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.854]                             info)
[17:39:36.854]                           info <- base::paste(info, collapse = "; ")
[17:39:36.854]                           if (!has_future) {
[17:39:36.854]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.854]                               info)
[17:39:36.854]                           }
[17:39:36.854]                           else {
[17:39:36.854]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.854]                               info, version)
[17:39:36.854]                           }
[17:39:36.854]                           base::stop(msg)
[17:39:36.854]                         }
[17:39:36.854]                       })
[17:39:36.854]                     }
[17:39:36.854]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.854]                     base::options(mc.cores = 1L)
[17:39:36.854]                   }
[17:39:36.854]                   ...future.strategy.old <- future::plan("list")
[17:39:36.854]                   options(future.plan = NULL)
[17:39:36.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.854]                 }
[17:39:36.854]                 ...future.workdir <- getwd()
[17:39:36.854]             }
[17:39:36.854]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.854]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.854]         }
[17:39:36.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.854]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.854]             base::names(...future.oldOptions))
[17:39:36.854]     }
[17:39:36.854]     if (FALSE) {
[17:39:36.854]     }
[17:39:36.854]     else {
[17:39:36.854]         if (TRUE) {
[17:39:36.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.854]                 open = "w")
[17:39:36.854]         }
[17:39:36.854]         else {
[17:39:36.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.854]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.854]         }
[17:39:36.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.854]             base::sink(type = "output", split = FALSE)
[17:39:36.854]             base::close(...future.stdout)
[17:39:36.854]         }, add = TRUE)
[17:39:36.854]     }
[17:39:36.854]     ...future.frame <- base::sys.nframe()
[17:39:36.854]     ...future.conditions <- base::list()
[17:39:36.854]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.854]     if (FALSE) {
[17:39:36.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.854]     }
[17:39:36.854]     ...future.result <- base::tryCatch({
[17:39:36.854]         base::withCallingHandlers({
[17:39:36.854]             ...future.value <- base::withVisible(base::local({
[17:39:36.854]                 ...future.makeSendCondition <- base::local({
[17:39:36.854]                   sendCondition <- NULL
[17:39:36.854]                   function(frame = 1L) {
[17:39:36.854]                     if (is.function(sendCondition)) 
[17:39:36.854]                       return(sendCondition)
[17:39:36.854]                     ns <- getNamespace("parallel")
[17:39:36.854]                     if (exists("sendData", mode = "function", 
[17:39:36.854]                       envir = ns)) {
[17:39:36.854]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.854]                         envir = ns)
[17:39:36.854]                       envir <- sys.frame(frame)
[17:39:36.854]                       master <- NULL
[17:39:36.854]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.854]                         !identical(envir, emptyenv())) {
[17:39:36.854]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.854]                           inherits = FALSE)) {
[17:39:36.854]                           master <- get("master", mode = "list", 
[17:39:36.854]                             envir = envir, inherits = FALSE)
[17:39:36.854]                           if (inherits(master, c("SOCKnode", 
[17:39:36.854]                             "SOCK0node"))) {
[17:39:36.854]                             sendCondition <<- function(cond) {
[17:39:36.854]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.854]                                 success = TRUE)
[17:39:36.854]                               parallel_sendData(master, data)
[17:39:36.854]                             }
[17:39:36.854]                             return(sendCondition)
[17:39:36.854]                           }
[17:39:36.854]                         }
[17:39:36.854]                         frame <- frame + 1L
[17:39:36.854]                         envir <- sys.frame(frame)
[17:39:36.854]                       }
[17:39:36.854]                     }
[17:39:36.854]                     sendCondition <<- function(cond) NULL
[17:39:36.854]                   }
[17:39:36.854]                 })
[17:39:36.854]                 withCallingHandlers({
[17:39:36.854]                   NULL
[17:39:36.854]                 }, immediateCondition = function(cond) {
[17:39:36.854]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.854]                   sendCondition(cond)
[17:39:36.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.854]                   {
[17:39:36.854]                     inherits <- base::inherits
[17:39:36.854]                     invokeRestart <- base::invokeRestart
[17:39:36.854]                     is.null <- base::is.null
[17:39:36.854]                     muffled <- FALSE
[17:39:36.854]                     if (inherits(cond, "message")) {
[17:39:36.854]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.854]                       if (muffled) 
[17:39:36.854]                         invokeRestart("muffleMessage")
[17:39:36.854]                     }
[17:39:36.854]                     else if (inherits(cond, "warning")) {
[17:39:36.854]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.854]                       if (muffled) 
[17:39:36.854]                         invokeRestart("muffleWarning")
[17:39:36.854]                     }
[17:39:36.854]                     else if (inherits(cond, "condition")) {
[17:39:36.854]                       if (!is.null(pattern)) {
[17:39:36.854]                         computeRestarts <- base::computeRestarts
[17:39:36.854]                         grepl <- base::grepl
[17:39:36.854]                         restarts <- computeRestarts(cond)
[17:39:36.854]                         for (restart in restarts) {
[17:39:36.854]                           name <- restart$name
[17:39:36.854]                           if (is.null(name)) 
[17:39:36.854]                             next
[17:39:36.854]                           if (!grepl(pattern, name)) 
[17:39:36.854]                             next
[17:39:36.854]                           invokeRestart(restart)
[17:39:36.854]                           muffled <- TRUE
[17:39:36.854]                           break
[17:39:36.854]                         }
[17:39:36.854]                       }
[17:39:36.854]                     }
[17:39:36.854]                     invisible(muffled)
[17:39:36.854]                   }
[17:39:36.854]                   muffleCondition(cond)
[17:39:36.854]                 })
[17:39:36.854]             }))
[17:39:36.854]             future::FutureResult(value = ...future.value$value, 
[17:39:36.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.854]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.854]                     ...future.globalenv.names))
[17:39:36.854]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.854]         }, condition = base::local({
[17:39:36.854]             c <- base::c
[17:39:36.854]             inherits <- base::inherits
[17:39:36.854]             invokeRestart <- base::invokeRestart
[17:39:36.854]             length <- base::length
[17:39:36.854]             list <- base::list
[17:39:36.854]             seq.int <- base::seq.int
[17:39:36.854]             signalCondition <- base::signalCondition
[17:39:36.854]             sys.calls <- base::sys.calls
[17:39:36.854]             `[[` <- base::`[[`
[17:39:36.854]             `+` <- base::`+`
[17:39:36.854]             `<<-` <- base::`<<-`
[17:39:36.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.854]                   3L)]
[17:39:36.854]             }
[17:39:36.854]             function(cond) {
[17:39:36.854]                 is_error <- inherits(cond, "error")
[17:39:36.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.854]                   NULL)
[17:39:36.854]                 if (is_error) {
[17:39:36.854]                   sessionInformation <- function() {
[17:39:36.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.854]                       search = base::search(), system = base::Sys.info())
[17:39:36.854]                   }
[17:39:36.854]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.854]                     cond$call), session = sessionInformation(), 
[17:39:36.854]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.854]                   signalCondition(cond)
[17:39:36.854]                 }
[17:39:36.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.854]                 "immediateCondition"))) {
[17:39:36.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.854]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.854]                   if (TRUE && !signal) {
[17:39:36.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.854]                     {
[17:39:36.854]                       inherits <- base::inherits
[17:39:36.854]                       invokeRestart <- base::invokeRestart
[17:39:36.854]                       is.null <- base::is.null
[17:39:36.854]                       muffled <- FALSE
[17:39:36.854]                       if (inherits(cond, "message")) {
[17:39:36.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.854]                         if (muffled) 
[17:39:36.854]                           invokeRestart("muffleMessage")
[17:39:36.854]                       }
[17:39:36.854]                       else if (inherits(cond, "warning")) {
[17:39:36.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.854]                         if (muffled) 
[17:39:36.854]                           invokeRestart("muffleWarning")
[17:39:36.854]                       }
[17:39:36.854]                       else if (inherits(cond, "condition")) {
[17:39:36.854]                         if (!is.null(pattern)) {
[17:39:36.854]                           computeRestarts <- base::computeRestarts
[17:39:36.854]                           grepl <- base::grepl
[17:39:36.854]                           restarts <- computeRestarts(cond)
[17:39:36.854]                           for (restart in restarts) {
[17:39:36.854]                             name <- restart$name
[17:39:36.854]                             if (is.null(name)) 
[17:39:36.854]                               next
[17:39:36.854]                             if (!grepl(pattern, name)) 
[17:39:36.854]                               next
[17:39:36.854]                             invokeRestart(restart)
[17:39:36.854]                             muffled <- TRUE
[17:39:36.854]                             break
[17:39:36.854]                           }
[17:39:36.854]                         }
[17:39:36.854]                       }
[17:39:36.854]                       invisible(muffled)
[17:39:36.854]                     }
[17:39:36.854]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.854]                   }
[17:39:36.854]                 }
[17:39:36.854]                 else {
[17:39:36.854]                   if (TRUE) {
[17:39:36.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.854]                     {
[17:39:36.854]                       inherits <- base::inherits
[17:39:36.854]                       invokeRestart <- base::invokeRestart
[17:39:36.854]                       is.null <- base::is.null
[17:39:36.854]                       muffled <- FALSE
[17:39:36.854]                       if (inherits(cond, "message")) {
[17:39:36.854]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.854]                         if (muffled) 
[17:39:36.854]                           invokeRestart("muffleMessage")
[17:39:36.854]                       }
[17:39:36.854]                       else if (inherits(cond, "warning")) {
[17:39:36.854]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.854]                         if (muffled) 
[17:39:36.854]                           invokeRestart("muffleWarning")
[17:39:36.854]                       }
[17:39:36.854]                       else if (inherits(cond, "condition")) {
[17:39:36.854]                         if (!is.null(pattern)) {
[17:39:36.854]                           computeRestarts <- base::computeRestarts
[17:39:36.854]                           grepl <- base::grepl
[17:39:36.854]                           restarts <- computeRestarts(cond)
[17:39:36.854]                           for (restart in restarts) {
[17:39:36.854]                             name <- restart$name
[17:39:36.854]                             if (is.null(name)) 
[17:39:36.854]                               next
[17:39:36.854]                             if (!grepl(pattern, name)) 
[17:39:36.854]                               next
[17:39:36.854]                             invokeRestart(restart)
[17:39:36.854]                             muffled <- TRUE
[17:39:36.854]                             break
[17:39:36.854]                           }
[17:39:36.854]                         }
[17:39:36.854]                       }
[17:39:36.854]                       invisible(muffled)
[17:39:36.854]                     }
[17:39:36.854]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.854]                   }
[17:39:36.854]                 }
[17:39:36.854]             }
[17:39:36.854]         }))
[17:39:36.854]     }, error = function(ex) {
[17:39:36.854]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.854]                 ...future.rng), started = ...future.startTime, 
[17:39:36.854]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.854]             version = "1.8"), class = "FutureResult")
[17:39:36.854]     }, finally = {
[17:39:36.854]         if (!identical(...future.workdir, getwd())) 
[17:39:36.854]             setwd(...future.workdir)
[17:39:36.854]         {
[17:39:36.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.854]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.854]             }
[17:39:36.854]             base::options(...future.oldOptions)
[17:39:36.854]             if (.Platform$OS.type == "windows") {
[17:39:36.854]                 old_names <- names(...future.oldEnvVars)
[17:39:36.854]                 envs <- base::Sys.getenv()
[17:39:36.854]                 names <- names(envs)
[17:39:36.854]                 common <- intersect(names, old_names)
[17:39:36.854]                 added <- setdiff(names, old_names)
[17:39:36.854]                 removed <- setdiff(old_names, names)
[17:39:36.854]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.854]                   envs[common]]
[17:39:36.854]                 NAMES <- toupper(changed)
[17:39:36.854]                 args <- list()
[17:39:36.854]                 for (kk in seq_along(NAMES)) {
[17:39:36.854]                   name <- changed[[kk]]
[17:39:36.854]                   NAME <- NAMES[[kk]]
[17:39:36.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.854]                     next
[17:39:36.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.854]                 }
[17:39:36.854]                 NAMES <- toupper(added)
[17:39:36.854]                 for (kk in seq_along(NAMES)) {
[17:39:36.854]                   name <- added[[kk]]
[17:39:36.854]                   NAME <- NAMES[[kk]]
[17:39:36.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.854]                     next
[17:39:36.854]                   args[[name]] <- ""
[17:39:36.854]                 }
[17:39:36.854]                 NAMES <- toupper(removed)
[17:39:36.854]                 for (kk in seq_along(NAMES)) {
[17:39:36.854]                   name <- removed[[kk]]
[17:39:36.854]                   NAME <- NAMES[[kk]]
[17:39:36.854]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.854]                     next
[17:39:36.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.854]                 }
[17:39:36.854]                 if (length(args) > 0) 
[17:39:36.854]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.854]             }
[17:39:36.854]             else {
[17:39:36.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.854]             }
[17:39:36.854]             {
[17:39:36.854]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.854]                   0L) {
[17:39:36.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.854]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.854]                   base::options(opts)
[17:39:36.854]                 }
[17:39:36.854]                 {
[17:39:36.854]                   {
[17:39:36.854]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.854]                     NULL
[17:39:36.854]                   }
[17:39:36.854]                   options(future.plan = NULL)
[17:39:36.854]                   if (is.na(NA_character_)) 
[17:39:36.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.854]                     .init = FALSE)
[17:39:36.854]                 }
[17:39:36.854]             }
[17:39:36.854]         }
[17:39:36.854]     })
[17:39:36.854]     if (TRUE) {
[17:39:36.854]         base::sink(type = "output", split = FALSE)
[17:39:36.854]         if (TRUE) {
[17:39:36.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.854]         }
[17:39:36.854]         else {
[17:39:36.854]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.854]         }
[17:39:36.854]         base::close(...future.stdout)
[17:39:36.854]         ...future.stdout <- NULL
[17:39:36.854]     }
[17:39:36.854]     ...future.result$conditions <- ...future.conditions
[17:39:36.854]     ...future.result$finished <- base::Sys.time()
[17:39:36.854]     ...future.result
[17:39:36.854] }
[17:39:36.857] MultisessionFuture started
[17:39:36.857] - Launch lazy future ... done
[17:39:36.857] run() for ‘MultisessionFuture’ ... done
[17:39:36.858] getGlobalsAndPackages() ...
[17:39:36.858] Searching for globals...
[17:39:36.859] - globals found: [1] ‘{’
[17:39:36.859] Searching for globals ... DONE
[17:39:36.859] Resolving globals: FALSE
[17:39:36.859] 
[17:39:36.859] 
[17:39:36.860] getGlobalsAndPackages() ... DONE
[17:39:36.860] run() for ‘Future’ ...
[17:39:36.860] - state: ‘created’
[17:39:36.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.874]   - Field: ‘node’
[17:39:36.875]   - Field: ‘label’
[17:39:36.875]   - Field: ‘local’
[17:39:36.875]   - Field: ‘owner’
[17:39:36.875]   - Field: ‘envir’
[17:39:36.875]   - Field: ‘workers’
[17:39:36.875]   - Field: ‘packages’
[17:39:36.875]   - Field: ‘gc’
[17:39:36.875]   - Field: ‘conditions’
[17:39:36.875]   - Field: ‘persistent’
[17:39:36.875]   - Field: ‘expr’
[17:39:36.875]   - Field: ‘uuid’
[17:39:36.876]   - Field: ‘seed’
[17:39:36.876]   - Field: ‘version’
[17:39:36.876]   - Field: ‘result’
[17:39:36.876]   - Field: ‘asynchronous’
[17:39:36.876]   - Field: ‘calls’
[17:39:36.876]   - Field: ‘globals’
[17:39:36.876]   - Field: ‘stdout’
[17:39:36.876]   - Field: ‘earlySignal’
[17:39:36.876]   - Field: ‘lazy’
[17:39:36.876]   - Field: ‘state’
[17:39:36.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.877] - Launch lazy future ...
[17:39:36.877] Packages needed by the future expression (n = 0): <none>
[17:39:36.877] Packages needed by future strategies (n = 0): <none>
[17:39:36.877] {
[17:39:36.877]     {
[17:39:36.877]         {
[17:39:36.877]             ...future.startTime <- base::Sys.time()
[17:39:36.877]             {
[17:39:36.877]                 {
[17:39:36.877]                   {
[17:39:36.877]                     {
[17:39:36.877]                       base::local({
[17:39:36.877]                         has_future <- base::requireNamespace("future", 
[17:39:36.877]                           quietly = TRUE)
[17:39:36.877]                         if (has_future) {
[17:39:36.877]                           ns <- base::getNamespace("future")
[17:39:36.877]                           version <- ns[[".package"]][["version"]]
[17:39:36.877]                           if (is.null(version)) 
[17:39:36.877]                             version <- utils::packageVersion("future")
[17:39:36.877]                         }
[17:39:36.877]                         else {
[17:39:36.877]                           version <- NULL
[17:39:36.877]                         }
[17:39:36.877]                         if (!has_future || version < "1.8.0") {
[17:39:36.877]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.877]                             "", base::R.version$version.string), 
[17:39:36.877]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.877]                               "release", "version")], collapse = " "), 
[17:39:36.877]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.877]                             info)
[17:39:36.877]                           info <- base::paste(info, collapse = "; ")
[17:39:36.877]                           if (!has_future) {
[17:39:36.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.877]                               info)
[17:39:36.877]                           }
[17:39:36.877]                           else {
[17:39:36.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.877]                               info, version)
[17:39:36.877]                           }
[17:39:36.877]                           base::stop(msg)
[17:39:36.877]                         }
[17:39:36.877]                       })
[17:39:36.877]                     }
[17:39:36.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.877]                     base::options(mc.cores = 1L)
[17:39:36.877]                   }
[17:39:36.877]                   ...future.strategy.old <- future::plan("list")
[17:39:36.877]                   options(future.plan = NULL)
[17:39:36.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.877]                 }
[17:39:36.877]                 ...future.workdir <- getwd()
[17:39:36.877]             }
[17:39:36.877]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.877]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.877]         }
[17:39:36.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.877]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.877]             base::names(...future.oldOptions))
[17:39:36.877]     }
[17:39:36.877]     if (FALSE) {
[17:39:36.877]     }
[17:39:36.877]     else {
[17:39:36.877]         if (TRUE) {
[17:39:36.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.877]                 open = "w")
[17:39:36.877]         }
[17:39:36.877]         else {
[17:39:36.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.877]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.877]         }
[17:39:36.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.877]             base::sink(type = "output", split = FALSE)
[17:39:36.877]             base::close(...future.stdout)
[17:39:36.877]         }, add = TRUE)
[17:39:36.877]     }
[17:39:36.877]     ...future.frame <- base::sys.nframe()
[17:39:36.877]     ...future.conditions <- base::list()
[17:39:36.877]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.877]     if (FALSE) {
[17:39:36.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.877]     }
[17:39:36.877]     ...future.result <- base::tryCatch({
[17:39:36.877]         base::withCallingHandlers({
[17:39:36.877]             ...future.value <- base::withVisible(base::local({
[17:39:36.877]                 ...future.makeSendCondition <- base::local({
[17:39:36.877]                   sendCondition <- NULL
[17:39:36.877]                   function(frame = 1L) {
[17:39:36.877]                     if (is.function(sendCondition)) 
[17:39:36.877]                       return(sendCondition)
[17:39:36.877]                     ns <- getNamespace("parallel")
[17:39:36.877]                     if (exists("sendData", mode = "function", 
[17:39:36.877]                       envir = ns)) {
[17:39:36.877]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.877]                         envir = ns)
[17:39:36.877]                       envir <- sys.frame(frame)
[17:39:36.877]                       master <- NULL
[17:39:36.877]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.877]                         !identical(envir, emptyenv())) {
[17:39:36.877]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.877]                           inherits = FALSE)) {
[17:39:36.877]                           master <- get("master", mode = "list", 
[17:39:36.877]                             envir = envir, inherits = FALSE)
[17:39:36.877]                           if (inherits(master, c("SOCKnode", 
[17:39:36.877]                             "SOCK0node"))) {
[17:39:36.877]                             sendCondition <<- function(cond) {
[17:39:36.877]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.877]                                 success = TRUE)
[17:39:36.877]                               parallel_sendData(master, data)
[17:39:36.877]                             }
[17:39:36.877]                             return(sendCondition)
[17:39:36.877]                           }
[17:39:36.877]                         }
[17:39:36.877]                         frame <- frame + 1L
[17:39:36.877]                         envir <- sys.frame(frame)
[17:39:36.877]                       }
[17:39:36.877]                     }
[17:39:36.877]                     sendCondition <<- function(cond) NULL
[17:39:36.877]                   }
[17:39:36.877]                 })
[17:39:36.877]                 withCallingHandlers({
[17:39:36.877]                   {
[17:39:36.877]                     4
[17:39:36.877]                   }
[17:39:36.877]                 }, immediateCondition = function(cond) {
[17:39:36.877]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.877]                   sendCondition(cond)
[17:39:36.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.877]                   {
[17:39:36.877]                     inherits <- base::inherits
[17:39:36.877]                     invokeRestart <- base::invokeRestart
[17:39:36.877]                     is.null <- base::is.null
[17:39:36.877]                     muffled <- FALSE
[17:39:36.877]                     if (inherits(cond, "message")) {
[17:39:36.877]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.877]                       if (muffled) 
[17:39:36.877]                         invokeRestart("muffleMessage")
[17:39:36.877]                     }
[17:39:36.877]                     else if (inherits(cond, "warning")) {
[17:39:36.877]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.877]                       if (muffled) 
[17:39:36.877]                         invokeRestart("muffleWarning")
[17:39:36.877]                     }
[17:39:36.877]                     else if (inherits(cond, "condition")) {
[17:39:36.877]                       if (!is.null(pattern)) {
[17:39:36.877]                         computeRestarts <- base::computeRestarts
[17:39:36.877]                         grepl <- base::grepl
[17:39:36.877]                         restarts <- computeRestarts(cond)
[17:39:36.877]                         for (restart in restarts) {
[17:39:36.877]                           name <- restart$name
[17:39:36.877]                           if (is.null(name)) 
[17:39:36.877]                             next
[17:39:36.877]                           if (!grepl(pattern, name)) 
[17:39:36.877]                             next
[17:39:36.877]                           invokeRestart(restart)
[17:39:36.877]                           muffled <- TRUE
[17:39:36.877]                           break
[17:39:36.877]                         }
[17:39:36.877]                       }
[17:39:36.877]                     }
[17:39:36.877]                     invisible(muffled)
[17:39:36.877]                   }
[17:39:36.877]                   muffleCondition(cond)
[17:39:36.877]                 })
[17:39:36.877]             }))
[17:39:36.877]             future::FutureResult(value = ...future.value$value, 
[17:39:36.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.877]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.877]                     ...future.globalenv.names))
[17:39:36.877]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.877]         }, condition = base::local({
[17:39:36.877]             c <- base::c
[17:39:36.877]             inherits <- base::inherits
[17:39:36.877]             invokeRestart <- base::invokeRestart
[17:39:36.877]             length <- base::length
[17:39:36.877]             list <- base::list
[17:39:36.877]             seq.int <- base::seq.int
[17:39:36.877]             signalCondition <- base::signalCondition
[17:39:36.877]             sys.calls <- base::sys.calls
[17:39:36.877]             `[[` <- base::`[[`
[17:39:36.877]             `+` <- base::`+`
[17:39:36.877]             `<<-` <- base::`<<-`
[17:39:36.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.877]                   3L)]
[17:39:36.877]             }
[17:39:36.877]             function(cond) {
[17:39:36.877]                 is_error <- inherits(cond, "error")
[17:39:36.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.877]                   NULL)
[17:39:36.877]                 if (is_error) {
[17:39:36.877]                   sessionInformation <- function() {
[17:39:36.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.877]                       search = base::search(), system = base::Sys.info())
[17:39:36.877]                   }
[17:39:36.877]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.877]                     cond$call), session = sessionInformation(), 
[17:39:36.877]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.877]                   signalCondition(cond)
[17:39:36.877]                 }
[17:39:36.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.877]                 "immediateCondition"))) {
[17:39:36.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.877]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.877]                   if (TRUE && !signal) {
[17:39:36.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.877]                     {
[17:39:36.877]                       inherits <- base::inherits
[17:39:36.877]                       invokeRestart <- base::invokeRestart
[17:39:36.877]                       is.null <- base::is.null
[17:39:36.877]                       muffled <- FALSE
[17:39:36.877]                       if (inherits(cond, "message")) {
[17:39:36.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.877]                         if (muffled) 
[17:39:36.877]                           invokeRestart("muffleMessage")
[17:39:36.877]                       }
[17:39:36.877]                       else if (inherits(cond, "warning")) {
[17:39:36.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.877]                         if (muffled) 
[17:39:36.877]                           invokeRestart("muffleWarning")
[17:39:36.877]                       }
[17:39:36.877]                       else if (inherits(cond, "condition")) {
[17:39:36.877]                         if (!is.null(pattern)) {
[17:39:36.877]                           computeRestarts <- base::computeRestarts
[17:39:36.877]                           grepl <- base::grepl
[17:39:36.877]                           restarts <- computeRestarts(cond)
[17:39:36.877]                           for (restart in restarts) {
[17:39:36.877]                             name <- restart$name
[17:39:36.877]                             if (is.null(name)) 
[17:39:36.877]                               next
[17:39:36.877]                             if (!grepl(pattern, name)) 
[17:39:36.877]                               next
[17:39:36.877]                             invokeRestart(restart)
[17:39:36.877]                             muffled <- TRUE
[17:39:36.877]                             break
[17:39:36.877]                           }
[17:39:36.877]                         }
[17:39:36.877]                       }
[17:39:36.877]                       invisible(muffled)
[17:39:36.877]                     }
[17:39:36.877]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.877]                   }
[17:39:36.877]                 }
[17:39:36.877]                 else {
[17:39:36.877]                   if (TRUE) {
[17:39:36.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.877]                     {
[17:39:36.877]                       inherits <- base::inherits
[17:39:36.877]                       invokeRestart <- base::invokeRestart
[17:39:36.877]                       is.null <- base::is.null
[17:39:36.877]                       muffled <- FALSE
[17:39:36.877]                       if (inherits(cond, "message")) {
[17:39:36.877]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.877]                         if (muffled) 
[17:39:36.877]                           invokeRestart("muffleMessage")
[17:39:36.877]                       }
[17:39:36.877]                       else if (inherits(cond, "warning")) {
[17:39:36.877]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.877]                         if (muffled) 
[17:39:36.877]                           invokeRestart("muffleWarning")
[17:39:36.877]                       }
[17:39:36.877]                       else if (inherits(cond, "condition")) {
[17:39:36.877]                         if (!is.null(pattern)) {
[17:39:36.877]                           computeRestarts <- base::computeRestarts
[17:39:36.877]                           grepl <- base::grepl
[17:39:36.877]                           restarts <- computeRestarts(cond)
[17:39:36.877]                           for (restart in restarts) {
[17:39:36.877]                             name <- restart$name
[17:39:36.877]                             if (is.null(name)) 
[17:39:36.877]                               next
[17:39:36.877]                             if (!grepl(pattern, name)) 
[17:39:36.877]                               next
[17:39:36.877]                             invokeRestart(restart)
[17:39:36.877]                             muffled <- TRUE
[17:39:36.877]                             break
[17:39:36.877]                           }
[17:39:36.877]                         }
[17:39:36.877]                       }
[17:39:36.877]                       invisible(muffled)
[17:39:36.877]                     }
[17:39:36.877]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.877]                   }
[17:39:36.877]                 }
[17:39:36.877]             }
[17:39:36.877]         }))
[17:39:36.877]     }, error = function(ex) {
[17:39:36.877]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.877]                 ...future.rng), started = ...future.startTime, 
[17:39:36.877]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.877]             version = "1.8"), class = "FutureResult")
[17:39:36.877]     }, finally = {
[17:39:36.877]         if (!identical(...future.workdir, getwd())) 
[17:39:36.877]             setwd(...future.workdir)
[17:39:36.877]         {
[17:39:36.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.877]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.877]             }
[17:39:36.877]             base::options(...future.oldOptions)
[17:39:36.877]             if (.Platform$OS.type == "windows") {
[17:39:36.877]                 old_names <- names(...future.oldEnvVars)
[17:39:36.877]                 envs <- base::Sys.getenv()
[17:39:36.877]                 names <- names(envs)
[17:39:36.877]                 common <- intersect(names, old_names)
[17:39:36.877]                 added <- setdiff(names, old_names)
[17:39:36.877]                 removed <- setdiff(old_names, names)
[17:39:36.877]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.877]                   envs[common]]
[17:39:36.877]                 NAMES <- toupper(changed)
[17:39:36.877]                 args <- list()
[17:39:36.877]                 for (kk in seq_along(NAMES)) {
[17:39:36.877]                   name <- changed[[kk]]
[17:39:36.877]                   NAME <- NAMES[[kk]]
[17:39:36.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.877]                     next
[17:39:36.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.877]                 }
[17:39:36.877]                 NAMES <- toupper(added)
[17:39:36.877]                 for (kk in seq_along(NAMES)) {
[17:39:36.877]                   name <- added[[kk]]
[17:39:36.877]                   NAME <- NAMES[[kk]]
[17:39:36.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.877]                     next
[17:39:36.877]                   args[[name]] <- ""
[17:39:36.877]                 }
[17:39:36.877]                 NAMES <- toupper(removed)
[17:39:36.877]                 for (kk in seq_along(NAMES)) {
[17:39:36.877]                   name <- removed[[kk]]
[17:39:36.877]                   NAME <- NAMES[[kk]]
[17:39:36.877]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.877]                     next
[17:39:36.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.877]                 }
[17:39:36.877]                 if (length(args) > 0) 
[17:39:36.877]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.877]             }
[17:39:36.877]             else {
[17:39:36.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.877]             }
[17:39:36.877]             {
[17:39:36.877]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.877]                   0L) {
[17:39:36.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.877]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.877]                   base::options(opts)
[17:39:36.877]                 }
[17:39:36.877]                 {
[17:39:36.877]                   {
[17:39:36.877]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.877]                     NULL
[17:39:36.877]                   }
[17:39:36.877]                   options(future.plan = NULL)
[17:39:36.877]                   if (is.na(NA_character_)) 
[17:39:36.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.877]                     .init = FALSE)
[17:39:36.877]                 }
[17:39:36.877]             }
[17:39:36.877]         }
[17:39:36.877]     })
[17:39:36.877]     if (TRUE) {
[17:39:36.877]         base::sink(type = "output", split = FALSE)
[17:39:36.877]         if (TRUE) {
[17:39:36.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.877]         }
[17:39:36.877]         else {
[17:39:36.877]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.877]         }
[17:39:36.877]         base::close(...future.stdout)
[17:39:36.877]         ...future.stdout <- NULL
[17:39:36.877]     }
[17:39:36.877]     ...future.result$conditions <- ...future.conditions
[17:39:36.877]     ...future.result$finished <- base::Sys.time()
[17:39:36.877]     ...future.result
[17:39:36.877] }
[17:39:36.879] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:36.890] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.890] - Validating connection of MultisessionFuture
[17:39:36.890] - received message: FutureResult
[17:39:36.891] - Received FutureResult
[17:39:36.891] - Erased future from FutureRegistry
[17:39:36.891] result() for ClusterFuture ...
[17:39:36.891] - result already collected: FutureResult
[17:39:36.891] result() for ClusterFuture ... done
[17:39:36.891] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.891] result() for ClusterFuture ...
[17:39:36.891] - result already collected: FutureResult
[17:39:36.891] result() for ClusterFuture ... done
[17:39:36.891] result() for ClusterFuture ...
[17:39:36.892] - result already collected: FutureResult
[17:39:36.892] result() for ClusterFuture ... done
[17:39:36.893] MultisessionFuture started
[17:39:36.893] - Launch lazy future ... done
[17:39:36.893] run() for ‘MultisessionFuture’ ... done
<environment: 0x55adf1124468> 
<environment: 0x55adf1f62de0> 
[17:39:36.894] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.895] - Validating connection of MultisessionFuture
[17:39:36.895] - received message: FutureResult
[17:39:36.895] - Received FutureResult
[17:39:36.895] - Erased future from FutureRegistry
[17:39:36.895] result() for ClusterFuture ...
[17:39:36.895] - result already collected: FutureResult
[17:39:36.895] result() for ClusterFuture ... done
[17:39:36.895] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.896] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.896] - Validating connection of MultisessionFuture
[17:39:36.896] - received message: FutureResult
[17:39:36.896] - Received FutureResult
[17:39:36.896] - Erased future from FutureRegistry
[17:39:36.896] result() for ClusterFuture ...
[17:39:36.896] - result already collected: FutureResult
[17:39:36.896] result() for ClusterFuture ... done
[17:39:36.897] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.898] resolve() on environment ...
[17:39:36.898]  recursive: 0
[17:39:36.898]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.898] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.899] - nx: 4
[17:39:36.899] - relay: TRUE
[17:39:36.899] - stdout: TRUE
[17:39:36.899] - signal: TRUE
[17:39:36.899] - resignal: FALSE
[17:39:36.899] - force: TRUE
[17:39:36.899] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.899] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.899]  - until=2
[17:39:36.899]  - relaying element #2
[17:39:36.899] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.899] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.900] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.900]  length: 3 (resolved future 1)
[17:39:36.900] Future #2
[17:39:36.900] result() for ClusterFuture ...
[17:39:36.900] - result already collected: FutureResult
[17:39:36.900] result() for ClusterFuture ... done
[17:39:36.900] result() for ClusterFuture ...
[17:39:36.900] - result already collected: FutureResult
[17:39:36.900] result() for ClusterFuture ... done
[17:39:36.900] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:36.900] - nx: 4
[17:39:36.901] - relay: TRUE
[17:39:36.901] - stdout: TRUE
[17:39:36.901] - signal: TRUE
[17:39:36.901] - resignal: FALSE
[17:39:36.901] - force: TRUE
[17:39:36.901] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.901] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.901]  - until=2
[17:39:36.901]  - relaying element #2
[17:39:36.901] result() for ClusterFuture ...
[17:39:36.901] - result already collected: FutureResult
[17:39:36.902] result() for ClusterFuture ... done
[17:39:36.902] result() for ClusterFuture ...
[17:39:36.902] - result already collected: FutureResult
[17:39:36.902] result() for ClusterFuture ... done
[17:39:36.902] result() for ClusterFuture ...
[17:39:36.902] - result already collected: FutureResult
[17:39:36.902] result() for ClusterFuture ... done
[17:39:36.902] result() for ClusterFuture ...
[17:39:36.902] - result already collected: FutureResult
[17:39:36.902] result() for ClusterFuture ... done
[17:39:36.902] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.902] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.903] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:36.903]  length: 2 (resolved future 2)
[17:39:36.903] Future #3
[17:39:36.903] result() for ClusterFuture ...
[17:39:36.903] - result already collected: FutureResult
[17:39:36.905] result() for ClusterFuture ... done
[17:39:36.906] result() for ClusterFuture ...
[17:39:36.906] - result already collected: FutureResult
[17:39:36.906] result() for ClusterFuture ... done
[17:39:36.906] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:36.906] - nx: 4
[17:39:36.906] - relay: TRUE
[17:39:36.906] - stdout: TRUE
[17:39:36.906] - signal: TRUE
[17:39:36.906] - resignal: FALSE
[17:39:36.907] - force: TRUE
[17:39:36.907] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:36.907] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:36.907]  - until=3
[17:39:36.907]  - relaying element #3
[17:39:36.907] result() for ClusterFuture ...
[17:39:36.907] - result already collected: FutureResult
[17:39:36.907] result() for ClusterFuture ... done
[17:39:36.907] result() for ClusterFuture ...
[17:39:36.907] - result already collected: FutureResult
[17:39:36.907] result() for ClusterFuture ... done
[17:39:36.908] result() for ClusterFuture ...
[17:39:36.908] - result already collected: FutureResult
[17:39:36.908] result() for ClusterFuture ... done
[17:39:36.908] result() for ClusterFuture ...
[17:39:36.908] - result already collected: FutureResult
[17:39:36.908] result() for ClusterFuture ... done
[17:39:36.908] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.908] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.908] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:36.908]  length: 1 (resolved future 3)
[17:39:36.908] Future #4
[17:39:36.909] result() for ClusterFuture ...
[17:39:36.909] - result already collected: FutureResult
[17:39:36.909] result() for ClusterFuture ... done
[17:39:36.909] result() for ClusterFuture ...
[17:39:36.909] - result already collected: FutureResult
[17:39:36.909] result() for ClusterFuture ... done
[17:39:36.909] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:36.909] - nx: 4
[17:39:36.909] - relay: TRUE
[17:39:36.909] - stdout: TRUE
[17:39:36.909] - signal: TRUE
[17:39:36.909] - resignal: FALSE
[17:39:36.910] - force: TRUE
[17:39:36.910] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:36.910] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:36.910]  - until=4
[17:39:36.910]  - relaying element #4
[17:39:36.910] result() for ClusterFuture ...
[17:39:36.910] - result already collected: FutureResult
[17:39:36.910] result() for ClusterFuture ... done
[17:39:36.910] result() for ClusterFuture ...
[17:39:36.910] - result already collected: FutureResult
[17:39:36.910] result() for ClusterFuture ... done
[17:39:36.910] result() for ClusterFuture ...
[17:39:36.911] - result already collected: FutureResult
[17:39:36.911] result() for ClusterFuture ... done
[17:39:36.911] result() for ClusterFuture ...
[17:39:36.911] - result already collected: FutureResult
[17:39:36.911] result() for ClusterFuture ... done
[17:39:36.911] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.911] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.911] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:36.911]  length: 0 (resolved future 4)
[17:39:36.911] Relaying remaining futures
[17:39:36.911] signalConditionsASAP(NULL, pos=0) ...
[17:39:36.911] - nx: 4
[17:39:36.912] - relay: TRUE
[17:39:36.912] - stdout: TRUE
[17:39:36.912] - signal: TRUE
[17:39:36.912] - resignal: FALSE
[17:39:36.912] - force: TRUE
[17:39:36.912] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.912] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:36.912] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:36.912] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:36.912] signalConditionsASAP(NULL, pos=0) ... done
[17:39:36.912] resolve() on environment ... DONE
[17:39:36.913] result() for ClusterFuture ...
[17:39:36.913] - result already collected: FutureResult
[17:39:36.913] result() for ClusterFuture ... done
[17:39:36.913] result() for ClusterFuture ...
[17:39:36.913] - result already collected: FutureResult
[17:39:36.913] result() for ClusterFuture ... done
[17:39:36.913] result() for ClusterFuture ...
[17:39:36.913] - result already collected: FutureResult
[17:39:36.913] result() for ClusterFuture ... done
[17:39:36.913] result() for ClusterFuture ...
[17:39:36.913] - result already collected: FutureResult
[17:39:36.913] result() for ClusterFuture ... done
[17:39:36.914] result() for ClusterFuture ...
[17:39:36.914] - result already collected: FutureResult
[17:39:36.914] result() for ClusterFuture ... done
[17:39:36.914] result() for ClusterFuture ...
[17:39:36.914] - result already collected: FutureResult
[17:39:36.914] result() for ClusterFuture ... done
<environment: 0x55adf21101d0> 
Dimensions: c(2, 3, 1)
[17:39:36.914] getGlobalsAndPackages() ...
[17:39:36.914] Searching for globals...
[17:39:36.915] 
[17:39:36.915] Searching for globals ... DONE
[17:39:36.915] - globals: [0] <none>
[17:39:36.915] getGlobalsAndPackages() ... DONE
[17:39:36.915] run() for ‘Future’ ...
[17:39:36.915] - state: ‘created’
[17:39:36.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.929]   - Field: ‘node’
[17:39:36.930]   - Field: ‘label’
[17:39:36.930]   - Field: ‘local’
[17:39:36.930]   - Field: ‘owner’
[17:39:36.930]   - Field: ‘envir’
[17:39:36.930]   - Field: ‘workers’
[17:39:36.930]   - Field: ‘packages’
[17:39:36.930]   - Field: ‘gc’
[17:39:36.930]   - Field: ‘conditions’
[17:39:36.930]   - Field: ‘persistent’
[17:39:36.930]   - Field: ‘expr’
[17:39:36.930]   - Field: ‘uuid’
[17:39:36.930]   - Field: ‘seed’
[17:39:36.931]   - Field: ‘version’
[17:39:36.931]   - Field: ‘result’
[17:39:36.931]   - Field: ‘asynchronous’
[17:39:36.931]   - Field: ‘calls’
[17:39:36.931]   - Field: ‘globals’
[17:39:36.931]   - Field: ‘stdout’
[17:39:36.931]   - Field: ‘earlySignal’
[17:39:36.931]   - Field: ‘lazy’
[17:39:36.931]   - Field: ‘state’
[17:39:36.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.931] - Launch lazy future ...
[17:39:36.932] Packages needed by the future expression (n = 0): <none>
[17:39:36.932] Packages needed by future strategies (n = 0): <none>
[17:39:36.932] {
[17:39:36.932]     {
[17:39:36.932]         {
[17:39:36.932]             ...future.startTime <- base::Sys.time()
[17:39:36.932]             {
[17:39:36.932]                 {
[17:39:36.932]                   {
[17:39:36.932]                     {
[17:39:36.932]                       base::local({
[17:39:36.932]                         has_future <- base::requireNamespace("future", 
[17:39:36.932]                           quietly = TRUE)
[17:39:36.932]                         if (has_future) {
[17:39:36.932]                           ns <- base::getNamespace("future")
[17:39:36.932]                           version <- ns[[".package"]][["version"]]
[17:39:36.932]                           if (is.null(version)) 
[17:39:36.932]                             version <- utils::packageVersion("future")
[17:39:36.932]                         }
[17:39:36.932]                         else {
[17:39:36.932]                           version <- NULL
[17:39:36.932]                         }
[17:39:36.932]                         if (!has_future || version < "1.8.0") {
[17:39:36.932]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.932]                             "", base::R.version$version.string), 
[17:39:36.932]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.932]                               "release", "version")], collapse = " "), 
[17:39:36.932]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.932]                             info)
[17:39:36.932]                           info <- base::paste(info, collapse = "; ")
[17:39:36.932]                           if (!has_future) {
[17:39:36.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.932]                               info)
[17:39:36.932]                           }
[17:39:36.932]                           else {
[17:39:36.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.932]                               info, version)
[17:39:36.932]                           }
[17:39:36.932]                           base::stop(msg)
[17:39:36.932]                         }
[17:39:36.932]                       })
[17:39:36.932]                     }
[17:39:36.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.932]                     base::options(mc.cores = 1L)
[17:39:36.932]                   }
[17:39:36.932]                   ...future.strategy.old <- future::plan("list")
[17:39:36.932]                   options(future.plan = NULL)
[17:39:36.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.932]                 }
[17:39:36.932]                 ...future.workdir <- getwd()
[17:39:36.932]             }
[17:39:36.932]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.932]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.932]         }
[17:39:36.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.932]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.932]             base::names(...future.oldOptions))
[17:39:36.932]     }
[17:39:36.932]     if (FALSE) {
[17:39:36.932]     }
[17:39:36.932]     else {
[17:39:36.932]         if (TRUE) {
[17:39:36.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.932]                 open = "w")
[17:39:36.932]         }
[17:39:36.932]         else {
[17:39:36.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.932]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.932]         }
[17:39:36.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.932]             base::sink(type = "output", split = FALSE)
[17:39:36.932]             base::close(...future.stdout)
[17:39:36.932]         }, add = TRUE)
[17:39:36.932]     }
[17:39:36.932]     ...future.frame <- base::sys.nframe()
[17:39:36.932]     ...future.conditions <- base::list()
[17:39:36.932]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.932]     if (FALSE) {
[17:39:36.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.932]     }
[17:39:36.932]     ...future.result <- base::tryCatch({
[17:39:36.932]         base::withCallingHandlers({
[17:39:36.932]             ...future.value <- base::withVisible(base::local({
[17:39:36.932]                 ...future.makeSendCondition <- base::local({
[17:39:36.932]                   sendCondition <- NULL
[17:39:36.932]                   function(frame = 1L) {
[17:39:36.932]                     if (is.function(sendCondition)) 
[17:39:36.932]                       return(sendCondition)
[17:39:36.932]                     ns <- getNamespace("parallel")
[17:39:36.932]                     if (exists("sendData", mode = "function", 
[17:39:36.932]                       envir = ns)) {
[17:39:36.932]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.932]                         envir = ns)
[17:39:36.932]                       envir <- sys.frame(frame)
[17:39:36.932]                       master <- NULL
[17:39:36.932]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.932]                         !identical(envir, emptyenv())) {
[17:39:36.932]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.932]                           inherits = FALSE)) {
[17:39:36.932]                           master <- get("master", mode = "list", 
[17:39:36.932]                             envir = envir, inherits = FALSE)
[17:39:36.932]                           if (inherits(master, c("SOCKnode", 
[17:39:36.932]                             "SOCK0node"))) {
[17:39:36.932]                             sendCondition <<- function(cond) {
[17:39:36.932]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.932]                                 success = TRUE)
[17:39:36.932]                               parallel_sendData(master, data)
[17:39:36.932]                             }
[17:39:36.932]                             return(sendCondition)
[17:39:36.932]                           }
[17:39:36.932]                         }
[17:39:36.932]                         frame <- frame + 1L
[17:39:36.932]                         envir <- sys.frame(frame)
[17:39:36.932]                       }
[17:39:36.932]                     }
[17:39:36.932]                     sendCondition <<- function(cond) NULL
[17:39:36.932]                   }
[17:39:36.932]                 })
[17:39:36.932]                 withCallingHandlers({
[17:39:36.932]                   2
[17:39:36.932]                 }, immediateCondition = function(cond) {
[17:39:36.932]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.932]                   sendCondition(cond)
[17:39:36.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.932]                   {
[17:39:36.932]                     inherits <- base::inherits
[17:39:36.932]                     invokeRestart <- base::invokeRestart
[17:39:36.932]                     is.null <- base::is.null
[17:39:36.932]                     muffled <- FALSE
[17:39:36.932]                     if (inherits(cond, "message")) {
[17:39:36.932]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.932]                       if (muffled) 
[17:39:36.932]                         invokeRestart("muffleMessage")
[17:39:36.932]                     }
[17:39:36.932]                     else if (inherits(cond, "warning")) {
[17:39:36.932]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.932]                       if (muffled) 
[17:39:36.932]                         invokeRestart("muffleWarning")
[17:39:36.932]                     }
[17:39:36.932]                     else if (inherits(cond, "condition")) {
[17:39:36.932]                       if (!is.null(pattern)) {
[17:39:36.932]                         computeRestarts <- base::computeRestarts
[17:39:36.932]                         grepl <- base::grepl
[17:39:36.932]                         restarts <- computeRestarts(cond)
[17:39:36.932]                         for (restart in restarts) {
[17:39:36.932]                           name <- restart$name
[17:39:36.932]                           if (is.null(name)) 
[17:39:36.932]                             next
[17:39:36.932]                           if (!grepl(pattern, name)) 
[17:39:36.932]                             next
[17:39:36.932]                           invokeRestart(restart)
[17:39:36.932]                           muffled <- TRUE
[17:39:36.932]                           break
[17:39:36.932]                         }
[17:39:36.932]                       }
[17:39:36.932]                     }
[17:39:36.932]                     invisible(muffled)
[17:39:36.932]                   }
[17:39:36.932]                   muffleCondition(cond)
[17:39:36.932]                 })
[17:39:36.932]             }))
[17:39:36.932]             future::FutureResult(value = ...future.value$value, 
[17:39:36.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.932]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.932]                     ...future.globalenv.names))
[17:39:36.932]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.932]         }, condition = base::local({
[17:39:36.932]             c <- base::c
[17:39:36.932]             inherits <- base::inherits
[17:39:36.932]             invokeRestart <- base::invokeRestart
[17:39:36.932]             length <- base::length
[17:39:36.932]             list <- base::list
[17:39:36.932]             seq.int <- base::seq.int
[17:39:36.932]             signalCondition <- base::signalCondition
[17:39:36.932]             sys.calls <- base::sys.calls
[17:39:36.932]             `[[` <- base::`[[`
[17:39:36.932]             `+` <- base::`+`
[17:39:36.932]             `<<-` <- base::`<<-`
[17:39:36.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.932]                   3L)]
[17:39:36.932]             }
[17:39:36.932]             function(cond) {
[17:39:36.932]                 is_error <- inherits(cond, "error")
[17:39:36.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.932]                   NULL)
[17:39:36.932]                 if (is_error) {
[17:39:36.932]                   sessionInformation <- function() {
[17:39:36.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.932]                       search = base::search(), system = base::Sys.info())
[17:39:36.932]                   }
[17:39:36.932]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.932]                     cond$call), session = sessionInformation(), 
[17:39:36.932]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.932]                   signalCondition(cond)
[17:39:36.932]                 }
[17:39:36.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.932]                 "immediateCondition"))) {
[17:39:36.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.932]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.932]                   if (TRUE && !signal) {
[17:39:36.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.932]                     {
[17:39:36.932]                       inherits <- base::inherits
[17:39:36.932]                       invokeRestart <- base::invokeRestart
[17:39:36.932]                       is.null <- base::is.null
[17:39:36.932]                       muffled <- FALSE
[17:39:36.932]                       if (inherits(cond, "message")) {
[17:39:36.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.932]                         if (muffled) 
[17:39:36.932]                           invokeRestart("muffleMessage")
[17:39:36.932]                       }
[17:39:36.932]                       else if (inherits(cond, "warning")) {
[17:39:36.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.932]                         if (muffled) 
[17:39:36.932]                           invokeRestart("muffleWarning")
[17:39:36.932]                       }
[17:39:36.932]                       else if (inherits(cond, "condition")) {
[17:39:36.932]                         if (!is.null(pattern)) {
[17:39:36.932]                           computeRestarts <- base::computeRestarts
[17:39:36.932]                           grepl <- base::grepl
[17:39:36.932]                           restarts <- computeRestarts(cond)
[17:39:36.932]                           for (restart in restarts) {
[17:39:36.932]                             name <- restart$name
[17:39:36.932]                             if (is.null(name)) 
[17:39:36.932]                               next
[17:39:36.932]                             if (!grepl(pattern, name)) 
[17:39:36.932]                               next
[17:39:36.932]                             invokeRestart(restart)
[17:39:36.932]                             muffled <- TRUE
[17:39:36.932]                             break
[17:39:36.932]                           }
[17:39:36.932]                         }
[17:39:36.932]                       }
[17:39:36.932]                       invisible(muffled)
[17:39:36.932]                     }
[17:39:36.932]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.932]                   }
[17:39:36.932]                 }
[17:39:36.932]                 else {
[17:39:36.932]                   if (TRUE) {
[17:39:36.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.932]                     {
[17:39:36.932]                       inherits <- base::inherits
[17:39:36.932]                       invokeRestart <- base::invokeRestart
[17:39:36.932]                       is.null <- base::is.null
[17:39:36.932]                       muffled <- FALSE
[17:39:36.932]                       if (inherits(cond, "message")) {
[17:39:36.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.932]                         if (muffled) 
[17:39:36.932]                           invokeRestart("muffleMessage")
[17:39:36.932]                       }
[17:39:36.932]                       else if (inherits(cond, "warning")) {
[17:39:36.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.932]                         if (muffled) 
[17:39:36.932]                           invokeRestart("muffleWarning")
[17:39:36.932]                       }
[17:39:36.932]                       else if (inherits(cond, "condition")) {
[17:39:36.932]                         if (!is.null(pattern)) {
[17:39:36.932]                           computeRestarts <- base::computeRestarts
[17:39:36.932]                           grepl <- base::grepl
[17:39:36.932]                           restarts <- computeRestarts(cond)
[17:39:36.932]                           for (restart in restarts) {
[17:39:36.932]                             name <- restart$name
[17:39:36.932]                             if (is.null(name)) 
[17:39:36.932]                               next
[17:39:36.932]                             if (!grepl(pattern, name)) 
[17:39:36.932]                               next
[17:39:36.932]                             invokeRestart(restart)
[17:39:36.932]                             muffled <- TRUE
[17:39:36.932]                             break
[17:39:36.932]                           }
[17:39:36.932]                         }
[17:39:36.932]                       }
[17:39:36.932]                       invisible(muffled)
[17:39:36.932]                     }
[17:39:36.932]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.932]                   }
[17:39:36.932]                 }
[17:39:36.932]             }
[17:39:36.932]         }))
[17:39:36.932]     }, error = function(ex) {
[17:39:36.932]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.932]                 ...future.rng), started = ...future.startTime, 
[17:39:36.932]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.932]             version = "1.8"), class = "FutureResult")
[17:39:36.932]     }, finally = {
[17:39:36.932]         if (!identical(...future.workdir, getwd())) 
[17:39:36.932]             setwd(...future.workdir)
[17:39:36.932]         {
[17:39:36.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.932]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.932]             }
[17:39:36.932]             base::options(...future.oldOptions)
[17:39:36.932]             if (.Platform$OS.type == "windows") {
[17:39:36.932]                 old_names <- names(...future.oldEnvVars)
[17:39:36.932]                 envs <- base::Sys.getenv()
[17:39:36.932]                 names <- names(envs)
[17:39:36.932]                 common <- intersect(names, old_names)
[17:39:36.932]                 added <- setdiff(names, old_names)
[17:39:36.932]                 removed <- setdiff(old_names, names)
[17:39:36.932]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.932]                   envs[common]]
[17:39:36.932]                 NAMES <- toupper(changed)
[17:39:36.932]                 args <- list()
[17:39:36.932]                 for (kk in seq_along(NAMES)) {
[17:39:36.932]                   name <- changed[[kk]]
[17:39:36.932]                   NAME <- NAMES[[kk]]
[17:39:36.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.932]                     next
[17:39:36.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.932]                 }
[17:39:36.932]                 NAMES <- toupper(added)
[17:39:36.932]                 for (kk in seq_along(NAMES)) {
[17:39:36.932]                   name <- added[[kk]]
[17:39:36.932]                   NAME <- NAMES[[kk]]
[17:39:36.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.932]                     next
[17:39:36.932]                   args[[name]] <- ""
[17:39:36.932]                 }
[17:39:36.932]                 NAMES <- toupper(removed)
[17:39:36.932]                 for (kk in seq_along(NAMES)) {
[17:39:36.932]                   name <- removed[[kk]]
[17:39:36.932]                   NAME <- NAMES[[kk]]
[17:39:36.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.932]                     next
[17:39:36.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.932]                 }
[17:39:36.932]                 if (length(args) > 0) 
[17:39:36.932]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.932]             }
[17:39:36.932]             else {
[17:39:36.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.932]             }
[17:39:36.932]             {
[17:39:36.932]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.932]                   0L) {
[17:39:36.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.932]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.932]                   base::options(opts)
[17:39:36.932]                 }
[17:39:36.932]                 {
[17:39:36.932]                   {
[17:39:36.932]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.932]                     NULL
[17:39:36.932]                   }
[17:39:36.932]                   options(future.plan = NULL)
[17:39:36.932]                   if (is.na(NA_character_)) 
[17:39:36.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.932]                     .init = FALSE)
[17:39:36.932]                 }
[17:39:36.932]             }
[17:39:36.932]         }
[17:39:36.932]     })
[17:39:36.932]     if (TRUE) {
[17:39:36.932]         base::sink(type = "output", split = FALSE)
[17:39:36.932]         if (TRUE) {
[17:39:36.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.932]         }
[17:39:36.932]         else {
[17:39:36.932]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.932]         }
[17:39:36.932]         base::close(...future.stdout)
[17:39:36.932]         ...future.stdout <- NULL
[17:39:36.932]     }
[17:39:36.932]     ...future.result$conditions <- ...future.conditions
[17:39:36.932]     ...future.result$finished <- base::Sys.time()
[17:39:36.932]     ...future.result
[17:39:36.932] }
[17:39:36.935] MultisessionFuture started
[17:39:36.935] - Launch lazy future ... done
[17:39:36.935] run() for ‘MultisessionFuture’ ... done
[17:39:36.936] getGlobalsAndPackages() ...
[17:39:36.936] Searching for globals...
[17:39:36.936] 
[17:39:36.936] Searching for globals ... DONE
[17:39:36.937] - globals: [0] <none>
[17:39:36.937] getGlobalsAndPackages() ... DONE
[17:39:36.937] run() for ‘Future’ ...
[17:39:36.937] - state: ‘created’
[17:39:36.937] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.951]   - Field: ‘node’
[17:39:36.951]   - Field: ‘label’
[17:39:36.951]   - Field: ‘local’
[17:39:36.951]   - Field: ‘owner’
[17:39:36.951]   - Field: ‘envir’
[17:39:36.951]   - Field: ‘workers’
[17:39:36.951]   - Field: ‘packages’
[17:39:36.952]   - Field: ‘gc’
[17:39:36.952]   - Field: ‘conditions’
[17:39:36.952]   - Field: ‘persistent’
[17:39:36.952]   - Field: ‘expr’
[17:39:36.952]   - Field: ‘uuid’
[17:39:36.952]   - Field: ‘seed’
[17:39:36.952]   - Field: ‘version’
[17:39:36.952]   - Field: ‘result’
[17:39:36.952]   - Field: ‘asynchronous’
[17:39:36.952]   - Field: ‘calls’
[17:39:36.952]   - Field: ‘globals’
[17:39:36.953]   - Field: ‘stdout’
[17:39:36.953]   - Field: ‘earlySignal’
[17:39:36.953]   - Field: ‘lazy’
[17:39:36.953]   - Field: ‘state’
[17:39:36.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.953] - Launch lazy future ...
[17:39:36.953] Packages needed by the future expression (n = 0): <none>
[17:39:36.953] Packages needed by future strategies (n = 0): <none>
[17:39:36.954] {
[17:39:36.954]     {
[17:39:36.954]         {
[17:39:36.954]             ...future.startTime <- base::Sys.time()
[17:39:36.954]             {
[17:39:36.954]                 {
[17:39:36.954]                   {
[17:39:36.954]                     {
[17:39:36.954]                       base::local({
[17:39:36.954]                         has_future <- base::requireNamespace("future", 
[17:39:36.954]                           quietly = TRUE)
[17:39:36.954]                         if (has_future) {
[17:39:36.954]                           ns <- base::getNamespace("future")
[17:39:36.954]                           version <- ns[[".package"]][["version"]]
[17:39:36.954]                           if (is.null(version)) 
[17:39:36.954]                             version <- utils::packageVersion("future")
[17:39:36.954]                         }
[17:39:36.954]                         else {
[17:39:36.954]                           version <- NULL
[17:39:36.954]                         }
[17:39:36.954]                         if (!has_future || version < "1.8.0") {
[17:39:36.954]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.954]                             "", base::R.version$version.string), 
[17:39:36.954]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.954]                               "release", "version")], collapse = " "), 
[17:39:36.954]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.954]                             info)
[17:39:36.954]                           info <- base::paste(info, collapse = "; ")
[17:39:36.954]                           if (!has_future) {
[17:39:36.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.954]                               info)
[17:39:36.954]                           }
[17:39:36.954]                           else {
[17:39:36.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.954]                               info, version)
[17:39:36.954]                           }
[17:39:36.954]                           base::stop(msg)
[17:39:36.954]                         }
[17:39:36.954]                       })
[17:39:36.954]                     }
[17:39:36.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.954]                     base::options(mc.cores = 1L)
[17:39:36.954]                   }
[17:39:36.954]                   ...future.strategy.old <- future::plan("list")
[17:39:36.954]                   options(future.plan = NULL)
[17:39:36.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.954]                 }
[17:39:36.954]                 ...future.workdir <- getwd()
[17:39:36.954]             }
[17:39:36.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.954]         }
[17:39:36.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.954]             base::names(...future.oldOptions))
[17:39:36.954]     }
[17:39:36.954]     if (FALSE) {
[17:39:36.954]     }
[17:39:36.954]     else {
[17:39:36.954]         if (TRUE) {
[17:39:36.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.954]                 open = "w")
[17:39:36.954]         }
[17:39:36.954]         else {
[17:39:36.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.954]         }
[17:39:36.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.954]             base::sink(type = "output", split = FALSE)
[17:39:36.954]             base::close(...future.stdout)
[17:39:36.954]         }, add = TRUE)
[17:39:36.954]     }
[17:39:36.954]     ...future.frame <- base::sys.nframe()
[17:39:36.954]     ...future.conditions <- base::list()
[17:39:36.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.954]     if (FALSE) {
[17:39:36.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.954]     }
[17:39:36.954]     ...future.result <- base::tryCatch({
[17:39:36.954]         base::withCallingHandlers({
[17:39:36.954]             ...future.value <- base::withVisible(base::local({
[17:39:36.954]                 ...future.makeSendCondition <- base::local({
[17:39:36.954]                   sendCondition <- NULL
[17:39:36.954]                   function(frame = 1L) {
[17:39:36.954]                     if (is.function(sendCondition)) 
[17:39:36.954]                       return(sendCondition)
[17:39:36.954]                     ns <- getNamespace("parallel")
[17:39:36.954]                     if (exists("sendData", mode = "function", 
[17:39:36.954]                       envir = ns)) {
[17:39:36.954]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.954]                         envir = ns)
[17:39:36.954]                       envir <- sys.frame(frame)
[17:39:36.954]                       master <- NULL
[17:39:36.954]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.954]                         !identical(envir, emptyenv())) {
[17:39:36.954]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.954]                           inherits = FALSE)) {
[17:39:36.954]                           master <- get("master", mode = "list", 
[17:39:36.954]                             envir = envir, inherits = FALSE)
[17:39:36.954]                           if (inherits(master, c("SOCKnode", 
[17:39:36.954]                             "SOCK0node"))) {
[17:39:36.954]                             sendCondition <<- function(cond) {
[17:39:36.954]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.954]                                 success = TRUE)
[17:39:36.954]                               parallel_sendData(master, data)
[17:39:36.954]                             }
[17:39:36.954]                             return(sendCondition)
[17:39:36.954]                           }
[17:39:36.954]                         }
[17:39:36.954]                         frame <- frame + 1L
[17:39:36.954]                         envir <- sys.frame(frame)
[17:39:36.954]                       }
[17:39:36.954]                     }
[17:39:36.954]                     sendCondition <<- function(cond) NULL
[17:39:36.954]                   }
[17:39:36.954]                 })
[17:39:36.954]                 withCallingHandlers({
[17:39:36.954]                   NULL
[17:39:36.954]                 }, immediateCondition = function(cond) {
[17:39:36.954]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.954]                   sendCondition(cond)
[17:39:36.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.954]                   {
[17:39:36.954]                     inherits <- base::inherits
[17:39:36.954]                     invokeRestart <- base::invokeRestart
[17:39:36.954]                     is.null <- base::is.null
[17:39:36.954]                     muffled <- FALSE
[17:39:36.954]                     if (inherits(cond, "message")) {
[17:39:36.954]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.954]                       if (muffled) 
[17:39:36.954]                         invokeRestart("muffleMessage")
[17:39:36.954]                     }
[17:39:36.954]                     else if (inherits(cond, "warning")) {
[17:39:36.954]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.954]                       if (muffled) 
[17:39:36.954]                         invokeRestart("muffleWarning")
[17:39:36.954]                     }
[17:39:36.954]                     else if (inherits(cond, "condition")) {
[17:39:36.954]                       if (!is.null(pattern)) {
[17:39:36.954]                         computeRestarts <- base::computeRestarts
[17:39:36.954]                         grepl <- base::grepl
[17:39:36.954]                         restarts <- computeRestarts(cond)
[17:39:36.954]                         for (restart in restarts) {
[17:39:36.954]                           name <- restart$name
[17:39:36.954]                           if (is.null(name)) 
[17:39:36.954]                             next
[17:39:36.954]                           if (!grepl(pattern, name)) 
[17:39:36.954]                             next
[17:39:36.954]                           invokeRestart(restart)
[17:39:36.954]                           muffled <- TRUE
[17:39:36.954]                           break
[17:39:36.954]                         }
[17:39:36.954]                       }
[17:39:36.954]                     }
[17:39:36.954]                     invisible(muffled)
[17:39:36.954]                   }
[17:39:36.954]                   muffleCondition(cond)
[17:39:36.954]                 })
[17:39:36.954]             }))
[17:39:36.954]             future::FutureResult(value = ...future.value$value, 
[17:39:36.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.954]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.954]                     ...future.globalenv.names))
[17:39:36.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.954]         }, condition = base::local({
[17:39:36.954]             c <- base::c
[17:39:36.954]             inherits <- base::inherits
[17:39:36.954]             invokeRestart <- base::invokeRestart
[17:39:36.954]             length <- base::length
[17:39:36.954]             list <- base::list
[17:39:36.954]             seq.int <- base::seq.int
[17:39:36.954]             signalCondition <- base::signalCondition
[17:39:36.954]             sys.calls <- base::sys.calls
[17:39:36.954]             `[[` <- base::`[[`
[17:39:36.954]             `+` <- base::`+`
[17:39:36.954]             `<<-` <- base::`<<-`
[17:39:36.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.954]                   3L)]
[17:39:36.954]             }
[17:39:36.954]             function(cond) {
[17:39:36.954]                 is_error <- inherits(cond, "error")
[17:39:36.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.954]                   NULL)
[17:39:36.954]                 if (is_error) {
[17:39:36.954]                   sessionInformation <- function() {
[17:39:36.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.954]                       search = base::search(), system = base::Sys.info())
[17:39:36.954]                   }
[17:39:36.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.954]                     cond$call), session = sessionInformation(), 
[17:39:36.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.954]                   signalCondition(cond)
[17:39:36.954]                 }
[17:39:36.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.954]                 "immediateCondition"))) {
[17:39:36.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.954]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.954]                   if (TRUE && !signal) {
[17:39:36.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.954]                     {
[17:39:36.954]                       inherits <- base::inherits
[17:39:36.954]                       invokeRestart <- base::invokeRestart
[17:39:36.954]                       is.null <- base::is.null
[17:39:36.954]                       muffled <- FALSE
[17:39:36.954]                       if (inherits(cond, "message")) {
[17:39:36.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.954]                         if (muffled) 
[17:39:36.954]                           invokeRestart("muffleMessage")
[17:39:36.954]                       }
[17:39:36.954]                       else if (inherits(cond, "warning")) {
[17:39:36.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.954]                         if (muffled) 
[17:39:36.954]                           invokeRestart("muffleWarning")
[17:39:36.954]                       }
[17:39:36.954]                       else if (inherits(cond, "condition")) {
[17:39:36.954]                         if (!is.null(pattern)) {
[17:39:36.954]                           computeRestarts <- base::computeRestarts
[17:39:36.954]                           grepl <- base::grepl
[17:39:36.954]                           restarts <- computeRestarts(cond)
[17:39:36.954]                           for (restart in restarts) {
[17:39:36.954]                             name <- restart$name
[17:39:36.954]                             if (is.null(name)) 
[17:39:36.954]                               next
[17:39:36.954]                             if (!grepl(pattern, name)) 
[17:39:36.954]                               next
[17:39:36.954]                             invokeRestart(restart)
[17:39:36.954]                             muffled <- TRUE
[17:39:36.954]                             break
[17:39:36.954]                           }
[17:39:36.954]                         }
[17:39:36.954]                       }
[17:39:36.954]                       invisible(muffled)
[17:39:36.954]                     }
[17:39:36.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.954]                   }
[17:39:36.954]                 }
[17:39:36.954]                 else {
[17:39:36.954]                   if (TRUE) {
[17:39:36.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.954]                     {
[17:39:36.954]                       inherits <- base::inherits
[17:39:36.954]                       invokeRestart <- base::invokeRestart
[17:39:36.954]                       is.null <- base::is.null
[17:39:36.954]                       muffled <- FALSE
[17:39:36.954]                       if (inherits(cond, "message")) {
[17:39:36.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.954]                         if (muffled) 
[17:39:36.954]                           invokeRestart("muffleMessage")
[17:39:36.954]                       }
[17:39:36.954]                       else if (inherits(cond, "warning")) {
[17:39:36.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.954]                         if (muffled) 
[17:39:36.954]                           invokeRestart("muffleWarning")
[17:39:36.954]                       }
[17:39:36.954]                       else if (inherits(cond, "condition")) {
[17:39:36.954]                         if (!is.null(pattern)) {
[17:39:36.954]                           computeRestarts <- base::computeRestarts
[17:39:36.954]                           grepl <- base::grepl
[17:39:36.954]                           restarts <- computeRestarts(cond)
[17:39:36.954]                           for (restart in restarts) {
[17:39:36.954]                             name <- restart$name
[17:39:36.954]                             if (is.null(name)) 
[17:39:36.954]                               next
[17:39:36.954]                             if (!grepl(pattern, name)) 
[17:39:36.954]                               next
[17:39:36.954]                             invokeRestart(restart)
[17:39:36.954]                             muffled <- TRUE
[17:39:36.954]                             break
[17:39:36.954]                           }
[17:39:36.954]                         }
[17:39:36.954]                       }
[17:39:36.954]                       invisible(muffled)
[17:39:36.954]                     }
[17:39:36.954]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.954]                   }
[17:39:36.954]                 }
[17:39:36.954]             }
[17:39:36.954]         }))
[17:39:36.954]     }, error = function(ex) {
[17:39:36.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.954]                 ...future.rng), started = ...future.startTime, 
[17:39:36.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.954]             version = "1.8"), class = "FutureResult")
[17:39:36.954]     }, finally = {
[17:39:36.954]         if (!identical(...future.workdir, getwd())) 
[17:39:36.954]             setwd(...future.workdir)
[17:39:36.954]         {
[17:39:36.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.954]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.954]             }
[17:39:36.954]             base::options(...future.oldOptions)
[17:39:36.954]             if (.Platform$OS.type == "windows") {
[17:39:36.954]                 old_names <- names(...future.oldEnvVars)
[17:39:36.954]                 envs <- base::Sys.getenv()
[17:39:36.954]                 names <- names(envs)
[17:39:36.954]                 common <- intersect(names, old_names)
[17:39:36.954]                 added <- setdiff(names, old_names)
[17:39:36.954]                 removed <- setdiff(old_names, names)
[17:39:36.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.954]                   envs[common]]
[17:39:36.954]                 NAMES <- toupper(changed)
[17:39:36.954]                 args <- list()
[17:39:36.954]                 for (kk in seq_along(NAMES)) {
[17:39:36.954]                   name <- changed[[kk]]
[17:39:36.954]                   NAME <- NAMES[[kk]]
[17:39:36.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.954]                     next
[17:39:36.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.954]                 }
[17:39:36.954]                 NAMES <- toupper(added)
[17:39:36.954]                 for (kk in seq_along(NAMES)) {
[17:39:36.954]                   name <- added[[kk]]
[17:39:36.954]                   NAME <- NAMES[[kk]]
[17:39:36.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.954]                     next
[17:39:36.954]                   args[[name]] <- ""
[17:39:36.954]                 }
[17:39:36.954]                 NAMES <- toupper(removed)
[17:39:36.954]                 for (kk in seq_along(NAMES)) {
[17:39:36.954]                   name <- removed[[kk]]
[17:39:36.954]                   NAME <- NAMES[[kk]]
[17:39:36.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.954]                     next
[17:39:36.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.954]                 }
[17:39:36.954]                 if (length(args) > 0) 
[17:39:36.954]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.954]             }
[17:39:36.954]             else {
[17:39:36.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.954]             }
[17:39:36.954]             {
[17:39:36.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.954]                   0L) {
[17:39:36.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.954]                   base::options(opts)
[17:39:36.954]                 }
[17:39:36.954]                 {
[17:39:36.954]                   {
[17:39:36.954]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.954]                     NULL
[17:39:36.954]                   }
[17:39:36.954]                   options(future.plan = NULL)
[17:39:36.954]                   if (is.na(NA_character_)) 
[17:39:36.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.954]                     .init = FALSE)
[17:39:36.954]                 }
[17:39:36.954]             }
[17:39:36.954]         }
[17:39:36.954]     })
[17:39:36.954]     if (TRUE) {
[17:39:36.954]         base::sink(type = "output", split = FALSE)
[17:39:36.954]         if (TRUE) {
[17:39:36.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.954]         }
[17:39:36.954]         else {
[17:39:36.954]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.954]         }
[17:39:36.954]         base::close(...future.stdout)
[17:39:36.954]         ...future.stdout <- NULL
[17:39:36.954]     }
[17:39:36.954]     ...future.result$conditions <- ...future.conditions
[17:39:36.954]     ...future.result$finished <- base::Sys.time()
[17:39:36.954]     ...future.result
[17:39:36.954] }
[17:39:36.957] MultisessionFuture started
[17:39:36.957] - Launch lazy future ... done
[17:39:36.957] run() for ‘MultisessionFuture’ ... done
[17:39:36.957] getGlobalsAndPackages() ...
[17:39:36.957] Searching for globals...
[17:39:36.958] - globals found: [1] ‘{’
[17:39:36.958] Searching for globals ... DONE
[17:39:36.958] Resolving globals: FALSE
[17:39:36.959] 
[17:39:36.959] 
[17:39:36.959] getGlobalsAndPackages() ... DONE
[17:39:36.959] run() for ‘Future’ ...
[17:39:36.959] - state: ‘created’
[17:39:36.959] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:36.973] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:36.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:36.973]   - Field: ‘node’
[17:39:36.973]   - Field: ‘label’
[17:39:36.973]   - Field: ‘local’
[17:39:36.973]   - Field: ‘owner’
[17:39:36.973]   - Field: ‘envir’
[17:39:36.974]   - Field: ‘workers’
[17:39:36.974]   - Field: ‘packages’
[17:39:36.974]   - Field: ‘gc’
[17:39:36.974]   - Field: ‘conditions’
[17:39:36.974]   - Field: ‘persistent’
[17:39:36.974]   - Field: ‘expr’
[17:39:36.974]   - Field: ‘uuid’
[17:39:36.974]   - Field: ‘seed’
[17:39:36.974]   - Field: ‘version’
[17:39:36.974]   - Field: ‘result’
[17:39:36.974]   - Field: ‘asynchronous’
[17:39:36.975]   - Field: ‘calls’
[17:39:36.975]   - Field: ‘globals’
[17:39:36.975]   - Field: ‘stdout’
[17:39:36.975]   - Field: ‘earlySignal’
[17:39:36.975]   - Field: ‘lazy’
[17:39:36.975]   - Field: ‘state’
[17:39:36.975] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:36.975] - Launch lazy future ...
[17:39:36.975] Packages needed by the future expression (n = 0): <none>
[17:39:36.976] Packages needed by future strategies (n = 0): <none>
[17:39:36.976] {
[17:39:36.976]     {
[17:39:36.976]         {
[17:39:36.976]             ...future.startTime <- base::Sys.time()
[17:39:36.976]             {
[17:39:36.976]                 {
[17:39:36.976]                   {
[17:39:36.976]                     {
[17:39:36.976]                       base::local({
[17:39:36.976]                         has_future <- base::requireNamespace("future", 
[17:39:36.976]                           quietly = TRUE)
[17:39:36.976]                         if (has_future) {
[17:39:36.976]                           ns <- base::getNamespace("future")
[17:39:36.976]                           version <- ns[[".package"]][["version"]]
[17:39:36.976]                           if (is.null(version)) 
[17:39:36.976]                             version <- utils::packageVersion("future")
[17:39:36.976]                         }
[17:39:36.976]                         else {
[17:39:36.976]                           version <- NULL
[17:39:36.976]                         }
[17:39:36.976]                         if (!has_future || version < "1.8.0") {
[17:39:36.976]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:36.976]                             "", base::R.version$version.string), 
[17:39:36.976]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:36.976]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:36.976]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:36.976]                               "release", "version")], collapse = " "), 
[17:39:36.976]                             hostname = base::Sys.info()[["nodename"]])
[17:39:36.976]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:36.976]                             info)
[17:39:36.976]                           info <- base::paste(info, collapse = "; ")
[17:39:36.976]                           if (!has_future) {
[17:39:36.976]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:36.976]                               info)
[17:39:36.976]                           }
[17:39:36.976]                           else {
[17:39:36.976]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:36.976]                               info, version)
[17:39:36.976]                           }
[17:39:36.976]                           base::stop(msg)
[17:39:36.976]                         }
[17:39:36.976]                       })
[17:39:36.976]                     }
[17:39:36.976]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:36.976]                     base::options(mc.cores = 1L)
[17:39:36.976]                   }
[17:39:36.976]                   ...future.strategy.old <- future::plan("list")
[17:39:36.976]                   options(future.plan = NULL)
[17:39:36.976]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.976]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:36.976]                 }
[17:39:36.976]                 ...future.workdir <- getwd()
[17:39:36.976]             }
[17:39:36.976]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:36.976]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:36.976]         }
[17:39:36.976]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:36.976]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:36.976]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:36.976]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:36.976]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:36.976]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:36.976]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:36.976]             base::names(...future.oldOptions))
[17:39:36.976]     }
[17:39:36.976]     if (FALSE) {
[17:39:36.976]     }
[17:39:36.976]     else {
[17:39:36.976]         if (TRUE) {
[17:39:36.976]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:36.976]                 open = "w")
[17:39:36.976]         }
[17:39:36.976]         else {
[17:39:36.976]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:36.976]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:36.976]         }
[17:39:36.976]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:36.976]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:36.976]             base::sink(type = "output", split = FALSE)
[17:39:36.976]             base::close(...future.stdout)
[17:39:36.976]         }, add = TRUE)
[17:39:36.976]     }
[17:39:36.976]     ...future.frame <- base::sys.nframe()
[17:39:36.976]     ...future.conditions <- base::list()
[17:39:36.976]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:36.976]     if (FALSE) {
[17:39:36.976]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:36.976]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:36.976]     }
[17:39:36.976]     ...future.result <- base::tryCatch({
[17:39:36.976]         base::withCallingHandlers({
[17:39:36.976]             ...future.value <- base::withVisible(base::local({
[17:39:36.976]                 ...future.makeSendCondition <- base::local({
[17:39:36.976]                   sendCondition <- NULL
[17:39:36.976]                   function(frame = 1L) {
[17:39:36.976]                     if (is.function(sendCondition)) 
[17:39:36.976]                       return(sendCondition)
[17:39:36.976]                     ns <- getNamespace("parallel")
[17:39:36.976]                     if (exists("sendData", mode = "function", 
[17:39:36.976]                       envir = ns)) {
[17:39:36.976]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:36.976]                         envir = ns)
[17:39:36.976]                       envir <- sys.frame(frame)
[17:39:36.976]                       master <- NULL
[17:39:36.976]                       while (!identical(envir, .GlobalEnv) && 
[17:39:36.976]                         !identical(envir, emptyenv())) {
[17:39:36.976]                         if (exists("master", mode = "list", envir = envir, 
[17:39:36.976]                           inherits = FALSE)) {
[17:39:36.976]                           master <- get("master", mode = "list", 
[17:39:36.976]                             envir = envir, inherits = FALSE)
[17:39:36.976]                           if (inherits(master, c("SOCKnode", 
[17:39:36.976]                             "SOCK0node"))) {
[17:39:36.976]                             sendCondition <<- function(cond) {
[17:39:36.976]                               data <- list(type = "VALUE", value = cond, 
[17:39:36.976]                                 success = TRUE)
[17:39:36.976]                               parallel_sendData(master, data)
[17:39:36.976]                             }
[17:39:36.976]                             return(sendCondition)
[17:39:36.976]                           }
[17:39:36.976]                         }
[17:39:36.976]                         frame <- frame + 1L
[17:39:36.976]                         envir <- sys.frame(frame)
[17:39:36.976]                       }
[17:39:36.976]                     }
[17:39:36.976]                     sendCondition <<- function(cond) NULL
[17:39:36.976]                   }
[17:39:36.976]                 })
[17:39:36.976]                 withCallingHandlers({
[17:39:36.976]                   {
[17:39:36.976]                     4
[17:39:36.976]                   }
[17:39:36.976]                 }, immediateCondition = function(cond) {
[17:39:36.976]                   sendCondition <- ...future.makeSendCondition()
[17:39:36.976]                   sendCondition(cond)
[17:39:36.976]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.976]                   {
[17:39:36.976]                     inherits <- base::inherits
[17:39:36.976]                     invokeRestart <- base::invokeRestart
[17:39:36.976]                     is.null <- base::is.null
[17:39:36.976]                     muffled <- FALSE
[17:39:36.976]                     if (inherits(cond, "message")) {
[17:39:36.976]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:36.976]                       if (muffled) 
[17:39:36.976]                         invokeRestart("muffleMessage")
[17:39:36.976]                     }
[17:39:36.976]                     else if (inherits(cond, "warning")) {
[17:39:36.976]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:36.976]                       if (muffled) 
[17:39:36.976]                         invokeRestart("muffleWarning")
[17:39:36.976]                     }
[17:39:36.976]                     else if (inherits(cond, "condition")) {
[17:39:36.976]                       if (!is.null(pattern)) {
[17:39:36.976]                         computeRestarts <- base::computeRestarts
[17:39:36.976]                         grepl <- base::grepl
[17:39:36.976]                         restarts <- computeRestarts(cond)
[17:39:36.976]                         for (restart in restarts) {
[17:39:36.976]                           name <- restart$name
[17:39:36.976]                           if (is.null(name)) 
[17:39:36.976]                             next
[17:39:36.976]                           if (!grepl(pattern, name)) 
[17:39:36.976]                             next
[17:39:36.976]                           invokeRestart(restart)
[17:39:36.976]                           muffled <- TRUE
[17:39:36.976]                           break
[17:39:36.976]                         }
[17:39:36.976]                       }
[17:39:36.976]                     }
[17:39:36.976]                     invisible(muffled)
[17:39:36.976]                   }
[17:39:36.976]                   muffleCondition(cond)
[17:39:36.976]                 })
[17:39:36.976]             }))
[17:39:36.976]             future::FutureResult(value = ...future.value$value, 
[17:39:36.976]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.976]                   ...future.rng), globalenv = if (FALSE) 
[17:39:36.976]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:36.976]                     ...future.globalenv.names))
[17:39:36.976]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:36.976]         }, condition = base::local({
[17:39:36.976]             c <- base::c
[17:39:36.976]             inherits <- base::inherits
[17:39:36.976]             invokeRestart <- base::invokeRestart
[17:39:36.976]             length <- base::length
[17:39:36.976]             list <- base::list
[17:39:36.976]             seq.int <- base::seq.int
[17:39:36.976]             signalCondition <- base::signalCondition
[17:39:36.976]             sys.calls <- base::sys.calls
[17:39:36.976]             `[[` <- base::`[[`
[17:39:36.976]             `+` <- base::`+`
[17:39:36.976]             `<<-` <- base::`<<-`
[17:39:36.976]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:36.976]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:36.976]                   3L)]
[17:39:36.976]             }
[17:39:36.976]             function(cond) {
[17:39:36.976]                 is_error <- inherits(cond, "error")
[17:39:36.976]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:36.976]                   NULL)
[17:39:36.976]                 if (is_error) {
[17:39:36.976]                   sessionInformation <- function() {
[17:39:36.976]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:36.976]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:36.976]                       search = base::search(), system = base::Sys.info())
[17:39:36.976]                   }
[17:39:36.976]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.976]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:36.976]                     cond$call), session = sessionInformation(), 
[17:39:36.976]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:36.976]                   signalCondition(cond)
[17:39:36.976]                 }
[17:39:36.976]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:36.976]                 "immediateCondition"))) {
[17:39:36.976]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:36.976]                   ...future.conditions[[length(...future.conditions) + 
[17:39:36.976]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:36.976]                   if (TRUE && !signal) {
[17:39:36.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.976]                     {
[17:39:36.976]                       inherits <- base::inherits
[17:39:36.976]                       invokeRestart <- base::invokeRestart
[17:39:36.976]                       is.null <- base::is.null
[17:39:36.976]                       muffled <- FALSE
[17:39:36.976]                       if (inherits(cond, "message")) {
[17:39:36.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.976]                         if (muffled) 
[17:39:36.976]                           invokeRestart("muffleMessage")
[17:39:36.976]                       }
[17:39:36.976]                       else if (inherits(cond, "warning")) {
[17:39:36.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.976]                         if (muffled) 
[17:39:36.976]                           invokeRestart("muffleWarning")
[17:39:36.976]                       }
[17:39:36.976]                       else if (inherits(cond, "condition")) {
[17:39:36.976]                         if (!is.null(pattern)) {
[17:39:36.976]                           computeRestarts <- base::computeRestarts
[17:39:36.976]                           grepl <- base::grepl
[17:39:36.976]                           restarts <- computeRestarts(cond)
[17:39:36.976]                           for (restart in restarts) {
[17:39:36.976]                             name <- restart$name
[17:39:36.976]                             if (is.null(name)) 
[17:39:36.976]                               next
[17:39:36.976]                             if (!grepl(pattern, name)) 
[17:39:36.976]                               next
[17:39:36.976]                             invokeRestart(restart)
[17:39:36.976]                             muffled <- TRUE
[17:39:36.976]                             break
[17:39:36.976]                           }
[17:39:36.976]                         }
[17:39:36.976]                       }
[17:39:36.976]                       invisible(muffled)
[17:39:36.976]                     }
[17:39:36.976]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.976]                   }
[17:39:36.976]                 }
[17:39:36.976]                 else {
[17:39:36.976]                   if (TRUE) {
[17:39:36.976]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:36.976]                     {
[17:39:36.976]                       inherits <- base::inherits
[17:39:36.976]                       invokeRestart <- base::invokeRestart
[17:39:36.976]                       is.null <- base::is.null
[17:39:36.976]                       muffled <- FALSE
[17:39:36.976]                       if (inherits(cond, "message")) {
[17:39:36.976]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:36.976]                         if (muffled) 
[17:39:36.976]                           invokeRestart("muffleMessage")
[17:39:36.976]                       }
[17:39:36.976]                       else if (inherits(cond, "warning")) {
[17:39:36.976]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:36.976]                         if (muffled) 
[17:39:36.976]                           invokeRestart("muffleWarning")
[17:39:36.976]                       }
[17:39:36.976]                       else if (inherits(cond, "condition")) {
[17:39:36.976]                         if (!is.null(pattern)) {
[17:39:36.976]                           computeRestarts <- base::computeRestarts
[17:39:36.976]                           grepl <- base::grepl
[17:39:36.976]                           restarts <- computeRestarts(cond)
[17:39:36.976]                           for (restart in restarts) {
[17:39:36.976]                             name <- restart$name
[17:39:36.976]                             if (is.null(name)) 
[17:39:36.976]                               next
[17:39:36.976]                             if (!grepl(pattern, name)) 
[17:39:36.976]                               next
[17:39:36.976]                             invokeRestart(restart)
[17:39:36.976]                             muffled <- TRUE
[17:39:36.976]                             break
[17:39:36.976]                           }
[17:39:36.976]                         }
[17:39:36.976]                       }
[17:39:36.976]                       invisible(muffled)
[17:39:36.976]                     }
[17:39:36.976]                     muffleCondition(cond, pattern = "^muffle")
[17:39:36.976]                   }
[17:39:36.976]                 }
[17:39:36.976]             }
[17:39:36.976]         }))
[17:39:36.976]     }, error = function(ex) {
[17:39:36.976]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:36.976]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:36.976]                 ...future.rng), started = ...future.startTime, 
[17:39:36.976]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:36.976]             version = "1.8"), class = "FutureResult")
[17:39:36.976]     }, finally = {
[17:39:36.976]         if (!identical(...future.workdir, getwd())) 
[17:39:36.976]             setwd(...future.workdir)
[17:39:36.976]         {
[17:39:36.976]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:36.976]                 ...future.oldOptions$nwarnings <- NULL
[17:39:36.976]             }
[17:39:36.976]             base::options(...future.oldOptions)
[17:39:36.976]             if (.Platform$OS.type == "windows") {
[17:39:36.976]                 old_names <- names(...future.oldEnvVars)
[17:39:36.976]                 envs <- base::Sys.getenv()
[17:39:36.976]                 names <- names(envs)
[17:39:36.976]                 common <- intersect(names, old_names)
[17:39:36.976]                 added <- setdiff(names, old_names)
[17:39:36.976]                 removed <- setdiff(old_names, names)
[17:39:36.976]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:36.976]                   envs[common]]
[17:39:36.976]                 NAMES <- toupper(changed)
[17:39:36.976]                 args <- list()
[17:39:36.976]                 for (kk in seq_along(NAMES)) {
[17:39:36.976]                   name <- changed[[kk]]
[17:39:36.976]                   NAME <- NAMES[[kk]]
[17:39:36.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.976]                     next
[17:39:36.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.976]                 }
[17:39:36.976]                 NAMES <- toupper(added)
[17:39:36.976]                 for (kk in seq_along(NAMES)) {
[17:39:36.976]                   name <- added[[kk]]
[17:39:36.976]                   NAME <- NAMES[[kk]]
[17:39:36.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.976]                     next
[17:39:36.976]                   args[[name]] <- ""
[17:39:36.976]                 }
[17:39:36.976]                 NAMES <- toupper(removed)
[17:39:36.976]                 for (kk in seq_along(NAMES)) {
[17:39:36.976]                   name <- removed[[kk]]
[17:39:36.976]                   NAME <- NAMES[[kk]]
[17:39:36.976]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:36.976]                     next
[17:39:36.976]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:36.976]                 }
[17:39:36.976]                 if (length(args) > 0) 
[17:39:36.976]                   base::do.call(base::Sys.setenv, args = args)
[17:39:36.976]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:36.976]             }
[17:39:36.976]             else {
[17:39:36.976]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:36.976]             }
[17:39:36.976]             {
[17:39:36.976]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:36.976]                   0L) {
[17:39:36.976]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:36.976]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:36.976]                   base::options(opts)
[17:39:36.976]                 }
[17:39:36.976]                 {
[17:39:36.976]                   {
[17:39:36.976]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:36.976]                     NULL
[17:39:36.976]                   }
[17:39:36.976]                   options(future.plan = NULL)
[17:39:36.976]                   if (is.na(NA_character_)) 
[17:39:36.976]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:36.976]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:36.976]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:36.976]                     .init = FALSE)
[17:39:36.976]                 }
[17:39:36.976]             }
[17:39:36.976]         }
[17:39:36.976]     })
[17:39:36.976]     if (TRUE) {
[17:39:36.976]         base::sink(type = "output", split = FALSE)
[17:39:36.976]         if (TRUE) {
[17:39:36.976]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:36.976]         }
[17:39:36.976]         else {
[17:39:36.976]             ...future.result["stdout"] <- base::list(NULL)
[17:39:36.976]         }
[17:39:36.976]         base::close(...future.stdout)
[17:39:36.976]         ...future.stdout <- NULL
[17:39:36.976]     }
[17:39:36.976]     ...future.result$conditions <- ...future.conditions
[17:39:36.976]     ...future.result$finished <- base::Sys.time()
[17:39:36.976]     ...future.result
[17:39:36.976] }
[17:39:36.978] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:36.989] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.989] - Validating connection of MultisessionFuture
[17:39:36.989] - received message: FutureResult
[17:39:36.989] - Received FutureResult
[17:39:36.989] - Erased future from FutureRegistry
[17:39:36.989] result() for ClusterFuture ...
[17:39:36.990] - result already collected: FutureResult
[17:39:36.990] result() for ClusterFuture ... done
[17:39:36.990] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.990] result() for ClusterFuture ...
[17:39:36.990] - result already collected: FutureResult
[17:39:36.990] result() for ClusterFuture ... done
[17:39:36.990] result() for ClusterFuture ...
[17:39:36.990] - result already collected: FutureResult
[17:39:36.990] result() for ClusterFuture ... done
[17:39:36.991] MultisessionFuture started
[17:39:36.991] - Launch lazy future ... done
[17:39:36.991] run() for ‘MultisessionFuture’ ... done
<environment: 0x55adf0251c48> 
<environment: 0x55adf141e260> 
[17:39:36.993] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.993] - Validating connection of MultisessionFuture
[17:39:36.993] - received message: FutureResult
[17:39:36.994] - Received FutureResult
[17:39:36.994] - Erased future from FutureRegistry
[17:39:36.994] result() for ClusterFuture ...
[17:39:36.994] - result already collected: FutureResult
[17:39:36.994] result() for ClusterFuture ... done
[17:39:36.994] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:36.994] receiveMessageFromWorker() for ClusterFuture ...
[17:39:36.995] - Validating connection of MultisessionFuture
[17:39:36.995] - received message: FutureResult
[17:39:36.995] - Received FutureResult
[17:39:36.995] - Erased future from FutureRegistry
[17:39:36.995] result() for ClusterFuture ...
[17:39:36.995] - result already collected: FutureResult
[17:39:36.995] result() for ClusterFuture ... done
[17:39:36.995] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:36.996] resolve() on environment ...
[17:39:36.996]  recursive: 0
[17:39:36.997]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:36.997] signalConditionsASAP(numeric, pos=1) ...
[17:39:36.997] - nx: 4
[17:39:36.997] - relay: TRUE
[17:39:36.997] - stdout: TRUE
[17:39:36.997] - signal: TRUE
[17:39:36.997] - resignal: FALSE
[17:39:36.998] - force: TRUE
[17:39:36.998] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.998] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.998]  - until=2
[17:39:36.998]  - relaying element #2
[17:39:36.998] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:36.998] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:36.998] signalConditionsASAP(NULL, pos=1) ... done
[17:39:36.998]  length: 3 (resolved future 1)
[17:39:36.998] Future #2
[17:39:36.999] result() for ClusterFuture ...
[17:39:36.999] - result already collected: FutureResult
[17:39:36.999] result() for ClusterFuture ... done
[17:39:36.999] result() for ClusterFuture ...
[17:39:36.999] - result already collected: FutureResult
[17:39:36.999] result() for ClusterFuture ... done
[17:39:36.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:36.999] - nx: 4
[17:39:36.999] - relay: TRUE
[17:39:36.999] - stdout: TRUE
[17:39:36.999] - signal: TRUE
[17:39:36.999] - resignal: FALSE
[17:39:37.000] - force: TRUE
[17:39:37.000] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:37.000] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:37.000]  - until=2
[17:39:37.000]  - relaying element #2
[17:39:37.000] result() for ClusterFuture ...
[17:39:37.000] - result already collected: FutureResult
[17:39:37.000] result() for ClusterFuture ... done
[17:39:37.000] result() for ClusterFuture ...
[17:39:37.000] - result already collected: FutureResult
[17:39:37.000] result() for ClusterFuture ... done
[17:39:37.001] result() for ClusterFuture ...
[17:39:37.001] - result already collected: FutureResult
[17:39:37.001] result() for ClusterFuture ... done
[17:39:37.001] result() for ClusterFuture ...
[17:39:37.001] - result already collected: FutureResult
[17:39:37.001] result() for ClusterFuture ... done
[17:39:37.001] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:37.001] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:37.001] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:37.001]  length: 2 (resolved future 2)
[17:39:37.001] Future #3
[17:39:37.002] result() for ClusterFuture ...
[17:39:37.002] - result already collected: FutureResult
[17:39:37.002] result() for ClusterFuture ... done
[17:39:37.002] result() for ClusterFuture ...
[17:39:37.002] - result already collected: FutureResult
[17:39:37.002] result() for ClusterFuture ... done
[17:39:37.002] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:37.002] - nx: 4
[17:39:37.002] - relay: TRUE
[17:39:37.002] - stdout: TRUE
[17:39:37.002] - signal: TRUE
[17:39:37.002] - resignal: FALSE
[17:39:37.003] - force: TRUE
[17:39:37.003] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:37.003] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:37.003]  - until=3
[17:39:37.003]  - relaying element #3
[17:39:37.003] result() for ClusterFuture ...
[17:39:37.003] - result already collected: FutureResult
[17:39:37.003] result() for ClusterFuture ... done
[17:39:37.003] result() for ClusterFuture ...
[17:39:37.003] - result already collected: FutureResult
[17:39:37.003] result() for ClusterFuture ... done
[17:39:37.004] result() for ClusterFuture ...
[17:39:37.004] - result already collected: FutureResult
[17:39:37.004] result() for ClusterFuture ... done
[17:39:37.004] result() for ClusterFuture ...
[17:39:37.004] - result already collected: FutureResult
[17:39:37.004] result() for ClusterFuture ... done
[17:39:37.004] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:37.004] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:37.004] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:37.004]  length: 1 (resolved future 3)
[17:39:37.004] Future #4
[17:39:37.005] result() for ClusterFuture ...
[17:39:37.005] - result already collected: FutureResult
[17:39:37.005] result() for ClusterFuture ... done
[17:39:37.005] result() for ClusterFuture ...
[17:39:37.005] - result already collected: FutureResult
[17:39:37.005] result() for ClusterFuture ... done
[17:39:37.005] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:37.005] - nx: 4
[17:39:37.005] - relay: TRUE
[17:39:37.005] - stdout: TRUE
[17:39:37.005] - signal: TRUE
[17:39:37.005] - resignal: FALSE
[17:39:37.006] - force: TRUE
[17:39:37.006] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:37.006] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:37.006]  - until=4
[17:39:37.006]  - relaying element #4
[17:39:37.006] result() for ClusterFuture ...
[17:39:37.006] - result already collected: FutureResult
[17:39:37.006] result() for ClusterFuture ... done
[17:39:37.006] result() for ClusterFuture ...
[17:39:37.006] - result already collected: FutureResult
[17:39:37.006] result() for ClusterFuture ... done
[17:39:37.006] result() for ClusterFuture ...
[17:39:37.007] - result already collected: FutureResult
[17:39:37.007] result() for ClusterFuture ... done
[17:39:37.007] result() for ClusterFuture ...
[17:39:37.007] - result already collected: FutureResult
[17:39:37.007] result() for ClusterFuture ... done
[17:39:37.007] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.007] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:37.007] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:37.007]  length: 0 (resolved future 4)
[17:39:37.007] Relaying remaining futures
[17:39:37.007] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.007] - nx: 4
[17:39:37.008] - relay: TRUE
[17:39:37.008] - stdout: TRUE
[17:39:37.008] - signal: TRUE
[17:39:37.008] - resignal: FALSE
[17:39:37.008] - force: TRUE
[17:39:37.008] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.008] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:37.008] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.008] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:37.008] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.008] resolve() on environment ... DONE
[17:39:37.009] result() for ClusterFuture ...
[17:39:37.009] - result already collected: FutureResult
[17:39:37.009] result() for ClusterFuture ... done
[17:39:37.009] result() for ClusterFuture ...
[17:39:37.009] - result already collected: FutureResult
[17:39:37.009] result() for ClusterFuture ... done
[17:39:37.009] result() for ClusterFuture ...
[17:39:37.009] - result already collected: FutureResult
[17:39:37.009] result() for ClusterFuture ... done
[17:39:37.009] result() for ClusterFuture ...
[17:39:37.009] - result already collected: FutureResult
[17:39:37.009] result() for ClusterFuture ... done
[17:39:37.010] result() for ClusterFuture ...
[17:39:37.010] - result already collected: FutureResult
[17:39:37.010] result() for ClusterFuture ... done
[17:39:37.010] result() for ClusterFuture ...
[17:39:37.010] - result already collected: FutureResult
[17:39:37.010] result() for ClusterFuture ... done
<environment: 0x55adf163efb0> 
Dimensions: c(2, 1, 3, 1)
[17:39:37.010] getGlobalsAndPackages() ...
[17:39:37.010] Searching for globals...
[17:39:37.011] 
[17:39:37.011] Searching for globals ... DONE
[17:39:37.011] - globals: [0] <none>
[17:39:37.011] getGlobalsAndPackages() ... DONE
[17:39:37.011] run() for ‘Future’ ...
[17:39:37.011] - state: ‘created’
[17:39:37.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.026] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:37.026]   - Field: ‘node’
[17:39:37.026]   - Field: ‘label’
[17:39:37.026]   - Field: ‘local’
[17:39:37.027]   - Field: ‘owner’
[17:39:37.027]   - Field: ‘envir’
[17:39:37.027]   - Field: ‘workers’
[17:39:37.027]   - Field: ‘packages’
[17:39:37.027]   - Field: ‘gc’
[17:39:37.027]   - Field: ‘conditions’
[17:39:37.027]   - Field: ‘persistent’
[17:39:37.027]   - Field: ‘expr’
[17:39:37.027]   - Field: ‘uuid’
[17:39:37.027]   - Field: ‘seed’
[17:39:37.027]   - Field: ‘version’
[17:39:37.028]   - Field: ‘result’
[17:39:37.028]   - Field: ‘asynchronous’
[17:39:37.028]   - Field: ‘calls’
[17:39:37.028]   - Field: ‘globals’
[17:39:37.028]   - Field: ‘stdout’
[17:39:37.028]   - Field: ‘earlySignal’
[17:39:37.028]   - Field: ‘lazy’
[17:39:37.028]   - Field: ‘state’
[17:39:37.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:37.028] - Launch lazy future ...
[17:39:37.029] Packages needed by the future expression (n = 0): <none>
[17:39:37.029] Packages needed by future strategies (n = 0): <none>
[17:39:37.029] {
[17:39:37.029]     {
[17:39:37.029]         {
[17:39:37.029]             ...future.startTime <- base::Sys.time()
[17:39:37.029]             {
[17:39:37.029]                 {
[17:39:37.029]                   {
[17:39:37.029]                     {
[17:39:37.029]                       base::local({
[17:39:37.029]                         has_future <- base::requireNamespace("future", 
[17:39:37.029]                           quietly = TRUE)
[17:39:37.029]                         if (has_future) {
[17:39:37.029]                           ns <- base::getNamespace("future")
[17:39:37.029]                           version <- ns[[".package"]][["version"]]
[17:39:37.029]                           if (is.null(version)) 
[17:39:37.029]                             version <- utils::packageVersion("future")
[17:39:37.029]                         }
[17:39:37.029]                         else {
[17:39:37.029]                           version <- NULL
[17:39:37.029]                         }
[17:39:37.029]                         if (!has_future || version < "1.8.0") {
[17:39:37.029]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.029]                             "", base::R.version$version.string), 
[17:39:37.029]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.029]                               "release", "version")], collapse = " "), 
[17:39:37.029]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.029]                             info)
[17:39:37.029]                           info <- base::paste(info, collapse = "; ")
[17:39:37.029]                           if (!has_future) {
[17:39:37.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.029]                               info)
[17:39:37.029]                           }
[17:39:37.029]                           else {
[17:39:37.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.029]                               info, version)
[17:39:37.029]                           }
[17:39:37.029]                           base::stop(msg)
[17:39:37.029]                         }
[17:39:37.029]                       })
[17:39:37.029]                     }
[17:39:37.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.029]                     base::options(mc.cores = 1L)
[17:39:37.029]                   }
[17:39:37.029]                   ...future.strategy.old <- future::plan("list")
[17:39:37.029]                   options(future.plan = NULL)
[17:39:37.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.029]                 }
[17:39:37.029]                 ...future.workdir <- getwd()
[17:39:37.029]             }
[17:39:37.029]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.029]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.029]         }
[17:39:37.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.029]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.029]             base::names(...future.oldOptions))
[17:39:37.029]     }
[17:39:37.029]     if (FALSE) {
[17:39:37.029]     }
[17:39:37.029]     else {
[17:39:37.029]         if (TRUE) {
[17:39:37.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.029]                 open = "w")
[17:39:37.029]         }
[17:39:37.029]         else {
[17:39:37.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.029]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.029]         }
[17:39:37.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.029]             base::sink(type = "output", split = FALSE)
[17:39:37.029]             base::close(...future.stdout)
[17:39:37.029]         }, add = TRUE)
[17:39:37.029]     }
[17:39:37.029]     ...future.frame <- base::sys.nframe()
[17:39:37.029]     ...future.conditions <- base::list()
[17:39:37.029]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.029]     if (FALSE) {
[17:39:37.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.029]     }
[17:39:37.029]     ...future.result <- base::tryCatch({
[17:39:37.029]         base::withCallingHandlers({
[17:39:37.029]             ...future.value <- base::withVisible(base::local({
[17:39:37.029]                 ...future.makeSendCondition <- base::local({
[17:39:37.029]                   sendCondition <- NULL
[17:39:37.029]                   function(frame = 1L) {
[17:39:37.029]                     if (is.function(sendCondition)) 
[17:39:37.029]                       return(sendCondition)
[17:39:37.029]                     ns <- getNamespace("parallel")
[17:39:37.029]                     if (exists("sendData", mode = "function", 
[17:39:37.029]                       envir = ns)) {
[17:39:37.029]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:37.029]                         envir = ns)
[17:39:37.029]                       envir <- sys.frame(frame)
[17:39:37.029]                       master <- NULL
[17:39:37.029]                       while (!identical(envir, .GlobalEnv) && 
[17:39:37.029]                         !identical(envir, emptyenv())) {
[17:39:37.029]                         if (exists("master", mode = "list", envir = envir, 
[17:39:37.029]                           inherits = FALSE)) {
[17:39:37.029]                           master <- get("master", mode = "list", 
[17:39:37.029]                             envir = envir, inherits = FALSE)
[17:39:37.029]                           if (inherits(master, c("SOCKnode", 
[17:39:37.029]                             "SOCK0node"))) {
[17:39:37.029]                             sendCondition <<- function(cond) {
[17:39:37.029]                               data <- list(type = "VALUE", value = cond, 
[17:39:37.029]                                 success = TRUE)
[17:39:37.029]                               parallel_sendData(master, data)
[17:39:37.029]                             }
[17:39:37.029]                             return(sendCondition)
[17:39:37.029]                           }
[17:39:37.029]                         }
[17:39:37.029]                         frame <- frame + 1L
[17:39:37.029]                         envir <- sys.frame(frame)
[17:39:37.029]                       }
[17:39:37.029]                     }
[17:39:37.029]                     sendCondition <<- function(cond) NULL
[17:39:37.029]                   }
[17:39:37.029]                 })
[17:39:37.029]                 withCallingHandlers({
[17:39:37.029]                   2
[17:39:37.029]                 }, immediateCondition = function(cond) {
[17:39:37.029]                   sendCondition <- ...future.makeSendCondition()
[17:39:37.029]                   sendCondition(cond)
[17:39:37.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.029]                   {
[17:39:37.029]                     inherits <- base::inherits
[17:39:37.029]                     invokeRestart <- base::invokeRestart
[17:39:37.029]                     is.null <- base::is.null
[17:39:37.029]                     muffled <- FALSE
[17:39:37.029]                     if (inherits(cond, "message")) {
[17:39:37.029]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.029]                       if (muffled) 
[17:39:37.029]                         invokeRestart("muffleMessage")
[17:39:37.029]                     }
[17:39:37.029]                     else if (inherits(cond, "warning")) {
[17:39:37.029]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.029]                       if (muffled) 
[17:39:37.029]                         invokeRestart("muffleWarning")
[17:39:37.029]                     }
[17:39:37.029]                     else if (inherits(cond, "condition")) {
[17:39:37.029]                       if (!is.null(pattern)) {
[17:39:37.029]                         computeRestarts <- base::computeRestarts
[17:39:37.029]                         grepl <- base::grepl
[17:39:37.029]                         restarts <- computeRestarts(cond)
[17:39:37.029]                         for (restart in restarts) {
[17:39:37.029]                           name <- restart$name
[17:39:37.029]                           if (is.null(name)) 
[17:39:37.029]                             next
[17:39:37.029]                           if (!grepl(pattern, name)) 
[17:39:37.029]                             next
[17:39:37.029]                           invokeRestart(restart)
[17:39:37.029]                           muffled <- TRUE
[17:39:37.029]                           break
[17:39:37.029]                         }
[17:39:37.029]                       }
[17:39:37.029]                     }
[17:39:37.029]                     invisible(muffled)
[17:39:37.029]                   }
[17:39:37.029]                   muffleCondition(cond)
[17:39:37.029]                 })
[17:39:37.029]             }))
[17:39:37.029]             future::FutureResult(value = ...future.value$value, 
[17:39:37.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.029]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.029]                     ...future.globalenv.names))
[17:39:37.029]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.029]         }, condition = base::local({
[17:39:37.029]             c <- base::c
[17:39:37.029]             inherits <- base::inherits
[17:39:37.029]             invokeRestart <- base::invokeRestart
[17:39:37.029]             length <- base::length
[17:39:37.029]             list <- base::list
[17:39:37.029]             seq.int <- base::seq.int
[17:39:37.029]             signalCondition <- base::signalCondition
[17:39:37.029]             sys.calls <- base::sys.calls
[17:39:37.029]             `[[` <- base::`[[`
[17:39:37.029]             `+` <- base::`+`
[17:39:37.029]             `<<-` <- base::`<<-`
[17:39:37.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.029]                   3L)]
[17:39:37.029]             }
[17:39:37.029]             function(cond) {
[17:39:37.029]                 is_error <- inherits(cond, "error")
[17:39:37.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.029]                   NULL)
[17:39:37.029]                 if (is_error) {
[17:39:37.029]                   sessionInformation <- function() {
[17:39:37.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.029]                       search = base::search(), system = base::Sys.info())
[17:39:37.029]                   }
[17:39:37.029]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.029]                     cond$call), session = sessionInformation(), 
[17:39:37.029]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.029]                   signalCondition(cond)
[17:39:37.029]                 }
[17:39:37.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.029]                 "immediateCondition"))) {
[17:39:37.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.029]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.029]                   if (TRUE && !signal) {
[17:39:37.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.029]                     {
[17:39:37.029]                       inherits <- base::inherits
[17:39:37.029]                       invokeRestart <- base::invokeRestart
[17:39:37.029]                       is.null <- base::is.null
[17:39:37.029]                       muffled <- FALSE
[17:39:37.029]                       if (inherits(cond, "message")) {
[17:39:37.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.029]                         if (muffled) 
[17:39:37.029]                           invokeRestart("muffleMessage")
[17:39:37.029]                       }
[17:39:37.029]                       else if (inherits(cond, "warning")) {
[17:39:37.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.029]                         if (muffled) 
[17:39:37.029]                           invokeRestart("muffleWarning")
[17:39:37.029]                       }
[17:39:37.029]                       else if (inherits(cond, "condition")) {
[17:39:37.029]                         if (!is.null(pattern)) {
[17:39:37.029]                           computeRestarts <- base::computeRestarts
[17:39:37.029]                           grepl <- base::grepl
[17:39:37.029]                           restarts <- computeRestarts(cond)
[17:39:37.029]                           for (restart in restarts) {
[17:39:37.029]                             name <- restart$name
[17:39:37.029]                             if (is.null(name)) 
[17:39:37.029]                               next
[17:39:37.029]                             if (!grepl(pattern, name)) 
[17:39:37.029]                               next
[17:39:37.029]                             invokeRestart(restart)
[17:39:37.029]                             muffled <- TRUE
[17:39:37.029]                             break
[17:39:37.029]                           }
[17:39:37.029]                         }
[17:39:37.029]                       }
[17:39:37.029]                       invisible(muffled)
[17:39:37.029]                     }
[17:39:37.029]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.029]                   }
[17:39:37.029]                 }
[17:39:37.029]                 else {
[17:39:37.029]                   if (TRUE) {
[17:39:37.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.029]                     {
[17:39:37.029]                       inherits <- base::inherits
[17:39:37.029]                       invokeRestart <- base::invokeRestart
[17:39:37.029]                       is.null <- base::is.null
[17:39:37.029]                       muffled <- FALSE
[17:39:37.029]                       if (inherits(cond, "message")) {
[17:39:37.029]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.029]                         if (muffled) 
[17:39:37.029]                           invokeRestart("muffleMessage")
[17:39:37.029]                       }
[17:39:37.029]                       else if (inherits(cond, "warning")) {
[17:39:37.029]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.029]                         if (muffled) 
[17:39:37.029]                           invokeRestart("muffleWarning")
[17:39:37.029]                       }
[17:39:37.029]                       else if (inherits(cond, "condition")) {
[17:39:37.029]                         if (!is.null(pattern)) {
[17:39:37.029]                           computeRestarts <- base::computeRestarts
[17:39:37.029]                           grepl <- base::grepl
[17:39:37.029]                           restarts <- computeRestarts(cond)
[17:39:37.029]                           for (restart in restarts) {
[17:39:37.029]                             name <- restart$name
[17:39:37.029]                             if (is.null(name)) 
[17:39:37.029]                               next
[17:39:37.029]                             if (!grepl(pattern, name)) 
[17:39:37.029]                               next
[17:39:37.029]                             invokeRestart(restart)
[17:39:37.029]                             muffled <- TRUE
[17:39:37.029]                             break
[17:39:37.029]                           }
[17:39:37.029]                         }
[17:39:37.029]                       }
[17:39:37.029]                       invisible(muffled)
[17:39:37.029]                     }
[17:39:37.029]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.029]                   }
[17:39:37.029]                 }
[17:39:37.029]             }
[17:39:37.029]         }))
[17:39:37.029]     }, error = function(ex) {
[17:39:37.029]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.029]                 ...future.rng), started = ...future.startTime, 
[17:39:37.029]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.029]             version = "1.8"), class = "FutureResult")
[17:39:37.029]     }, finally = {
[17:39:37.029]         if (!identical(...future.workdir, getwd())) 
[17:39:37.029]             setwd(...future.workdir)
[17:39:37.029]         {
[17:39:37.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.029]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.029]             }
[17:39:37.029]             base::options(...future.oldOptions)
[17:39:37.029]             if (.Platform$OS.type == "windows") {
[17:39:37.029]                 old_names <- names(...future.oldEnvVars)
[17:39:37.029]                 envs <- base::Sys.getenv()
[17:39:37.029]                 names <- names(envs)
[17:39:37.029]                 common <- intersect(names, old_names)
[17:39:37.029]                 added <- setdiff(names, old_names)
[17:39:37.029]                 removed <- setdiff(old_names, names)
[17:39:37.029]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.029]                   envs[common]]
[17:39:37.029]                 NAMES <- toupper(changed)
[17:39:37.029]                 args <- list()
[17:39:37.029]                 for (kk in seq_along(NAMES)) {
[17:39:37.029]                   name <- changed[[kk]]
[17:39:37.029]                   NAME <- NAMES[[kk]]
[17:39:37.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.029]                     next
[17:39:37.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.029]                 }
[17:39:37.029]                 NAMES <- toupper(added)
[17:39:37.029]                 for (kk in seq_along(NAMES)) {
[17:39:37.029]                   name <- added[[kk]]
[17:39:37.029]                   NAME <- NAMES[[kk]]
[17:39:37.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.029]                     next
[17:39:37.029]                   args[[name]] <- ""
[17:39:37.029]                 }
[17:39:37.029]                 NAMES <- toupper(removed)
[17:39:37.029]                 for (kk in seq_along(NAMES)) {
[17:39:37.029]                   name <- removed[[kk]]
[17:39:37.029]                   NAME <- NAMES[[kk]]
[17:39:37.029]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.029]                     next
[17:39:37.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.029]                 }
[17:39:37.029]                 if (length(args) > 0) 
[17:39:37.029]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.029]             }
[17:39:37.029]             else {
[17:39:37.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.029]             }
[17:39:37.029]             {
[17:39:37.029]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.029]                   0L) {
[17:39:37.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.029]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.029]                   base::options(opts)
[17:39:37.029]                 }
[17:39:37.029]                 {
[17:39:37.029]                   {
[17:39:37.029]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.029]                     NULL
[17:39:37.029]                   }
[17:39:37.029]                   options(future.plan = NULL)
[17:39:37.029]                   if (is.na(NA_character_)) 
[17:39:37.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.029]                     .init = FALSE)
[17:39:37.029]                 }
[17:39:37.029]             }
[17:39:37.029]         }
[17:39:37.029]     })
[17:39:37.029]     if (TRUE) {
[17:39:37.029]         base::sink(type = "output", split = FALSE)
[17:39:37.029]         if (TRUE) {
[17:39:37.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.029]         }
[17:39:37.029]         else {
[17:39:37.029]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.029]         }
[17:39:37.029]         base::close(...future.stdout)
[17:39:37.029]         ...future.stdout <- NULL
[17:39:37.029]     }
[17:39:37.029]     ...future.result$conditions <- ...future.conditions
[17:39:37.029]     ...future.result$finished <- base::Sys.time()
[17:39:37.029]     ...future.result
[17:39:37.029] }
[17:39:37.032] MultisessionFuture started
[17:39:37.032] - Launch lazy future ... done
[17:39:37.032] run() for ‘MultisessionFuture’ ... done
[17:39:37.033] getGlobalsAndPackages() ...
[17:39:37.033] Searching for globals...
[17:39:37.033] 
[17:39:37.033] Searching for globals ... DONE
[17:39:37.034] - globals: [0] <none>
[17:39:37.034] getGlobalsAndPackages() ... DONE
[17:39:37.034] run() for ‘Future’ ...
[17:39:37.034] - state: ‘created’
[17:39:37.034] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:37.055]   - Field: ‘node’
[17:39:37.055]   - Field: ‘label’
[17:39:37.055]   - Field: ‘local’
[17:39:37.055]   - Field: ‘owner’
[17:39:37.055]   - Field: ‘envir’
[17:39:37.055]   - Field: ‘workers’
[17:39:37.056]   - Field: ‘packages’
[17:39:37.056]   - Field: ‘gc’
[17:39:37.056]   - Field: ‘conditions’
[17:39:37.056]   - Field: ‘persistent’
[17:39:37.056]   - Field: ‘expr’
[17:39:37.056]   - Field: ‘uuid’
[17:39:37.056]   - Field: ‘seed’
[17:39:37.056]   - Field: ‘version’
[17:39:37.056]   - Field: ‘result’
[17:39:37.056]   - Field: ‘asynchronous’
[17:39:37.056]   - Field: ‘calls’
[17:39:37.057]   - Field: ‘globals’
[17:39:37.057]   - Field: ‘stdout’
[17:39:37.057]   - Field: ‘earlySignal’
[17:39:37.057]   - Field: ‘lazy’
[17:39:37.057]   - Field: ‘state’
[17:39:37.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:37.057] - Launch lazy future ...
[17:39:37.057] Packages needed by the future expression (n = 0): <none>
[17:39:37.058] Packages needed by future strategies (n = 0): <none>
[17:39:37.058] {
[17:39:37.058]     {
[17:39:37.058]         {
[17:39:37.058]             ...future.startTime <- base::Sys.time()
[17:39:37.058]             {
[17:39:37.058]                 {
[17:39:37.058]                   {
[17:39:37.058]                     {
[17:39:37.058]                       base::local({
[17:39:37.058]                         has_future <- base::requireNamespace("future", 
[17:39:37.058]                           quietly = TRUE)
[17:39:37.058]                         if (has_future) {
[17:39:37.058]                           ns <- base::getNamespace("future")
[17:39:37.058]                           version <- ns[[".package"]][["version"]]
[17:39:37.058]                           if (is.null(version)) 
[17:39:37.058]                             version <- utils::packageVersion("future")
[17:39:37.058]                         }
[17:39:37.058]                         else {
[17:39:37.058]                           version <- NULL
[17:39:37.058]                         }
[17:39:37.058]                         if (!has_future || version < "1.8.0") {
[17:39:37.058]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.058]                             "", base::R.version$version.string), 
[17:39:37.058]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.058]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.058]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.058]                               "release", "version")], collapse = " "), 
[17:39:37.058]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.058]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.058]                             info)
[17:39:37.058]                           info <- base::paste(info, collapse = "; ")
[17:39:37.058]                           if (!has_future) {
[17:39:37.058]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.058]                               info)
[17:39:37.058]                           }
[17:39:37.058]                           else {
[17:39:37.058]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.058]                               info, version)
[17:39:37.058]                           }
[17:39:37.058]                           base::stop(msg)
[17:39:37.058]                         }
[17:39:37.058]                       })
[17:39:37.058]                     }
[17:39:37.058]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.058]                     base::options(mc.cores = 1L)
[17:39:37.058]                   }
[17:39:37.058]                   ...future.strategy.old <- future::plan("list")
[17:39:37.058]                   options(future.plan = NULL)
[17:39:37.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.058]                 }
[17:39:37.058]                 ...future.workdir <- getwd()
[17:39:37.058]             }
[17:39:37.058]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.058]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.058]         }
[17:39:37.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.058]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.058]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.058]             base::names(...future.oldOptions))
[17:39:37.058]     }
[17:39:37.058]     if (FALSE) {
[17:39:37.058]     }
[17:39:37.058]     else {
[17:39:37.058]         if (TRUE) {
[17:39:37.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.058]                 open = "w")
[17:39:37.058]         }
[17:39:37.058]         else {
[17:39:37.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.058]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.058]         }
[17:39:37.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.058]             base::sink(type = "output", split = FALSE)
[17:39:37.058]             base::close(...future.stdout)
[17:39:37.058]         }, add = TRUE)
[17:39:37.058]     }
[17:39:37.058]     ...future.frame <- base::sys.nframe()
[17:39:37.058]     ...future.conditions <- base::list()
[17:39:37.058]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.058]     if (FALSE) {
[17:39:37.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.058]     }
[17:39:37.058]     ...future.result <- base::tryCatch({
[17:39:37.058]         base::withCallingHandlers({
[17:39:37.058]             ...future.value <- base::withVisible(base::local({
[17:39:37.058]                 ...future.makeSendCondition <- base::local({
[17:39:37.058]                   sendCondition <- NULL
[17:39:37.058]                   function(frame = 1L) {
[17:39:37.058]                     if (is.function(sendCondition)) 
[17:39:37.058]                       return(sendCondition)
[17:39:37.058]                     ns <- getNamespace("parallel")
[17:39:37.058]                     if (exists("sendData", mode = "function", 
[17:39:37.058]                       envir = ns)) {
[17:39:37.058]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:37.058]                         envir = ns)
[17:39:37.058]                       envir <- sys.frame(frame)
[17:39:37.058]                       master <- NULL
[17:39:37.058]                       while (!identical(envir, .GlobalEnv) && 
[17:39:37.058]                         !identical(envir, emptyenv())) {
[17:39:37.058]                         if (exists("master", mode = "list", envir = envir, 
[17:39:37.058]                           inherits = FALSE)) {
[17:39:37.058]                           master <- get("master", mode = "list", 
[17:39:37.058]                             envir = envir, inherits = FALSE)
[17:39:37.058]                           if (inherits(master, c("SOCKnode", 
[17:39:37.058]                             "SOCK0node"))) {
[17:39:37.058]                             sendCondition <<- function(cond) {
[17:39:37.058]                               data <- list(type = "VALUE", value = cond, 
[17:39:37.058]                                 success = TRUE)
[17:39:37.058]                               parallel_sendData(master, data)
[17:39:37.058]                             }
[17:39:37.058]                             return(sendCondition)
[17:39:37.058]                           }
[17:39:37.058]                         }
[17:39:37.058]                         frame <- frame + 1L
[17:39:37.058]                         envir <- sys.frame(frame)
[17:39:37.058]                       }
[17:39:37.058]                     }
[17:39:37.058]                     sendCondition <<- function(cond) NULL
[17:39:37.058]                   }
[17:39:37.058]                 })
[17:39:37.058]                 withCallingHandlers({
[17:39:37.058]                   NULL
[17:39:37.058]                 }, immediateCondition = function(cond) {
[17:39:37.058]                   sendCondition <- ...future.makeSendCondition()
[17:39:37.058]                   sendCondition(cond)
[17:39:37.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.058]                   {
[17:39:37.058]                     inherits <- base::inherits
[17:39:37.058]                     invokeRestart <- base::invokeRestart
[17:39:37.058]                     is.null <- base::is.null
[17:39:37.058]                     muffled <- FALSE
[17:39:37.058]                     if (inherits(cond, "message")) {
[17:39:37.058]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.058]                       if (muffled) 
[17:39:37.058]                         invokeRestart("muffleMessage")
[17:39:37.058]                     }
[17:39:37.058]                     else if (inherits(cond, "warning")) {
[17:39:37.058]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.058]                       if (muffled) 
[17:39:37.058]                         invokeRestart("muffleWarning")
[17:39:37.058]                     }
[17:39:37.058]                     else if (inherits(cond, "condition")) {
[17:39:37.058]                       if (!is.null(pattern)) {
[17:39:37.058]                         computeRestarts <- base::computeRestarts
[17:39:37.058]                         grepl <- base::grepl
[17:39:37.058]                         restarts <- computeRestarts(cond)
[17:39:37.058]                         for (restart in restarts) {
[17:39:37.058]                           name <- restart$name
[17:39:37.058]                           if (is.null(name)) 
[17:39:37.058]                             next
[17:39:37.058]                           if (!grepl(pattern, name)) 
[17:39:37.058]                             next
[17:39:37.058]                           invokeRestart(restart)
[17:39:37.058]                           muffled <- TRUE
[17:39:37.058]                           break
[17:39:37.058]                         }
[17:39:37.058]                       }
[17:39:37.058]                     }
[17:39:37.058]                     invisible(muffled)
[17:39:37.058]                   }
[17:39:37.058]                   muffleCondition(cond)
[17:39:37.058]                 })
[17:39:37.058]             }))
[17:39:37.058]             future::FutureResult(value = ...future.value$value, 
[17:39:37.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.058]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.058]                     ...future.globalenv.names))
[17:39:37.058]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.058]         }, condition = base::local({
[17:39:37.058]             c <- base::c
[17:39:37.058]             inherits <- base::inherits
[17:39:37.058]             invokeRestart <- base::invokeRestart
[17:39:37.058]             length <- base::length
[17:39:37.058]             list <- base::list
[17:39:37.058]             seq.int <- base::seq.int
[17:39:37.058]             signalCondition <- base::signalCondition
[17:39:37.058]             sys.calls <- base::sys.calls
[17:39:37.058]             `[[` <- base::`[[`
[17:39:37.058]             `+` <- base::`+`
[17:39:37.058]             `<<-` <- base::`<<-`
[17:39:37.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.058]                   3L)]
[17:39:37.058]             }
[17:39:37.058]             function(cond) {
[17:39:37.058]                 is_error <- inherits(cond, "error")
[17:39:37.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.058]                   NULL)
[17:39:37.058]                 if (is_error) {
[17:39:37.058]                   sessionInformation <- function() {
[17:39:37.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.058]                       search = base::search(), system = base::Sys.info())
[17:39:37.058]                   }
[17:39:37.058]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.058]                     cond$call), session = sessionInformation(), 
[17:39:37.058]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.058]                   signalCondition(cond)
[17:39:37.058]                 }
[17:39:37.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.058]                 "immediateCondition"))) {
[17:39:37.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.058]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.058]                   if (TRUE && !signal) {
[17:39:37.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.058]                     {
[17:39:37.058]                       inherits <- base::inherits
[17:39:37.058]                       invokeRestart <- base::invokeRestart
[17:39:37.058]                       is.null <- base::is.null
[17:39:37.058]                       muffled <- FALSE
[17:39:37.058]                       if (inherits(cond, "message")) {
[17:39:37.058]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.058]                         if (muffled) 
[17:39:37.058]                           invokeRestart("muffleMessage")
[17:39:37.058]                       }
[17:39:37.058]                       else if (inherits(cond, "warning")) {
[17:39:37.058]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.058]                         if (muffled) 
[17:39:37.058]                           invokeRestart("muffleWarning")
[17:39:37.058]                       }
[17:39:37.058]                       else if (inherits(cond, "condition")) {
[17:39:37.058]                         if (!is.null(pattern)) {
[17:39:37.058]                           computeRestarts <- base::computeRestarts
[17:39:37.058]                           grepl <- base::grepl
[17:39:37.058]                           restarts <- computeRestarts(cond)
[17:39:37.058]                           for (restart in restarts) {
[17:39:37.058]                             name <- restart$name
[17:39:37.058]                             if (is.null(name)) 
[17:39:37.058]                               next
[17:39:37.058]                             if (!grepl(pattern, name)) 
[17:39:37.058]                               next
[17:39:37.058]                             invokeRestart(restart)
[17:39:37.058]                             muffled <- TRUE
[17:39:37.058]                             break
[17:39:37.058]                           }
[17:39:37.058]                         }
[17:39:37.058]                       }
[17:39:37.058]                       invisible(muffled)
[17:39:37.058]                     }
[17:39:37.058]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.058]                   }
[17:39:37.058]                 }
[17:39:37.058]                 else {
[17:39:37.058]                   if (TRUE) {
[17:39:37.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.058]                     {
[17:39:37.058]                       inherits <- base::inherits
[17:39:37.058]                       invokeRestart <- base::invokeRestart
[17:39:37.058]                       is.null <- base::is.null
[17:39:37.058]                       muffled <- FALSE
[17:39:37.058]                       if (inherits(cond, "message")) {
[17:39:37.058]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.058]                         if (muffled) 
[17:39:37.058]                           invokeRestart("muffleMessage")
[17:39:37.058]                       }
[17:39:37.058]                       else if (inherits(cond, "warning")) {
[17:39:37.058]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.058]                         if (muffled) 
[17:39:37.058]                           invokeRestart("muffleWarning")
[17:39:37.058]                       }
[17:39:37.058]                       else if (inherits(cond, "condition")) {
[17:39:37.058]                         if (!is.null(pattern)) {
[17:39:37.058]                           computeRestarts <- base::computeRestarts
[17:39:37.058]                           grepl <- base::grepl
[17:39:37.058]                           restarts <- computeRestarts(cond)
[17:39:37.058]                           for (restart in restarts) {
[17:39:37.058]                             name <- restart$name
[17:39:37.058]                             if (is.null(name)) 
[17:39:37.058]                               next
[17:39:37.058]                             if (!grepl(pattern, name)) 
[17:39:37.058]                               next
[17:39:37.058]                             invokeRestart(restart)
[17:39:37.058]                             muffled <- TRUE
[17:39:37.058]                             break
[17:39:37.058]                           }
[17:39:37.058]                         }
[17:39:37.058]                       }
[17:39:37.058]                       invisible(muffled)
[17:39:37.058]                     }
[17:39:37.058]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.058]                   }
[17:39:37.058]                 }
[17:39:37.058]             }
[17:39:37.058]         }))
[17:39:37.058]     }, error = function(ex) {
[17:39:37.058]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.058]                 ...future.rng), started = ...future.startTime, 
[17:39:37.058]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.058]             version = "1.8"), class = "FutureResult")
[17:39:37.058]     }, finally = {
[17:39:37.058]         if (!identical(...future.workdir, getwd())) 
[17:39:37.058]             setwd(...future.workdir)
[17:39:37.058]         {
[17:39:37.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.058]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.058]             }
[17:39:37.058]             base::options(...future.oldOptions)
[17:39:37.058]             if (.Platform$OS.type == "windows") {
[17:39:37.058]                 old_names <- names(...future.oldEnvVars)
[17:39:37.058]                 envs <- base::Sys.getenv()
[17:39:37.058]                 names <- names(envs)
[17:39:37.058]                 common <- intersect(names, old_names)
[17:39:37.058]                 added <- setdiff(names, old_names)
[17:39:37.058]                 removed <- setdiff(old_names, names)
[17:39:37.058]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.058]                   envs[common]]
[17:39:37.058]                 NAMES <- toupper(changed)
[17:39:37.058]                 args <- list()
[17:39:37.058]                 for (kk in seq_along(NAMES)) {
[17:39:37.058]                   name <- changed[[kk]]
[17:39:37.058]                   NAME <- NAMES[[kk]]
[17:39:37.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.058]                     next
[17:39:37.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.058]                 }
[17:39:37.058]                 NAMES <- toupper(added)
[17:39:37.058]                 for (kk in seq_along(NAMES)) {
[17:39:37.058]                   name <- added[[kk]]
[17:39:37.058]                   NAME <- NAMES[[kk]]
[17:39:37.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.058]                     next
[17:39:37.058]                   args[[name]] <- ""
[17:39:37.058]                 }
[17:39:37.058]                 NAMES <- toupper(removed)
[17:39:37.058]                 for (kk in seq_along(NAMES)) {
[17:39:37.058]                   name <- removed[[kk]]
[17:39:37.058]                   NAME <- NAMES[[kk]]
[17:39:37.058]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.058]                     next
[17:39:37.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.058]                 }
[17:39:37.058]                 if (length(args) > 0) 
[17:39:37.058]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.058]             }
[17:39:37.058]             else {
[17:39:37.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.058]             }
[17:39:37.058]             {
[17:39:37.058]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.058]                   0L) {
[17:39:37.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.058]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.058]                   base::options(opts)
[17:39:37.058]                 }
[17:39:37.058]                 {
[17:39:37.058]                   {
[17:39:37.058]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.058]                     NULL
[17:39:37.058]                   }
[17:39:37.058]                   options(future.plan = NULL)
[17:39:37.058]                   if (is.na(NA_character_)) 
[17:39:37.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.058]                     .init = FALSE)
[17:39:37.058]                 }
[17:39:37.058]             }
[17:39:37.058]         }
[17:39:37.058]     })
[17:39:37.058]     if (TRUE) {
[17:39:37.058]         base::sink(type = "output", split = FALSE)
[17:39:37.058]         if (TRUE) {
[17:39:37.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.058]         }
[17:39:37.058]         else {
[17:39:37.058]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.058]         }
[17:39:37.058]         base::close(...future.stdout)
[17:39:37.058]         ...future.stdout <- NULL
[17:39:37.058]     }
[17:39:37.058]     ...future.result$conditions <- ...future.conditions
[17:39:37.058]     ...future.result$finished <- base::Sys.time()
[17:39:37.058]     ...future.result
[17:39:37.058] }
[17:39:37.061] MultisessionFuture started
[17:39:37.061] - Launch lazy future ... done
[17:39:37.061] run() for ‘MultisessionFuture’ ... done
[17:39:37.062] getGlobalsAndPackages() ...
[17:39:37.062] Searching for globals...
[17:39:37.063] - globals found: [1] ‘{’
[17:39:37.063] Searching for globals ... DONE
[17:39:37.063] Resolving globals: FALSE
[17:39:37.064] 
[17:39:37.064] 
[17:39:37.064] getGlobalsAndPackages() ... DONE
[17:39:37.064] run() for ‘Future’ ...
[17:39:37.064] - state: ‘created’
[17:39:37.064] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:37.078]   - Field: ‘node’
[17:39:37.079]   - Field: ‘label’
[17:39:37.079]   - Field: ‘local’
[17:39:37.079]   - Field: ‘owner’
[17:39:37.079]   - Field: ‘envir’
[17:39:37.079]   - Field: ‘workers’
[17:39:37.079]   - Field: ‘packages’
[17:39:37.079]   - Field: ‘gc’
[17:39:37.079]   - Field: ‘conditions’
[17:39:37.079]   - Field: ‘persistent’
[17:39:37.079]   - Field: ‘expr’
[17:39:37.079]   - Field: ‘uuid’
[17:39:37.080]   - Field: ‘seed’
[17:39:37.080]   - Field: ‘version’
[17:39:37.080]   - Field: ‘result’
[17:39:37.080]   - Field: ‘asynchronous’
[17:39:37.080]   - Field: ‘calls’
[17:39:37.080]   - Field: ‘globals’
[17:39:37.080]   - Field: ‘stdout’
[17:39:37.080]   - Field: ‘earlySignal’
[17:39:37.080]   - Field: ‘lazy’
[17:39:37.080]   - Field: ‘state’
[17:39:37.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:37.081] - Launch lazy future ...
[17:39:37.081] Packages needed by the future expression (n = 0): <none>
[17:39:37.081] Packages needed by future strategies (n = 0): <none>
[17:39:37.081] {
[17:39:37.081]     {
[17:39:37.081]         {
[17:39:37.081]             ...future.startTime <- base::Sys.time()
[17:39:37.081]             {
[17:39:37.081]                 {
[17:39:37.081]                   {
[17:39:37.081]                     {
[17:39:37.081]                       base::local({
[17:39:37.081]                         has_future <- base::requireNamespace("future", 
[17:39:37.081]                           quietly = TRUE)
[17:39:37.081]                         if (has_future) {
[17:39:37.081]                           ns <- base::getNamespace("future")
[17:39:37.081]                           version <- ns[[".package"]][["version"]]
[17:39:37.081]                           if (is.null(version)) 
[17:39:37.081]                             version <- utils::packageVersion("future")
[17:39:37.081]                         }
[17:39:37.081]                         else {
[17:39:37.081]                           version <- NULL
[17:39:37.081]                         }
[17:39:37.081]                         if (!has_future || version < "1.8.0") {
[17:39:37.081]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.081]                             "", base::R.version$version.string), 
[17:39:37.081]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.081]                               "release", "version")], collapse = " "), 
[17:39:37.081]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.081]                             info)
[17:39:37.081]                           info <- base::paste(info, collapse = "; ")
[17:39:37.081]                           if (!has_future) {
[17:39:37.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.081]                               info)
[17:39:37.081]                           }
[17:39:37.081]                           else {
[17:39:37.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.081]                               info, version)
[17:39:37.081]                           }
[17:39:37.081]                           base::stop(msg)
[17:39:37.081]                         }
[17:39:37.081]                       })
[17:39:37.081]                     }
[17:39:37.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.081]                     base::options(mc.cores = 1L)
[17:39:37.081]                   }
[17:39:37.081]                   ...future.strategy.old <- future::plan("list")
[17:39:37.081]                   options(future.plan = NULL)
[17:39:37.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.081]                 }
[17:39:37.081]                 ...future.workdir <- getwd()
[17:39:37.081]             }
[17:39:37.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.081]         }
[17:39:37.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.081]             base::names(...future.oldOptions))
[17:39:37.081]     }
[17:39:37.081]     if (FALSE) {
[17:39:37.081]     }
[17:39:37.081]     else {
[17:39:37.081]         if (TRUE) {
[17:39:37.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.081]                 open = "w")
[17:39:37.081]         }
[17:39:37.081]         else {
[17:39:37.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.081]         }
[17:39:37.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.081]             base::sink(type = "output", split = FALSE)
[17:39:37.081]             base::close(...future.stdout)
[17:39:37.081]         }, add = TRUE)
[17:39:37.081]     }
[17:39:37.081]     ...future.frame <- base::sys.nframe()
[17:39:37.081]     ...future.conditions <- base::list()
[17:39:37.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.081]     if (FALSE) {
[17:39:37.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.081]     }
[17:39:37.081]     ...future.result <- base::tryCatch({
[17:39:37.081]         base::withCallingHandlers({
[17:39:37.081]             ...future.value <- base::withVisible(base::local({
[17:39:37.081]                 ...future.makeSendCondition <- base::local({
[17:39:37.081]                   sendCondition <- NULL
[17:39:37.081]                   function(frame = 1L) {
[17:39:37.081]                     if (is.function(sendCondition)) 
[17:39:37.081]                       return(sendCondition)
[17:39:37.081]                     ns <- getNamespace("parallel")
[17:39:37.081]                     if (exists("sendData", mode = "function", 
[17:39:37.081]                       envir = ns)) {
[17:39:37.081]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:37.081]                         envir = ns)
[17:39:37.081]                       envir <- sys.frame(frame)
[17:39:37.081]                       master <- NULL
[17:39:37.081]                       while (!identical(envir, .GlobalEnv) && 
[17:39:37.081]                         !identical(envir, emptyenv())) {
[17:39:37.081]                         if (exists("master", mode = "list", envir = envir, 
[17:39:37.081]                           inherits = FALSE)) {
[17:39:37.081]                           master <- get("master", mode = "list", 
[17:39:37.081]                             envir = envir, inherits = FALSE)
[17:39:37.081]                           if (inherits(master, c("SOCKnode", 
[17:39:37.081]                             "SOCK0node"))) {
[17:39:37.081]                             sendCondition <<- function(cond) {
[17:39:37.081]                               data <- list(type = "VALUE", value = cond, 
[17:39:37.081]                                 success = TRUE)
[17:39:37.081]                               parallel_sendData(master, data)
[17:39:37.081]                             }
[17:39:37.081]                             return(sendCondition)
[17:39:37.081]                           }
[17:39:37.081]                         }
[17:39:37.081]                         frame <- frame + 1L
[17:39:37.081]                         envir <- sys.frame(frame)
[17:39:37.081]                       }
[17:39:37.081]                     }
[17:39:37.081]                     sendCondition <<- function(cond) NULL
[17:39:37.081]                   }
[17:39:37.081]                 })
[17:39:37.081]                 withCallingHandlers({
[17:39:37.081]                   {
[17:39:37.081]                     4
[17:39:37.081]                   }
[17:39:37.081]                 }, immediateCondition = function(cond) {
[17:39:37.081]                   sendCondition <- ...future.makeSendCondition()
[17:39:37.081]                   sendCondition(cond)
[17:39:37.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.081]                   {
[17:39:37.081]                     inherits <- base::inherits
[17:39:37.081]                     invokeRestart <- base::invokeRestart
[17:39:37.081]                     is.null <- base::is.null
[17:39:37.081]                     muffled <- FALSE
[17:39:37.081]                     if (inherits(cond, "message")) {
[17:39:37.081]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.081]                       if (muffled) 
[17:39:37.081]                         invokeRestart("muffleMessage")
[17:39:37.081]                     }
[17:39:37.081]                     else if (inherits(cond, "warning")) {
[17:39:37.081]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.081]                       if (muffled) 
[17:39:37.081]                         invokeRestart("muffleWarning")
[17:39:37.081]                     }
[17:39:37.081]                     else if (inherits(cond, "condition")) {
[17:39:37.081]                       if (!is.null(pattern)) {
[17:39:37.081]                         computeRestarts <- base::computeRestarts
[17:39:37.081]                         grepl <- base::grepl
[17:39:37.081]                         restarts <- computeRestarts(cond)
[17:39:37.081]                         for (restart in restarts) {
[17:39:37.081]                           name <- restart$name
[17:39:37.081]                           if (is.null(name)) 
[17:39:37.081]                             next
[17:39:37.081]                           if (!grepl(pattern, name)) 
[17:39:37.081]                             next
[17:39:37.081]                           invokeRestart(restart)
[17:39:37.081]                           muffled <- TRUE
[17:39:37.081]                           break
[17:39:37.081]                         }
[17:39:37.081]                       }
[17:39:37.081]                     }
[17:39:37.081]                     invisible(muffled)
[17:39:37.081]                   }
[17:39:37.081]                   muffleCondition(cond)
[17:39:37.081]                 })
[17:39:37.081]             }))
[17:39:37.081]             future::FutureResult(value = ...future.value$value, 
[17:39:37.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.081]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.081]                     ...future.globalenv.names))
[17:39:37.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.081]         }, condition = base::local({
[17:39:37.081]             c <- base::c
[17:39:37.081]             inherits <- base::inherits
[17:39:37.081]             invokeRestart <- base::invokeRestart
[17:39:37.081]             length <- base::length
[17:39:37.081]             list <- base::list
[17:39:37.081]             seq.int <- base::seq.int
[17:39:37.081]             signalCondition <- base::signalCondition
[17:39:37.081]             sys.calls <- base::sys.calls
[17:39:37.081]             `[[` <- base::`[[`
[17:39:37.081]             `+` <- base::`+`
[17:39:37.081]             `<<-` <- base::`<<-`
[17:39:37.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.081]                   3L)]
[17:39:37.081]             }
[17:39:37.081]             function(cond) {
[17:39:37.081]                 is_error <- inherits(cond, "error")
[17:39:37.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.081]                   NULL)
[17:39:37.081]                 if (is_error) {
[17:39:37.081]                   sessionInformation <- function() {
[17:39:37.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.081]                       search = base::search(), system = base::Sys.info())
[17:39:37.081]                   }
[17:39:37.081]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.081]                     cond$call), session = sessionInformation(), 
[17:39:37.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.081]                   signalCondition(cond)
[17:39:37.081]                 }
[17:39:37.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.081]                 "immediateCondition"))) {
[17:39:37.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.081]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.081]                   if (TRUE && !signal) {
[17:39:37.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.081]                     {
[17:39:37.081]                       inherits <- base::inherits
[17:39:37.081]                       invokeRestart <- base::invokeRestart
[17:39:37.081]                       is.null <- base::is.null
[17:39:37.081]                       muffled <- FALSE
[17:39:37.081]                       if (inherits(cond, "message")) {
[17:39:37.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.081]                         if (muffled) 
[17:39:37.081]                           invokeRestart("muffleMessage")
[17:39:37.081]                       }
[17:39:37.081]                       else if (inherits(cond, "warning")) {
[17:39:37.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.081]                         if (muffled) 
[17:39:37.081]                           invokeRestart("muffleWarning")
[17:39:37.081]                       }
[17:39:37.081]                       else if (inherits(cond, "condition")) {
[17:39:37.081]                         if (!is.null(pattern)) {
[17:39:37.081]                           computeRestarts <- base::computeRestarts
[17:39:37.081]                           grepl <- base::grepl
[17:39:37.081]                           restarts <- computeRestarts(cond)
[17:39:37.081]                           for (restart in restarts) {
[17:39:37.081]                             name <- restart$name
[17:39:37.081]                             if (is.null(name)) 
[17:39:37.081]                               next
[17:39:37.081]                             if (!grepl(pattern, name)) 
[17:39:37.081]                               next
[17:39:37.081]                             invokeRestart(restart)
[17:39:37.081]                             muffled <- TRUE
[17:39:37.081]                             break
[17:39:37.081]                           }
[17:39:37.081]                         }
[17:39:37.081]                       }
[17:39:37.081]                       invisible(muffled)
[17:39:37.081]                     }
[17:39:37.081]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.081]                   }
[17:39:37.081]                 }
[17:39:37.081]                 else {
[17:39:37.081]                   if (TRUE) {
[17:39:37.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.081]                     {
[17:39:37.081]                       inherits <- base::inherits
[17:39:37.081]                       invokeRestart <- base::invokeRestart
[17:39:37.081]                       is.null <- base::is.null
[17:39:37.081]                       muffled <- FALSE
[17:39:37.081]                       if (inherits(cond, "message")) {
[17:39:37.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.081]                         if (muffled) 
[17:39:37.081]                           invokeRestart("muffleMessage")
[17:39:37.081]                       }
[17:39:37.081]                       else if (inherits(cond, "warning")) {
[17:39:37.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.081]                         if (muffled) 
[17:39:37.081]                           invokeRestart("muffleWarning")
[17:39:37.081]                       }
[17:39:37.081]                       else if (inherits(cond, "condition")) {
[17:39:37.081]                         if (!is.null(pattern)) {
[17:39:37.081]                           computeRestarts <- base::computeRestarts
[17:39:37.081]                           grepl <- base::grepl
[17:39:37.081]                           restarts <- computeRestarts(cond)
[17:39:37.081]                           for (restart in restarts) {
[17:39:37.081]                             name <- restart$name
[17:39:37.081]                             if (is.null(name)) 
[17:39:37.081]                               next
[17:39:37.081]                             if (!grepl(pattern, name)) 
[17:39:37.081]                               next
[17:39:37.081]                             invokeRestart(restart)
[17:39:37.081]                             muffled <- TRUE
[17:39:37.081]                             break
[17:39:37.081]                           }
[17:39:37.081]                         }
[17:39:37.081]                       }
[17:39:37.081]                       invisible(muffled)
[17:39:37.081]                     }
[17:39:37.081]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.081]                   }
[17:39:37.081]                 }
[17:39:37.081]             }
[17:39:37.081]         }))
[17:39:37.081]     }, error = function(ex) {
[17:39:37.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.081]                 ...future.rng), started = ...future.startTime, 
[17:39:37.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.081]             version = "1.8"), class = "FutureResult")
[17:39:37.081]     }, finally = {
[17:39:37.081]         if (!identical(...future.workdir, getwd())) 
[17:39:37.081]             setwd(...future.workdir)
[17:39:37.081]         {
[17:39:37.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.081]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.081]             }
[17:39:37.081]             base::options(...future.oldOptions)
[17:39:37.081]             if (.Platform$OS.type == "windows") {
[17:39:37.081]                 old_names <- names(...future.oldEnvVars)
[17:39:37.081]                 envs <- base::Sys.getenv()
[17:39:37.081]                 names <- names(envs)
[17:39:37.081]                 common <- intersect(names, old_names)
[17:39:37.081]                 added <- setdiff(names, old_names)
[17:39:37.081]                 removed <- setdiff(old_names, names)
[17:39:37.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.081]                   envs[common]]
[17:39:37.081]                 NAMES <- toupper(changed)
[17:39:37.081]                 args <- list()
[17:39:37.081]                 for (kk in seq_along(NAMES)) {
[17:39:37.081]                   name <- changed[[kk]]
[17:39:37.081]                   NAME <- NAMES[[kk]]
[17:39:37.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.081]                     next
[17:39:37.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.081]                 }
[17:39:37.081]                 NAMES <- toupper(added)
[17:39:37.081]                 for (kk in seq_along(NAMES)) {
[17:39:37.081]                   name <- added[[kk]]
[17:39:37.081]                   NAME <- NAMES[[kk]]
[17:39:37.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.081]                     next
[17:39:37.081]                   args[[name]] <- ""
[17:39:37.081]                 }
[17:39:37.081]                 NAMES <- toupper(removed)
[17:39:37.081]                 for (kk in seq_along(NAMES)) {
[17:39:37.081]                   name <- removed[[kk]]
[17:39:37.081]                   NAME <- NAMES[[kk]]
[17:39:37.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.081]                     next
[17:39:37.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.081]                 }
[17:39:37.081]                 if (length(args) > 0) 
[17:39:37.081]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.081]             }
[17:39:37.081]             else {
[17:39:37.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.081]             }
[17:39:37.081]             {
[17:39:37.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.081]                   0L) {
[17:39:37.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.081]                   base::options(opts)
[17:39:37.081]                 }
[17:39:37.081]                 {
[17:39:37.081]                   {
[17:39:37.081]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.081]                     NULL
[17:39:37.081]                   }
[17:39:37.081]                   options(future.plan = NULL)
[17:39:37.081]                   if (is.na(NA_character_)) 
[17:39:37.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.081]                     .init = FALSE)
[17:39:37.081]                 }
[17:39:37.081]             }
[17:39:37.081]         }
[17:39:37.081]     })
[17:39:37.081]     if (TRUE) {
[17:39:37.081]         base::sink(type = "output", split = FALSE)
[17:39:37.081]         if (TRUE) {
[17:39:37.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.081]         }
[17:39:37.081]         else {
[17:39:37.081]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.081]         }
[17:39:37.081]         base::close(...future.stdout)
[17:39:37.081]         ...future.stdout <- NULL
[17:39:37.081]     }
[17:39:37.081]     ...future.result$conditions <- ...future.conditions
[17:39:37.081]     ...future.result$finished <- base::Sys.time()
[17:39:37.081]     ...future.result
[17:39:37.081] }
[17:39:37.083] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:37.094] receiveMessageFromWorker() for ClusterFuture ...
[17:39:37.094] - Validating connection of MultisessionFuture
[17:39:37.094] - received message: FutureResult
[17:39:37.094] - Received FutureResult
[17:39:37.095] - Erased future from FutureRegistry
[17:39:37.095] result() for ClusterFuture ...
[17:39:37.095] - result already collected: FutureResult
[17:39:37.095] result() for ClusterFuture ... done
[17:39:37.095] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:37.095] result() for ClusterFuture ...
[17:39:37.095] - result already collected: FutureResult
[17:39:37.095] result() for ClusterFuture ... done
[17:39:37.095] result() for ClusterFuture ...
[17:39:37.095] - result already collected: FutureResult
[17:39:37.095] result() for ClusterFuture ... done
[17:39:37.097] MultisessionFuture started
[17:39:37.097] - Launch lazy future ... done
[17:39:37.097] run() for ‘MultisessionFuture’ ... done
<environment: 0x55adf1ecbdb8> 
<environment: 0x55adefc493e0> 
[17:39:37.098] receiveMessageFromWorker() for ClusterFuture ...
[17:39:37.098] - Validating connection of MultisessionFuture
[17:39:37.099] - received message: FutureResult
[17:39:37.099] - Received FutureResult
[17:39:37.099] - Erased future from FutureRegistry
[17:39:37.099] result() for ClusterFuture ...
[17:39:37.099] - result already collected: FutureResult
[17:39:37.099] result() for ClusterFuture ... done
[17:39:37.099] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:37.100] receiveMessageFromWorker() for ClusterFuture ...
[17:39:37.100] - Validating connection of MultisessionFuture
[17:39:37.100] - received message: FutureResult
[17:39:37.100] - Received FutureResult
[17:39:37.100] - Erased future from FutureRegistry
[17:39:37.100] result() for ClusterFuture ...
[17:39:37.100] - result already collected: FutureResult
[17:39:37.100] result() for ClusterFuture ... done
[17:39:37.100] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:39:37.102] resolve() on environment ...
[17:39:37.102]  recursive: 0
[17:39:37.102]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:39:37.102] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.102] - nx: 4
[17:39:37.102] - relay: TRUE
[17:39:37.103] - stdout: TRUE
[17:39:37.103] - signal: TRUE
[17:39:37.103] - resignal: FALSE
[17:39:37.103] - force: TRUE
[17:39:37.103] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:37.103] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:37.103]  - until=2
[17:39:37.103]  - relaying element #2
[17:39:37.103] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:37.103] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:37.103] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.104]  length: 3 (resolved future 1)
[17:39:37.104] Future #2
[17:39:37.104] result() for ClusterFuture ...
[17:39:37.104] - result already collected: FutureResult
[17:39:37.104] result() for ClusterFuture ... done
[17:39:37.104] result() for ClusterFuture ...
[17:39:37.104] - result already collected: FutureResult
[17:39:37.104] result() for ClusterFuture ... done
[17:39:37.104] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:37.104] - nx: 4
[17:39:37.105] - relay: TRUE
[17:39:37.105] - stdout: TRUE
[17:39:37.105] - signal: TRUE
[17:39:37.105] - resignal: FALSE
[17:39:37.105] - force: TRUE
[17:39:37.105] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:39:37.105] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:39:37.105]  - until=2
[17:39:37.105]  - relaying element #2
[17:39:37.105] result() for ClusterFuture ...
[17:39:37.105] - result already collected: FutureResult
[17:39:37.106] result() for ClusterFuture ... done
[17:39:37.106] result() for ClusterFuture ...
[17:39:37.106] - result already collected: FutureResult
[17:39:37.106] result() for ClusterFuture ... done
[17:39:37.106] result() for ClusterFuture ...
[17:39:37.106] - result already collected: FutureResult
[17:39:37.106] result() for ClusterFuture ... done
[17:39:37.106] result() for ClusterFuture ...
[17:39:37.106] - result already collected: FutureResult
[17:39:37.106] result() for ClusterFuture ... done
[17:39:37.106] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:37.107] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:37.107] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:37.107]  length: 2 (resolved future 2)
[17:39:37.107] Future #3
[17:39:37.107] result() for ClusterFuture ...
[17:39:37.107] - result already collected: FutureResult
[17:39:37.107] result() for ClusterFuture ... done
[17:39:37.107] result() for ClusterFuture ...
[17:39:37.107] - result already collected: FutureResult
[17:39:37.107] result() for ClusterFuture ... done
[17:39:37.107] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:37.108] - nx: 4
[17:39:37.108] - relay: TRUE
[17:39:37.108] - stdout: TRUE
[17:39:37.108] - signal: TRUE
[17:39:37.108] - resignal: FALSE
[17:39:37.108] - force: TRUE
[17:39:37.108] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:39:37.108] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:39:37.108]  - until=3
[17:39:37.108]  - relaying element #3
[17:39:37.108] result() for ClusterFuture ...
[17:39:37.109] - result already collected: FutureResult
[17:39:37.109] result() for ClusterFuture ... done
[17:39:37.109] result() for ClusterFuture ...
[17:39:37.109] - result already collected: FutureResult
[17:39:37.109] result() for ClusterFuture ... done
[17:39:37.109] result() for ClusterFuture ...
[17:39:37.109] - result already collected: FutureResult
[17:39:37.109] result() for ClusterFuture ... done
[17:39:37.109] result() for ClusterFuture ...
[17:39:37.109] - result already collected: FutureResult
[17:39:37.109] result() for ClusterFuture ... done
[17:39:37.109] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:37.110] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:37.110] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:37.110]  length: 1 (resolved future 3)
[17:39:37.110] Future #4
[17:39:37.110] result() for ClusterFuture ...
[17:39:37.110] - result already collected: FutureResult
[17:39:37.110] result() for ClusterFuture ... done
[17:39:37.110] result() for ClusterFuture ...
[17:39:37.110] - result already collected: FutureResult
[17:39:37.110] result() for ClusterFuture ... done
[17:39:37.110] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:37.111] - nx: 4
[17:39:37.111] - relay: TRUE
[17:39:37.111] - stdout: TRUE
[17:39:37.111] - signal: TRUE
[17:39:37.111] - resignal: FALSE
[17:39:37.111] - force: TRUE
[17:39:37.111] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:39:37.111] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:39:37.111]  - until=4
[17:39:37.111]  - relaying element #4
[17:39:37.111] result() for ClusterFuture ...
[17:39:37.111] - result already collected: FutureResult
[17:39:37.112] result() for ClusterFuture ... done
[17:39:37.112] result() for ClusterFuture ...
[17:39:37.112] - result already collected: FutureResult
[17:39:37.112] result() for ClusterFuture ... done
[17:39:37.112] result() for ClusterFuture ...
[17:39:37.112] - result already collected: FutureResult
[17:39:37.112] result() for ClusterFuture ... done
[17:39:37.112] result() for ClusterFuture ...
[17:39:37.112] - result already collected: FutureResult
[17:39:37.112] result() for ClusterFuture ... done
[17:39:37.112] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.113] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:37.113] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:37.113]  length: 0 (resolved future 4)
[17:39:37.113] Relaying remaining futures
[17:39:37.113] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.113] - nx: 4
[17:39:37.113] - relay: TRUE
[17:39:37.113] - stdout: TRUE
[17:39:37.113] - signal: TRUE
[17:39:37.113] - resignal: FALSE
[17:39:37.113] - force: TRUE
[17:39:37.113] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.114] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:39:37.114] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:39:37.114] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:39:37.114] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.114] resolve() on environment ... DONE
[17:39:37.114] result() for ClusterFuture ...
[17:39:37.114] - result already collected: FutureResult
[17:39:37.114] result() for ClusterFuture ... done
[17:39:37.114] result() for ClusterFuture ...
[17:39:37.114] - result already collected: FutureResult
[17:39:37.114] result() for ClusterFuture ... done
[17:39:37.115] result() for ClusterFuture ...
[17:39:37.115] - result already collected: FutureResult
[17:39:37.115] result() for ClusterFuture ... done
[17:39:37.115] result() for ClusterFuture ...
[17:39:37.115] - result already collected: FutureResult
[17:39:37.115] result() for ClusterFuture ... done
[17:39:37.115] result() for ClusterFuture ...
[17:39:37.115] - result already collected: FutureResult
[17:39:37.115] result() for ClusterFuture ... done
[17:39:37.115] result() for ClusterFuture ...
[17:39:37.115] - result already collected: FutureResult
[17:39:37.115] result() for ClusterFuture ... done
<environment: 0x55adee90e680> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[17:39:37.116] plan(): Setting new future strategy stack:
[17:39:37.116] List of future strategies:
[17:39:37.116] 1. multicore:
[17:39:37.116]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.116]    - tweaked: FALSE
[17:39:37.116]    - call: plan(strategy)
[17:39:37.121] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:37.121] getGlobalsAndPackages() ...
[17:39:37.121] Searching for globals...
[17:39:37.122] 
[17:39:37.122] Searching for globals ... DONE
[17:39:37.122] - globals: [0] <none>
[17:39:37.122] getGlobalsAndPackages() ... DONE
[17:39:37.123] run() for ‘Future’ ...
[17:39:37.123] - state: ‘created’
[17:39:37.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.128]   - Field: ‘label’
[17:39:37.128]   - Field: ‘local’
[17:39:37.128]   - Field: ‘owner’
[17:39:37.128]   - Field: ‘envir’
[17:39:37.128]   - Field: ‘workers’
[17:39:37.128]   - Field: ‘packages’
[17:39:37.128]   - Field: ‘gc’
[17:39:37.128]   - Field: ‘job’
[17:39:37.128]   - Field: ‘conditions’
[17:39:37.129]   - Field: ‘expr’
[17:39:37.129]   - Field: ‘uuid’
[17:39:37.129]   - Field: ‘seed’
[17:39:37.129]   - Field: ‘version’
[17:39:37.129]   - Field: ‘result’
[17:39:37.129]   - Field: ‘asynchronous’
[17:39:37.129]   - Field: ‘calls’
[17:39:37.129]   - Field: ‘globals’
[17:39:37.129]   - Field: ‘stdout’
[17:39:37.129]   - Field: ‘earlySignal’
[17:39:37.129]   - Field: ‘lazy’
[17:39:37.130]   - Field: ‘state’
[17:39:37.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.130] - Launch lazy future ...
[17:39:37.130] Packages needed by the future expression (n = 0): <none>
[17:39:37.130] Packages needed by future strategies (n = 0): <none>
[17:39:37.131] {
[17:39:37.131]     {
[17:39:37.131]         {
[17:39:37.131]             ...future.startTime <- base::Sys.time()
[17:39:37.131]             {
[17:39:37.131]                 {
[17:39:37.131]                   {
[17:39:37.131]                     {
[17:39:37.131]                       base::local({
[17:39:37.131]                         has_future <- base::requireNamespace("future", 
[17:39:37.131]                           quietly = TRUE)
[17:39:37.131]                         if (has_future) {
[17:39:37.131]                           ns <- base::getNamespace("future")
[17:39:37.131]                           version <- ns[[".package"]][["version"]]
[17:39:37.131]                           if (is.null(version)) 
[17:39:37.131]                             version <- utils::packageVersion("future")
[17:39:37.131]                         }
[17:39:37.131]                         else {
[17:39:37.131]                           version <- NULL
[17:39:37.131]                         }
[17:39:37.131]                         if (!has_future || version < "1.8.0") {
[17:39:37.131]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.131]                             "", base::R.version$version.string), 
[17:39:37.131]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.131]                               "release", "version")], collapse = " "), 
[17:39:37.131]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.131]                             info)
[17:39:37.131]                           info <- base::paste(info, collapse = "; ")
[17:39:37.131]                           if (!has_future) {
[17:39:37.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.131]                               info)
[17:39:37.131]                           }
[17:39:37.131]                           else {
[17:39:37.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.131]                               info, version)
[17:39:37.131]                           }
[17:39:37.131]                           base::stop(msg)
[17:39:37.131]                         }
[17:39:37.131]                       })
[17:39:37.131]                     }
[17:39:37.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.131]                     base::options(mc.cores = 1L)
[17:39:37.131]                   }
[17:39:37.131]                   ...future.strategy.old <- future::plan("list")
[17:39:37.131]                   options(future.plan = NULL)
[17:39:37.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.131]                 }
[17:39:37.131]                 ...future.workdir <- getwd()
[17:39:37.131]             }
[17:39:37.131]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.131]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.131]         }
[17:39:37.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.131]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.131]             base::names(...future.oldOptions))
[17:39:37.131]     }
[17:39:37.131]     if (FALSE) {
[17:39:37.131]     }
[17:39:37.131]     else {
[17:39:37.131]         if (TRUE) {
[17:39:37.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.131]                 open = "w")
[17:39:37.131]         }
[17:39:37.131]         else {
[17:39:37.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.131]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.131]         }
[17:39:37.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.131]             base::sink(type = "output", split = FALSE)
[17:39:37.131]             base::close(...future.stdout)
[17:39:37.131]         }, add = TRUE)
[17:39:37.131]     }
[17:39:37.131]     ...future.frame <- base::sys.nframe()
[17:39:37.131]     ...future.conditions <- base::list()
[17:39:37.131]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.131]     if (FALSE) {
[17:39:37.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.131]     }
[17:39:37.131]     ...future.result <- base::tryCatch({
[17:39:37.131]         base::withCallingHandlers({
[17:39:37.131]             ...future.value <- base::withVisible(base::local({
[17:39:37.131]                 withCallingHandlers({
[17:39:37.131]                   2
[17:39:37.131]                 }, immediateCondition = function(cond) {
[17:39:37.131]                   save_rds <- function (object, pathname, ...) 
[17:39:37.131]                   {
[17:39:37.131]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.131]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.131]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.131]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.131]                         fi_tmp[["mtime"]])
[17:39:37.131]                     }
[17:39:37.131]                     tryCatch({
[17:39:37.131]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.131]                     }, error = function(ex) {
[17:39:37.131]                       msg <- conditionMessage(ex)
[17:39:37.131]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.131]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.131]                         fi_tmp[["mtime"]], msg)
[17:39:37.131]                       ex$message <- msg
[17:39:37.131]                       stop(ex)
[17:39:37.131]                     })
[17:39:37.131]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.131]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.131]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.131]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.131]                       fi <- file.info(pathname)
[17:39:37.131]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.131]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.131]                         fi[["size"]], fi[["mtime"]])
[17:39:37.131]                       stop(msg)
[17:39:37.131]                     }
[17:39:37.131]                     invisible(pathname)
[17:39:37.131]                   }
[17:39:37.131]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.131]                     rootPath = tempdir()) 
[17:39:37.131]                   {
[17:39:37.131]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.131]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.131]                       tmpdir = path, fileext = ".rds")
[17:39:37.131]                     save_rds(obj, file)
[17:39:37.131]                   }
[17:39:37.131]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.131]                   {
[17:39:37.131]                     inherits <- base::inherits
[17:39:37.131]                     invokeRestart <- base::invokeRestart
[17:39:37.131]                     is.null <- base::is.null
[17:39:37.131]                     muffled <- FALSE
[17:39:37.131]                     if (inherits(cond, "message")) {
[17:39:37.131]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.131]                       if (muffled) 
[17:39:37.131]                         invokeRestart("muffleMessage")
[17:39:37.131]                     }
[17:39:37.131]                     else if (inherits(cond, "warning")) {
[17:39:37.131]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.131]                       if (muffled) 
[17:39:37.131]                         invokeRestart("muffleWarning")
[17:39:37.131]                     }
[17:39:37.131]                     else if (inherits(cond, "condition")) {
[17:39:37.131]                       if (!is.null(pattern)) {
[17:39:37.131]                         computeRestarts <- base::computeRestarts
[17:39:37.131]                         grepl <- base::grepl
[17:39:37.131]                         restarts <- computeRestarts(cond)
[17:39:37.131]                         for (restart in restarts) {
[17:39:37.131]                           name <- restart$name
[17:39:37.131]                           if (is.null(name)) 
[17:39:37.131]                             next
[17:39:37.131]                           if (!grepl(pattern, name)) 
[17:39:37.131]                             next
[17:39:37.131]                           invokeRestart(restart)
[17:39:37.131]                           muffled <- TRUE
[17:39:37.131]                           break
[17:39:37.131]                         }
[17:39:37.131]                       }
[17:39:37.131]                     }
[17:39:37.131]                     invisible(muffled)
[17:39:37.131]                   }
[17:39:37.131]                   muffleCondition(cond)
[17:39:37.131]                 })
[17:39:37.131]             }))
[17:39:37.131]             future::FutureResult(value = ...future.value$value, 
[17:39:37.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.131]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.131]                     ...future.globalenv.names))
[17:39:37.131]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.131]         }, condition = base::local({
[17:39:37.131]             c <- base::c
[17:39:37.131]             inherits <- base::inherits
[17:39:37.131]             invokeRestart <- base::invokeRestart
[17:39:37.131]             length <- base::length
[17:39:37.131]             list <- base::list
[17:39:37.131]             seq.int <- base::seq.int
[17:39:37.131]             signalCondition <- base::signalCondition
[17:39:37.131]             sys.calls <- base::sys.calls
[17:39:37.131]             `[[` <- base::`[[`
[17:39:37.131]             `+` <- base::`+`
[17:39:37.131]             `<<-` <- base::`<<-`
[17:39:37.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.131]                   3L)]
[17:39:37.131]             }
[17:39:37.131]             function(cond) {
[17:39:37.131]                 is_error <- inherits(cond, "error")
[17:39:37.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.131]                   NULL)
[17:39:37.131]                 if (is_error) {
[17:39:37.131]                   sessionInformation <- function() {
[17:39:37.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.131]                       search = base::search(), system = base::Sys.info())
[17:39:37.131]                   }
[17:39:37.131]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.131]                     cond$call), session = sessionInformation(), 
[17:39:37.131]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.131]                   signalCondition(cond)
[17:39:37.131]                 }
[17:39:37.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.131]                 "immediateCondition"))) {
[17:39:37.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.131]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.131]                   if (TRUE && !signal) {
[17:39:37.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.131]                     {
[17:39:37.131]                       inherits <- base::inherits
[17:39:37.131]                       invokeRestart <- base::invokeRestart
[17:39:37.131]                       is.null <- base::is.null
[17:39:37.131]                       muffled <- FALSE
[17:39:37.131]                       if (inherits(cond, "message")) {
[17:39:37.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.131]                         if (muffled) 
[17:39:37.131]                           invokeRestart("muffleMessage")
[17:39:37.131]                       }
[17:39:37.131]                       else if (inherits(cond, "warning")) {
[17:39:37.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.131]                         if (muffled) 
[17:39:37.131]                           invokeRestart("muffleWarning")
[17:39:37.131]                       }
[17:39:37.131]                       else if (inherits(cond, "condition")) {
[17:39:37.131]                         if (!is.null(pattern)) {
[17:39:37.131]                           computeRestarts <- base::computeRestarts
[17:39:37.131]                           grepl <- base::grepl
[17:39:37.131]                           restarts <- computeRestarts(cond)
[17:39:37.131]                           for (restart in restarts) {
[17:39:37.131]                             name <- restart$name
[17:39:37.131]                             if (is.null(name)) 
[17:39:37.131]                               next
[17:39:37.131]                             if (!grepl(pattern, name)) 
[17:39:37.131]                               next
[17:39:37.131]                             invokeRestart(restart)
[17:39:37.131]                             muffled <- TRUE
[17:39:37.131]                             break
[17:39:37.131]                           }
[17:39:37.131]                         }
[17:39:37.131]                       }
[17:39:37.131]                       invisible(muffled)
[17:39:37.131]                     }
[17:39:37.131]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.131]                   }
[17:39:37.131]                 }
[17:39:37.131]                 else {
[17:39:37.131]                   if (TRUE) {
[17:39:37.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.131]                     {
[17:39:37.131]                       inherits <- base::inherits
[17:39:37.131]                       invokeRestart <- base::invokeRestart
[17:39:37.131]                       is.null <- base::is.null
[17:39:37.131]                       muffled <- FALSE
[17:39:37.131]                       if (inherits(cond, "message")) {
[17:39:37.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.131]                         if (muffled) 
[17:39:37.131]                           invokeRestart("muffleMessage")
[17:39:37.131]                       }
[17:39:37.131]                       else if (inherits(cond, "warning")) {
[17:39:37.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.131]                         if (muffled) 
[17:39:37.131]                           invokeRestart("muffleWarning")
[17:39:37.131]                       }
[17:39:37.131]                       else if (inherits(cond, "condition")) {
[17:39:37.131]                         if (!is.null(pattern)) {
[17:39:37.131]                           computeRestarts <- base::computeRestarts
[17:39:37.131]                           grepl <- base::grepl
[17:39:37.131]                           restarts <- computeRestarts(cond)
[17:39:37.131]                           for (restart in restarts) {
[17:39:37.131]                             name <- restart$name
[17:39:37.131]                             if (is.null(name)) 
[17:39:37.131]                               next
[17:39:37.131]                             if (!grepl(pattern, name)) 
[17:39:37.131]                               next
[17:39:37.131]                             invokeRestart(restart)
[17:39:37.131]                             muffled <- TRUE
[17:39:37.131]                             break
[17:39:37.131]                           }
[17:39:37.131]                         }
[17:39:37.131]                       }
[17:39:37.131]                       invisible(muffled)
[17:39:37.131]                     }
[17:39:37.131]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.131]                   }
[17:39:37.131]                 }
[17:39:37.131]             }
[17:39:37.131]         }))
[17:39:37.131]     }, error = function(ex) {
[17:39:37.131]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.131]                 ...future.rng), started = ...future.startTime, 
[17:39:37.131]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.131]             version = "1.8"), class = "FutureResult")
[17:39:37.131]     }, finally = {
[17:39:37.131]         if (!identical(...future.workdir, getwd())) 
[17:39:37.131]             setwd(...future.workdir)
[17:39:37.131]         {
[17:39:37.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.131]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.131]             }
[17:39:37.131]             base::options(...future.oldOptions)
[17:39:37.131]             if (.Platform$OS.type == "windows") {
[17:39:37.131]                 old_names <- names(...future.oldEnvVars)
[17:39:37.131]                 envs <- base::Sys.getenv()
[17:39:37.131]                 names <- names(envs)
[17:39:37.131]                 common <- intersect(names, old_names)
[17:39:37.131]                 added <- setdiff(names, old_names)
[17:39:37.131]                 removed <- setdiff(old_names, names)
[17:39:37.131]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.131]                   envs[common]]
[17:39:37.131]                 NAMES <- toupper(changed)
[17:39:37.131]                 args <- list()
[17:39:37.131]                 for (kk in seq_along(NAMES)) {
[17:39:37.131]                   name <- changed[[kk]]
[17:39:37.131]                   NAME <- NAMES[[kk]]
[17:39:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.131]                     next
[17:39:37.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.131]                 }
[17:39:37.131]                 NAMES <- toupper(added)
[17:39:37.131]                 for (kk in seq_along(NAMES)) {
[17:39:37.131]                   name <- added[[kk]]
[17:39:37.131]                   NAME <- NAMES[[kk]]
[17:39:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.131]                     next
[17:39:37.131]                   args[[name]] <- ""
[17:39:37.131]                 }
[17:39:37.131]                 NAMES <- toupper(removed)
[17:39:37.131]                 for (kk in seq_along(NAMES)) {
[17:39:37.131]                   name <- removed[[kk]]
[17:39:37.131]                   NAME <- NAMES[[kk]]
[17:39:37.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.131]                     next
[17:39:37.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.131]                 }
[17:39:37.131]                 if (length(args) > 0) 
[17:39:37.131]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.131]             }
[17:39:37.131]             else {
[17:39:37.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.131]             }
[17:39:37.131]             {
[17:39:37.131]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.131]                   0L) {
[17:39:37.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.131]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.131]                   base::options(opts)
[17:39:37.131]                 }
[17:39:37.131]                 {
[17:39:37.131]                   {
[17:39:37.131]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.131]                     NULL
[17:39:37.131]                   }
[17:39:37.131]                   options(future.plan = NULL)
[17:39:37.131]                   if (is.na(NA_character_)) 
[17:39:37.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.131]                     .init = FALSE)
[17:39:37.131]                 }
[17:39:37.131]             }
[17:39:37.131]         }
[17:39:37.131]     })
[17:39:37.131]     if (TRUE) {
[17:39:37.131]         base::sink(type = "output", split = FALSE)
[17:39:37.131]         if (TRUE) {
[17:39:37.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.131]         }
[17:39:37.131]         else {
[17:39:37.131]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.131]         }
[17:39:37.131]         base::close(...future.stdout)
[17:39:37.131]         ...future.stdout <- NULL
[17:39:37.131]     }
[17:39:37.131]     ...future.result$conditions <- ...future.conditions
[17:39:37.131]     ...future.result$finished <- base::Sys.time()
[17:39:37.131]     ...future.result
[17:39:37.131] }
[17:39:37.133] requestCore(): workers = 2
[17:39:37.135] MulticoreFuture started
[17:39:37.136] - Launch lazy future ... done
[17:39:37.136] run() for ‘MulticoreFuture’ ... done
[17:39:37.136] getGlobalsAndPackages() ...
[17:39:37.137] Searching for globals...
[17:39:37.137] plan(): Setting new future strategy stack:
[17:39:37.137] List of future strategies:
[17:39:37.137] 1. sequential:
[17:39:37.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.137]    - tweaked: FALSE
[17:39:37.137]    - call: NULL
[17:39:37.138] 
[17:39:37.138] plan(): nbrOfWorkers() = 1
[17:39:37.138] Searching for globals ... DONE
[17:39:37.138] - globals: [0] <none>
[17:39:37.138] getGlobalsAndPackages() ... DONE
[17:39:37.139] run() for ‘Future’ ...
[17:39:37.139] - state: ‘created’
[17:39:37.139] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.140] plan(): Setting new future strategy stack:
[17:39:37.140] List of future strategies:
[17:39:37.140] 1. multicore:
[17:39:37.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.140]    - tweaked: FALSE
[17:39:37.140]    - call: plan(strategy)
[17:39:37.145] plan(): nbrOfWorkers() = 2
[17:39:37.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.146]   - Field: ‘label’
[17:39:37.146]   - Field: ‘local’
[17:39:37.146]   - Field: ‘owner’
[17:39:37.147]   - Field: ‘envir’
[17:39:37.147]   - Field: ‘workers’
[17:39:37.147]   - Field: ‘packages’
[17:39:37.147]   - Field: ‘gc’
[17:39:37.147]   - Field: ‘job’
[17:39:37.147]   - Field: ‘conditions’
[17:39:37.147]   - Field: ‘expr’
[17:39:37.148]   - Field: ‘uuid’
[17:39:37.148]   - Field: ‘seed’
[17:39:37.148]   - Field: ‘version’
[17:39:37.148]   - Field: ‘result’
[17:39:37.148]   - Field: ‘asynchronous’
[17:39:37.148]   - Field: ‘calls’
[17:39:37.148]   - Field: ‘globals’
[17:39:37.149]   - Field: ‘stdout’
[17:39:37.149]   - Field: ‘earlySignal’
[17:39:37.149]   - Field: ‘lazy’
[17:39:37.149]   - Field: ‘state’
[17:39:37.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.149] - Launch lazy future ...
[17:39:37.150] Packages needed by the future expression (n = 0): <none>
[17:39:37.150] Packages needed by future strategies (n = 0): <none>
[17:39:37.151] {
[17:39:37.151]     {
[17:39:37.151]         {
[17:39:37.151]             ...future.startTime <- base::Sys.time()
[17:39:37.151]             {
[17:39:37.151]                 {
[17:39:37.151]                   {
[17:39:37.151]                     {
[17:39:37.151]                       base::local({
[17:39:37.151]                         has_future <- base::requireNamespace("future", 
[17:39:37.151]                           quietly = TRUE)
[17:39:37.151]                         if (has_future) {
[17:39:37.151]                           ns <- base::getNamespace("future")
[17:39:37.151]                           version <- ns[[".package"]][["version"]]
[17:39:37.151]                           if (is.null(version)) 
[17:39:37.151]                             version <- utils::packageVersion("future")
[17:39:37.151]                         }
[17:39:37.151]                         else {
[17:39:37.151]                           version <- NULL
[17:39:37.151]                         }
[17:39:37.151]                         if (!has_future || version < "1.8.0") {
[17:39:37.151]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.151]                             "", base::R.version$version.string), 
[17:39:37.151]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.151]                               "release", "version")], collapse = " "), 
[17:39:37.151]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.151]                             info)
[17:39:37.151]                           info <- base::paste(info, collapse = "; ")
[17:39:37.151]                           if (!has_future) {
[17:39:37.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.151]                               info)
[17:39:37.151]                           }
[17:39:37.151]                           else {
[17:39:37.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.151]                               info, version)
[17:39:37.151]                           }
[17:39:37.151]                           base::stop(msg)
[17:39:37.151]                         }
[17:39:37.151]                       })
[17:39:37.151]                     }
[17:39:37.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.151]                     base::options(mc.cores = 1L)
[17:39:37.151]                   }
[17:39:37.151]                   ...future.strategy.old <- future::plan("list")
[17:39:37.151]                   options(future.plan = NULL)
[17:39:37.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.151]                 }
[17:39:37.151]                 ...future.workdir <- getwd()
[17:39:37.151]             }
[17:39:37.151]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.151]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.151]         }
[17:39:37.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.151]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.151]             base::names(...future.oldOptions))
[17:39:37.151]     }
[17:39:37.151]     if (FALSE) {
[17:39:37.151]     }
[17:39:37.151]     else {
[17:39:37.151]         if (TRUE) {
[17:39:37.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.151]                 open = "w")
[17:39:37.151]         }
[17:39:37.151]         else {
[17:39:37.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.151]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.151]         }
[17:39:37.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.151]             base::sink(type = "output", split = FALSE)
[17:39:37.151]             base::close(...future.stdout)
[17:39:37.151]         }, add = TRUE)
[17:39:37.151]     }
[17:39:37.151]     ...future.frame <- base::sys.nframe()
[17:39:37.151]     ...future.conditions <- base::list()
[17:39:37.151]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.151]     if (FALSE) {
[17:39:37.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.151]     }
[17:39:37.151]     ...future.result <- base::tryCatch({
[17:39:37.151]         base::withCallingHandlers({
[17:39:37.151]             ...future.value <- base::withVisible(base::local({
[17:39:37.151]                 withCallingHandlers({
[17:39:37.151]                   NULL
[17:39:37.151]                 }, immediateCondition = function(cond) {
[17:39:37.151]                   save_rds <- function (object, pathname, ...) 
[17:39:37.151]                   {
[17:39:37.151]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.151]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.151]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.151]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.151]                         fi_tmp[["mtime"]])
[17:39:37.151]                     }
[17:39:37.151]                     tryCatch({
[17:39:37.151]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.151]                     }, error = function(ex) {
[17:39:37.151]                       msg <- conditionMessage(ex)
[17:39:37.151]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.151]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.151]                         fi_tmp[["mtime"]], msg)
[17:39:37.151]                       ex$message <- msg
[17:39:37.151]                       stop(ex)
[17:39:37.151]                     })
[17:39:37.151]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.151]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.151]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.151]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.151]                       fi <- file.info(pathname)
[17:39:37.151]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.151]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.151]                         fi[["size"]], fi[["mtime"]])
[17:39:37.151]                       stop(msg)
[17:39:37.151]                     }
[17:39:37.151]                     invisible(pathname)
[17:39:37.151]                   }
[17:39:37.151]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.151]                     rootPath = tempdir()) 
[17:39:37.151]                   {
[17:39:37.151]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.151]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.151]                       tmpdir = path, fileext = ".rds")
[17:39:37.151]                     save_rds(obj, file)
[17:39:37.151]                   }
[17:39:37.151]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.151]                   {
[17:39:37.151]                     inherits <- base::inherits
[17:39:37.151]                     invokeRestart <- base::invokeRestart
[17:39:37.151]                     is.null <- base::is.null
[17:39:37.151]                     muffled <- FALSE
[17:39:37.151]                     if (inherits(cond, "message")) {
[17:39:37.151]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.151]                       if (muffled) 
[17:39:37.151]                         invokeRestart("muffleMessage")
[17:39:37.151]                     }
[17:39:37.151]                     else if (inherits(cond, "warning")) {
[17:39:37.151]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.151]                       if (muffled) 
[17:39:37.151]                         invokeRestart("muffleWarning")
[17:39:37.151]                     }
[17:39:37.151]                     else if (inherits(cond, "condition")) {
[17:39:37.151]                       if (!is.null(pattern)) {
[17:39:37.151]                         computeRestarts <- base::computeRestarts
[17:39:37.151]                         grepl <- base::grepl
[17:39:37.151]                         restarts <- computeRestarts(cond)
[17:39:37.151]                         for (restart in restarts) {
[17:39:37.151]                           name <- restart$name
[17:39:37.151]                           if (is.null(name)) 
[17:39:37.151]                             next
[17:39:37.151]                           if (!grepl(pattern, name)) 
[17:39:37.151]                             next
[17:39:37.151]                           invokeRestart(restart)
[17:39:37.151]                           muffled <- TRUE
[17:39:37.151]                           break
[17:39:37.151]                         }
[17:39:37.151]                       }
[17:39:37.151]                     }
[17:39:37.151]                     invisible(muffled)
[17:39:37.151]                   }
[17:39:37.151]                   muffleCondition(cond)
[17:39:37.151]                 })
[17:39:37.151]             }))
[17:39:37.151]             future::FutureResult(value = ...future.value$value, 
[17:39:37.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.151]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.151]                     ...future.globalenv.names))
[17:39:37.151]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.151]         }, condition = base::local({
[17:39:37.151]             c <- base::c
[17:39:37.151]             inherits <- base::inherits
[17:39:37.151]             invokeRestart <- base::invokeRestart
[17:39:37.151]             length <- base::length
[17:39:37.151]             list <- base::list
[17:39:37.151]             seq.int <- base::seq.int
[17:39:37.151]             signalCondition <- base::signalCondition
[17:39:37.151]             sys.calls <- base::sys.calls
[17:39:37.151]             `[[` <- base::`[[`
[17:39:37.151]             `+` <- base::`+`
[17:39:37.151]             `<<-` <- base::`<<-`
[17:39:37.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.151]                   3L)]
[17:39:37.151]             }
[17:39:37.151]             function(cond) {
[17:39:37.151]                 is_error <- inherits(cond, "error")
[17:39:37.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.151]                   NULL)
[17:39:37.151]                 if (is_error) {
[17:39:37.151]                   sessionInformation <- function() {
[17:39:37.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.151]                       search = base::search(), system = base::Sys.info())
[17:39:37.151]                   }
[17:39:37.151]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.151]                     cond$call), session = sessionInformation(), 
[17:39:37.151]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.151]                   signalCondition(cond)
[17:39:37.151]                 }
[17:39:37.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.151]                 "immediateCondition"))) {
[17:39:37.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.151]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.151]                   if (TRUE && !signal) {
[17:39:37.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.151]                     {
[17:39:37.151]                       inherits <- base::inherits
[17:39:37.151]                       invokeRestart <- base::invokeRestart
[17:39:37.151]                       is.null <- base::is.null
[17:39:37.151]                       muffled <- FALSE
[17:39:37.151]                       if (inherits(cond, "message")) {
[17:39:37.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.151]                         if (muffled) 
[17:39:37.151]                           invokeRestart("muffleMessage")
[17:39:37.151]                       }
[17:39:37.151]                       else if (inherits(cond, "warning")) {
[17:39:37.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.151]                         if (muffled) 
[17:39:37.151]                           invokeRestart("muffleWarning")
[17:39:37.151]                       }
[17:39:37.151]                       else if (inherits(cond, "condition")) {
[17:39:37.151]                         if (!is.null(pattern)) {
[17:39:37.151]                           computeRestarts <- base::computeRestarts
[17:39:37.151]                           grepl <- base::grepl
[17:39:37.151]                           restarts <- computeRestarts(cond)
[17:39:37.151]                           for (restart in restarts) {
[17:39:37.151]                             name <- restart$name
[17:39:37.151]                             if (is.null(name)) 
[17:39:37.151]                               next
[17:39:37.151]                             if (!grepl(pattern, name)) 
[17:39:37.151]                               next
[17:39:37.151]                             invokeRestart(restart)
[17:39:37.151]                             muffled <- TRUE
[17:39:37.151]                             break
[17:39:37.151]                           }
[17:39:37.151]                         }
[17:39:37.151]                       }
[17:39:37.151]                       invisible(muffled)
[17:39:37.151]                     }
[17:39:37.151]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.151]                   }
[17:39:37.151]                 }
[17:39:37.151]                 else {
[17:39:37.151]                   if (TRUE) {
[17:39:37.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.151]                     {
[17:39:37.151]                       inherits <- base::inherits
[17:39:37.151]                       invokeRestart <- base::invokeRestart
[17:39:37.151]                       is.null <- base::is.null
[17:39:37.151]                       muffled <- FALSE
[17:39:37.151]                       if (inherits(cond, "message")) {
[17:39:37.151]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.151]                         if (muffled) 
[17:39:37.151]                           invokeRestart("muffleMessage")
[17:39:37.151]                       }
[17:39:37.151]                       else if (inherits(cond, "warning")) {
[17:39:37.151]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.151]                         if (muffled) 
[17:39:37.151]                           invokeRestart("muffleWarning")
[17:39:37.151]                       }
[17:39:37.151]                       else if (inherits(cond, "condition")) {
[17:39:37.151]                         if (!is.null(pattern)) {
[17:39:37.151]                           computeRestarts <- base::computeRestarts
[17:39:37.151]                           grepl <- base::grepl
[17:39:37.151]                           restarts <- computeRestarts(cond)
[17:39:37.151]                           for (restart in restarts) {
[17:39:37.151]                             name <- restart$name
[17:39:37.151]                             if (is.null(name)) 
[17:39:37.151]                               next
[17:39:37.151]                             if (!grepl(pattern, name)) 
[17:39:37.151]                               next
[17:39:37.151]                             invokeRestart(restart)
[17:39:37.151]                             muffled <- TRUE
[17:39:37.151]                             break
[17:39:37.151]                           }
[17:39:37.151]                         }
[17:39:37.151]                       }
[17:39:37.151]                       invisible(muffled)
[17:39:37.151]                     }
[17:39:37.151]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.151]                   }
[17:39:37.151]                 }
[17:39:37.151]             }
[17:39:37.151]         }))
[17:39:37.151]     }, error = function(ex) {
[17:39:37.151]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.151]                 ...future.rng), started = ...future.startTime, 
[17:39:37.151]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.151]             version = "1.8"), class = "FutureResult")
[17:39:37.151]     }, finally = {
[17:39:37.151]         if (!identical(...future.workdir, getwd())) 
[17:39:37.151]             setwd(...future.workdir)
[17:39:37.151]         {
[17:39:37.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.151]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.151]             }
[17:39:37.151]             base::options(...future.oldOptions)
[17:39:37.151]             if (.Platform$OS.type == "windows") {
[17:39:37.151]                 old_names <- names(...future.oldEnvVars)
[17:39:37.151]                 envs <- base::Sys.getenv()
[17:39:37.151]                 names <- names(envs)
[17:39:37.151]                 common <- intersect(names, old_names)
[17:39:37.151]                 added <- setdiff(names, old_names)
[17:39:37.151]                 removed <- setdiff(old_names, names)
[17:39:37.151]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.151]                   envs[common]]
[17:39:37.151]                 NAMES <- toupper(changed)
[17:39:37.151]                 args <- list()
[17:39:37.151]                 for (kk in seq_along(NAMES)) {
[17:39:37.151]                   name <- changed[[kk]]
[17:39:37.151]                   NAME <- NAMES[[kk]]
[17:39:37.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.151]                     next
[17:39:37.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.151]                 }
[17:39:37.151]                 NAMES <- toupper(added)
[17:39:37.151]                 for (kk in seq_along(NAMES)) {
[17:39:37.151]                   name <- added[[kk]]
[17:39:37.151]                   NAME <- NAMES[[kk]]
[17:39:37.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.151]                     next
[17:39:37.151]                   args[[name]] <- ""
[17:39:37.151]                 }
[17:39:37.151]                 NAMES <- toupper(removed)
[17:39:37.151]                 for (kk in seq_along(NAMES)) {
[17:39:37.151]                   name <- removed[[kk]]
[17:39:37.151]                   NAME <- NAMES[[kk]]
[17:39:37.151]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.151]                     next
[17:39:37.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.151]                 }
[17:39:37.151]                 if (length(args) > 0) 
[17:39:37.151]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.151]             }
[17:39:37.151]             else {
[17:39:37.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.151]             }
[17:39:37.151]             {
[17:39:37.151]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.151]                   0L) {
[17:39:37.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.151]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.151]                   base::options(opts)
[17:39:37.151]                 }
[17:39:37.151]                 {
[17:39:37.151]                   {
[17:39:37.151]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.151]                     NULL
[17:39:37.151]                   }
[17:39:37.151]                   options(future.plan = NULL)
[17:39:37.151]                   if (is.na(NA_character_)) 
[17:39:37.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.151]                     .init = FALSE)
[17:39:37.151]                 }
[17:39:37.151]             }
[17:39:37.151]         }
[17:39:37.151]     })
[17:39:37.151]     if (TRUE) {
[17:39:37.151]         base::sink(type = "output", split = FALSE)
[17:39:37.151]         if (TRUE) {
[17:39:37.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.151]         }
[17:39:37.151]         else {
[17:39:37.151]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.151]         }
[17:39:37.151]         base::close(...future.stdout)
[17:39:37.151]         ...future.stdout <- NULL
[17:39:37.151]     }
[17:39:37.151]     ...future.result$conditions <- ...future.conditions
[17:39:37.151]     ...future.result$finished <- base::Sys.time()
[17:39:37.151]     ...future.result
[17:39:37.151] }
[17:39:37.154] requestCore(): workers = 2
[17:39:37.157] MulticoreFuture started
[17:39:37.158] - Launch lazy future ... done
[17:39:37.158] run() for ‘MulticoreFuture’ ... done
[17:39:37.158] plan(): Setting new future strategy stack:
[17:39:37.159] getGlobalsAndPackages() ...
[17:39:37.159] Searching for globals...
[17:39:37.158] List of future strategies:
[17:39:37.158] 1. sequential:
[17:39:37.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.158]    - tweaked: FALSE
[17:39:37.158]    - call: NULL
[17:39:37.160] plan(): nbrOfWorkers() = 1
[17:39:37.160] - globals found: [1] ‘{’
[17:39:37.161] Searching for globals ... DONE
[17:39:37.161] Resolving globals: FALSE
[17:39:37.161] 
[17:39:37.161] 
[17:39:37.161] getGlobalsAndPackages() ... DONE
[17:39:37.162] plan(): Setting new future strategy stack:
[17:39:37.162] run() for ‘Future’ ...
[17:39:37.162] - state: ‘created’
[17:39:37.162] List of future strategies:
[17:39:37.162] 1. multicore:
[17:39:37.162]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.162]    - tweaked: FALSE
[17:39:37.162]    - call: plan(strategy)
[17:39:37.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.167] plan(): nbrOfWorkers() = 2
[17:39:37.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.168]   - Field: ‘label’
[17:39:37.168]   - Field: ‘local’
[17:39:37.168]   - Field: ‘owner’
[17:39:37.168]   - Field: ‘envir’
[17:39:37.168]   - Field: ‘workers’
[17:39:37.169]   - Field: ‘packages’
[17:39:37.169]   - Field: ‘gc’
[17:39:37.169]   - Field: ‘job’
[17:39:37.169]   - Field: ‘conditions’
[17:39:37.169]   - Field: ‘expr’
[17:39:37.169]   - Field: ‘uuid’
[17:39:37.169]   - Field: ‘seed’
[17:39:37.170]   - Field: ‘version’
[17:39:37.170]   - Field: ‘result’
[17:39:37.170]   - Field: ‘asynchronous’
[17:39:37.170]   - Field: ‘calls’
[17:39:37.170]   - Field: ‘globals’
[17:39:37.170]   - Field: ‘stdout’
[17:39:37.170]   - Field: ‘earlySignal’
[17:39:37.171]   - Field: ‘lazy’
[17:39:37.171]   - Field: ‘state’
[17:39:37.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.171] - Launch lazy future ...
[17:39:37.171] Packages needed by the future expression (n = 0): <none>
[17:39:37.172] Packages needed by future strategies (n = 0): <none>
[17:39:37.172] {
[17:39:37.172]     {
[17:39:37.172]         {
[17:39:37.172]             ...future.startTime <- base::Sys.time()
[17:39:37.172]             {
[17:39:37.172]                 {
[17:39:37.172]                   {
[17:39:37.172]                     {
[17:39:37.172]                       base::local({
[17:39:37.172]                         has_future <- base::requireNamespace("future", 
[17:39:37.172]                           quietly = TRUE)
[17:39:37.172]                         if (has_future) {
[17:39:37.172]                           ns <- base::getNamespace("future")
[17:39:37.172]                           version <- ns[[".package"]][["version"]]
[17:39:37.172]                           if (is.null(version)) 
[17:39:37.172]                             version <- utils::packageVersion("future")
[17:39:37.172]                         }
[17:39:37.172]                         else {
[17:39:37.172]                           version <- NULL
[17:39:37.172]                         }
[17:39:37.172]                         if (!has_future || version < "1.8.0") {
[17:39:37.172]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.172]                             "", base::R.version$version.string), 
[17:39:37.172]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.172]                               "release", "version")], collapse = " "), 
[17:39:37.172]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.172]                             info)
[17:39:37.172]                           info <- base::paste(info, collapse = "; ")
[17:39:37.172]                           if (!has_future) {
[17:39:37.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.172]                               info)
[17:39:37.172]                           }
[17:39:37.172]                           else {
[17:39:37.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.172]                               info, version)
[17:39:37.172]                           }
[17:39:37.172]                           base::stop(msg)
[17:39:37.172]                         }
[17:39:37.172]                       })
[17:39:37.172]                     }
[17:39:37.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.172]                     base::options(mc.cores = 1L)
[17:39:37.172]                   }
[17:39:37.172]                   ...future.strategy.old <- future::plan("list")
[17:39:37.172]                   options(future.plan = NULL)
[17:39:37.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.172]                 }
[17:39:37.172]                 ...future.workdir <- getwd()
[17:39:37.172]             }
[17:39:37.172]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.172]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.172]         }
[17:39:37.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.172]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.172]             base::names(...future.oldOptions))
[17:39:37.172]     }
[17:39:37.172]     if (FALSE) {
[17:39:37.172]     }
[17:39:37.172]     else {
[17:39:37.172]         if (TRUE) {
[17:39:37.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.172]                 open = "w")
[17:39:37.172]         }
[17:39:37.172]         else {
[17:39:37.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.172]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.172]         }
[17:39:37.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.172]             base::sink(type = "output", split = FALSE)
[17:39:37.172]             base::close(...future.stdout)
[17:39:37.172]         }, add = TRUE)
[17:39:37.172]     }
[17:39:37.172]     ...future.frame <- base::sys.nframe()
[17:39:37.172]     ...future.conditions <- base::list()
[17:39:37.172]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.172]     if (FALSE) {
[17:39:37.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.172]     }
[17:39:37.172]     ...future.result <- base::tryCatch({
[17:39:37.172]         base::withCallingHandlers({
[17:39:37.172]             ...future.value <- base::withVisible(base::local({
[17:39:37.172]                 withCallingHandlers({
[17:39:37.172]                   {
[17:39:37.172]                     4
[17:39:37.172]                   }
[17:39:37.172]                 }, immediateCondition = function(cond) {
[17:39:37.172]                   save_rds <- function (object, pathname, ...) 
[17:39:37.172]                   {
[17:39:37.172]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.172]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.172]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.172]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.172]                         fi_tmp[["mtime"]])
[17:39:37.172]                     }
[17:39:37.172]                     tryCatch({
[17:39:37.172]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.172]                     }, error = function(ex) {
[17:39:37.172]                       msg <- conditionMessage(ex)
[17:39:37.172]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.172]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.172]                         fi_tmp[["mtime"]], msg)
[17:39:37.172]                       ex$message <- msg
[17:39:37.172]                       stop(ex)
[17:39:37.172]                     })
[17:39:37.172]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.172]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.172]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.172]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.172]                       fi <- file.info(pathname)
[17:39:37.172]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.172]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.172]                         fi[["size"]], fi[["mtime"]])
[17:39:37.172]                       stop(msg)
[17:39:37.172]                     }
[17:39:37.172]                     invisible(pathname)
[17:39:37.172]                   }
[17:39:37.172]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.172]                     rootPath = tempdir()) 
[17:39:37.172]                   {
[17:39:37.172]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.172]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.172]                       tmpdir = path, fileext = ".rds")
[17:39:37.172]                     save_rds(obj, file)
[17:39:37.172]                   }
[17:39:37.172]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.172]                   {
[17:39:37.172]                     inherits <- base::inherits
[17:39:37.172]                     invokeRestart <- base::invokeRestart
[17:39:37.172]                     is.null <- base::is.null
[17:39:37.172]                     muffled <- FALSE
[17:39:37.172]                     if (inherits(cond, "message")) {
[17:39:37.172]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.172]                       if (muffled) 
[17:39:37.172]                         invokeRestart("muffleMessage")
[17:39:37.172]                     }
[17:39:37.172]                     else if (inherits(cond, "warning")) {
[17:39:37.172]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.172]                       if (muffled) 
[17:39:37.172]                         invokeRestart("muffleWarning")
[17:39:37.172]                     }
[17:39:37.172]                     else if (inherits(cond, "condition")) {
[17:39:37.172]                       if (!is.null(pattern)) {
[17:39:37.172]                         computeRestarts <- base::computeRestarts
[17:39:37.172]                         grepl <- base::grepl
[17:39:37.172]                         restarts <- computeRestarts(cond)
[17:39:37.172]                         for (restart in restarts) {
[17:39:37.172]                           name <- restart$name
[17:39:37.172]                           if (is.null(name)) 
[17:39:37.172]                             next
[17:39:37.172]                           if (!grepl(pattern, name)) 
[17:39:37.172]                             next
[17:39:37.172]                           invokeRestart(restart)
[17:39:37.172]                           muffled <- TRUE
[17:39:37.172]                           break
[17:39:37.172]                         }
[17:39:37.172]                       }
[17:39:37.172]                     }
[17:39:37.172]                     invisible(muffled)
[17:39:37.172]                   }
[17:39:37.172]                   muffleCondition(cond)
[17:39:37.172]                 })
[17:39:37.172]             }))
[17:39:37.172]             future::FutureResult(value = ...future.value$value, 
[17:39:37.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.172]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.172]                     ...future.globalenv.names))
[17:39:37.172]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.172]         }, condition = base::local({
[17:39:37.172]             c <- base::c
[17:39:37.172]             inherits <- base::inherits
[17:39:37.172]             invokeRestart <- base::invokeRestart
[17:39:37.172]             length <- base::length
[17:39:37.172]             list <- base::list
[17:39:37.172]             seq.int <- base::seq.int
[17:39:37.172]             signalCondition <- base::signalCondition
[17:39:37.172]             sys.calls <- base::sys.calls
[17:39:37.172]             `[[` <- base::`[[`
[17:39:37.172]             `+` <- base::`+`
[17:39:37.172]             `<<-` <- base::`<<-`
[17:39:37.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.172]                   3L)]
[17:39:37.172]             }
[17:39:37.172]             function(cond) {
[17:39:37.172]                 is_error <- inherits(cond, "error")
[17:39:37.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.172]                   NULL)
[17:39:37.172]                 if (is_error) {
[17:39:37.172]                   sessionInformation <- function() {
[17:39:37.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.172]                       search = base::search(), system = base::Sys.info())
[17:39:37.172]                   }
[17:39:37.172]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.172]                     cond$call), session = sessionInformation(), 
[17:39:37.172]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.172]                   signalCondition(cond)
[17:39:37.172]                 }
[17:39:37.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.172]                 "immediateCondition"))) {
[17:39:37.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.172]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.172]                   if (TRUE && !signal) {
[17:39:37.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.172]                     {
[17:39:37.172]                       inherits <- base::inherits
[17:39:37.172]                       invokeRestart <- base::invokeRestart
[17:39:37.172]                       is.null <- base::is.null
[17:39:37.172]                       muffled <- FALSE
[17:39:37.172]                       if (inherits(cond, "message")) {
[17:39:37.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.172]                         if (muffled) 
[17:39:37.172]                           invokeRestart("muffleMessage")
[17:39:37.172]                       }
[17:39:37.172]                       else if (inherits(cond, "warning")) {
[17:39:37.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.172]                         if (muffled) 
[17:39:37.172]                           invokeRestart("muffleWarning")
[17:39:37.172]                       }
[17:39:37.172]                       else if (inherits(cond, "condition")) {
[17:39:37.172]                         if (!is.null(pattern)) {
[17:39:37.172]                           computeRestarts <- base::computeRestarts
[17:39:37.172]                           grepl <- base::grepl
[17:39:37.172]                           restarts <- computeRestarts(cond)
[17:39:37.172]                           for (restart in restarts) {
[17:39:37.172]                             name <- restart$name
[17:39:37.172]                             if (is.null(name)) 
[17:39:37.172]                               next
[17:39:37.172]                             if (!grepl(pattern, name)) 
[17:39:37.172]                               next
[17:39:37.172]                             invokeRestart(restart)
[17:39:37.172]                             muffled <- TRUE
[17:39:37.172]                             break
[17:39:37.172]                           }
[17:39:37.172]                         }
[17:39:37.172]                       }
[17:39:37.172]                       invisible(muffled)
[17:39:37.172]                     }
[17:39:37.172]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.172]                   }
[17:39:37.172]                 }
[17:39:37.172]                 else {
[17:39:37.172]                   if (TRUE) {
[17:39:37.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.172]                     {
[17:39:37.172]                       inherits <- base::inherits
[17:39:37.172]                       invokeRestart <- base::invokeRestart
[17:39:37.172]                       is.null <- base::is.null
[17:39:37.172]                       muffled <- FALSE
[17:39:37.172]                       if (inherits(cond, "message")) {
[17:39:37.172]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.172]                         if (muffled) 
[17:39:37.172]                           invokeRestart("muffleMessage")
[17:39:37.172]                       }
[17:39:37.172]                       else if (inherits(cond, "warning")) {
[17:39:37.172]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.172]                         if (muffled) 
[17:39:37.172]                           invokeRestart("muffleWarning")
[17:39:37.172]                       }
[17:39:37.172]                       else if (inherits(cond, "condition")) {
[17:39:37.172]                         if (!is.null(pattern)) {
[17:39:37.172]                           computeRestarts <- base::computeRestarts
[17:39:37.172]                           grepl <- base::grepl
[17:39:37.172]                           restarts <- computeRestarts(cond)
[17:39:37.172]                           for (restart in restarts) {
[17:39:37.172]                             name <- restart$name
[17:39:37.172]                             if (is.null(name)) 
[17:39:37.172]                               next
[17:39:37.172]                             if (!grepl(pattern, name)) 
[17:39:37.172]                               next
[17:39:37.172]                             invokeRestart(restart)
[17:39:37.172]                             muffled <- TRUE
[17:39:37.172]                             break
[17:39:37.172]                           }
[17:39:37.172]                         }
[17:39:37.172]                       }
[17:39:37.172]                       invisible(muffled)
[17:39:37.172]                     }
[17:39:37.172]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.172]                   }
[17:39:37.172]                 }
[17:39:37.172]             }
[17:39:37.172]         }))
[17:39:37.172]     }, error = function(ex) {
[17:39:37.172]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.172]                 ...future.rng), started = ...future.startTime, 
[17:39:37.172]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.172]             version = "1.8"), class = "FutureResult")
[17:39:37.172]     }, finally = {
[17:39:37.172]         if (!identical(...future.workdir, getwd())) 
[17:39:37.172]             setwd(...future.workdir)
[17:39:37.172]         {
[17:39:37.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.172]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.172]             }
[17:39:37.172]             base::options(...future.oldOptions)
[17:39:37.172]             if (.Platform$OS.type == "windows") {
[17:39:37.172]                 old_names <- names(...future.oldEnvVars)
[17:39:37.172]                 envs <- base::Sys.getenv()
[17:39:37.172]                 names <- names(envs)
[17:39:37.172]                 common <- intersect(names, old_names)
[17:39:37.172]                 added <- setdiff(names, old_names)
[17:39:37.172]                 removed <- setdiff(old_names, names)
[17:39:37.172]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.172]                   envs[common]]
[17:39:37.172]                 NAMES <- toupper(changed)
[17:39:37.172]                 args <- list()
[17:39:37.172]                 for (kk in seq_along(NAMES)) {
[17:39:37.172]                   name <- changed[[kk]]
[17:39:37.172]                   NAME <- NAMES[[kk]]
[17:39:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.172]                     next
[17:39:37.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.172]                 }
[17:39:37.172]                 NAMES <- toupper(added)
[17:39:37.172]                 for (kk in seq_along(NAMES)) {
[17:39:37.172]                   name <- added[[kk]]
[17:39:37.172]                   NAME <- NAMES[[kk]]
[17:39:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.172]                     next
[17:39:37.172]                   args[[name]] <- ""
[17:39:37.172]                 }
[17:39:37.172]                 NAMES <- toupper(removed)
[17:39:37.172]                 for (kk in seq_along(NAMES)) {
[17:39:37.172]                   name <- removed[[kk]]
[17:39:37.172]                   NAME <- NAMES[[kk]]
[17:39:37.172]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.172]                     next
[17:39:37.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.172]                 }
[17:39:37.172]                 if (length(args) > 0) 
[17:39:37.172]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.172]             }
[17:39:37.172]             else {
[17:39:37.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.172]             }
[17:39:37.172]             {
[17:39:37.172]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.172]                   0L) {
[17:39:37.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.172]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.172]                   base::options(opts)
[17:39:37.172]                 }
[17:39:37.172]                 {
[17:39:37.172]                   {
[17:39:37.172]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.172]                     NULL
[17:39:37.172]                   }
[17:39:37.172]                   options(future.plan = NULL)
[17:39:37.172]                   if (is.na(NA_character_)) 
[17:39:37.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.172]                     .init = FALSE)
[17:39:37.172]                 }
[17:39:37.172]             }
[17:39:37.172]         }
[17:39:37.172]     })
[17:39:37.172]     if (TRUE) {
[17:39:37.172]         base::sink(type = "output", split = FALSE)
[17:39:37.172]         if (TRUE) {
[17:39:37.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.172]         }
[17:39:37.172]         else {
[17:39:37.172]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.172]         }
[17:39:37.172]         base::close(...future.stdout)
[17:39:37.172]         ...future.stdout <- NULL
[17:39:37.172]     }
[17:39:37.172]     ...future.result$conditions <- ...future.conditions
[17:39:37.172]     ...future.result$finished <- base::Sys.time()
[17:39:37.172]     ...future.result
[17:39:37.172] }
[17:39:37.176] requestCore(): workers = 2
[17:39:37.176] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:37.187] result() for MulticoreFuture ...
[17:39:37.188] result() for MulticoreFuture ...
[17:39:37.188] result() for MulticoreFuture ... done
[17:39:37.188] result() for MulticoreFuture ... done
[17:39:37.188] result() for MulticoreFuture ...
[17:39:37.189] result() for MulticoreFuture ... done
[17:39:37.192] MulticoreFuture started
[17:39:37.193] - Launch lazy future ... done
[17:39:37.193] run() for ‘MulticoreFuture’ ... done
[17:39:37.193] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55adf146e710> 
[17:39:37.193] List of future strategies:
[17:39:37.193] 1. sequential:
[17:39:37.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.193]    - tweaked: FALSE
[17:39:37.193]    - call: NULL
[17:39:37.195] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55adf207d4b0> 
[17:39:37.197] plan(): Setting new future strategy stack:
[17:39:37.197] List of future strategies:
[17:39:37.197] 1. multicore:
[17:39:37.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.197]    - tweaked: FALSE
[17:39:37.197]    - call: plan(strategy)
[17:39:37.202] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:37.205] resolve() on list environment ...
[17:39:37.205]  recursive: 0
[17:39:37.206]  length: 6
[17:39:37.206]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:37.206] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.207] - nx: 6
[17:39:37.207] - relay: TRUE
[17:39:37.207] - stdout: TRUE
[17:39:37.207] - signal: TRUE
[17:39:37.207] - resignal: FALSE
[17:39:37.207] - force: TRUE
[17:39:37.207] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.207] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.208]  - until=2
[17:39:37.208]  - relaying element #2
[17:39:37.208] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.208] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.208] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.208]  length: 5 (resolved future 1)
[17:39:37.208] Future #2
[17:39:37.209] result() for MulticoreFuture ...
[17:39:37.217] result() for MulticoreFuture ... done
[17:39:37.217] result() for MulticoreFuture ...
[17:39:37.218] result() for MulticoreFuture ... done
[17:39:37.218] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:37.219] - nx: 6
[17:39:37.219] - relay: TRUE
[17:39:37.219] - stdout: TRUE
[17:39:37.219] - signal: TRUE
[17:39:37.220] - resignal: FALSE
[17:39:37.220] - force: TRUE
[17:39:37.220] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.220] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.220]  - until=2
[17:39:37.221]  - relaying element #2
[17:39:37.221] result() for MulticoreFuture ...
[17:39:37.221] result() for MulticoreFuture ... done
[17:39:37.221] result() for MulticoreFuture ...
[17:39:37.221] result() for MulticoreFuture ... done
[17:39:37.221] result() for MulticoreFuture ...
[17:39:37.222] result() for MulticoreFuture ... done
[17:39:37.222] result() for MulticoreFuture ...
[17:39:37.222] result() for MulticoreFuture ... done
[17:39:37.222] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.222] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.222] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:37.222]  length: 4 (resolved future 2)
[17:39:37.223] Future #3
[17:39:37.223] result() for MulticoreFuture ...
[17:39:37.224] result() for MulticoreFuture ...
[17:39:37.224] result() for MulticoreFuture ... done
[17:39:37.224] result() for MulticoreFuture ... done
[17:39:37.224] result() for MulticoreFuture ...
[17:39:37.224] result() for MulticoreFuture ... done
[17:39:37.225] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:37.225] - nx: 6
[17:39:37.225] - relay: TRUE
[17:39:37.225] - stdout: TRUE
[17:39:37.225] - signal: TRUE
[17:39:37.225] - resignal: FALSE
[17:39:37.225] - force: TRUE
[17:39:37.225] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.226] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.226]  - until=3
[17:39:37.226]  - relaying element #3
[17:39:37.226] result() for MulticoreFuture ...
[17:39:37.226] result() for MulticoreFuture ... done
[17:39:37.226] result() for MulticoreFuture ...
[17:39:37.226] result() for MulticoreFuture ... done
[17:39:37.227] result() for MulticoreFuture ...
[17:39:37.227] result() for MulticoreFuture ... done
[17:39:37.227] result() for MulticoreFuture ...
[17:39:37.227] result() for MulticoreFuture ... done
[17:39:37.227] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.227] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.227] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:37.228]  length: 3 (resolved future 3)
[17:39:37.228] Future #4
[17:39:37.228] result() for MulticoreFuture ...
[17:39:37.229] result() for MulticoreFuture ...
[17:39:37.229] result() for MulticoreFuture ... done
[17:39:37.229] result() for MulticoreFuture ... done
[17:39:37.229] result() for MulticoreFuture ...
[17:39:37.229] result() for MulticoreFuture ... done
[17:39:37.230] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:37.230] - nx: 6
[17:39:37.230] - relay: TRUE
[17:39:37.230] - stdout: TRUE
[17:39:37.230] - signal: TRUE
[17:39:37.230] - resignal: FALSE
[17:39:37.231] - force: TRUE
[17:39:37.231] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.231] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.231]  - until=4
[17:39:37.231]  - relaying element #4
[17:39:37.231] result() for MulticoreFuture ...
[17:39:37.232] result() for MulticoreFuture ... done
[17:39:37.232] result() for MulticoreFuture ...
[17:39:37.232] result() for MulticoreFuture ... done
[17:39:37.232] result() for MulticoreFuture ...
[17:39:37.232] result() for MulticoreFuture ... done
[17:39:37.232] result() for MulticoreFuture ...
[17:39:37.232] result() for MulticoreFuture ... done
[17:39:37.233] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.233] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.233] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:37.233]  length: 2 (resolved future 4)
[17:39:37.233] signalConditionsASAP(NULL, pos=5) ...
[17:39:37.233] - nx: 6
[17:39:37.233] - relay: TRUE
[17:39:37.234] - stdout: TRUE
[17:39:37.234] - signal: TRUE
[17:39:37.234] - resignal: FALSE
[17:39:37.234] - force: TRUE
[17:39:37.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.234] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.234]  - until=6
[17:39:37.234]  - relaying element #6
[17:39:37.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.234] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.235] signalConditionsASAP(NULL, pos=5) ... done
[17:39:37.235]  length: 1 (resolved future 5)
[17:39:37.235] signalConditionsASAP(numeric, pos=6) ...
[17:39:37.235] - nx: 6
[17:39:37.235] - relay: TRUE
[17:39:37.235] - stdout: TRUE
[17:39:37.235] - signal: TRUE
[17:39:37.235] - resignal: FALSE
[17:39:37.235] - force: TRUE
[17:39:37.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.235] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.236]  - until=6
[17:39:37.236] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.236] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.236] signalConditionsASAP(numeric, pos=6) ... done
[17:39:37.236]  length: 0 (resolved future 6)
[17:39:37.236] Relaying remaining futures
[17:39:37.236] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.236] - nx: 6
[17:39:37.236] - relay: TRUE
[17:39:37.237] - stdout: TRUE
[17:39:37.237] - signal: TRUE
[17:39:37.237] - resignal: FALSE
[17:39:37.237] - force: TRUE
[17:39:37.237] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.237] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:37.237] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.237] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.237] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.237] resolve() on list environment ... DONE
[17:39:37.238] result() for MulticoreFuture ...
[17:39:37.238] result() for MulticoreFuture ... done
[17:39:37.238] result() for MulticoreFuture ...
[17:39:37.238] result() for MulticoreFuture ... done
[17:39:37.238] result() for MulticoreFuture ...
[17:39:37.238] result() for MulticoreFuture ... done
[17:39:37.238] result() for MulticoreFuture ...
[17:39:37.238] result() for MulticoreFuture ... done
[17:39:37.239] result() for MulticoreFuture ...
[17:39:37.239] result() for MulticoreFuture ... done
[17:39:37.239] result() for MulticoreFuture ...
[17:39:37.239] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf21cec48> 
Dimensions: c(1, 6)
[17:39:37.240] getGlobalsAndPackages() ...
[17:39:37.240] Searching for globals...
[17:39:37.240] 
[17:39:37.240] Searching for globals ... DONE
[17:39:37.240] - globals: [0] <none>
[17:39:37.241] getGlobalsAndPackages() ... DONE
[17:39:37.241] run() for ‘Future’ ...
[17:39:37.241] - state: ‘created’
[17:39:37.241] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.246] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.246]   - Field: ‘label’
[17:39:37.246]   - Field: ‘local’
[17:39:37.246]   - Field: ‘owner’
[17:39:37.247]   - Field: ‘envir’
[17:39:37.247]   - Field: ‘workers’
[17:39:37.247]   - Field: ‘packages’
[17:39:37.247]   - Field: ‘gc’
[17:39:37.247]   - Field: ‘job’
[17:39:37.247]   - Field: ‘conditions’
[17:39:37.248]   - Field: ‘expr’
[17:39:37.248]   - Field: ‘uuid’
[17:39:37.248]   - Field: ‘seed’
[17:39:37.248]   - Field: ‘version’
[17:39:37.248]   - Field: ‘result’
[17:39:37.248]   - Field: ‘asynchronous’
[17:39:37.248]   - Field: ‘calls’
[17:39:37.249]   - Field: ‘globals’
[17:39:37.249]   - Field: ‘stdout’
[17:39:37.249]   - Field: ‘earlySignal’
[17:39:37.249]   - Field: ‘lazy’
[17:39:37.249]   - Field: ‘state’
[17:39:37.249] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.249] - Launch lazy future ...
[17:39:37.250] Packages needed by the future expression (n = 0): <none>
[17:39:37.250] Packages needed by future strategies (n = 0): <none>
[17:39:37.251] {
[17:39:37.251]     {
[17:39:37.251]         {
[17:39:37.251]             ...future.startTime <- base::Sys.time()
[17:39:37.251]             {
[17:39:37.251]                 {
[17:39:37.251]                   {
[17:39:37.251]                     {
[17:39:37.251]                       base::local({
[17:39:37.251]                         has_future <- base::requireNamespace("future", 
[17:39:37.251]                           quietly = TRUE)
[17:39:37.251]                         if (has_future) {
[17:39:37.251]                           ns <- base::getNamespace("future")
[17:39:37.251]                           version <- ns[[".package"]][["version"]]
[17:39:37.251]                           if (is.null(version)) 
[17:39:37.251]                             version <- utils::packageVersion("future")
[17:39:37.251]                         }
[17:39:37.251]                         else {
[17:39:37.251]                           version <- NULL
[17:39:37.251]                         }
[17:39:37.251]                         if (!has_future || version < "1.8.0") {
[17:39:37.251]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.251]                             "", base::R.version$version.string), 
[17:39:37.251]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.251]                               "release", "version")], collapse = " "), 
[17:39:37.251]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.251]                             info)
[17:39:37.251]                           info <- base::paste(info, collapse = "; ")
[17:39:37.251]                           if (!has_future) {
[17:39:37.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.251]                               info)
[17:39:37.251]                           }
[17:39:37.251]                           else {
[17:39:37.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.251]                               info, version)
[17:39:37.251]                           }
[17:39:37.251]                           base::stop(msg)
[17:39:37.251]                         }
[17:39:37.251]                       })
[17:39:37.251]                     }
[17:39:37.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.251]                     base::options(mc.cores = 1L)
[17:39:37.251]                   }
[17:39:37.251]                   ...future.strategy.old <- future::plan("list")
[17:39:37.251]                   options(future.plan = NULL)
[17:39:37.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.251]                 }
[17:39:37.251]                 ...future.workdir <- getwd()
[17:39:37.251]             }
[17:39:37.251]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.251]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.251]         }
[17:39:37.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.251]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.251]             base::names(...future.oldOptions))
[17:39:37.251]     }
[17:39:37.251]     if (FALSE) {
[17:39:37.251]     }
[17:39:37.251]     else {
[17:39:37.251]         if (TRUE) {
[17:39:37.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.251]                 open = "w")
[17:39:37.251]         }
[17:39:37.251]         else {
[17:39:37.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.251]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.251]         }
[17:39:37.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.251]             base::sink(type = "output", split = FALSE)
[17:39:37.251]             base::close(...future.stdout)
[17:39:37.251]         }, add = TRUE)
[17:39:37.251]     }
[17:39:37.251]     ...future.frame <- base::sys.nframe()
[17:39:37.251]     ...future.conditions <- base::list()
[17:39:37.251]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.251]     if (FALSE) {
[17:39:37.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.251]     }
[17:39:37.251]     ...future.result <- base::tryCatch({
[17:39:37.251]         base::withCallingHandlers({
[17:39:37.251]             ...future.value <- base::withVisible(base::local({
[17:39:37.251]                 withCallingHandlers({
[17:39:37.251]                   2
[17:39:37.251]                 }, immediateCondition = function(cond) {
[17:39:37.251]                   save_rds <- function (object, pathname, ...) 
[17:39:37.251]                   {
[17:39:37.251]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.251]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.251]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.251]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.251]                         fi_tmp[["mtime"]])
[17:39:37.251]                     }
[17:39:37.251]                     tryCatch({
[17:39:37.251]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.251]                     }, error = function(ex) {
[17:39:37.251]                       msg <- conditionMessage(ex)
[17:39:37.251]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.251]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.251]                         fi_tmp[["mtime"]], msg)
[17:39:37.251]                       ex$message <- msg
[17:39:37.251]                       stop(ex)
[17:39:37.251]                     })
[17:39:37.251]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.251]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.251]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.251]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.251]                       fi <- file.info(pathname)
[17:39:37.251]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.251]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.251]                         fi[["size"]], fi[["mtime"]])
[17:39:37.251]                       stop(msg)
[17:39:37.251]                     }
[17:39:37.251]                     invisible(pathname)
[17:39:37.251]                   }
[17:39:37.251]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.251]                     rootPath = tempdir()) 
[17:39:37.251]                   {
[17:39:37.251]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.251]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.251]                       tmpdir = path, fileext = ".rds")
[17:39:37.251]                     save_rds(obj, file)
[17:39:37.251]                   }
[17:39:37.251]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.251]                   {
[17:39:37.251]                     inherits <- base::inherits
[17:39:37.251]                     invokeRestart <- base::invokeRestart
[17:39:37.251]                     is.null <- base::is.null
[17:39:37.251]                     muffled <- FALSE
[17:39:37.251]                     if (inherits(cond, "message")) {
[17:39:37.251]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.251]                       if (muffled) 
[17:39:37.251]                         invokeRestart("muffleMessage")
[17:39:37.251]                     }
[17:39:37.251]                     else if (inherits(cond, "warning")) {
[17:39:37.251]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.251]                       if (muffled) 
[17:39:37.251]                         invokeRestart("muffleWarning")
[17:39:37.251]                     }
[17:39:37.251]                     else if (inherits(cond, "condition")) {
[17:39:37.251]                       if (!is.null(pattern)) {
[17:39:37.251]                         computeRestarts <- base::computeRestarts
[17:39:37.251]                         grepl <- base::grepl
[17:39:37.251]                         restarts <- computeRestarts(cond)
[17:39:37.251]                         for (restart in restarts) {
[17:39:37.251]                           name <- restart$name
[17:39:37.251]                           if (is.null(name)) 
[17:39:37.251]                             next
[17:39:37.251]                           if (!grepl(pattern, name)) 
[17:39:37.251]                             next
[17:39:37.251]                           invokeRestart(restart)
[17:39:37.251]                           muffled <- TRUE
[17:39:37.251]                           break
[17:39:37.251]                         }
[17:39:37.251]                       }
[17:39:37.251]                     }
[17:39:37.251]                     invisible(muffled)
[17:39:37.251]                   }
[17:39:37.251]                   muffleCondition(cond)
[17:39:37.251]                 })
[17:39:37.251]             }))
[17:39:37.251]             future::FutureResult(value = ...future.value$value, 
[17:39:37.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.251]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.251]                     ...future.globalenv.names))
[17:39:37.251]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.251]         }, condition = base::local({
[17:39:37.251]             c <- base::c
[17:39:37.251]             inherits <- base::inherits
[17:39:37.251]             invokeRestart <- base::invokeRestart
[17:39:37.251]             length <- base::length
[17:39:37.251]             list <- base::list
[17:39:37.251]             seq.int <- base::seq.int
[17:39:37.251]             signalCondition <- base::signalCondition
[17:39:37.251]             sys.calls <- base::sys.calls
[17:39:37.251]             `[[` <- base::`[[`
[17:39:37.251]             `+` <- base::`+`
[17:39:37.251]             `<<-` <- base::`<<-`
[17:39:37.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.251]                   3L)]
[17:39:37.251]             }
[17:39:37.251]             function(cond) {
[17:39:37.251]                 is_error <- inherits(cond, "error")
[17:39:37.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.251]                   NULL)
[17:39:37.251]                 if (is_error) {
[17:39:37.251]                   sessionInformation <- function() {
[17:39:37.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.251]                       search = base::search(), system = base::Sys.info())
[17:39:37.251]                   }
[17:39:37.251]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.251]                     cond$call), session = sessionInformation(), 
[17:39:37.251]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.251]                   signalCondition(cond)
[17:39:37.251]                 }
[17:39:37.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.251]                 "immediateCondition"))) {
[17:39:37.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.251]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.251]                   if (TRUE && !signal) {
[17:39:37.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.251]                     {
[17:39:37.251]                       inherits <- base::inherits
[17:39:37.251]                       invokeRestart <- base::invokeRestart
[17:39:37.251]                       is.null <- base::is.null
[17:39:37.251]                       muffled <- FALSE
[17:39:37.251]                       if (inherits(cond, "message")) {
[17:39:37.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.251]                         if (muffled) 
[17:39:37.251]                           invokeRestart("muffleMessage")
[17:39:37.251]                       }
[17:39:37.251]                       else if (inherits(cond, "warning")) {
[17:39:37.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.251]                         if (muffled) 
[17:39:37.251]                           invokeRestart("muffleWarning")
[17:39:37.251]                       }
[17:39:37.251]                       else if (inherits(cond, "condition")) {
[17:39:37.251]                         if (!is.null(pattern)) {
[17:39:37.251]                           computeRestarts <- base::computeRestarts
[17:39:37.251]                           grepl <- base::grepl
[17:39:37.251]                           restarts <- computeRestarts(cond)
[17:39:37.251]                           for (restart in restarts) {
[17:39:37.251]                             name <- restart$name
[17:39:37.251]                             if (is.null(name)) 
[17:39:37.251]                               next
[17:39:37.251]                             if (!grepl(pattern, name)) 
[17:39:37.251]                               next
[17:39:37.251]                             invokeRestart(restart)
[17:39:37.251]                             muffled <- TRUE
[17:39:37.251]                             break
[17:39:37.251]                           }
[17:39:37.251]                         }
[17:39:37.251]                       }
[17:39:37.251]                       invisible(muffled)
[17:39:37.251]                     }
[17:39:37.251]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.251]                   }
[17:39:37.251]                 }
[17:39:37.251]                 else {
[17:39:37.251]                   if (TRUE) {
[17:39:37.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.251]                     {
[17:39:37.251]                       inherits <- base::inherits
[17:39:37.251]                       invokeRestart <- base::invokeRestart
[17:39:37.251]                       is.null <- base::is.null
[17:39:37.251]                       muffled <- FALSE
[17:39:37.251]                       if (inherits(cond, "message")) {
[17:39:37.251]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.251]                         if (muffled) 
[17:39:37.251]                           invokeRestart("muffleMessage")
[17:39:37.251]                       }
[17:39:37.251]                       else if (inherits(cond, "warning")) {
[17:39:37.251]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.251]                         if (muffled) 
[17:39:37.251]                           invokeRestart("muffleWarning")
[17:39:37.251]                       }
[17:39:37.251]                       else if (inherits(cond, "condition")) {
[17:39:37.251]                         if (!is.null(pattern)) {
[17:39:37.251]                           computeRestarts <- base::computeRestarts
[17:39:37.251]                           grepl <- base::grepl
[17:39:37.251]                           restarts <- computeRestarts(cond)
[17:39:37.251]                           for (restart in restarts) {
[17:39:37.251]                             name <- restart$name
[17:39:37.251]                             if (is.null(name)) 
[17:39:37.251]                               next
[17:39:37.251]                             if (!grepl(pattern, name)) 
[17:39:37.251]                               next
[17:39:37.251]                             invokeRestart(restart)
[17:39:37.251]                             muffled <- TRUE
[17:39:37.251]                             break
[17:39:37.251]                           }
[17:39:37.251]                         }
[17:39:37.251]                       }
[17:39:37.251]                       invisible(muffled)
[17:39:37.251]                     }
[17:39:37.251]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.251]                   }
[17:39:37.251]                 }
[17:39:37.251]             }
[17:39:37.251]         }))
[17:39:37.251]     }, error = function(ex) {
[17:39:37.251]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.251]                 ...future.rng), started = ...future.startTime, 
[17:39:37.251]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.251]             version = "1.8"), class = "FutureResult")
[17:39:37.251]     }, finally = {
[17:39:37.251]         if (!identical(...future.workdir, getwd())) 
[17:39:37.251]             setwd(...future.workdir)
[17:39:37.251]         {
[17:39:37.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.251]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.251]             }
[17:39:37.251]             base::options(...future.oldOptions)
[17:39:37.251]             if (.Platform$OS.type == "windows") {
[17:39:37.251]                 old_names <- names(...future.oldEnvVars)
[17:39:37.251]                 envs <- base::Sys.getenv()
[17:39:37.251]                 names <- names(envs)
[17:39:37.251]                 common <- intersect(names, old_names)
[17:39:37.251]                 added <- setdiff(names, old_names)
[17:39:37.251]                 removed <- setdiff(old_names, names)
[17:39:37.251]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.251]                   envs[common]]
[17:39:37.251]                 NAMES <- toupper(changed)
[17:39:37.251]                 args <- list()
[17:39:37.251]                 for (kk in seq_along(NAMES)) {
[17:39:37.251]                   name <- changed[[kk]]
[17:39:37.251]                   NAME <- NAMES[[kk]]
[17:39:37.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.251]                     next
[17:39:37.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.251]                 }
[17:39:37.251]                 NAMES <- toupper(added)
[17:39:37.251]                 for (kk in seq_along(NAMES)) {
[17:39:37.251]                   name <- added[[kk]]
[17:39:37.251]                   NAME <- NAMES[[kk]]
[17:39:37.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.251]                     next
[17:39:37.251]                   args[[name]] <- ""
[17:39:37.251]                 }
[17:39:37.251]                 NAMES <- toupper(removed)
[17:39:37.251]                 for (kk in seq_along(NAMES)) {
[17:39:37.251]                   name <- removed[[kk]]
[17:39:37.251]                   NAME <- NAMES[[kk]]
[17:39:37.251]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.251]                     next
[17:39:37.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.251]                 }
[17:39:37.251]                 if (length(args) > 0) 
[17:39:37.251]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.251]             }
[17:39:37.251]             else {
[17:39:37.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.251]             }
[17:39:37.251]             {
[17:39:37.251]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.251]                   0L) {
[17:39:37.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.251]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.251]                   base::options(opts)
[17:39:37.251]                 }
[17:39:37.251]                 {
[17:39:37.251]                   {
[17:39:37.251]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.251]                     NULL
[17:39:37.251]                   }
[17:39:37.251]                   options(future.plan = NULL)
[17:39:37.251]                   if (is.na(NA_character_)) 
[17:39:37.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.251]                     .init = FALSE)
[17:39:37.251]                 }
[17:39:37.251]             }
[17:39:37.251]         }
[17:39:37.251]     })
[17:39:37.251]     if (TRUE) {
[17:39:37.251]         base::sink(type = "output", split = FALSE)
[17:39:37.251]         if (TRUE) {
[17:39:37.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.251]         }
[17:39:37.251]         else {
[17:39:37.251]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.251]         }
[17:39:37.251]         base::close(...future.stdout)
[17:39:37.251]         ...future.stdout <- NULL
[17:39:37.251]     }
[17:39:37.251]     ...future.result$conditions <- ...future.conditions
[17:39:37.251]     ...future.result$finished <- base::Sys.time()
[17:39:37.251]     ...future.result
[17:39:37.251] }
[17:39:37.254] requestCore(): workers = 2
[17:39:37.256] MulticoreFuture started
[17:39:37.257] - Launch lazy future ... done
[17:39:37.257] run() for ‘MulticoreFuture’ ... done
[17:39:37.257] getGlobalsAndPackages() ...
[17:39:37.258] Searching for globals...
[17:39:37.258] plan(): Setting new future strategy stack:
[17:39:37.258] List of future strategies:
[17:39:37.258] 1. sequential:
[17:39:37.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.258]    - tweaked: FALSE
[17:39:37.258]    - call: NULL
[17:39:37.259] 
[17:39:37.259] Searching for globals ... DONE
[17:39:37.259] plan(): nbrOfWorkers() = 1
[17:39:37.259] - globals: [0] <none>
[17:39:37.259] getGlobalsAndPackages() ... DONE
[17:39:37.260] run() for ‘Future’ ...
[17:39:37.260] - state: ‘created’
[17:39:37.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.261] plan(): Setting new future strategy stack:
[17:39:37.261] List of future strategies:
[17:39:37.261] 1. multicore:
[17:39:37.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.261]    - tweaked: FALSE
[17:39:37.261]    - call: plan(strategy)
[17:39:37.265] plan(): nbrOfWorkers() = 2
[17:39:37.266] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.266]   - Field: ‘label’
[17:39:37.266]   - Field: ‘local’
[17:39:37.266]   - Field: ‘owner’
[17:39:37.267]   - Field: ‘envir’
[17:39:37.267]   - Field: ‘workers’
[17:39:37.267]   - Field: ‘packages’
[17:39:37.267]   - Field: ‘gc’
[17:39:37.267]   - Field: ‘job’
[17:39:37.268]   - Field: ‘conditions’
[17:39:37.268]   - Field: ‘expr’
[17:39:37.268]   - Field: ‘uuid’
[17:39:37.268]   - Field: ‘seed’
[17:39:37.268]   - Field: ‘version’
[17:39:37.268]   - Field: ‘result’
[17:39:37.269]   - Field: ‘asynchronous’
[17:39:37.269]   - Field: ‘calls’
[17:39:37.269]   - Field: ‘globals’
[17:39:37.269]   - Field: ‘stdout’
[17:39:37.269]   - Field: ‘earlySignal’
[17:39:37.269]   - Field: ‘lazy’
[17:39:37.269]   - Field: ‘state’
[17:39:37.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.270] - Launch lazy future ...
[17:39:37.270] Packages needed by the future expression (n = 0): <none>
[17:39:37.271] Packages needed by future strategies (n = 0): <none>
[17:39:37.271] {
[17:39:37.271]     {
[17:39:37.271]         {
[17:39:37.271]             ...future.startTime <- base::Sys.time()
[17:39:37.271]             {
[17:39:37.271]                 {
[17:39:37.271]                   {
[17:39:37.271]                     {
[17:39:37.271]                       base::local({
[17:39:37.271]                         has_future <- base::requireNamespace("future", 
[17:39:37.271]                           quietly = TRUE)
[17:39:37.271]                         if (has_future) {
[17:39:37.271]                           ns <- base::getNamespace("future")
[17:39:37.271]                           version <- ns[[".package"]][["version"]]
[17:39:37.271]                           if (is.null(version)) 
[17:39:37.271]                             version <- utils::packageVersion("future")
[17:39:37.271]                         }
[17:39:37.271]                         else {
[17:39:37.271]                           version <- NULL
[17:39:37.271]                         }
[17:39:37.271]                         if (!has_future || version < "1.8.0") {
[17:39:37.271]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.271]                             "", base::R.version$version.string), 
[17:39:37.271]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.271]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.271]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.271]                               "release", "version")], collapse = " "), 
[17:39:37.271]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.271]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.271]                             info)
[17:39:37.271]                           info <- base::paste(info, collapse = "; ")
[17:39:37.271]                           if (!has_future) {
[17:39:37.271]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.271]                               info)
[17:39:37.271]                           }
[17:39:37.271]                           else {
[17:39:37.271]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.271]                               info, version)
[17:39:37.271]                           }
[17:39:37.271]                           base::stop(msg)
[17:39:37.271]                         }
[17:39:37.271]                       })
[17:39:37.271]                     }
[17:39:37.271]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.271]                     base::options(mc.cores = 1L)
[17:39:37.271]                   }
[17:39:37.271]                   ...future.strategy.old <- future::plan("list")
[17:39:37.271]                   options(future.plan = NULL)
[17:39:37.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.271]                 }
[17:39:37.271]                 ...future.workdir <- getwd()
[17:39:37.271]             }
[17:39:37.271]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.271]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.271]         }
[17:39:37.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.271]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.271]             base::names(...future.oldOptions))
[17:39:37.271]     }
[17:39:37.271]     if (FALSE) {
[17:39:37.271]     }
[17:39:37.271]     else {
[17:39:37.271]         if (TRUE) {
[17:39:37.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.271]                 open = "w")
[17:39:37.271]         }
[17:39:37.271]         else {
[17:39:37.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.271]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.271]         }
[17:39:37.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.271]             base::sink(type = "output", split = FALSE)
[17:39:37.271]             base::close(...future.stdout)
[17:39:37.271]         }, add = TRUE)
[17:39:37.271]     }
[17:39:37.271]     ...future.frame <- base::sys.nframe()
[17:39:37.271]     ...future.conditions <- base::list()
[17:39:37.271]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.271]     if (FALSE) {
[17:39:37.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.271]     }
[17:39:37.271]     ...future.result <- base::tryCatch({
[17:39:37.271]         base::withCallingHandlers({
[17:39:37.271]             ...future.value <- base::withVisible(base::local({
[17:39:37.271]                 withCallingHandlers({
[17:39:37.271]                   NULL
[17:39:37.271]                 }, immediateCondition = function(cond) {
[17:39:37.271]                   save_rds <- function (object, pathname, ...) 
[17:39:37.271]                   {
[17:39:37.271]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.271]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.271]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.271]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.271]                         fi_tmp[["mtime"]])
[17:39:37.271]                     }
[17:39:37.271]                     tryCatch({
[17:39:37.271]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.271]                     }, error = function(ex) {
[17:39:37.271]                       msg <- conditionMessage(ex)
[17:39:37.271]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.271]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.271]                         fi_tmp[["mtime"]], msg)
[17:39:37.271]                       ex$message <- msg
[17:39:37.271]                       stop(ex)
[17:39:37.271]                     })
[17:39:37.271]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.271]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.271]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.271]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.271]                       fi <- file.info(pathname)
[17:39:37.271]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.271]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.271]                         fi[["size"]], fi[["mtime"]])
[17:39:37.271]                       stop(msg)
[17:39:37.271]                     }
[17:39:37.271]                     invisible(pathname)
[17:39:37.271]                   }
[17:39:37.271]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.271]                     rootPath = tempdir()) 
[17:39:37.271]                   {
[17:39:37.271]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.271]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.271]                       tmpdir = path, fileext = ".rds")
[17:39:37.271]                     save_rds(obj, file)
[17:39:37.271]                   }
[17:39:37.271]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.271]                   {
[17:39:37.271]                     inherits <- base::inherits
[17:39:37.271]                     invokeRestart <- base::invokeRestart
[17:39:37.271]                     is.null <- base::is.null
[17:39:37.271]                     muffled <- FALSE
[17:39:37.271]                     if (inherits(cond, "message")) {
[17:39:37.271]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.271]                       if (muffled) 
[17:39:37.271]                         invokeRestart("muffleMessage")
[17:39:37.271]                     }
[17:39:37.271]                     else if (inherits(cond, "warning")) {
[17:39:37.271]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.271]                       if (muffled) 
[17:39:37.271]                         invokeRestart("muffleWarning")
[17:39:37.271]                     }
[17:39:37.271]                     else if (inherits(cond, "condition")) {
[17:39:37.271]                       if (!is.null(pattern)) {
[17:39:37.271]                         computeRestarts <- base::computeRestarts
[17:39:37.271]                         grepl <- base::grepl
[17:39:37.271]                         restarts <- computeRestarts(cond)
[17:39:37.271]                         for (restart in restarts) {
[17:39:37.271]                           name <- restart$name
[17:39:37.271]                           if (is.null(name)) 
[17:39:37.271]                             next
[17:39:37.271]                           if (!grepl(pattern, name)) 
[17:39:37.271]                             next
[17:39:37.271]                           invokeRestart(restart)
[17:39:37.271]                           muffled <- TRUE
[17:39:37.271]                           break
[17:39:37.271]                         }
[17:39:37.271]                       }
[17:39:37.271]                     }
[17:39:37.271]                     invisible(muffled)
[17:39:37.271]                   }
[17:39:37.271]                   muffleCondition(cond)
[17:39:37.271]                 })
[17:39:37.271]             }))
[17:39:37.271]             future::FutureResult(value = ...future.value$value, 
[17:39:37.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.271]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.271]                     ...future.globalenv.names))
[17:39:37.271]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.271]         }, condition = base::local({
[17:39:37.271]             c <- base::c
[17:39:37.271]             inherits <- base::inherits
[17:39:37.271]             invokeRestart <- base::invokeRestart
[17:39:37.271]             length <- base::length
[17:39:37.271]             list <- base::list
[17:39:37.271]             seq.int <- base::seq.int
[17:39:37.271]             signalCondition <- base::signalCondition
[17:39:37.271]             sys.calls <- base::sys.calls
[17:39:37.271]             `[[` <- base::`[[`
[17:39:37.271]             `+` <- base::`+`
[17:39:37.271]             `<<-` <- base::`<<-`
[17:39:37.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.271]                   3L)]
[17:39:37.271]             }
[17:39:37.271]             function(cond) {
[17:39:37.271]                 is_error <- inherits(cond, "error")
[17:39:37.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.271]                   NULL)
[17:39:37.271]                 if (is_error) {
[17:39:37.271]                   sessionInformation <- function() {
[17:39:37.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.271]                       search = base::search(), system = base::Sys.info())
[17:39:37.271]                   }
[17:39:37.271]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.271]                     cond$call), session = sessionInformation(), 
[17:39:37.271]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.271]                   signalCondition(cond)
[17:39:37.271]                 }
[17:39:37.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.271]                 "immediateCondition"))) {
[17:39:37.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.271]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.271]                   if (TRUE && !signal) {
[17:39:37.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.271]                     {
[17:39:37.271]                       inherits <- base::inherits
[17:39:37.271]                       invokeRestart <- base::invokeRestart
[17:39:37.271]                       is.null <- base::is.null
[17:39:37.271]                       muffled <- FALSE
[17:39:37.271]                       if (inherits(cond, "message")) {
[17:39:37.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.271]                         if (muffled) 
[17:39:37.271]                           invokeRestart("muffleMessage")
[17:39:37.271]                       }
[17:39:37.271]                       else if (inherits(cond, "warning")) {
[17:39:37.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.271]                         if (muffled) 
[17:39:37.271]                           invokeRestart("muffleWarning")
[17:39:37.271]                       }
[17:39:37.271]                       else if (inherits(cond, "condition")) {
[17:39:37.271]                         if (!is.null(pattern)) {
[17:39:37.271]                           computeRestarts <- base::computeRestarts
[17:39:37.271]                           grepl <- base::grepl
[17:39:37.271]                           restarts <- computeRestarts(cond)
[17:39:37.271]                           for (restart in restarts) {
[17:39:37.271]                             name <- restart$name
[17:39:37.271]                             if (is.null(name)) 
[17:39:37.271]                               next
[17:39:37.271]                             if (!grepl(pattern, name)) 
[17:39:37.271]                               next
[17:39:37.271]                             invokeRestart(restart)
[17:39:37.271]                             muffled <- TRUE
[17:39:37.271]                             break
[17:39:37.271]                           }
[17:39:37.271]                         }
[17:39:37.271]                       }
[17:39:37.271]                       invisible(muffled)
[17:39:37.271]                     }
[17:39:37.271]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.271]                   }
[17:39:37.271]                 }
[17:39:37.271]                 else {
[17:39:37.271]                   if (TRUE) {
[17:39:37.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.271]                     {
[17:39:37.271]                       inherits <- base::inherits
[17:39:37.271]                       invokeRestart <- base::invokeRestart
[17:39:37.271]                       is.null <- base::is.null
[17:39:37.271]                       muffled <- FALSE
[17:39:37.271]                       if (inherits(cond, "message")) {
[17:39:37.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.271]                         if (muffled) 
[17:39:37.271]                           invokeRestart("muffleMessage")
[17:39:37.271]                       }
[17:39:37.271]                       else if (inherits(cond, "warning")) {
[17:39:37.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.271]                         if (muffled) 
[17:39:37.271]                           invokeRestart("muffleWarning")
[17:39:37.271]                       }
[17:39:37.271]                       else if (inherits(cond, "condition")) {
[17:39:37.271]                         if (!is.null(pattern)) {
[17:39:37.271]                           computeRestarts <- base::computeRestarts
[17:39:37.271]                           grepl <- base::grepl
[17:39:37.271]                           restarts <- computeRestarts(cond)
[17:39:37.271]                           for (restart in restarts) {
[17:39:37.271]                             name <- restart$name
[17:39:37.271]                             if (is.null(name)) 
[17:39:37.271]                               next
[17:39:37.271]                             if (!grepl(pattern, name)) 
[17:39:37.271]                               next
[17:39:37.271]                             invokeRestart(restart)
[17:39:37.271]                             muffled <- TRUE
[17:39:37.271]                             break
[17:39:37.271]                           }
[17:39:37.271]                         }
[17:39:37.271]                       }
[17:39:37.271]                       invisible(muffled)
[17:39:37.271]                     }
[17:39:37.271]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.271]                   }
[17:39:37.271]                 }
[17:39:37.271]             }
[17:39:37.271]         }))
[17:39:37.271]     }, error = function(ex) {
[17:39:37.271]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.271]                 ...future.rng), started = ...future.startTime, 
[17:39:37.271]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.271]             version = "1.8"), class = "FutureResult")
[17:39:37.271]     }, finally = {
[17:39:37.271]         if (!identical(...future.workdir, getwd())) 
[17:39:37.271]             setwd(...future.workdir)
[17:39:37.271]         {
[17:39:37.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.271]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.271]             }
[17:39:37.271]             base::options(...future.oldOptions)
[17:39:37.271]             if (.Platform$OS.type == "windows") {
[17:39:37.271]                 old_names <- names(...future.oldEnvVars)
[17:39:37.271]                 envs <- base::Sys.getenv()
[17:39:37.271]                 names <- names(envs)
[17:39:37.271]                 common <- intersect(names, old_names)
[17:39:37.271]                 added <- setdiff(names, old_names)
[17:39:37.271]                 removed <- setdiff(old_names, names)
[17:39:37.271]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.271]                   envs[common]]
[17:39:37.271]                 NAMES <- toupper(changed)
[17:39:37.271]                 args <- list()
[17:39:37.271]                 for (kk in seq_along(NAMES)) {
[17:39:37.271]                   name <- changed[[kk]]
[17:39:37.271]                   NAME <- NAMES[[kk]]
[17:39:37.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.271]                     next
[17:39:37.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.271]                 }
[17:39:37.271]                 NAMES <- toupper(added)
[17:39:37.271]                 for (kk in seq_along(NAMES)) {
[17:39:37.271]                   name <- added[[kk]]
[17:39:37.271]                   NAME <- NAMES[[kk]]
[17:39:37.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.271]                     next
[17:39:37.271]                   args[[name]] <- ""
[17:39:37.271]                 }
[17:39:37.271]                 NAMES <- toupper(removed)
[17:39:37.271]                 for (kk in seq_along(NAMES)) {
[17:39:37.271]                   name <- removed[[kk]]
[17:39:37.271]                   NAME <- NAMES[[kk]]
[17:39:37.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.271]                     next
[17:39:37.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.271]                 }
[17:39:37.271]                 if (length(args) > 0) 
[17:39:37.271]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.271]             }
[17:39:37.271]             else {
[17:39:37.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.271]             }
[17:39:37.271]             {
[17:39:37.271]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.271]                   0L) {
[17:39:37.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.271]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.271]                   base::options(opts)
[17:39:37.271]                 }
[17:39:37.271]                 {
[17:39:37.271]                   {
[17:39:37.271]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.271]                     NULL
[17:39:37.271]                   }
[17:39:37.271]                   options(future.plan = NULL)
[17:39:37.271]                   if (is.na(NA_character_)) 
[17:39:37.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.271]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.271]                     .init = FALSE)
[17:39:37.271]                 }
[17:39:37.271]             }
[17:39:37.271]         }
[17:39:37.271]     })
[17:39:37.271]     if (TRUE) {
[17:39:37.271]         base::sink(type = "output", split = FALSE)
[17:39:37.271]         if (TRUE) {
[17:39:37.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.271]         }
[17:39:37.271]         else {
[17:39:37.271]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.271]         }
[17:39:37.271]         base::close(...future.stdout)
[17:39:37.271]         ...future.stdout <- NULL
[17:39:37.271]     }
[17:39:37.271]     ...future.result$conditions <- ...future.conditions
[17:39:37.271]     ...future.result$finished <- base::Sys.time()
[17:39:37.271]     ...future.result
[17:39:37.271] }
[17:39:37.275] requestCore(): workers = 2
[17:39:37.278] MulticoreFuture started
[17:39:37.279] - Launch lazy future ... done
[17:39:37.279] run() for ‘MulticoreFuture’ ... done
[17:39:37.279] plan(): Setting new future strategy stack:
[17:39:37.280] getGlobalsAndPackages() ...
[17:39:37.280] Searching for globals...
[17:39:37.280] List of future strategies:
[17:39:37.280] 1. sequential:
[17:39:37.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.280]    - tweaked: FALSE
[17:39:37.280]    - call: NULL
[17:39:37.281] plan(): nbrOfWorkers() = 1
[17:39:37.281] - globals found: [1] ‘{’
[17:39:37.282] Searching for globals ... DONE
[17:39:37.282] Resolving globals: FALSE
[17:39:37.282] 
[17:39:37.282] 
[17:39:37.283] getGlobalsAndPackages() ... DONE
[17:39:37.283] plan(): Setting new future strategy stack:
[17:39:37.283] run() for ‘Future’ ...
[17:39:37.283] - state: ‘created’
[17:39:37.283] List of future strategies:
[17:39:37.283] 1. multicore:
[17:39:37.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.283]    - tweaked: FALSE
[17:39:37.283]    - call: plan(strategy)
[17:39:37.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.288] plan(): nbrOfWorkers() = 2
[17:39:37.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.289]   - Field: ‘label’
[17:39:37.289]   - Field: ‘local’
[17:39:37.289]   - Field: ‘owner’
[17:39:37.289]   - Field: ‘envir’
[17:39:37.289]   - Field: ‘workers’
[17:39:37.289]   - Field: ‘packages’
[17:39:37.290]   - Field: ‘gc’
[17:39:37.290]   - Field: ‘job’
[17:39:37.290]   - Field: ‘conditions’
[17:39:37.290]   - Field: ‘expr’
[17:39:37.290]   - Field: ‘uuid’
[17:39:37.290]   - Field: ‘seed’
[17:39:37.290]   - Field: ‘version’
[17:39:37.291]   - Field: ‘result’
[17:39:37.291]   - Field: ‘asynchronous’
[17:39:37.291]   - Field: ‘calls’
[17:39:37.291]   - Field: ‘globals’
[17:39:37.291]   - Field: ‘stdout’
[17:39:37.291]   - Field: ‘earlySignal’
[17:39:37.291]   - Field: ‘lazy’
[17:39:37.291]   - Field: ‘state’
[17:39:37.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.292] - Launch lazy future ...
[17:39:37.292] Packages needed by the future expression (n = 0): <none>
[17:39:37.292] Packages needed by future strategies (n = 0): <none>
[17:39:37.293] {
[17:39:37.293]     {
[17:39:37.293]         {
[17:39:37.293]             ...future.startTime <- base::Sys.time()
[17:39:37.293]             {
[17:39:37.293]                 {
[17:39:37.293]                   {
[17:39:37.293]                     {
[17:39:37.293]                       base::local({
[17:39:37.293]                         has_future <- base::requireNamespace("future", 
[17:39:37.293]                           quietly = TRUE)
[17:39:37.293]                         if (has_future) {
[17:39:37.293]                           ns <- base::getNamespace("future")
[17:39:37.293]                           version <- ns[[".package"]][["version"]]
[17:39:37.293]                           if (is.null(version)) 
[17:39:37.293]                             version <- utils::packageVersion("future")
[17:39:37.293]                         }
[17:39:37.293]                         else {
[17:39:37.293]                           version <- NULL
[17:39:37.293]                         }
[17:39:37.293]                         if (!has_future || version < "1.8.0") {
[17:39:37.293]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.293]                             "", base::R.version$version.string), 
[17:39:37.293]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.293]                               "release", "version")], collapse = " "), 
[17:39:37.293]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.293]                             info)
[17:39:37.293]                           info <- base::paste(info, collapse = "; ")
[17:39:37.293]                           if (!has_future) {
[17:39:37.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.293]                               info)
[17:39:37.293]                           }
[17:39:37.293]                           else {
[17:39:37.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.293]                               info, version)
[17:39:37.293]                           }
[17:39:37.293]                           base::stop(msg)
[17:39:37.293]                         }
[17:39:37.293]                       })
[17:39:37.293]                     }
[17:39:37.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.293]                     base::options(mc.cores = 1L)
[17:39:37.293]                   }
[17:39:37.293]                   ...future.strategy.old <- future::plan("list")
[17:39:37.293]                   options(future.plan = NULL)
[17:39:37.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.293]                 }
[17:39:37.293]                 ...future.workdir <- getwd()
[17:39:37.293]             }
[17:39:37.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.293]         }
[17:39:37.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.293]             base::names(...future.oldOptions))
[17:39:37.293]     }
[17:39:37.293]     if (FALSE) {
[17:39:37.293]     }
[17:39:37.293]     else {
[17:39:37.293]         if (TRUE) {
[17:39:37.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.293]                 open = "w")
[17:39:37.293]         }
[17:39:37.293]         else {
[17:39:37.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.293]         }
[17:39:37.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.293]             base::sink(type = "output", split = FALSE)
[17:39:37.293]             base::close(...future.stdout)
[17:39:37.293]         }, add = TRUE)
[17:39:37.293]     }
[17:39:37.293]     ...future.frame <- base::sys.nframe()
[17:39:37.293]     ...future.conditions <- base::list()
[17:39:37.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.293]     if (FALSE) {
[17:39:37.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.293]     }
[17:39:37.293]     ...future.result <- base::tryCatch({
[17:39:37.293]         base::withCallingHandlers({
[17:39:37.293]             ...future.value <- base::withVisible(base::local({
[17:39:37.293]                 withCallingHandlers({
[17:39:37.293]                   {
[17:39:37.293]                     4
[17:39:37.293]                   }
[17:39:37.293]                 }, immediateCondition = function(cond) {
[17:39:37.293]                   save_rds <- function (object, pathname, ...) 
[17:39:37.293]                   {
[17:39:37.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.293]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.293]                         fi_tmp[["mtime"]])
[17:39:37.293]                     }
[17:39:37.293]                     tryCatch({
[17:39:37.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.293]                     }, error = function(ex) {
[17:39:37.293]                       msg <- conditionMessage(ex)
[17:39:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.293]                         fi_tmp[["mtime"]], msg)
[17:39:37.293]                       ex$message <- msg
[17:39:37.293]                       stop(ex)
[17:39:37.293]                     })
[17:39:37.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.293]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.293]                       fi <- file.info(pathname)
[17:39:37.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.293]                         fi[["size"]], fi[["mtime"]])
[17:39:37.293]                       stop(msg)
[17:39:37.293]                     }
[17:39:37.293]                     invisible(pathname)
[17:39:37.293]                   }
[17:39:37.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.293]                     rootPath = tempdir()) 
[17:39:37.293]                   {
[17:39:37.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.293]                       tmpdir = path, fileext = ".rds")
[17:39:37.293]                     save_rds(obj, file)
[17:39:37.293]                   }
[17:39:37.293]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.293]                   {
[17:39:37.293]                     inherits <- base::inherits
[17:39:37.293]                     invokeRestart <- base::invokeRestart
[17:39:37.293]                     is.null <- base::is.null
[17:39:37.293]                     muffled <- FALSE
[17:39:37.293]                     if (inherits(cond, "message")) {
[17:39:37.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.293]                       if (muffled) 
[17:39:37.293]                         invokeRestart("muffleMessage")
[17:39:37.293]                     }
[17:39:37.293]                     else if (inherits(cond, "warning")) {
[17:39:37.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.293]                       if (muffled) 
[17:39:37.293]                         invokeRestart("muffleWarning")
[17:39:37.293]                     }
[17:39:37.293]                     else if (inherits(cond, "condition")) {
[17:39:37.293]                       if (!is.null(pattern)) {
[17:39:37.293]                         computeRestarts <- base::computeRestarts
[17:39:37.293]                         grepl <- base::grepl
[17:39:37.293]                         restarts <- computeRestarts(cond)
[17:39:37.293]                         for (restart in restarts) {
[17:39:37.293]                           name <- restart$name
[17:39:37.293]                           if (is.null(name)) 
[17:39:37.293]                             next
[17:39:37.293]                           if (!grepl(pattern, name)) 
[17:39:37.293]                             next
[17:39:37.293]                           invokeRestart(restart)
[17:39:37.293]                           muffled <- TRUE
[17:39:37.293]                           break
[17:39:37.293]                         }
[17:39:37.293]                       }
[17:39:37.293]                     }
[17:39:37.293]                     invisible(muffled)
[17:39:37.293]                   }
[17:39:37.293]                   muffleCondition(cond)
[17:39:37.293]                 })
[17:39:37.293]             }))
[17:39:37.293]             future::FutureResult(value = ...future.value$value, 
[17:39:37.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.293]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.293]                     ...future.globalenv.names))
[17:39:37.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.293]         }, condition = base::local({
[17:39:37.293]             c <- base::c
[17:39:37.293]             inherits <- base::inherits
[17:39:37.293]             invokeRestart <- base::invokeRestart
[17:39:37.293]             length <- base::length
[17:39:37.293]             list <- base::list
[17:39:37.293]             seq.int <- base::seq.int
[17:39:37.293]             signalCondition <- base::signalCondition
[17:39:37.293]             sys.calls <- base::sys.calls
[17:39:37.293]             `[[` <- base::`[[`
[17:39:37.293]             `+` <- base::`+`
[17:39:37.293]             `<<-` <- base::`<<-`
[17:39:37.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.293]                   3L)]
[17:39:37.293]             }
[17:39:37.293]             function(cond) {
[17:39:37.293]                 is_error <- inherits(cond, "error")
[17:39:37.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.293]                   NULL)
[17:39:37.293]                 if (is_error) {
[17:39:37.293]                   sessionInformation <- function() {
[17:39:37.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.293]                       search = base::search(), system = base::Sys.info())
[17:39:37.293]                   }
[17:39:37.293]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.293]                     cond$call), session = sessionInformation(), 
[17:39:37.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.293]                   signalCondition(cond)
[17:39:37.293]                 }
[17:39:37.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.293]                 "immediateCondition"))) {
[17:39:37.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.293]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.293]                   if (TRUE && !signal) {
[17:39:37.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.293]                     {
[17:39:37.293]                       inherits <- base::inherits
[17:39:37.293]                       invokeRestart <- base::invokeRestart
[17:39:37.293]                       is.null <- base::is.null
[17:39:37.293]                       muffled <- FALSE
[17:39:37.293]                       if (inherits(cond, "message")) {
[17:39:37.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.293]                         if (muffled) 
[17:39:37.293]                           invokeRestart("muffleMessage")
[17:39:37.293]                       }
[17:39:37.293]                       else if (inherits(cond, "warning")) {
[17:39:37.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.293]                         if (muffled) 
[17:39:37.293]                           invokeRestart("muffleWarning")
[17:39:37.293]                       }
[17:39:37.293]                       else if (inherits(cond, "condition")) {
[17:39:37.293]                         if (!is.null(pattern)) {
[17:39:37.293]                           computeRestarts <- base::computeRestarts
[17:39:37.293]                           grepl <- base::grepl
[17:39:37.293]                           restarts <- computeRestarts(cond)
[17:39:37.293]                           for (restart in restarts) {
[17:39:37.293]                             name <- restart$name
[17:39:37.293]                             if (is.null(name)) 
[17:39:37.293]                               next
[17:39:37.293]                             if (!grepl(pattern, name)) 
[17:39:37.293]                               next
[17:39:37.293]                             invokeRestart(restart)
[17:39:37.293]                             muffled <- TRUE
[17:39:37.293]                             break
[17:39:37.293]                           }
[17:39:37.293]                         }
[17:39:37.293]                       }
[17:39:37.293]                       invisible(muffled)
[17:39:37.293]                     }
[17:39:37.293]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.293]                   }
[17:39:37.293]                 }
[17:39:37.293]                 else {
[17:39:37.293]                   if (TRUE) {
[17:39:37.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.293]                     {
[17:39:37.293]                       inherits <- base::inherits
[17:39:37.293]                       invokeRestart <- base::invokeRestart
[17:39:37.293]                       is.null <- base::is.null
[17:39:37.293]                       muffled <- FALSE
[17:39:37.293]                       if (inherits(cond, "message")) {
[17:39:37.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.293]                         if (muffled) 
[17:39:37.293]                           invokeRestart("muffleMessage")
[17:39:37.293]                       }
[17:39:37.293]                       else if (inherits(cond, "warning")) {
[17:39:37.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.293]                         if (muffled) 
[17:39:37.293]                           invokeRestart("muffleWarning")
[17:39:37.293]                       }
[17:39:37.293]                       else if (inherits(cond, "condition")) {
[17:39:37.293]                         if (!is.null(pattern)) {
[17:39:37.293]                           computeRestarts <- base::computeRestarts
[17:39:37.293]                           grepl <- base::grepl
[17:39:37.293]                           restarts <- computeRestarts(cond)
[17:39:37.293]                           for (restart in restarts) {
[17:39:37.293]                             name <- restart$name
[17:39:37.293]                             if (is.null(name)) 
[17:39:37.293]                               next
[17:39:37.293]                             if (!grepl(pattern, name)) 
[17:39:37.293]                               next
[17:39:37.293]                             invokeRestart(restart)
[17:39:37.293]                             muffled <- TRUE
[17:39:37.293]                             break
[17:39:37.293]                           }
[17:39:37.293]                         }
[17:39:37.293]                       }
[17:39:37.293]                       invisible(muffled)
[17:39:37.293]                     }
[17:39:37.293]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.293]                   }
[17:39:37.293]                 }
[17:39:37.293]             }
[17:39:37.293]         }))
[17:39:37.293]     }, error = function(ex) {
[17:39:37.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.293]                 ...future.rng), started = ...future.startTime, 
[17:39:37.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.293]             version = "1.8"), class = "FutureResult")
[17:39:37.293]     }, finally = {
[17:39:37.293]         if (!identical(...future.workdir, getwd())) 
[17:39:37.293]             setwd(...future.workdir)
[17:39:37.293]         {
[17:39:37.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.293]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.293]             }
[17:39:37.293]             base::options(...future.oldOptions)
[17:39:37.293]             if (.Platform$OS.type == "windows") {
[17:39:37.293]                 old_names <- names(...future.oldEnvVars)
[17:39:37.293]                 envs <- base::Sys.getenv()
[17:39:37.293]                 names <- names(envs)
[17:39:37.293]                 common <- intersect(names, old_names)
[17:39:37.293]                 added <- setdiff(names, old_names)
[17:39:37.293]                 removed <- setdiff(old_names, names)
[17:39:37.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.293]                   envs[common]]
[17:39:37.293]                 NAMES <- toupper(changed)
[17:39:37.293]                 args <- list()
[17:39:37.293]                 for (kk in seq_along(NAMES)) {
[17:39:37.293]                   name <- changed[[kk]]
[17:39:37.293]                   NAME <- NAMES[[kk]]
[17:39:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.293]                     next
[17:39:37.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.293]                 }
[17:39:37.293]                 NAMES <- toupper(added)
[17:39:37.293]                 for (kk in seq_along(NAMES)) {
[17:39:37.293]                   name <- added[[kk]]
[17:39:37.293]                   NAME <- NAMES[[kk]]
[17:39:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.293]                     next
[17:39:37.293]                   args[[name]] <- ""
[17:39:37.293]                 }
[17:39:37.293]                 NAMES <- toupper(removed)
[17:39:37.293]                 for (kk in seq_along(NAMES)) {
[17:39:37.293]                   name <- removed[[kk]]
[17:39:37.293]                   NAME <- NAMES[[kk]]
[17:39:37.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.293]                     next
[17:39:37.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.293]                 }
[17:39:37.293]                 if (length(args) > 0) 
[17:39:37.293]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.293]             }
[17:39:37.293]             else {
[17:39:37.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.293]             }
[17:39:37.293]             {
[17:39:37.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.293]                   0L) {
[17:39:37.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.293]                   base::options(opts)
[17:39:37.293]                 }
[17:39:37.293]                 {
[17:39:37.293]                   {
[17:39:37.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.293]                     NULL
[17:39:37.293]                   }
[17:39:37.293]                   options(future.plan = NULL)
[17:39:37.293]                   if (is.na(NA_character_)) 
[17:39:37.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.293]                     .init = FALSE)
[17:39:37.293]                 }
[17:39:37.293]             }
[17:39:37.293]         }
[17:39:37.293]     })
[17:39:37.293]     if (TRUE) {
[17:39:37.293]         base::sink(type = "output", split = FALSE)
[17:39:37.293]         if (TRUE) {
[17:39:37.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.293]         }
[17:39:37.293]         else {
[17:39:37.293]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.293]         }
[17:39:37.293]         base::close(...future.stdout)
[17:39:37.293]         ...future.stdout <- NULL
[17:39:37.293]     }
[17:39:37.293]     ...future.result$conditions <- ...future.conditions
[17:39:37.293]     ...future.result$finished <- base::Sys.time()
[17:39:37.293]     ...future.result
[17:39:37.293] }
[17:39:37.297] requestCore(): workers = 2
[17:39:37.297] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:37.308] result() for MulticoreFuture ...
[17:39:37.309] result() for MulticoreFuture ...
[17:39:37.309] result() for MulticoreFuture ... done
[17:39:37.309] result() for MulticoreFuture ... done
[17:39:37.309] result() for MulticoreFuture ...
[17:39:37.309] result() for MulticoreFuture ... done
[17:39:37.312] MulticoreFuture started
[17:39:37.313] - Launch lazy future ... done
[17:39:37.313] run() for ‘MulticoreFuture’ ... done
[17:39:37.313] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55adefd59540> 
[17:39:37.314] List of future strategies:
[17:39:37.314] 1. sequential:
[17:39:37.314]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.314]    - tweaked: FALSE
[17:39:37.314]    - call: NULL
[17:39:37.315] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55adf14ddc10> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[17:39:37.318] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:39:37.318] List of future strategies:
[17:39:37.318] 1. multicore:
[17:39:37.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.318]    - tweaked: FALSE
[17:39:37.318]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:37.324] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:37.328] resolve() on list environment ...
[17:39:37.328]  recursive: 0
[17:39:37.330]  length: 6
[17:39:37.330]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:37.330] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.330] - nx: 6
[17:39:37.330] - relay: TRUE
[17:39:37.330] - stdout: TRUE
[17:39:37.331] - signal: TRUE
[17:39:37.331] - resignal: FALSE
[17:39:37.331] - force: TRUE
[17:39:37.331] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.331] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.331]  - until=2
[17:39:37.331]  - relaying element #2
[17:39:37.331] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.332] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.332] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.332]  length: 5 (resolved future 1)
[17:39:37.332] Future #2
[17:39:37.332] result() for MulticoreFuture ...
[17:39:37.332] result() for MulticoreFuture ... done
[17:39:37.333] result() for MulticoreFuture ...
[17:39:37.333] result() for MulticoreFuture ... done
[17:39:37.333] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:37.333] - nx: 6
[17:39:37.333] - relay: TRUE
[17:39:37.333] - stdout: TRUE
[17:39:37.333] - signal: TRUE
[17:39:37.333] - resignal: FALSE
[17:39:37.334] - force: TRUE
[17:39:37.334] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.334] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.334]  - until=2
[17:39:37.334]  - relaying element #2
[17:39:37.334] result() for MulticoreFuture ...
[17:39:37.334] result() for MulticoreFuture ... done
[17:39:37.335] result() for MulticoreFuture ...
[17:39:37.335] result() for MulticoreFuture ... done
[17:39:37.335] result() for MulticoreFuture ...
[17:39:37.335] result() for MulticoreFuture ... done
[17:39:37.335] result() for MulticoreFuture ...
[17:39:37.335] result() for MulticoreFuture ... done
[17:39:37.335] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.335] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.336] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:37.336]  length: 4 (resolved future 2)
[17:39:37.336] Future #3
[17:39:37.336] result() for MulticoreFuture ...
[17:39:37.337] result() for MulticoreFuture ...
[17:39:37.337] result() for MulticoreFuture ... done
[17:39:37.337] result() for MulticoreFuture ... done
[17:39:37.338] result() for MulticoreFuture ...
[17:39:37.338] result() for MulticoreFuture ... done
[17:39:37.338] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:37.338] - nx: 6
[17:39:37.338] - relay: TRUE
[17:39:37.338] - stdout: TRUE
[17:39:37.338] - signal: TRUE
[17:39:37.338] - resignal: FALSE
[17:39:37.338] - force: TRUE
[17:39:37.339] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.339] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.339]  - until=3
[17:39:37.339]  - relaying element #3
[17:39:37.339] result() for MulticoreFuture ...
[17:39:37.339] result() for MulticoreFuture ... done
[17:39:37.339] result() for MulticoreFuture ...
[17:39:37.340] result() for MulticoreFuture ... done
[17:39:37.340] result() for MulticoreFuture ...
[17:39:37.340] result() for MulticoreFuture ... done
[17:39:37.340] result() for MulticoreFuture ...
[17:39:37.340] result() for MulticoreFuture ... done
[17:39:37.340] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.340] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.340] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:37.341]  length: 3 (resolved future 3)
[17:39:37.341] Future #4
[17:39:37.341] result() for MulticoreFuture ...
[17:39:37.342] result() for MulticoreFuture ...
[17:39:37.342] result() for MulticoreFuture ... done
[17:39:37.342] result() for MulticoreFuture ... done
[17:39:37.342] result() for MulticoreFuture ...
[17:39:37.343] result() for MulticoreFuture ... done
[17:39:37.343] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:37.343] - nx: 6
[17:39:37.343] - relay: TRUE
[17:39:37.343] - stdout: TRUE
[17:39:37.343] - signal: TRUE
[17:39:37.344] - resignal: FALSE
[17:39:37.344] - force: TRUE
[17:39:37.344] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.344] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.344]  - until=4
[17:39:37.344]  - relaying element #4
[17:39:37.345] result() for MulticoreFuture ...
[17:39:37.345] result() for MulticoreFuture ... done
[17:39:37.345] result() for MulticoreFuture ...
[17:39:37.345] result() for MulticoreFuture ... done
[17:39:37.345] result() for MulticoreFuture ...
[17:39:37.345] result() for MulticoreFuture ... done
[17:39:37.346] result() for MulticoreFuture ...
[17:39:37.346] result() for MulticoreFuture ... done
[17:39:37.346] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.346] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.346] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:37.346]  length: 2 (resolved future 4)
[17:39:37.346] signalConditionsASAP(NULL, pos=5) ...
[17:39:37.346] - nx: 6
[17:39:37.346] - relay: TRUE
[17:39:37.346] - stdout: TRUE
[17:39:37.347] - signal: TRUE
[17:39:37.347] - resignal: FALSE
[17:39:37.347] - force: TRUE
[17:39:37.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.347] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.347]  - until=6
[17:39:37.347]  - relaying element #6
[17:39:37.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.347] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.347] signalConditionsASAP(NULL, pos=5) ... done
[17:39:37.348]  length: 1 (resolved future 5)
[17:39:37.348] signalConditionsASAP(numeric, pos=6) ...
[17:39:37.348] - nx: 6
[17:39:37.348] - relay: TRUE
[17:39:37.348] - stdout: TRUE
[17:39:37.348] - signal: TRUE
[17:39:37.348] - resignal: FALSE
[17:39:37.348] - force: TRUE
[17:39:37.348] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.349] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.349]  - until=6
[17:39:37.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.349] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.349] signalConditionsASAP(numeric, pos=6) ... done
[17:39:37.349]  length: 0 (resolved future 6)
[17:39:37.349] Relaying remaining futures
[17:39:37.349] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.349] - nx: 6
[17:39:37.349] - relay: TRUE
[17:39:37.350] - stdout: TRUE
[17:39:37.350] - signal: TRUE
[17:39:37.350] - resignal: FALSE
[17:39:37.350] - force: TRUE
[17:39:37.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.350] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:37.350] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.350] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.350] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.350] resolve() on list environment ... DONE
[17:39:37.351] result() for MulticoreFuture ...
[17:39:37.351] result() for MulticoreFuture ... done
[17:39:37.351] result() for MulticoreFuture ...
[17:39:37.351] result() for MulticoreFuture ... done
[17:39:37.351] result() for MulticoreFuture ...
[17:39:37.351] result() for MulticoreFuture ... done
[17:39:37.351] result() for MulticoreFuture ...
[17:39:37.351] result() for MulticoreFuture ... done
[17:39:37.352] result() for MulticoreFuture ...
[17:39:37.352] result() for MulticoreFuture ... done
[17:39:37.352] result() for MulticoreFuture ...
[17:39:37.352] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf17fcbc8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:37.354] getGlobalsAndPackages() ...
[17:39:37.354] Searching for globals...
[17:39:37.355] 
[17:39:37.355] Searching for globals ... DONE
[17:39:37.355] - globals: [0] <none>
[17:39:37.355] getGlobalsAndPackages() ... DONE
[17:39:37.355] run() for ‘Future’ ...
[17:39:37.355] - state: ‘created’
[17:39:37.356] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.360]   - Field: ‘label’
[17:39:37.360]   - Field: ‘local’
[17:39:37.361]   - Field: ‘owner’
[17:39:37.361]   - Field: ‘envir’
[17:39:37.361]   - Field: ‘workers’
[17:39:37.361]   - Field: ‘packages’
[17:39:37.361]   - Field: ‘gc’
[17:39:37.361]   - Field: ‘job’
[17:39:37.361]   - Field: ‘conditions’
[17:39:37.365]   - Field: ‘expr’
[17:39:37.365]   - Field: ‘uuid’
[17:39:37.366]   - Field: ‘seed’
[17:39:37.366]   - Field: ‘version’
[17:39:37.366]   - Field: ‘result’
[17:39:37.366]   - Field: ‘asynchronous’
[17:39:37.366]   - Field: ‘calls’
[17:39:37.366]   - Field: ‘globals’
[17:39:37.367]   - Field: ‘stdout’
[17:39:37.367]   - Field: ‘earlySignal’
[17:39:37.367]   - Field: ‘lazy’
[17:39:37.367]   - Field: ‘state’
[17:39:37.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.367] - Launch lazy future ...
[17:39:37.368] Packages needed by the future expression (n = 0): <none>
[17:39:37.368] Packages needed by future strategies (n = 0): <none>
[17:39:37.368] {
[17:39:37.368]     {
[17:39:37.368]         {
[17:39:37.368]             ...future.startTime <- base::Sys.time()
[17:39:37.368]             {
[17:39:37.368]                 {
[17:39:37.368]                   {
[17:39:37.368]                     {
[17:39:37.368]                       base::local({
[17:39:37.368]                         has_future <- base::requireNamespace("future", 
[17:39:37.368]                           quietly = TRUE)
[17:39:37.368]                         if (has_future) {
[17:39:37.368]                           ns <- base::getNamespace("future")
[17:39:37.368]                           version <- ns[[".package"]][["version"]]
[17:39:37.368]                           if (is.null(version)) 
[17:39:37.368]                             version <- utils::packageVersion("future")
[17:39:37.368]                         }
[17:39:37.368]                         else {
[17:39:37.368]                           version <- NULL
[17:39:37.368]                         }
[17:39:37.368]                         if (!has_future || version < "1.8.0") {
[17:39:37.368]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.368]                             "", base::R.version$version.string), 
[17:39:37.368]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.368]                               "release", "version")], collapse = " "), 
[17:39:37.368]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.368]                             info)
[17:39:37.368]                           info <- base::paste(info, collapse = "; ")
[17:39:37.368]                           if (!has_future) {
[17:39:37.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.368]                               info)
[17:39:37.368]                           }
[17:39:37.368]                           else {
[17:39:37.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.368]                               info, version)
[17:39:37.368]                           }
[17:39:37.368]                           base::stop(msg)
[17:39:37.368]                         }
[17:39:37.368]                       })
[17:39:37.368]                     }
[17:39:37.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.368]                     base::options(mc.cores = 1L)
[17:39:37.368]                   }
[17:39:37.368]                   ...future.strategy.old <- future::plan("list")
[17:39:37.368]                   options(future.plan = NULL)
[17:39:37.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.368]                 }
[17:39:37.368]                 ...future.workdir <- getwd()
[17:39:37.368]             }
[17:39:37.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.368]         }
[17:39:37.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.368]             base::names(...future.oldOptions))
[17:39:37.368]     }
[17:39:37.368]     if (FALSE) {
[17:39:37.368]     }
[17:39:37.368]     else {
[17:39:37.368]         if (TRUE) {
[17:39:37.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.368]                 open = "w")
[17:39:37.368]         }
[17:39:37.368]         else {
[17:39:37.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.368]         }
[17:39:37.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.368]             base::sink(type = "output", split = FALSE)
[17:39:37.368]             base::close(...future.stdout)
[17:39:37.368]         }, add = TRUE)
[17:39:37.368]     }
[17:39:37.368]     ...future.frame <- base::sys.nframe()
[17:39:37.368]     ...future.conditions <- base::list()
[17:39:37.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.368]     if (FALSE) {
[17:39:37.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.368]     }
[17:39:37.368]     ...future.result <- base::tryCatch({
[17:39:37.368]         base::withCallingHandlers({
[17:39:37.368]             ...future.value <- base::withVisible(base::local({
[17:39:37.368]                 withCallingHandlers({
[17:39:37.368]                   2
[17:39:37.368]                 }, immediateCondition = function(cond) {
[17:39:37.368]                   save_rds <- function (object, pathname, ...) 
[17:39:37.368]                   {
[17:39:37.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.368]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.368]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.368]                         fi_tmp[["mtime"]])
[17:39:37.368]                     }
[17:39:37.368]                     tryCatch({
[17:39:37.368]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.368]                     }, error = function(ex) {
[17:39:37.368]                       msg <- conditionMessage(ex)
[17:39:37.368]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.368]                         fi_tmp[["mtime"]], msg)
[17:39:37.368]                       ex$message <- msg
[17:39:37.368]                       stop(ex)
[17:39:37.368]                     })
[17:39:37.368]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.368]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.368]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.368]                       fi <- file.info(pathname)
[17:39:37.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.368]                         fi[["size"]], fi[["mtime"]])
[17:39:37.368]                       stop(msg)
[17:39:37.368]                     }
[17:39:37.368]                     invisible(pathname)
[17:39:37.368]                   }
[17:39:37.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.368]                     rootPath = tempdir()) 
[17:39:37.368]                   {
[17:39:37.368]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.368]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.368]                       tmpdir = path, fileext = ".rds")
[17:39:37.368]                     save_rds(obj, file)
[17:39:37.368]                   }
[17:39:37.368]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.368]                   {
[17:39:37.368]                     inherits <- base::inherits
[17:39:37.368]                     invokeRestart <- base::invokeRestart
[17:39:37.368]                     is.null <- base::is.null
[17:39:37.368]                     muffled <- FALSE
[17:39:37.368]                     if (inherits(cond, "message")) {
[17:39:37.368]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.368]                       if (muffled) 
[17:39:37.368]                         invokeRestart("muffleMessage")
[17:39:37.368]                     }
[17:39:37.368]                     else if (inherits(cond, "warning")) {
[17:39:37.368]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.368]                       if (muffled) 
[17:39:37.368]                         invokeRestart("muffleWarning")
[17:39:37.368]                     }
[17:39:37.368]                     else if (inherits(cond, "condition")) {
[17:39:37.368]                       if (!is.null(pattern)) {
[17:39:37.368]                         computeRestarts <- base::computeRestarts
[17:39:37.368]                         grepl <- base::grepl
[17:39:37.368]                         restarts <- computeRestarts(cond)
[17:39:37.368]                         for (restart in restarts) {
[17:39:37.368]                           name <- restart$name
[17:39:37.368]                           if (is.null(name)) 
[17:39:37.368]                             next
[17:39:37.368]                           if (!grepl(pattern, name)) 
[17:39:37.368]                             next
[17:39:37.368]                           invokeRestart(restart)
[17:39:37.368]                           muffled <- TRUE
[17:39:37.368]                           break
[17:39:37.368]                         }
[17:39:37.368]                       }
[17:39:37.368]                     }
[17:39:37.368]                     invisible(muffled)
[17:39:37.368]                   }
[17:39:37.368]                   muffleCondition(cond)
[17:39:37.368]                 })
[17:39:37.368]             }))
[17:39:37.368]             future::FutureResult(value = ...future.value$value, 
[17:39:37.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.368]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.368]                     ...future.globalenv.names))
[17:39:37.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.368]         }, condition = base::local({
[17:39:37.368]             c <- base::c
[17:39:37.368]             inherits <- base::inherits
[17:39:37.368]             invokeRestart <- base::invokeRestart
[17:39:37.368]             length <- base::length
[17:39:37.368]             list <- base::list
[17:39:37.368]             seq.int <- base::seq.int
[17:39:37.368]             signalCondition <- base::signalCondition
[17:39:37.368]             sys.calls <- base::sys.calls
[17:39:37.368]             `[[` <- base::`[[`
[17:39:37.368]             `+` <- base::`+`
[17:39:37.368]             `<<-` <- base::`<<-`
[17:39:37.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.368]                   3L)]
[17:39:37.368]             }
[17:39:37.368]             function(cond) {
[17:39:37.368]                 is_error <- inherits(cond, "error")
[17:39:37.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.368]                   NULL)
[17:39:37.368]                 if (is_error) {
[17:39:37.368]                   sessionInformation <- function() {
[17:39:37.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.368]                       search = base::search(), system = base::Sys.info())
[17:39:37.368]                   }
[17:39:37.368]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.368]                     cond$call), session = sessionInformation(), 
[17:39:37.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.368]                   signalCondition(cond)
[17:39:37.368]                 }
[17:39:37.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.368]                 "immediateCondition"))) {
[17:39:37.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.368]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.368]                   if (TRUE && !signal) {
[17:39:37.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.368]                     {
[17:39:37.368]                       inherits <- base::inherits
[17:39:37.368]                       invokeRestart <- base::invokeRestart
[17:39:37.368]                       is.null <- base::is.null
[17:39:37.368]                       muffled <- FALSE
[17:39:37.368]                       if (inherits(cond, "message")) {
[17:39:37.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.368]                         if (muffled) 
[17:39:37.368]                           invokeRestart("muffleMessage")
[17:39:37.368]                       }
[17:39:37.368]                       else if (inherits(cond, "warning")) {
[17:39:37.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.368]                         if (muffled) 
[17:39:37.368]                           invokeRestart("muffleWarning")
[17:39:37.368]                       }
[17:39:37.368]                       else if (inherits(cond, "condition")) {
[17:39:37.368]                         if (!is.null(pattern)) {
[17:39:37.368]                           computeRestarts <- base::computeRestarts
[17:39:37.368]                           grepl <- base::grepl
[17:39:37.368]                           restarts <- computeRestarts(cond)
[17:39:37.368]                           for (restart in restarts) {
[17:39:37.368]                             name <- restart$name
[17:39:37.368]                             if (is.null(name)) 
[17:39:37.368]                               next
[17:39:37.368]                             if (!grepl(pattern, name)) 
[17:39:37.368]                               next
[17:39:37.368]                             invokeRestart(restart)
[17:39:37.368]                             muffled <- TRUE
[17:39:37.368]                             break
[17:39:37.368]                           }
[17:39:37.368]                         }
[17:39:37.368]                       }
[17:39:37.368]                       invisible(muffled)
[17:39:37.368]                     }
[17:39:37.368]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.368]                   }
[17:39:37.368]                 }
[17:39:37.368]                 else {
[17:39:37.368]                   if (TRUE) {
[17:39:37.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.368]                     {
[17:39:37.368]                       inherits <- base::inherits
[17:39:37.368]                       invokeRestart <- base::invokeRestart
[17:39:37.368]                       is.null <- base::is.null
[17:39:37.368]                       muffled <- FALSE
[17:39:37.368]                       if (inherits(cond, "message")) {
[17:39:37.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.368]                         if (muffled) 
[17:39:37.368]                           invokeRestart("muffleMessage")
[17:39:37.368]                       }
[17:39:37.368]                       else if (inherits(cond, "warning")) {
[17:39:37.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.368]                         if (muffled) 
[17:39:37.368]                           invokeRestart("muffleWarning")
[17:39:37.368]                       }
[17:39:37.368]                       else if (inherits(cond, "condition")) {
[17:39:37.368]                         if (!is.null(pattern)) {
[17:39:37.368]                           computeRestarts <- base::computeRestarts
[17:39:37.368]                           grepl <- base::grepl
[17:39:37.368]                           restarts <- computeRestarts(cond)
[17:39:37.368]                           for (restart in restarts) {
[17:39:37.368]                             name <- restart$name
[17:39:37.368]                             if (is.null(name)) 
[17:39:37.368]                               next
[17:39:37.368]                             if (!grepl(pattern, name)) 
[17:39:37.368]                               next
[17:39:37.368]                             invokeRestart(restart)
[17:39:37.368]                             muffled <- TRUE
[17:39:37.368]                             break
[17:39:37.368]                           }
[17:39:37.368]                         }
[17:39:37.368]                       }
[17:39:37.368]                       invisible(muffled)
[17:39:37.368]                     }
[17:39:37.368]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.368]                   }
[17:39:37.368]                 }
[17:39:37.368]             }
[17:39:37.368]         }))
[17:39:37.368]     }, error = function(ex) {
[17:39:37.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.368]                 ...future.rng), started = ...future.startTime, 
[17:39:37.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.368]             version = "1.8"), class = "FutureResult")
[17:39:37.368]     }, finally = {
[17:39:37.368]         if (!identical(...future.workdir, getwd())) 
[17:39:37.368]             setwd(...future.workdir)
[17:39:37.368]         {
[17:39:37.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.368]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.368]             }
[17:39:37.368]             base::options(...future.oldOptions)
[17:39:37.368]             if (.Platform$OS.type == "windows") {
[17:39:37.368]                 old_names <- names(...future.oldEnvVars)
[17:39:37.368]                 envs <- base::Sys.getenv()
[17:39:37.368]                 names <- names(envs)
[17:39:37.368]                 common <- intersect(names, old_names)
[17:39:37.368]                 added <- setdiff(names, old_names)
[17:39:37.368]                 removed <- setdiff(old_names, names)
[17:39:37.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.368]                   envs[common]]
[17:39:37.368]                 NAMES <- toupper(changed)
[17:39:37.368]                 args <- list()
[17:39:37.368]                 for (kk in seq_along(NAMES)) {
[17:39:37.368]                   name <- changed[[kk]]
[17:39:37.368]                   NAME <- NAMES[[kk]]
[17:39:37.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.368]                     next
[17:39:37.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.368]                 }
[17:39:37.368]                 NAMES <- toupper(added)
[17:39:37.368]                 for (kk in seq_along(NAMES)) {
[17:39:37.368]                   name <- added[[kk]]
[17:39:37.368]                   NAME <- NAMES[[kk]]
[17:39:37.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.368]                     next
[17:39:37.368]                   args[[name]] <- ""
[17:39:37.368]                 }
[17:39:37.368]                 NAMES <- toupper(removed)
[17:39:37.368]                 for (kk in seq_along(NAMES)) {
[17:39:37.368]                   name <- removed[[kk]]
[17:39:37.368]                   NAME <- NAMES[[kk]]
[17:39:37.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.368]                     next
[17:39:37.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.368]                 }
[17:39:37.368]                 if (length(args) > 0) 
[17:39:37.368]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.368]             }
[17:39:37.368]             else {
[17:39:37.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.368]             }
[17:39:37.368]             {
[17:39:37.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.368]                   0L) {
[17:39:37.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.368]                   base::options(opts)
[17:39:37.368]                 }
[17:39:37.368]                 {
[17:39:37.368]                   {
[17:39:37.368]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.368]                     NULL
[17:39:37.368]                   }
[17:39:37.368]                   options(future.plan = NULL)
[17:39:37.368]                   if (is.na(NA_character_)) 
[17:39:37.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.368]                     .init = FALSE)
[17:39:37.368]                 }
[17:39:37.368]             }
[17:39:37.368]         }
[17:39:37.368]     })
[17:39:37.368]     if (TRUE) {
[17:39:37.368]         base::sink(type = "output", split = FALSE)
[17:39:37.368]         if (TRUE) {
[17:39:37.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.368]         }
[17:39:37.368]         else {
[17:39:37.368]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.368]         }
[17:39:37.368]         base::close(...future.stdout)
[17:39:37.368]         ...future.stdout <- NULL
[17:39:37.368]     }
[17:39:37.368]     ...future.result$conditions <- ...future.conditions
[17:39:37.368]     ...future.result$finished <- base::Sys.time()
[17:39:37.368]     ...future.result
[17:39:37.368] }
[17:39:37.371] requestCore(): workers = 2
[17:39:37.373] MulticoreFuture started
[17:39:37.374] - Launch lazy future ... done
[17:39:37.374] run() for ‘MulticoreFuture’ ... done
[17:39:37.374] getGlobalsAndPackages() ...
[17:39:37.374] plan(): Setting new future strategy stack:
[17:39:37.375] Searching for globals...
[17:39:37.375] 
[17:39:37.375] List of future strategies:
[17:39:37.375] 1. sequential:
[17:39:37.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.375]    - tweaked: FALSE
[17:39:37.375]    - call: NULL
[17:39:37.376] Searching for globals ... DONE
[17:39:37.376] plan(): nbrOfWorkers() = 1
[17:39:37.376] - globals: [0] <none>
[17:39:37.376] getGlobalsAndPackages() ... DONE
[17:39:37.376] run() for ‘Future’ ...
[17:39:37.377] - state: ‘created’
[17:39:37.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.378] plan(): Setting new future strategy stack:
[17:39:37.378] List of future strategies:
[17:39:37.378] 1. multicore:
[17:39:37.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.378]    - tweaked: FALSE
[17:39:37.378]    - call: plan(strategy)
[17:39:37.382] plan(): nbrOfWorkers() = 2
[17:39:37.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.382]   - Field: ‘label’
[17:39:37.383]   - Field: ‘local’
[17:39:37.383]   - Field: ‘owner’
[17:39:37.383]   - Field: ‘envir’
[17:39:37.383]   - Field: ‘workers’
[17:39:37.383]   - Field: ‘packages’
[17:39:37.383]   - Field: ‘gc’
[17:39:37.384]   - Field: ‘job’
[17:39:37.384]   - Field: ‘conditions’
[17:39:37.384]   - Field: ‘expr’
[17:39:37.384]   - Field: ‘uuid’
[17:39:37.384]   - Field: ‘seed’
[17:39:37.384]   - Field: ‘version’
[17:39:37.384]   - Field: ‘result’
[17:39:37.385]   - Field: ‘asynchronous’
[17:39:37.385]   - Field: ‘calls’
[17:39:37.385]   - Field: ‘globals’
[17:39:37.385]   - Field: ‘stdout’
[17:39:37.385]   - Field: ‘earlySignal’
[17:39:37.385]   - Field: ‘lazy’
[17:39:37.385]   - Field: ‘state’
[17:39:37.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.386] - Launch lazy future ...
[17:39:37.386] Packages needed by the future expression (n = 0): <none>
[17:39:37.386] Packages needed by future strategies (n = 0): <none>
[17:39:37.387] {
[17:39:37.387]     {
[17:39:37.387]         {
[17:39:37.387]             ...future.startTime <- base::Sys.time()
[17:39:37.387]             {
[17:39:37.387]                 {
[17:39:37.387]                   {
[17:39:37.387]                     {
[17:39:37.387]                       base::local({
[17:39:37.387]                         has_future <- base::requireNamespace("future", 
[17:39:37.387]                           quietly = TRUE)
[17:39:37.387]                         if (has_future) {
[17:39:37.387]                           ns <- base::getNamespace("future")
[17:39:37.387]                           version <- ns[[".package"]][["version"]]
[17:39:37.387]                           if (is.null(version)) 
[17:39:37.387]                             version <- utils::packageVersion("future")
[17:39:37.387]                         }
[17:39:37.387]                         else {
[17:39:37.387]                           version <- NULL
[17:39:37.387]                         }
[17:39:37.387]                         if (!has_future || version < "1.8.0") {
[17:39:37.387]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.387]                             "", base::R.version$version.string), 
[17:39:37.387]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.387]                               "release", "version")], collapse = " "), 
[17:39:37.387]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.387]                             info)
[17:39:37.387]                           info <- base::paste(info, collapse = "; ")
[17:39:37.387]                           if (!has_future) {
[17:39:37.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.387]                               info)
[17:39:37.387]                           }
[17:39:37.387]                           else {
[17:39:37.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.387]                               info, version)
[17:39:37.387]                           }
[17:39:37.387]                           base::stop(msg)
[17:39:37.387]                         }
[17:39:37.387]                       })
[17:39:37.387]                     }
[17:39:37.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.387]                     base::options(mc.cores = 1L)
[17:39:37.387]                   }
[17:39:37.387]                   ...future.strategy.old <- future::plan("list")
[17:39:37.387]                   options(future.plan = NULL)
[17:39:37.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.387]                 }
[17:39:37.387]                 ...future.workdir <- getwd()
[17:39:37.387]             }
[17:39:37.387]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.387]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.387]         }
[17:39:37.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.387]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.387]             base::names(...future.oldOptions))
[17:39:37.387]     }
[17:39:37.387]     if (FALSE) {
[17:39:37.387]     }
[17:39:37.387]     else {
[17:39:37.387]         if (TRUE) {
[17:39:37.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.387]                 open = "w")
[17:39:37.387]         }
[17:39:37.387]         else {
[17:39:37.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.387]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.387]         }
[17:39:37.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.387]             base::sink(type = "output", split = FALSE)
[17:39:37.387]             base::close(...future.stdout)
[17:39:37.387]         }, add = TRUE)
[17:39:37.387]     }
[17:39:37.387]     ...future.frame <- base::sys.nframe()
[17:39:37.387]     ...future.conditions <- base::list()
[17:39:37.387]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.387]     if (FALSE) {
[17:39:37.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.387]     }
[17:39:37.387]     ...future.result <- base::tryCatch({
[17:39:37.387]         base::withCallingHandlers({
[17:39:37.387]             ...future.value <- base::withVisible(base::local({
[17:39:37.387]                 withCallingHandlers({
[17:39:37.387]                   NULL
[17:39:37.387]                 }, immediateCondition = function(cond) {
[17:39:37.387]                   save_rds <- function (object, pathname, ...) 
[17:39:37.387]                   {
[17:39:37.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.387]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.387]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.387]                         fi_tmp[["mtime"]])
[17:39:37.387]                     }
[17:39:37.387]                     tryCatch({
[17:39:37.387]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.387]                     }, error = function(ex) {
[17:39:37.387]                       msg <- conditionMessage(ex)
[17:39:37.387]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.387]                         fi_tmp[["mtime"]], msg)
[17:39:37.387]                       ex$message <- msg
[17:39:37.387]                       stop(ex)
[17:39:37.387]                     })
[17:39:37.387]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.387]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.387]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.387]                       fi <- file.info(pathname)
[17:39:37.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.387]                         fi[["size"]], fi[["mtime"]])
[17:39:37.387]                       stop(msg)
[17:39:37.387]                     }
[17:39:37.387]                     invisible(pathname)
[17:39:37.387]                   }
[17:39:37.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.387]                     rootPath = tempdir()) 
[17:39:37.387]                   {
[17:39:37.387]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.387]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.387]                       tmpdir = path, fileext = ".rds")
[17:39:37.387]                     save_rds(obj, file)
[17:39:37.387]                   }
[17:39:37.387]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.387]                   {
[17:39:37.387]                     inherits <- base::inherits
[17:39:37.387]                     invokeRestart <- base::invokeRestart
[17:39:37.387]                     is.null <- base::is.null
[17:39:37.387]                     muffled <- FALSE
[17:39:37.387]                     if (inherits(cond, "message")) {
[17:39:37.387]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.387]                       if (muffled) 
[17:39:37.387]                         invokeRestart("muffleMessage")
[17:39:37.387]                     }
[17:39:37.387]                     else if (inherits(cond, "warning")) {
[17:39:37.387]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.387]                       if (muffled) 
[17:39:37.387]                         invokeRestart("muffleWarning")
[17:39:37.387]                     }
[17:39:37.387]                     else if (inherits(cond, "condition")) {
[17:39:37.387]                       if (!is.null(pattern)) {
[17:39:37.387]                         computeRestarts <- base::computeRestarts
[17:39:37.387]                         grepl <- base::grepl
[17:39:37.387]                         restarts <- computeRestarts(cond)
[17:39:37.387]                         for (restart in restarts) {
[17:39:37.387]                           name <- restart$name
[17:39:37.387]                           if (is.null(name)) 
[17:39:37.387]                             next
[17:39:37.387]                           if (!grepl(pattern, name)) 
[17:39:37.387]                             next
[17:39:37.387]                           invokeRestart(restart)
[17:39:37.387]                           muffled <- TRUE
[17:39:37.387]                           break
[17:39:37.387]                         }
[17:39:37.387]                       }
[17:39:37.387]                     }
[17:39:37.387]                     invisible(muffled)
[17:39:37.387]                   }
[17:39:37.387]                   muffleCondition(cond)
[17:39:37.387]                 })
[17:39:37.387]             }))
[17:39:37.387]             future::FutureResult(value = ...future.value$value, 
[17:39:37.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.387]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.387]                     ...future.globalenv.names))
[17:39:37.387]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.387]         }, condition = base::local({
[17:39:37.387]             c <- base::c
[17:39:37.387]             inherits <- base::inherits
[17:39:37.387]             invokeRestart <- base::invokeRestart
[17:39:37.387]             length <- base::length
[17:39:37.387]             list <- base::list
[17:39:37.387]             seq.int <- base::seq.int
[17:39:37.387]             signalCondition <- base::signalCondition
[17:39:37.387]             sys.calls <- base::sys.calls
[17:39:37.387]             `[[` <- base::`[[`
[17:39:37.387]             `+` <- base::`+`
[17:39:37.387]             `<<-` <- base::`<<-`
[17:39:37.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.387]                   3L)]
[17:39:37.387]             }
[17:39:37.387]             function(cond) {
[17:39:37.387]                 is_error <- inherits(cond, "error")
[17:39:37.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.387]                   NULL)
[17:39:37.387]                 if (is_error) {
[17:39:37.387]                   sessionInformation <- function() {
[17:39:37.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.387]                       search = base::search(), system = base::Sys.info())
[17:39:37.387]                   }
[17:39:37.387]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.387]                     cond$call), session = sessionInformation(), 
[17:39:37.387]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.387]                   signalCondition(cond)
[17:39:37.387]                 }
[17:39:37.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.387]                 "immediateCondition"))) {
[17:39:37.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.387]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.387]                   if (TRUE && !signal) {
[17:39:37.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.387]                     {
[17:39:37.387]                       inherits <- base::inherits
[17:39:37.387]                       invokeRestart <- base::invokeRestart
[17:39:37.387]                       is.null <- base::is.null
[17:39:37.387]                       muffled <- FALSE
[17:39:37.387]                       if (inherits(cond, "message")) {
[17:39:37.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.387]                         if (muffled) 
[17:39:37.387]                           invokeRestart("muffleMessage")
[17:39:37.387]                       }
[17:39:37.387]                       else if (inherits(cond, "warning")) {
[17:39:37.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.387]                         if (muffled) 
[17:39:37.387]                           invokeRestart("muffleWarning")
[17:39:37.387]                       }
[17:39:37.387]                       else if (inherits(cond, "condition")) {
[17:39:37.387]                         if (!is.null(pattern)) {
[17:39:37.387]                           computeRestarts <- base::computeRestarts
[17:39:37.387]                           grepl <- base::grepl
[17:39:37.387]                           restarts <- computeRestarts(cond)
[17:39:37.387]                           for (restart in restarts) {
[17:39:37.387]                             name <- restart$name
[17:39:37.387]                             if (is.null(name)) 
[17:39:37.387]                               next
[17:39:37.387]                             if (!grepl(pattern, name)) 
[17:39:37.387]                               next
[17:39:37.387]                             invokeRestart(restart)
[17:39:37.387]                             muffled <- TRUE
[17:39:37.387]                             break
[17:39:37.387]                           }
[17:39:37.387]                         }
[17:39:37.387]                       }
[17:39:37.387]                       invisible(muffled)
[17:39:37.387]                     }
[17:39:37.387]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.387]                   }
[17:39:37.387]                 }
[17:39:37.387]                 else {
[17:39:37.387]                   if (TRUE) {
[17:39:37.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.387]                     {
[17:39:37.387]                       inherits <- base::inherits
[17:39:37.387]                       invokeRestart <- base::invokeRestart
[17:39:37.387]                       is.null <- base::is.null
[17:39:37.387]                       muffled <- FALSE
[17:39:37.387]                       if (inherits(cond, "message")) {
[17:39:37.387]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.387]                         if (muffled) 
[17:39:37.387]                           invokeRestart("muffleMessage")
[17:39:37.387]                       }
[17:39:37.387]                       else if (inherits(cond, "warning")) {
[17:39:37.387]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.387]                         if (muffled) 
[17:39:37.387]                           invokeRestart("muffleWarning")
[17:39:37.387]                       }
[17:39:37.387]                       else if (inherits(cond, "condition")) {
[17:39:37.387]                         if (!is.null(pattern)) {
[17:39:37.387]                           computeRestarts <- base::computeRestarts
[17:39:37.387]                           grepl <- base::grepl
[17:39:37.387]                           restarts <- computeRestarts(cond)
[17:39:37.387]                           for (restart in restarts) {
[17:39:37.387]                             name <- restart$name
[17:39:37.387]                             if (is.null(name)) 
[17:39:37.387]                               next
[17:39:37.387]                             if (!grepl(pattern, name)) 
[17:39:37.387]                               next
[17:39:37.387]                             invokeRestart(restart)
[17:39:37.387]                             muffled <- TRUE
[17:39:37.387]                             break
[17:39:37.387]                           }
[17:39:37.387]                         }
[17:39:37.387]                       }
[17:39:37.387]                       invisible(muffled)
[17:39:37.387]                     }
[17:39:37.387]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.387]                   }
[17:39:37.387]                 }
[17:39:37.387]             }
[17:39:37.387]         }))
[17:39:37.387]     }, error = function(ex) {
[17:39:37.387]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.387]                 ...future.rng), started = ...future.startTime, 
[17:39:37.387]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.387]             version = "1.8"), class = "FutureResult")
[17:39:37.387]     }, finally = {
[17:39:37.387]         if (!identical(...future.workdir, getwd())) 
[17:39:37.387]             setwd(...future.workdir)
[17:39:37.387]         {
[17:39:37.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.387]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.387]             }
[17:39:37.387]             base::options(...future.oldOptions)
[17:39:37.387]             if (.Platform$OS.type == "windows") {
[17:39:37.387]                 old_names <- names(...future.oldEnvVars)
[17:39:37.387]                 envs <- base::Sys.getenv()
[17:39:37.387]                 names <- names(envs)
[17:39:37.387]                 common <- intersect(names, old_names)
[17:39:37.387]                 added <- setdiff(names, old_names)
[17:39:37.387]                 removed <- setdiff(old_names, names)
[17:39:37.387]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.387]                   envs[common]]
[17:39:37.387]                 NAMES <- toupper(changed)
[17:39:37.387]                 args <- list()
[17:39:37.387]                 for (kk in seq_along(NAMES)) {
[17:39:37.387]                   name <- changed[[kk]]
[17:39:37.387]                   NAME <- NAMES[[kk]]
[17:39:37.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.387]                     next
[17:39:37.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.387]                 }
[17:39:37.387]                 NAMES <- toupper(added)
[17:39:37.387]                 for (kk in seq_along(NAMES)) {
[17:39:37.387]                   name <- added[[kk]]
[17:39:37.387]                   NAME <- NAMES[[kk]]
[17:39:37.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.387]                     next
[17:39:37.387]                   args[[name]] <- ""
[17:39:37.387]                 }
[17:39:37.387]                 NAMES <- toupper(removed)
[17:39:37.387]                 for (kk in seq_along(NAMES)) {
[17:39:37.387]                   name <- removed[[kk]]
[17:39:37.387]                   NAME <- NAMES[[kk]]
[17:39:37.387]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.387]                     next
[17:39:37.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.387]                 }
[17:39:37.387]                 if (length(args) > 0) 
[17:39:37.387]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.387]             }
[17:39:37.387]             else {
[17:39:37.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.387]             }
[17:39:37.387]             {
[17:39:37.387]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.387]                   0L) {
[17:39:37.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.387]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.387]                   base::options(opts)
[17:39:37.387]                 }
[17:39:37.387]                 {
[17:39:37.387]                   {
[17:39:37.387]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.387]                     NULL
[17:39:37.387]                   }
[17:39:37.387]                   options(future.plan = NULL)
[17:39:37.387]                   if (is.na(NA_character_)) 
[17:39:37.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.387]                     .init = FALSE)
[17:39:37.387]                 }
[17:39:37.387]             }
[17:39:37.387]         }
[17:39:37.387]     })
[17:39:37.387]     if (TRUE) {
[17:39:37.387]         base::sink(type = "output", split = FALSE)
[17:39:37.387]         if (TRUE) {
[17:39:37.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.387]         }
[17:39:37.387]         else {
[17:39:37.387]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.387]         }
[17:39:37.387]         base::close(...future.stdout)
[17:39:37.387]         ...future.stdout <- NULL
[17:39:37.387]     }
[17:39:37.387]     ...future.result$conditions <- ...future.conditions
[17:39:37.387]     ...future.result$finished <- base::Sys.time()
[17:39:37.387]     ...future.result
[17:39:37.387] }
[17:39:37.391] requestCore(): workers = 2
[17:39:37.394] MulticoreFuture started
[17:39:37.394] - Launch lazy future ... done
[17:39:37.394] run() for ‘MulticoreFuture’ ... done
[17:39:37.395] plan(): Setting new future strategy stack:
[17:39:37.395] getGlobalsAndPackages() ...
[17:39:37.395] Searching for globals...
[17:39:37.395] List of future strategies:
[17:39:37.395] 1. sequential:
[17:39:37.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.395]    - tweaked: FALSE
[17:39:37.395]    - call: NULL
[17:39:37.396] plan(): nbrOfWorkers() = 1
[17:39:37.397] - globals found: [1] ‘{’
[17:39:37.397] Searching for globals ... DONE
[17:39:37.397] Resolving globals: FALSE
[17:39:37.398] 
[17:39:37.398] 
[17:39:37.398] getGlobalsAndPackages() ... DONE
[17:39:37.398] plan(): Setting new future strategy stack:
[17:39:37.398] run() for ‘Future’ ...
[17:39:37.399] - state: ‘created’
[17:39:37.398] List of future strategies:
[17:39:37.398] 1. multicore:
[17:39:37.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.398]    - tweaked: FALSE
[17:39:37.398]    - call: plan(strategy)
[17:39:37.399] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.404] plan(): nbrOfWorkers() = 2
[17:39:37.404] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.404]   - Field: ‘label’
[17:39:37.404]   - Field: ‘local’
[17:39:37.404]   - Field: ‘owner’
[17:39:37.405]   - Field: ‘envir’
[17:39:37.405]   - Field: ‘workers’
[17:39:37.405]   - Field: ‘packages’
[17:39:37.405]   - Field: ‘gc’
[17:39:37.405]   - Field: ‘job’
[17:39:37.405]   - Field: ‘conditions’
[17:39:37.405]   - Field: ‘expr’
[17:39:37.406]   - Field: ‘uuid’
[17:39:37.406]   - Field: ‘seed’
[17:39:37.406]   - Field: ‘version’
[17:39:37.406]   - Field: ‘result’
[17:39:37.406]   - Field: ‘asynchronous’
[17:39:37.406]   - Field: ‘calls’
[17:39:37.407]   - Field: ‘globals’
[17:39:37.407]   - Field: ‘stdout’
[17:39:37.407]   - Field: ‘earlySignal’
[17:39:37.407]   - Field: ‘lazy’
[17:39:37.407]   - Field: ‘state’
[17:39:37.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.407] - Launch lazy future ...
[17:39:37.408] Packages needed by the future expression (n = 0): <none>
[17:39:37.408] Packages needed by future strategies (n = 0): <none>
[17:39:37.409] {
[17:39:37.409]     {
[17:39:37.409]         {
[17:39:37.409]             ...future.startTime <- base::Sys.time()
[17:39:37.409]             {
[17:39:37.409]                 {
[17:39:37.409]                   {
[17:39:37.409]                     {
[17:39:37.409]                       base::local({
[17:39:37.409]                         has_future <- base::requireNamespace("future", 
[17:39:37.409]                           quietly = TRUE)
[17:39:37.409]                         if (has_future) {
[17:39:37.409]                           ns <- base::getNamespace("future")
[17:39:37.409]                           version <- ns[[".package"]][["version"]]
[17:39:37.409]                           if (is.null(version)) 
[17:39:37.409]                             version <- utils::packageVersion("future")
[17:39:37.409]                         }
[17:39:37.409]                         else {
[17:39:37.409]                           version <- NULL
[17:39:37.409]                         }
[17:39:37.409]                         if (!has_future || version < "1.8.0") {
[17:39:37.409]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.409]                             "", base::R.version$version.string), 
[17:39:37.409]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.409]                               "release", "version")], collapse = " "), 
[17:39:37.409]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.409]                             info)
[17:39:37.409]                           info <- base::paste(info, collapse = "; ")
[17:39:37.409]                           if (!has_future) {
[17:39:37.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.409]                               info)
[17:39:37.409]                           }
[17:39:37.409]                           else {
[17:39:37.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.409]                               info, version)
[17:39:37.409]                           }
[17:39:37.409]                           base::stop(msg)
[17:39:37.409]                         }
[17:39:37.409]                       })
[17:39:37.409]                     }
[17:39:37.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.409]                     base::options(mc.cores = 1L)
[17:39:37.409]                   }
[17:39:37.409]                   ...future.strategy.old <- future::plan("list")
[17:39:37.409]                   options(future.plan = NULL)
[17:39:37.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.409]                 }
[17:39:37.409]                 ...future.workdir <- getwd()
[17:39:37.409]             }
[17:39:37.409]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.409]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.409]         }
[17:39:37.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.409]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.409]             base::names(...future.oldOptions))
[17:39:37.409]     }
[17:39:37.409]     if (FALSE) {
[17:39:37.409]     }
[17:39:37.409]     else {
[17:39:37.409]         if (TRUE) {
[17:39:37.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.409]                 open = "w")
[17:39:37.409]         }
[17:39:37.409]         else {
[17:39:37.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.409]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.409]         }
[17:39:37.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.409]             base::sink(type = "output", split = FALSE)
[17:39:37.409]             base::close(...future.stdout)
[17:39:37.409]         }, add = TRUE)
[17:39:37.409]     }
[17:39:37.409]     ...future.frame <- base::sys.nframe()
[17:39:37.409]     ...future.conditions <- base::list()
[17:39:37.409]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.409]     if (FALSE) {
[17:39:37.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.409]     }
[17:39:37.409]     ...future.result <- base::tryCatch({
[17:39:37.409]         base::withCallingHandlers({
[17:39:37.409]             ...future.value <- base::withVisible(base::local({
[17:39:37.409]                 withCallingHandlers({
[17:39:37.409]                   {
[17:39:37.409]                     4
[17:39:37.409]                   }
[17:39:37.409]                 }, immediateCondition = function(cond) {
[17:39:37.409]                   save_rds <- function (object, pathname, ...) 
[17:39:37.409]                   {
[17:39:37.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.409]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.409]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.409]                         fi_tmp[["mtime"]])
[17:39:37.409]                     }
[17:39:37.409]                     tryCatch({
[17:39:37.409]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.409]                     }, error = function(ex) {
[17:39:37.409]                       msg <- conditionMessage(ex)
[17:39:37.409]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.409]                         fi_tmp[["mtime"]], msg)
[17:39:37.409]                       ex$message <- msg
[17:39:37.409]                       stop(ex)
[17:39:37.409]                     })
[17:39:37.409]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.409]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.409]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.409]                       fi <- file.info(pathname)
[17:39:37.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.409]                         fi[["size"]], fi[["mtime"]])
[17:39:37.409]                       stop(msg)
[17:39:37.409]                     }
[17:39:37.409]                     invisible(pathname)
[17:39:37.409]                   }
[17:39:37.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.409]                     rootPath = tempdir()) 
[17:39:37.409]                   {
[17:39:37.409]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.409]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.409]                       tmpdir = path, fileext = ".rds")
[17:39:37.409]                     save_rds(obj, file)
[17:39:37.409]                   }
[17:39:37.409]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.409]                   {
[17:39:37.409]                     inherits <- base::inherits
[17:39:37.409]                     invokeRestart <- base::invokeRestart
[17:39:37.409]                     is.null <- base::is.null
[17:39:37.409]                     muffled <- FALSE
[17:39:37.409]                     if (inherits(cond, "message")) {
[17:39:37.409]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.409]                       if (muffled) 
[17:39:37.409]                         invokeRestart("muffleMessage")
[17:39:37.409]                     }
[17:39:37.409]                     else if (inherits(cond, "warning")) {
[17:39:37.409]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.409]                       if (muffled) 
[17:39:37.409]                         invokeRestart("muffleWarning")
[17:39:37.409]                     }
[17:39:37.409]                     else if (inherits(cond, "condition")) {
[17:39:37.409]                       if (!is.null(pattern)) {
[17:39:37.409]                         computeRestarts <- base::computeRestarts
[17:39:37.409]                         grepl <- base::grepl
[17:39:37.409]                         restarts <- computeRestarts(cond)
[17:39:37.409]                         for (restart in restarts) {
[17:39:37.409]                           name <- restart$name
[17:39:37.409]                           if (is.null(name)) 
[17:39:37.409]                             next
[17:39:37.409]                           if (!grepl(pattern, name)) 
[17:39:37.409]                             next
[17:39:37.409]                           invokeRestart(restart)
[17:39:37.409]                           muffled <- TRUE
[17:39:37.409]                           break
[17:39:37.409]                         }
[17:39:37.409]                       }
[17:39:37.409]                     }
[17:39:37.409]                     invisible(muffled)
[17:39:37.409]                   }
[17:39:37.409]                   muffleCondition(cond)
[17:39:37.409]                 })
[17:39:37.409]             }))
[17:39:37.409]             future::FutureResult(value = ...future.value$value, 
[17:39:37.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.409]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.409]                     ...future.globalenv.names))
[17:39:37.409]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.409]         }, condition = base::local({
[17:39:37.409]             c <- base::c
[17:39:37.409]             inherits <- base::inherits
[17:39:37.409]             invokeRestart <- base::invokeRestart
[17:39:37.409]             length <- base::length
[17:39:37.409]             list <- base::list
[17:39:37.409]             seq.int <- base::seq.int
[17:39:37.409]             signalCondition <- base::signalCondition
[17:39:37.409]             sys.calls <- base::sys.calls
[17:39:37.409]             `[[` <- base::`[[`
[17:39:37.409]             `+` <- base::`+`
[17:39:37.409]             `<<-` <- base::`<<-`
[17:39:37.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.409]                   3L)]
[17:39:37.409]             }
[17:39:37.409]             function(cond) {
[17:39:37.409]                 is_error <- inherits(cond, "error")
[17:39:37.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.409]                   NULL)
[17:39:37.409]                 if (is_error) {
[17:39:37.409]                   sessionInformation <- function() {
[17:39:37.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.409]                       search = base::search(), system = base::Sys.info())
[17:39:37.409]                   }
[17:39:37.409]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.409]                     cond$call), session = sessionInformation(), 
[17:39:37.409]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.409]                   signalCondition(cond)
[17:39:37.409]                 }
[17:39:37.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.409]                 "immediateCondition"))) {
[17:39:37.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.409]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.409]                   if (TRUE && !signal) {
[17:39:37.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.409]                     {
[17:39:37.409]                       inherits <- base::inherits
[17:39:37.409]                       invokeRestart <- base::invokeRestart
[17:39:37.409]                       is.null <- base::is.null
[17:39:37.409]                       muffled <- FALSE
[17:39:37.409]                       if (inherits(cond, "message")) {
[17:39:37.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.409]                         if (muffled) 
[17:39:37.409]                           invokeRestart("muffleMessage")
[17:39:37.409]                       }
[17:39:37.409]                       else if (inherits(cond, "warning")) {
[17:39:37.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.409]                         if (muffled) 
[17:39:37.409]                           invokeRestart("muffleWarning")
[17:39:37.409]                       }
[17:39:37.409]                       else if (inherits(cond, "condition")) {
[17:39:37.409]                         if (!is.null(pattern)) {
[17:39:37.409]                           computeRestarts <- base::computeRestarts
[17:39:37.409]                           grepl <- base::grepl
[17:39:37.409]                           restarts <- computeRestarts(cond)
[17:39:37.409]                           for (restart in restarts) {
[17:39:37.409]                             name <- restart$name
[17:39:37.409]                             if (is.null(name)) 
[17:39:37.409]                               next
[17:39:37.409]                             if (!grepl(pattern, name)) 
[17:39:37.409]                               next
[17:39:37.409]                             invokeRestart(restart)
[17:39:37.409]                             muffled <- TRUE
[17:39:37.409]                             break
[17:39:37.409]                           }
[17:39:37.409]                         }
[17:39:37.409]                       }
[17:39:37.409]                       invisible(muffled)
[17:39:37.409]                     }
[17:39:37.409]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.409]                   }
[17:39:37.409]                 }
[17:39:37.409]                 else {
[17:39:37.409]                   if (TRUE) {
[17:39:37.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.409]                     {
[17:39:37.409]                       inherits <- base::inherits
[17:39:37.409]                       invokeRestart <- base::invokeRestart
[17:39:37.409]                       is.null <- base::is.null
[17:39:37.409]                       muffled <- FALSE
[17:39:37.409]                       if (inherits(cond, "message")) {
[17:39:37.409]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.409]                         if (muffled) 
[17:39:37.409]                           invokeRestart("muffleMessage")
[17:39:37.409]                       }
[17:39:37.409]                       else if (inherits(cond, "warning")) {
[17:39:37.409]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.409]                         if (muffled) 
[17:39:37.409]                           invokeRestart("muffleWarning")
[17:39:37.409]                       }
[17:39:37.409]                       else if (inherits(cond, "condition")) {
[17:39:37.409]                         if (!is.null(pattern)) {
[17:39:37.409]                           computeRestarts <- base::computeRestarts
[17:39:37.409]                           grepl <- base::grepl
[17:39:37.409]                           restarts <- computeRestarts(cond)
[17:39:37.409]                           for (restart in restarts) {
[17:39:37.409]                             name <- restart$name
[17:39:37.409]                             if (is.null(name)) 
[17:39:37.409]                               next
[17:39:37.409]                             if (!grepl(pattern, name)) 
[17:39:37.409]                               next
[17:39:37.409]                             invokeRestart(restart)
[17:39:37.409]                             muffled <- TRUE
[17:39:37.409]                             break
[17:39:37.409]                           }
[17:39:37.409]                         }
[17:39:37.409]                       }
[17:39:37.409]                       invisible(muffled)
[17:39:37.409]                     }
[17:39:37.409]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.409]                   }
[17:39:37.409]                 }
[17:39:37.409]             }
[17:39:37.409]         }))
[17:39:37.409]     }, error = function(ex) {
[17:39:37.409]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.409]                 ...future.rng), started = ...future.startTime, 
[17:39:37.409]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.409]             version = "1.8"), class = "FutureResult")
[17:39:37.409]     }, finally = {
[17:39:37.409]         if (!identical(...future.workdir, getwd())) 
[17:39:37.409]             setwd(...future.workdir)
[17:39:37.409]         {
[17:39:37.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.409]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.409]             }
[17:39:37.409]             base::options(...future.oldOptions)
[17:39:37.409]             if (.Platform$OS.type == "windows") {
[17:39:37.409]                 old_names <- names(...future.oldEnvVars)
[17:39:37.409]                 envs <- base::Sys.getenv()
[17:39:37.409]                 names <- names(envs)
[17:39:37.409]                 common <- intersect(names, old_names)
[17:39:37.409]                 added <- setdiff(names, old_names)
[17:39:37.409]                 removed <- setdiff(old_names, names)
[17:39:37.409]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.409]                   envs[common]]
[17:39:37.409]                 NAMES <- toupper(changed)
[17:39:37.409]                 args <- list()
[17:39:37.409]                 for (kk in seq_along(NAMES)) {
[17:39:37.409]                   name <- changed[[kk]]
[17:39:37.409]                   NAME <- NAMES[[kk]]
[17:39:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.409]                     next
[17:39:37.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.409]                 }
[17:39:37.409]                 NAMES <- toupper(added)
[17:39:37.409]                 for (kk in seq_along(NAMES)) {
[17:39:37.409]                   name <- added[[kk]]
[17:39:37.409]                   NAME <- NAMES[[kk]]
[17:39:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.409]                     next
[17:39:37.409]                   args[[name]] <- ""
[17:39:37.409]                 }
[17:39:37.409]                 NAMES <- toupper(removed)
[17:39:37.409]                 for (kk in seq_along(NAMES)) {
[17:39:37.409]                   name <- removed[[kk]]
[17:39:37.409]                   NAME <- NAMES[[kk]]
[17:39:37.409]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.409]                     next
[17:39:37.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.409]                 }
[17:39:37.409]                 if (length(args) > 0) 
[17:39:37.409]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.409]             }
[17:39:37.409]             else {
[17:39:37.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.409]             }
[17:39:37.409]             {
[17:39:37.409]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.409]                   0L) {
[17:39:37.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.409]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.409]                   base::options(opts)
[17:39:37.409]                 }
[17:39:37.409]                 {
[17:39:37.409]                   {
[17:39:37.409]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.409]                     NULL
[17:39:37.409]                   }
[17:39:37.409]                   options(future.plan = NULL)
[17:39:37.409]                   if (is.na(NA_character_)) 
[17:39:37.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.409]                     .init = FALSE)
[17:39:37.409]                 }
[17:39:37.409]             }
[17:39:37.409]         }
[17:39:37.409]     })
[17:39:37.409]     if (TRUE) {
[17:39:37.409]         base::sink(type = "output", split = FALSE)
[17:39:37.409]         if (TRUE) {
[17:39:37.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.409]         }
[17:39:37.409]         else {
[17:39:37.409]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.409]         }
[17:39:37.409]         base::close(...future.stdout)
[17:39:37.409]         ...future.stdout <- NULL
[17:39:37.409]     }
[17:39:37.409]     ...future.result$conditions <- ...future.conditions
[17:39:37.409]     ...future.result$finished <- base::Sys.time()
[17:39:37.409]     ...future.result
[17:39:37.409] }
[17:39:37.413] requestCore(): workers = 2
[17:39:37.413] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:37.424] result() for MulticoreFuture ...
[17:39:37.425] result() for MulticoreFuture ...
[17:39:37.425] result() for MulticoreFuture ... done
[17:39:37.425] result() for MulticoreFuture ... done
[17:39:37.425] result() for MulticoreFuture ...
[17:39:37.425] result() for MulticoreFuture ... done
[17:39:37.428] MulticoreFuture started
[17:39:37.429] - Launch lazy future ... done
[17:39:37.429] run() for ‘MulticoreFuture’ ... done
[17:39:37.429] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55adf21e05f0> 
[17:39:37.430] List of future strategies:
[17:39:37.430] 1. sequential:
[17:39:37.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.430]    - tweaked: FALSE
[17:39:37.430]    - call: NULL
[17:39:37.431] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55adefa819a8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[17:39:37.434] plan(): Setting new future strategy stack:
List of 2
  ..$ :[17:39:37.434] List of future strategies:
[17:39:37.434] 1. multicore:
[17:39:37.434]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.434]    - tweaked: FALSE
[17:39:37.434]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:39:37.441] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:37.445] resolve() on list environment ...
[17:39:37.445]  recursive: 0
[17:39:37.447]  length: 6
[17:39:37.447]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:37.448] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.448] - nx: 6
[17:39:37.448] - relay: TRUE
[17:39:37.448] - stdout: TRUE
[17:39:37.448] - signal: TRUE
[17:39:37.448] - resignal: FALSE
[17:39:37.449] - force: TRUE
[17:39:37.449] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.449] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.449]  - until=2
[17:39:37.449]  - relaying element #2
[17:39:37.449] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.450] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.450] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.450]  length: 5 (resolved future 1)
[17:39:37.450] Future #2
[17:39:37.450] result() for MulticoreFuture ...
[17:39:37.450] result() for MulticoreFuture ... done
[17:39:37.451] result() for MulticoreFuture ...
[17:39:37.451] result() for MulticoreFuture ... done
[17:39:37.451] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:37.451] - nx: 6
[17:39:37.451] - relay: TRUE
[17:39:37.451] - stdout: TRUE
[17:39:37.451] - signal: TRUE
[17:39:37.452] - resignal: FALSE
[17:39:37.452] - force: TRUE
[17:39:37.452] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.452] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.452]  - until=2
[17:39:37.452]  - relaying element #2
[17:39:37.452] result() for MulticoreFuture ...
[17:39:37.452] result() for MulticoreFuture ... done
[17:39:37.453] result() for MulticoreFuture ...
[17:39:37.453] result() for MulticoreFuture ... done
[17:39:37.453] result() for MulticoreFuture ...
[17:39:37.453] result() for MulticoreFuture ... done
[17:39:37.453] result() for MulticoreFuture ...
[17:39:37.453] result() for MulticoreFuture ... done
[17:39:37.453] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.454] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.454] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:37.454]  length: 4 (resolved future 2)
[17:39:37.454] Future #3
[17:39:37.454] result() for MulticoreFuture ...
[17:39:37.455] result() for MulticoreFuture ...
[17:39:37.455] result() for MulticoreFuture ... done
[17:39:37.456] result() for MulticoreFuture ... done
[17:39:37.456] result() for MulticoreFuture ...
[17:39:37.456] result() for MulticoreFuture ... done
[17:39:37.456] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:37.456] - nx: 6
[17:39:37.456] - relay: TRUE
[17:39:37.456] - stdout: TRUE
[17:39:37.457] - signal: TRUE
[17:39:37.457] - resignal: FALSE
[17:39:37.457] - force: TRUE
[17:39:37.457] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.457] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.457]  - until=3
[17:39:37.457]  - relaying element #3
[17:39:37.457] result() for MulticoreFuture ...
[17:39:37.458] result() for MulticoreFuture ... done
[17:39:37.458] result() for MulticoreFuture ...
[17:39:37.458] result() for MulticoreFuture ... done
[17:39:37.458] result() for MulticoreFuture ...
[17:39:37.458] result() for MulticoreFuture ... done
[17:39:37.458] result() for MulticoreFuture ...
[17:39:37.458] result() for MulticoreFuture ... done
[17:39:37.459] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.459] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.459] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:37.459]  length: 3 (resolved future 3)
[17:39:37.459] Future #4
[17:39:37.460] result() for MulticoreFuture ...
[17:39:37.460] result() for MulticoreFuture ...
[17:39:37.460] result() for MulticoreFuture ... done
[17:39:37.461] result() for MulticoreFuture ... done
[17:39:37.461] result() for MulticoreFuture ...
[17:39:37.461] result() for MulticoreFuture ... done
[17:39:37.461] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:37.461] - nx: 6
[17:39:37.462] - relay: TRUE
[17:39:37.462] - stdout: TRUE
[17:39:37.462] - signal: TRUE
[17:39:37.462] - resignal: FALSE
[17:39:37.462] - force: TRUE
[17:39:37.462] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.462] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.463]  - until=4
[17:39:37.463]  - relaying element #4
[17:39:37.463] result() for MulticoreFuture ...
[17:39:37.463] result() for MulticoreFuture ... done
[17:39:37.463] result() for MulticoreFuture ...
[17:39:37.463] result() for MulticoreFuture ... done
[17:39:37.464] result() for MulticoreFuture ...
[17:39:37.464] result() for MulticoreFuture ... done
[17:39:37.464] result() for MulticoreFuture ...
[17:39:37.464] result() for MulticoreFuture ... done
[17:39:37.464] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.464] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.465] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:37.465]  length: 2 (resolved future 4)
[17:39:37.465] signalConditionsASAP(NULL, pos=5) ...
[17:39:37.465] - nx: 6
[17:39:37.465] - relay: TRUE
[17:39:37.465] - stdout: TRUE
[17:39:37.465] - signal: TRUE
[17:39:37.465] - resignal: FALSE
[17:39:37.465] - force: TRUE
[17:39:37.465] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.466] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.466]  - until=6
[17:39:37.466]  - relaying element #6
[17:39:37.466] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.466] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.466] signalConditionsASAP(NULL, pos=5) ... done
[17:39:37.466]  length: 1 (resolved future 5)
[17:39:37.466] signalConditionsASAP(numeric, pos=6) ...
[17:39:37.466] - nx: 6
[17:39:37.466] - relay: TRUE
[17:39:37.467] - stdout: TRUE
[17:39:37.467] - signal: TRUE
[17:39:37.467] - resignal: FALSE
[17:39:37.467] - force: TRUE
[17:39:37.467] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.467] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.467]  - until=6
[17:39:37.467] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.467] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.467] signalConditionsASAP(numeric, pos=6) ... done
[17:39:37.468]  length: 0 (resolved future 6)
[17:39:37.468] Relaying remaining futures
[17:39:37.468] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.468] - nx: 6
[17:39:37.468] - relay: TRUE
[17:39:37.468] - stdout: TRUE
[17:39:37.468] - signal: TRUE
[17:39:37.468] - resignal: FALSE
[17:39:37.468] - force: TRUE
[17:39:37.468] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.468] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:37.469] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.469] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.469] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.469] resolve() on list environment ... DONE
[17:39:37.469] result() for MulticoreFuture ...
[17:39:37.469] result() for MulticoreFuture ... done
[17:39:37.469] result() for MulticoreFuture ...
[17:39:37.469] result() for MulticoreFuture ... done
[17:39:37.470] result() for MulticoreFuture ...
[17:39:37.470] result() for MulticoreFuture ... done
[17:39:37.470] result() for MulticoreFuture ...
[17:39:37.470] result() for MulticoreFuture ... done
[17:39:37.470] result() for MulticoreFuture ...
[17:39:37.470] result() for MulticoreFuture ... done
[17:39:37.470] result() for MulticoreFuture ...
[17:39:37.470] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adee69fc00> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:37.473] getGlobalsAndPackages() ...
[17:39:37.473] Searching for globals...
[17:39:37.473] 
[17:39:37.473] Searching for globals ... DONE
[17:39:37.473] - globals: [0] <none>
[17:39:37.473] getGlobalsAndPackages() ... DONE
[17:39:37.474] run() for ‘Future’ ...
[17:39:37.474] - state: ‘created’
[17:39:37.474] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.478] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.479]   - Field: ‘label’
[17:39:37.479]   - Field: ‘local’
[17:39:37.479]   - Field: ‘owner’
[17:39:37.479]   - Field: ‘envir’
[17:39:37.479]   - Field: ‘workers’
[17:39:37.479]   - Field: ‘packages’
[17:39:37.479]   - Field: ‘gc’
[17:39:37.479]   - Field: ‘job’
[17:39:37.479]   - Field: ‘conditions’
[17:39:37.480]   - Field: ‘expr’
[17:39:37.480]   - Field: ‘uuid’
[17:39:37.480]   - Field: ‘seed’
[17:39:37.480]   - Field: ‘version’
[17:39:37.480]   - Field: ‘result’
[17:39:37.480]   - Field: ‘asynchronous’
[17:39:37.480]   - Field: ‘calls’
[17:39:37.480]   - Field: ‘globals’
[17:39:37.480]   - Field: ‘stdout’
[17:39:37.481]   - Field: ‘earlySignal’
[17:39:37.481]   - Field: ‘lazy’
[17:39:37.481]   - Field: ‘state’
[17:39:37.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.481] - Launch lazy future ...
[17:39:37.481] Packages needed by the future expression (n = 0): <none>
[17:39:37.481] Packages needed by future strategies (n = 0): <none>
[17:39:37.482] {
[17:39:37.482]     {
[17:39:37.482]         {
[17:39:37.482]             ...future.startTime <- base::Sys.time()
[17:39:37.482]             {
[17:39:37.482]                 {
[17:39:37.482]                   {
[17:39:37.482]                     {
[17:39:37.482]                       base::local({
[17:39:37.482]                         has_future <- base::requireNamespace("future", 
[17:39:37.482]                           quietly = TRUE)
[17:39:37.482]                         if (has_future) {
[17:39:37.482]                           ns <- base::getNamespace("future")
[17:39:37.482]                           version <- ns[[".package"]][["version"]]
[17:39:37.482]                           if (is.null(version)) 
[17:39:37.482]                             version <- utils::packageVersion("future")
[17:39:37.482]                         }
[17:39:37.482]                         else {
[17:39:37.482]                           version <- NULL
[17:39:37.482]                         }
[17:39:37.482]                         if (!has_future || version < "1.8.0") {
[17:39:37.482]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.482]                             "", base::R.version$version.string), 
[17:39:37.482]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.482]                               "release", "version")], collapse = " "), 
[17:39:37.482]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.482]                             info)
[17:39:37.482]                           info <- base::paste(info, collapse = "; ")
[17:39:37.482]                           if (!has_future) {
[17:39:37.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.482]                               info)
[17:39:37.482]                           }
[17:39:37.482]                           else {
[17:39:37.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.482]                               info, version)
[17:39:37.482]                           }
[17:39:37.482]                           base::stop(msg)
[17:39:37.482]                         }
[17:39:37.482]                       })
[17:39:37.482]                     }
[17:39:37.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.482]                     base::options(mc.cores = 1L)
[17:39:37.482]                   }
[17:39:37.482]                   ...future.strategy.old <- future::plan("list")
[17:39:37.482]                   options(future.plan = NULL)
[17:39:37.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.482]                 }
[17:39:37.482]                 ...future.workdir <- getwd()
[17:39:37.482]             }
[17:39:37.482]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.482]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.482]         }
[17:39:37.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.482]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.482]             base::names(...future.oldOptions))
[17:39:37.482]     }
[17:39:37.482]     if (FALSE) {
[17:39:37.482]     }
[17:39:37.482]     else {
[17:39:37.482]         if (TRUE) {
[17:39:37.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.482]                 open = "w")
[17:39:37.482]         }
[17:39:37.482]         else {
[17:39:37.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.482]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.482]         }
[17:39:37.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.482]             base::sink(type = "output", split = FALSE)
[17:39:37.482]             base::close(...future.stdout)
[17:39:37.482]         }, add = TRUE)
[17:39:37.482]     }
[17:39:37.482]     ...future.frame <- base::sys.nframe()
[17:39:37.482]     ...future.conditions <- base::list()
[17:39:37.482]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.482]     if (FALSE) {
[17:39:37.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.482]     }
[17:39:37.482]     ...future.result <- base::tryCatch({
[17:39:37.482]         base::withCallingHandlers({
[17:39:37.482]             ...future.value <- base::withVisible(base::local({
[17:39:37.482]                 withCallingHandlers({
[17:39:37.482]                   2
[17:39:37.482]                 }, immediateCondition = function(cond) {
[17:39:37.482]                   save_rds <- function (object, pathname, ...) 
[17:39:37.482]                   {
[17:39:37.482]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.482]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.482]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.482]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.482]                         fi_tmp[["mtime"]])
[17:39:37.482]                     }
[17:39:37.482]                     tryCatch({
[17:39:37.482]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.482]                     }, error = function(ex) {
[17:39:37.482]                       msg <- conditionMessage(ex)
[17:39:37.482]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.482]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.482]                         fi_tmp[["mtime"]], msg)
[17:39:37.482]                       ex$message <- msg
[17:39:37.482]                       stop(ex)
[17:39:37.482]                     })
[17:39:37.482]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.482]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.482]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.482]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.482]                       fi <- file.info(pathname)
[17:39:37.482]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.482]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.482]                         fi[["size"]], fi[["mtime"]])
[17:39:37.482]                       stop(msg)
[17:39:37.482]                     }
[17:39:37.482]                     invisible(pathname)
[17:39:37.482]                   }
[17:39:37.482]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.482]                     rootPath = tempdir()) 
[17:39:37.482]                   {
[17:39:37.482]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.482]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.482]                       tmpdir = path, fileext = ".rds")
[17:39:37.482]                     save_rds(obj, file)
[17:39:37.482]                   }
[17:39:37.482]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.482]                   {
[17:39:37.482]                     inherits <- base::inherits
[17:39:37.482]                     invokeRestart <- base::invokeRestart
[17:39:37.482]                     is.null <- base::is.null
[17:39:37.482]                     muffled <- FALSE
[17:39:37.482]                     if (inherits(cond, "message")) {
[17:39:37.482]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.482]                       if (muffled) 
[17:39:37.482]                         invokeRestart("muffleMessage")
[17:39:37.482]                     }
[17:39:37.482]                     else if (inherits(cond, "warning")) {
[17:39:37.482]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.482]                       if (muffled) 
[17:39:37.482]                         invokeRestart("muffleWarning")
[17:39:37.482]                     }
[17:39:37.482]                     else if (inherits(cond, "condition")) {
[17:39:37.482]                       if (!is.null(pattern)) {
[17:39:37.482]                         computeRestarts <- base::computeRestarts
[17:39:37.482]                         grepl <- base::grepl
[17:39:37.482]                         restarts <- computeRestarts(cond)
[17:39:37.482]                         for (restart in restarts) {
[17:39:37.482]                           name <- restart$name
[17:39:37.482]                           if (is.null(name)) 
[17:39:37.482]                             next
[17:39:37.482]                           if (!grepl(pattern, name)) 
[17:39:37.482]                             next
[17:39:37.482]                           invokeRestart(restart)
[17:39:37.482]                           muffled <- TRUE
[17:39:37.482]                           break
[17:39:37.482]                         }
[17:39:37.482]                       }
[17:39:37.482]                     }
[17:39:37.482]                     invisible(muffled)
[17:39:37.482]                   }
[17:39:37.482]                   muffleCondition(cond)
[17:39:37.482]                 })
[17:39:37.482]             }))
[17:39:37.482]             future::FutureResult(value = ...future.value$value, 
[17:39:37.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.482]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.482]                     ...future.globalenv.names))
[17:39:37.482]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.482]         }, condition = base::local({
[17:39:37.482]             c <- base::c
[17:39:37.482]             inherits <- base::inherits
[17:39:37.482]             invokeRestart <- base::invokeRestart
[17:39:37.482]             length <- base::length
[17:39:37.482]             list <- base::list
[17:39:37.482]             seq.int <- base::seq.int
[17:39:37.482]             signalCondition <- base::signalCondition
[17:39:37.482]             sys.calls <- base::sys.calls
[17:39:37.482]             `[[` <- base::`[[`
[17:39:37.482]             `+` <- base::`+`
[17:39:37.482]             `<<-` <- base::`<<-`
[17:39:37.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.482]                   3L)]
[17:39:37.482]             }
[17:39:37.482]             function(cond) {
[17:39:37.482]                 is_error <- inherits(cond, "error")
[17:39:37.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.482]                   NULL)
[17:39:37.482]                 if (is_error) {
[17:39:37.482]                   sessionInformation <- function() {
[17:39:37.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.482]                       search = base::search(), system = base::Sys.info())
[17:39:37.482]                   }
[17:39:37.482]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.482]                     cond$call), session = sessionInformation(), 
[17:39:37.482]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.482]                   signalCondition(cond)
[17:39:37.482]                 }
[17:39:37.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.482]                 "immediateCondition"))) {
[17:39:37.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.482]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.482]                   if (TRUE && !signal) {
[17:39:37.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.482]                     {
[17:39:37.482]                       inherits <- base::inherits
[17:39:37.482]                       invokeRestart <- base::invokeRestart
[17:39:37.482]                       is.null <- base::is.null
[17:39:37.482]                       muffled <- FALSE
[17:39:37.482]                       if (inherits(cond, "message")) {
[17:39:37.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.482]                         if (muffled) 
[17:39:37.482]                           invokeRestart("muffleMessage")
[17:39:37.482]                       }
[17:39:37.482]                       else if (inherits(cond, "warning")) {
[17:39:37.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.482]                         if (muffled) 
[17:39:37.482]                           invokeRestart("muffleWarning")
[17:39:37.482]                       }
[17:39:37.482]                       else if (inherits(cond, "condition")) {
[17:39:37.482]                         if (!is.null(pattern)) {
[17:39:37.482]                           computeRestarts <- base::computeRestarts
[17:39:37.482]                           grepl <- base::grepl
[17:39:37.482]                           restarts <- computeRestarts(cond)
[17:39:37.482]                           for (restart in restarts) {
[17:39:37.482]                             name <- restart$name
[17:39:37.482]                             if (is.null(name)) 
[17:39:37.482]                               next
[17:39:37.482]                             if (!grepl(pattern, name)) 
[17:39:37.482]                               next
[17:39:37.482]                             invokeRestart(restart)
[17:39:37.482]                             muffled <- TRUE
[17:39:37.482]                             break
[17:39:37.482]                           }
[17:39:37.482]                         }
[17:39:37.482]                       }
[17:39:37.482]                       invisible(muffled)
[17:39:37.482]                     }
[17:39:37.482]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.482]                   }
[17:39:37.482]                 }
[17:39:37.482]                 else {
[17:39:37.482]                   if (TRUE) {
[17:39:37.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.482]                     {
[17:39:37.482]                       inherits <- base::inherits
[17:39:37.482]                       invokeRestart <- base::invokeRestart
[17:39:37.482]                       is.null <- base::is.null
[17:39:37.482]                       muffled <- FALSE
[17:39:37.482]                       if (inherits(cond, "message")) {
[17:39:37.482]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.482]                         if (muffled) 
[17:39:37.482]                           invokeRestart("muffleMessage")
[17:39:37.482]                       }
[17:39:37.482]                       else if (inherits(cond, "warning")) {
[17:39:37.482]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.482]                         if (muffled) 
[17:39:37.482]                           invokeRestart("muffleWarning")
[17:39:37.482]                       }
[17:39:37.482]                       else if (inherits(cond, "condition")) {
[17:39:37.482]                         if (!is.null(pattern)) {
[17:39:37.482]                           computeRestarts <- base::computeRestarts
[17:39:37.482]                           grepl <- base::grepl
[17:39:37.482]                           restarts <- computeRestarts(cond)
[17:39:37.482]                           for (restart in restarts) {
[17:39:37.482]                             name <- restart$name
[17:39:37.482]                             if (is.null(name)) 
[17:39:37.482]                               next
[17:39:37.482]                             if (!grepl(pattern, name)) 
[17:39:37.482]                               next
[17:39:37.482]                             invokeRestart(restart)
[17:39:37.482]                             muffled <- TRUE
[17:39:37.482]                             break
[17:39:37.482]                           }
[17:39:37.482]                         }
[17:39:37.482]                       }
[17:39:37.482]                       invisible(muffled)
[17:39:37.482]                     }
[17:39:37.482]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.482]                   }
[17:39:37.482]                 }
[17:39:37.482]             }
[17:39:37.482]         }))
[17:39:37.482]     }, error = function(ex) {
[17:39:37.482]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.482]                 ...future.rng), started = ...future.startTime, 
[17:39:37.482]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.482]             version = "1.8"), class = "FutureResult")
[17:39:37.482]     }, finally = {
[17:39:37.482]         if (!identical(...future.workdir, getwd())) 
[17:39:37.482]             setwd(...future.workdir)
[17:39:37.482]         {
[17:39:37.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.482]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.482]             }
[17:39:37.482]             base::options(...future.oldOptions)
[17:39:37.482]             if (.Platform$OS.type == "windows") {
[17:39:37.482]                 old_names <- names(...future.oldEnvVars)
[17:39:37.482]                 envs <- base::Sys.getenv()
[17:39:37.482]                 names <- names(envs)
[17:39:37.482]                 common <- intersect(names, old_names)
[17:39:37.482]                 added <- setdiff(names, old_names)
[17:39:37.482]                 removed <- setdiff(old_names, names)
[17:39:37.482]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.482]                   envs[common]]
[17:39:37.482]                 NAMES <- toupper(changed)
[17:39:37.482]                 args <- list()
[17:39:37.482]                 for (kk in seq_along(NAMES)) {
[17:39:37.482]                   name <- changed[[kk]]
[17:39:37.482]                   NAME <- NAMES[[kk]]
[17:39:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.482]                     next
[17:39:37.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.482]                 }
[17:39:37.482]                 NAMES <- toupper(added)
[17:39:37.482]                 for (kk in seq_along(NAMES)) {
[17:39:37.482]                   name <- added[[kk]]
[17:39:37.482]                   NAME <- NAMES[[kk]]
[17:39:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.482]                     next
[17:39:37.482]                   args[[name]] <- ""
[17:39:37.482]                 }
[17:39:37.482]                 NAMES <- toupper(removed)
[17:39:37.482]                 for (kk in seq_along(NAMES)) {
[17:39:37.482]                   name <- removed[[kk]]
[17:39:37.482]                   NAME <- NAMES[[kk]]
[17:39:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.482]                     next
[17:39:37.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.482]                 }
[17:39:37.482]                 if (length(args) > 0) 
[17:39:37.482]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.482]             }
[17:39:37.482]             else {
[17:39:37.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.482]             }
[17:39:37.482]             {
[17:39:37.482]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.482]                   0L) {
[17:39:37.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.482]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.482]                   base::options(opts)
[17:39:37.482]                 }
[17:39:37.482]                 {
[17:39:37.482]                   {
[17:39:37.482]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.482]                     NULL
[17:39:37.482]                   }
[17:39:37.482]                   options(future.plan = NULL)
[17:39:37.482]                   if (is.na(NA_character_)) 
[17:39:37.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.482]                     .init = FALSE)
[17:39:37.482]                 }
[17:39:37.482]             }
[17:39:37.482]         }
[17:39:37.482]     })
[17:39:37.482]     if (TRUE) {
[17:39:37.482]         base::sink(type = "output", split = FALSE)
[17:39:37.482]         if (TRUE) {
[17:39:37.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.482]         }
[17:39:37.482]         else {
[17:39:37.482]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.482]         }
[17:39:37.482]         base::close(...future.stdout)
[17:39:37.482]         ...future.stdout <- NULL
[17:39:37.482]     }
[17:39:37.482]     ...future.result$conditions <- ...future.conditions
[17:39:37.482]     ...future.result$finished <- base::Sys.time()
[17:39:37.482]     ...future.result
[17:39:37.482] }
[17:39:37.485] requestCore(): workers = 2
[17:39:37.487] MulticoreFuture started
[17:39:37.487] - Launch lazy future ... done
[17:39:37.487] run() for ‘MulticoreFuture’ ... done
[17:39:37.488] getGlobalsAndPackages() ...
[17:39:37.488] Searching for globals...
[17:39:37.488] plan(): Setting new future strategy stack:
[17:39:37.489] 
[17:39:37.489] Searching for globals ... DONE
[17:39:37.488] List of future strategies:
[17:39:37.488] 1. sequential:
[17:39:37.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.488]    - tweaked: FALSE
[17:39:37.488]    - call: NULL
[17:39:37.489] - globals: [0] <none>
[17:39:37.489] plan(): nbrOfWorkers() = 1
[17:39:37.489] getGlobalsAndPackages() ... DONE
[17:39:37.490] run() for ‘Future’ ...
[17:39:37.490] - state: ‘created’
[17:39:37.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.491] plan(): Setting new future strategy stack:
[17:39:37.491] List of future strategies:
[17:39:37.491] 1. multicore:
[17:39:37.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.491]    - tweaked: FALSE
[17:39:37.491]    - call: plan(strategy)
[17:39:37.495] plan(): nbrOfWorkers() = 2
[17:39:37.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.496]   - Field: ‘label’
[17:39:37.496]   - Field: ‘local’
[17:39:37.496]   - Field: ‘owner’
[17:39:37.496]   - Field: ‘envir’
[17:39:37.496]   - Field: ‘workers’
[17:39:37.496]   - Field: ‘packages’
[17:39:37.497]   - Field: ‘gc’
[17:39:37.497]   - Field: ‘job’
[17:39:37.497]   - Field: ‘conditions’
[17:39:37.497]   - Field: ‘expr’
[17:39:37.497]   - Field: ‘uuid’
[17:39:37.497]   - Field: ‘seed’
[17:39:37.497]   - Field: ‘version’
[17:39:37.498]   - Field: ‘result’
[17:39:37.498]   - Field: ‘asynchronous’
[17:39:37.498]   - Field: ‘calls’
[17:39:37.498]   - Field: ‘globals’
[17:39:37.498]   - Field: ‘stdout’
[17:39:37.498]   - Field: ‘earlySignal’
[17:39:37.498]   - Field: ‘lazy’
[17:39:37.498]   - Field: ‘state’
[17:39:37.499] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.499] - Launch lazy future ...
[17:39:37.499] Packages needed by the future expression (n = 0): <none>
[17:39:37.499] Packages needed by future strategies (n = 0): <none>
[17:39:37.500] {
[17:39:37.500]     {
[17:39:37.500]         {
[17:39:37.500]             ...future.startTime <- base::Sys.time()
[17:39:37.500]             {
[17:39:37.500]                 {
[17:39:37.500]                   {
[17:39:37.500]                     {
[17:39:37.500]                       base::local({
[17:39:37.500]                         has_future <- base::requireNamespace("future", 
[17:39:37.500]                           quietly = TRUE)
[17:39:37.500]                         if (has_future) {
[17:39:37.500]                           ns <- base::getNamespace("future")
[17:39:37.500]                           version <- ns[[".package"]][["version"]]
[17:39:37.500]                           if (is.null(version)) 
[17:39:37.500]                             version <- utils::packageVersion("future")
[17:39:37.500]                         }
[17:39:37.500]                         else {
[17:39:37.500]                           version <- NULL
[17:39:37.500]                         }
[17:39:37.500]                         if (!has_future || version < "1.8.0") {
[17:39:37.500]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.500]                             "", base::R.version$version.string), 
[17:39:37.500]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.500]                               "release", "version")], collapse = " "), 
[17:39:37.500]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.500]                             info)
[17:39:37.500]                           info <- base::paste(info, collapse = "; ")
[17:39:37.500]                           if (!has_future) {
[17:39:37.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.500]                               info)
[17:39:37.500]                           }
[17:39:37.500]                           else {
[17:39:37.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.500]                               info, version)
[17:39:37.500]                           }
[17:39:37.500]                           base::stop(msg)
[17:39:37.500]                         }
[17:39:37.500]                       })
[17:39:37.500]                     }
[17:39:37.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.500]                     base::options(mc.cores = 1L)
[17:39:37.500]                   }
[17:39:37.500]                   ...future.strategy.old <- future::plan("list")
[17:39:37.500]                   options(future.plan = NULL)
[17:39:37.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.500]                 }
[17:39:37.500]                 ...future.workdir <- getwd()
[17:39:37.500]             }
[17:39:37.500]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.500]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.500]         }
[17:39:37.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.500]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.500]             base::names(...future.oldOptions))
[17:39:37.500]     }
[17:39:37.500]     if (FALSE) {
[17:39:37.500]     }
[17:39:37.500]     else {
[17:39:37.500]         if (TRUE) {
[17:39:37.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.500]                 open = "w")
[17:39:37.500]         }
[17:39:37.500]         else {
[17:39:37.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.500]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.500]         }
[17:39:37.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.500]             base::sink(type = "output", split = FALSE)
[17:39:37.500]             base::close(...future.stdout)
[17:39:37.500]         }, add = TRUE)
[17:39:37.500]     }
[17:39:37.500]     ...future.frame <- base::sys.nframe()
[17:39:37.500]     ...future.conditions <- base::list()
[17:39:37.500]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.500]     if (FALSE) {
[17:39:37.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.500]     }
[17:39:37.500]     ...future.result <- base::tryCatch({
[17:39:37.500]         base::withCallingHandlers({
[17:39:37.500]             ...future.value <- base::withVisible(base::local({
[17:39:37.500]                 withCallingHandlers({
[17:39:37.500]                   NULL
[17:39:37.500]                 }, immediateCondition = function(cond) {
[17:39:37.500]                   save_rds <- function (object, pathname, ...) 
[17:39:37.500]                   {
[17:39:37.500]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.500]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.500]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.500]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.500]                         fi_tmp[["mtime"]])
[17:39:37.500]                     }
[17:39:37.500]                     tryCatch({
[17:39:37.500]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.500]                     }, error = function(ex) {
[17:39:37.500]                       msg <- conditionMessage(ex)
[17:39:37.500]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.500]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.500]                         fi_tmp[["mtime"]], msg)
[17:39:37.500]                       ex$message <- msg
[17:39:37.500]                       stop(ex)
[17:39:37.500]                     })
[17:39:37.500]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.500]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.500]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.500]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.500]                       fi <- file.info(pathname)
[17:39:37.500]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.500]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.500]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.500]                         fi[["size"]], fi[["mtime"]])
[17:39:37.500]                       stop(msg)
[17:39:37.500]                     }
[17:39:37.500]                     invisible(pathname)
[17:39:37.500]                   }
[17:39:37.500]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.500]                     rootPath = tempdir()) 
[17:39:37.500]                   {
[17:39:37.500]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.500]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.500]                       tmpdir = path, fileext = ".rds")
[17:39:37.500]                     save_rds(obj, file)
[17:39:37.500]                   }
[17:39:37.500]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.500]                   {
[17:39:37.500]                     inherits <- base::inherits
[17:39:37.500]                     invokeRestart <- base::invokeRestart
[17:39:37.500]                     is.null <- base::is.null
[17:39:37.500]                     muffled <- FALSE
[17:39:37.500]                     if (inherits(cond, "message")) {
[17:39:37.500]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.500]                       if (muffled) 
[17:39:37.500]                         invokeRestart("muffleMessage")
[17:39:37.500]                     }
[17:39:37.500]                     else if (inherits(cond, "warning")) {
[17:39:37.500]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.500]                       if (muffled) 
[17:39:37.500]                         invokeRestart("muffleWarning")
[17:39:37.500]                     }
[17:39:37.500]                     else if (inherits(cond, "condition")) {
[17:39:37.500]                       if (!is.null(pattern)) {
[17:39:37.500]                         computeRestarts <- base::computeRestarts
[17:39:37.500]                         grepl <- base::grepl
[17:39:37.500]                         restarts <- computeRestarts(cond)
[17:39:37.500]                         for (restart in restarts) {
[17:39:37.500]                           name <- restart$name
[17:39:37.500]                           if (is.null(name)) 
[17:39:37.500]                             next
[17:39:37.500]                           if (!grepl(pattern, name)) 
[17:39:37.500]                             next
[17:39:37.500]                           invokeRestart(restart)
[17:39:37.500]                           muffled <- TRUE
[17:39:37.500]                           break
[17:39:37.500]                         }
[17:39:37.500]                       }
[17:39:37.500]                     }
[17:39:37.500]                     invisible(muffled)
[17:39:37.500]                   }
[17:39:37.500]                   muffleCondition(cond)
[17:39:37.500]                 })
[17:39:37.500]             }))
[17:39:37.500]             future::FutureResult(value = ...future.value$value, 
[17:39:37.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.500]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.500]                     ...future.globalenv.names))
[17:39:37.500]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.500]         }, condition = base::local({
[17:39:37.500]             c <- base::c
[17:39:37.500]             inherits <- base::inherits
[17:39:37.500]             invokeRestart <- base::invokeRestart
[17:39:37.500]             length <- base::length
[17:39:37.500]             list <- base::list
[17:39:37.500]             seq.int <- base::seq.int
[17:39:37.500]             signalCondition <- base::signalCondition
[17:39:37.500]             sys.calls <- base::sys.calls
[17:39:37.500]             `[[` <- base::`[[`
[17:39:37.500]             `+` <- base::`+`
[17:39:37.500]             `<<-` <- base::`<<-`
[17:39:37.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.500]                   3L)]
[17:39:37.500]             }
[17:39:37.500]             function(cond) {
[17:39:37.500]                 is_error <- inherits(cond, "error")
[17:39:37.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.500]                   NULL)
[17:39:37.500]                 if (is_error) {
[17:39:37.500]                   sessionInformation <- function() {
[17:39:37.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.500]                       search = base::search(), system = base::Sys.info())
[17:39:37.500]                   }
[17:39:37.500]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.500]                     cond$call), session = sessionInformation(), 
[17:39:37.500]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.500]                   signalCondition(cond)
[17:39:37.500]                 }
[17:39:37.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.500]                 "immediateCondition"))) {
[17:39:37.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.500]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.500]                   if (TRUE && !signal) {
[17:39:37.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.500]                     {
[17:39:37.500]                       inherits <- base::inherits
[17:39:37.500]                       invokeRestart <- base::invokeRestart
[17:39:37.500]                       is.null <- base::is.null
[17:39:37.500]                       muffled <- FALSE
[17:39:37.500]                       if (inherits(cond, "message")) {
[17:39:37.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.500]                         if (muffled) 
[17:39:37.500]                           invokeRestart("muffleMessage")
[17:39:37.500]                       }
[17:39:37.500]                       else if (inherits(cond, "warning")) {
[17:39:37.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.500]                         if (muffled) 
[17:39:37.500]                           invokeRestart("muffleWarning")
[17:39:37.500]                       }
[17:39:37.500]                       else if (inherits(cond, "condition")) {
[17:39:37.500]                         if (!is.null(pattern)) {
[17:39:37.500]                           computeRestarts <- base::computeRestarts
[17:39:37.500]                           grepl <- base::grepl
[17:39:37.500]                           restarts <- computeRestarts(cond)
[17:39:37.500]                           for (restart in restarts) {
[17:39:37.500]                             name <- restart$name
[17:39:37.500]                             if (is.null(name)) 
[17:39:37.500]                               next
[17:39:37.500]                             if (!grepl(pattern, name)) 
[17:39:37.500]                               next
[17:39:37.500]                             invokeRestart(restart)
[17:39:37.500]                             muffled <- TRUE
[17:39:37.500]                             break
[17:39:37.500]                           }
[17:39:37.500]                         }
[17:39:37.500]                       }
[17:39:37.500]                       invisible(muffled)
[17:39:37.500]                     }
[17:39:37.500]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.500]                   }
[17:39:37.500]                 }
[17:39:37.500]                 else {
[17:39:37.500]                   if (TRUE) {
[17:39:37.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.500]                     {
[17:39:37.500]                       inherits <- base::inherits
[17:39:37.500]                       invokeRestart <- base::invokeRestart
[17:39:37.500]                       is.null <- base::is.null
[17:39:37.500]                       muffled <- FALSE
[17:39:37.500]                       if (inherits(cond, "message")) {
[17:39:37.500]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.500]                         if (muffled) 
[17:39:37.500]                           invokeRestart("muffleMessage")
[17:39:37.500]                       }
[17:39:37.500]                       else if (inherits(cond, "warning")) {
[17:39:37.500]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.500]                         if (muffled) 
[17:39:37.500]                           invokeRestart("muffleWarning")
[17:39:37.500]                       }
[17:39:37.500]                       else if (inherits(cond, "condition")) {
[17:39:37.500]                         if (!is.null(pattern)) {
[17:39:37.500]                           computeRestarts <- base::computeRestarts
[17:39:37.500]                           grepl <- base::grepl
[17:39:37.500]                           restarts <- computeRestarts(cond)
[17:39:37.500]                           for (restart in restarts) {
[17:39:37.500]                             name <- restart$name
[17:39:37.500]                             if (is.null(name)) 
[17:39:37.500]                               next
[17:39:37.500]                             if (!grepl(pattern, name)) 
[17:39:37.500]                               next
[17:39:37.500]                             invokeRestart(restart)
[17:39:37.500]                             muffled <- TRUE
[17:39:37.500]                             break
[17:39:37.500]                           }
[17:39:37.500]                         }
[17:39:37.500]                       }
[17:39:37.500]                       invisible(muffled)
[17:39:37.500]                     }
[17:39:37.500]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.500]                   }
[17:39:37.500]                 }
[17:39:37.500]             }
[17:39:37.500]         }))
[17:39:37.500]     }, error = function(ex) {
[17:39:37.500]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.500]                 ...future.rng), started = ...future.startTime, 
[17:39:37.500]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.500]             version = "1.8"), class = "FutureResult")
[17:39:37.500]     }, finally = {
[17:39:37.500]         if (!identical(...future.workdir, getwd())) 
[17:39:37.500]             setwd(...future.workdir)
[17:39:37.500]         {
[17:39:37.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.500]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.500]             }
[17:39:37.500]             base::options(...future.oldOptions)
[17:39:37.500]             if (.Platform$OS.type == "windows") {
[17:39:37.500]                 old_names <- names(...future.oldEnvVars)
[17:39:37.500]                 envs <- base::Sys.getenv()
[17:39:37.500]                 names <- names(envs)
[17:39:37.500]                 common <- intersect(names, old_names)
[17:39:37.500]                 added <- setdiff(names, old_names)
[17:39:37.500]                 removed <- setdiff(old_names, names)
[17:39:37.500]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.500]                   envs[common]]
[17:39:37.500]                 NAMES <- toupper(changed)
[17:39:37.500]                 args <- list()
[17:39:37.500]                 for (kk in seq_along(NAMES)) {
[17:39:37.500]                   name <- changed[[kk]]
[17:39:37.500]                   NAME <- NAMES[[kk]]
[17:39:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.500]                     next
[17:39:37.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.500]                 }
[17:39:37.500]                 NAMES <- toupper(added)
[17:39:37.500]                 for (kk in seq_along(NAMES)) {
[17:39:37.500]                   name <- added[[kk]]
[17:39:37.500]                   NAME <- NAMES[[kk]]
[17:39:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.500]                     next
[17:39:37.500]                   args[[name]] <- ""
[17:39:37.500]                 }
[17:39:37.500]                 NAMES <- toupper(removed)
[17:39:37.500]                 for (kk in seq_along(NAMES)) {
[17:39:37.500]                   name <- removed[[kk]]
[17:39:37.500]                   NAME <- NAMES[[kk]]
[17:39:37.500]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.500]                     next
[17:39:37.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.500]                 }
[17:39:37.500]                 if (length(args) > 0) 
[17:39:37.500]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.500]             }
[17:39:37.500]             else {
[17:39:37.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.500]             }
[17:39:37.500]             {
[17:39:37.500]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.500]                   0L) {
[17:39:37.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.500]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.500]                   base::options(opts)
[17:39:37.500]                 }
[17:39:37.500]                 {
[17:39:37.500]                   {
[17:39:37.500]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.500]                     NULL
[17:39:37.500]                   }
[17:39:37.500]                   options(future.plan = NULL)
[17:39:37.500]                   if (is.na(NA_character_)) 
[17:39:37.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.500]                     .init = FALSE)
[17:39:37.500]                 }
[17:39:37.500]             }
[17:39:37.500]         }
[17:39:37.500]     })
[17:39:37.500]     if (TRUE) {
[17:39:37.500]         base::sink(type = "output", split = FALSE)
[17:39:37.500]         if (TRUE) {
[17:39:37.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.500]         }
[17:39:37.500]         else {
[17:39:37.500]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.500]         }
[17:39:37.500]         base::close(...future.stdout)
[17:39:37.500]         ...future.stdout <- NULL
[17:39:37.500]     }
[17:39:37.500]     ...future.result$conditions <- ...future.conditions
[17:39:37.500]     ...future.result$finished <- base::Sys.time()
[17:39:37.500]     ...future.result
[17:39:37.500] }
[17:39:37.503] requestCore(): workers = 2
[17:39:37.506] MulticoreFuture started
[17:39:37.507] - Launch lazy future ... done
[17:39:37.507] run() for ‘MulticoreFuture’ ... done
[17:39:37.507] plan(): Setting new future strategy stack:
[17:39:37.508] getGlobalsAndPackages() ...
[17:39:37.508] Searching for globals...
[17:39:37.507] List of future strategies:
[17:39:37.507] 1. sequential:
[17:39:37.507]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.507]    - tweaked: FALSE
[17:39:37.507]    - call: NULL
[17:39:37.509] plan(): nbrOfWorkers() = 1
[17:39:37.509] - globals found: [1] ‘{’
[17:39:37.510] Searching for globals ... DONE
[17:39:37.510] Resolving globals: FALSE
[17:39:37.510] 
[17:39:37.510] plan(): Setting new future strategy stack:
[17:39:37.510] 
[17:39:37.511] getGlobalsAndPackages() ... DONE
[17:39:37.511] List of future strategies:
[17:39:37.511] 1. multicore:
[17:39:37.511]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.511]    - tweaked: FALSE
[17:39:37.511]    - call: plan(strategy)
[17:39:37.511] run() for ‘Future’ ...
[17:39:37.511] - state: ‘created’
[17:39:37.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.516] plan(): nbrOfWorkers() = 2
[17:39:37.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.517]   - Field: ‘label’
[17:39:37.517]   - Field: ‘local’
[17:39:37.517]   - Field: ‘owner’
[17:39:37.517]   - Field: ‘envir’
[17:39:37.518]   - Field: ‘workers’
[17:39:37.518]   - Field: ‘packages’
[17:39:37.518]   - Field: ‘gc’
[17:39:37.518]   - Field: ‘job’
[17:39:37.518]   - Field: ‘conditions’
[17:39:37.518]   - Field: ‘expr’
[17:39:37.518]   - Field: ‘uuid’
[17:39:37.519]   - Field: ‘seed’
[17:39:37.519]   - Field: ‘version’
[17:39:37.519]   - Field: ‘result’
[17:39:37.519]   - Field: ‘asynchronous’
[17:39:37.519]   - Field: ‘calls’
[17:39:37.519]   - Field: ‘globals’
[17:39:37.519]   - Field: ‘stdout’
[17:39:37.519]   - Field: ‘earlySignal’
[17:39:37.520]   - Field: ‘lazy’
[17:39:37.520]   - Field: ‘state’
[17:39:37.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.520] - Launch lazy future ...
[17:39:37.521] Packages needed by the future expression (n = 0): <none>
[17:39:37.521] Packages needed by future strategies (n = 0): <none>
[17:39:37.521] {
[17:39:37.521]     {
[17:39:37.521]         {
[17:39:37.521]             ...future.startTime <- base::Sys.time()
[17:39:37.521]             {
[17:39:37.521]                 {
[17:39:37.521]                   {
[17:39:37.521]                     {
[17:39:37.521]                       base::local({
[17:39:37.521]                         has_future <- base::requireNamespace("future", 
[17:39:37.521]                           quietly = TRUE)
[17:39:37.521]                         if (has_future) {
[17:39:37.521]                           ns <- base::getNamespace("future")
[17:39:37.521]                           version <- ns[[".package"]][["version"]]
[17:39:37.521]                           if (is.null(version)) 
[17:39:37.521]                             version <- utils::packageVersion("future")
[17:39:37.521]                         }
[17:39:37.521]                         else {
[17:39:37.521]                           version <- NULL
[17:39:37.521]                         }
[17:39:37.521]                         if (!has_future || version < "1.8.0") {
[17:39:37.521]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.521]                             "", base::R.version$version.string), 
[17:39:37.521]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.521]                               "release", "version")], collapse = " "), 
[17:39:37.521]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.521]                             info)
[17:39:37.521]                           info <- base::paste(info, collapse = "; ")
[17:39:37.521]                           if (!has_future) {
[17:39:37.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.521]                               info)
[17:39:37.521]                           }
[17:39:37.521]                           else {
[17:39:37.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.521]                               info, version)
[17:39:37.521]                           }
[17:39:37.521]                           base::stop(msg)
[17:39:37.521]                         }
[17:39:37.521]                       })
[17:39:37.521]                     }
[17:39:37.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.521]                     base::options(mc.cores = 1L)
[17:39:37.521]                   }
[17:39:37.521]                   ...future.strategy.old <- future::plan("list")
[17:39:37.521]                   options(future.plan = NULL)
[17:39:37.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.521]                 }
[17:39:37.521]                 ...future.workdir <- getwd()
[17:39:37.521]             }
[17:39:37.521]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.521]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.521]         }
[17:39:37.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.521]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.521]             base::names(...future.oldOptions))
[17:39:37.521]     }
[17:39:37.521]     if (FALSE) {
[17:39:37.521]     }
[17:39:37.521]     else {
[17:39:37.521]         if (TRUE) {
[17:39:37.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.521]                 open = "w")
[17:39:37.521]         }
[17:39:37.521]         else {
[17:39:37.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.521]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.521]         }
[17:39:37.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.521]             base::sink(type = "output", split = FALSE)
[17:39:37.521]             base::close(...future.stdout)
[17:39:37.521]         }, add = TRUE)
[17:39:37.521]     }
[17:39:37.521]     ...future.frame <- base::sys.nframe()
[17:39:37.521]     ...future.conditions <- base::list()
[17:39:37.521]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.521]     if (FALSE) {
[17:39:37.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.521]     }
[17:39:37.521]     ...future.result <- base::tryCatch({
[17:39:37.521]         base::withCallingHandlers({
[17:39:37.521]             ...future.value <- base::withVisible(base::local({
[17:39:37.521]                 withCallingHandlers({
[17:39:37.521]                   {
[17:39:37.521]                     4
[17:39:37.521]                   }
[17:39:37.521]                 }, immediateCondition = function(cond) {
[17:39:37.521]                   save_rds <- function (object, pathname, ...) 
[17:39:37.521]                   {
[17:39:37.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.521]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.521]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.521]                         fi_tmp[["mtime"]])
[17:39:37.521]                     }
[17:39:37.521]                     tryCatch({
[17:39:37.521]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.521]                     }, error = function(ex) {
[17:39:37.521]                       msg <- conditionMessage(ex)
[17:39:37.521]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.521]                         fi_tmp[["mtime"]], msg)
[17:39:37.521]                       ex$message <- msg
[17:39:37.521]                       stop(ex)
[17:39:37.521]                     })
[17:39:37.521]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.521]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.521]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.521]                       fi <- file.info(pathname)
[17:39:37.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.521]                         fi[["size"]], fi[["mtime"]])
[17:39:37.521]                       stop(msg)
[17:39:37.521]                     }
[17:39:37.521]                     invisible(pathname)
[17:39:37.521]                   }
[17:39:37.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.521]                     rootPath = tempdir()) 
[17:39:37.521]                   {
[17:39:37.521]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.521]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.521]                       tmpdir = path, fileext = ".rds")
[17:39:37.521]                     save_rds(obj, file)
[17:39:37.521]                   }
[17:39:37.521]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.521]                   {
[17:39:37.521]                     inherits <- base::inherits
[17:39:37.521]                     invokeRestart <- base::invokeRestart
[17:39:37.521]                     is.null <- base::is.null
[17:39:37.521]                     muffled <- FALSE
[17:39:37.521]                     if (inherits(cond, "message")) {
[17:39:37.521]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.521]                       if (muffled) 
[17:39:37.521]                         invokeRestart("muffleMessage")
[17:39:37.521]                     }
[17:39:37.521]                     else if (inherits(cond, "warning")) {
[17:39:37.521]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.521]                       if (muffled) 
[17:39:37.521]                         invokeRestart("muffleWarning")
[17:39:37.521]                     }
[17:39:37.521]                     else if (inherits(cond, "condition")) {
[17:39:37.521]                       if (!is.null(pattern)) {
[17:39:37.521]                         computeRestarts <- base::computeRestarts
[17:39:37.521]                         grepl <- base::grepl
[17:39:37.521]                         restarts <- computeRestarts(cond)
[17:39:37.521]                         for (restart in restarts) {
[17:39:37.521]                           name <- restart$name
[17:39:37.521]                           if (is.null(name)) 
[17:39:37.521]                             next
[17:39:37.521]                           if (!grepl(pattern, name)) 
[17:39:37.521]                             next
[17:39:37.521]                           invokeRestart(restart)
[17:39:37.521]                           muffled <- TRUE
[17:39:37.521]                           break
[17:39:37.521]                         }
[17:39:37.521]                       }
[17:39:37.521]                     }
[17:39:37.521]                     invisible(muffled)
[17:39:37.521]                   }
[17:39:37.521]                   muffleCondition(cond)
[17:39:37.521]                 })
[17:39:37.521]             }))
[17:39:37.521]             future::FutureResult(value = ...future.value$value, 
[17:39:37.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.521]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.521]                     ...future.globalenv.names))
[17:39:37.521]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.521]         }, condition = base::local({
[17:39:37.521]             c <- base::c
[17:39:37.521]             inherits <- base::inherits
[17:39:37.521]             invokeRestart <- base::invokeRestart
[17:39:37.521]             length <- base::length
[17:39:37.521]             list <- base::list
[17:39:37.521]             seq.int <- base::seq.int
[17:39:37.521]             signalCondition <- base::signalCondition
[17:39:37.521]             sys.calls <- base::sys.calls
[17:39:37.521]             `[[` <- base::`[[`
[17:39:37.521]             `+` <- base::`+`
[17:39:37.521]             `<<-` <- base::`<<-`
[17:39:37.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.521]                   3L)]
[17:39:37.521]             }
[17:39:37.521]             function(cond) {
[17:39:37.521]                 is_error <- inherits(cond, "error")
[17:39:37.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.521]                   NULL)
[17:39:37.521]                 if (is_error) {
[17:39:37.521]                   sessionInformation <- function() {
[17:39:37.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.521]                       search = base::search(), system = base::Sys.info())
[17:39:37.521]                   }
[17:39:37.521]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.521]                     cond$call), session = sessionInformation(), 
[17:39:37.521]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.521]                   signalCondition(cond)
[17:39:37.521]                 }
[17:39:37.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.521]                 "immediateCondition"))) {
[17:39:37.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.521]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.521]                   if (TRUE && !signal) {
[17:39:37.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.521]                     {
[17:39:37.521]                       inherits <- base::inherits
[17:39:37.521]                       invokeRestart <- base::invokeRestart
[17:39:37.521]                       is.null <- base::is.null
[17:39:37.521]                       muffled <- FALSE
[17:39:37.521]                       if (inherits(cond, "message")) {
[17:39:37.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.521]                         if (muffled) 
[17:39:37.521]                           invokeRestart("muffleMessage")
[17:39:37.521]                       }
[17:39:37.521]                       else if (inherits(cond, "warning")) {
[17:39:37.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.521]                         if (muffled) 
[17:39:37.521]                           invokeRestart("muffleWarning")
[17:39:37.521]                       }
[17:39:37.521]                       else if (inherits(cond, "condition")) {
[17:39:37.521]                         if (!is.null(pattern)) {
[17:39:37.521]                           computeRestarts <- base::computeRestarts
[17:39:37.521]                           grepl <- base::grepl
[17:39:37.521]                           restarts <- computeRestarts(cond)
[17:39:37.521]                           for (restart in restarts) {
[17:39:37.521]                             name <- restart$name
[17:39:37.521]                             if (is.null(name)) 
[17:39:37.521]                               next
[17:39:37.521]                             if (!grepl(pattern, name)) 
[17:39:37.521]                               next
[17:39:37.521]                             invokeRestart(restart)
[17:39:37.521]                             muffled <- TRUE
[17:39:37.521]                             break
[17:39:37.521]                           }
[17:39:37.521]                         }
[17:39:37.521]                       }
[17:39:37.521]                       invisible(muffled)
[17:39:37.521]                     }
[17:39:37.521]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.521]                   }
[17:39:37.521]                 }
[17:39:37.521]                 else {
[17:39:37.521]                   if (TRUE) {
[17:39:37.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.521]                     {
[17:39:37.521]                       inherits <- base::inherits
[17:39:37.521]                       invokeRestart <- base::invokeRestart
[17:39:37.521]                       is.null <- base::is.null
[17:39:37.521]                       muffled <- FALSE
[17:39:37.521]                       if (inherits(cond, "message")) {
[17:39:37.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.521]                         if (muffled) 
[17:39:37.521]                           invokeRestart("muffleMessage")
[17:39:37.521]                       }
[17:39:37.521]                       else if (inherits(cond, "warning")) {
[17:39:37.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.521]                         if (muffled) 
[17:39:37.521]                           invokeRestart("muffleWarning")
[17:39:37.521]                       }
[17:39:37.521]                       else if (inherits(cond, "condition")) {
[17:39:37.521]                         if (!is.null(pattern)) {
[17:39:37.521]                           computeRestarts <- base::computeRestarts
[17:39:37.521]                           grepl <- base::grepl
[17:39:37.521]                           restarts <- computeRestarts(cond)
[17:39:37.521]                           for (restart in restarts) {
[17:39:37.521]                             name <- restart$name
[17:39:37.521]                             if (is.null(name)) 
[17:39:37.521]                               next
[17:39:37.521]                             if (!grepl(pattern, name)) 
[17:39:37.521]                               next
[17:39:37.521]                             invokeRestart(restart)
[17:39:37.521]                             muffled <- TRUE
[17:39:37.521]                             break
[17:39:37.521]                           }
[17:39:37.521]                         }
[17:39:37.521]                       }
[17:39:37.521]                       invisible(muffled)
[17:39:37.521]                     }
[17:39:37.521]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.521]                   }
[17:39:37.521]                 }
[17:39:37.521]             }
[17:39:37.521]         }))
[17:39:37.521]     }, error = function(ex) {
[17:39:37.521]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.521]                 ...future.rng), started = ...future.startTime, 
[17:39:37.521]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.521]             version = "1.8"), class = "FutureResult")
[17:39:37.521]     }, finally = {
[17:39:37.521]         if (!identical(...future.workdir, getwd())) 
[17:39:37.521]             setwd(...future.workdir)
[17:39:37.521]         {
[17:39:37.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.521]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.521]             }
[17:39:37.521]             base::options(...future.oldOptions)
[17:39:37.521]             if (.Platform$OS.type == "windows") {
[17:39:37.521]                 old_names <- names(...future.oldEnvVars)
[17:39:37.521]                 envs <- base::Sys.getenv()
[17:39:37.521]                 names <- names(envs)
[17:39:37.521]                 common <- intersect(names, old_names)
[17:39:37.521]                 added <- setdiff(names, old_names)
[17:39:37.521]                 removed <- setdiff(old_names, names)
[17:39:37.521]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.521]                   envs[common]]
[17:39:37.521]                 NAMES <- toupper(changed)
[17:39:37.521]                 args <- list()
[17:39:37.521]                 for (kk in seq_along(NAMES)) {
[17:39:37.521]                   name <- changed[[kk]]
[17:39:37.521]                   NAME <- NAMES[[kk]]
[17:39:37.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.521]                     next
[17:39:37.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.521]                 }
[17:39:37.521]                 NAMES <- toupper(added)
[17:39:37.521]                 for (kk in seq_along(NAMES)) {
[17:39:37.521]                   name <- added[[kk]]
[17:39:37.521]                   NAME <- NAMES[[kk]]
[17:39:37.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.521]                     next
[17:39:37.521]                   args[[name]] <- ""
[17:39:37.521]                 }
[17:39:37.521]                 NAMES <- toupper(removed)
[17:39:37.521]                 for (kk in seq_along(NAMES)) {
[17:39:37.521]                   name <- removed[[kk]]
[17:39:37.521]                   NAME <- NAMES[[kk]]
[17:39:37.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.521]                     next
[17:39:37.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.521]                 }
[17:39:37.521]                 if (length(args) > 0) 
[17:39:37.521]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.521]             }
[17:39:37.521]             else {
[17:39:37.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.521]             }
[17:39:37.521]             {
[17:39:37.521]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.521]                   0L) {
[17:39:37.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.521]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.521]                   base::options(opts)
[17:39:37.521]                 }
[17:39:37.521]                 {
[17:39:37.521]                   {
[17:39:37.521]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.521]                     NULL
[17:39:37.521]                   }
[17:39:37.521]                   options(future.plan = NULL)
[17:39:37.521]                   if (is.na(NA_character_)) 
[17:39:37.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.521]                     .init = FALSE)
[17:39:37.521]                 }
[17:39:37.521]             }
[17:39:37.521]         }
[17:39:37.521]     })
[17:39:37.521]     if (TRUE) {
[17:39:37.521]         base::sink(type = "output", split = FALSE)
[17:39:37.521]         if (TRUE) {
[17:39:37.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.521]         }
[17:39:37.521]         else {
[17:39:37.521]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.521]         }
[17:39:37.521]         base::close(...future.stdout)
[17:39:37.521]         ...future.stdout <- NULL
[17:39:37.521]     }
[17:39:37.521]     ...future.result$conditions <- ...future.conditions
[17:39:37.521]     ...future.result$finished <- base::Sys.time()
[17:39:37.521]     ...future.result
[17:39:37.521] }
[17:39:37.525] requestCore(): workers = 2
[17:39:37.525] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:37.536] result() for MulticoreFuture ...
[17:39:37.537] result() for MulticoreFuture ...
[17:39:37.537] result() for MulticoreFuture ... done
[17:39:37.537] result() for MulticoreFuture ... done
[17:39:37.537] result() for MulticoreFuture ...
[17:39:37.538] result() for MulticoreFuture ... done
[17:39:37.541] MulticoreFuture started
[17:39:37.541] - Launch lazy future ... done
[17:39:37.542] run() for ‘MulticoreFuture’ ... done
[17:39:37.542] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55adf188b740> 
[17:39:37.542] List of future strategies:
[17:39:37.542] 1. sequential:
[17:39:37.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.542]    - tweaked: FALSE
[17:39:37.542]    - call: NULL
[17:39:37.552] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55adf0b571d0> 
 - attr(*, "dim.")=[17:39:37.556] plan(): Setting new future strategy stack:
[17:39:37.556] List of future strategies:
[17:39:37.556] 1. multicore:
[17:39:37.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.556]    - tweaked: FALSE
[17:39:37.556]    - call: plan(strategy)
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:37.561] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:37.565] resolve() on list environment ...
[17:39:37.565]  recursive: 0
[17:39:37.566]  length: 6
[17:39:37.567]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:37.567] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.567] - nx: 6
[17:39:37.567] - relay: TRUE
[17:39:37.567] - stdout: TRUE
[17:39:37.567] - signal: TRUE
[17:39:37.567] - resignal: FALSE
[17:39:37.568] - force: TRUE
[17:39:37.568] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.568] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.568]  - until=2
[17:39:37.568]  - relaying element #2
[17:39:37.568] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.568] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.569] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.569]  length: 5 (resolved future 1)
[17:39:37.569] Future #2
[17:39:37.569] result() for MulticoreFuture ...
[17:39:37.569] result() for MulticoreFuture ... done
[17:39:37.569] result() for MulticoreFuture ...
[17:39:37.569] result() for MulticoreFuture ... done
[17:39:37.570] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:37.570] - nx: 6
[17:39:37.570] - relay: TRUE
[17:39:37.570] - stdout: TRUE
[17:39:37.570] - signal: TRUE
[17:39:37.570] - resignal: FALSE
[17:39:37.570] - force: TRUE
[17:39:37.570] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.571] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.571]  - until=2
[17:39:37.571]  - relaying element #2
[17:39:37.571] result() for MulticoreFuture ...
[17:39:37.571] result() for MulticoreFuture ... done
[17:39:37.571] result() for MulticoreFuture ...
[17:39:37.571] result() for MulticoreFuture ... done
[17:39:37.572] result() for MulticoreFuture ...
[17:39:37.572] result() for MulticoreFuture ... done
[17:39:37.572] result() for MulticoreFuture ...
[17:39:37.572] result() for MulticoreFuture ... done
[17:39:37.572] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.572] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.572] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:37.572]  length: 4 (resolved future 2)
[17:39:37.573] Future #3
[17:39:37.573] result() for MulticoreFuture ...
[17:39:37.574] result() for MulticoreFuture ...
[17:39:37.574] result() for MulticoreFuture ... done
[17:39:37.574] result() for MulticoreFuture ... done
[17:39:37.574] result() for MulticoreFuture ...
[17:39:37.574] result() for MulticoreFuture ... done
[17:39:37.574] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:37.574] - nx: 6
[17:39:37.575] - relay: TRUE
[17:39:37.575] - stdout: TRUE
[17:39:37.575] - signal: TRUE
[17:39:37.575] - resignal: FALSE
[17:39:37.575] - force: TRUE
[17:39:37.575] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.575] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.575]  - until=3
[17:39:37.576]  - relaying element #3
[17:39:37.576] result() for MulticoreFuture ...
[17:39:37.576] result() for MulticoreFuture ... done
[17:39:37.576] result() for MulticoreFuture ...
[17:39:37.576] result() for MulticoreFuture ... done
[17:39:37.576] result() for MulticoreFuture ...
[17:39:37.576] result() for MulticoreFuture ... done
[17:39:37.577] result() for MulticoreFuture ...
[17:39:37.577] result() for MulticoreFuture ... done
[17:39:37.577] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.577] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.577] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:37.577]  length: 3 (resolved future 3)
[17:39:37.577] Future #4
[17:39:37.578] result() for MulticoreFuture ...
[17:39:37.578] result() for MulticoreFuture ...
[17:39:37.578] result() for MulticoreFuture ... done
[17:39:37.579] result() for MulticoreFuture ... done
[17:39:37.579] result() for MulticoreFuture ...
[17:39:37.579] result() for MulticoreFuture ... done
[17:39:37.579] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:37.579] - nx: 6
[17:39:37.579] - relay: TRUE
[17:39:37.579] - stdout: TRUE
[17:39:37.579] - signal: TRUE
[17:39:37.580] - resignal: FALSE
[17:39:37.580] - force: TRUE
[17:39:37.580] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.580] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.580]  - until=4
[17:39:37.580]  - relaying element #4
[17:39:37.580] result() for MulticoreFuture ...
[17:39:37.580] result() for MulticoreFuture ... done
[17:39:37.580] result() for MulticoreFuture ...
[17:39:37.581] result() for MulticoreFuture ... done
[17:39:37.581] result() for MulticoreFuture ...
[17:39:37.581] result() for MulticoreFuture ... done
[17:39:37.581] result() for MulticoreFuture ...
[17:39:37.581] result() for MulticoreFuture ... done
[17:39:37.581] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.581] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.581] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:37.581]  length: 2 (resolved future 4)
[17:39:37.582] signalConditionsASAP(NULL, pos=5) ...
[17:39:37.582] - nx: 6
[17:39:37.582] - relay: TRUE
[17:39:37.582] - stdout: TRUE
[17:39:37.582] - signal: TRUE
[17:39:37.582] - resignal: FALSE
[17:39:37.582] - force: TRUE
[17:39:37.582] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.582] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.582]  - until=6
[17:39:37.583]  - relaying element #6
[17:39:37.583] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.583] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.583] signalConditionsASAP(NULL, pos=5) ... done
[17:39:37.583]  length: 1 (resolved future 5)
[17:39:37.583] signalConditionsASAP(numeric, pos=6) ...
[17:39:37.583] - nx: 6
[17:39:37.583] - relay: TRUE
[17:39:37.583] - stdout: TRUE
[17:39:37.583] - signal: TRUE
[17:39:37.584] - resignal: FALSE
[17:39:37.584] - force: TRUE
[17:39:37.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.584]  - until=6
[17:39:37.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.584] signalConditionsASAP(numeric, pos=6) ... done
[17:39:37.584]  length: 0 (resolved future 6)
[17:39:37.585] Relaying remaining futures
[17:39:37.585] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.585] - nx: 6
[17:39:37.585] - relay: TRUE
[17:39:37.585] - stdout: TRUE
[17:39:37.585] - signal: TRUE
[17:39:37.585] - resignal: FALSE
[17:39:37.585] - force: TRUE
[17:39:37.585] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.585] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:37.586] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.586] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.586] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.586] resolve() on list environment ... DONE
[17:39:37.586] result() for MulticoreFuture ...
[17:39:37.586] result() for MulticoreFuture ... done
[17:39:37.586] result() for MulticoreFuture ...
[17:39:37.587] result() for MulticoreFuture ... done
[17:39:37.587] result() for MulticoreFuture ...
[17:39:37.587] result() for MulticoreFuture ... done
[17:39:37.587] result() for MulticoreFuture ...
[17:39:37.587] result() for MulticoreFuture ... done
[17:39:37.587] result() for MulticoreFuture ...
[17:39:37.587] result() for MulticoreFuture ... done
[17:39:37.588] result() for MulticoreFuture ...
[17:39:37.588] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf04a7640> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:37.590] getGlobalsAndPackages() ...
[17:39:37.590] Searching for globals...
[17:39:37.591] 
[17:39:37.591] Searching for globals ... DONE
[17:39:37.591] - globals: [0] <none>
[17:39:37.591] getGlobalsAndPackages() ... DONE
[17:39:37.591] run() for ‘Future’ ...
[17:39:37.591] - state: ‘created’
[17:39:37.591] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.596] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.596] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.597]   - Field: ‘label’
[17:39:37.597]   - Field: ‘local’
[17:39:37.597]   - Field: ‘owner’
[17:39:37.597]   - Field: ‘envir’
[17:39:37.597]   - Field: ‘workers’
[17:39:37.597]   - Field: ‘packages’
[17:39:37.597]   - Field: ‘gc’
[17:39:37.597]   - Field: ‘job’
[17:39:37.598]   - Field: ‘conditions’
[17:39:37.598]   - Field: ‘expr’
[17:39:37.598]   - Field: ‘uuid’
[17:39:37.598]   - Field: ‘seed’
[17:39:37.598]   - Field: ‘version’
[17:39:37.598]   - Field: ‘result’
[17:39:37.598]   - Field: ‘asynchronous’
[17:39:37.598]   - Field: ‘calls’
[17:39:37.598]   - Field: ‘globals’
[17:39:37.599]   - Field: ‘stdout’
[17:39:37.599]   - Field: ‘earlySignal’
[17:39:37.599]   - Field: ‘lazy’
[17:39:37.599]   - Field: ‘state’
[17:39:37.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.599] - Launch lazy future ...
[17:39:37.599] Packages needed by the future expression (n = 0): <none>
[17:39:37.600] Packages needed by future strategies (n = 0): <none>
[17:39:37.600] {
[17:39:37.600]     {
[17:39:37.600]         {
[17:39:37.600]             ...future.startTime <- base::Sys.time()
[17:39:37.600]             {
[17:39:37.600]                 {
[17:39:37.600]                   {
[17:39:37.600]                     {
[17:39:37.600]                       base::local({
[17:39:37.600]                         has_future <- base::requireNamespace("future", 
[17:39:37.600]                           quietly = TRUE)
[17:39:37.600]                         if (has_future) {
[17:39:37.600]                           ns <- base::getNamespace("future")
[17:39:37.600]                           version <- ns[[".package"]][["version"]]
[17:39:37.600]                           if (is.null(version)) 
[17:39:37.600]                             version <- utils::packageVersion("future")
[17:39:37.600]                         }
[17:39:37.600]                         else {
[17:39:37.600]                           version <- NULL
[17:39:37.600]                         }
[17:39:37.600]                         if (!has_future || version < "1.8.0") {
[17:39:37.600]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.600]                             "", base::R.version$version.string), 
[17:39:37.600]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.600]                               "release", "version")], collapse = " "), 
[17:39:37.600]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.600]                             info)
[17:39:37.600]                           info <- base::paste(info, collapse = "; ")
[17:39:37.600]                           if (!has_future) {
[17:39:37.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.600]                               info)
[17:39:37.600]                           }
[17:39:37.600]                           else {
[17:39:37.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.600]                               info, version)
[17:39:37.600]                           }
[17:39:37.600]                           base::stop(msg)
[17:39:37.600]                         }
[17:39:37.600]                       })
[17:39:37.600]                     }
[17:39:37.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.600]                     base::options(mc.cores = 1L)
[17:39:37.600]                   }
[17:39:37.600]                   ...future.strategy.old <- future::plan("list")
[17:39:37.600]                   options(future.plan = NULL)
[17:39:37.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.600]                 }
[17:39:37.600]                 ...future.workdir <- getwd()
[17:39:37.600]             }
[17:39:37.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.600]         }
[17:39:37.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.600]             base::names(...future.oldOptions))
[17:39:37.600]     }
[17:39:37.600]     if (FALSE) {
[17:39:37.600]     }
[17:39:37.600]     else {
[17:39:37.600]         if (TRUE) {
[17:39:37.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.600]                 open = "w")
[17:39:37.600]         }
[17:39:37.600]         else {
[17:39:37.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.600]         }
[17:39:37.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.600]             base::sink(type = "output", split = FALSE)
[17:39:37.600]             base::close(...future.stdout)
[17:39:37.600]         }, add = TRUE)
[17:39:37.600]     }
[17:39:37.600]     ...future.frame <- base::sys.nframe()
[17:39:37.600]     ...future.conditions <- base::list()
[17:39:37.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.600]     if (FALSE) {
[17:39:37.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.600]     }
[17:39:37.600]     ...future.result <- base::tryCatch({
[17:39:37.600]         base::withCallingHandlers({
[17:39:37.600]             ...future.value <- base::withVisible(base::local({
[17:39:37.600]                 withCallingHandlers({
[17:39:37.600]                   2
[17:39:37.600]                 }, immediateCondition = function(cond) {
[17:39:37.600]                   save_rds <- function (object, pathname, ...) 
[17:39:37.600]                   {
[17:39:37.600]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.600]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.600]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.600]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.600]                         fi_tmp[["mtime"]])
[17:39:37.600]                     }
[17:39:37.600]                     tryCatch({
[17:39:37.600]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.600]                     }, error = function(ex) {
[17:39:37.600]                       msg <- conditionMessage(ex)
[17:39:37.600]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.600]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.600]                         fi_tmp[["mtime"]], msg)
[17:39:37.600]                       ex$message <- msg
[17:39:37.600]                       stop(ex)
[17:39:37.600]                     })
[17:39:37.600]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.600]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.600]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.600]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.600]                       fi <- file.info(pathname)
[17:39:37.600]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.600]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.600]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.600]                         fi[["size"]], fi[["mtime"]])
[17:39:37.600]                       stop(msg)
[17:39:37.600]                     }
[17:39:37.600]                     invisible(pathname)
[17:39:37.600]                   }
[17:39:37.600]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.600]                     rootPath = tempdir()) 
[17:39:37.600]                   {
[17:39:37.600]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.600]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.600]                       tmpdir = path, fileext = ".rds")
[17:39:37.600]                     save_rds(obj, file)
[17:39:37.600]                   }
[17:39:37.600]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.600]                   {
[17:39:37.600]                     inherits <- base::inherits
[17:39:37.600]                     invokeRestart <- base::invokeRestart
[17:39:37.600]                     is.null <- base::is.null
[17:39:37.600]                     muffled <- FALSE
[17:39:37.600]                     if (inherits(cond, "message")) {
[17:39:37.600]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.600]                       if (muffled) 
[17:39:37.600]                         invokeRestart("muffleMessage")
[17:39:37.600]                     }
[17:39:37.600]                     else if (inherits(cond, "warning")) {
[17:39:37.600]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.600]                       if (muffled) 
[17:39:37.600]                         invokeRestart("muffleWarning")
[17:39:37.600]                     }
[17:39:37.600]                     else if (inherits(cond, "condition")) {
[17:39:37.600]                       if (!is.null(pattern)) {
[17:39:37.600]                         computeRestarts <- base::computeRestarts
[17:39:37.600]                         grepl <- base::grepl
[17:39:37.600]                         restarts <- computeRestarts(cond)
[17:39:37.600]                         for (restart in restarts) {
[17:39:37.600]                           name <- restart$name
[17:39:37.600]                           if (is.null(name)) 
[17:39:37.600]                             next
[17:39:37.600]                           if (!grepl(pattern, name)) 
[17:39:37.600]                             next
[17:39:37.600]                           invokeRestart(restart)
[17:39:37.600]                           muffled <- TRUE
[17:39:37.600]                           break
[17:39:37.600]                         }
[17:39:37.600]                       }
[17:39:37.600]                     }
[17:39:37.600]                     invisible(muffled)
[17:39:37.600]                   }
[17:39:37.600]                   muffleCondition(cond)
[17:39:37.600]                 })
[17:39:37.600]             }))
[17:39:37.600]             future::FutureResult(value = ...future.value$value, 
[17:39:37.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.600]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.600]                     ...future.globalenv.names))
[17:39:37.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.600]         }, condition = base::local({
[17:39:37.600]             c <- base::c
[17:39:37.600]             inherits <- base::inherits
[17:39:37.600]             invokeRestart <- base::invokeRestart
[17:39:37.600]             length <- base::length
[17:39:37.600]             list <- base::list
[17:39:37.600]             seq.int <- base::seq.int
[17:39:37.600]             signalCondition <- base::signalCondition
[17:39:37.600]             sys.calls <- base::sys.calls
[17:39:37.600]             `[[` <- base::`[[`
[17:39:37.600]             `+` <- base::`+`
[17:39:37.600]             `<<-` <- base::`<<-`
[17:39:37.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.600]                   3L)]
[17:39:37.600]             }
[17:39:37.600]             function(cond) {
[17:39:37.600]                 is_error <- inherits(cond, "error")
[17:39:37.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.600]                   NULL)
[17:39:37.600]                 if (is_error) {
[17:39:37.600]                   sessionInformation <- function() {
[17:39:37.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.600]                       search = base::search(), system = base::Sys.info())
[17:39:37.600]                   }
[17:39:37.600]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.600]                     cond$call), session = sessionInformation(), 
[17:39:37.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.600]                   signalCondition(cond)
[17:39:37.600]                 }
[17:39:37.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.600]                 "immediateCondition"))) {
[17:39:37.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.600]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.600]                   if (TRUE && !signal) {
[17:39:37.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.600]                     {
[17:39:37.600]                       inherits <- base::inherits
[17:39:37.600]                       invokeRestart <- base::invokeRestart
[17:39:37.600]                       is.null <- base::is.null
[17:39:37.600]                       muffled <- FALSE
[17:39:37.600]                       if (inherits(cond, "message")) {
[17:39:37.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.600]                         if (muffled) 
[17:39:37.600]                           invokeRestart("muffleMessage")
[17:39:37.600]                       }
[17:39:37.600]                       else if (inherits(cond, "warning")) {
[17:39:37.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.600]                         if (muffled) 
[17:39:37.600]                           invokeRestart("muffleWarning")
[17:39:37.600]                       }
[17:39:37.600]                       else if (inherits(cond, "condition")) {
[17:39:37.600]                         if (!is.null(pattern)) {
[17:39:37.600]                           computeRestarts <- base::computeRestarts
[17:39:37.600]                           grepl <- base::grepl
[17:39:37.600]                           restarts <- computeRestarts(cond)
[17:39:37.600]                           for (restart in restarts) {
[17:39:37.600]                             name <- restart$name
[17:39:37.600]                             if (is.null(name)) 
[17:39:37.600]                               next
[17:39:37.600]                             if (!grepl(pattern, name)) 
[17:39:37.600]                               next
[17:39:37.600]                             invokeRestart(restart)
[17:39:37.600]                             muffled <- TRUE
[17:39:37.600]                             break
[17:39:37.600]                           }
[17:39:37.600]                         }
[17:39:37.600]                       }
[17:39:37.600]                       invisible(muffled)
[17:39:37.600]                     }
[17:39:37.600]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.600]                   }
[17:39:37.600]                 }
[17:39:37.600]                 else {
[17:39:37.600]                   if (TRUE) {
[17:39:37.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.600]                     {
[17:39:37.600]                       inherits <- base::inherits
[17:39:37.600]                       invokeRestart <- base::invokeRestart
[17:39:37.600]                       is.null <- base::is.null
[17:39:37.600]                       muffled <- FALSE
[17:39:37.600]                       if (inherits(cond, "message")) {
[17:39:37.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.600]                         if (muffled) 
[17:39:37.600]                           invokeRestart("muffleMessage")
[17:39:37.600]                       }
[17:39:37.600]                       else if (inherits(cond, "warning")) {
[17:39:37.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.600]                         if (muffled) 
[17:39:37.600]                           invokeRestart("muffleWarning")
[17:39:37.600]                       }
[17:39:37.600]                       else if (inherits(cond, "condition")) {
[17:39:37.600]                         if (!is.null(pattern)) {
[17:39:37.600]                           computeRestarts <- base::computeRestarts
[17:39:37.600]                           grepl <- base::grepl
[17:39:37.600]                           restarts <- computeRestarts(cond)
[17:39:37.600]                           for (restart in restarts) {
[17:39:37.600]                             name <- restart$name
[17:39:37.600]                             if (is.null(name)) 
[17:39:37.600]                               next
[17:39:37.600]                             if (!grepl(pattern, name)) 
[17:39:37.600]                               next
[17:39:37.600]                             invokeRestart(restart)
[17:39:37.600]                             muffled <- TRUE
[17:39:37.600]                             break
[17:39:37.600]                           }
[17:39:37.600]                         }
[17:39:37.600]                       }
[17:39:37.600]                       invisible(muffled)
[17:39:37.600]                     }
[17:39:37.600]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.600]                   }
[17:39:37.600]                 }
[17:39:37.600]             }
[17:39:37.600]         }))
[17:39:37.600]     }, error = function(ex) {
[17:39:37.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.600]                 ...future.rng), started = ...future.startTime, 
[17:39:37.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.600]             version = "1.8"), class = "FutureResult")
[17:39:37.600]     }, finally = {
[17:39:37.600]         if (!identical(...future.workdir, getwd())) 
[17:39:37.600]             setwd(...future.workdir)
[17:39:37.600]         {
[17:39:37.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.600]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.600]             }
[17:39:37.600]             base::options(...future.oldOptions)
[17:39:37.600]             if (.Platform$OS.type == "windows") {
[17:39:37.600]                 old_names <- names(...future.oldEnvVars)
[17:39:37.600]                 envs <- base::Sys.getenv()
[17:39:37.600]                 names <- names(envs)
[17:39:37.600]                 common <- intersect(names, old_names)
[17:39:37.600]                 added <- setdiff(names, old_names)
[17:39:37.600]                 removed <- setdiff(old_names, names)
[17:39:37.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.600]                   envs[common]]
[17:39:37.600]                 NAMES <- toupper(changed)
[17:39:37.600]                 args <- list()
[17:39:37.600]                 for (kk in seq_along(NAMES)) {
[17:39:37.600]                   name <- changed[[kk]]
[17:39:37.600]                   NAME <- NAMES[[kk]]
[17:39:37.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.600]                     next
[17:39:37.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.600]                 }
[17:39:37.600]                 NAMES <- toupper(added)
[17:39:37.600]                 for (kk in seq_along(NAMES)) {
[17:39:37.600]                   name <- added[[kk]]
[17:39:37.600]                   NAME <- NAMES[[kk]]
[17:39:37.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.600]                     next
[17:39:37.600]                   args[[name]] <- ""
[17:39:37.600]                 }
[17:39:37.600]                 NAMES <- toupper(removed)
[17:39:37.600]                 for (kk in seq_along(NAMES)) {
[17:39:37.600]                   name <- removed[[kk]]
[17:39:37.600]                   NAME <- NAMES[[kk]]
[17:39:37.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.600]                     next
[17:39:37.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.600]                 }
[17:39:37.600]                 if (length(args) > 0) 
[17:39:37.600]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.600]             }
[17:39:37.600]             else {
[17:39:37.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.600]             }
[17:39:37.600]             {
[17:39:37.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.600]                   0L) {
[17:39:37.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.600]                   base::options(opts)
[17:39:37.600]                 }
[17:39:37.600]                 {
[17:39:37.600]                   {
[17:39:37.600]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.600]                     NULL
[17:39:37.600]                   }
[17:39:37.600]                   options(future.plan = NULL)
[17:39:37.600]                   if (is.na(NA_character_)) 
[17:39:37.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.600]                     .init = FALSE)
[17:39:37.600]                 }
[17:39:37.600]             }
[17:39:37.600]         }
[17:39:37.600]     })
[17:39:37.600]     if (TRUE) {
[17:39:37.600]         base::sink(type = "output", split = FALSE)
[17:39:37.600]         if (TRUE) {
[17:39:37.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.600]         }
[17:39:37.600]         else {
[17:39:37.600]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.600]         }
[17:39:37.600]         base::close(...future.stdout)
[17:39:37.600]         ...future.stdout <- NULL
[17:39:37.600]     }
[17:39:37.600]     ...future.result$conditions <- ...future.conditions
[17:39:37.600]     ...future.result$finished <- base::Sys.time()
[17:39:37.600]     ...future.result
[17:39:37.600] }
[17:39:37.602] requestCore(): workers = 2
[17:39:37.605] MulticoreFuture started
[17:39:37.605] - Launch lazy future ... done
[17:39:37.605] run() for ‘MulticoreFuture’ ... done
[17:39:37.606] getGlobalsAndPackages() ...
[17:39:37.606] Searching for globals...
[17:39:37.606] plan(): Setting new future strategy stack:
[17:39:37.607] 
[17:39:37.607] Searching for globals ... DONE
[17:39:37.606] List of future strategies:
[17:39:37.606] 1. sequential:
[17:39:37.606]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.606]    - tweaked: FALSE
[17:39:37.606]    - call: NULL
[17:39:37.607] - globals: [0] <none>
[17:39:37.607] plan(): nbrOfWorkers() = 1
[17:39:37.607] getGlobalsAndPackages() ... DONE
[17:39:37.608] run() for ‘Future’ ...
[17:39:37.608] - state: ‘created’
[17:39:37.608] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.609] plan(): Setting new future strategy stack:
[17:39:37.609] List of future strategies:
[17:39:37.609] 1. multicore:
[17:39:37.609]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.609]    - tweaked: FALSE
[17:39:37.609]    - call: plan(strategy)
[17:39:37.614] plan(): nbrOfWorkers() = 2
[17:39:37.614] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.615]   - Field: ‘label’
[17:39:37.615]   - Field: ‘local’
[17:39:37.615]   - Field: ‘owner’
[17:39:37.615]   - Field: ‘envir’
[17:39:37.615]   - Field: ‘workers’
[17:39:37.615]   - Field: ‘packages’
[17:39:37.616]   - Field: ‘gc’
[17:39:37.616]   - Field: ‘job’
[17:39:37.616]   - Field: ‘conditions’
[17:39:37.616]   - Field: ‘expr’
[17:39:37.616]   - Field: ‘uuid’
[17:39:37.616]   - Field: ‘seed’
[17:39:37.616]   - Field: ‘version’
[17:39:37.617]   - Field: ‘result’
[17:39:37.617]   - Field: ‘asynchronous’
[17:39:37.617]   - Field: ‘calls’
[17:39:37.617]   - Field: ‘globals’
[17:39:37.617]   - Field: ‘stdout’
[17:39:37.617]   - Field: ‘earlySignal’
[17:39:37.617]   - Field: ‘lazy’
[17:39:37.618]   - Field: ‘state’
[17:39:37.618] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.618] - Launch lazy future ...
[17:39:37.618] Packages needed by the future expression (n = 0): <none>
[17:39:37.618] Packages needed by future strategies (n = 0): <none>
[17:39:37.619] {
[17:39:37.619]     {
[17:39:37.619]         {
[17:39:37.619]             ...future.startTime <- base::Sys.time()
[17:39:37.619]             {
[17:39:37.619]                 {
[17:39:37.619]                   {
[17:39:37.619]                     {
[17:39:37.619]                       base::local({
[17:39:37.619]                         has_future <- base::requireNamespace("future", 
[17:39:37.619]                           quietly = TRUE)
[17:39:37.619]                         if (has_future) {
[17:39:37.619]                           ns <- base::getNamespace("future")
[17:39:37.619]                           version <- ns[[".package"]][["version"]]
[17:39:37.619]                           if (is.null(version)) 
[17:39:37.619]                             version <- utils::packageVersion("future")
[17:39:37.619]                         }
[17:39:37.619]                         else {
[17:39:37.619]                           version <- NULL
[17:39:37.619]                         }
[17:39:37.619]                         if (!has_future || version < "1.8.0") {
[17:39:37.619]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.619]                             "", base::R.version$version.string), 
[17:39:37.619]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.619]                               "release", "version")], collapse = " "), 
[17:39:37.619]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.619]                             info)
[17:39:37.619]                           info <- base::paste(info, collapse = "; ")
[17:39:37.619]                           if (!has_future) {
[17:39:37.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.619]                               info)
[17:39:37.619]                           }
[17:39:37.619]                           else {
[17:39:37.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.619]                               info, version)
[17:39:37.619]                           }
[17:39:37.619]                           base::stop(msg)
[17:39:37.619]                         }
[17:39:37.619]                       })
[17:39:37.619]                     }
[17:39:37.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.619]                     base::options(mc.cores = 1L)
[17:39:37.619]                   }
[17:39:37.619]                   ...future.strategy.old <- future::plan("list")
[17:39:37.619]                   options(future.plan = NULL)
[17:39:37.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.619]                 }
[17:39:37.619]                 ...future.workdir <- getwd()
[17:39:37.619]             }
[17:39:37.619]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.619]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.619]         }
[17:39:37.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.619]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.619]             base::names(...future.oldOptions))
[17:39:37.619]     }
[17:39:37.619]     if (FALSE) {
[17:39:37.619]     }
[17:39:37.619]     else {
[17:39:37.619]         if (TRUE) {
[17:39:37.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.619]                 open = "w")
[17:39:37.619]         }
[17:39:37.619]         else {
[17:39:37.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.619]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.619]         }
[17:39:37.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.619]             base::sink(type = "output", split = FALSE)
[17:39:37.619]             base::close(...future.stdout)
[17:39:37.619]         }, add = TRUE)
[17:39:37.619]     }
[17:39:37.619]     ...future.frame <- base::sys.nframe()
[17:39:37.619]     ...future.conditions <- base::list()
[17:39:37.619]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.619]     if (FALSE) {
[17:39:37.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.619]     }
[17:39:37.619]     ...future.result <- base::tryCatch({
[17:39:37.619]         base::withCallingHandlers({
[17:39:37.619]             ...future.value <- base::withVisible(base::local({
[17:39:37.619]                 withCallingHandlers({
[17:39:37.619]                   NULL
[17:39:37.619]                 }, immediateCondition = function(cond) {
[17:39:37.619]                   save_rds <- function (object, pathname, ...) 
[17:39:37.619]                   {
[17:39:37.619]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.619]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.619]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.619]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.619]                         fi_tmp[["mtime"]])
[17:39:37.619]                     }
[17:39:37.619]                     tryCatch({
[17:39:37.619]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.619]                     }, error = function(ex) {
[17:39:37.619]                       msg <- conditionMessage(ex)
[17:39:37.619]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.619]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.619]                         fi_tmp[["mtime"]], msg)
[17:39:37.619]                       ex$message <- msg
[17:39:37.619]                       stop(ex)
[17:39:37.619]                     })
[17:39:37.619]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.619]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.619]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.619]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.619]                       fi <- file.info(pathname)
[17:39:37.619]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.619]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.619]                         fi[["size"]], fi[["mtime"]])
[17:39:37.619]                       stop(msg)
[17:39:37.619]                     }
[17:39:37.619]                     invisible(pathname)
[17:39:37.619]                   }
[17:39:37.619]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.619]                     rootPath = tempdir()) 
[17:39:37.619]                   {
[17:39:37.619]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.619]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.619]                       tmpdir = path, fileext = ".rds")
[17:39:37.619]                     save_rds(obj, file)
[17:39:37.619]                   }
[17:39:37.619]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.619]                   {
[17:39:37.619]                     inherits <- base::inherits
[17:39:37.619]                     invokeRestart <- base::invokeRestart
[17:39:37.619]                     is.null <- base::is.null
[17:39:37.619]                     muffled <- FALSE
[17:39:37.619]                     if (inherits(cond, "message")) {
[17:39:37.619]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.619]                       if (muffled) 
[17:39:37.619]                         invokeRestart("muffleMessage")
[17:39:37.619]                     }
[17:39:37.619]                     else if (inherits(cond, "warning")) {
[17:39:37.619]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.619]                       if (muffled) 
[17:39:37.619]                         invokeRestart("muffleWarning")
[17:39:37.619]                     }
[17:39:37.619]                     else if (inherits(cond, "condition")) {
[17:39:37.619]                       if (!is.null(pattern)) {
[17:39:37.619]                         computeRestarts <- base::computeRestarts
[17:39:37.619]                         grepl <- base::grepl
[17:39:37.619]                         restarts <- computeRestarts(cond)
[17:39:37.619]                         for (restart in restarts) {
[17:39:37.619]                           name <- restart$name
[17:39:37.619]                           if (is.null(name)) 
[17:39:37.619]                             next
[17:39:37.619]                           if (!grepl(pattern, name)) 
[17:39:37.619]                             next
[17:39:37.619]                           invokeRestart(restart)
[17:39:37.619]                           muffled <- TRUE
[17:39:37.619]                           break
[17:39:37.619]                         }
[17:39:37.619]                       }
[17:39:37.619]                     }
[17:39:37.619]                     invisible(muffled)
[17:39:37.619]                   }
[17:39:37.619]                   muffleCondition(cond)
[17:39:37.619]                 })
[17:39:37.619]             }))
[17:39:37.619]             future::FutureResult(value = ...future.value$value, 
[17:39:37.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.619]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.619]                     ...future.globalenv.names))
[17:39:37.619]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.619]         }, condition = base::local({
[17:39:37.619]             c <- base::c
[17:39:37.619]             inherits <- base::inherits
[17:39:37.619]             invokeRestart <- base::invokeRestart
[17:39:37.619]             length <- base::length
[17:39:37.619]             list <- base::list
[17:39:37.619]             seq.int <- base::seq.int
[17:39:37.619]             signalCondition <- base::signalCondition
[17:39:37.619]             sys.calls <- base::sys.calls
[17:39:37.619]             `[[` <- base::`[[`
[17:39:37.619]             `+` <- base::`+`
[17:39:37.619]             `<<-` <- base::`<<-`
[17:39:37.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.619]                   3L)]
[17:39:37.619]             }
[17:39:37.619]             function(cond) {
[17:39:37.619]                 is_error <- inherits(cond, "error")
[17:39:37.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.619]                   NULL)
[17:39:37.619]                 if (is_error) {
[17:39:37.619]                   sessionInformation <- function() {
[17:39:37.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.619]                       search = base::search(), system = base::Sys.info())
[17:39:37.619]                   }
[17:39:37.619]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.619]                     cond$call), session = sessionInformation(), 
[17:39:37.619]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.619]                   signalCondition(cond)
[17:39:37.619]                 }
[17:39:37.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.619]                 "immediateCondition"))) {
[17:39:37.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.619]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.619]                   if (TRUE && !signal) {
[17:39:37.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.619]                     {
[17:39:37.619]                       inherits <- base::inherits
[17:39:37.619]                       invokeRestart <- base::invokeRestart
[17:39:37.619]                       is.null <- base::is.null
[17:39:37.619]                       muffled <- FALSE
[17:39:37.619]                       if (inherits(cond, "message")) {
[17:39:37.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.619]                         if (muffled) 
[17:39:37.619]                           invokeRestart("muffleMessage")
[17:39:37.619]                       }
[17:39:37.619]                       else if (inherits(cond, "warning")) {
[17:39:37.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.619]                         if (muffled) 
[17:39:37.619]                           invokeRestart("muffleWarning")
[17:39:37.619]                       }
[17:39:37.619]                       else if (inherits(cond, "condition")) {
[17:39:37.619]                         if (!is.null(pattern)) {
[17:39:37.619]                           computeRestarts <- base::computeRestarts
[17:39:37.619]                           grepl <- base::grepl
[17:39:37.619]                           restarts <- computeRestarts(cond)
[17:39:37.619]                           for (restart in restarts) {
[17:39:37.619]                             name <- restart$name
[17:39:37.619]                             if (is.null(name)) 
[17:39:37.619]                               next
[17:39:37.619]                             if (!grepl(pattern, name)) 
[17:39:37.619]                               next
[17:39:37.619]                             invokeRestart(restart)
[17:39:37.619]                             muffled <- TRUE
[17:39:37.619]                             break
[17:39:37.619]                           }
[17:39:37.619]                         }
[17:39:37.619]                       }
[17:39:37.619]                       invisible(muffled)
[17:39:37.619]                     }
[17:39:37.619]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.619]                   }
[17:39:37.619]                 }
[17:39:37.619]                 else {
[17:39:37.619]                   if (TRUE) {
[17:39:37.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.619]                     {
[17:39:37.619]                       inherits <- base::inherits
[17:39:37.619]                       invokeRestart <- base::invokeRestart
[17:39:37.619]                       is.null <- base::is.null
[17:39:37.619]                       muffled <- FALSE
[17:39:37.619]                       if (inherits(cond, "message")) {
[17:39:37.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.619]                         if (muffled) 
[17:39:37.619]                           invokeRestart("muffleMessage")
[17:39:37.619]                       }
[17:39:37.619]                       else if (inherits(cond, "warning")) {
[17:39:37.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.619]                         if (muffled) 
[17:39:37.619]                           invokeRestart("muffleWarning")
[17:39:37.619]                       }
[17:39:37.619]                       else if (inherits(cond, "condition")) {
[17:39:37.619]                         if (!is.null(pattern)) {
[17:39:37.619]                           computeRestarts <- base::computeRestarts
[17:39:37.619]                           grepl <- base::grepl
[17:39:37.619]                           restarts <- computeRestarts(cond)
[17:39:37.619]                           for (restart in restarts) {
[17:39:37.619]                             name <- restart$name
[17:39:37.619]                             if (is.null(name)) 
[17:39:37.619]                               next
[17:39:37.619]                             if (!grepl(pattern, name)) 
[17:39:37.619]                               next
[17:39:37.619]                             invokeRestart(restart)
[17:39:37.619]                             muffled <- TRUE
[17:39:37.619]                             break
[17:39:37.619]                           }
[17:39:37.619]                         }
[17:39:37.619]                       }
[17:39:37.619]                       invisible(muffled)
[17:39:37.619]                     }
[17:39:37.619]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.619]                   }
[17:39:37.619]                 }
[17:39:37.619]             }
[17:39:37.619]         }))
[17:39:37.619]     }, error = function(ex) {
[17:39:37.619]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.619]                 ...future.rng), started = ...future.startTime, 
[17:39:37.619]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.619]             version = "1.8"), class = "FutureResult")
[17:39:37.619]     }, finally = {
[17:39:37.619]         if (!identical(...future.workdir, getwd())) 
[17:39:37.619]             setwd(...future.workdir)
[17:39:37.619]         {
[17:39:37.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.619]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.619]             }
[17:39:37.619]             base::options(...future.oldOptions)
[17:39:37.619]             if (.Platform$OS.type == "windows") {
[17:39:37.619]                 old_names <- names(...future.oldEnvVars)
[17:39:37.619]                 envs <- base::Sys.getenv()
[17:39:37.619]                 names <- names(envs)
[17:39:37.619]                 common <- intersect(names, old_names)
[17:39:37.619]                 added <- setdiff(names, old_names)
[17:39:37.619]                 removed <- setdiff(old_names, names)
[17:39:37.619]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.619]                   envs[common]]
[17:39:37.619]                 NAMES <- toupper(changed)
[17:39:37.619]                 args <- list()
[17:39:37.619]                 for (kk in seq_along(NAMES)) {
[17:39:37.619]                   name <- changed[[kk]]
[17:39:37.619]                   NAME <- NAMES[[kk]]
[17:39:37.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.619]                     next
[17:39:37.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.619]                 }
[17:39:37.619]                 NAMES <- toupper(added)
[17:39:37.619]                 for (kk in seq_along(NAMES)) {
[17:39:37.619]                   name <- added[[kk]]
[17:39:37.619]                   NAME <- NAMES[[kk]]
[17:39:37.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.619]                     next
[17:39:37.619]                   args[[name]] <- ""
[17:39:37.619]                 }
[17:39:37.619]                 NAMES <- toupper(removed)
[17:39:37.619]                 for (kk in seq_along(NAMES)) {
[17:39:37.619]                   name <- removed[[kk]]
[17:39:37.619]                   NAME <- NAMES[[kk]]
[17:39:37.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.619]                     next
[17:39:37.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.619]                 }
[17:39:37.619]                 if (length(args) > 0) 
[17:39:37.619]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.619]             }
[17:39:37.619]             else {
[17:39:37.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.619]             }
[17:39:37.619]             {
[17:39:37.619]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.619]                   0L) {
[17:39:37.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.619]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.619]                   base::options(opts)
[17:39:37.619]                 }
[17:39:37.619]                 {
[17:39:37.619]                   {
[17:39:37.619]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.619]                     NULL
[17:39:37.619]                   }
[17:39:37.619]                   options(future.plan = NULL)
[17:39:37.619]                   if (is.na(NA_character_)) 
[17:39:37.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.619]                     .init = FALSE)
[17:39:37.619]                 }
[17:39:37.619]             }
[17:39:37.619]         }
[17:39:37.619]     })
[17:39:37.619]     if (TRUE) {
[17:39:37.619]         base::sink(type = "output", split = FALSE)
[17:39:37.619]         if (TRUE) {
[17:39:37.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.619]         }
[17:39:37.619]         else {
[17:39:37.619]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.619]         }
[17:39:37.619]         base::close(...future.stdout)
[17:39:37.619]         ...future.stdout <- NULL
[17:39:37.619]     }
[17:39:37.619]     ...future.result$conditions <- ...future.conditions
[17:39:37.619]     ...future.result$finished <- base::Sys.time()
[17:39:37.619]     ...future.result
[17:39:37.619] }
[17:39:37.623] requestCore(): workers = 2
[17:39:37.626] MulticoreFuture started
[17:39:37.626] - Launch lazy future ... done
[17:39:37.627] run() for ‘MulticoreFuture’ ... done
[17:39:37.627] plan(): Setting new future strategy stack:
[17:39:37.628] getGlobalsAndPackages() ...
[17:39:37.628] Searching for globals...
[17:39:37.627] List of future strategies:
[17:39:37.627] 1. sequential:
[17:39:37.627]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.627]    - tweaked: FALSE
[17:39:37.627]    - call: NULL
[17:39:37.628] plan(): nbrOfWorkers() = 1
[17:39:37.629] - globals found: [1] ‘{’
[17:39:37.629] Searching for globals ... DONE
[17:39:37.630] Resolving globals: FALSE
[17:39:37.630] 
[17:39:37.630] 
[17:39:37.630] getGlobalsAndPackages() ... DONE
[17:39:37.630] plan(): Setting new future strategy stack:
[17:39:37.631] run() for ‘Future’ ...
[17:39:37.631] List of future strategies:
[17:39:37.631] 1. multicore:
[17:39:37.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.631]    - tweaked: FALSE
[17:39:37.631]    - call: plan(strategy)
[17:39:37.631] - state: ‘created’
[17:39:37.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:39:37.636] plan(): nbrOfWorkers() = 2
[17:39:37.637] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:37.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:39:37.637]   - Field: ‘label’
[17:39:37.637]   - Field: ‘local’
[17:39:37.638]   - Field: ‘owner’
[17:39:37.638]   - Field: ‘envir’
[17:39:37.638]   - Field: ‘workers’
[17:39:37.638]   - Field: ‘packages’
[17:39:37.638]   - Field: ‘gc’
[17:39:37.638]   - Field: ‘job’
[17:39:37.638]   - Field: ‘conditions’
[17:39:37.638]   - Field: ‘expr’
[17:39:37.639]   - Field: ‘uuid’
[17:39:37.639]   - Field: ‘seed’
[17:39:37.639]   - Field: ‘version’
[17:39:37.639]   - Field: ‘result’
[17:39:37.639]   - Field: ‘asynchronous’
[17:39:37.639]   - Field: ‘calls’
[17:39:37.639]   - Field: ‘globals’
[17:39:37.640]   - Field: ‘stdout’
[17:39:37.640]   - Field: ‘earlySignal’
[17:39:37.640]   - Field: ‘lazy’
[17:39:37.640]   - Field: ‘state’
[17:39:37.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:39:37.640] - Launch lazy future ...
[17:39:37.641] Packages needed by the future expression (n = 0): <none>
[17:39:37.641] Packages needed by future strategies (n = 0): <none>
[17:39:37.642] {
[17:39:37.642]     {
[17:39:37.642]         {
[17:39:37.642]             ...future.startTime <- base::Sys.time()
[17:39:37.642]             {
[17:39:37.642]                 {
[17:39:37.642]                   {
[17:39:37.642]                     {
[17:39:37.642]                       base::local({
[17:39:37.642]                         has_future <- base::requireNamespace("future", 
[17:39:37.642]                           quietly = TRUE)
[17:39:37.642]                         if (has_future) {
[17:39:37.642]                           ns <- base::getNamespace("future")
[17:39:37.642]                           version <- ns[[".package"]][["version"]]
[17:39:37.642]                           if (is.null(version)) 
[17:39:37.642]                             version <- utils::packageVersion("future")
[17:39:37.642]                         }
[17:39:37.642]                         else {
[17:39:37.642]                           version <- NULL
[17:39:37.642]                         }
[17:39:37.642]                         if (!has_future || version < "1.8.0") {
[17:39:37.642]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:37.642]                             "", base::R.version$version.string), 
[17:39:37.642]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:37.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:37.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:37.642]                               "release", "version")], collapse = " "), 
[17:39:37.642]                             hostname = base::Sys.info()[["nodename"]])
[17:39:37.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:37.642]                             info)
[17:39:37.642]                           info <- base::paste(info, collapse = "; ")
[17:39:37.642]                           if (!has_future) {
[17:39:37.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:37.642]                               info)
[17:39:37.642]                           }
[17:39:37.642]                           else {
[17:39:37.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:37.642]                               info, version)
[17:39:37.642]                           }
[17:39:37.642]                           base::stop(msg)
[17:39:37.642]                         }
[17:39:37.642]                       })
[17:39:37.642]                     }
[17:39:37.642]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:37.642]                     base::options(mc.cores = 1L)
[17:39:37.642]                   }
[17:39:37.642]                   ...future.strategy.old <- future::plan("list")
[17:39:37.642]                   options(future.plan = NULL)
[17:39:37.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:37.642]                 }
[17:39:37.642]                 ...future.workdir <- getwd()
[17:39:37.642]             }
[17:39:37.642]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:37.642]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:37.642]         }
[17:39:37.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:37.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:37.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:37.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:37.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:37.642]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:37.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:37.642]             base::names(...future.oldOptions))
[17:39:37.642]     }
[17:39:37.642]     if (FALSE) {
[17:39:37.642]     }
[17:39:37.642]     else {
[17:39:37.642]         if (TRUE) {
[17:39:37.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:37.642]                 open = "w")
[17:39:37.642]         }
[17:39:37.642]         else {
[17:39:37.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:37.642]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:37.642]         }
[17:39:37.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:37.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:37.642]             base::sink(type = "output", split = FALSE)
[17:39:37.642]             base::close(...future.stdout)
[17:39:37.642]         }, add = TRUE)
[17:39:37.642]     }
[17:39:37.642]     ...future.frame <- base::sys.nframe()
[17:39:37.642]     ...future.conditions <- base::list()
[17:39:37.642]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:37.642]     if (FALSE) {
[17:39:37.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:37.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:37.642]     }
[17:39:37.642]     ...future.result <- base::tryCatch({
[17:39:37.642]         base::withCallingHandlers({
[17:39:37.642]             ...future.value <- base::withVisible(base::local({
[17:39:37.642]                 withCallingHandlers({
[17:39:37.642]                   {
[17:39:37.642]                     4
[17:39:37.642]                   }
[17:39:37.642]                 }, immediateCondition = function(cond) {
[17:39:37.642]                   save_rds <- function (object, pathname, ...) 
[17:39:37.642]                   {
[17:39:37.642]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:39:37.642]                     if (file_test("-f", pathname_tmp)) {
[17:39:37.642]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.642]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:39:37.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.642]                         fi_tmp[["mtime"]])
[17:39:37.642]                     }
[17:39:37.642]                     tryCatch({
[17:39:37.642]                       saveRDS(object, file = pathname_tmp, ...)
[17:39:37.642]                     }, error = function(ex) {
[17:39:37.642]                       msg <- conditionMessage(ex)
[17:39:37.642]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.642]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:39:37.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.642]                         fi_tmp[["mtime"]], msg)
[17:39:37.642]                       ex$message <- msg
[17:39:37.642]                       stop(ex)
[17:39:37.642]                     })
[17:39:37.642]                     stopifnot(file_test("-f", pathname_tmp))
[17:39:37.642]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:39:37.642]                     if (!res || file_test("-f", pathname_tmp)) {
[17:39:37.642]                       fi_tmp <- file.info(pathname_tmp)
[17:39:37.642]                       fi <- file.info(pathname)
[17:39:37.642]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:39:37.642]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:39:37.642]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:39:37.642]                         fi[["size"]], fi[["mtime"]])
[17:39:37.642]                       stop(msg)
[17:39:37.642]                     }
[17:39:37.642]                     invisible(pathname)
[17:39:37.642]                   }
[17:39:37.642]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:39:37.642]                     rootPath = tempdir()) 
[17:39:37.642]                   {
[17:39:37.642]                     obj <- list(time = Sys.time(), condition = cond)
[17:39:37.642]                     file <- tempfile(pattern = class(cond)[1], 
[17:39:37.642]                       tmpdir = path, fileext = ".rds")
[17:39:37.642]                     save_rds(obj, file)
[17:39:37.642]                   }
[17:39:37.642]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8ZyoGD/.future/immediateConditions")
[17:39:37.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.642]                   {
[17:39:37.642]                     inherits <- base::inherits
[17:39:37.642]                     invokeRestart <- base::invokeRestart
[17:39:37.642]                     is.null <- base::is.null
[17:39:37.642]                     muffled <- FALSE
[17:39:37.642]                     if (inherits(cond, "message")) {
[17:39:37.642]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:37.642]                       if (muffled) 
[17:39:37.642]                         invokeRestart("muffleMessage")
[17:39:37.642]                     }
[17:39:37.642]                     else if (inherits(cond, "warning")) {
[17:39:37.642]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:37.642]                       if (muffled) 
[17:39:37.642]                         invokeRestart("muffleWarning")
[17:39:37.642]                     }
[17:39:37.642]                     else if (inherits(cond, "condition")) {
[17:39:37.642]                       if (!is.null(pattern)) {
[17:39:37.642]                         computeRestarts <- base::computeRestarts
[17:39:37.642]                         grepl <- base::grepl
[17:39:37.642]                         restarts <- computeRestarts(cond)
[17:39:37.642]                         for (restart in restarts) {
[17:39:37.642]                           name <- restart$name
[17:39:37.642]                           if (is.null(name)) 
[17:39:37.642]                             next
[17:39:37.642]                           if (!grepl(pattern, name)) 
[17:39:37.642]                             next
[17:39:37.642]                           invokeRestart(restart)
[17:39:37.642]                           muffled <- TRUE
[17:39:37.642]                           break
[17:39:37.642]                         }
[17:39:37.642]                       }
[17:39:37.642]                     }
[17:39:37.642]                     invisible(muffled)
[17:39:37.642]                   }
[17:39:37.642]                   muffleCondition(cond)
[17:39:37.642]                 })
[17:39:37.642]             }))
[17:39:37.642]             future::FutureResult(value = ...future.value$value, 
[17:39:37.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.642]                   ...future.rng), globalenv = if (FALSE) 
[17:39:37.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:37.642]                     ...future.globalenv.names))
[17:39:37.642]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:37.642]         }, condition = base::local({
[17:39:37.642]             c <- base::c
[17:39:37.642]             inherits <- base::inherits
[17:39:37.642]             invokeRestart <- base::invokeRestart
[17:39:37.642]             length <- base::length
[17:39:37.642]             list <- base::list
[17:39:37.642]             seq.int <- base::seq.int
[17:39:37.642]             signalCondition <- base::signalCondition
[17:39:37.642]             sys.calls <- base::sys.calls
[17:39:37.642]             `[[` <- base::`[[`
[17:39:37.642]             `+` <- base::`+`
[17:39:37.642]             `<<-` <- base::`<<-`
[17:39:37.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:37.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:37.642]                   3L)]
[17:39:37.642]             }
[17:39:37.642]             function(cond) {
[17:39:37.642]                 is_error <- inherits(cond, "error")
[17:39:37.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:37.642]                   NULL)
[17:39:37.642]                 if (is_error) {
[17:39:37.642]                   sessionInformation <- function() {
[17:39:37.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:37.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:37.642]                       search = base::search(), system = base::Sys.info())
[17:39:37.642]                   }
[17:39:37.642]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:37.642]                     cond$call), session = sessionInformation(), 
[17:39:37.642]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:37.642]                   signalCondition(cond)
[17:39:37.642]                 }
[17:39:37.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:37.642]                 "immediateCondition"))) {
[17:39:37.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:37.642]                   ...future.conditions[[length(...future.conditions) + 
[17:39:37.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:37.642]                   if (TRUE && !signal) {
[17:39:37.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.642]                     {
[17:39:37.642]                       inherits <- base::inherits
[17:39:37.642]                       invokeRestart <- base::invokeRestart
[17:39:37.642]                       is.null <- base::is.null
[17:39:37.642]                       muffled <- FALSE
[17:39:37.642]                       if (inherits(cond, "message")) {
[17:39:37.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.642]                         if (muffled) 
[17:39:37.642]                           invokeRestart("muffleMessage")
[17:39:37.642]                       }
[17:39:37.642]                       else if (inherits(cond, "warning")) {
[17:39:37.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.642]                         if (muffled) 
[17:39:37.642]                           invokeRestart("muffleWarning")
[17:39:37.642]                       }
[17:39:37.642]                       else if (inherits(cond, "condition")) {
[17:39:37.642]                         if (!is.null(pattern)) {
[17:39:37.642]                           computeRestarts <- base::computeRestarts
[17:39:37.642]                           grepl <- base::grepl
[17:39:37.642]                           restarts <- computeRestarts(cond)
[17:39:37.642]                           for (restart in restarts) {
[17:39:37.642]                             name <- restart$name
[17:39:37.642]                             if (is.null(name)) 
[17:39:37.642]                               next
[17:39:37.642]                             if (!grepl(pattern, name)) 
[17:39:37.642]                               next
[17:39:37.642]                             invokeRestart(restart)
[17:39:37.642]                             muffled <- TRUE
[17:39:37.642]                             break
[17:39:37.642]                           }
[17:39:37.642]                         }
[17:39:37.642]                       }
[17:39:37.642]                       invisible(muffled)
[17:39:37.642]                     }
[17:39:37.642]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.642]                   }
[17:39:37.642]                 }
[17:39:37.642]                 else {
[17:39:37.642]                   if (TRUE) {
[17:39:37.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:37.642]                     {
[17:39:37.642]                       inherits <- base::inherits
[17:39:37.642]                       invokeRestart <- base::invokeRestart
[17:39:37.642]                       is.null <- base::is.null
[17:39:37.642]                       muffled <- FALSE
[17:39:37.642]                       if (inherits(cond, "message")) {
[17:39:37.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:37.642]                         if (muffled) 
[17:39:37.642]                           invokeRestart("muffleMessage")
[17:39:37.642]                       }
[17:39:37.642]                       else if (inherits(cond, "warning")) {
[17:39:37.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:37.642]                         if (muffled) 
[17:39:37.642]                           invokeRestart("muffleWarning")
[17:39:37.642]                       }
[17:39:37.642]                       else if (inherits(cond, "condition")) {
[17:39:37.642]                         if (!is.null(pattern)) {
[17:39:37.642]                           computeRestarts <- base::computeRestarts
[17:39:37.642]                           grepl <- base::grepl
[17:39:37.642]                           restarts <- computeRestarts(cond)
[17:39:37.642]                           for (restart in restarts) {
[17:39:37.642]                             name <- restart$name
[17:39:37.642]                             if (is.null(name)) 
[17:39:37.642]                               next
[17:39:37.642]                             if (!grepl(pattern, name)) 
[17:39:37.642]                               next
[17:39:37.642]                             invokeRestart(restart)
[17:39:37.642]                             muffled <- TRUE
[17:39:37.642]                             break
[17:39:37.642]                           }
[17:39:37.642]                         }
[17:39:37.642]                       }
[17:39:37.642]                       invisible(muffled)
[17:39:37.642]                     }
[17:39:37.642]                     muffleCondition(cond, pattern = "^muffle")
[17:39:37.642]                   }
[17:39:37.642]                 }
[17:39:37.642]             }
[17:39:37.642]         }))
[17:39:37.642]     }, error = function(ex) {
[17:39:37.642]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:37.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:37.642]                 ...future.rng), started = ...future.startTime, 
[17:39:37.642]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:37.642]             version = "1.8"), class = "FutureResult")
[17:39:37.642]     }, finally = {
[17:39:37.642]         if (!identical(...future.workdir, getwd())) 
[17:39:37.642]             setwd(...future.workdir)
[17:39:37.642]         {
[17:39:37.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:37.642]                 ...future.oldOptions$nwarnings <- NULL
[17:39:37.642]             }
[17:39:37.642]             base::options(...future.oldOptions)
[17:39:37.642]             if (.Platform$OS.type == "windows") {
[17:39:37.642]                 old_names <- names(...future.oldEnvVars)
[17:39:37.642]                 envs <- base::Sys.getenv()
[17:39:37.642]                 names <- names(envs)
[17:39:37.642]                 common <- intersect(names, old_names)
[17:39:37.642]                 added <- setdiff(names, old_names)
[17:39:37.642]                 removed <- setdiff(old_names, names)
[17:39:37.642]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:37.642]                   envs[common]]
[17:39:37.642]                 NAMES <- toupper(changed)
[17:39:37.642]                 args <- list()
[17:39:37.642]                 for (kk in seq_along(NAMES)) {
[17:39:37.642]                   name <- changed[[kk]]
[17:39:37.642]                   NAME <- NAMES[[kk]]
[17:39:37.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.642]                     next
[17:39:37.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.642]                 }
[17:39:37.642]                 NAMES <- toupper(added)
[17:39:37.642]                 for (kk in seq_along(NAMES)) {
[17:39:37.642]                   name <- added[[kk]]
[17:39:37.642]                   NAME <- NAMES[[kk]]
[17:39:37.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.642]                     next
[17:39:37.642]                   args[[name]] <- ""
[17:39:37.642]                 }
[17:39:37.642]                 NAMES <- toupper(removed)
[17:39:37.642]                 for (kk in seq_along(NAMES)) {
[17:39:37.642]                   name <- removed[[kk]]
[17:39:37.642]                   NAME <- NAMES[[kk]]
[17:39:37.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:37.642]                     next
[17:39:37.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:37.642]                 }
[17:39:37.642]                 if (length(args) > 0) 
[17:39:37.642]                   base::do.call(base::Sys.setenv, args = args)
[17:39:37.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:37.642]             }
[17:39:37.642]             else {
[17:39:37.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:37.642]             }
[17:39:37.642]             {
[17:39:37.642]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:37.642]                   0L) {
[17:39:37.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:37.642]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:37.642]                   base::options(opts)
[17:39:37.642]                 }
[17:39:37.642]                 {
[17:39:37.642]                   {
[17:39:37.642]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:37.642]                     NULL
[17:39:37.642]                   }
[17:39:37.642]                   options(future.plan = NULL)
[17:39:37.642]                   if (is.na(NA_character_)) 
[17:39:37.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:37.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:37.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:37.642]                     .init = FALSE)
[17:39:37.642]                 }
[17:39:37.642]             }
[17:39:37.642]         }
[17:39:37.642]     })
[17:39:37.642]     if (TRUE) {
[17:39:37.642]         base::sink(type = "output", split = FALSE)
[17:39:37.642]         if (TRUE) {
[17:39:37.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:37.642]         }
[17:39:37.642]         else {
[17:39:37.642]             ...future.result["stdout"] <- base::list(NULL)
[17:39:37.642]         }
[17:39:37.642]         base::close(...future.stdout)
[17:39:37.642]         ...future.stdout <- NULL
[17:39:37.642]     }
[17:39:37.642]     ...future.result$conditions <- ...future.conditions
[17:39:37.642]     ...future.result$finished <- base::Sys.time()
[17:39:37.642]     ...future.result
[17:39:37.642] }
[17:39:37.645] requestCore(): workers = 2
[17:39:37.646] Poll #1 (0): usedCores() = 2, workers = 2
[17:39:37.656] result() for MulticoreFuture ...
[17:39:37.657] result() for MulticoreFuture ...
[17:39:37.657] result() for MulticoreFuture ... done
[17:39:37.658] result() for MulticoreFuture ... done
[17:39:37.658] result() for MulticoreFuture ...
[17:39:37.658] result() for MulticoreFuture ... done
[17:39:37.661] MulticoreFuture started
[17:39:37.662] - Launch lazy future ... done
[17:39:37.662] run() for ‘MulticoreFuture’ ... done
[17:39:37.662] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55adf08c0960> 
[17:39:37.663] List of future strategies:
[17:39:37.663] 1. sequential:
[17:39:37.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:37.663]    - tweaked: FALSE
[17:39:37.663]    - call: NULL
[17:39:37.664] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55adf1c05bf0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[17:39:37.666] plan(): Setting new future strategy stack:
List of 4
  ..$ :[17:39:37.666] List of future strategies:
[17:39:37.666] 1. multicore:
[17:39:37.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:39:37.666]    - tweaked: FALSE
[17:39:37.666]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:37.671] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:37.675] resolve() on list environment ...
[17:39:37.675]  recursive: 0
[17:39:37.677]  length: 6
[17:39:37.677]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:37.677] signalConditionsASAP(numeric, pos=1) ...
[17:39:37.677] - nx: 6
[17:39:37.677] - relay: TRUE
[17:39:37.677] - stdout: TRUE
[17:39:37.678] - signal: TRUE
[17:39:37.678] - resignal: FALSE
[17:39:37.678] - force: TRUE
[17:39:37.678] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.678] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.678]  - until=2
[17:39:37.678]  - relaying element #2
[17:39:37.678] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.679] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.679] signalConditionsASAP(NULL, pos=1) ... done
[17:39:37.679]  length: 5 (resolved future 1)
[17:39:37.679] Future #2
[17:39:37.679] result() for MulticoreFuture ...
[17:39:37.679] result() for MulticoreFuture ... done
[17:39:37.680] result() for MulticoreFuture ...
[17:39:37.680] result() for MulticoreFuture ... done
[17:39:37.680] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:39:37.680] - nx: 6
[17:39:37.680] - relay: TRUE
[17:39:37.680] - stdout: TRUE
[17:39:37.680] - signal: TRUE
[17:39:37.680] - resignal: FALSE
[17:39:37.681] - force: TRUE
[17:39:37.681] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.681] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:37.681]  - until=2
[17:39:37.681]  - relaying element #2
[17:39:37.681] result() for MulticoreFuture ...
[17:39:37.681] result() for MulticoreFuture ... done
[17:39:37.682] result() for MulticoreFuture ...
[17:39:37.682] result() for MulticoreFuture ... done
[17:39:37.682] result() for MulticoreFuture ...
[17:39:37.682] result() for MulticoreFuture ... done
[17:39:37.682] result() for MulticoreFuture ...
[17:39:37.682] result() for MulticoreFuture ... done
[17:39:37.682] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.682] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.683] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:39:37.683]  length: 4 (resolved future 2)
[17:39:37.683] Future #3
[17:39:37.683] result() for MulticoreFuture ...
[17:39:37.684] result() for MulticoreFuture ...
[17:39:37.684] result() for MulticoreFuture ... done
[17:39:37.685] result() for MulticoreFuture ... done
[17:39:37.685] result() for MulticoreFuture ...
[17:39:37.685] result() for MulticoreFuture ... done
[17:39:37.685] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:39:37.685] - nx: 6
[17:39:37.685] - relay: TRUE
[17:39:37.686] - stdout: TRUE
[17:39:37.686] - signal: TRUE
[17:39:37.686] - resignal: FALSE
[17:39:37.686] - force: TRUE
[17:39:37.686] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.686] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:37.686]  - until=3
[17:39:37.687]  - relaying element #3
[17:39:37.687] result() for MulticoreFuture ...
[17:39:37.687] result() for MulticoreFuture ... done
[17:39:37.687] result() for MulticoreFuture ...
[17:39:37.687] result() for MulticoreFuture ... done
[17:39:37.688] result() for MulticoreFuture ...
[17:39:37.688] result() for MulticoreFuture ... done
[17:39:37.688] result() for MulticoreFuture ...
[17:39:37.688] result() for MulticoreFuture ... done
[17:39:37.688] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.688] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.689] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:39:37.689]  length: 3 (resolved future 3)
[17:39:37.689] Future #4
[17:39:37.689] result() for MulticoreFuture ...
[17:39:37.690] result() for MulticoreFuture ...
[17:39:37.690] result() for MulticoreFuture ... done
[17:39:37.695] result() for MulticoreFuture ... done
[17:39:37.695] result() for MulticoreFuture ...
[17:39:37.695] result() for MulticoreFuture ... done
[17:39:37.696] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:39:37.696] - nx: 6
[17:39:37.696] - relay: TRUE
[17:39:37.696] - stdout: TRUE
[17:39:37.696] - signal: TRUE
[17:39:37.697] - resignal: FALSE
[17:39:37.697] - force: TRUE
[17:39:37.697] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.697] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:37.697]  - until=4
[17:39:37.697]  - relaying element #4
[17:39:37.697] result() for MulticoreFuture ...
[17:39:37.697] result() for MulticoreFuture ... done
[17:39:37.698] result() for MulticoreFuture ...
[17:39:37.698] result() for MulticoreFuture ... done
[17:39:37.698] result() for MulticoreFuture ...
[17:39:37.698] result() for MulticoreFuture ... done
[17:39:37.698] result() for MulticoreFuture ...
[17:39:37.698] result() for MulticoreFuture ... done
[17:39:37.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.698] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.698] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:39:37.699]  length: 2 (resolved future 4)
[17:39:37.699] signalConditionsASAP(NULL, pos=5) ...
[17:39:37.699] - nx: 6
[17:39:37.699] - relay: TRUE
[17:39:37.699] - stdout: TRUE
[17:39:37.699] - signal: TRUE
[17:39:37.699] - resignal: FALSE
[17:39:37.699] - force: TRUE
[17:39:37.699] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.699] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.700]  - until=6
[17:39:37.700]  - relaying element #6
[17:39:37.700] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.700] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.700] signalConditionsASAP(NULL, pos=5) ... done
[17:39:37.700]  length: 1 (resolved future 5)
[17:39:37.700] signalConditionsASAP(numeric, pos=6) ...
[17:39:37.700] - nx: 6
[17:39:37.701] - relay: TRUE
[17:39:37.701] - stdout: TRUE
[17:39:37.701] - signal: TRUE
[17:39:37.701] - resignal: FALSE
[17:39:37.701] - force: TRUE
[17:39:37.701] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:37.701] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.701]  - until=6
[17:39:37.701] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.702] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.702] signalConditionsASAP(numeric, pos=6) ... done
[17:39:37.702]  length: 0 (resolved future 6)
[17:39:37.702] Relaying remaining futures
[17:39:37.702] signalConditionsASAP(NULL, pos=0) ...
[17:39:37.702] - nx: 6
[17:39:37.702] - relay: TRUE
[17:39:37.702] - stdout: TRUE
[17:39:37.702] - signal: TRUE
[17:39:37.703] - resignal: FALSE
[17:39:37.703] - force: TRUE
[17:39:37.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:37.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:37.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:37.703] signalConditionsASAP(NULL, pos=0) ... done
[17:39:37.703] resolve() on list environment ... DONE
[17:39:37.704] result() for MulticoreFuture ...
[17:39:37.704] result() for MulticoreFuture ... done
[17:39:37.704] result() for MulticoreFuture ...
[17:39:37.704] result() for MulticoreFuture ... done
[17:39:37.704] result() for MulticoreFuture ...
[17:39:37.704] result() for MulticoreFuture ... done
[17:39:37.704] result() for MulticoreFuture ...
[17:39:37.705] result() for MulticoreFuture ... done
[17:39:37.705] result() for MulticoreFuture ...
[17:39:37.705] result() for MulticoreFuture ... done
[17:39:37.705] result() for MulticoreFuture ...
[17:39:37.705] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf1ed8fb8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:39:37.708] plan(): Setting new future strategy stack:
[17:39:37.708] List of future strategies:
[17:39:37.708] 1. multisession:
[17:39:37.708]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:37.708]    - tweaked: FALSE
[17:39:37.708]    - call: plan(strategy)
[17:39:37.709] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:39:37.709] multisession:
[17:39:37.709] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:39:37.709] - tweaked: FALSE
[17:39:37.709] - call: plan(strategy)
[17:39:37.713] getGlobalsAndPackages() ...
[17:39:37.713] Not searching for globals
[17:39:37.714] - globals: [0] <none>
[17:39:37.714] getGlobalsAndPackages() ... DONE
[17:39:37.714] [local output] makeClusterPSOCK() ...
[17:39:37.718] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:39:37.718] [local output] Base port: 11960
[17:39:37.719] [local output] Getting setup options for 2 cluster nodes ...
[17:39:37.719] [local output]  - Node 1 of 2 ...
[17:39:37.719] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:37.720] [local output] Rscript port: 11960

[17:39:37.720] [local output]  - Node 2 of 2 ...
[17:39:37.721] [local output] localMachine=TRUE => revtunnel=FALSE

[17:39:37.721] [local output] Rscript port: 11960

[17:39:37.721] [local output] Getting setup options for 2 cluster nodes ... done
[17:39:37.722] [local output]  - Parallel setup requested for some PSOCK nodes
[17:39:37.722] [local output] Setting up PSOCK nodes in parallel
[17:39:37.722] List of 36
[17:39:37.722]  $ worker          : chr "localhost"
[17:39:37.722]   ..- attr(*, "localhost")= logi TRUE
[17:39:37.722]  $ master          : chr "localhost"
[17:39:37.722]  $ port            : int 11960
[17:39:37.722]  $ connectTimeout  : num 120
[17:39:37.722]  $ timeout         : num 2592000
[17:39:37.722]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:39:37.722]  $ homogeneous     : logi TRUE
[17:39:37.722]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:39:37.722]  $ rscript_envs    : NULL
[17:39:37.722]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:37.722]  $ rscript_startup : NULL
[17:39:37.722]  $ rscript_sh      : chr "sh"
[17:39:37.722]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:37.722]  $ methods         : logi TRUE
[17:39:37.722]  $ socketOptions   : chr "no-delay"
[17:39:37.722]  $ useXDR          : logi FALSE
[17:39:37.722]  $ outfile         : chr "/dev/null"
[17:39:37.722]  $ renice          : int NA
[17:39:37.722]  $ rshcmd          : NULL
[17:39:37.722]  $ user            : chr(0) 
[17:39:37.722]  $ revtunnel       : logi FALSE
[17:39:37.722]  $ rshlogfile      : NULL
[17:39:37.722]  $ rshopts         : chr(0) 
[17:39:37.722]  $ rank            : int 1
[17:39:37.722]  $ manual          : logi FALSE
[17:39:37.722]  $ dryrun          : logi FALSE
[17:39:37.722]  $ quiet           : logi FALSE
[17:39:37.722]  $ setup_strategy  : chr "parallel"
[17:39:37.722]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:37.722]  $ pidfile         : chr "/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476dd23948.pid"
[17:39:37.722]  $ rshcmd_label    : NULL
[17:39:37.722]  $ rsh_call        : NULL
[17:39:37.722]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:39:37.722]  $ localMachine    : logi TRUE
[17:39:37.722]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:39:37.722]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:39:37.722]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:39:37.722]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:39:37.722]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:39:37.722]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:39:37.722]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:39:37.722]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:39:37.722]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:39:37.722]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:39:37.722]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:39:37.722]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:39:37.722]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:39:37.722]  $ arguments       :List of 28
[17:39:37.722]   ..$ worker          : chr "localhost"
[17:39:37.722]   ..$ master          : NULL
[17:39:37.722]   ..$ port            : int 11960
[17:39:37.722]   ..$ connectTimeout  : num 120
[17:39:37.722]   ..$ timeout         : num 2592000
[17:39:37.722]   ..$ rscript         : NULL
[17:39:37.722]   ..$ homogeneous     : NULL
[17:39:37.722]   ..$ rscript_args    : NULL
[17:39:37.722]   ..$ rscript_envs    : NULL
[17:39:37.722]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:39:37.722]   ..$ rscript_startup : NULL
[17:39:37.722]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:39:37.722]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:39:37.722]   ..$ methods         : logi TRUE
[17:39:37.722]   ..$ socketOptions   : chr "no-delay"
[17:39:37.722]   ..$ useXDR          : logi FALSE
[17:39:37.722]   ..$ outfile         : chr "/dev/null"
[17:39:37.722]   ..$ renice          : int NA
[17:39:37.722]   ..$ rshcmd          : NULL
[17:39:37.722]   ..$ user            : NULL
[17:39:37.722]   ..$ revtunnel       : logi NA
[17:39:37.722]   ..$ rshlogfile      : NULL
[17:39:37.722]   ..$ rshopts         : NULL
[17:39:37.722]   ..$ rank            : int 1
[17:39:37.722]   ..$ manual          : logi FALSE
[17:39:37.722]   ..$ dryrun          : logi FALSE
[17:39:37.722]   ..$ quiet           : logi FALSE
[17:39:37.722]   ..$ setup_strategy  : chr "parallel"
[17:39:37.722]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:39:37.742] [local output] System call to launch all workers:
[17:39:37.742] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8ZyoGD/worker.rank=1.parallelly.parent=42102.a476dd23948.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11960 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:39:37.742] [local output] Starting PSOCK main server
[17:39:37.744] [local output] Workers launched
[17:39:37.744] [local output] Waiting for workers to connect back
[17:39:37.745]  - [local output] 0 workers out of 2 ready
[17:39:37.990]  - [local output] 0 workers out of 2 ready
[17:39:37.991]  - [local output] 1 workers out of 2 ready
[17:39:37.991]  - [local output] 2 workers out of 2 ready
[17:39:37.991] [local output] Launching of workers completed
[17:39:37.992] [local output] Collecting session information from workers
[17:39:37.992] [local output]  - Worker #1 of 2
[17:39:37.993] [local output]  - Worker #2 of 2
[17:39:37.993] [local output] makeClusterPSOCK() ... done
[17:39:38.004] Packages needed by the future expression (n = 0): <none>
[17:39:38.004] Packages needed by future strategies (n = 0): <none>
[17:39:38.005] {
[17:39:38.005]     {
[17:39:38.005]         {
[17:39:38.005]             ...future.startTime <- base::Sys.time()
[17:39:38.005]             {
[17:39:38.005]                 {
[17:39:38.005]                   {
[17:39:38.005]                     {
[17:39:38.005]                       base::local({
[17:39:38.005]                         has_future <- base::requireNamespace("future", 
[17:39:38.005]                           quietly = TRUE)
[17:39:38.005]                         if (has_future) {
[17:39:38.005]                           ns <- base::getNamespace("future")
[17:39:38.005]                           version <- ns[[".package"]][["version"]]
[17:39:38.005]                           if (is.null(version)) 
[17:39:38.005]                             version <- utils::packageVersion("future")
[17:39:38.005]                         }
[17:39:38.005]                         else {
[17:39:38.005]                           version <- NULL
[17:39:38.005]                         }
[17:39:38.005]                         if (!has_future || version < "1.8.0") {
[17:39:38.005]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.005]                             "", base::R.version$version.string), 
[17:39:38.005]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.005]                               "release", "version")], collapse = " "), 
[17:39:38.005]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.005]                             info)
[17:39:38.005]                           info <- base::paste(info, collapse = "; ")
[17:39:38.005]                           if (!has_future) {
[17:39:38.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.005]                               info)
[17:39:38.005]                           }
[17:39:38.005]                           else {
[17:39:38.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.005]                               info, version)
[17:39:38.005]                           }
[17:39:38.005]                           base::stop(msg)
[17:39:38.005]                         }
[17:39:38.005]                       })
[17:39:38.005]                     }
[17:39:38.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.005]                     base::options(mc.cores = 1L)
[17:39:38.005]                   }
[17:39:38.005]                   ...future.strategy.old <- future::plan("list")
[17:39:38.005]                   options(future.plan = NULL)
[17:39:38.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.005]                 }
[17:39:38.005]                 ...future.workdir <- getwd()
[17:39:38.005]             }
[17:39:38.005]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.005]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.005]         }
[17:39:38.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.005]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.005]             base::names(...future.oldOptions))
[17:39:38.005]     }
[17:39:38.005]     if (FALSE) {
[17:39:38.005]     }
[17:39:38.005]     else {
[17:39:38.005]         if (TRUE) {
[17:39:38.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.005]                 open = "w")
[17:39:38.005]         }
[17:39:38.005]         else {
[17:39:38.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.005]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.005]         }
[17:39:38.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.005]             base::sink(type = "output", split = FALSE)
[17:39:38.005]             base::close(...future.stdout)
[17:39:38.005]         }, add = TRUE)
[17:39:38.005]     }
[17:39:38.005]     ...future.frame <- base::sys.nframe()
[17:39:38.005]     ...future.conditions <- base::list()
[17:39:38.005]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.005]     if (FALSE) {
[17:39:38.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.005]     }
[17:39:38.005]     ...future.result <- base::tryCatch({
[17:39:38.005]         base::withCallingHandlers({
[17:39:38.005]             ...future.value <- base::withVisible(base::local({
[17:39:38.005]                 ...future.makeSendCondition <- base::local({
[17:39:38.005]                   sendCondition <- NULL
[17:39:38.005]                   function(frame = 1L) {
[17:39:38.005]                     if (is.function(sendCondition)) 
[17:39:38.005]                       return(sendCondition)
[17:39:38.005]                     ns <- getNamespace("parallel")
[17:39:38.005]                     if (exists("sendData", mode = "function", 
[17:39:38.005]                       envir = ns)) {
[17:39:38.005]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.005]                         envir = ns)
[17:39:38.005]                       envir <- sys.frame(frame)
[17:39:38.005]                       master <- NULL
[17:39:38.005]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.005]                         !identical(envir, emptyenv())) {
[17:39:38.005]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.005]                           inherits = FALSE)) {
[17:39:38.005]                           master <- get("master", mode = "list", 
[17:39:38.005]                             envir = envir, inherits = FALSE)
[17:39:38.005]                           if (inherits(master, c("SOCKnode", 
[17:39:38.005]                             "SOCK0node"))) {
[17:39:38.005]                             sendCondition <<- function(cond) {
[17:39:38.005]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.005]                                 success = TRUE)
[17:39:38.005]                               parallel_sendData(master, data)
[17:39:38.005]                             }
[17:39:38.005]                             return(sendCondition)
[17:39:38.005]                           }
[17:39:38.005]                         }
[17:39:38.005]                         frame <- frame + 1L
[17:39:38.005]                         envir <- sys.frame(frame)
[17:39:38.005]                       }
[17:39:38.005]                     }
[17:39:38.005]                     sendCondition <<- function(cond) NULL
[17:39:38.005]                   }
[17:39:38.005]                 })
[17:39:38.005]                 withCallingHandlers({
[17:39:38.005]                   NA
[17:39:38.005]                 }, immediateCondition = function(cond) {
[17:39:38.005]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.005]                   sendCondition(cond)
[17:39:38.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.005]                   {
[17:39:38.005]                     inherits <- base::inherits
[17:39:38.005]                     invokeRestart <- base::invokeRestart
[17:39:38.005]                     is.null <- base::is.null
[17:39:38.005]                     muffled <- FALSE
[17:39:38.005]                     if (inherits(cond, "message")) {
[17:39:38.005]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.005]                       if (muffled) 
[17:39:38.005]                         invokeRestart("muffleMessage")
[17:39:38.005]                     }
[17:39:38.005]                     else if (inherits(cond, "warning")) {
[17:39:38.005]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.005]                       if (muffled) 
[17:39:38.005]                         invokeRestart("muffleWarning")
[17:39:38.005]                     }
[17:39:38.005]                     else if (inherits(cond, "condition")) {
[17:39:38.005]                       if (!is.null(pattern)) {
[17:39:38.005]                         computeRestarts <- base::computeRestarts
[17:39:38.005]                         grepl <- base::grepl
[17:39:38.005]                         restarts <- computeRestarts(cond)
[17:39:38.005]                         for (restart in restarts) {
[17:39:38.005]                           name <- restart$name
[17:39:38.005]                           if (is.null(name)) 
[17:39:38.005]                             next
[17:39:38.005]                           if (!grepl(pattern, name)) 
[17:39:38.005]                             next
[17:39:38.005]                           invokeRestart(restart)
[17:39:38.005]                           muffled <- TRUE
[17:39:38.005]                           break
[17:39:38.005]                         }
[17:39:38.005]                       }
[17:39:38.005]                     }
[17:39:38.005]                     invisible(muffled)
[17:39:38.005]                   }
[17:39:38.005]                   muffleCondition(cond)
[17:39:38.005]                 })
[17:39:38.005]             }))
[17:39:38.005]             future::FutureResult(value = ...future.value$value, 
[17:39:38.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.005]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.005]                     ...future.globalenv.names))
[17:39:38.005]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.005]         }, condition = base::local({
[17:39:38.005]             c <- base::c
[17:39:38.005]             inherits <- base::inherits
[17:39:38.005]             invokeRestart <- base::invokeRestart
[17:39:38.005]             length <- base::length
[17:39:38.005]             list <- base::list
[17:39:38.005]             seq.int <- base::seq.int
[17:39:38.005]             signalCondition <- base::signalCondition
[17:39:38.005]             sys.calls <- base::sys.calls
[17:39:38.005]             `[[` <- base::`[[`
[17:39:38.005]             `+` <- base::`+`
[17:39:38.005]             `<<-` <- base::`<<-`
[17:39:38.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.005]                   3L)]
[17:39:38.005]             }
[17:39:38.005]             function(cond) {
[17:39:38.005]                 is_error <- inherits(cond, "error")
[17:39:38.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.005]                   NULL)
[17:39:38.005]                 if (is_error) {
[17:39:38.005]                   sessionInformation <- function() {
[17:39:38.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.005]                       search = base::search(), system = base::Sys.info())
[17:39:38.005]                   }
[17:39:38.005]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.005]                     cond$call), session = sessionInformation(), 
[17:39:38.005]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.005]                   signalCondition(cond)
[17:39:38.005]                 }
[17:39:38.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.005]                 "immediateCondition"))) {
[17:39:38.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.005]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.005]                   if (TRUE && !signal) {
[17:39:38.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.005]                     {
[17:39:38.005]                       inherits <- base::inherits
[17:39:38.005]                       invokeRestart <- base::invokeRestart
[17:39:38.005]                       is.null <- base::is.null
[17:39:38.005]                       muffled <- FALSE
[17:39:38.005]                       if (inherits(cond, "message")) {
[17:39:38.005]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.005]                         if (muffled) 
[17:39:38.005]                           invokeRestart("muffleMessage")
[17:39:38.005]                       }
[17:39:38.005]                       else if (inherits(cond, "warning")) {
[17:39:38.005]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.005]                         if (muffled) 
[17:39:38.005]                           invokeRestart("muffleWarning")
[17:39:38.005]                       }
[17:39:38.005]                       else if (inherits(cond, "condition")) {
[17:39:38.005]                         if (!is.null(pattern)) {
[17:39:38.005]                           computeRestarts <- base::computeRestarts
[17:39:38.005]                           grepl <- base::grepl
[17:39:38.005]                           restarts <- computeRestarts(cond)
[17:39:38.005]                           for (restart in restarts) {
[17:39:38.005]                             name <- restart$name
[17:39:38.005]                             if (is.null(name)) 
[17:39:38.005]                               next
[17:39:38.005]                             if (!grepl(pattern, name)) 
[17:39:38.005]                               next
[17:39:38.005]                             invokeRestart(restart)
[17:39:38.005]                             muffled <- TRUE
[17:39:38.005]                             break
[17:39:38.005]                           }
[17:39:38.005]                         }
[17:39:38.005]                       }
[17:39:38.005]                       invisible(muffled)
[17:39:38.005]                     }
[17:39:38.005]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.005]                   }
[17:39:38.005]                 }
[17:39:38.005]                 else {
[17:39:38.005]                   if (TRUE) {
[17:39:38.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.005]                     {
[17:39:38.005]                       inherits <- base::inherits
[17:39:38.005]                       invokeRestart <- base::invokeRestart
[17:39:38.005]                       is.null <- base::is.null
[17:39:38.005]                       muffled <- FALSE
[17:39:38.005]                       if (inherits(cond, "message")) {
[17:39:38.005]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.005]                         if (muffled) 
[17:39:38.005]                           invokeRestart("muffleMessage")
[17:39:38.005]                       }
[17:39:38.005]                       else if (inherits(cond, "warning")) {
[17:39:38.005]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.005]                         if (muffled) 
[17:39:38.005]                           invokeRestart("muffleWarning")
[17:39:38.005]                       }
[17:39:38.005]                       else if (inherits(cond, "condition")) {
[17:39:38.005]                         if (!is.null(pattern)) {
[17:39:38.005]                           computeRestarts <- base::computeRestarts
[17:39:38.005]                           grepl <- base::grepl
[17:39:38.005]                           restarts <- computeRestarts(cond)
[17:39:38.005]                           for (restart in restarts) {
[17:39:38.005]                             name <- restart$name
[17:39:38.005]                             if (is.null(name)) 
[17:39:38.005]                               next
[17:39:38.005]                             if (!grepl(pattern, name)) 
[17:39:38.005]                               next
[17:39:38.005]                             invokeRestart(restart)
[17:39:38.005]                             muffled <- TRUE
[17:39:38.005]                             break
[17:39:38.005]                           }
[17:39:38.005]                         }
[17:39:38.005]                       }
[17:39:38.005]                       invisible(muffled)
[17:39:38.005]                     }
[17:39:38.005]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.005]                   }
[17:39:38.005]                 }
[17:39:38.005]             }
[17:39:38.005]         }))
[17:39:38.005]     }, error = function(ex) {
[17:39:38.005]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.005]                 ...future.rng), started = ...future.startTime, 
[17:39:38.005]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.005]             version = "1.8"), class = "FutureResult")
[17:39:38.005]     }, finally = {
[17:39:38.005]         if (!identical(...future.workdir, getwd())) 
[17:39:38.005]             setwd(...future.workdir)
[17:39:38.005]         {
[17:39:38.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.005]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.005]             }
[17:39:38.005]             base::options(...future.oldOptions)
[17:39:38.005]             if (.Platform$OS.type == "windows") {
[17:39:38.005]                 old_names <- names(...future.oldEnvVars)
[17:39:38.005]                 envs <- base::Sys.getenv()
[17:39:38.005]                 names <- names(envs)
[17:39:38.005]                 common <- intersect(names, old_names)
[17:39:38.005]                 added <- setdiff(names, old_names)
[17:39:38.005]                 removed <- setdiff(old_names, names)
[17:39:38.005]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.005]                   envs[common]]
[17:39:38.005]                 NAMES <- toupper(changed)
[17:39:38.005]                 args <- list()
[17:39:38.005]                 for (kk in seq_along(NAMES)) {
[17:39:38.005]                   name <- changed[[kk]]
[17:39:38.005]                   NAME <- NAMES[[kk]]
[17:39:38.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.005]                     next
[17:39:38.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.005]                 }
[17:39:38.005]                 NAMES <- toupper(added)
[17:39:38.005]                 for (kk in seq_along(NAMES)) {
[17:39:38.005]                   name <- added[[kk]]
[17:39:38.005]                   NAME <- NAMES[[kk]]
[17:39:38.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.005]                     next
[17:39:38.005]                   args[[name]] <- ""
[17:39:38.005]                 }
[17:39:38.005]                 NAMES <- toupper(removed)
[17:39:38.005]                 for (kk in seq_along(NAMES)) {
[17:39:38.005]                   name <- removed[[kk]]
[17:39:38.005]                   NAME <- NAMES[[kk]]
[17:39:38.005]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.005]                     next
[17:39:38.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.005]                 }
[17:39:38.005]                 if (length(args) > 0) 
[17:39:38.005]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.005]             }
[17:39:38.005]             else {
[17:39:38.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.005]             }
[17:39:38.005]             {
[17:39:38.005]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.005]                   0L) {
[17:39:38.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.005]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.005]                   base::options(opts)
[17:39:38.005]                 }
[17:39:38.005]                 {
[17:39:38.005]                   {
[17:39:38.005]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.005]                     NULL
[17:39:38.005]                   }
[17:39:38.005]                   options(future.plan = NULL)
[17:39:38.005]                   if (is.na(NA_character_)) 
[17:39:38.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.005]                     .init = FALSE)
[17:39:38.005]                 }
[17:39:38.005]             }
[17:39:38.005]         }
[17:39:38.005]     })
[17:39:38.005]     if (TRUE) {
[17:39:38.005]         base::sink(type = "output", split = FALSE)
[17:39:38.005]         if (TRUE) {
[17:39:38.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.005]         }
[17:39:38.005]         else {
[17:39:38.005]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.005]         }
[17:39:38.005]         base::close(...future.stdout)
[17:39:38.005]         ...future.stdout <- NULL
[17:39:38.005]     }
[17:39:38.005]     ...future.result$conditions <- ...future.conditions
[17:39:38.005]     ...future.result$finished <- base::Sys.time()
[17:39:38.005]     ...future.result
[17:39:38.005] }
[17:39:38.057] MultisessionFuture started
[17:39:38.058] result() for ClusterFuture ...
[17:39:38.058] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.058] - Validating connection of MultisessionFuture
[17:39:38.090] - received message: FutureResult
[17:39:38.090] - Received FutureResult
[17:39:38.090] - Erased future from FutureRegistry
[17:39:38.090] result() for ClusterFuture ...
[17:39:38.090] - result already collected: FutureResult
[17:39:38.090] result() for ClusterFuture ... done
[17:39:38.090] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.091] result() for ClusterFuture ... done
[17:39:38.091] result() for ClusterFuture ...
[17:39:38.091] - result already collected: FutureResult
[17:39:38.091] result() for ClusterFuture ... done
[17:39:38.091] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:39:38.095] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:39:38.095] getGlobalsAndPackages() ...
[17:39:38.095] Searching for globals...
[17:39:38.096] 
[17:39:38.096] Searching for globals ... DONE
[17:39:38.096] - globals: [0] <none>
[17:39:38.096] getGlobalsAndPackages() ... DONE
[17:39:38.096] run() for ‘Future’ ...
[17:39:38.096] - state: ‘created’
[17:39:38.097] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.111]   - Field: ‘node’
[17:39:38.111]   - Field: ‘label’
[17:39:38.111]   - Field: ‘local’
[17:39:38.111]   - Field: ‘owner’
[17:39:38.111]   - Field: ‘envir’
[17:39:38.111]   - Field: ‘workers’
[17:39:38.111]   - Field: ‘packages’
[17:39:38.111]   - Field: ‘gc’
[17:39:38.111]   - Field: ‘conditions’
[17:39:38.111]   - Field: ‘persistent’
[17:39:38.112]   - Field: ‘expr’
[17:39:38.112]   - Field: ‘uuid’
[17:39:38.112]   - Field: ‘seed’
[17:39:38.112]   - Field: ‘version’
[17:39:38.112]   - Field: ‘result’
[17:39:38.112]   - Field: ‘asynchronous’
[17:39:38.112]   - Field: ‘calls’
[17:39:38.112]   - Field: ‘globals’
[17:39:38.112]   - Field: ‘stdout’
[17:39:38.112]   - Field: ‘earlySignal’
[17:39:38.113]   - Field: ‘lazy’
[17:39:38.113]   - Field: ‘state’
[17:39:38.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.113] - Launch lazy future ...
[17:39:38.113] Packages needed by the future expression (n = 0): <none>
[17:39:38.113] Packages needed by future strategies (n = 0): <none>
[17:39:38.114] {
[17:39:38.114]     {
[17:39:38.114]         {
[17:39:38.114]             ...future.startTime <- base::Sys.time()
[17:39:38.114]             {
[17:39:38.114]                 {
[17:39:38.114]                   {
[17:39:38.114]                     {
[17:39:38.114]                       base::local({
[17:39:38.114]                         has_future <- base::requireNamespace("future", 
[17:39:38.114]                           quietly = TRUE)
[17:39:38.114]                         if (has_future) {
[17:39:38.114]                           ns <- base::getNamespace("future")
[17:39:38.114]                           version <- ns[[".package"]][["version"]]
[17:39:38.114]                           if (is.null(version)) 
[17:39:38.114]                             version <- utils::packageVersion("future")
[17:39:38.114]                         }
[17:39:38.114]                         else {
[17:39:38.114]                           version <- NULL
[17:39:38.114]                         }
[17:39:38.114]                         if (!has_future || version < "1.8.0") {
[17:39:38.114]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.114]                             "", base::R.version$version.string), 
[17:39:38.114]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.114]                               "release", "version")], collapse = " "), 
[17:39:38.114]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.114]                             info)
[17:39:38.114]                           info <- base::paste(info, collapse = "; ")
[17:39:38.114]                           if (!has_future) {
[17:39:38.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.114]                               info)
[17:39:38.114]                           }
[17:39:38.114]                           else {
[17:39:38.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.114]                               info, version)
[17:39:38.114]                           }
[17:39:38.114]                           base::stop(msg)
[17:39:38.114]                         }
[17:39:38.114]                       })
[17:39:38.114]                     }
[17:39:38.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.114]                     base::options(mc.cores = 1L)
[17:39:38.114]                   }
[17:39:38.114]                   ...future.strategy.old <- future::plan("list")
[17:39:38.114]                   options(future.plan = NULL)
[17:39:38.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.114]                 }
[17:39:38.114]                 ...future.workdir <- getwd()
[17:39:38.114]             }
[17:39:38.114]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.114]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.114]         }
[17:39:38.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.114]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.114]             base::names(...future.oldOptions))
[17:39:38.114]     }
[17:39:38.114]     if (FALSE) {
[17:39:38.114]     }
[17:39:38.114]     else {
[17:39:38.114]         if (TRUE) {
[17:39:38.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.114]                 open = "w")
[17:39:38.114]         }
[17:39:38.114]         else {
[17:39:38.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.114]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.114]         }
[17:39:38.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.114]             base::sink(type = "output", split = FALSE)
[17:39:38.114]             base::close(...future.stdout)
[17:39:38.114]         }, add = TRUE)
[17:39:38.114]     }
[17:39:38.114]     ...future.frame <- base::sys.nframe()
[17:39:38.114]     ...future.conditions <- base::list()
[17:39:38.114]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.114]     if (FALSE) {
[17:39:38.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.114]     }
[17:39:38.114]     ...future.result <- base::tryCatch({
[17:39:38.114]         base::withCallingHandlers({
[17:39:38.114]             ...future.value <- base::withVisible(base::local({
[17:39:38.114]                 ...future.makeSendCondition <- base::local({
[17:39:38.114]                   sendCondition <- NULL
[17:39:38.114]                   function(frame = 1L) {
[17:39:38.114]                     if (is.function(sendCondition)) 
[17:39:38.114]                       return(sendCondition)
[17:39:38.114]                     ns <- getNamespace("parallel")
[17:39:38.114]                     if (exists("sendData", mode = "function", 
[17:39:38.114]                       envir = ns)) {
[17:39:38.114]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.114]                         envir = ns)
[17:39:38.114]                       envir <- sys.frame(frame)
[17:39:38.114]                       master <- NULL
[17:39:38.114]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.114]                         !identical(envir, emptyenv())) {
[17:39:38.114]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.114]                           inherits = FALSE)) {
[17:39:38.114]                           master <- get("master", mode = "list", 
[17:39:38.114]                             envir = envir, inherits = FALSE)
[17:39:38.114]                           if (inherits(master, c("SOCKnode", 
[17:39:38.114]                             "SOCK0node"))) {
[17:39:38.114]                             sendCondition <<- function(cond) {
[17:39:38.114]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.114]                                 success = TRUE)
[17:39:38.114]                               parallel_sendData(master, data)
[17:39:38.114]                             }
[17:39:38.114]                             return(sendCondition)
[17:39:38.114]                           }
[17:39:38.114]                         }
[17:39:38.114]                         frame <- frame + 1L
[17:39:38.114]                         envir <- sys.frame(frame)
[17:39:38.114]                       }
[17:39:38.114]                     }
[17:39:38.114]                     sendCondition <<- function(cond) NULL
[17:39:38.114]                   }
[17:39:38.114]                 })
[17:39:38.114]                 withCallingHandlers({
[17:39:38.114]                   2
[17:39:38.114]                 }, immediateCondition = function(cond) {
[17:39:38.114]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.114]                   sendCondition(cond)
[17:39:38.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.114]                   {
[17:39:38.114]                     inherits <- base::inherits
[17:39:38.114]                     invokeRestart <- base::invokeRestart
[17:39:38.114]                     is.null <- base::is.null
[17:39:38.114]                     muffled <- FALSE
[17:39:38.114]                     if (inherits(cond, "message")) {
[17:39:38.114]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.114]                       if (muffled) 
[17:39:38.114]                         invokeRestart("muffleMessage")
[17:39:38.114]                     }
[17:39:38.114]                     else if (inherits(cond, "warning")) {
[17:39:38.114]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.114]                       if (muffled) 
[17:39:38.114]                         invokeRestart("muffleWarning")
[17:39:38.114]                     }
[17:39:38.114]                     else if (inherits(cond, "condition")) {
[17:39:38.114]                       if (!is.null(pattern)) {
[17:39:38.114]                         computeRestarts <- base::computeRestarts
[17:39:38.114]                         grepl <- base::grepl
[17:39:38.114]                         restarts <- computeRestarts(cond)
[17:39:38.114]                         for (restart in restarts) {
[17:39:38.114]                           name <- restart$name
[17:39:38.114]                           if (is.null(name)) 
[17:39:38.114]                             next
[17:39:38.114]                           if (!grepl(pattern, name)) 
[17:39:38.114]                             next
[17:39:38.114]                           invokeRestart(restart)
[17:39:38.114]                           muffled <- TRUE
[17:39:38.114]                           break
[17:39:38.114]                         }
[17:39:38.114]                       }
[17:39:38.114]                     }
[17:39:38.114]                     invisible(muffled)
[17:39:38.114]                   }
[17:39:38.114]                   muffleCondition(cond)
[17:39:38.114]                 })
[17:39:38.114]             }))
[17:39:38.114]             future::FutureResult(value = ...future.value$value, 
[17:39:38.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.114]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.114]                     ...future.globalenv.names))
[17:39:38.114]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.114]         }, condition = base::local({
[17:39:38.114]             c <- base::c
[17:39:38.114]             inherits <- base::inherits
[17:39:38.114]             invokeRestart <- base::invokeRestart
[17:39:38.114]             length <- base::length
[17:39:38.114]             list <- base::list
[17:39:38.114]             seq.int <- base::seq.int
[17:39:38.114]             signalCondition <- base::signalCondition
[17:39:38.114]             sys.calls <- base::sys.calls
[17:39:38.114]             `[[` <- base::`[[`
[17:39:38.114]             `+` <- base::`+`
[17:39:38.114]             `<<-` <- base::`<<-`
[17:39:38.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.114]                   3L)]
[17:39:38.114]             }
[17:39:38.114]             function(cond) {
[17:39:38.114]                 is_error <- inherits(cond, "error")
[17:39:38.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.114]                   NULL)
[17:39:38.114]                 if (is_error) {
[17:39:38.114]                   sessionInformation <- function() {
[17:39:38.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.114]                       search = base::search(), system = base::Sys.info())
[17:39:38.114]                   }
[17:39:38.114]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.114]                     cond$call), session = sessionInformation(), 
[17:39:38.114]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.114]                   signalCondition(cond)
[17:39:38.114]                 }
[17:39:38.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.114]                 "immediateCondition"))) {
[17:39:38.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.114]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.114]                   if (TRUE && !signal) {
[17:39:38.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.114]                     {
[17:39:38.114]                       inherits <- base::inherits
[17:39:38.114]                       invokeRestart <- base::invokeRestart
[17:39:38.114]                       is.null <- base::is.null
[17:39:38.114]                       muffled <- FALSE
[17:39:38.114]                       if (inherits(cond, "message")) {
[17:39:38.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.114]                         if (muffled) 
[17:39:38.114]                           invokeRestart("muffleMessage")
[17:39:38.114]                       }
[17:39:38.114]                       else if (inherits(cond, "warning")) {
[17:39:38.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.114]                         if (muffled) 
[17:39:38.114]                           invokeRestart("muffleWarning")
[17:39:38.114]                       }
[17:39:38.114]                       else if (inherits(cond, "condition")) {
[17:39:38.114]                         if (!is.null(pattern)) {
[17:39:38.114]                           computeRestarts <- base::computeRestarts
[17:39:38.114]                           grepl <- base::grepl
[17:39:38.114]                           restarts <- computeRestarts(cond)
[17:39:38.114]                           for (restart in restarts) {
[17:39:38.114]                             name <- restart$name
[17:39:38.114]                             if (is.null(name)) 
[17:39:38.114]                               next
[17:39:38.114]                             if (!grepl(pattern, name)) 
[17:39:38.114]                               next
[17:39:38.114]                             invokeRestart(restart)
[17:39:38.114]                             muffled <- TRUE
[17:39:38.114]                             break
[17:39:38.114]                           }
[17:39:38.114]                         }
[17:39:38.114]                       }
[17:39:38.114]                       invisible(muffled)
[17:39:38.114]                     }
[17:39:38.114]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.114]                   }
[17:39:38.114]                 }
[17:39:38.114]                 else {
[17:39:38.114]                   if (TRUE) {
[17:39:38.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.114]                     {
[17:39:38.114]                       inherits <- base::inherits
[17:39:38.114]                       invokeRestart <- base::invokeRestart
[17:39:38.114]                       is.null <- base::is.null
[17:39:38.114]                       muffled <- FALSE
[17:39:38.114]                       if (inherits(cond, "message")) {
[17:39:38.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.114]                         if (muffled) 
[17:39:38.114]                           invokeRestart("muffleMessage")
[17:39:38.114]                       }
[17:39:38.114]                       else if (inherits(cond, "warning")) {
[17:39:38.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.114]                         if (muffled) 
[17:39:38.114]                           invokeRestart("muffleWarning")
[17:39:38.114]                       }
[17:39:38.114]                       else if (inherits(cond, "condition")) {
[17:39:38.114]                         if (!is.null(pattern)) {
[17:39:38.114]                           computeRestarts <- base::computeRestarts
[17:39:38.114]                           grepl <- base::grepl
[17:39:38.114]                           restarts <- computeRestarts(cond)
[17:39:38.114]                           for (restart in restarts) {
[17:39:38.114]                             name <- restart$name
[17:39:38.114]                             if (is.null(name)) 
[17:39:38.114]                               next
[17:39:38.114]                             if (!grepl(pattern, name)) 
[17:39:38.114]                               next
[17:39:38.114]                             invokeRestart(restart)
[17:39:38.114]                             muffled <- TRUE
[17:39:38.114]                             break
[17:39:38.114]                           }
[17:39:38.114]                         }
[17:39:38.114]                       }
[17:39:38.114]                       invisible(muffled)
[17:39:38.114]                     }
[17:39:38.114]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.114]                   }
[17:39:38.114]                 }
[17:39:38.114]             }
[17:39:38.114]         }))
[17:39:38.114]     }, error = function(ex) {
[17:39:38.114]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.114]                 ...future.rng), started = ...future.startTime, 
[17:39:38.114]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.114]             version = "1.8"), class = "FutureResult")
[17:39:38.114]     }, finally = {
[17:39:38.114]         if (!identical(...future.workdir, getwd())) 
[17:39:38.114]             setwd(...future.workdir)
[17:39:38.114]         {
[17:39:38.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.114]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.114]             }
[17:39:38.114]             base::options(...future.oldOptions)
[17:39:38.114]             if (.Platform$OS.type == "windows") {
[17:39:38.114]                 old_names <- names(...future.oldEnvVars)
[17:39:38.114]                 envs <- base::Sys.getenv()
[17:39:38.114]                 names <- names(envs)
[17:39:38.114]                 common <- intersect(names, old_names)
[17:39:38.114]                 added <- setdiff(names, old_names)
[17:39:38.114]                 removed <- setdiff(old_names, names)
[17:39:38.114]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.114]                   envs[common]]
[17:39:38.114]                 NAMES <- toupper(changed)
[17:39:38.114]                 args <- list()
[17:39:38.114]                 for (kk in seq_along(NAMES)) {
[17:39:38.114]                   name <- changed[[kk]]
[17:39:38.114]                   NAME <- NAMES[[kk]]
[17:39:38.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.114]                     next
[17:39:38.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.114]                 }
[17:39:38.114]                 NAMES <- toupper(added)
[17:39:38.114]                 for (kk in seq_along(NAMES)) {
[17:39:38.114]                   name <- added[[kk]]
[17:39:38.114]                   NAME <- NAMES[[kk]]
[17:39:38.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.114]                     next
[17:39:38.114]                   args[[name]] <- ""
[17:39:38.114]                 }
[17:39:38.114]                 NAMES <- toupper(removed)
[17:39:38.114]                 for (kk in seq_along(NAMES)) {
[17:39:38.114]                   name <- removed[[kk]]
[17:39:38.114]                   NAME <- NAMES[[kk]]
[17:39:38.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.114]                     next
[17:39:38.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.114]                 }
[17:39:38.114]                 if (length(args) > 0) 
[17:39:38.114]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.114]             }
[17:39:38.114]             else {
[17:39:38.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.114]             }
[17:39:38.114]             {
[17:39:38.114]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.114]                   0L) {
[17:39:38.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.114]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.114]                   base::options(opts)
[17:39:38.114]                 }
[17:39:38.114]                 {
[17:39:38.114]                   {
[17:39:38.114]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.114]                     NULL
[17:39:38.114]                   }
[17:39:38.114]                   options(future.plan = NULL)
[17:39:38.114]                   if (is.na(NA_character_)) 
[17:39:38.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.114]                     .init = FALSE)
[17:39:38.114]                 }
[17:39:38.114]             }
[17:39:38.114]         }
[17:39:38.114]     })
[17:39:38.114]     if (TRUE) {
[17:39:38.114]         base::sink(type = "output", split = FALSE)
[17:39:38.114]         if (TRUE) {
[17:39:38.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.114]         }
[17:39:38.114]         else {
[17:39:38.114]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.114]         }
[17:39:38.114]         base::close(...future.stdout)
[17:39:38.114]         ...future.stdout <- NULL
[17:39:38.114]     }
[17:39:38.114]     ...future.result$conditions <- ...future.conditions
[17:39:38.114]     ...future.result$finished <- base::Sys.time()
[17:39:38.114]     ...future.result
[17:39:38.114] }
[17:39:38.117] MultisessionFuture started
[17:39:38.117] - Launch lazy future ... done
[17:39:38.117] run() for ‘MultisessionFuture’ ... done
[17:39:38.117] getGlobalsAndPackages() ...
[17:39:38.117] Searching for globals...
[17:39:38.118] 
[17:39:38.118] Searching for globals ... DONE
[17:39:38.118] - globals: [0] <none>
[17:39:38.118] getGlobalsAndPackages() ... DONE
[17:39:38.118] run() for ‘Future’ ...
[17:39:38.118] - state: ‘created’
[17:39:38.118] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.132] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.133]   - Field: ‘node’
[17:39:38.133]   - Field: ‘label’
[17:39:38.133]   - Field: ‘local’
[17:39:38.133]   - Field: ‘owner’
[17:39:38.133]   - Field: ‘envir’
[17:39:38.133]   - Field: ‘workers’
[17:39:38.133]   - Field: ‘packages’
[17:39:38.133]   - Field: ‘gc’
[17:39:38.133]   - Field: ‘conditions’
[17:39:38.133]   - Field: ‘persistent’
[17:39:38.133]   - Field: ‘expr’
[17:39:38.134]   - Field: ‘uuid’
[17:39:38.134]   - Field: ‘seed’
[17:39:38.134]   - Field: ‘version’
[17:39:38.134]   - Field: ‘result’
[17:39:38.134]   - Field: ‘asynchronous’
[17:39:38.134]   - Field: ‘calls’
[17:39:38.134]   - Field: ‘globals’
[17:39:38.134]   - Field: ‘stdout’
[17:39:38.134]   - Field: ‘earlySignal’
[17:39:38.134]   - Field: ‘lazy’
[17:39:38.135]   - Field: ‘state’
[17:39:38.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.135] - Launch lazy future ...
[17:39:38.135] Packages needed by the future expression (n = 0): <none>
[17:39:38.135] Packages needed by future strategies (n = 0): <none>
[17:39:38.136] {
[17:39:38.136]     {
[17:39:38.136]         {
[17:39:38.136]             ...future.startTime <- base::Sys.time()
[17:39:38.136]             {
[17:39:38.136]                 {
[17:39:38.136]                   {
[17:39:38.136]                     {
[17:39:38.136]                       base::local({
[17:39:38.136]                         has_future <- base::requireNamespace("future", 
[17:39:38.136]                           quietly = TRUE)
[17:39:38.136]                         if (has_future) {
[17:39:38.136]                           ns <- base::getNamespace("future")
[17:39:38.136]                           version <- ns[[".package"]][["version"]]
[17:39:38.136]                           if (is.null(version)) 
[17:39:38.136]                             version <- utils::packageVersion("future")
[17:39:38.136]                         }
[17:39:38.136]                         else {
[17:39:38.136]                           version <- NULL
[17:39:38.136]                         }
[17:39:38.136]                         if (!has_future || version < "1.8.0") {
[17:39:38.136]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.136]                             "", base::R.version$version.string), 
[17:39:38.136]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.136]                               "release", "version")], collapse = " "), 
[17:39:38.136]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.136]                             info)
[17:39:38.136]                           info <- base::paste(info, collapse = "; ")
[17:39:38.136]                           if (!has_future) {
[17:39:38.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.136]                               info)
[17:39:38.136]                           }
[17:39:38.136]                           else {
[17:39:38.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.136]                               info, version)
[17:39:38.136]                           }
[17:39:38.136]                           base::stop(msg)
[17:39:38.136]                         }
[17:39:38.136]                       })
[17:39:38.136]                     }
[17:39:38.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.136]                     base::options(mc.cores = 1L)
[17:39:38.136]                   }
[17:39:38.136]                   ...future.strategy.old <- future::plan("list")
[17:39:38.136]                   options(future.plan = NULL)
[17:39:38.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.136]                 }
[17:39:38.136]                 ...future.workdir <- getwd()
[17:39:38.136]             }
[17:39:38.136]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.136]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.136]         }
[17:39:38.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.136]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.136]             base::names(...future.oldOptions))
[17:39:38.136]     }
[17:39:38.136]     if (FALSE) {
[17:39:38.136]     }
[17:39:38.136]     else {
[17:39:38.136]         if (TRUE) {
[17:39:38.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.136]                 open = "w")
[17:39:38.136]         }
[17:39:38.136]         else {
[17:39:38.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.136]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.136]         }
[17:39:38.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.136]             base::sink(type = "output", split = FALSE)
[17:39:38.136]             base::close(...future.stdout)
[17:39:38.136]         }, add = TRUE)
[17:39:38.136]     }
[17:39:38.136]     ...future.frame <- base::sys.nframe()
[17:39:38.136]     ...future.conditions <- base::list()
[17:39:38.136]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.136]     if (FALSE) {
[17:39:38.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.136]     }
[17:39:38.136]     ...future.result <- base::tryCatch({
[17:39:38.136]         base::withCallingHandlers({
[17:39:38.136]             ...future.value <- base::withVisible(base::local({
[17:39:38.136]                 ...future.makeSendCondition <- base::local({
[17:39:38.136]                   sendCondition <- NULL
[17:39:38.136]                   function(frame = 1L) {
[17:39:38.136]                     if (is.function(sendCondition)) 
[17:39:38.136]                       return(sendCondition)
[17:39:38.136]                     ns <- getNamespace("parallel")
[17:39:38.136]                     if (exists("sendData", mode = "function", 
[17:39:38.136]                       envir = ns)) {
[17:39:38.136]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.136]                         envir = ns)
[17:39:38.136]                       envir <- sys.frame(frame)
[17:39:38.136]                       master <- NULL
[17:39:38.136]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.136]                         !identical(envir, emptyenv())) {
[17:39:38.136]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.136]                           inherits = FALSE)) {
[17:39:38.136]                           master <- get("master", mode = "list", 
[17:39:38.136]                             envir = envir, inherits = FALSE)
[17:39:38.136]                           if (inherits(master, c("SOCKnode", 
[17:39:38.136]                             "SOCK0node"))) {
[17:39:38.136]                             sendCondition <<- function(cond) {
[17:39:38.136]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.136]                                 success = TRUE)
[17:39:38.136]                               parallel_sendData(master, data)
[17:39:38.136]                             }
[17:39:38.136]                             return(sendCondition)
[17:39:38.136]                           }
[17:39:38.136]                         }
[17:39:38.136]                         frame <- frame + 1L
[17:39:38.136]                         envir <- sys.frame(frame)
[17:39:38.136]                       }
[17:39:38.136]                     }
[17:39:38.136]                     sendCondition <<- function(cond) NULL
[17:39:38.136]                   }
[17:39:38.136]                 })
[17:39:38.136]                 withCallingHandlers({
[17:39:38.136]                   NULL
[17:39:38.136]                 }, immediateCondition = function(cond) {
[17:39:38.136]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.136]                   sendCondition(cond)
[17:39:38.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.136]                   {
[17:39:38.136]                     inherits <- base::inherits
[17:39:38.136]                     invokeRestart <- base::invokeRestart
[17:39:38.136]                     is.null <- base::is.null
[17:39:38.136]                     muffled <- FALSE
[17:39:38.136]                     if (inherits(cond, "message")) {
[17:39:38.136]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.136]                       if (muffled) 
[17:39:38.136]                         invokeRestart("muffleMessage")
[17:39:38.136]                     }
[17:39:38.136]                     else if (inherits(cond, "warning")) {
[17:39:38.136]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.136]                       if (muffled) 
[17:39:38.136]                         invokeRestart("muffleWarning")
[17:39:38.136]                     }
[17:39:38.136]                     else if (inherits(cond, "condition")) {
[17:39:38.136]                       if (!is.null(pattern)) {
[17:39:38.136]                         computeRestarts <- base::computeRestarts
[17:39:38.136]                         grepl <- base::grepl
[17:39:38.136]                         restarts <- computeRestarts(cond)
[17:39:38.136]                         for (restart in restarts) {
[17:39:38.136]                           name <- restart$name
[17:39:38.136]                           if (is.null(name)) 
[17:39:38.136]                             next
[17:39:38.136]                           if (!grepl(pattern, name)) 
[17:39:38.136]                             next
[17:39:38.136]                           invokeRestart(restart)
[17:39:38.136]                           muffled <- TRUE
[17:39:38.136]                           break
[17:39:38.136]                         }
[17:39:38.136]                       }
[17:39:38.136]                     }
[17:39:38.136]                     invisible(muffled)
[17:39:38.136]                   }
[17:39:38.136]                   muffleCondition(cond)
[17:39:38.136]                 })
[17:39:38.136]             }))
[17:39:38.136]             future::FutureResult(value = ...future.value$value, 
[17:39:38.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.136]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.136]                     ...future.globalenv.names))
[17:39:38.136]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.136]         }, condition = base::local({
[17:39:38.136]             c <- base::c
[17:39:38.136]             inherits <- base::inherits
[17:39:38.136]             invokeRestart <- base::invokeRestart
[17:39:38.136]             length <- base::length
[17:39:38.136]             list <- base::list
[17:39:38.136]             seq.int <- base::seq.int
[17:39:38.136]             signalCondition <- base::signalCondition
[17:39:38.136]             sys.calls <- base::sys.calls
[17:39:38.136]             `[[` <- base::`[[`
[17:39:38.136]             `+` <- base::`+`
[17:39:38.136]             `<<-` <- base::`<<-`
[17:39:38.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.136]                   3L)]
[17:39:38.136]             }
[17:39:38.136]             function(cond) {
[17:39:38.136]                 is_error <- inherits(cond, "error")
[17:39:38.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.136]                   NULL)
[17:39:38.136]                 if (is_error) {
[17:39:38.136]                   sessionInformation <- function() {
[17:39:38.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.136]                       search = base::search(), system = base::Sys.info())
[17:39:38.136]                   }
[17:39:38.136]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.136]                     cond$call), session = sessionInformation(), 
[17:39:38.136]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.136]                   signalCondition(cond)
[17:39:38.136]                 }
[17:39:38.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.136]                 "immediateCondition"))) {
[17:39:38.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.136]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.136]                   if (TRUE && !signal) {
[17:39:38.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.136]                     {
[17:39:38.136]                       inherits <- base::inherits
[17:39:38.136]                       invokeRestart <- base::invokeRestart
[17:39:38.136]                       is.null <- base::is.null
[17:39:38.136]                       muffled <- FALSE
[17:39:38.136]                       if (inherits(cond, "message")) {
[17:39:38.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.136]                         if (muffled) 
[17:39:38.136]                           invokeRestart("muffleMessage")
[17:39:38.136]                       }
[17:39:38.136]                       else if (inherits(cond, "warning")) {
[17:39:38.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.136]                         if (muffled) 
[17:39:38.136]                           invokeRestart("muffleWarning")
[17:39:38.136]                       }
[17:39:38.136]                       else if (inherits(cond, "condition")) {
[17:39:38.136]                         if (!is.null(pattern)) {
[17:39:38.136]                           computeRestarts <- base::computeRestarts
[17:39:38.136]                           grepl <- base::grepl
[17:39:38.136]                           restarts <- computeRestarts(cond)
[17:39:38.136]                           for (restart in restarts) {
[17:39:38.136]                             name <- restart$name
[17:39:38.136]                             if (is.null(name)) 
[17:39:38.136]                               next
[17:39:38.136]                             if (!grepl(pattern, name)) 
[17:39:38.136]                               next
[17:39:38.136]                             invokeRestart(restart)
[17:39:38.136]                             muffled <- TRUE
[17:39:38.136]                             break
[17:39:38.136]                           }
[17:39:38.136]                         }
[17:39:38.136]                       }
[17:39:38.136]                       invisible(muffled)
[17:39:38.136]                     }
[17:39:38.136]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.136]                   }
[17:39:38.136]                 }
[17:39:38.136]                 else {
[17:39:38.136]                   if (TRUE) {
[17:39:38.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.136]                     {
[17:39:38.136]                       inherits <- base::inherits
[17:39:38.136]                       invokeRestart <- base::invokeRestart
[17:39:38.136]                       is.null <- base::is.null
[17:39:38.136]                       muffled <- FALSE
[17:39:38.136]                       if (inherits(cond, "message")) {
[17:39:38.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.136]                         if (muffled) 
[17:39:38.136]                           invokeRestart("muffleMessage")
[17:39:38.136]                       }
[17:39:38.136]                       else if (inherits(cond, "warning")) {
[17:39:38.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.136]                         if (muffled) 
[17:39:38.136]                           invokeRestart("muffleWarning")
[17:39:38.136]                       }
[17:39:38.136]                       else if (inherits(cond, "condition")) {
[17:39:38.136]                         if (!is.null(pattern)) {
[17:39:38.136]                           computeRestarts <- base::computeRestarts
[17:39:38.136]                           grepl <- base::grepl
[17:39:38.136]                           restarts <- computeRestarts(cond)
[17:39:38.136]                           for (restart in restarts) {
[17:39:38.136]                             name <- restart$name
[17:39:38.136]                             if (is.null(name)) 
[17:39:38.136]                               next
[17:39:38.136]                             if (!grepl(pattern, name)) 
[17:39:38.136]                               next
[17:39:38.136]                             invokeRestart(restart)
[17:39:38.136]                             muffled <- TRUE
[17:39:38.136]                             break
[17:39:38.136]                           }
[17:39:38.136]                         }
[17:39:38.136]                       }
[17:39:38.136]                       invisible(muffled)
[17:39:38.136]                     }
[17:39:38.136]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.136]                   }
[17:39:38.136]                 }
[17:39:38.136]             }
[17:39:38.136]         }))
[17:39:38.136]     }, error = function(ex) {
[17:39:38.136]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.136]                 ...future.rng), started = ...future.startTime, 
[17:39:38.136]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.136]             version = "1.8"), class = "FutureResult")
[17:39:38.136]     }, finally = {
[17:39:38.136]         if (!identical(...future.workdir, getwd())) 
[17:39:38.136]             setwd(...future.workdir)
[17:39:38.136]         {
[17:39:38.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.136]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.136]             }
[17:39:38.136]             base::options(...future.oldOptions)
[17:39:38.136]             if (.Platform$OS.type == "windows") {
[17:39:38.136]                 old_names <- names(...future.oldEnvVars)
[17:39:38.136]                 envs <- base::Sys.getenv()
[17:39:38.136]                 names <- names(envs)
[17:39:38.136]                 common <- intersect(names, old_names)
[17:39:38.136]                 added <- setdiff(names, old_names)
[17:39:38.136]                 removed <- setdiff(old_names, names)
[17:39:38.136]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.136]                   envs[common]]
[17:39:38.136]                 NAMES <- toupper(changed)
[17:39:38.136]                 args <- list()
[17:39:38.136]                 for (kk in seq_along(NAMES)) {
[17:39:38.136]                   name <- changed[[kk]]
[17:39:38.136]                   NAME <- NAMES[[kk]]
[17:39:38.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.136]                     next
[17:39:38.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.136]                 }
[17:39:38.136]                 NAMES <- toupper(added)
[17:39:38.136]                 for (kk in seq_along(NAMES)) {
[17:39:38.136]                   name <- added[[kk]]
[17:39:38.136]                   NAME <- NAMES[[kk]]
[17:39:38.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.136]                     next
[17:39:38.136]                   args[[name]] <- ""
[17:39:38.136]                 }
[17:39:38.136]                 NAMES <- toupper(removed)
[17:39:38.136]                 for (kk in seq_along(NAMES)) {
[17:39:38.136]                   name <- removed[[kk]]
[17:39:38.136]                   NAME <- NAMES[[kk]]
[17:39:38.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.136]                     next
[17:39:38.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.136]                 }
[17:39:38.136]                 if (length(args) > 0) 
[17:39:38.136]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.136]             }
[17:39:38.136]             else {
[17:39:38.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.136]             }
[17:39:38.136]             {
[17:39:38.136]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.136]                   0L) {
[17:39:38.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.136]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.136]                   base::options(opts)
[17:39:38.136]                 }
[17:39:38.136]                 {
[17:39:38.136]                   {
[17:39:38.136]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.136]                     NULL
[17:39:38.136]                   }
[17:39:38.136]                   options(future.plan = NULL)
[17:39:38.136]                   if (is.na(NA_character_)) 
[17:39:38.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.136]                     .init = FALSE)
[17:39:38.136]                 }
[17:39:38.136]             }
[17:39:38.136]         }
[17:39:38.136]     })
[17:39:38.136]     if (TRUE) {
[17:39:38.136]         base::sink(type = "output", split = FALSE)
[17:39:38.136]         if (TRUE) {
[17:39:38.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.136]         }
[17:39:38.136]         else {
[17:39:38.136]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.136]         }
[17:39:38.136]         base::close(...future.stdout)
[17:39:38.136]         ...future.stdout <- NULL
[17:39:38.136]     }
[17:39:38.136]     ...future.result$conditions <- ...future.conditions
[17:39:38.136]     ...future.result$finished <- base::Sys.time()
[17:39:38.136]     ...future.result
[17:39:38.136] }
[17:39:38.187] MultisessionFuture started
[17:39:38.188] - Launch lazy future ... done
[17:39:38.188] run() for ‘MultisessionFuture’ ... done
[17:39:38.188] getGlobalsAndPackages() ...
[17:39:38.189] Searching for globals...
[17:39:38.190] - globals found: [1] ‘{’
[17:39:38.190] Searching for globals ... DONE
[17:39:38.190] Resolving globals: FALSE
[17:39:38.190] 
[17:39:38.191] 
[17:39:38.191] getGlobalsAndPackages() ... DONE
[17:39:38.191] run() for ‘Future’ ...
[17:39:38.191] - state: ‘created’
[17:39:38.192] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.210]   - Field: ‘node’
[17:39:38.210]   - Field: ‘label’
[17:39:38.210]   - Field: ‘local’
[17:39:38.210]   - Field: ‘owner’
[17:39:38.210]   - Field: ‘envir’
[17:39:38.210]   - Field: ‘workers’
[17:39:38.211]   - Field: ‘packages’
[17:39:38.211]   - Field: ‘gc’
[17:39:38.211]   - Field: ‘conditions’
[17:39:38.211]   - Field: ‘persistent’
[17:39:38.211]   - Field: ‘expr’
[17:39:38.215]   - Field: ‘uuid’
[17:39:38.215]   - Field: ‘seed’
[17:39:38.215]   - Field: ‘version’
[17:39:38.216]   - Field: ‘result’
[17:39:38.216]   - Field: ‘asynchronous’
[17:39:38.216]   - Field: ‘calls’
[17:39:38.216]   - Field: ‘globals’
[17:39:38.216]   - Field: ‘stdout’
[17:39:38.217]   - Field: ‘earlySignal’
[17:39:38.217]   - Field: ‘lazy’
[17:39:38.217]   - Field: ‘state’
[17:39:38.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.217] - Launch lazy future ...
[17:39:38.218] Packages needed by the future expression (n = 0): <none>
[17:39:38.218] Packages needed by future strategies (n = 0): <none>
[17:39:38.219] {
[17:39:38.219]     {
[17:39:38.219]         {
[17:39:38.219]             ...future.startTime <- base::Sys.time()
[17:39:38.219]             {
[17:39:38.219]                 {
[17:39:38.219]                   {
[17:39:38.219]                     {
[17:39:38.219]                       base::local({
[17:39:38.219]                         has_future <- base::requireNamespace("future", 
[17:39:38.219]                           quietly = TRUE)
[17:39:38.219]                         if (has_future) {
[17:39:38.219]                           ns <- base::getNamespace("future")
[17:39:38.219]                           version <- ns[[".package"]][["version"]]
[17:39:38.219]                           if (is.null(version)) 
[17:39:38.219]                             version <- utils::packageVersion("future")
[17:39:38.219]                         }
[17:39:38.219]                         else {
[17:39:38.219]                           version <- NULL
[17:39:38.219]                         }
[17:39:38.219]                         if (!has_future || version < "1.8.0") {
[17:39:38.219]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.219]                             "", base::R.version$version.string), 
[17:39:38.219]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.219]                               "release", "version")], collapse = " "), 
[17:39:38.219]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.219]                             info)
[17:39:38.219]                           info <- base::paste(info, collapse = "; ")
[17:39:38.219]                           if (!has_future) {
[17:39:38.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.219]                               info)
[17:39:38.219]                           }
[17:39:38.219]                           else {
[17:39:38.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.219]                               info, version)
[17:39:38.219]                           }
[17:39:38.219]                           base::stop(msg)
[17:39:38.219]                         }
[17:39:38.219]                       })
[17:39:38.219]                     }
[17:39:38.219]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.219]                     base::options(mc.cores = 1L)
[17:39:38.219]                   }
[17:39:38.219]                   ...future.strategy.old <- future::plan("list")
[17:39:38.219]                   options(future.plan = NULL)
[17:39:38.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.219]                 }
[17:39:38.219]                 ...future.workdir <- getwd()
[17:39:38.219]             }
[17:39:38.219]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.219]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.219]         }
[17:39:38.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.219]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.219]             base::names(...future.oldOptions))
[17:39:38.219]     }
[17:39:38.219]     if (FALSE) {
[17:39:38.219]     }
[17:39:38.219]     else {
[17:39:38.219]         if (TRUE) {
[17:39:38.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.219]                 open = "w")
[17:39:38.219]         }
[17:39:38.219]         else {
[17:39:38.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.219]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.219]         }
[17:39:38.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.219]             base::sink(type = "output", split = FALSE)
[17:39:38.219]             base::close(...future.stdout)
[17:39:38.219]         }, add = TRUE)
[17:39:38.219]     }
[17:39:38.219]     ...future.frame <- base::sys.nframe()
[17:39:38.219]     ...future.conditions <- base::list()
[17:39:38.219]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.219]     if (FALSE) {
[17:39:38.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.219]     }
[17:39:38.219]     ...future.result <- base::tryCatch({
[17:39:38.219]         base::withCallingHandlers({
[17:39:38.219]             ...future.value <- base::withVisible(base::local({
[17:39:38.219]                 ...future.makeSendCondition <- base::local({
[17:39:38.219]                   sendCondition <- NULL
[17:39:38.219]                   function(frame = 1L) {
[17:39:38.219]                     if (is.function(sendCondition)) 
[17:39:38.219]                       return(sendCondition)
[17:39:38.219]                     ns <- getNamespace("parallel")
[17:39:38.219]                     if (exists("sendData", mode = "function", 
[17:39:38.219]                       envir = ns)) {
[17:39:38.219]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.219]                         envir = ns)
[17:39:38.219]                       envir <- sys.frame(frame)
[17:39:38.219]                       master <- NULL
[17:39:38.219]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.219]                         !identical(envir, emptyenv())) {
[17:39:38.219]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.219]                           inherits = FALSE)) {
[17:39:38.219]                           master <- get("master", mode = "list", 
[17:39:38.219]                             envir = envir, inherits = FALSE)
[17:39:38.219]                           if (inherits(master, c("SOCKnode", 
[17:39:38.219]                             "SOCK0node"))) {
[17:39:38.219]                             sendCondition <<- function(cond) {
[17:39:38.219]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.219]                                 success = TRUE)
[17:39:38.219]                               parallel_sendData(master, data)
[17:39:38.219]                             }
[17:39:38.219]                             return(sendCondition)
[17:39:38.219]                           }
[17:39:38.219]                         }
[17:39:38.219]                         frame <- frame + 1L
[17:39:38.219]                         envir <- sys.frame(frame)
[17:39:38.219]                       }
[17:39:38.219]                     }
[17:39:38.219]                     sendCondition <<- function(cond) NULL
[17:39:38.219]                   }
[17:39:38.219]                 })
[17:39:38.219]                 withCallingHandlers({
[17:39:38.219]                   {
[17:39:38.219]                     4
[17:39:38.219]                   }
[17:39:38.219]                 }, immediateCondition = function(cond) {
[17:39:38.219]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.219]                   sendCondition(cond)
[17:39:38.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.219]                   {
[17:39:38.219]                     inherits <- base::inherits
[17:39:38.219]                     invokeRestart <- base::invokeRestart
[17:39:38.219]                     is.null <- base::is.null
[17:39:38.219]                     muffled <- FALSE
[17:39:38.219]                     if (inherits(cond, "message")) {
[17:39:38.219]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.219]                       if (muffled) 
[17:39:38.219]                         invokeRestart("muffleMessage")
[17:39:38.219]                     }
[17:39:38.219]                     else if (inherits(cond, "warning")) {
[17:39:38.219]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.219]                       if (muffled) 
[17:39:38.219]                         invokeRestart("muffleWarning")
[17:39:38.219]                     }
[17:39:38.219]                     else if (inherits(cond, "condition")) {
[17:39:38.219]                       if (!is.null(pattern)) {
[17:39:38.219]                         computeRestarts <- base::computeRestarts
[17:39:38.219]                         grepl <- base::grepl
[17:39:38.219]                         restarts <- computeRestarts(cond)
[17:39:38.219]                         for (restart in restarts) {
[17:39:38.219]                           name <- restart$name
[17:39:38.219]                           if (is.null(name)) 
[17:39:38.219]                             next
[17:39:38.219]                           if (!grepl(pattern, name)) 
[17:39:38.219]                             next
[17:39:38.219]                           invokeRestart(restart)
[17:39:38.219]                           muffled <- TRUE
[17:39:38.219]                           break
[17:39:38.219]                         }
[17:39:38.219]                       }
[17:39:38.219]                     }
[17:39:38.219]                     invisible(muffled)
[17:39:38.219]                   }
[17:39:38.219]                   muffleCondition(cond)
[17:39:38.219]                 })
[17:39:38.219]             }))
[17:39:38.219]             future::FutureResult(value = ...future.value$value, 
[17:39:38.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.219]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.219]                     ...future.globalenv.names))
[17:39:38.219]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.219]         }, condition = base::local({
[17:39:38.219]             c <- base::c
[17:39:38.219]             inherits <- base::inherits
[17:39:38.219]             invokeRestart <- base::invokeRestart
[17:39:38.219]             length <- base::length
[17:39:38.219]             list <- base::list
[17:39:38.219]             seq.int <- base::seq.int
[17:39:38.219]             signalCondition <- base::signalCondition
[17:39:38.219]             sys.calls <- base::sys.calls
[17:39:38.219]             `[[` <- base::`[[`
[17:39:38.219]             `+` <- base::`+`
[17:39:38.219]             `<<-` <- base::`<<-`
[17:39:38.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.219]                   3L)]
[17:39:38.219]             }
[17:39:38.219]             function(cond) {
[17:39:38.219]                 is_error <- inherits(cond, "error")
[17:39:38.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.219]                   NULL)
[17:39:38.219]                 if (is_error) {
[17:39:38.219]                   sessionInformation <- function() {
[17:39:38.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.219]                       search = base::search(), system = base::Sys.info())
[17:39:38.219]                   }
[17:39:38.219]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.219]                     cond$call), session = sessionInformation(), 
[17:39:38.219]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.219]                   signalCondition(cond)
[17:39:38.219]                 }
[17:39:38.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.219]                 "immediateCondition"))) {
[17:39:38.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.219]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.219]                   if (TRUE && !signal) {
[17:39:38.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.219]                     {
[17:39:38.219]                       inherits <- base::inherits
[17:39:38.219]                       invokeRestart <- base::invokeRestart
[17:39:38.219]                       is.null <- base::is.null
[17:39:38.219]                       muffled <- FALSE
[17:39:38.219]                       if (inherits(cond, "message")) {
[17:39:38.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.219]                         if (muffled) 
[17:39:38.219]                           invokeRestart("muffleMessage")
[17:39:38.219]                       }
[17:39:38.219]                       else if (inherits(cond, "warning")) {
[17:39:38.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.219]                         if (muffled) 
[17:39:38.219]                           invokeRestart("muffleWarning")
[17:39:38.219]                       }
[17:39:38.219]                       else if (inherits(cond, "condition")) {
[17:39:38.219]                         if (!is.null(pattern)) {
[17:39:38.219]                           computeRestarts <- base::computeRestarts
[17:39:38.219]                           grepl <- base::grepl
[17:39:38.219]                           restarts <- computeRestarts(cond)
[17:39:38.219]                           for (restart in restarts) {
[17:39:38.219]                             name <- restart$name
[17:39:38.219]                             if (is.null(name)) 
[17:39:38.219]                               next
[17:39:38.219]                             if (!grepl(pattern, name)) 
[17:39:38.219]                               next
[17:39:38.219]                             invokeRestart(restart)
[17:39:38.219]                             muffled <- TRUE
[17:39:38.219]                             break
[17:39:38.219]                           }
[17:39:38.219]                         }
[17:39:38.219]                       }
[17:39:38.219]                       invisible(muffled)
[17:39:38.219]                     }
[17:39:38.219]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.219]                   }
[17:39:38.219]                 }
[17:39:38.219]                 else {
[17:39:38.219]                   if (TRUE) {
[17:39:38.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.219]                     {
[17:39:38.219]                       inherits <- base::inherits
[17:39:38.219]                       invokeRestart <- base::invokeRestart
[17:39:38.219]                       is.null <- base::is.null
[17:39:38.219]                       muffled <- FALSE
[17:39:38.219]                       if (inherits(cond, "message")) {
[17:39:38.219]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.219]                         if (muffled) 
[17:39:38.219]                           invokeRestart("muffleMessage")
[17:39:38.219]                       }
[17:39:38.219]                       else if (inherits(cond, "warning")) {
[17:39:38.219]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.219]                         if (muffled) 
[17:39:38.219]                           invokeRestart("muffleWarning")
[17:39:38.219]                       }
[17:39:38.219]                       else if (inherits(cond, "condition")) {
[17:39:38.219]                         if (!is.null(pattern)) {
[17:39:38.219]                           computeRestarts <- base::computeRestarts
[17:39:38.219]                           grepl <- base::grepl
[17:39:38.219]                           restarts <- computeRestarts(cond)
[17:39:38.219]                           for (restart in restarts) {
[17:39:38.219]                             name <- restart$name
[17:39:38.219]                             if (is.null(name)) 
[17:39:38.219]                               next
[17:39:38.219]                             if (!grepl(pattern, name)) 
[17:39:38.219]                               next
[17:39:38.219]                             invokeRestart(restart)
[17:39:38.219]                             muffled <- TRUE
[17:39:38.219]                             break
[17:39:38.219]                           }
[17:39:38.219]                         }
[17:39:38.219]                       }
[17:39:38.219]                       invisible(muffled)
[17:39:38.219]                     }
[17:39:38.219]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.219]                   }
[17:39:38.219]                 }
[17:39:38.219]             }
[17:39:38.219]         }))
[17:39:38.219]     }, error = function(ex) {
[17:39:38.219]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.219]                 ...future.rng), started = ...future.startTime, 
[17:39:38.219]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.219]             version = "1.8"), class = "FutureResult")
[17:39:38.219]     }, finally = {
[17:39:38.219]         if (!identical(...future.workdir, getwd())) 
[17:39:38.219]             setwd(...future.workdir)
[17:39:38.219]         {
[17:39:38.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.219]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.219]             }
[17:39:38.219]             base::options(...future.oldOptions)
[17:39:38.219]             if (.Platform$OS.type == "windows") {
[17:39:38.219]                 old_names <- names(...future.oldEnvVars)
[17:39:38.219]                 envs <- base::Sys.getenv()
[17:39:38.219]                 names <- names(envs)
[17:39:38.219]                 common <- intersect(names, old_names)
[17:39:38.219]                 added <- setdiff(names, old_names)
[17:39:38.219]                 removed <- setdiff(old_names, names)
[17:39:38.219]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.219]                   envs[common]]
[17:39:38.219]                 NAMES <- toupper(changed)
[17:39:38.219]                 args <- list()
[17:39:38.219]                 for (kk in seq_along(NAMES)) {
[17:39:38.219]                   name <- changed[[kk]]
[17:39:38.219]                   NAME <- NAMES[[kk]]
[17:39:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.219]                     next
[17:39:38.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.219]                 }
[17:39:38.219]                 NAMES <- toupper(added)
[17:39:38.219]                 for (kk in seq_along(NAMES)) {
[17:39:38.219]                   name <- added[[kk]]
[17:39:38.219]                   NAME <- NAMES[[kk]]
[17:39:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.219]                     next
[17:39:38.219]                   args[[name]] <- ""
[17:39:38.219]                 }
[17:39:38.219]                 NAMES <- toupper(removed)
[17:39:38.219]                 for (kk in seq_along(NAMES)) {
[17:39:38.219]                   name <- removed[[kk]]
[17:39:38.219]                   NAME <- NAMES[[kk]]
[17:39:38.219]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.219]                     next
[17:39:38.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.219]                 }
[17:39:38.219]                 if (length(args) > 0) 
[17:39:38.219]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.219]             }
[17:39:38.219]             else {
[17:39:38.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.219]             }
[17:39:38.219]             {
[17:39:38.219]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.219]                   0L) {
[17:39:38.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.219]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.219]                   base::options(opts)
[17:39:38.219]                 }
[17:39:38.219]                 {
[17:39:38.219]                   {
[17:39:38.219]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.219]                     NULL
[17:39:38.219]                   }
[17:39:38.219]                   options(future.plan = NULL)
[17:39:38.219]                   if (is.na(NA_character_)) 
[17:39:38.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.219]                     .init = FALSE)
[17:39:38.219]                 }
[17:39:38.219]             }
[17:39:38.219]         }
[17:39:38.219]     })
[17:39:38.219]     if (TRUE) {
[17:39:38.219]         base::sink(type = "output", split = FALSE)
[17:39:38.219]         if (TRUE) {
[17:39:38.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.219]         }
[17:39:38.219]         else {
[17:39:38.219]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.219]         }
[17:39:38.219]         base::close(...future.stdout)
[17:39:38.219]         ...future.stdout <- NULL
[17:39:38.219]     }
[17:39:38.219]     ...future.result$conditions <- ...future.conditions
[17:39:38.219]     ...future.result$finished <- base::Sys.time()
[17:39:38.219]     ...future.result
[17:39:38.219] }
[17:39:38.222] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:38.233] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.233] - Validating connection of MultisessionFuture
[17:39:38.233] - received message: FutureResult
[17:39:38.233] - Received FutureResult
[17:39:38.233] - Erased future from FutureRegistry
[17:39:38.233] result() for ClusterFuture ...
[17:39:38.233] - result already collected: FutureResult
[17:39:38.233] result() for ClusterFuture ... done
[17:39:38.234] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.234] result() for ClusterFuture ...
[17:39:38.234] - result already collected: FutureResult
[17:39:38.234] result() for ClusterFuture ... done
[17:39:38.234] result() for ClusterFuture ...
[17:39:38.234] - result already collected: FutureResult
[17:39:38.234] result() for ClusterFuture ... done
[17:39:38.235] MultisessionFuture started
[17:39:38.235] - Launch lazy future ... done
[17:39:38.235] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf189b820> 
Classes 'listenv', 'environment' <environment: 0x55adf057c450> 
[17:39:38.239] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.240] - Validating connection of MultisessionFuture
[17:39:38.240] - received message: FutureResult
[17:39:38.240] - Received FutureResult
[17:39:38.240] - Erased future from FutureRegistry
[17:39:38.240] result() for ClusterFuture ...
[17:39:38.240] - result already collected: FutureResult
[17:39:38.241] result() for ClusterFuture ... done
[17:39:38.241] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.242] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.242] - Validating connection of MultisessionFuture
[17:39:38.242] - received message: FutureResult
[17:39:38.242] - Received FutureResult
[17:39:38.242] - Erased future from FutureRegistry
[17:39:38.242] result() for ClusterFuture ...
[17:39:38.242] - result already collected: FutureResult
[17:39:38.243] result() for ClusterFuture ... done
[17:39:38.243] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:38.244] resolve() on list environment ...
[17:39:38.244]  recursive: 0
[17:39:38.245]  length: 6
[17:39:38.245]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:38.245] signalConditionsASAP(numeric, pos=1) ...
[17:39:38.245] - nx: 6
[17:39:38.245] - relay: TRUE
[17:39:38.246] - stdout: TRUE
[17:39:38.246] - signal: TRUE
[17:39:38.246] - resignal: FALSE
[17:39:38.246] - force: TRUE
[17:39:38.246] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.246] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.246]  - until=2
[17:39:38.246]  - relaying element #2
[17:39:38.246] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.246] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.246] signalConditionsASAP(NULL, pos=1) ... done
[17:39:38.247]  length: 5 (resolved future 1)
[17:39:38.247] Future #2
[17:39:38.247] result() for ClusterFuture ...
[17:39:38.247] - result already collected: FutureResult
[17:39:38.247] result() for ClusterFuture ... done
[17:39:38.247] result() for ClusterFuture ...
[17:39:38.247] - result already collected: FutureResult
[17:39:38.247] result() for ClusterFuture ... done
[17:39:38.247] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:38.247] - nx: 6
[17:39:38.247] - relay: TRUE
[17:39:38.248] - stdout: TRUE
[17:39:38.248] - signal: TRUE
[17:39:38.248] - resignal: FALSE
[17:39:38.248] - force: TRUE
[17:39:38.248] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.248] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.248]  - until=2
[17:39:38.248]  - relaying element #2
[17:39:38.248] result() for ClusterFuture ...
[17:39:38.248] - result already collected: FutureResult
[17:39:38.248] result() for ClusterFuture ... done
[17:39:38.248] result() for ClusterFuture ...
[17:39:38.249] - result already collected: FutureResult
[17:39:38.249] result() for ClusterFuture ... done
[17:39:38.249] result() for ClusterFuture ...
[17:39:38.249] - result already collected: FutureResult
[17:39:38.249] result() for ClusterFuture ... done
[17:39:38.249] result() for ClusterFuture ...
[17:39:38.249] - result already collected: FutureResult
[17:39:38.249] result() for ClusterFuture ... done
[17:39:38.249] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.249] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.249] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:38.250]  length: 4 (resolved future 2)
[17:39:38.250] Future #3
[17:39:38.250] result() for ClusterFuture ...
[17:39:38.250] - result already collected: FutureResult
[17:39:38.250] result() for ClusterFuture ... done
[17:39:38.250] result() for ClusterFuture ...
[17:39:38.250] - result already collected: FutureResult
[17:39:38.250] result() for ClusterFuture ... done
[17:39:38.250] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:38.250] - nx: 6
[17:39:38.250] - relay: TRUE
[17:39:38.251] - stdout: TRUE
[17:39:38.251] - signal: TRUE
[17:39:38.251] - resignal: FALSE
[17:39:38.251] - force: TRUE
[17:39:38.251] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.251] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.251]  - until=3
[17:39:38.251]  - relaying element #3
[17:39:38.251] result() for ClusterFuture ...
[17:39:38.251] - result already collected: FutureResult
[17:39:38.251] result() for ClusterFuture ... done
[17:39:38.251] result() for ClusterFuture ...
[17:39:38.252] - result already collected: FutureResult
[17:39:38.252] result() for ClusterFuture ... done
[17:39:38.252] result() for ClusterFuture ...
[17:39:38.252] - result already collected: FutureResult
[17:39:38.252] result() for ClusterFuture ... done
[17:39:38.252] result() for ClusterFuture ...
[17:39:38.252] - result already collected: FutureResult
[17:39:38.252] result() for ClusterFuture ... done
[17:39:38.252] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.252] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.253] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:38.253]  length: 3 (resolved future 3)
[17:39:38.253] Future #4
[17:39:38.253] result() for ClusterFuture ...
[17:39:38.253] - result already collected: FutureResult
[17:39:38.253] result() for ClusterFuture ... done
[17:39:38.253] result() for ClusterFuture ...
[17:39:38.253] - result already collected: FutureResult
[17:39:38.253] result() for ClusterFuture ... done
[17:39:38.254] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:38.254] - nx: 6
[17:39:38.254] - relay: TRUE
[17:39:38.254] - stdout: TRUE
[17:39:38.254] - signal: TRUE
[17:39:38.254] - resignal: FALSE
[17:39:38.254] - force: TRUE
[17:39:38.254] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.255]  - until=4
[17:39:38.255]  - relaying element #4
[17:39:38.255] result() for ClusterFuture ...
[17:39:38.255] - result already collected: FutureResult
[17:39:38.255] result() for ClusterFuture ... done
[17:39:38.255] result() for ClusterFuture ...
[17:39:38.255] - result already collected: FutureResult
[17:39:38.255] result() for ClusterFuture ... done
[17:39:38.255] result() for ClusterFuture ...
[17:39:38.255] - result already collected: FutureResult
[17:39:38.256] result() for ClusterFuture ... done
[17:39:38.256] result() for ClusterFuture ...
[17:39:38.256] - result already collected: FutureResult
[17:39:38.256] result() for ClusterFuture ... done
[17:39:38.256] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.256] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.256] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:38.256]  length: 2 (resolved future 4)
[17:39:38.256] signalConditionsASAP(NULL, pos=5) ...
[17:39:38.256] - nx: 6
[17:39:38.257] - relay: TRUE
[17:39:38.257] - stdout: TRUE
[17:39:38.257] - signal: TRUE
[17:39:38.257] - resignal: FALSE
[17:39:38.257] - force: TRUE
[17:39:38.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.257] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.257]  - until=6
[17:39:38.257]  - relaying element #6
[17:39:38.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.257] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.257] signalConditionsASAP(NULL, pos=5) ... done
[17:39:38.258]  length: 1 (resolved future 5)
[17:39:38.258] signalConditionsASAP(numeric, pos=6) ...
[17:39:38.258] - nx: 6
[17:39:38.258] - relay: TRUE
[17:39:38.258] - stdout: TRUE
[17:39:38.258] - signal: TRUE
[17:39:38.258] - resignal: FALSE
[17:39:38.258] - force: TRUE
[17:39:38.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.258] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.258]  - until=6
[17:39:38.259] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.259] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.259] signalConditionsASAP(numeric, pos=6) ... done
[17:39:38.259]  length: 0 (resolved future 6)
[17:39:38.259] Relaying remaining futures
[17:39:38.259] signalConditionsASAP(NULL, pos=0) ...
[17:39:38.259] - nx: 6
[17:39:38.259] - relay: TRUE
[17:39:38.259] - stdout: TRUE
[17:39:38.259] - signal: TRUE
[17:39:38.259] - resignal: FALSE
[17:39:38.259] - force: TRUE
[17:39:38.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.260] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:38.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.260] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.260] signalConditionsASAP(NULL, pos=0) ... done
[17:39:38.260] resolve() on list environment ... DONE
[17:39:38.260] result() for ClusterFuture ...
[17:39:38.260] - result already collected: FutureResult
[17:39:38.260] result() for ClusterFuture ... done
[17:39:38.260] result() for ClusterFuture ...
[17:39:38.261] - result already collected: FutureResult
[17:39:38.261] result() for ClusterFuture ... done
[17:39:38.261] result() for ClusterFuture ...
[17:39:38.261] - result already collected: FutureResult
[17:39:38.261] result() for ClusterFuture ... done
[17:39:38.261] result() for ClusterFuture ...
[17:39:38.261] - result already collected: FutureResult
[17:39:38.261] result() for ClusterFuture ... done
[17:39:38.261] result() for ClusterFuture ...
[17:39:38.261] - result already collected: FutureResult
[17:39:38.262] result() for ClusterFuture ... done
[17:39:38.262] result() for ClusterFuture ...
[17:39:38.262] - result already collected: FutureResult
[17:39:38.262] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf018db80> 
Dimensions: c(1, 6)
[17:39:38.262] getGlobalsAndPackages() ...
[17:39:38.263] Searching for globals...
[17:39:38.263] 
[17:39:38.263] Searching for globals ... DONE
[17:39:38.263] - globals: [0] <none>
[17:39:38.263] getGlobalsAndPackages() ... DONE
[17:39:38.263] run() for ‘Future’ ...
[17:39:38.264] - state: ‘created’
[17:39:38.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.278]   - Field: ‘node’
[17:39:38.278]   - Field: ‘label’
[17:39:38.279]   - Field: ‘local’
[17:39:38.279]   - Field: ‘owner’
[17:39:38.279]   - Field: ‘envir’
[17:39:38.279]   - Field: ‘workers’
[17:39:38.279]   - Field: ‘packages’
[17:39:38.279]   - Field: ‘gc’
[17:39:38.279]   - Field: ‘conditions’
[17:39:38.279]   - Field: ‘persistent’
[17:39:38.279]   - Field: ‘expr’
[17:39:38.279]   - Field: ‘uuid’
[17:39:38.280]   - Field: ‘seed’
[17:39:38.280]   - Field: ‘version’
[17:39:38.280]   - Field: ‘result’
[17:39:38.280]   - Field: ‘asynchronous’
[17:39:38.280]   - Field: ‘calls’
[17:39:38.280]   - Field: ‘globals’
[17:39:38.280]   - Field: ‘stdout’
[17:39:38.280]   - Field: ‘earlySignal’
[17:39:38.280]   - Field: ‘lazy’
[17:39:38.280]   - Field: ‘state’
[17:39:38.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.281] - Launch lazy future ...
[17:39:38.281] Packages needed by the future expression (n = 0): <none>
[17:39:38.281] Packages needed by future strategies (n = 0): <none>
[17:39:38.281] {
[17:39:38.281]     {
[17:39:38.281]         {
[17:39:38.281]             ...future.startTime <- base::Sys.time()
[17:39:38.281]             {
[17:39:38.281]                 {
[17:39:38.281]                   {
[17:39:38.281]                     {
[17:39:38.281]                       base::local({
[17:39:38.281]                         has_future <- base::requireNamespace("future", 
[17:39:38.281]                           quietly = TRUE)
[17:39:38.281]                         if (has_future) {
[17:39:38.281]                           ns <- base::getNamespace("future")
[17:39:38.281]                           version <- ns[[".package"]][["version"]]
[17:39:38.281]                           if (is.null(version)) 
[17:39:38.281]                             version <- utils::packageVersion("future")
[17:39:38.281]                         }
[17:39:38.281]                         else {
[17:39:38.281]                           version <- NULL
[17:39:38.281]                         }
[17:39:38.281]                         if (!has_future || version < "1.8.0") {
[17:39:38.281]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.281]                             "", base::R.version$version.string), 
[17:39:38.281]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.281]                               "release", "version")], collapse = " "), 
[17:39:38.281]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.281]                             info)
[17:39:38.281]                           info <- base::paste(info, collapse = "; ")
[17:39:38.281]                           if (!has_future) {
[17:39:38.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.281]                               info)
[17:39:38.281]                           }
[17:39:38.281]                           else {
[17:39:38.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.281]                               info, version)
[17:39:38.281]                           }
[17:39:38.281]                           base::stop(msg)
[17:39:38.281]                         }
[17:39:38.281]                       })
[17:39:38.281]                     }
[17:39:38.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.281]                     base::options(mc.cores = 1L)
[17:39:38.281]                   }
[17:39:38.281]                   ...future.strategy.old <- future::plan("list")
[17:39:38.281]                   options(future.plan = NULL)
[17:39:38.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.281]                 }
[17:39:38.281]                 ...future.workdir <- getwd()
[17:39:38.281]             }
[17:39:38.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.281]         }
[17:39:38.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.281]             base::names(...future.oldOptions))
[17:39:38.281]     }
[17:39:38.281]     if (FALSE) {
[17:39:38.281]     }
[17:39:38.281]     else {
[17:39:38.281]         if (TRUE) {
[17:39:38.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.281]                 open = "w")
[17:39:38.281]         }
[17:39:38.281]         else {
[17:39:38.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.281]         }
[17:39:38.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.281]             base::sink(type = "output", split = FALSE)
[17:39:38.281]             base::close(...future.stdout)
[17:39:38.281]         }, add = TRUE)
[17:39:38.281]     }
[17:39:38.281]     ...future.frame <- base::sys.nframe()
[17:39:38.281]     ...future.conditions <- base::list()
[17:39:38.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.281]     if (FALSE) {
[17:39:38.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.281]     }
[17:39:38.281]     ...future.result <- base::tryCatch({
[17:39:38.281]         base::withCallingHandlers({
[17:39:38.281]             ...future.value <- base::withVisible(base::local({
[17:39:38.281]                 ...future.makeSendCondition <- base::local({
[17:39:38.281]                   sendCondition <- NULL
[17:39:38.281]                   function(frame = 1L) {
[17:39:38.281]                     if (is.function(sendCondition)) 
[17:39:38.281]                       return(sendCondition)
[17:39:38.281]                     ns <- getNamespace("parallel")
[17:39:38.281]                     if (exists("sendData", mode = "function", 
[17:39:38.281]                       envir = ns)) {
[17:39:38.281]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.281]                         envir = ns)
[17:39:38.281]                       envir <- sys.frame(frame)
[17:39:38.281]                       master <- NULL
[17:39:38.281]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.281]                         !identical(envir, emptyenv())) {
[17:39:38.281]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.281]                           inherits = FALSE)) {
[17:39:38.281]                           master <- get("master", mode = "list", 
[17:39:38.281]                             envir = envir, inherits = FALSE)
[17:39:38.281]                           if (inherits(master, c("SOCKnode", 
[17:39:38.281]                             "SOCK0node"))) {
[17:39:38.281]                             sendCondition <<- function(cond) {
[17:39:38.281]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.281]                                 success = TRUE)
[17:39:38.281]                               parallel_sendData(master, data)
[17:39:38.281]                             }
[17:39:38.281]                             return(sendCondition)
[17:39:38.281]                           }
[17:39:38.281]                         }
[17:39:38.281]                         frame <- frame + 1L
[17:39:38.281]                         envir <- sys.frame(frame)
[17:39:38.281]                       }
[17:39:38.281]                     }
[17:39:38.281]                     sendCondition <<- function(cond) NULL
[17:39:38.281]                   }
[17:39:38.281]                 })
[17:39:38.281]                 withCallingHandlers({
[17:39:38.281]                   2
[17:39:38.281]                 }, immediateCondition = function(cond) {
[17:39:38.281]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.281]                   sendCondition(cond)
[17:39:38.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.281]                   {
[17:39:38.281]                     inherits <- base::inherits
[17:39:38.281]                     invokeRestart <- base::invokeRestart
[17:39:38.281]                     is.null <- base::is.null
[17:39:38.281]                     muffled <- FALSE
[17:39:38.281]                     if (inherits(cond, "message")) {
[17:39:38.281]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.281]                       if (muffled) 
[17:39:38.281]                         invokeRestart("muffleMessage")
[17:39:38.281]                     }
[17:39:38.281]                     else if (inherits(cond, "warning")) {
[17:39:38.281]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.281]                       if (muffled) 
[17:39:38.281]                         invokeRestart("muffleWarning")
[17:39:38.281]                     }
[17:39:38.281]                     else if (inherits(cond, "condition")) {
[17:39:38.281]                       if (!is.null(pattern)) {
[17:39:38.281]                         computeRestarts <- base::computeRestarts
[17:39:38.281]                         grepl <- base::grepl
[17:39:38.281]                         restarts <- computeRestarts(cond)
[17:39:38.281]                         for (restart in restarts) {
[17:39:38.281]                           name <- restart$name
[17:39:38.281]                           if (is.null(name)) 
[17:39:38.281]                             next
[17:39:38.281]                           if (!grepl(pattern, name)) 
[17:39:38.281]                             next
[17:39:38.281]                           invokeRestart(restart)
[17:39:38.281]                           muffled <- TRUE
[17:39:38.281]                           break
[17:39:38.281]                         }
[17:39:38.281]                       }
[17:39:38.281]                     }
[17:39:38.281]                     invisible(muffled)
[17:39:38.281]                   }
[17:39:38.281]                   muffleCondition(cond)
[17:39:38.281]                 })
[17:39:38.281]             }))
[17:39:38.281]             future::FutureResult(value = ...future.value$value, 
[17:39:38.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.281]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.281]                     ...future.globalenv.names))
[17:39:38.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.281]         }, condition = base::local({
[17:39:38.281]             c <- base::c
[17:39:38.281]             inherits <- base::inherits
[17:39:38.281]             invokeRestart <- base::invokeRestart
[17:39:38.281]             length <- base::length
[17:39:38.281]             list <- base::list
[17:39:38.281]             seq.int <- base::seq.int
[17:39:38.281]             signalCondition <- base::signalCondition
[17:39:38.281]             sys.calls <- base::sys.calls
[17:39:38.281]             `[[` <- base::`[[`
[17:39:38.281]             `+` <- base::`+`
[17:39:38.281]             `<<-` <- base::`<<-`
[17:39:38.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.281]                   3L)]
[17:39:38.281]             }
[17:39:38.281]             function(cond) {
[17:39:38.281]                 is_error <- inherits(cond, "error")
[17:39:38.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.281]                   NULL)
[17:39:38.281]                 if (is_error) {
[17:39:38.281]                   sessionInformation <- function() {
[17:39:38.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.281]                       search = base::search(), system = base::Sys.info())
[17:39:38.281]                   }
[17:39:38.281]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.281]                     cond$call), session = sessionInformation(), 
[17:39:38.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.281]                   signalCondition(cond)
[17:39:38.281]                 }
[17:39:38.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.281]                 "immediateCondition"))) {
[17:39:38.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.281]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.281]                   if (TRUE && !signal) {
[17:39:38.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.281]                     {
[17:39:38.281]                       inherits <- base::inherits
[17:39:38.281]                       invokeRestart <- base::invokeRestart
[17:39:38.281]                       is.null <- base::is.null
[17:39:38.281]                       muffled <- FALSE
[17:39:38.281]                       if (inherits(cond, "message")) {
[17:39:38.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.281]                         if (muffled) 
[17:39:38.281]                           invokeRestart("muffleMessage")
[17:39:38.281]                       }
[17:39:38.281]                       else if (inherits(cond, "warning")) {
[17:39:38.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.281]                         if (muffled) 
[17:39:38.281]                           invokeRestart("muffleWarning")
[17:39:38.281]                       }
[17:39:38.281]                       else if (inherits(cond, "condition")) {
[17:39:38.281]                         if (!is.null(pattern)) {
[17:39:38.281]                           computeRestarts <- base::computeRestarts
[17:39:38.281]                           grepl <- base::grepl
[17:39:38.281]                           restarts <- computeRestarts(cond)
[17:39:38.281]                           for (restart in restarts) {
[17:39:38.281]                             name <- restart$name
[17:39:38.281]                             if (is.null(name)) 
[17:39:38.281]                               next
[17:39:38.281]                             if (!grepl(pattern, name)) 
[17:39:38.281]                               next
[17:39:38.281]                             invokeRestart(restart)
[17:39:38.281]                             muffled <- TRUE
[17:39:38.281]                             break
[17:39:38.281]                           }
[17:39:38.281]                         }
[17:39:38.281]                       }
[17:39:38.281]                       invisible(muffled)
[17:39:38.281]                     }
[17:39:38.281]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.281]                   }
[17:39:38.281]                 }
[17:39:38.281]                 else {
[17:39:38.281]                   if (TRUE) {
[17:39:38.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.281]                     {
[17:39:38.281]                       inherits <- base::inherits
[17:39:38.281]                       invokeRestart <- base::invokeRestart
[17:39:38.281]                       is.null <- base::is.null
[17:39:38.281]                       muffled <- FALSE
[17:39:38.281]                       if (inherits(cond, "message")) {
[17:39:38.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.281]                         if (muffled) 
[17:39:38.281]                           invokeRestart("muffleMessage")
[17:39:38.281]                       }
[17:39:38.281]                       else if (inherits(cond, "warning")) {
[17:39:38.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.281]                         if (muffled) 
[17:39:38.281]                           invokeRestart("muffleWarning")
[17:39:38.281]                       }
[17:39:38.281]                       else if (inherits(cond, "condition")) {
[17:39:38.281]                         if (!is.null(pattern)) {
[17:39:38.281]                           computeRestarts <- base::computeRestarts
[17:39:38.281]                           grepl <- base::grepl
[17:39:38.281]                           restarts <- computeRestarts(cond)
[17:39:38.281]                           for (restart in restarts) {
[17:39:38.281]                             name <- restart$name
[17:39:38.281]                             if (is.null(name)) 
[17:39:38.281]                               next
[17:39:38.281]                             if (!grepl(pattern, name)) 
[17:39:38.281]                               next
[17:39:38.281]                             invokeRestart(restart)
[17:39:38.281]                             muffled <- TRUE
[17:39:38.281]                             break
[17:39:38.281]                           }
[17:39:38.281]                         }
[17:39:38.281]                       }
[17:39:38.281]                       invisible(muffled)
[17:39:38.281]                     }
[17:39:38.281]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.281]                   }
[17:39:38.281]                 }
[17:39:38.281]             }
[17:39:38.281]         }))
[17:39:38.281]     }, error = function(ex) {
[17:39:38.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.281]                 ...future.rng), started = ...future.startTime, 
[17:39:38.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.281]             version = "1.8"), class = "FutureResult")
[17:39:38.281]     }, finally = {
[17:39:38.281]         if (!identical(...future.workdir, getwd())) 
[17:39:38.281]             setwd(...future.workdir)
[17:39:38.281]         {
[17:39:38.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.281]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.281]             }
[17:39:38.281]             base::options(...future.oldOptions)
[17:39:38.281]             if (.Platform$OS.type == "windows") {
[17:39:38.281]                 old_names <- names(...future.oldEnvVars)
[17:39:38.281]                 envs <- base::Sys.getenv()
[17:39:38.281]                 names <- names(envs)
[17:39:38.281]                 common <- intersect(names, old_names)
[17:39:38.281]                 added <- setdiff(names, old_names)
[17:39:38.281]                 removed <- setdiff(old_names, names)
[17:39:38.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.281]                   envs[common]]
[17:39:38.281]                 NAMES <- toupper(changed)
[17:39:38.281]                 args <- list()
[17:39:38.281]                 for (kk in seq_along(NAMES)) {
[17:39:38.281]                   name <- changed[[kk]]
[17:39:38.281]                   NAME <- NAMES[[kk]]
[17:39:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.281]                     next
[17:39:38.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.281]                 }
[17:39:38.281]                 NAMES <- toupper(added)
[17:39:38.281]                 for (kk in seq_along(NAMES)) {
[17:39:38.281]                   name <- added[[kk]]
[17:39:38.281]                   NAME <- NAMES[[kk]]
[17:39:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.281]                     next
[17:39:38.281]                   args[[name]] <- ""
[17:39:38.281]                 }
[17:39:38.281]                 NAMES <- toupper(removed)
[17:39:38.281]                 for (kk in seq_along(NAMES)) {
[17:39:38.281]                   name <- removed[[kk]]
[17:39:38.281]                   NAME <- NAMES[[kk]]
[17:39:38.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.281]                     next
[17:39:38.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.281]                 }
[17:39:38.281]                 if (length(args) > 0) 
[17:39:38.281]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.281]             }
[17:39:38.281]             else {
[17:39:38.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.281]             }
[17:39:38.281]             {
[17:39:38.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.281]                   0L) {
[17:39:38.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.281]                   base::options(opts)
[17:39:38.281]                 }
[17:39:38.281]                 {
[17:39:38.281]                   {
[17:39:38.281]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.281]                     NULL
[17:39:38.281]                   }
[17:39:38.281]                   options(future.plan = NULL)
[17:39:38.281]                   if (is.na(NA_character_)) 
[17:39:38.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.281]                     .init = FALSE)
[17:39:38.281]                 }
[17:39:38.281]             }
[17:39:38.281]         }
[17:39:38.281]     })
[17:39:38.281]     if (TRUE) {
[17:39:38.281]         base::sink(type = "output", split = FALSE)
[17:39:38.281]         if (TRUE) {
[17:39:38.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.281]         }
[17:39:38.281]         else {
[17:39:38.281]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.281]         }
[17:39:38.281]         base::close(...future.stdout)
[17:39:38.281]         ...future.stdout <- NULL
[17:39:38.281]     }
[17:39:38.281]     ...future.result$conditions <- ...future.conditions
[17:39:38.281]     ...future.result$finished <- base::Sys.time()
[17:39:38.281]     ...future.result
[17:39:38.281] }
[17:39:38.285] MultisessionFuture started
[17:39:38.285] - Launch lazy future ... done
[17:39:38.285] run() for ‘MultisessionFuture’ ... done
[17:39:38.285] getGlobalsAndPackages() ...
[17:39:38.285] Searching for globals...
[17:39:38.285] 
[17:39:38.286] Searching for globals ... DONE
[17:39:38.286] - globals: [0] <none>
[17:39:38.286] getGlobalsAndPackages() ... DONE
[17:39:38.286] run() for ‘Future’ ...
[17:39:38.286] - state: ‘created’
[17:39:38.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.300]   - Field: ‘node’
[17:39:38.300]   - Field: ‘label’
[17:39:38.300]   - Field: ‘local’
[17:39:38.301]   - Field: ‘owner’
[17:39:38.301]   - Field: ‘envir’
[17:39:38.301]   - Field: ‘workers’
[17:39:38.301]   - Field: ‘packages’
[17:39:38.301]   - Field: ‘gc’
[17:39:38.301]   - Field: ‘conditions’
[17:39:38.301]   - Field: ‘persistent’
[17:39:38.301]   - Field: ‘expr’
[17:39:38.301]   - Field: ‘uuid’
[17:39:38.301]   - Field: ‘seed’
[17:39:38.301]   - Field: ‘version’
[17:39:38.302]   - Field: ‘result’
[17:39:38.302]   - Field: ‘asynchronous’
[17:39:38.302]   - Field: ‘calls’
[17:39:38.302]   - Field: ‘globals’
[17:39:38.302]   - Field: ‘stdout’
[17:39:38.302]   - Field: ‘earlySignal’
[17:39:38.302]   - Field: ‘lazy’
[17:39:38.302]   - Field: ‘state’
[17:39:38.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.302] - Launch lazy future ...
[17:39:38.303] Packages needed by the future expression (n = 0): <none>
[17:39:38.303] Packages needed by future strategies (n = 0): <none>
[17:39:38.303] {
[17:39:38.303]     {
[17:39:38.303]         {
[17:39:38.303]             ...future.startTime <- base::Sys.time()
[17:39:38.303]             {
[17:39:38.303]                 {
[17:39:38.303]                   {
[17:39:38.303]                     {
[17:39:38.303]                       base::local({
[17:39:38.303]                         has_future <- base::requireNamespace("future", 
[17:39:38.303]                           quietly = TRUE)
[17:39:38.303]                         if (has_future) {
[17:39:38.303]                           ns <- base::getNamespace("future")
[17:39:38.303]                           version <- ns[[".package"]][["version"]]
[17:39:38.303]                           if (is.null(version)) 
[17:39:38.303]                             version <- utils::packageVersion("future")
[17:39:38.303]                         }
[17:39:38.303]                         else {
[17:39:38.303]                           version <- NULL
[17:39:38.303]                         }
[17:39:38.303]                         if (!has_future || version < "1.8.0") {
[17:39:38.303]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.303]                             "", base::R.version$version.string), 
[17:39:38.303]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.303]                               "release", "version")], collapse = " "), 
[17:39:38.303]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.303]                             info)
[17:39:38.303]                           info <- base::paste(info, collapse = "; ")
[17:39:38.303]                           if (!has_future) {
[17:39:38.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.303]                               info)
[17:39:38.303]                           }
[17:39:38.303]                           else {
[17:39:38.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.303]                               info, version)
[17:39:38.303]                           }
[17:39:38.303]                           base::stop(msg)
[17:39:38.303]                         }
[17:39:38.303]                       })
[17:39:38.303]                     }
[17:39:38.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.303]                     base::options(mc.cores = 1L)
[17:39:38.303]                   }
[17:39:38.303]                   ...future.strategy.old <- future::plan("list")
[17:39:38.303]                   options(future.plan = NULL)
[17:39:38.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.303]                 }
[17:39:38.303]                 ...future.workdir <- getwd()
[17:39:38.303]             }
[17:39:38.303]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.303]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.303]         }
[17:39:38.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.303]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.303]             base::names(...future.oldOptions))
[17:39:38.303]     }
[17:39:38.303]     if (FALSE) {
[17:39:38.303]     }
[17:39:38.303]     else {
[17:39:38.303]         if (TRUE) {
[17:39:38.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.303]                 open = "w")
[17:39:38.303]         }
[17:39:38.303]         else {
[17:39:38.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.303]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.303]         }
[17:39:38.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.303]             base::sink(type = "output", split = FALSE)
[17:39:38.303]             base::close(...future.stdout)
[17:39:38.303]         }, add = TRUE)
[17:39:38.303]     }
[17:39:38.303]     ...future.frame <- base::sys.nframe()
[17:39:38.303]     ...future.conditions <- base::list()
[17:39:38.303]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.303]     if (FALSE) {
[17:39:38.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.303]     }
[17:39:38.303]     ...future.result <- base::tryCatch({
[17:39:38.303]         base::withCallingHandlers({
[17:39:38.303]             ...future.value <- base::withVisible(base::local({
[17:39:38.303]                 ...future.makeSendCondition <- base::local({
[17:39:38.303]                   sendCondition <- NULL
[17:39:38.303]                   function(frame = 1L) {
[17:39:38.303]                     if (is.function(sendCondition)) 
[17:39:38.303]                       return(sendCondition)
[17:39:38.303]                     ns <- getNamespace("parallel")
[17:39:38.303]                     if (exists("sendData", mode = "function", 
[17:39:38.303]                       envir = ns)) {
[17:39:38.303]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.303]                         envir = ns)
[17:39:38.303]                       envir <- sys.frame(frame)
[17:39:38.303]                       master <- NULL
[17:39:38.303]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.303]                         !identical(envir, emptyenv())) {
[17:39:38.303]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.303]                           inherits = FALSE)) {
[17:39:38.303]                           master <- get("master", mode = "list", 
[17:39:38.303]                             envir = envir, inherits = FALSE)
[17:39:38.303]                           if (inherits(master, c("SOCKnode", 
[17:39:38.303]                             "SOCK0node"))) {
[17:39:38.303]                             sendCondition <<- function(cond) {
[17:39:38.303]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.303]                                 success = TRUE)
[17:39:38.303]                               parallel_sendData(master, data)
[17:39:38.303]                             }
[17:39:38.303]                             return(sendCondition)
[17:39:38.303]                           }
[17:39:38.303]                         }
[17:39:38.303]                         frame <- frame + 1L
[17:39:38.303]                         envir <- sys.frame(frame)
[17:39:38.303]                       }
[17:39:38.303]                     }
[17:39:38.303]                     sendCondition <<- function(cond) NULL
[17:39:38.303]                   }
[17:39:38.303]                 })
[17:39:38.303]                 withCallingHandlers({
[17:39:38.303]                   NULL
[17:39:38.303]                 }, immediateCondition = function(cond) {
[17:39:38.303]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.303]                   sendCondition(cond)
[17:39:38.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.303]                   {
[17:39:38.303]                     inherits <- base::inherits
[17:39:38.303]                     invokeRestart <- base::invokeRestart
[17:39:38.303]                     is.null <- base::is.null
[17:39:38.303]                     muffled <- FALSE
[17:39:38.303]                     if (inherits(cond, "message")) {
[17:39:38.303]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.303]                       if (muffled) 
[17:39:38.303]                         invokeRestart("muffleMessage")
[17:39:38.303]                     }
[17:39:38.303]                     else if (inherits(cond, "warning")) {
[17:39:38.303]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.303]                       if (muffled) 
[17:39:38.303]                         invokeRestart("muffleWarning")
[17:39:38.303]                     }
[17:39:38.303]                     else if (inherits(cond, "condition")) {
[17:39:38.303]                       if (!is.null(pattern)) {
[17:39:38.303]                         computeRestarts <- base::computeRestarts
[17:39:38.303]                         grepl <- base::grepl
[17:39:38.303]                         restarts <- computeRestarts(cond)
[17:39:38.303]                         for (restart in restarts) {
[17:39:38.303]                           name <- restart$name
[17:39:38.303]                           if (is.null(name)) 
[17:39:38.303]                             next
[17:39:38.303]                           if (!grepl(pattern, name)) 
[17:39:38.303]                             next
[17:39:38.303]                           invokeRestart(restart)
[17:39:38.303]                           muffled <- TRUE
[17:39:38.303]                           break
[17:39:38.303]                         }
[17:39:38.303]                       }
[17:39:38.303]                     }
[17:39:38.303]                     invisible(muffled)
[17:39:38.303]                   }
[17:39:38.303]                   muffleCondition(cond)
[17:39:38.303]                 })
[17:39:38.303]             }))
[17:39:38.303]             future::FutureResult(value = ...future.value$value, 
[17:39:38.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.303]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.303]                     ...future.globalenv.names))
[17:39:38.303]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.303]         }, condition = base::local({
[17:39:38.303]             c <- base::c
[17:39:38.303]             inherits <- base::inherits
[17:39:38.303]             invokeRestart <- base::invokeRestart
[17:39:38.303]             length <- base::length
[17:39:38.303]             list <- base::list
[17:39:38.303]             seq.int <- base::seq.int
[17:39:38.303]             signalCondition <- base::signalCondition
[17:39:38.303]             sys.calls <- base::sys.calls
[17:39:38.303]             `[[` <- base::`[[`
[17:39:38.303]             `+` <- base::`+`
[17:39:38.303]             `<<-` <- base::`<<-`
[17:39:38.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.303]                   3L)]
[17:39:38.303]             }
[17:39:38.303]             function(cond) {
[17:39:38.303]                 is_error <- inherits(cond, "error")
[17:39:38.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.303]                   NULL)
[17:39:38.303]                 if (is_error) {
[17:39:38.303]                   sessionInformation <- function() {
[17:39:38.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.303]                       search = base::search(), system = base::Sys.info())
[17:39:38.303]                   }
[17:39:38.303]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.303]                     cond$call), session = sessionInformation(), 
[17:39:38.303]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.303]                   signalCondition(cond)
[17:39:38.303]                 }
[17:39:38.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.303]                 "immediateCondition"))) {
[17:39:38.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.303]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.303]                   if (TRUE && !signal) {
[17:39:38.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.303]                     {
[17:39:38.303]                       inherits <- base::inherits
[17:39:38.303]                       invokeRestart <- base::invokeRestart
[17:39:38.303]                       is.null <- base::is.null
[17:39:38.303]                       muffled <- FALSE
[17:39:38.303]                       if (inherits(cond, "message")) {
[17:39:38.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.303]                         if (muffled) 
[17:39:38.303]                           invokeRestart("muffleMessage")
[17:39:38.303]                       }
[17:39:38.303]                       else if (inherits(cond, "warning")) {
[17:39:38.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.303]                         if (muffled) 
[17:39:38.303]                           invokeRestart("muffleWarning")
[17:39:38.303]                       }
[17:39:38.303]                       else if (inherits(cond, "condition")) {
[17:39:38.303]                         if (!is.null(pattern)) {
[17:39:38.303]                           computeRestarts <- base::computeRestarts
[17:39:38.303]                           grepl <- base::grepl
[17:39:38.303]                           restarts <- computeRestarts(cond)
[17:39:38.303]                           for (restart in restarts) {
[17:39:38.303]                             name <- restart$name
[17:39:38.303]                             if (is.null(name)) 
[17:39:38.303]                               next
[17:39:38.303]                             if (!grepl(pattern, name)) 
[17:39:38.303]                               next
[17:39:38.303]                             invokeRestart(restart)
[17:39:38.303]                             muffled <- TRUE
[17:39:38.303]                             break
[17:39:38.303]                           }
[17:39:38.303]                         }
[17:39:38.303]                       }
[17:39:38.303]                       invisible(muffled)
[17:39:38.303]                     }
[17:39:38.303]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.303]                   }
[17:39:38.303]                 }
[17:39:38.303]                 else {
[17:39:38.303]                   if (TRUE) {
[17:39:38.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.303]                     {
[17:39:38.303]                       inherits <- base::inherits
[17:39:38.303]                       invokeRestart <- base::invokeRestart
[17:39:38.303]                       is.null <- base::is.null
[17:39:38.303]                       muffled <- FALSE
[17:39:38.303]                       if (inherits(cond, "message")) {
[17:39:38.303]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.303]                         if (muffled) 
[17:39:38.303]                           invokeRestart("muffleMessage")
[17:39:38.303]                       }
[17:39:38.303]                       else if (inherits(cond, "warning")) {
[17:39:38.303]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.303]                         if (muffled) 
[17:39:38.303]                           invokeRestart("muffleWarning")
[17:39:38.303]                       }
[17:39:38.303]                       else if (inherits(cond, "condition")) {
[17:39:38.303]                         if (!is.null(pattern)) {
[17:39:38.303]                           computeRestarts <- base::computeRestarts
[17:39:38.303]                           grepl <- base::grepl
[17:39:38.303]                           restarts <- computeRestarts(cond)
[17:39:38.303]                           for (restart in restarts) {
[17:39:38.303]                             name <- restart$name
[17:39:38.303]                             if (is.null(name)) 
[17:39:38.303]                               next
[17:39:38.303]                             if (!grepl(pattern, name)) 
[17:39:38.303]                               next
[17:39:38.303]                             invokeRestart(restart)
[17:39:38.303]                             muffled <- TRUE
[17:39:38.303]                             break
[17:39:38.303]                           }
[17:39:38.303]                         }
[17:39:38.303]                       }
[17:39:38.303]                       invisible(muffled)
[17:39:38.303]                     }
[17:39:38.303]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.303]                   }
[17:39:38.303]                 }
[17:39:38.303]             }
[17:39:38.303]         }))
[17:39:38.303]     }, error = function(ex) {
[17:39:38.303]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.303]                 ...future.rng), started = ...future.startTime, 
[17:39:38.303]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.303]             version = "1.8"), class = "FutureResult")
[17:39:38.303]     }, finally = {
[17:39:38.303]         if (!identical(...future.workdir, getwd())) 
[17:39:38.303]             setwd(...future.workdir)
[17:39:38.303]         {
[17:39:38.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.303]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.303]             }
[17:39:38.303]             base::options(...future.oldOptions)
[17:39:38.303]             if (.Platform$OS.type == "windows") {
[17:39:38.303]                 old_names <- names(...future.oldEnvVars)
[17:39:38.303]                 envs <- base::Sys.getenv()
[17:39:38.303]                 names <- names(envs)
[17:39:38.303]                 common <- intersect(names, old_names)
[17:39:38.303]                 added <- setdiff(names, old_names)
[17:39:38.303]                 removed <- setdiff(old_names, names)
[17:39:38.303]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.303]                   envs[common]]
[17:39:38.303]                 NAMES <- toupper(changed)
[17:39:38.303]                 args <- list()
[17:39:38.303]                 for (kk in seq_along(NAMES)) {
[17:39:38.303]                   name <- changed[[kk]]
[17:39:38.303]                   NAME <- NAMES[[kk]]
[17:39:38.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.303]                     next
[17:39:38.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.303]                 }
[17:39:38.303]                 NAMES <- toupper(added)
[17:39:38.303]                 for (kk in seq_along(NAMES)) {
[17:39:38.303]                   name <- added[[kk]]
[17:39:38.303]                   NAME <- NAMES[[kk]]
[17:39:38.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.303]                     next
[17:39:38.303]                   args[[name]] <- ""
[17:39:38.303]                 }
[17:39:38.303]                 NAMES <- toupper(removed)
[17:39:38.303]                 for (kk in seq_along(NAMES)) {
[17:39:38.303]                   name <- removed[[kk]]
[17:39:38.303]                   NAME <- NAMES[[kk]]
[17:39:38.303]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.303]                     next
[17:39:38.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.303]                 }
[17:39:38.303]                 if (length(args) > 0) 
[17:39:38.303]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.303]             }
[17:39:38.303]             else {
[17:39:38.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.303]             }
[17:39:38.303]             {
[17:39:38.303]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.303]                   0L) {
[17:39:38.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.303]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.303]                   base::options(opts)
[17:39:38.303]                 }
[17:39:38.303]                 {
[17:39:38.303]                   {
[17:39:38.303]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.303]                     NULL
[17:39:38.303]                   }
[17:39:38.303]                   options(future.plan = NULL)
[17:39:38.303]                   if (is.na(NA_character_)) 
[17:39:38.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.303]                     .init = FALSE)
[17:39:38.303]                 }
[17:39:38.303]             }
[17:39:38.303]         }
[17:39:38.303]     })
[17:39:38.303]     if (TRUE) {
[17:39:38.303]         base::sink(type = "output", split = FALSE)
[17:39:38.303]         if (TRUE) {
[17:39:38.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.303]         }
[17:39:38.303]         else {
[17:39:38.303]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.303]         }
[17:39:38.303]         base::close(...future.stdout)
[17:39:38.303]         ...future.stdout <- NULL
[17:39:38.303]     }
[17:39:38.303]     ...future.result$conditions <- ...future.conditions
[17:39:38.303]     ...future.result$finished <- base::Sys.time()
[17:39:38.303]     ...future.result
[17:39:38.303] }
[17:39:38.306] MultisessionFuture started
[17:39:38.306] - Launch lazy future ... done
[17:39:38.306] run() for ‘MultisessionFuture’ ... done
[17:39:38.307] getGlobalsAndPackages() ...
[17:39:38.307] Searching for globals...
[17:39:38.308] - globals found: [1] ‘{’
[17:39:38.308] Searching for globals ... DONE
[17:39:38.308] Resolving globals: FALSE
[17:39:38.308] 
[17:39:38.308] 
[17:39:38.308] getGlobalsAndPackages() ... DONE
[17:39:38.309] run() for ‘Future’ ...
[17:39:38.309] - state: ‘created’
[17:39:38.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.323]   - Field: ‘node’
[17:39:38.323]   - Field: ‘label’
[17:39:38.323]   - Field: ‘local’
[17:39:38.323]   - Field: ‘owner’
[17:39:38.323]   - Field: ‘envir’
[17:39:38.323]   - Field: ‘workers’
[17:39:38.323]   - Field: ‘packages’
[17:39:38.324]   - Field: ‘gc’
[17:39:38.324]   - Field: ‘conditions’
[17:39:38.324]   - Field: ‘persistent’
[17:39:38.324]   - Field: ‘expr’
[17:39:38.324]   - Field: ‘uuid’
[17:39:38.324]   - Field: ‘seed’
[17:39:38.324]   - Field: ‘version’
[17:39:38.324]   - Field: ‘result’
[17:39:38.324]   - Field: ‘asynchronous’
[17:39:38.324]   - Field: ‘calls’
[17:39:38.324]   - Field: ‘globals’
[17:39:38.325]   - Field: ‘stdout’
[17:39:38.325]   - Field: ‘earlySignal’
[17:39:38.325]   - Field: ‘lazy’
[17:39:38.325]   - Field: ‘state’
[17:39:38.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.325] - Launch lazy future ...
[17:39:38.325] Packages needed by the future expression (n = 0): <none>
[17:39:38.325] Packages needed by future strategies (n = 0): <none>
[17:39:38.326] {
[17:39:38.326]     {
[17:39:38.326]         {
[17:39:38.326]             ...future.startTime <- base::Sys.time()
[17:39:38.326]             {
[17:39:38.326]                 {
[17:39:38.326]                   {
[17:39:38.326]                     {
[17:39:38.326]                       base::local({
[17:39:38.326]                         has_future <- base::requireNamespace("future", 
[17:39:38.326]                           quietly = TRUE)
[17:39:38.326]                         if (has_future) {
[17:39:38.326]                           ns <- base::getNamespace("future")
[17:39:38.326]                           version <- ns[[".package"]][["version"]]
[17:39:38.326]                           if (is.null(version)) 
[17:39:38.326]                             version <- utils::packageVersion("future")
[17:39:38.326]                         }
[17:39:38.326]                         else {
[17:39:38.326]                           version <- NULL
[17:39:38.326]                         }
[17:39:38.326]                         if (!has_future || version < "1.8.0") {
[17:39:38.326]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.326]                             "", base::R.version$version.string), 
[17:39:38.326]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.326]                               "release", "version")], collapse = " "), 
[17:39:38.326]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.326]                             info)
[17:39:38.326]                           info <- base::paste(info, collapse = "; ")
[17:39:38.326]                           if (!has_future) {
[17:39:38.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.326]                               info)
[17:39:38.326]                           }
[17:39:38.326]                           else {
[17:39:38.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.326]                               info, version)
[17:39:38.326]                           }
[17:39:38.326]                           base::stop(msg)
[17:39:38.326]                         }
[17:39:38.326]                       })
[17:39:38.326]                     }
[17:39:38.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.326]                     base::options(mc.cores = 1L)
[17:39:38.326]                   }
[17:39:38.326]                   ...future.strategy.old <- future::plan("list")
[17:39:38.326]                   options(future.plan = NULL)
[17:39:38.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.326]                 }
[17:39:38.326]                 ...future.workdir <- getwd()
[17:39:38.326]             }
[17:39:38.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.326]         }
[17:39:38.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.326]             base::names(...future.oldOptions))
[17:39:38.326]     }
[17:39:38.326]     if (FALSE) {
[17:39:38.326]     }
[17:39:38.326]     else {
[17:39:38.326]         if (TRUE) {
[17:39:38.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.326]                 open = "w")
[17:39:38.326]         }
[17:39:38.326]         else {
[17:39:38.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.326]         }
[17:39:38.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.326]             base::sink(type = "output", split = FALSE)
[17:39:38.326]             base::close(...future.stdout)
[17:39:38.326]         }, add = TRUE)
[17:39:38.326]     }
[17:39:38.326]     ...future.frame <- base::sys.nframe()
[17:39:38.326]     ...future.conditions <- base::list()
[17:39:38.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.326]     if (FALSE) {
[17:39:38.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.326]     }
[17:39:38.326]     ...future.result <- base::tryCatch({
[17:39:38.326]         base::withCallingHandlers({
[17:39:38.326]             ...future.value <- base::withVisible(base::local({
[17:39:38.326]                 ...future.makeSendCondition <- base::local({
[17:39:38.326]                   sendCondition <- NULL
[17:39:38.326]                   function(frame = 1L) {
[17:39:38.326]                     if (is.function(sendCondition)) 
[17:39:38.326]                       return(sendCondition)
[17:39:38.326]                     ns <- getNamespace("parallel")
[17:39:38.326]                     if (exists("sendData", mode = "function", 
[17:39:38.326]                       envir = ns)) {
[17:39:38.326]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.326]                         envir = ns)
[17:39:38.326]                       envir <- sys.frame(frame)
[17:39:38.326]                       master <- NULL
[17:39:38.326]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.326]                         !identical(envir, emptyenv())) {
[17:39:38.326]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.326]                           inherits = FALSE)) {
[17:39:38.326]                           master <- get("master", mode = "list", 
[17:39:38.326]                             envir = envir, inherits = FALSE)
[17:39:38.326]                           if (inherits(master, c("SOCKnode", 
[17:39:38.326]                             "SOCK0node"))) {
[17:39:38.326]                             sendCondition <<- function(cond) {
[17:39:38.326]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.326]                                 success = TRUE)
[17:39:38.326]                               parallel_sendData(master, data)
[17:39:38.326]                             }
[17:39:38.326]                             return(sendCondition)
[17:39:38.326]                           }
[17:39:38.326]                         }
[17:39:38.326]                         frame <- frame + 1L
[17:39:38.326]                         envir <- sys.frame(frame)
[17:39:38.326]                       }
[17:39:38.326]                     }
[17:39:38.326]                     sendCondition <<- function(cond) NULL
[17:39:38.326]                   }
[17:39:38.326]                 })
[17:39:38.326]                 withCallingHandlers({
[17:39:38.326]                   {
[17:39:38.326]                     4
[17:39:38.326]                   }
[17:39:38.326]                 }, immediateCondition = function(cond) {
[17:39:38.326]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.326]                   sendCondition(cond)
[17:39:38.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.326]                   {
[17:39:38.326]                     inherits <- base::inherits
[17:39:38.326]                     invokeRestart <- base::invokeRestart
[17:39:38.326]                     is.null <- base::is.null
[17:39:38.326]                     muffled <- FALSE
[17:39:38.326]                     if (inherits(cond, "message")) {
[17:39:38.326]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.326]                       if (muffled) 
[17:39:38.326]                         invokeRestart("muffleMessage")
[17:39:38.326]                     }
[17:39:38.326]                     else if (inherits(cond, "warning")) {
[17:39:38.326]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.326]                       if (muffled) 
[17:39:38.326]                         invokeRestart("muffleWarning")
[17:39:38.326]                     }
[17:39:38.326]                     else if (inherits(cond, "condition")) {
[17:39:38.326]                       if (!is.null(pattern)) {
[17:39:38.326]                         computeRestarts <- base::computeRestarts
[17:39:38.326]                         grepl <- base::grepl
[17:39:38.326]                         restarts <- computeRestarts(cond)
[17:39:38.326]                         for (restart in restarts) {
[17:39:38.326]                           name <- restart$name
[17:39:38.326]                           if (is.null(name)) 
[17:39:38.326]                             next
[17:39:38.326]                           if (!grepl(pattern, name)) 
[17:39:38.326]                             next
[17:39:38.326]                           invokeRestart(restart)
[17:39:38.326]                           muffled <- TRUE
[17:39:38.326]                           break
[17:39:38.326]                         }
[17:39:38.326]                       }
[17:39:38.326]                     }
[17:39:38.326]                     invisible(muffled)
[17:39:38.326]                   }
[17:39:38.326]                   muffleCondition(cond)
[17:39:38.326]                 })
[17:39:38.326]             }))
[17:39:38.326]             future::FutureResult(value = ...future.value$value, 
[17:39:38.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.326]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.326]                     ...future.globalenv.names))
[17:39:38.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.326]         }, condition = base::local({
[17:39:38.326]             c <- base::c
[17:39:38.326]             inherits <- base::inherits
[17:39:38.326]             invokeRestart <- base::invokeRestart
[17:39:38.326]             length <- base::length
[17:39:38.326]             list <- base::list
[17:39:38.326]             seq.int <- base::seq.int
[17:39:38.326]             signalCondition <- base::signalCondition
[17:39:38.326]             sys.calls <- base::sys.calls
[17:39:38.326]             `[[` <- base::`[[`
[17:39:38.326]             `+` <- base::`+`
[17:39:38.326]             `<<-` <- base::`<<-`
[17:39:38.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.326]                   3L)]
[17:39:38.326]             }
[17:39:38.326]             function(cond) {
[17:39:38.326]                 is_error <- inherits(cond, "error")
[17:39:38.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.326]                   NULL)
[17:39:38.326]                 if (is_error) {
[17:39:38.326]                   sessionInformation <- function() {
[17:39:38.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.326]                       search = base::search(), system = base::Sys.info())
[17:39:38.326]                   }
[17:39:38.326]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.326]                     cond$call), session = sessionInformation(), 
[17:39:38.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.326]                   signalCondition(cond)
[17:39:38.326]                 }
[17:39:38.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.326]                 "immediateCondition"))) {
[17:39:38.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.326]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.326]                   if (TRUE && !signal) {
[17:39:38.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.326]                     {
[17:39:38.326]                       inherits <- base::inherits
[17:39:38.326]                       invokeRestart <- base::invokeRestart
[17:39:38.326]                       is.null <- base::is.null
[17:39:38.326]                       muffled <- FALSE
[17:39:38.326]                       if (inherits(cond, "message")) {
[17:39:38.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.326]                         if (muffled) 
[17:39:38.326]                           invokeRestart("muffleMessage")
[17:39:38.326]                       }
[17:39:38.326]                       else if (inherits(cond, "warning")) {
[17:39:38.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.326]                         if (muffled) 
[17:39:38.326]                           invokeRestart("muffleWarning")
[17:39:38.326]                       }
[17:39:38.326]                       else if (inherits(cond, "condition")) {
[17:39:38.326]                         if (!is.null(pattern)) {
[17:39:38.326]                           computeRestarts <- base::computeRestarts
[17:39:38.326]                           grepl <- base::grepl
[17:39:38.326]                           restarts <- computeRestarts(cond)
[17:39:38.326]                           for (restart in restarts) {
[17:39:38.326]                             name <- restart$name
[17:39:38.326]                             if (is.null(name)) 
[17:39:38.326]                               next
[17:39:38.326]                             if (!grepl(pattern, name)) 
[17:39:38.326]                               next
[17:39:38.326]                             invokeRestart(restart)
[17:39:38.326]                             muffled <- TRUE
[17:39:38.326]                             break
[17:39:38.326]                           }
[17:39:38.326]                         }
[17:39:38.326]                       }
[17:39:38.326]                       invisible(muffled)
[17:39:38.326]                     }
[17:39:38.326]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.326]                   }
[17:39:38.326]                 }
[17:39:38.326]                 else {
[17:39:38.326]                   if (TRUE) {
[17:39:38.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.326]                     {
[17:39:38.326]                       inherits <- base::inherits
[17:39:38.326]                       invokeRestart <- base::invokeRestart
[17:39:38.326]                       is.null <- base::is.null
[17:39:38.326]                       muffled <- FALSE
[17:39:38.326]                       if (inherits(cond, "message")) {
[17:39:38.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.326]                         if (muffled) 
[17:39:38.326]                           invokeRestart("muffleMessage")
[17:39:38.326]                       }
[17:39:38.326]                       else if (inherits(cond, "warning")) {
[17:39:38.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.326]                         if (muffled) 
[17:39:38.326]                           invokeRestart("muffleWarning")
[17:39:38.326]                       }
[17:39:38.326]                       else if (inherits(cond, "condition")) {
[17:39:38.326]                         if (!is.null(pattern)) {
[17:39:38.326]                           computeRestarts <- base::computeRestarts
[17:39:38.326]                           grepl <- base::grepl
[17:39:38.326]                           restarts <- computeRestarts(cond)
[17:39:38.326]                           for (restart in restarts) {
[17:39:38.326]                             name <- restart$name
[17:39:38.326]                             if (is.null(name)) 
[17:39:38.326]                               next
[17:39:38.326]                             if (!grepl(pattern, name)) 
[17:39:38.326]                               next
[17:39:38.326]                             invokeRestart(restart)
[17:39:38.326]                             muffled <- TRUE
[17:39:38.326]                             break
[17:39:38.326]                           }
[17:39:38.326]                         }
[17:39:38.326]                       }
[17:39:38.326]                       invisible(muffled)
[17:39:38.326]                     }
[17:39:38.326]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.326]                   }
[17:39:38.326]                 }
[17:39:38.326]             }
[17:39:38.326]         }))
[17:39:38.326]     }, error = function(ex) {
[17:39:38.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.326]                 ...future.rng), started = ...future.startTime, 
[17:39:38.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.326]             version = "1.8"), class = "FutureResult")
[17:39:38.326]     }, finally = {
[17:39:38.326]         if (!identical(...future.workdir, getwd())) 
[17:39:38.326]             setwd(...future.workdir)
[17:39:38.326]         {
[17:39:38.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.326]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.326]             }
[17:39:38.326]             base::options(...future.oldOptions)
[17:39:38.326]             if (.Platform$OS.type == "windows") {
[17:39:38.326]                 old_names <- names(...future.oldEnvVars)
[17:39:38.326]                 envs <- base::Sys.getenv()
[17:39:38.326]                 names <- names(envs)
[17:39:38.326]                 common <- intersect(names, old_names)
[17:39:38.326]                 added <- setdiff(names, old_names)
[17:39:38.326]                 removed <- setdiff(old_names, names)
[17:39:38.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.326]                   envs[common]]
[17:39:38.326]                 NAMES <- toupper(changed)
[17:39:38.326]                 args <- list()
[17:39:38.326]                 for (kk in seq_along(NAMES)) {
[17:39:38.326]                   name <- changed[[kk]]
[17:39:38.326]                   NAME <- NAMES[[kk]]
[17:39:38.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.326]                     next
[17:39:38.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.326]                 }
[17:39:38.326]                 NAMES <- toupper(added)
[17:39:38.326]                 for (kk in seq_along(NAMES)) {
[17:39:38.326]                   name <- added[[kk]]
[17:39:38.326]                   NAME <- NAMES[[kk]]
[17:39:38.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.326]                     next
[17:39:38.326]                   args[[name]] <- ""
[17:39:38.326]                 }
[17:39:38.326]                 NAMES <- toupper(removed)
[17:39:38.326]                 for (kk in seq_along(NAMES)) {
[17:39:38.326]                   name <- removed[[kk]]
[17:39:38.326]                   NAME <- NAMES[[kk]]
[17:39:38.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.326]                     next
[17:39:38.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.326]                 }
[17:39:38.326]                 if (length(args) > 0) 
[17:39:38.326]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.326]             }
[17:39:38.326]             else {
[17:39:38.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.326]             }
[17:39:38.326]             {
[17:39:38.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.326]                   0L) {
[17:39:38.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.326]                   base::options(opts)
[17:39:38.326]                 }
[17:39:38.326]                 {
[17:39:38.326]                   {
[17:39:38.326]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.326]                     NULL
[17:39:38.326]                   }
[17:39:38.326]                   options(future.plan = NULL)
[17:39:38.326]                   if (is.na(NA_character_)) 
[17:39:38.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.326]                     .init = FALSE)
[17:39:38.326]                 }
[17:39:38.326]             }
[17:39:38.326]         }
[17:39:38.326]     })
[17:39:38.326]     if (TRUE) {
[17:39:38.326]         base::sink(type = "output", split = FALSE)
[17:39:38.326]         if (TRUE) {
[17:39:38.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.326]         }
[17:39:38.326]         else {
[17:39:38.326]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.326]         }
[17:39:38.326]         base::close(...future.stdout)
[17:39:38.326]         ...future.stdout <- NULL
[17:39:38.326]     }
[17:39:38.326]     ...future.result$conditions <- ...future.conditions
[17:39:38.326]     ...future.result$finished <- base::Sys.time()
[17:39:38.326]     ...future.result
[17:39:38.326] }
[17:39:38.328] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:38.339] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.339] - Validating connection of MultisessionFuture
[17:39:38.339] - received message: FutureResult
[17:39:38.339] - Received FutureResult
[17:39:38.339] - Erased future from FutureRegistry
[17:39:38.339] result() for ClusterFuture ...
[17:39:38.340] - result already collected: FutureResult
[17:39:38.340] result() for ClusterFuture ... done
[17:39:38.340] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.340] result() for ClusterFuture ...
[17:39:38.340] - result already collected: FutureResult
[17:39:38.340] result() for ClusterFuture ... done
[17:39:38.340] result() for ClusterFuture ...
[17:39:38.340] - result already collected: FutureResult
[17:39:38.340] result() for ClusterFuture ... done
[17:39:38.341] MultisessionFuture started
[17:39:38.342] - Launch lazy future ... done
[17:39:38.342] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf0f56e60> 
Classes 'listenv', 'environment' <environment: 0x55adf1fe1a40> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:39:38.347] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.347] - Validating connection of MultisessionFuture
[17:39:38.347] - received message: FutureResult
[17:39:38.347] - Received FutureResult
[17:39:38.347] - Erased future from FutureRegistry
[17:39:38.347] result() for ClusterFuture ...
[17:39:38.347] - result already collected: FutureResult
[17:39:38.347] result() for ClusterFuture ... done
[17:39:38.347] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.348] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.348] - Validating connection of MultisessionFuture
[17:39:38.348] - received message: FutureResult
[17:39:38.348] - Received FutureResult
[17:39:38.348] - Erased future from FutureRegistry
[17:39:38.349] result() for ClusterFuture ...
[17:39:38.349] - result already collected: FutureResult
[17:39:38.349] result() for ClusterFuture ... done
[17:39:38.349] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:38.354] resolve() on list environment ...
[17:39:38.354]  recursive: 0
[17:39:38.355]  length: 6
[17:39:38.355]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:38.356] signalConditionsASAP(numeric, pos=1) ...
[17:39:38.356] - nx: 6
[17:39:38.356] - relay: TRUE
[17:39:38.356] - stdout: TRUE
[17:39:38.356] - signal: TRUE
[17:39:38.356] - resignal: FALSE
[17:39:38.356] - force: TRUE
[17:39:38.356] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.356] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.356]  - until=2
[17:39:38.356]  - relaying element #2
[17:39:38.357] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.357] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.357] signalConditionsASAP(NULL, pos=1) ... done
[17:39:38.357]  length: 5 (resolved future 1)
[17:39:38.357] Future #2
[17:39:38.357] result() for ClusterFuture ...
[17:39:38.357] - result already collected: FutureResult
[17:39:38.357] result() for ClusterFuture ... done
[17:39:38.357] result() for ClusterFuture ...
[17:39:38.357] - result already collected: FutureResult
[17:39:38.357] result() for ClusterFuture ... done
[17:39:38.358] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:38.358] - nx: 6
[17:39:38.358] - relay: TRUE
[17:39:38.358] - stdout: TRUE
[17:39:38.358] - signal: TRUE
[17:39:38.358] - resignal: FALSE
[17:39:38.358] - force: TRUE
[17:39:38.358] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.358] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.358]  - until=2
[17:39:38.358]  - relaying element #2
[17:39:38.359] result() for ClusterFuture ...
[17:39:38.359] - result already collected: FutureResult
[17:39:38.359] result() for ClusterFuture ... done
[17:39:38.359] result() for ClusterFuture ...
[17:39:38.359] - result already collected: FutureResult
[17:39:38.359] result() for ClusterFuture ... done
[17:39:38.359] result() for ClusterFuture ...
[17:39:38.359] - result already collected: FutureResult
[17:39:38.359] result() for ClusterFuture ... done
[17:39:38.359] result() for ClusterFuture ...
[17:39:38.359] - result already collected: FutureResult
[17:39:38.359] result() for ClusterFuture ... done
[17:39:38.360] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.360] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.360] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:38.360]  length: 4 (resolved future 2)
[17:39:38.360] Future #3
[17:39:38.360] result() for ClusterFuture ...
[17:39:38.360] - result already collected: FutureResult
[17:39:38.360] result() for ClusterFuture ... done
[17:39:38.360] result() for ClusterFuture ...
[17:39:38.360] - result already collected: FutureResult
[17:39:38.361] result() for ClusterFuture ... done
[17:39:38.361] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:38.361] - nx: 6
[17:39:38.361] - relay: TRUE
[17:39:38.361] - stdout: TRUE
[17:39:38.361] - signal: TRUE
[17:39:38.361] - resignal: FALSE
[17:39:38.361] - force: TRUE
[17:39:38.361] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.361] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.361]  - until=3
[17:39:38.361]  - relaying element #3
[17:39:38.362] result() for ClusterFuture ...
[17:39:38.362] - result already collected: FutureResult
[17:39:38.362] result() for ClusterFuture ... done
[17:39:38.362] result() for ClusterFuture ...
[17:39:38.362] - result already collected: FutureResult
[17:39:38.362] result() for ClusterFuture ... done
[17:39:38.362] result() for ClusterFuture ...
[17:39:38.362] - result already collected: FutureResult
[17:39:38.362] result() for ClusterFuture ... done
[17:39:38.362] result() for ClusterFuture ...
[17:39:38.362] - result already collected: FutureResult
[17:39:38.362] result() for ClusterFuture ... done
[17:39:38.363] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.363] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:38.363]  length: 3 (resolved future 3)
[17:39:38.363] Future #4
[17:39:38.363] result() for ClusterFuture ...
[17:39:38.363] - result already collected: FutureResult
[17:39:38.363] result() for ClusterFuture ... done
[17:39:38.363] result() for ClusterFuture ...
[17:39:38.363] - result already collected: FutureResult
[17:39:38.363] result() for ClusterFuture ... done
[17:39:38.364] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:38.364] - nx: 6
[17:39:38.364] - relay: TRUE
[17:39:38.364] - stdout: TRUE
[17:39:38.364] - signal: TRUE
[17:39:38.364] - resignal: FALSE
[17:39:38.364] - force: TRUE
[17:39:38.364] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.364]  - until=4
[17:39:38.364]  - relaying element #4
[17:39:38.364] result() for ClusterFuture ...
[17:39:38.365] - result already collected: FutureResult
[17:39:38.365] result() for ClusterFuture ... done
[17:39:38.365] result() for ClusterFuture ...
[17:39:38.365] - result already collected: FutureResult
[17:39:38.365] result() for ClusterFuture ... done
[17:39:38.365] result() for ClusterFuture ...
[17:39:38.365] - result already collected: FutureResult
[17:39:38.365] result() for ClusterFuture ... done
[17:39:38.365] result() for ClusterFuture ...
[17:39:38.365] - result already collected: FutureResult
[17:39:38.365] result() for ClusterFuture ... done
[17:39:38.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.366] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:38.366]  length: 2 (resolved future 4)
[17:39:38.366] signalConditionsASAP(NULL, pos=5) ...
[17:39:38.366] - nx: 6
[17:39:38.366] - relay: TRUE
[17:39:38.366] - stdout: TRUE
[17:39:38.366] - signal: TRUE
[17:39:38.366] - resignal: FALSE
[17:39:38.366] - force: TRUE
[17:39:38.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.366] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.367]  - until=6
[17:39:38.367]  - relaying element #6
[17:39:38.367] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.367] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.367] signalConditionsASAP(NULL, pos=5) ... done
[17:39:38.367]  length: 1 (resolved future 5)
[17:39:38.367] signalConditionsASAP(numeric, pos=6) ...
[17:39:38.367] - nx: 6
[17:39:38.367] - relay: TRUE
[17:39:38.367] - stdout: TRUE
[17:39:38.367] - signal: TRUE
[17:39:38.368] - resignal: FALSE
[17:39:38.368] - force: TRUE
[17:39:38.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.368]  - until=6
[17:39:38.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.368] signalConditionsASAP(numeric, pos=6) ... done
[17:39:38.368]  length: 0 (resolved future 6)
[17:39:38.368] Relaying remaining futures
[17:39:38.368] signalConditionsASAP(NULL, pos=0) ...
[17:39:38.368] - nx: 6
[17:39:38.369] - relay: TRUE
[17:39:38.369] - stdout: TRUE
[17:39:38.369] - signal: TRUE
[17:39:38.369] - resignal: FALSE
[17:39:38.369] - force: TRUE
[17:39:38.369] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.369] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:38.369] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.369] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.369] signalConditionsASAP(NULL, pos=0) ... done
[17:39:38.369] resolve() on list environment ... DONE
[17:39:38.370] result() for ClusterFuture ...
[17:39:38.370] - result already collected: FutureResult
[17:39:38.370] result() for ClusterFuture ... done
[17:39:38.370] result() for ClusterFuture ...
[17:39:38.370] - result already collected: FutureResult
[17:39:38.370] result() for ClusterFuture ... done
[17:39:38.370] result() for ClusterFuture ...
[17:39:38.370] - result already collected: FutureResult
[17:39:38.370] result() for ClusterFuture ... done
[17:39:38.370] result() for ClusterFuture ...
[17:39:38.370] - result already collected: FutureResult
[17:39:38.370] result() for ClusterFuture ... done
[17:39:38.371] result() for ClusterFuture ...
[17:39:38.371] - result already collected: FutureResult
[17:39:38.371] result() for ClusterFuture ... done
[17:39:38.371] result() for ClusterFuture ...
[17:39:38.371] - result already collected: FutureResult
[17:39:38.371] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf0c7a948> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:39:38.373] getGlobalsAndPackages() ...
[17:39:38.373] Searching for globals...
[17:39:38.373] 
[17:39:38.373] Searching for globals ... DONE
[17:39:38.374] - globals: [0] <none>
[17:39:38.374] getGlobalsAndPackages() ... DONE
[17:39:38.374] run() for ‘Future’ ...
[17:39:38.374] - state: ‘created’
[17:39:38.374] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.390]   - Field: ‘node’
[17:39:38.390]   - Field: ‘label’
[17:39:38.390]   - Field: ‘local’
[17:39:38.390]   - Field: ‘owner’
[17:39:38.390]   - Field: ‘envir’
[17:39:38.390]   - Field: ‘workers’
[17:39:38.390]   - Field: ‘packages’
[17:39:38.390]   - Field: ‘gc’
[17:39:38.390]   - Field: ‘conditions’
[17:39:38.391]   - Field: ‘persistent’
[17:39:38.391]   - Field: ‘expr’
[17:39:38.391]   - Field: ‘uuid’
[17:39:38.391]   - Field: ‘seed’
[17:39:38.391]   - Field: ‘version’
[17:39:38.391]   - Field: ‘result’
[17:39:38.391]   - Field: ‘asynchronous’
[17:39:38.391]   - Field: ‘calls’
[17:39:38.391]   - Field: ‘globals’
[17:39:38.391]   - Field: ‘stdout’
[17:39:38.391]   - Field: ‘earlySignal’
[17:39:38.392]   - Field: ‘lazy’
[17:39:38.392]   - Field: ‘state’
[17:39:38.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.392] - Launch lazy future ...
[17:39:38.392] Packages needed by the future expression (n = 0): <none>
[17:39:38.392] Packages needed by future strategies (n = 0): <none>
[17:39:38.393] {
[17:39:38.393]     {
[17:39:38.393]         {
[17:39:38.393]             ...future.startTime <- base::Sys.time()
[17:39:38.393]             {
[17:39:38.393]                 {
[17:39:38.393]                   {
[17:39:38.393]                     {
[17:39:38.393]                       base::local({
[17:39:38.393]                         has_future <- base::requireNamespace("future", 
[17:39:38.393]                           quietly = TRUE)
[17:39:38.393]                         if (has_future) {
[17:39:38.393]                           ns <- base::getNamespace("future")
[17:39:38.393]                           version <- ns[[".package"]][["version"]]
[17:39:38.393]                           if (is.null(version)) 
[17:39:38.393]                             version <- utils::packageVersion("future")
[17:39:38.393]                         }
[17:39:38.393]                         else {
[17:39:38.393]                           version <- NULL
[17:39:38.393]                         }
[17:39:38.393]                         if (!has_future || version < "1.8.0") {
[17:39:38.393]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.393]                             "", base::R.version$version.string), 
[17:39:38.393]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.393]                               "release", "version")], collapse = " "), 
[17:39:38.393]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.393]                             info)
[17:39:38.393]                           info <- base::paste(info, collapse = "; ")
[17:39:38.393]                           if (!has_future) {
[17:39:38.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.393]                               info)
[17:39:38.393]                           }
[17:39:38.393]                           else {
[17:39:38.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.393]                               info, version)
[17:39:38.393]                           }
[17:39:38.393]                           base::stop(msg)
[17:39:38.393]                         }
[17:39:38.393]                       })
[17:39:38.393]                     }
[17:39:38.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.393]                     base::options(mc.cores = 1L)
[17:39:38.393]                   }
[17:39:38.393]                   ...future.strategy.old <- future::plan("list")
[17:39:38.393]                   options(future.plan = NULL)
[17:39:38.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.393]                 }
[17:39:38.393]                 ...future.workdir <- getwd()
[17:39:38.393]             }
[17:39:38.393]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.393]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.393]         }
[17:39:38.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.393]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.393]             base::names(...future.oldOptions))
[17:39:38.393]     }
[17:39:38.393]     if (FALSE) {
[17:39:38.393]     }
[17:39:38.393]     else {
[17:39:38.393]         if (TRUE) {
[17:39:38.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.393]                 open = "w")
[17:39:38.393]         }
[17:39:38.393]         else {
[17:39:38.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.393]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.393]         }
[17:39:38.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.393]             base::sink(type = "output", split = FALSE)
[17:39:38.393]             base::close(...future.stdout)
[17:39:38.393]         }, add = TRUE)
[17:39:38.393]     }
[17:39:38.393]     ...future.frame <- base::sys.nframe()
[17:39:38.393]     ...future.conditions <- base::list()
[17:39:38.393]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.393]     if (FALSE) {
[17:39:38.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.393]     }
[17:39:38.393]     ...future.result <- base::tryCatch({
[17:39:38.393]         base::withCallingHandlers({
[17:39:38.393]             ...future.value <- base::withVisible(base::local({
[17:39:38.393]                 ...future.makeSendCondition <- base::local({
[17:39:38.393]                   sendCondition <- NULL
[17:39:38.393]                   function(frame = 1L) {
[17:39:38.393]                     if (is.function(sendCondition)) 
[17:39:38.393]                       return(sendCondition)
[17:39:38.393]                     ns <- getNamespace("parallel")
[17:39:38.393]                     if (exists("sendData", mode = "function", 
[17:39:38.393]                       envir = ns)) {
[17:39:38.393]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.393]                         envir = ns)
[17:39:38.393]                       envir <- sys.frame(frame)
[17:39:38.393]                       master <- NULL
[17:39:38.393]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.393]                         !identical(envir, emptyenv())) {
[17:39:38.393]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.393]                           inherits = FALSE)) {
[17:39:38.393]                           master <- get("master", mode = "list", 
[17:39:38.393]                             envir = envir, inherits = FALSE)
[17:39:38.393]                           if (inherits(master, c("SOCKnode", 
[17:39:38.393]                             "SOCK0node"))) {
[17:39:38.393]                             sendCondition <<- function(cond) {
[17:39:38.393]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.393]                                 success = TRUE)
[17:39:38.393]                               parallel_sendData(master, data)
[17:39:38.393]                             }
[17:39:38.393]                             return(sendCondition)
[17:39:38.393]                           }
[17:39:38.393]                         }
[17:39:38.393]                         frame <- frame + 1L
[17:39:38.393]                         envir <- sys.frame(frame)
[17:39:38.393]                       }
[17:39:38.393]                     }
[17:39:38.393]                     sendCondition <<- function(cond) NULL
[17:39:38.393]                   }
[17:39:38.393]                 })
[17:39:38.393]                 withCallingHandlers({
[17:39:38.393]                   2
[17:39:38.393]                 }, immediateCondition = function(cond) {
[17:39:38.393]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.393]                   sendCondition(cond)
[17:39:38.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.393]                   {
[17:39:38.393]                     inherits <- base::inherits
[17:39:38.393]                     invokeRestart <- base::invokeRestart
[17:39:38.393]                     is.null <- base::is.null
[17:39:38.393]                     muffled <- FALSE
[17:39:38.393]                     if (inherits(cond, "message")) {
[17:39:38.393]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.393]                       if (muffled) 
[17:39:38.393]                         invokeRestart("muffleMessage")
[17:39:38.393]                     }
[17:39:38.393]                     else if (inherits(cond, "warning")) {
[17:39:38.393]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.393]                       if (muffled) 
[17:39:38.393]                         invokeRestart("muffleWarning")
[17:39:38.393]                     }
[17:39:38.393]                     else if (inherits(cond, "condition")) {
[17:39:38.393]                       if (!is.null(pattern)) {
[17:39:38.393]                         computeRestarts <- base::computeRestarts
[17:39:38.393]                         grepl <- base::grepl
[17:39:38.393]                         restarts <- computeRestarts(cond)
[17:39:38.393]                         for (restart in restarts) {
[17:39:38.393]                           name <- restart$name
[17:39:38.393]                           if (is.null(name)) 
[17:39:38.393]                             next
[17:39:38.393]                           if (!grepl(pattern, name)) 
[17:39:38.393]                             next
[17:39:38.393]                           invokeRestart(restart)
[17:39:38.393]                           muffled <- TRUE
[17:39:38.393]                           break
[17:39:38.393]                         }
[17:39:38.393]                       }
[17:39:38.393]                     }
[17:39:38.393]                     invisible(muffled)
[17:39:38.393]                   }
[17:39:38.393]                   muffleCondition(cond)
[17:39:38.393]                 })
[17:39:38.393]             }))
[17:39:38.393]             future::FutureResult(value = ...future.value$value, 
[17:39:38.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.393]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.393]                     ...future.globalenv.names))
[17:39:38.393]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.393]         }, condition = base::local({
[17:39:38.393]             c <- base::c
[17:39:38.393]             inherits <- base::inherits
[17:39:38.393]             invokeRestart <- base::invokeRestart
[17:39:38.393]             length <- base::length
[17:39:38.393]             list <- base::list
[17:39:38.393]             seq.int <- base::seq.int
[17:39:38.393]             signalCondition <- base::signalCondition
[17:39:38.393]             sys.calls <- base::sys.calls
[17:39:38.393]             `[[` <- base::`[[`
[17:39:38.393]             `+` <- base::`+`
[17:39:38.393]             `<<-` <- base::`<<-`
[17:39:38.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.393]                   3L)]
[17:39:38.393]             }
[17:39:38.393]             function(cond) {
[17:39:38.393]                 is_error <- inherits(cond, "error")
[17:39:38.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.393]                   NULL)
[17:39:38.393]                 if (is_error) {
[17:39:38.393]                   sessionInformation <- function() {
[17:39:38.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.393]                       search = base::search(), system = base::Sys.info())
[17:39:38.393]                   }
[17:39:38.393]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.393]                     cond$call), session = sessionInformation(), 
[17:39:38.393]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.393]                   signalCondition(cond)
[17:39:38.393]                 }
[17:39:38.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.393]                 "immediateCondition"))) {
[17:39:38.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.393]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.393]                   if (TRUE && !signal) {
[17:39:38.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.393]                     {
[17:39:38.393]                       inherits <- base::inherits
[17:39:38.393]                       invokeRestart <- base::invokeRestart
[17:39:38.393]                       is.null <- base::is.null
[17:39:38.393]                       muffled <- FALSE
[17:39:38.393]                       if (inherits(cond, "message")) {
[17:39:38.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.393]                         if (muffled) 
[17:39:38.393]                           invokeRestart("muffleMessage")
[17:39:38.393]                       }
[17:39:38.393]                       else if (inherits(cond, "warning")) {
[17:39:38.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.393]                         if (muffled) 
[17:39:38.393]                           invokeRestart("muffleWarning")
[17:39:38.393]                       }
[17:39:38.393]                       else if (inherits(cond, "condition")) {
[17:39:38.393]                         if (!is.null(pattern)) {
[17:39:38.393]                           computeRestarts <- base::computeRestarts
[17:39:38.393]                           grepl <- base::grepl
[17:39:38.393]                           restarts <- computeRestarts(cond)
[17:39:38.393]                           for (restart in restarts) {
[17:39:38.393]                             name <- restart$name
[17:39:38.393]                             if (is.null(name)) 
[17:39:38.393]                               next
[17:39:38.393]                             if (!grepl(pattern, name)) 
[17:39:38.393]                               next
[17:39:38.393]                             invokeRestart(restart)
[17:39:38.393]                             muffled <- TRUE
[17:39:38.393]                             break
[17:39:38.393]                           }
[17:39:38.393]                         }
[17:39:38.393]                       }
[17:39:38.393]                       invisible(muffled)
[17:39:38.393]                     }
[17:39:38.393]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.393]                   }
[17:39:38.393]                 }
[17:39:38.393]                 else {
[17:39:38.393]                   if (TRUE) {
[17:39:38.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.393]                     {
[17:39:38.393]                       inherits <- base::inherits
[17:39:38.393]                       invokeRestart <- base::invokeRestart
[17:39:38.393]                       is.null <- base::is.null
[17:39:38.393]                       muffled <- FALSE
[17:39:38.393]                       if (inherits(cond, "message")) {
[17:39:38.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.393]                         if (muffled) 
[17:39:38.393]                           invokeRestart("muffleMessage")
[17:39:38.393]                       }
[17:39:38.393]                       else if (inherits(cond, "warning")) {
[17:39:38.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.393]                         if (muffled) 
[17:39:38.393]                           invokeRestart("muffleWarning")
[17:39:38.393]                       }
[17:39:38.393]                       else if (inherits(cond, "condition")) {
[17:39:38.393]                         if (!is.null(pattern)) {
[17:39:38.393]                           computeRestarts <- base::computeRestarts
[17:39:38.393]                           grepl <- base::grepl
[17:39:38.393]                           restarts <- computeRestarts(cond)
[17:39:38.393]                           for (restart in restarts) {
[17:39:38.393]                             name <- restart$name
[17:39:38.393]                             if (is.null(name)) 
[17:39:38.393]                               next
[17:39:38.393]                             if (!grepl(pattern, name)) 
[17:39:38.393]                               next
[17:39:38.393]                             invokeRestart(restart)
[17:39:38.393]                             muffled <- TRUE
[17:39:38.393]                             break
[17:39:38.393]                           }
[17:39:38.393]                         }
[17:39:38.393]                       }
[17:39:38.393]                       invisible(muffled)
[17:39:38.393]                     }
[17:39:38.393]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.393]                   }
[17:39:38.393]                 }
[17:39:38.393]             }
[17:39:38.393]         }))
[17:39:38.393]     }, error = function(ex) {
[17:39:38.393]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.393]                 ...future.rng), started = ...future.startTime, 
[17:39:38.393]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.393]             version = "1.8"), class = "FutureResult")
[17:39:38.393]     }, finally = {
[17:39:38.393]         if (!identical(...future.workdir, getwd())) 
[17:39:38.393]             setwd(...future.workdir)
[17:39:38.393]         {
[17:39:38.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.393]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.393]             }
[17:39:38.393]             base::options(...future.oldOptions)
[17:39:38.393]             if (.Platform$OS.type == "windows") {
[17:39:38.393]                 old_names <- names(...future.oldEnvVars)
[17:39:38.393]                 envs <- base::Sys.getenv()
[17:39:38.393]                 names <- names(envs)
[17:39:38.393]                 common <- intersect(names, old_names)
[17:39:38.393]                 added <- setdiff(names, old_names)
[17:39:38.393]                 removed <- setdiff(old_names, names)
[17:39:38.393]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.393]                   envs[common]]
[17:39:38.393]                 NAMES <- toupper(changed)
[17:39:38.393]                 args <- list()
[17:39:38.393]                 for (kk in seq_along(NAMES)) {
[17:39:38.393]                   name <- changed[[kk]]
[17:39:38.393]                   NAME <- NAMES[[kk]]
[17:39:38.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.393]                     next
[17:39:38.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.393]                 }
[17:39:38.393]                 NAMES <- toupper(added)
[17:39:38.393]                 for (kk in seq_along(NAMES)) {
[17:39:38.393]                   name <- added[[kk]]
[17:39:38.393]                   NAME <- NAMES[[kk]]
[17:39:38.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.393]                     next
[17:39:38.393]                   args[[name]] <- ""
[17:39:38.393]                 }
[17:39:38.393]                 NAMES <- toupper(removed)
[17:39:38.393]                 for (kk in seq_along(NAMES)) {
[17:39:38.393]                   name <- removed[[kk]]
[17:39:38.393]                   NAME <- NAMES[[kk]]
[17:39:38.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.393]                     next
[17:39:38.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.393]                 }
[17:39:38.393]                 if (length(args) > 0) 
[17:39:38.393]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.393]             }
[17:39:38.393]             else {
[17:39:38.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.393]             }
[17:39:38.393]             {
[17:39:38.393]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.393]                   0L) {
[17:39:38.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.393]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.393]                   base::options(opts)
[17:39:38.393]                 }
[17:39:38.393]                 {
[17:39:38.393]                   {
[17:39:38.393]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.393]                     NULL
[17:39:38.393]                   }
[17:39:38.393]                   options(future.plan = NULL)
[17:39:38.393]                   if (is.na(NA_character_)) 
[17:39:38.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.393]                     .init = FALSE)
[17:39:38.393]                 }
[17:39:38.393]             }
[17:39:38.393]         }
[17:39:38.393]     })
[17:39:38.393]     if (TRUE) {
[17:39:38.393]         base::sink(type = "output", split = FALSE)
[17:39:38.393]         if (TRUE) {
[17:39:38.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.393]         }
[17:39:38.393]         else {
[17:39:38.393]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.393]         }
[17:39:38.393]         base::close(...future.stdout)
[17:39:38.393]         ...future.stdout <- NULL
[17:39:38.393]     }
[17:39:38.393]     ...future.result$conditions <- ...future.conditions
[17:39:38.393]     ...future.result$finished <- base::Sys.time()
[17:39:38.393]     ...future.result
[17:39:38.393] }
[17:39:38.396] MultisessionFuture started
[17:39:38.396] - Launch lazy future ... done
[17:39:38.396] run() for ‘MultisessionFuture’ ... done
[17:39:38.396] getGlobalsAndPackages() ...
[17:39:38.397] Searching for globals...
[17:39:38.397] 
[17:39:38.397] Searching for globals ... DONE
[17:39:38.397] - globals: [0] <none>
[17:39:38.398] getGlobalsAndPackages() ... DONE
[17:39:38.398] run() for ‘Future’ ...
[17:39:38.398] - state: ‘created’
[17:39:38.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.412]   - Field: ‘node’
[17:39:38.412]   - Field: ‘label’
[17:39:38.412]   - Field: ‘local’
[17:39:38.412]   - Field: ‘owner’
[17:39:38.412]   - Field: ‘envir’
[17:39:38.413]   - Field: ‘workers’
[17:39:38.413]   - Field: ‘packages’
[17:39:38.413]   - Field: ‘gc’
[17:39:38.413]   - Field: ‘conditions’
[17:39:38.413]   - Field: ‘persistent’
[17:39:38.413]   - Field: ‘expr’
[17:39:38.413]   - Field: ‘uuid’
[17:39:38.413]   - Field: ‘seed’
[17:39:38.413]   - Field: ‘version’
[17:39:38.413]   - Field: ‘result’
[17:39:38.413]   - Field: ‘asynchronous’
[17:39:38.414]   - Field: ‘calls’
[17:39:38.414]   - Field: ‘globals’
[17:39:38.414]   - Field: ‘stdout’
[17:39:38.414]   - Field: ‘earlySignal’
[17:39:38.414]   - Field: ‘lazy’
[17:39:38.414]   - Field: ‘state’
[17:39:38.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.414] - Launch lazy future ...
[17:39:38.414] Packages needed by the future expression (n = 0): <none>
[17:39:38.415] Packages needed by future strategies (n = 0): <none>
[17:39:38.415] {
[17:39:38.415]     {
[17:39:38.415]         {
[17:39:38.415]             ...future.startTime <- base::Sys.time()
[17:39:38.415]             {
[17:39:38.415]                 {
[17:39:38.415]                   {
[17:39:38.415]                     {
[17:39:38.415]                       base::local({
[17:39:38.415]                         has_future <- base::requireNamespace("future", 
[17:39:38.415]                           quietly = TRUE)
[17:39:38.415]                         if (has_future) {
[17:39:38.415]                           ns <- base::getNamespace("future")
[17:39:38.415]                           version <- ns[[".package"]][["version"]]
[17:39:38.415]                           if (is.null(version)) 
[17:39:38.415]                             version <- utils::packageVersion("future")
[17:39:38.415]                         }
[17:39:38.415]                         else {
[17:39:38.415]                           version <- NULL
[17:39:38.415]                         }
[17:39:38.415]                         if (!has_future || version < "1.8.0") {
[17:39:38.415]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.415]                             "", base::R.version$version.string), 
[17:39:38.415]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.415]                               "release", "version")], collapse = " "), 
[17:39:38.415]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.415]                             info)
[17:39:38.415]                           info <- base::paste(info, collapse = "; ")
[17:39:38.415]                           if (!has_future) {
[17:39:38.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.415]                               info)
[17:39:38.415]                           }
[17:39:38.415]                           else {
[17:39:38.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.415]                               info, version)
[17:39:38.415]                           }
[17:39:38.415]                           base::stop(msg)
[17:39:38.415]                         }
[17:39:38.415]                       })
[17:39:38.415]                     }
[17:39:38.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.415]                     base::options(mc.cores = 1L)
[17:39:38.415]                   }
[17:39:38.415]                   ...future.strategy.old <- future::plan("list")
[17:39:38.415]                   options(future.plan = NULL)
[17:39:38.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.415]                 }
[17:39:38.415]                 ...future.workdir <- getwd()
[17:39:38.415]             }
[17:39:38.415]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.415]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.415]         }
[17:39:38.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.415]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.415]             base::names(...future.oldOptions))
[17:39:38.415]     }
[17:39:38.415]     if (FALSE) {
[17:39:38.415]     }
[17:39:38.415]     else {
[17:39:38.415]         if (TRUE) {
[17:39:38.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.415]                 open = "w")
[17:39:38.415]         }
[17:39:38.415]         else {
[17:39:38.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.415]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.415]         }
[17:39:38.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.415]             base::sink(type = "output", split = FALSE)
[17:39:38.415]             base::close(...future.stdout)
[17:39:38.415]         }, add = TRUE)
[17:39:38.415]     }
[17:39:38.415]     ...future.frame <- base::sys.nframe()
[17:39:38.415]     ...future.conditions <- base::list()
[17:39:38.415]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.415]     if (FALSE) {
[17:39:38.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.415]     }
[17:39:38.415]     ...future.result <- base::tryCatch({
[17:39:38.415]         base::withCallingHandlers({
[17:39:38.415]             ...future.value <- base::withVisible(base::local({
[17:39:38.415]                 ...future.makeSendCondition <- base::local({
[17:39:38.415]                   sendCondition <- NULL
[17:39:38.415]                   function(frame = 1L) {
[17:39:38.415]                     if (is.function(sendCondition)) 
[17:39:38.415]                       return(sendCondition)
[17:39:38.415]                     ns <- getNamespace("parallel")
[17:39:38.415]                     if (exists("sendData", mode = "function", 
[17:39:38.415]                       envir = ns)) {
[17:39:38.415]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.415]                         envir = ns)
[17:39:38.415]                       envir <- sys.frame(frame)
[17:39:38.415]                       master <- NULL
[17:39:38.415]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.415]                         !identical(envir, emptyenv())) {
[17:39:38.415]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.415]                           inherits = FALSE)) {
[17:39:38.415]                           master <- get("master", mode = "list", 
[17:39:38.415]                             envir = envir, inherits = FALSE)
[17:39:38.415]                           if (inherits(master, c("SOCKnode", 
[17:39:38.415]                             "SOCK0node"))) {
[17:39:38.415]                             sendCondition <<- function(cond) {
[17:39:38.415]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.415]                                 success = TRUE)
[17:39:38.415]                               parallel_sendData(master, data)
[17:39:38.415]                             }
[17:39:38.415]                             return(sendCondition)
[17:39:38.415]                           }
[17:39:38.415]                         }
[17:39:38.415]                         frame <- frame + 1L
[17:39:38.415]                         envir <- sys.frame(frame)
[17:39:38.415]                       }
[17:39:38.415]                     }
[17:39:38.415]                     sendCondition <<- function(cond) NULL
[17:39:38.415]                   }
[17:39:38.415]                 })
[17:39:38.415]                 withCallingHandlers({
[17:39:38.415]                   NULL
[17:39:38.415]                 }, immediateCondition = function(cond) {
[17:39:38.415]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.415]                   sendCondition(cond)
[17:39:38.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.415]                   {
[17:39:38.415]                     inherits <- base::inherits
[17:39:38.415]                     invokeRestart <- base::invokeRestart
[17:39:38.415]                     is.null <- base::is.null
[17:39:38.415]                     muffled <- FALSE
[17:39:38.415]                     if (inherits(cond, "message")) {
[17:39:38.415]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.415]                       if (muffled) 
[17:39:38.415]                         invokeRestart("muffleMessage")
[17:39:38.415]                     }
[17:39:38.415]                     else if (inherits(cond, "warning")) {
[17:39:38.415]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.415]                       if (muffled) 
[17:39:38.415]                         invokeRestart("muffleWarning")
[17:39:38.415]                     }
[17:39:38.415]                     else if (inherits(cond, "condition")) {
[17:39:38.415]                       if (!is.null(pattern)) {
[17:39:38.415]                         computeRestarts <- base::computeRestarts
[17:39:38.415]                         grepl <- base::grepl
[17:39:38.415]                         restarts <- computeRestarts(cond)
[17:39:38.415]                         for (restart in restarts) {
[17:39:38.415]                           name <- restart$name
[17:39:38.415]                           if (is.null(name)) 
[17:39:38.415]                             next
[17:39:38.415]                           if (!grepl(pattern, name)) 
[17:39:38.415]                             next
[17:39:38.415]                           invokeRestart(restart)
[17:39:38.415]                           muffled <- TRUE
[17:39:38.415]                           break
[17:39:38.415]                         }
[17:39:38.415]                       }
[17:39:38.415]                     }
[17:39:38.415]                     invisible(muffled)
[17:39:38.415]                   }
[17:39:38.415]                   muffleCondition(cond)
[17:39:38.415]                 })
[17:39:38.415]             }))
[17:39:38.415]             future::FutureResult(value = ...future.value$value, 
[17:39:38.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.415]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.415]                     ...future.globalenv.names))
[17:39:38.415]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.415]         }, condition = base::local({
[17:39:38.415]             c <- base::c
[17:39:38.415]             inherits <- base::inherits
[17:39:38.415]             invokeRestart <- base::invokeRestart
[17:39:38.415]             length <- base::length
[17:39:38.415]             list <- base::list
[17:39:38.415]             seq.int <- base::seq.int
[17:39:38.415]             signalCondition <- base::signalCondition
[17:39:38.415]             sys.calls <- base::sys.calls
[17:39:38.415]             `[[` <- base::`[[`
[17:39:38.415]             `+` <- base::`+`
[17:39:38.415]             `<<-` <- base::`<<-`
[17:39:38.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.415]                   3L)]
[17:39:38.415]             }
[17:39:38.415]             function(cond) {
[17:39:38.415]                 is_error <- inherits(cond, "error")
[17:39:38.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.415]                   NULL)
[17:39:38.415]                 if (is_error) {
[17:39:38.415]                   sessionInformation <- function() {
[17:39:38.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.415]                       search = base::search(), system = base::Sys.info())
[17:39:38.415]                   }
[17:39:38.415]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.415]                     cond$call), session = sessionInformation(), 
[17:39:38.415]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.415]                   signalCondition(cond)
[17:39:38.415]                 }
[17:39:38.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.415]                 "immediateCondition"))) {
[17:39:38.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.415]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.415]                   if (TRUE && !signal) {
[17:39:38.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.415]                     {
[17:39:38.415]                       inherits <- base::inherits
[17:39:38.415]                       invokeRestart <- base::invokeRestart
[17:39:38.415]                       is.null <- base::is.null
[17:39:38.415]                       muffled <- FALSE
[17:39:38.415]                       if (inherits(cond, "message")) {
[17:39:38.415]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.415]                         if (muffled) 
[17:39:38.415]                           invokeRestart("muffleMessage")
[17:39:38.415]                       }
[17:39:38.415]                       else if (inherits(cond, "warning")) {
[17:39:38.415]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.415]                         if (muffled) 
[17:39:38.415]                           invokeRestart("muffleWarning")
[17:39:38.415]                       }
[17:39:38.415]                       else if (inherits(cond, "condition")) {
[17:39:38.415]                         if (!is.null(pattern)) {
[17:39:38.415]                           computeRestarts <- base::computeRestarts
[17:39:38.415]                           grepl <- base::grepl
[17:39:38.415]                           restarts <- computeRestarts(cond)
[17:39:38.415]                           for (restart in restarts) {
[17:39:38.415]                             name <- restart$name
[17:39:38.415]                             if (is.null(name)) 
[17:39:38.415]                               next
[17:39:38.415]                             if (!grepl(pattern, name)) 
[17:39:38.415]                               next
[17:39:38.415]                             invokeRestart(restart)
[17:39:38.415]                             muffled <- TRUE
[17:39:38.415]                             break
[17:39:38.415]                           }
[17:39:38.415]                         }
[17:39:38.415]                       }
[17:39:38.415]                       invisible(muffled)
[17:39:38.415]                     }
[17:39:38.415]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.415]                   }
[17:39:38.415]                 }
[17:39:38.415]                 else {
[17:39:38.415]                   if (TRUE) {
[17:39:38.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.415]                     {
[17:39:38.415]                       inherits <- base::inherits
[17:39:38.415]                       invokeRestart <- base::invokeRestart
[17:39:38.415]                       is.null <- base::is.null
[17:39:38.415]                       muffled <- FALSE
[17:39:38.415]                       if (inherits(cond, "message")) {
[17:39:38.415]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.415]                         if (muffled) 
[17:39:38.415]                           invokeRestart("muffleMessage")
[17:39:38.415]                       }
[17:39:38.415]                       else if (inherits(cond, "warning")) {
[17:39:38.415]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.415]                         if (muffled) 
[17:39:38.415]                           invokeRestart("muffleWarning")
[17:39:38.415]                       }
[17:39:38.415]                       else if (inherits(cond, "condition")) {
[17:39:38.415]                         if (!is.null(pattern)) {
[17:39:38.415]                           computeRestarts <- base::computeRestarts
[17:39:38.415]                           grepl <- base::grepl
[17:39:38.415]                           restarts <- computeRestarts(cond)
[17:39:38.415]                           for (restart in restarts) {
[17:39:38.415]                             name <- restart$name
[17:39:38.415]                             if (is.null(name)) 
[17:39:38.415]                               next
[17:39:38.415]                             if (!grepl(pattern, name)) 
[17:39:38.415]                               next
[17:39:38.415]                             invokeRestart(restart)
[17:39:38.415]                             muffled <- TRUE
[17:39:38.415]                             break
[17:39:38.415]                           }
[17:39:38.415]                         }
[17:39:38.415]                       }
[17:39:38.415]                       invisible(muffled)
[17:39:38.415]                     }
[17:39:38.415]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.415]                   }
[17:39:38.415]                 }
[17:39:38.415]             }
[17:39:38.415]         }))
[17:39:38.415]     }, error = function(ex) {
[17:39:38.415]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.415]                 ...future.rng), started = ...future.startTime, 
[17:39:38.415]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.415]             version = "1.8"), class = "FutureResult")
[17:39:38.415]     }, finally = {
[17:39:38.415]         if (!identical(...future.workdir, getwd())) 
[17:39:38.415]             setwd(...future.workdir)
[17:39:38.415]         {
[17:39:38.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.415]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.415]             }
[17:39:38.415]             base::options(...future.oldOptions)
[17:39:38.415]             if (.Platform$OS.type == "windows") {
[17:39:38.415]                 old_names <- names(...future.oldEnvVars)
[17:39:38.415]                 envs <- base::Sys.getenv()
[17:39:38.415]                 names <- names(envs)
[17:39:38.415]                 common <- intersect(names, old_names)
[17:39:38.415]                 added <- setdiff(names, old_names)
[17:39:38.415]                 removed <- setdiff(old_names, names)
[17:39:38.415]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.415]                   envs[common]]
[17:39:38.415]                 NAMES <- toupper(changed)
[17:39:38.415]                 args <- list()
[17:39:38.415]                 for (kk in seq_along(NAMES)) {
[17:39:38.415]                   name <- changed[[kk]]
[17:39:38.415]                   NAME <- NAMES[[kk]]
[17:39:38.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.415]                     next
[17:39:38.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.415]                 }
[17:39:38.415]                 NAMES <- toupper(added)
[17:39:38.415]                 for (kk in seq_along(NAMES)) {
[17:39:38.415]                   name <- added[[kk]]
[17:39:38.415]                   NAME <- NAMES[[kk]]
[17:39:38.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.415]                     next
[17:39:38.415]                   args[[name]] <- ""
[17:39:38.415]                 }
[17:39:38.415]                 NAMES <- toupper(removed)
[17:39:38.415]                 for (kk in seq_along(NAMES)) {
[17:39:38.415]                   name <- removed[[kk]]
[17:39:38.415]                   NAME <- NAMES[[kk]]
[17:39:38.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.415]                     next
[17:39:38.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.415]                 }
[17:39:38.415]                 if (length(args) > 0) 
[17:39:38.415]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.415]             }
[17:39:38.415]             else {
[17:39:38.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.415]             }
[17:39:38.415]             {
[17:39:38.415]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.415]                   0L) {
[17:39:38.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.415]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.415]                   base::options(opts)
[17:39:38.415]                 }
[17:39:38.415]                 {
[17:39:38.415]                   {
[17:39:38.415]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.415]                     NULL
[17:39:38.415]                   }
[17:39:38.415]                   options(future.plan = NULL)
[17:39:38.415]                   if (is.na(NA_character_)) 
[17:39:38.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.415]                     .init = FALSE)
[17:39:38.415]                 }
[17:39:38.415]             }
[17:39:38.415]         }
[17:39:38.415]     })
[17:39:38.415]     if (TRUE) {
[17:39:38.415]         base::sink(type = "output", split = FALSE)
[17:39:38.415]         if (TRUE) {
[17:39:38.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.415]         }
[17:39:38.415]         else {
[17:39:38.415]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.415]         }
[17:39:38.415]         base::close(...future.stdout)
[17:39:38.415]         ...future.stdout <- NULL
[17:39:38.415]     }
[17:39:38.415]     ...future.result$conditions <- ...future.conditions
[17:39:38.415]     ...future.result$finished <- base::Sys.time()
[17:39:38.415]     ...future.result
[17:39:38.415] }
[17:39:38.418] MultisessionFuture started
[17:39:38.418] - Launch lazy future ... done
[17:39:38.418] run() for ‘MultisessionFuture’ ... done
[17:39:38.418] getGlobalsAndPackages() ...
[17:39:38.419] Searching for globals...
[17:39:38.419] - globals found: [1] ‘{’
[17:39:38.419] Searching for globals ... DONE
[17:39:38.419] Resolving globals: FALSE
[17:39:38.420] 
[17:39:38.420] 
[17:39:38.420] getGlobalsAndPackages() ... DONE
[17:39:38.420] run() for ‘Future’ ...
[17:39:38.420] - state: ‘created’
[17:39:38.420] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.435]   - Field: ‘node’
[17:39:38.435]   - Field: ‘label’
[17:39:38.435]   - Field: ‘local’
[17:39:38.435]   - Field: ‘owner’
[17:39:38.435]   - Field: ‘envir’
[17:39:38.435]   - Field: ‘workers’
[17:39:38.435]   - Field: ‘packages’
[17:39:38.435]   - Field: ‘gc’
[17:39:38.435]   - Field: ‘conditions’
[17:39:38.435]   - Field: ‘persistent’
[17:39:38.435]   - Field: ‘expr’
[17:39:38.436]   - Field: ‘uuid’
[17:39:38.436]   - Field: ‘seed’
[17:39:38.436]   - Field: ‘version’
[17:39:38.436]   - Field: ‘result’
[17:39:38.436]   - Field: ‘asynchronous’
[17:39:38.436]   - Field: ‘calls’
[17:39:38.436]   - Field: ‘globals’
[17:39:38.436]   - Field: ‘stdout’
[17:39:38.436]   - Field: ‘earlySignal’
[17:39:38.436]   - Field: ‘lazy’
[17:39:38.437]   - Field: ‘state’
[17:39:38.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.437] - Launch lazy future ...
[17:39:38.437] Packages needed by the future expression (n = 0): <none>
[17:39:38.437] Packages needed by future strategies (n = 0): <none>
[17:39:38.438] {
[17:39:38.438]     {
[17:39:38.438]         {
[17:39:38.438]             ...future.startTime <- base::Sys.time()
[17:39:38.438]             {
[17:39:38.438]                 {
[17:39:38.438]                   {
[17:39:38.438]                     {
[17:39:38.438]                       base::local({
[17:39:38.438]                         has_future <- base::requireNamespace("future", 
[17:39:38.438]                           quietly = TRUE)
[17:39:38.438]                         if (has_future) {
[17:39:38.438]                           ns <- base::getNamespace("future")
[17:39:38.438]                           version <- ns[[".package"]][["version"]]
[17:39:38.438]                           if (is.null(version)) 
[17:39:38.438]                             version <- utils::packageVersion("future")
[17:39:38.438]                         }
[17:39:38.438]                         else {
[17:39:38.438]                           version <- NULL
[17:39:38.438]                         }
[17:39:38.438]                         if (!has_future || version < "1.8.0") {
[17:39:38.438]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.438]                             "", base::R.version$version.string), 
[17:39:38.438]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.438]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.438]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.438]                               "release", "version")], collapse = " "), 
[17:39:38.438]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.438]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.438]                             info)
[17:39:38.438]                           info <- base::paste(info, collapse = "; ")
[17:39:38.438]                           if (!has_future) {
[17:39:38.438]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.438]                               info)
[17:39:38.438]                           }
[17:39:38.438]                           else {
[17:39:38.438]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.438]                               info, version)
[17:39:38.438]                           }
[17:39:38.438]                           base::stop(msg)
[17:39:38.438]                         }
[17:39:38.438]                       })
[17:39:38.438]                     }
[17:39:38.438]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.438]                     base::options(mc.cores = 1L)
[17:39:38.438]                   }
[17:39:38.438]                   ...future.strategy.old <- future::plan("list")
[17:39:38.438]                   options(future.plan = NULL)
[17:39:38.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.438]                 }
[17:39:38.438]                 ...future.workdir <- getwd()
[17:39:38.438]             }
[17:39:38.438]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.438]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.438]         }
[17:39:38.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.438]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.438]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.438]             base::names(...future.oldOptions))
[17:39:38.438]     }
[17:39:38.438]     if (FALSE) {
[17:39:38.438]     }
[17:39:38.438]     else {
[17:39:38.438]         if (TRUE) {
[17:39:38.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.438]                 open = "w")
[17:39:38.438]         }
[17:39:38.438]         else {
[17:39:38.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.438]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.438]         }
[17:39:38.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.438]             base::sink(type = "output", split = FALSE)
[17:39:38.438]             base::close(...future.stdout)
[17:39:38.438]         }, add = TRUE)
[17:39:38.438]     }
[17:39:38.438]     ...future.frame <- base::sys.nframe()
[17:39:38.438]     ...future.conditions <- base::list()
[17:39:38.438]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.438]     if (FALSE) {
[17:39:38.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.438]     }
[17:39:38.438]     ...future.result <- base::tryCatch({
[17:39:38.438]         base::withCallingHandlers({
[17:39:38.438]             ...future.value <- base::withVisible(base::local({
[17:39:38.438]                 ...future.makeSendCondition <- base::local({
[17:39:38.438]                   sendCondition <- NULL
[17:39:38.438]                   function(frame = 1L) {
[17:39:38.438]                     if (is.function(sendCondition)) 
[17:39:38.438]                       return(sendCondition)
[17:39:38.438]                     ns <- getNamespace("parallel")
[17:39:38.438]                     if (exists("sendData", mode = "function", 
[17:39:38.438]                       envir = ns)) {
[17:39:38.438]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.438]                         envir = ns)
[17:39:38.438]                       envir <- sys.frame(frame)
[17:39:38.438]                       master <- NULL
[17:39:38.438]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.438]                         !identical(envir, emptyenv())) {
[17:39:38.438]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.438]                           inherits = FALSE)) {
[17:39:38.438]                           master <- get("master", mode = "list", 
[17:39:38.438]                             envir = envir, inherits = FALSE)
[17:39:38.438]                           if (inherits(master, c("SOCKnode", 
[17:39:38.438]                             "SOCK0node"))) {
[17:39:38.438]                             sendCondition <<- function(cond) {
[17:39:38.438]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.438]                                 success = TRUE)
[17:39:38.438]                               parallel_sendData(master, data)
[17:39:38.438]                             }
[17:39:38.438]                             return(sendCondition)
[17:39:38.438]                           }
[17:39:38.438]                         }
[17:39:38.438]                         frame <- frame + 1L
[17:39:38.438]                         envir <- sys.frame(frame)
[17:39:38.438]                       }
[17:39:38.438]                     }
[17:39:38.438]                     sendCondition <<- function(cond) NULL
[17:39:38.438]                   }
[17:39:38.438]                 })
[17:39:38.438]                 withCallingHandlers({
[17:39:38.438]                   {
[17:39:38.438]                     4
[17:39:38.438]                   }
[17:39:38.438]                 }, immediateCondition = function(cond) {
[17:39:38.438]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.438]                   sendCondition(cond)
[17:39:38.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.438]                   {
[17:39:38.438]                     inherits <- base::inherits
[17:39:38.438]                     invokeRestart <- base::invokeRestart
[17:39:38.438]                     is.null <- base::is.null
[17:39:38.438]                     muffled <- FALSE
[17:39:38.438]                     if (inherits(cond, "message")) {
[17:39:38.438]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.438]                       if (muffled) 
[17:39:38.438]                         invokeRestart("muffleMessage")
[17:39:38.438]                     }
[17:39:38.438]                     else if (inherits(cond, "warning")) {
[17:39:38.438]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.438]                       if (muffled) 
[17:39:38.438]                         invokeRestart("muffleWarning")
[17:39:38.438]                     }
[17:39:38.438]                     else if (inherits(cond, "condition")) {
[17:39:38.438]                       if (!is.null(pattern)) {
[17:39:38.438]                         computeRestarts <- base::computeRestarts
[17:39:38.438]                         grepl <- base::grepl
[17:39:38.438]                         restarts <- computeRestarts(cond)
[17:39:38.438]                         for (restart in restarts) {
[17:39:38.438]                           name <- restart$name
[17:39:38.438]                           if (is.null(name)) 
[17:39:38.438]                             next
[17:39:38.438]                           if (!grepl(pattern, name)) 
[17:39:38.438]                             next
[17:39:38.438]                           invokeRestart(restart)
[17:39:38.438]                           muffled <- TRUE
[17:39:38.438]                           break
[17:39:38.438]                         }
[17:39:38.438]                       }
[17:39:38.438]                     }
[17:39:38.438]                     invisible(muffled)
[17:39:38.438]                   }
[17:39:38.438]                   muffleCondition(cond)
[17:39:38.438]                 })
[17:39:38.438]             }))
[17:39:38.438]             future::FutureResult(value = ...future.value$value, 
[17:39:38.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.438]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.438]                     ...future.globalenv.names))
[17:39:38.438]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.438]         }, condition = base::local({
[17:39:38.438]             c <- base::c
[17:39:38.438]             inherits <- base::inherits
[17:39:38.438]             invokeRestart <- base::invokeRestart
[17:39:38.438]             length <- base::length
[17:39:38.438]             list <- base::list
[17:39:38.438]             seq.int <- base::seq.int
[17:39:38.438]             signalCondition <- base::signalCondition
[17:39:38.438]             sys.calls <- base::sys.calls
[17:39:38.438]             `[[` <- base::`[[`
[17:39:38.438]             `+` <- base::`+`
[17:39:38.438]             `<<-` <- base::`<<-`
[17:39:38.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.438]                   3L)]
[17:39:38.438]             }
[17:39:38.438]             function(cond) {
[17:39:38.438]                 is_error <- inherits(cond, "error")
[17:39:38.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.438]                   NULL)
[17:39:38.438]                 if (is_error) {
[17:39:38.438]                   sessionInformation <- function() {
[17:39:38.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.438]                       search = base::search(), system = base::Sys.info())
[17:39:38.438]                   }
[17:39:38.438]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.438]                     cond$call), session = sessionInformation(), 
[17:39:38.438]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.438]                   signalCondition(cond)
[17:39:38.438]                 }
[17:39:38.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.438]                 "immediateCondition"))) {
[17:39:38.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.438]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.438]                   if (TRUE && !signal) {
[17:39:38.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.438]                     {
[17:39:38.438]                       inherits <- base::inherits
[17:39:38.438]                       invokeRestart <- base::invokeRestart
[17:39:38.438]                       is.null <- base::is.null
[17:39:38.438]                       muffled <- FALSE
[17:39:38.438]                       if (inherits(cond, "message")) {
[17:39:38.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.438]                         if (muffled) 
[17:39:38.438]                           invokeRestart("muffleMessage")
[17:39:38.438]                       }
[17:39:38.438]                       else if (inherits(cond, "warning")) {
[17:39:38.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.438]                         if (muffled) 
[17:39:38.438]                           invokeRestart("muffleWarning")
[17:39:38.438]                       }
[17:39:38.438]                       else if (inherits(cond, "condition")) {
[17:39:38.438]                         if (!is.null(pattern)) {
[17:39:38.438]                           computeRestarts <- base::computeRestarts
[17:39:38.438]                           grepl <- base::grepl
[17:39:38.438]                           restarts <- computeRestarts(cond)
[17:39:38.438]                           for (restart in restarts) {
[17:39:38.438]                             name <- restart$name
[17:39:38.438]                             if (is.null(name)) 
[17:39:38.438]                               next
[17:39:38.438]                             if (!grepl(pattern, name)) 
[17:39:38.438]                               next
[17:39:38.438]                             invokeRestart(restart)
[17:39:38.438]                             muffled <- TRUE
[17:39:38.438]                             break
[17:39:38.438]                           }
[17:39:38.438]                         }
[17:39:38.438]                       }
[17:39:38.438]                       invisible(muffled)
[17:39:38.438]                     }
[17:39:38.438]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.438]                   }
[17:39:38.438]                 }
[17:39:38.438]                 else {
[17:39:38.438]                   if (TRUE) {
[17:39:38.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.438]                     {
[17:39:38.438]                       inherits <- base::inherits
[17:39:38.438]                       invokeRestart <- base::invokeRestart
[17:39:38.438]                       is.null <- base::is.null
[17:39:38.438]                       muffled <- FALSE
[17:39:38.438]                       if (inherits(cond, "message")) {
[17:39:38.438]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.438]                         if (muffled) 
[17:39:38.438]                           invokeRestart("muffleMessage")
[17:39:38.438]                       }
[17:39:38.438]                       else if (inherits(cond, "warning")) {
[17:39:38.438]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.438]                         if (muffled) 
[17:39:38.438]                           invokeRestart("muffleWarning")
[17:39:38.438]                       }
[17:39:38.438]                       else if (inherits(cond, "condition")) {
[17:39:38.438]                         if (!is.null(pattern)) {
[17:39:38.438]                           computeRestarts <- base::computeRestarts
[17:39:38.438]                           grepl <- base::grepl
[17:39:38.438]                           restarts <- computeRestarts(cond)
[17:39:38.438]                           for (restart in restarts) {
[17:39:38.438]                             name <- restart$name
[17:39:38.438]                             if (is.null(name)) 
[17:39:38.438]                               next
[17:39:38.438]                             if (!grepl(pattern, name)) 
[17:39:38.438]                               next
[17:39:38.438]                             invokeRestart(restart)
[17:39:38.438]                             muffled <- TRUE
[17:39:38.438]                             break
[17:39:38.438]                           }
[17:39:38.438]                         }
[17:39:38.438]                       }
[17:39:38.438]                       invisible(muffled)
[17:39:38.438]                     }
[17:39:38.438]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.438]                   }
[17:39:38.438]                 }
[17:39:38.438]             }
[17:39:38.438]         }))
[17:39:38.438]     }, error = function(ex) {
[17:39:38.438]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.438]                 ...future.rng), started = ...future.startTime, 
[17:39:38.438]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.438]             version = "1.8"), class = "FutureResult")
[17:39:38.438]     }, finally = {
[17:39:38.438]         if (!identical(...future.workdir, getwd())) 
[17:39:38.438]             setwd(...future.workdir)
[17:39:38.438]         {
[17:39:38.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.438]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.438]             }
[17:39:38.438]             base::options(...future.oldOptions)
[17:39:38.438]             if (.Platform$OS.type == "windows") {
[17:39:38.438]                 old_names <- names(...future.oldEnvVars)
[17:39:38.438]                 envs <- base::Sys.getenv()
[17:39:38.438]                 names <- names(envs)
[17:39:38.438]                 common <- intersect(names, old_names)
[17:39:38.438]                 added <- setdiff(names, old_names)
[17:39:38.438]                 removed <- setdiff(old_names, names)
[17:39:38.438]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.438]                   envs[common]]
[17:39:38.438]                 NAMES <- toupper(changed)
[17:39:38.438]                 args <- list()
[17:39:38.438]                 for (kk in seq_along(NAMES)) {
[17:39:38.438]                   name <- changed[[kk]]
[17:39:38.438]                   NAME <- NAMES[[kk]]
[17:39:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.438]                     next
[17:39:38.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.438]                 }
[17:39:38.438]                 NAMES <- toupper(added)
[17:39:38.438]                 for (kk in seq_along(NAMES)) {
[17:39:38.438]                   name <- added[[kk]]
[17:39:38.438]                   NAME <- NAMES[[kk]]
[17:39:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.438]                     next
[17:39:38.438]                   args[[name]] <- ""
[17:39:38.438]                 }
[17:39:38.438]                 NAMES <- toupper(removed)
[17:39:38.438]                 for (kk in seq_along(NAMES)) {
[17:39:38.438]                   name <- removed[[kk]]
[17:39:38.438]                   NAME <- NAMES[[kk]]
[17:39:38.438]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.438]                     next
[17:39:38.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.438]                 }
[17:39:38.438]                 if (length(args) > 0) 
[17:39:38.438]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.438]             }
[17:39:38.438]             else {
[17:39:38.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.438]             }
[17:39:38.438]             {
[17:39:38.438]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.438]                   0L) {
[17:39:38.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.438]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.438]                   base::options(opts)
[17:39:38.438]                 }
[17:39:38.438]                 {
[17:39:38.438]                   {
[17:39:38.438]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.438]                     NULL
[17:39:38.438]                   }
[17:39:38.438]                   options(future.plan = NULL)
[17:39:38.438]                   if (is.na(NA_character_)) 
[17:39:38.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.438]                     .init = FALSE)
[17:39:38.438]                 }
[17:39:38.438]             }
[17:39:38.438]         }
[17:39:38.438]     })
[17:39:38.438]     if (TRUE) {
[17:39:38.438]         base::sink(type = "output", split = FALSE)
[17:39:38.438]         if (TRUE) {
[17:39:38.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.438]         }
[17:39:38.438]         else {
[17:39:38.438]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.438]         }
[17:39:38.438]         base::close(...future.stdout)
[17:39:38.438]         ...future.stdout <- NULL
[17:39:38.438]     }
[17:39:38.438]     ...future.result$conditions <- ...future.conditions
[17:39:38.438]     ...future.result$finished <- base::Sys.time()
[17:39:38.438]     ...future.result
[17:39:38.438] }
[17:39:38.440] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:38.451] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.451] - Validating connection of MultisessionFuture
[17:39:38.451] - received message: FutureResult
[17:39:38.451] - Received FutureResult
[17:39:38.451] - Erased future from FutureRegistry
[17:39:38.451] result() for ClusterFuture ...
[17:39:38.451] - result already collected: FutureResult
[17:39:38.451] result() for ClusterFuture ... done
[17:39:38.452] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.452] result() for ClusterFuture ...
[17:39:38.452] - result already collected: FutureResult
[17:39:38.452] result() for ClusterFuture ... done
[17:39:38.452] result() for ClusterFuture ...
[17:39:38.452] - result already collected: FutureResult
[17:39:38.452] result() for ClusterFuture ... done
[17:39:38.453] MultisessionFuture started
[17:39:38.453] - Launch lazy future ... done
[17:39:38.454] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adeefc6930> 
Classes 'listenv', 'environment' <environment: 0x55adf1c081e8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:39:38.458] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.459] - Validating connection of MultisessionFuture
[17:39:38.459] - received message: FutureResult
[17:39:38.459] - Received FutureResult
[17:39:38.459] - Erased future from FutureRegistry
[17:39:38.459] result() for ClusterFuture ...
[17:39:38.459] - result already collected: FutureResult
[17:39:38.459] result() for ClusterFuture ... done
[17:39:38.459] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.460] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.460] - Validating connection of MultisessionFuture
[17:39:38.460] - received message: FutureResult
[17:39:38.460] - Received FutureResult
[17:39:38.460] - Erased future from FutureRegistry
[17:39:38.460] result() for ClusterFuture ...
[17:39:38.460] - result already collected: FutureResult
[17:39:38.461] result() for ClusterFuture ... done
[17:39:38.461] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:38.463] resolve() on list environment ...
[17:39:38.463]  recursive: 0
[17:39:38.464]  length: 6
[17:39:38.464]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:38.464] signalConditionsASAP(numeric, pos=1) ...
[17:39:38.464] - nx: 6
[17:39:38.464] - relay: TRUE
[17:39:38.464] - stdout: TRUE
[17:39:38.464] - signal: TRUE
[17:39:38.465] - resignal: FALSE
[17:39:38.465] - force: TRUE
[17:39:38.465] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.465] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.465]  - until=2
[17:39:38.465]  - relaying element #2
[17:39:38.465] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.465] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.465] signalConditionsASAP(NULL, pos=1) ... done
[17:39:38.465]  length: 5 (resolved future 1)
[17:39:38.465] Future #2
[17:39:38.466] result() for ClusterFuture ...
[17:39:38.466] - result already collected: FutureResult
[17:39:38.466] result() for ClusterFuture ... done
[17:39:38.466] result() for ClusterFuture ...
[17:39:38.466] - result already collected: FutureResult
[17:39:38.466] result() for ClusterFuture ... done
[17:39:38.466] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:38.466] - nx: 6
[17:39:38.466] - relay: TRUE
[17:39:38.466] - stdout: TRUE
[17:39:38.466] - signal: TRUE
[17:39:38.467] - resignal: FALSE
[17:39:38.467] - force: TRUE
[17:39:38.467] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.467] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.467]  - until=2
[17:39:38.467]  - relaying element #2
[17:39:38.467] result() for ClusterFuture ...
[17:39:38.467] - result already collected: FutureResult
[17:39:38.467] result() for ClusterFuture ... done
[17:39:38.467] result() for ClusterFuture ...
[17:39:38.467] - result already collected: FutureResult
[17:39:38.467] result() for ClusterFuture ... done
[17:39:38.468] result() for ClusterFuture ...
[17:39:38.468] - result already collected: FutureResult
[17:39:38.468] result() for ClusterFuture ... done
[17:39:38.468] result() for ClusterFuture ...
[17:39:38.468] - result already collected: FutureResult
[17:39:38.468] result() for ClusterFuture ... done
[17:39:38.468] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.468] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.468] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:38.468]  length: 4 (resolved future 2)
[17:39:38.469] Future #3
[17:39:38.469] result() for ClusterFuture ...
[17:39:38.469] - result already collected: FutureResult
[17:39:38.469] result() for ClusterFuture ... done
[17:39:38.469] result() for ClusterFuture ...
[17:39:38.469] - result already collected: FutureResult
[17:39:38.469] result() for ClusterFuture ... done
[17:39:38.469] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:38.469] - nx: 6
[17:39:38.469] - relay: TRUE
[17:39:38.472] - stdout: TRUE
[17:39:38.472] - signal: TRUE
[17:39:38.473] - resignal: FALSE
[17:39:38.473] - force: TRUE
[17:39:38.473] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.473] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.473]  - until=3
[17:39:38.473]  - relaying element #3
[17:39:38.473] result() for ClusterFuture ...
[17:39:38.473] - result already collected: FutureResult
[17:39:38.473] result() for ClusterFuture ... done
[17:39:38.473] result() for ClusterFuture ...
[17:39:38.474] - result already collected: FutureResult
[17:39:38.474] result() for ClusterFuture ... done
[17:39:38.474] result() for ClusterFuture ...
[17:39:38.474] - result already collected: FutureResult
[17:39:38.474] result() for ClusterFuture ... done
[17:39:38.474] result() for ClusterFuture ...
[17:39:38.474] - result already collected: FutureResult
[17:39:38.474] result() for ClusterFuture ... done
[17:39:38.474] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.474] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.474] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:38.475]  length: 3 (resolved future 3)
[17:39:38.475] Future #4
[17:39:38.475] result() for ClusterFuture ...
[17:39:38.475] - result already collected: FutureResult
[17:39:38.475] result() for ClusterFuture ... done
[17:39:38.475] result() for ClusterFuture ...
[17:39:38.475] - result already collected: FutureResult
[17:39:38.475] result() for ClusterFuture ... done
[17:39:38.475] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:38.475] - nx: 6
[17:39:38.475] - relay: TRUE
[17:39:38.475] - stdout: TRUE
[17:39:38.476] - signal: TRUE
[17:39:38.476] - resignal: FALSE
[17:39:38.476] - force: TRUE
[17:39:38.476] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.476] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.476]  - until=4
[17:39:38.476]  - relaying element #4
[17:39:38.476] result() for ClusterFuture ...
[17:39:38.476] - result already collected: FutureResult
[17:39:38.476] result() for ClusterFuture ... done
[17:39:38.476] result() for ClusterFuture ...
[17:39:38.477] - result already collected: FutureResult
[17:39:38.477] result() for ClusterFuture ... done
[17:39:38.477] result() for ClusterFuture ...
[17:39:38.477] - result already collected: FutureResult
[17:39:38.477] result() for ClusterFuture ... done
[17:39:38.477] result() for ClusterFuture ...
[17:39:38.477] - result already collected: FutureResult
[17:39:38.477] result() for ClusterFuture ... done
[17:39:38.477] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.477] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.477] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:38.477]  length: 2 (resolved future 4)
[17:39:38.478] signalConditionsASAP(NULL, pos=5) ...
[17:39:38.478] - nx: 6
[17:39:38.478] - relay: TRUE
[17:39:38.478] - stdout: TRUE
[17:39:38.478] - signal: TRUE
[17:39:38.478] - resignal: FALSE
[17:39:38.478] - force: TRUE
[17:39:38.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.478] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.478]  - until=6
[17:39:38.478]  - relaying element #6
[17:39:38.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.479] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.479] signalConditionsASAP(NULL, pos=5) ... done
[17:39:38.479]  length: 1 (resolved future 5)
[17:39:38.479] signalConditionsASAP(numeric, pos=6) ...
[17:39:38.479] - nx: 6
[17:39:38.479] - relay: TRUE
[17:39:38.479] - stdout: TRUE
[17:39:38.479] - signal: TRUE
[17:39:38.479] - resignal: FALSE
[17:39:38.479] - force: TRUE
[17:39:38.479] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.479] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.480]  - until=6
[17:39:38.480] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.480] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.480] signalConditionsASAP(numeric, pos=6) ... done
[17:39:38.480]  length: 0 (resolved future 6)
[17:39:38.480] Relaying remaining futures
[17:39:38.480] signalConditionsASAP(NULL, pos=0) ...
[17:39:38.480] - nx: 6
[17:39:38.480] - relay: TRUE
[17:39:38.480] - stdout: TRUE
[17:39:38.480] - signal: TRUE
[17:39:38.480] - resignal: FALSE
[17:39:38.481] - force: TRUE
[17:39:38.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:38.481] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.481] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.481] signalConditionsASAP(NULL, pos=0) ... done
[17:39:38.481] resolve() on list environment ... DONE
[17:39:38.481] result() for ClusterFuture ...
[17:39:38.481] - result already collected: FutureResult
[17:39:38.481] result() for ClusterFuture ... done
[17:39:38.481] result() for ClusterFuture ...
[17:39:38.482] - result already collected: FutureResult
[17:39:38.482] result() for ClusterFuture ... done
[17:39:38.482] result() for ClusterFuture ...
[17:39:38.482] - result already collected: FutureResult
[17:39:38.482] result() for ClusterFuture ... done
[17:39:38.482] result() for ClusterFuture ...
[17:39:38.482] - result already collected: FutureResult
[17:39:38.482] result() for ClusterFuture ... done
[17:39:38.482] result() for ClusterFuture ...
[17:39:38.482] - result already collected: FutureResult
[17:39:38.482] result() for ClusterFuture ... done
[17:39:38.483] result() for ClusterFuture ...
[17:39:38.483] - result already collected: FutureResult
[17:39:38.483] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf1f580b0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:39:38.484] getGlobalsAndPackages() ...
[17:39:38.485] Searching for globals...
[17:39:38.485] 
[17:39:38.485] Searching for globals ... DONE
[17:39:38.485] - globals: [0] <none>
[17:39:38.485] getGlobalsAndPackages() ... DONE
[17:39:38.485] run() for ‘Future’ ...
[17:39:38.485] - state: ‘created’
[17:39:38.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.500]   - Field: ‘node’
[17:39:38.500]   - Field: ‘label’
[17:39:38.500]   - Field: ‘local’
[17:39:38.500]   - Field: ‘owner’
[17:39:38.500]   - Field: ‘envir’
[17:39:38.500]   - Field: ‘workers’
[17:39:38.501]   - Field: ‘packages’
[17:39:38.501]   - Field: ‘gc’
[17:39:38.501]   - Field: ‘conditions’
[17:39:38.501]   - Field: ‘persistent’
[17:39:38.501]   - Field: ‘expr’
[17:39:38.501]   - Field: ‘uuid’
[17:39:38.501]   - Field: ‘seed’
[17:39:38.501]   - Field: ‘version’
[17:39:38.501]   - Field: ‘result’
[17:39:38.501]   - Field: ‘asynchronous’
[17:39:38.501]   - Field: ‘calls’
[17:39:38.502]   - Field: ‘globals’
[17:39:38.502]   - Field: ‘stdout’
[17:39:38.502]   - Field: ‘earlySignal’
[17:39:38.502]   - Field: ‘lazy’
[17:39:38.502]   - Field: ‘state’
[17:39:38.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.502] - Launch lazy future ...
[17:39:38.502] Packages needed by the future expression (n = 0): <none>
[17:39:38.502] Packages needed by future strategies (n = 0): <none>
[17:39:38.503] {
[17:39:38.503]     {
[17:39:38.503]         {
[17:39:38.503]             ...future.startTime <- base::Sys.time()
[17:39:38.503]             {
[17:39:38.503]                 {
[17:39:38.503]                   {
[17:39:38.503]                     {
[17:39:38.503]                       base::local({
[17:39:38.503]                         has_future <- base::requireNamespace("future", 
[17:39:38.503]                           quietly = TRUE)
[17:39:38.503]                         if (has_future) {
[17:39:38.503]                           ns <- base::getNamespace("future")
[17:39:38.503]                           version <- ns[[".package"]][["version"]]
[17:39:38.503]                           if (is.null(version)) 
[17:39:38.503]                             version <- utils::packageVersion("future")
[17:39:38.503]                         }
[17:39:38.503]                         else {
[17:39:38.503]                           version <- NULL
[17:39:38.503]                         }
[17:39:38.503]                         if (!has_future || version < "1.8.0") {
[17:39:38.503]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.503]                             "", base::R.version$version.string), 
[17:39:38.503]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.503]                               "release", "version")], collapse = " "), 
[17:39:38.503]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.503]                             info)
[17:39:38.503]                           info <- base::paste(info, collapse = "; ")
[17:39:38.503]                           if (!has_future) {
[17:39:38.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.503]                               info)
[17:39:38.503]                           }
[17:39:38.503]                           else {
[17:39:38.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.503]                               info, version)
[17:39:38.503]                           }
[17:39:38.503]                           base::stop(msg)
[17:39:38.503]                         }
[17:39:38.503]                       })
[17:39:38.503]                     }
[17:39:38.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.503]                     base::options(mc.cores = 1L)
[17:39:38.503]                   }
[17:39:38.503]                   ...future.strategy.old <- future::plan("list")
[17:39:38.503]                   options(future.plan = NULL)
[17:39:38.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.503]                 }
[17:39:38.503]                 ...future.workdir <- getwd()
[17:39:38.503]             }
[17:39:38.503]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.503]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.503]         }
[17:39:38.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.503]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.503]             base::names(...future.oldOptions))
[17:39:38.503]     }
[17:39:38.503]     if (FALSE) {
[17:39:38.503]     }
[17:39:38.503]     else {
[17:39:38.503]         if (TRUE) {
[17:39:38.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.503]                 open = "w")
[17:39:38.503]         }
[17:39:38.503]         else {
[17:39:38.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.503]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.503]         }
[17:39:38.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.503]             base::sink(type = "output", split = FALSE)
[17:39:38.503]             base::close(...future.stdout)
[17:39:38.503]         }, add = TRUE)
[17:39:38.503]     }
[17:39:38.503]     ...future.frame <- base::sys.nframe()
[17:39:38.503]     ...future.conditions <- base::list()
[17:39:38.503]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.503]     if (FALSE) {
[17:39:38.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.503]     }
[17:39:38.503]     ...future.result <- base::tryCatch({
[17:39:38.503]         base::withCallingHandlers({
[17:39:38.503]             ...future.value <- base::withVisible(base::local({
[17:39:38.503]                 ...future.makeSendCondition <- base::local({
[17:39:38.503]                   sendCondition <- NULL
[17:39:38.503]                   function(frame = 1L) {
[17:39:38.503]                     if (is.function(sendCondition)) 
[17:39:38.503]                       return(sendCondition)
[17:39:38.503]                     ns <- getNamespace("parallel")
[17:39:38.503]                     if (exists("sendData", mode = "function", 
[17:39:38.503]                       envir = ns)) {
[17:39:38.503]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.503]                         envir = ns)
[17:39:38.503]                       envir <- sys.frame(frame)
[17:39:38.503]                       master <- NULL
[17:39:38.503]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.503]                         !identical(envir, emptyenv())) {
[17:39:38.503]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.503]                           inherits = FALSE)) {
[17:39:38.503]                           master <- get("master", mode = "list", 
[17:39:38.503]                             envir = envir, inherits = FALSE)
[17:39:38.503]                           if (inherits(master, c("SOCKnode", 
[17:39:38.503]                             "SOCK0node"))) {
[17:39:38.503]                             sendCondition <<- function(cond) {
[17:39:38.503]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.503]                                 success = TRUE)
[17:39:38.503]                               parallel_sendData(master, data)
[17:39:38.503]                             }
[17:39:38.503]                             return(sendCondition)
[17:39:38.503]                           }
[17:39:38.503]                         }
[17:39:38.503]                         frame <- frame + 1L
[17:39:38.503]                         envir <- sys.frame(frame)
[17:39:38.503]                       }
[17:39:38.503]                     }
[17:39:38.503]                     sendCondition <<- function(cond) NULL
[17:39:38.503]                   }
[17:39:38.503]                 })
[17:39:38.503]                 withCallingHandlers({
[17:39:38.503]                   2
[17:39:38.503]                 }, immediateCondition = function(cond) {
[17:39:38.503]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.503]                   sendCondition(cond)
[17:39:38.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.503]                   {
[17:39:38.503]                     inherits <- base::inherits
[17:39:38.503]                     invokeRestart <- base::invokeRestart
[17:39:38.503]                     is.null <- base::is.null
[17:39:38.503]                     muffled <- FALSE
[17:39:38.503]                     if (inherits(cond, "message")) {
[17:39:38.503]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.503]                       if (muffled) 
[17:39:38.503]                         invokeRestart("muffleMessage")
[17:39:38.503]                     }
[17:39:38.503]                     else if (inherits(cond, "warning")) {
[17:39:38.503]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.503]                       if (muffled) 
[17:39:38.503]                         invokeRestart("muffleWarning")
[17:39:38.503]                     }
[17:39:38.503]                     else if (inherits(cond, "condition")) {
[17:39:38.503]                       if (!is.null(pattern)) {
[17:39:38.503]                         computeRestarts <- base::computeRestarts
[17:39:38.503]                         grepl <- base::grepl
[17:39:38.503]                         restarts <- computeRestarts(cond)
[17:39:38.503]                         for (restart in restarts) {
[17:39:38.503]                           name <- restart$name
[17:39:38.503]                           if (is.null(name)) 
[17:39:38.503]                             next
[17:39:38.503]                           if (!grepl(pattern, name)) 
[17:39:38.503]                             next
[17:39:38.503]                           invokeRestart(restart)
[17:39:38.503]                           muffled <- TRUE
[17:39:38.503]                           break
[17:39:38.503]                         }
[17:39:38.503]                       }
[17:39:38.503]                     }
[17:39:38.503]                     invisible(muffled)
[17:39:38.503]                   }
[17:39:38.503]                   muffleCondition(cond)
[17:39:38.503]                 })
[17:39:38.503]             }))
[17:39:38.503]             future::FutureResult(value = ...future.value$value, 
[17:39:38.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.503]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.503]                     ...future.globalenv.names))
[17:39:38.503]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.503]         }, condition = base::local({
[17:39:38.503]             c <- base::c
[17:39:38.503]             inherits <- base::inherits
[17:39:38.503]             invokeRestart <- base::invokeRestart
[17:39:38.503]             length <- base::length
[17:39:38.503]             list <- base::list
[17:39:38.503]             seq.int <- base::seq.int
[17:39:38.503]             signalCondition <- base::signalCondition
[17:39:38.503]             sys.calls <- base::sys.calls
[17:39:38.503]             `[[` <- base::`[[`
[17:39:38.503]             `+` <- base::`+`
[17:39:38.503]             `<<-` <- base::`<<-`
[17:39:38.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.503]                   3L)]
[17:39:38.503]             }
[17:39:38.503]             function(cond) {
[17:39:38.503]                 is_error <- inherits(cond, "error")
[17:39:38.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.503]                   NULL)
[17:39:38.503]                 if (is_error) {
[17:39:38.503]                   sessionInformation <- function() {
[17:39:38.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.503]                       search = base::search(), system = base::Sys.info())
[17:39:38.503]                   }
[17:39:38.503]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.503]                     cond$call), session = sessionInformation(), 
[17:39:38.503]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.503]                   signalCondition(cond)
[17:39:38.503]                 }
[17:39:38.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.503]                 "immediateCondition"))) {
[17:39:38.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.503]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.503]                   if (TRUE && !signal) {
[17:39:38.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.503]                     {
[17:39:38.503]                       inherits <- base::inherits
[17:39:38.503]                       invokeRestart <- base::invokeRestart
[17:39:38.503]                       is.null <- base::is.null
[17:39:38.503]                       muffled <- FALSE
[17:39:38.503]                       if (inherits(cond, "message")) {
[17:39:38.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.503]                         if (muffled) 
[17:39:38.503]                           invokeRestart("muffleMessage")
[17:39:38.503]                       }
[17:39:38.503]                       else if (inherits(cond, "warning")) {
[17:39:38.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.503]                         if (muffled) 
[17:39:38.503]                           invokeRestart("muffleWarning")
[17:39:38.503]                       }
[17:39:38.503]                       else if (inherits(cond, "condition")) {
[17:39:38.503]                         if (!is.null(pattern)) {
[17:39:38.503]                           computeRestarts <- base::computeRestarts
[17:39:38.503]                           grepl <- base::grepl
[17:39:38.503]                           restarts <- computeRestarts(cond)
[17:39:38.503]                           for (restart in restarts) {
[17:39:38.503]                             name <- restart$name
[17:39:38.503]                             if (is.null(name)) 
[17:39:38.503]                               next
[17:39:38.503]                             if (!grepl(pattern, name)) 
[17:39:38.503]                               next
[17:39:38.503]                             invokeRestart(restart)
[17:39:38.503]                             muffled <- TRUE
[17:39:38.503]                             break
[17:39:38.503]                           }
[17:39:38.503]                         }
[17:39:38.503]                       }
[17:39:38.503]                       invisible(muffled)
[17:39:38.503]                     }
[17:39:38.503]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.503]                   }
[17:39:38.503]                 }
[17:39:38.503]                 else {
[17:39:38.503]                   if (TRUE) {
[17:39:38.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.503]                     {
[17:39:38.503]                       inherits <- base::inherits
[17:39:38.503]                       invokeRestart <- base::invokeRestart
[17:39:38.503]                       is.null <- base::is.null
[17:39:38.503]                       muffled <- FALSE
[17:39:38.503]                       if (inherits(cond, "message")) {
[17:39:38.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.503]                         if (muffled) 
[17:39:38.503]                           invokeRestart("muffleMessage")
[17:39:38.503]                       }
[17:39:38.503]                       else if (inherits(cond, "warning")) {
[17:39:38.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.503]                         if (muffled) 
[17:39:38.503]                           invokeRestart("muffleWarning")
[17:39:38.503]                       }
[17:39:38.503]                       else if (inherits(cond, "condition")) {
[17:39:38.503]                         if (!is.null(pattern)) {
[17:39:38.503]                           computeRestarts <- base::computeRestarts
[17:39:38.503]                           grepl <- base::grepl
[17:39:38.503]                           restarts <- computeRestarts(cond)
[17:39:38.503]                           for (restart in restarts) {
[17:39:38.503]                             name <- restart$name
[17:39:38.503]                             if (is.null(name)) 
[17:39:38.503]                               next
[17:39:38.503]                             if (!grepl(pattern, name)) 
[17:39:38.503]                               next
[17:39:38.503]                             invokeRestart(restart)
[17:39:38.503]                             muffled <- TRUE
[17:39:38.503]                             break
[17:39:38.503]                           }
[17:39:38.503]                         }
[17:39:38.503]                       }
[17:39:38.503]                       invisible(muffled)
[17:39:38.503]                     }
[17:39:38.503]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.503]                   }
[17:39:38.503]                 }
[17:39:38.503]             }
[17:39:38.503]         }))
[17:39:38.503]     }, error = function(ex) {
[17:39:38.503]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.503]                 ...future.rng), started = ...future.startTime, 
[17:39:38.503]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.503]             version = "1.8"), class = "FutureResult")
[17:39:38.503]     }, finally = {
[17:39:38.503]         if (!identical(...future.workdir, getwd())) 
[17:39:38.503]             setwd(...future.workdir)
[17:39:38.503]         {
[17:39:38.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.503]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.503]             }
[17:39:38.503]             base::options(...future.oldOptions)
[17:39:38.503]             if (.Platform$OS.type == "windows") {
[17:39:38.503]                 old_names <- names(...future.oldEnvVars)
[17:39:38.503]                 envs <- base::Sys.getenv()
[17:39:38.503]                 names <- names(envs)
[17:39:38.503]                 common <- intersect(names, old_names)
[17:39:38.503]                 added <- setdiff(names, old_names)
[17:39:38.503]                 removed <- setdiff(old_names, names)
[17:39:38.503]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.503]                   envs[common]]
[17:39:38.503]                 NAMES <- toupper(changed)
[17:39:38.503]                 args <- list()
[17:39:38.503]                 for (kk in seq_along(NAMES)) {
[17:39:38.503]                   name <- changed[[kk]]
[17:39:38.503]                   NAME <- NAMES[[kk]]
[17:39:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.503]                     next
[17:39:38.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.503]                 }
[17:39:38.503]                 NAMES <- toupper(added)
[17:39:38.503]                 for (kk in seq_along(NAMES)) {
[17:39:38.503]                   name <- added[[kk]]
[17:39:38.503]                   NAME <- NAMES[[kk]]
[17:39:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.503]                     next
[17:39:38.503]                   args[[name]] <- ""
[17:39:38.503]                 }
[17:39:38.503]                 NAMES <- toupper(removed)
[17:39:38.503]                 for (kk in seq_along(NAMES)) {
[17:39:38.503]                   name <- removed[[kk]]
[17:39:38.503]                   NAME <- NAMES[[kk]]
[17:39:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.503]                     next
[17:39:38.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.503]                 }
[17:39:38.503]                 if (length(args) > 0) 
[17:39:38.503]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.503]             }
[17:39:38.503]             else {
[17:39:38.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.503]             }
[17:39:38.503]             {
[17:39:38.503]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.503]                   0L) {
[17:39:38.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.503]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.503]                   base::options(opts)
[17:39:38.503]                 }
[17:39:38.503]                 {
[17:39:38.503]                   {
[17:39:38.503]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.503]                     NULL
[17:39:38.503]                   }
[17:39:38.503]                   options(future.plan = NULL)
[17:39:38.503]                   if (is.na(NA_character_)) 
[17:39:38.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.503]                     .init = FALSE)
[17:39:38.503]                 }
[17:39:38.503]             }
[17:39:38.503]         }
[17:39:38.503]     })
[17:39:38.503]     if (TRUE) {
[17:39:38.503]         base::sink(type = "output", split = FALSE)
[17:39:38.503]         if (TRUE) {
[17:39:38.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.503]         }
[17:39:38.503]         else {
[17:39:38.503]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.503]         }
[17:39:38.503]         base::close(...future.stdout)
[17:39:38.503]         ...future.stdout <- NULL
[17:39:38.503]     }
[17:39:38.503]     ...future.result$conditions <- ...future.conditions
[17:39:38.503]     ...future.result$finished <- base::Sys.time()
[17:39:38.503]     ...future.result
[17:39:38.503] }
[17:39:38.506] MultisessionFuture started
[17:39:38.506] - Launch lazy future ... done
[17:39:38.506] run() for ‘MultisessionFuture’ ... done
[17:39:38.506] getGlobalsAndPackages() ...
[17:39:38.507] Searching for globals...
[17:39:38.507] 
[17:39:38.507] Searching for globals ... DONE
[17:39:38.507] - globals: [0] <none>
[17:39:38.507] getGlobalsAndPackages() ... DONE
[17:39:38.507] run() for ‘Future’ ...
[17:39:38.507] - state: ‘created’
[17:39:38.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.523]   - Field: ‘node’
[17:39:38.523]   - Field: ‘label’
[17:39:38.523]   - Field: ‘local’
[17:39:38.523]   - Field: ‘owner’
[17:39:38.523]   - Field: ‘envir’
[17:39:38.523]   - Field: ‘workers’
[17:39:38.523]   - Field: ‘packages’
[17:39:38.523]   - Field: ‘gc’
[17:39:38.523]   - Field: ‘conditions’
[17:39:38.523]   - Field: ‘persistent’
[17:39:38.524]   - Field: ‘expr’
[17:39:38.524]   - Field: ‘uuid’
[17:39:38.524]   - Field: ‘seed’
[17:39:38.524]   - Field: ‘version’
[17:39:38.524]   - Field: ‘result’
[17:39:38.524]   - Field: ‘asynchronous’
[17:39:38.524]   - Field: ‘calls’
[17:39:38.524]   - Field: ‘globals’
[17:39:38.524]   - Field: ‘stdout’
[17:39:38.524]   - Field: ‘earlySignal’
[17:39:38.524]   - Field: ‘lazy’
[17:39:38.525]   - Field: ‘state’
[17:39:38.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.525] - Launch lazy future ...
[17:39:38.525] Packages needed by the future expression (n = 0): <none>
[17:39:38.525] Packages needed by future strategies (n = 0): <none>
[17:39:38.526] {
[17:39:38.526]     {
[17:39:38.526]         {
[17:39:38.526]             ...future.startTime <- base::Sys.time()
[17:39:38.526]             {
[17:39:38.526]                 {
[17:39:38.526]                   {
[17:39:38.526]                     {
[17:39:38.526]                       base::local({
[17:39:38.526]                         has_future <- base::requireNamespace("future", 
[17:39:38.526]                           quietly = TRUE)
[17:39:38.526]                         if (has_future) {
[17:39:38.526]                           ns <- base::getNamespace("future")
[17:39:38.526]                           version <- ns[[".package"]][["version"]]
[17:39:38.526]                           if (is.null(version)) 
[17:39:38.526]                             version <- utils::packageVersion("future")
[17:39:38.526]                         }
[17:39:38.526]                         else {
[17:39:38.526]                           version <- NULL
[17:39:38.526]                         }
[17:39:38.526]                         if (!has_future || version < "1.8.0") {
[17:39:38.526]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.526]                             "", base::R.version$version.string), 
[17:39:38.526]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.526]                               "release", "version")], collapse = " "), 
[17:39:38.526]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.526]                             info)
[17:39:38.526]                           info <- base::paste(info, collapse = "; ")
[17:39:38.526]                           if (!has_future) {
[17:39:38.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.526]                               info)
[17:39:38.526]                           }
[17:39:38.526]                           else {
[17:39:38.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.526]                               info, version)
[17:39:38.526]                           }
[17:39:38.526]                           base::stop(msg)
[17:39:38.526]                         }
[17:39:38.526]                       })
[17:39:38.526]                     }
[17:39:38.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.526]                     base::options(mc.cores = 1L)
[17:39:38.526]                   }
[17:39:38.526]                   ...future.strategy.old <- future::plan("list")
[17:39:38.526]                   options(future.plan = NULL)
[17:39:38.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.526]                 }
[17:39:38.526]                 ...future.workdir <- getwd()
[17:39:38.526]             }
[17:39:38.526]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.526]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.526]         }
[17:39:38.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.526]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.526]             base::names(...future.oldOptions))
[17:39:38.526]     }
[17:39:38.526]     if (FALSE) {
[17:39:38.526]     }
[17:39:38.526]     else {
[17:39:38.526]         if (TRUE) {
[17:39:38.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.526]                 open = "w")
[17:39:38.526]         }
[17:39:38.526]         else {
[17:39:38.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.526]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.526]         }
[17:39:38.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.526]             base::sink(type = "output", split = FALSE)
[17:39:38.526]             base::close(...future.stdout)
[17:39:38.526]         }, add = TRUE)
[17:39:38.526]     }
[17:39:38.526]     ...future.frame <- base::sys.nframe()
[17:39:38.526]     ...future.conditions <- base::list()
[17:39:38.526]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.526]     if (FALSE) {
[17:39:38.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.526]     }
[17:39:38.526]     ...future.result <- base::tryCatch({
[17:39:38.526]         base::withCallingHandlers({
[17:39:38.526]             ...future.value <- base::withVisible(base::local({
[17:39:38.526]                 ...future.makeSendCondition <- base::local({
[17:39:38.526]                   sendCondition <- NULL
[17:39:38.526]                   function(frame = 1L) {
[17:39:38.526]                     if (is.function(sendCondition)) 
[17:39:38.526]                       return(sendCondition)
[17:39:38.526]                     ns <- getNamespace("parallel")
[17:39:38.526]                     if (exists("sendData", mode = "function", 
[17:39:38.526]                       envir = ns)) {
[17:39:38.526]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.526]                         envir = ns)
[17:39:38.526]                       envir <- sys.frame(frame)
[17:39:38.526]                       master <- NULL
[17:39:38.526]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.526]                         !identical(envir, emptyenv())) {
[17:39:38.526]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.526]                           inherits = FALSE)) {
[17:39:38.526]                           master <- get("master", mode = "list", 
[17:39:38.526]                             envir = envir, inherits = FALSE)
[17:39:38.526]                           if (inherits(master, c("SOCKnode", 
[17:39:38.526]                             "SOCK0node"))) {
[17:39:38.526]                             sendCondition <<- function(cond) {
[17:39:38.526]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.526]                                 success = TRUE)
[17:39:38.526]                               parallel_sendData(master, data)
[17:39:38.526]                             }
[17:39:38.526]                             return(sendCondition)
[17:39:38.526]                           }
[17:39:38.526]                         }
[17:39:38.526]                         frame <- frame + 1L
[17:39:38.526]                         envir <- sys.frame(frame)
[17:39:38.526]                       }
[17:39:38.526]                     }
[17:39:38.526]                     sendCondition <<- function(cond) NULL
[17:39:38.526]                   }
[17:39:38.526]                 })
[17:39:38.526]                 withCallingHandlers({
[17:39:38.526]                   NULL
[17:39:38.526]                 }, immediateCondition = function(cond) {
[17:39:38.526]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.526]                   sendCondition(cond)
[17:39:38.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.526]                   {
[17:39:38.526]                     inherits <- base::inherits
[17:39:38.526]                     invokeRestart <- base::invokeRestart
[17:39:38.526]                     is.null <- base::is.null
[17:39:38.526]                     muffled <- FALSE
[17:39:38.526]                     if (inherits(cond, "message")) {
[17:39:38.526]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.526]                       if (muffled) 
[17:39:38.526]                         invokeRestart("muffleMessage")
[17:39:38.526]                     }
[17:39:38.526]                     else if (inherits(cond, "warning")) {
[17:39:38.526]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.526]                       if (muffled) 
[17:39:38.526]                         invokeRestart("muffleWarning")
[17:39:38.526]                     }
[17:39:38.526]                     else if (inherits(cond, "condition")) {
[17:39:38.526]                       if (!is.null(pattern)) {
[17:39:38.526]                         computeRestarts <- base::computeRestarts
[17:39:38.526]                         grepl <- base::grepl
[17:39:38.526]                         restarts <- computeRestarts(cond)
[17:39:38.526]                         for (restart in restarts) {
[17:39:38.526]                           name <- restart$name
[17:39:38.526]                           if (is.null(name)) 
[17:39:38.526]                             next
[17:39:38.526]                           if (!grepl(pattern, name)) 
[17:39:38.526]                             next
[17:39:38.526]                           invokeRestart(restart)
[17:39:38.526]                           muffled <- TRUE
[17:39:38.526]                           break
[17:39:38.526]                         }
[17:39:38.526]                       }
[17:39:38.526]                     }
[17:39:38.526]                     invisible(muffled)
[17:39:38.526]                   }
[17:39:38.526]                   muffleCondition(cond)
[17:39:38.526]                 })
[17:39:38.526]             }))
[17:39:38.526]             future::FutureResult(value = ...future.value$value, 
[17:39:38.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.526]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.526]                     ...future.globalenv.names))
[17:39:38.526]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.526]         }, condition = base::local({
[17:39:38.526]             c <- base::c
[17:39:38.526]             inherits <- base::inherits
[17:39:38.526]             invokeRestart <- base::invokeRestart
[17:39:38.526]             length <- base::length
[17:39:38.526]             list <- base::list
[17:39:38.526]             seq.int <- base::seq.int
[17:39:38.526]             signalCondition <- base::signalCondition
[17:39:38.526]             sys.calls <- base::sys.calls
[17:39:38.526]             `[[` <- base::`[[`
[17:39:38.526]             `+` <- base::`+`
[17:39:38.526]             `<<-` <- base::`<<-`
[17:39:38.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.526]                   3L)]
[17:39:38.526]             }
[17:39:38.526]             function(cond) {
[17:39:38.526]                 is_error <- inherits(cond, "error")
[17:39:38.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.526]                   NULL)
[17:39:38.526]                 if (is_error) {
[17:39:38.526]                   sessionInformation <- function() {
[17:39:38.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.526]                       search = base::search(), system = base::Sys.info())
[17:39:38.526]                   }
[17:39:38.526]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.526]                     cond$call), session = sessionInformation(), 
[17:39:38.526]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.526]                   signalCondition(cond)
[17:39:38.526]                 }
[17:39:38.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.526]                 "immediateCondition"))) {
[17:39:38.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.526]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.526]                   if (TRUE && !signal) {
[17:39:38.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.526]                     {
[17:39:38.526]                       inherits <- base::inherits
[17:39:38.526]                       invokeRestart <- base::invokeRestart
[17:39:38.526]                       is.null <- base::is.null
[17:39:38.526]                       muffled <- FALSE
[17:39:38.526]                       if (inherits(cond, "message")) {
[17:39:38.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.526]                         if (muffled) 
[17:39:38.526]                           invokeRestart("muffleMessage")
[17:39:38.526]                       }
[17:39:38.526]                       else if (inherits(cond, "warning")) {
[17:39:38.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.526]                         if (muffled) 
[17:39:38.526]                           invokeRestart("muffleWarning")
[17:39:38.526]                       }
[17:39:38.526]                       else if (inherits(cond, "condition")) {
[17:39:38.526]                         if (!is.null(pattern)) {
[17:39:38.526]                           computeRestarts <- base::computeRestarts
[17:39:38.526]                           grepl <- base::grepl
[17:39:38.526]                           restarts <- computeRestarts(cond)
[17:39:38.526]                           for (restart in restarts) {
[17:39:38.526]                             name <- restart$name
[17:39:38.526]                             if (is.null(name)) 
[17:39:38.526]                               next
[17:39:38.526]                             if (!grepl(pattern, name)) 
[17:39:38.526]                               next
[17:39:38.526]                             invokeRestart(restart)
[17:39:38.526]                             muffled <- TRUE
[17:39:38.526]                             break
[17:39:38.526]                           }
[17:39:38.526]                         }
[17:39:38.526]                       }
[17:39:38.526]                       invisible(muffled)
[17:39:38.526]                     }
[17:39:38.526]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.526]                   }
[17:39:38.526]                 }
[17:39:38.526]                 else {
[17:39:38.526]                   if (TRUE) {
[17:39:38.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.526]                     {
[17:39:38.526]                       inherits <- base::inherits
[17:39:38.526]                       invokeRestart <- base::invokeRestart
[17:39:38.526]                       is.null <- base::is.null
[17:39:38.526]                       muffled <- FALSE
[17:39:38.526]                       if (inherits(cond, "message")) {
[17:39:38.526]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.526]                         if (muffled) 
[17:39:38.526]                           invokeRestart("muffleMessage")
[17:39:38.526]                       }
[17:39:38.526]                       else if (inherits(cond, "warning")) {
[17:39:38.526]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.526]                         if (muffled) 
[17:39:38.526]                           invokeRestart("muffleWarning")
[17:39:38.526]                       }
[17:39:38.526]                       else if (inherits(cond, "condition")) {
[17:39:38.526]                         if (!is.null(pattern)) {
[17:39:38.526]                           computeRestarts <- base::computeRestarts
[17:39:38.526]                           grepl <- base::grepl
[17:39:38.526]                           restarts <- computeRestarts(cond)
[17:39:38.526]                           for (restart in restarts) {
[17:39:38.526]                             name <- restart$name
[17:39:38.526]                             if (is.null(name)) 
[17:39:38.526]                               next
[17:39:38.526]                             if (!grepl(pattern, name)) 
[17:39:38.526]                               next
[17:39:38.526]                             invokeRestart(restart)
[17:39:38.526]                             muffled <- TRUE
[17:39:38.526]                             break
[17:39:38.526]                           }
[17:39:38.526]                         }
[17:39:38.526]                       }
[17:39:38.526]                       invisible(muffled)
[17:39:38.526]                     }
[17:39:38.526]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.526]                   }
[17:39:38.526]                 }
[17:39:38.526]             }
[17:39:38.526]         }))
[17:39:38.526]     }, error = function(ex) {
[17:39:38.526]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.526]                 ...future.rng), started = ...future.startTime, 
[17:39:38.526]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.526]             version = "1.8"), class = "FutureResult")
[17:39:38.526]     }, finally = {
[17:39:38.526]         if (!identical(...future.workdir, getwd())) 
[17:39:38.526]             setwd(...future.workdir)
[17:39:38.526]         {
[17:39:38.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.526]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.526]             }
[17:39:38.526]             base::options(...future.oldOptions)
[17:39:38.526]             if (.Platform$OS.type == "windows") {
[17:39:38.526]                 old_names <- names(...future.oldEnvVars)
[17:39:38.526]                 envs <- base::Sys.getenv()
[17:39:38.526]                 names <- names(envs)
[17:39:38.526]                 common <- intersect(names, old_names)
[17:39:38.526]                 added <- setdiff(names, old_names)
[17:39:38.526]                 removed <- setdiff(old_names, names)
[17:39:38.526]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.526]                   envs[common]]
[17:39:38.526]                 NAMES <- toupper(changed)
[17:39:38.526]                 args <- list()
[17:39:38.526]                 for (kk in seq_along(NAMES)) {
[17:39:38.526]                   name <- changed[[kk]]
[17:39:38.526]                   NAME <- NAMES[[kk]]
[17:39:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.526]                     next
[17:39:38.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.526]                 }
[17:39:38.526]                 NAMES <- toupper(added)
[17:39:38.526]                 for (kk in seq_along(NAMES)) {
[17:39:38.526]                   name <- added[[kk]]
[17:39:38.526]                   NAME <- NAMES[[kk]]
[17:39:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.526]                     next
[17:39:38.526]                   args[[name]] <- ""
[17:39:38.526]                 }
[17:39:38.526]                 NAMES <- toupper(removed)
[17:39:38.526]                 for (kk in seq_along(NAMES)) {
[17:39:38.526]                   name <- removed[[kk]]
[17:39:38.526]                   NAME <- NAMES[[kk]]
[17:39:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.526]                     next
[17:39:38.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.526]                 }
[17:39:38.526]                 if (length(args) > 0) 
[17:39:38.526]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.526]             }
[17:39:38.526]             else {
[17:39:38.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.526]             }
[17:39:38.526]             {
[17:39:38.526]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.526]                   0L) {
[17:39:38.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.526]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.526]                   base::options(opts)
[17:39:38.526]                 }
[17:39:38.526]                 {
[17:39:38.526]                   {
[17:39:38.526]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.526]                     NULL
[17:39:38.526]                   }
[17:39:38.526]                   options(future.plan = NULL)
[17:39:38.526]                   if (is.na(NA_character_)) 
[17:39:38.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.526]                     .init = FALSE)
[17:39:38.526]                 }
[17:39:38.526]             }
[17:39:38.526]         }
[17:39:38.526]     })
[17:39:38.526]     if (TRUE) {
[17:39:38.526]         base::sink(type = "output", split = FALSE)
[17:39:38.526]         if (TRUE) {
[17:39:38.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.526]         }
[17:39:38.526]         else {
[17:39:38.526]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.526]         }
[17:39:38.526]         base::close(...future.stdout)
[17:39:38.526]         ...future.stdout <- NULL
[17:39:38.526]     }
[17:39:38.526]     ...future.result$conditions <- ...future.conditions
[17:39:38.526]     ...future.result$finished <- base::Sys.time()
[17:39:38.526]     ...future.result
[17:39:38.526] }
[17:39:38.529] MultisessionFuture started
[17:39:38.529] - Launch lazy future ... done
[17:39:38.529] run() for ‘MultisessionFuture’ ... done
[17:39:38.529] getGlobalsAndPackages() ...
[17:39:38.529] Searching for globals...
[17:39:38.530] - globals found: [1] ‘{’
[17:39:38.530] Searching for globals ... DONE
[17:39:38.530] Resolving globals: FALSE
[17:39:38.531] 
[17:39:38.531] 
[17:39:38.531] getGlobalsAndPackages() ... DONE
[17:39:38.531] run() for ‘Future’ ...
[17:39:38.531] - state: ‘created’
[17:39:38.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.545] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.545]   - Field: ‘node’
[17:39:38.545]   - Field: ‘label’
[17:39:38.545]   - Field: ‘local’
[17:39:38.545]   - Field: ‘owner’
[17:39:38.545]   - Field: ‘envir’
[17:39:38.545]   - Field: ‘workers’
[17:39:38.545]   - Field: ‘packages’
[17:39:38.546]   - Field: ‘gc’
[17:39:38.546]   - Field: ‘conditions’
[17:39:38.546]   - Field: ‘persistent’
[17:39:38.546]   - Field: ‘expr’
[17:39:38.546]   - Field: ‘uuid’
[17:39:38.546]   - Field: ‘seed’
[17:39:38.546]   - Field: ‘version’
[17:39:38.546]   - Field: ‘result’
[17:39:38.546]   - Field: ‘asynchronous’
[17:39:38.546]   - Field: ‘calls’
[17:39:38.546]   - Field: ‘globals’
[17:39:38.547]   - Field: ‘stdout’
[17:39:38.547]   - Field: ‘earlySignal’
[17:39:38.547]   - Field: ‘lazy’
[17:39:38.547]   - Field: ‘state’
[17:39:38.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.547] - Launch lazy future ...
[17:39:38.547] Packages needed by the future expression (n = 0): <none>
[17:39:38.547] Packages needed by future strategies (n = 0): <none>
[17:39:38.548] {
[17:39:38.548]     {
[17:39:38.548]         {
[17:39:38.548]             ...future.startTime <- base::Sys.time()
[17:39:38.548]             {
[17:39:38.548]                 {
[17:39:38.548]                   {
[17:39:38.548]                     {
[17:39:38.548]                       base::local({
[17:39:38.548]                         has_future <- base::requireNamespace("future", 
[17:39:38.548]                           quietly = TRUE)
[17:39:38.548]                         if (has_future) {
[17:39:38.548]                           ns <- base::getNamespace("future")
[17:39:38.548]                           version <- ns[[".package"]][["version"]]
[17:39:38.548]                           if (is.null(version)) 
[17:39:38.548]                             version <- utils::packageVersion("future")
[17:39:38.548]                         }
[17:39:38.548]                         else {
[17:39:38.548]                           version <- NULL
[17:39:38.548]                         }
[17:39:38.548]                         if (!has_future || version < "1.8.0") {
[17:39:38.548]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.548]                             "", base::R.version$version.string), 
[17:39:38.548]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.548]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.548]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.548]                               "release", "version")], collapse = " "), 
[17:39:38.548]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.548]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.548]                             info)
[17:39:38.548]                           info <- base::paste(info, collapse = "; ")
[17:39:38.548]                           if (!has_future) {
[17:39:38.548]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.548]                               info)
[17:39:38.548]                           }
[17:39:38.548]                           else {
[17:39:38.548]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.548]                               info, version)
[17:39:38.548]                           }
[17:39:38.548]                           base::stop(msg)
[17:39:38.548]                         }
[17:39:38.548]                       })
[17:39:38.548]                     }
[17:39:38.548]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.548]                     base::options(mc.cores = 1L)
[17:39:38.548]                   }
[17:39:38.548]                   ...future.strategy.old <- future::plan("list")
[17:39:38.548]                   options(future.plan = NULL)
[17:39:38.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.548]                 }
[17:39:38.548]                 ...future.workdir <- getwd()
[17:39:38.548]             }
[17:39:38.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.548]         }
[17:39:38.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.548]             base::names(...future.oldOptions))
[17:39:38.548]     }
[17:39:38.548]     if (FALSE) {
[17:39:38.548]     }
[17:39:38.548]     else {
[17:39:38.548]         if (TRUE) {
[17:39:38.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.548]                 open = "w")
[17:39:38.548]         }
[17:39:38.548]         else {
[17:39:38.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.548]         }
[17:39:38.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.548]             base::sink(type = "output", split = FALSE)
[17:39:38.548]             base::close(...future.stdout)
[17:39:38.548]         }, add = TRUE)
[17:39:38.548]     }
[17:39:38.548]     ...future.frame <- base::sys.nframe()
[17:39:38.548]     ...future.conditions <- base::list()
[17:39:38.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.548]     if (FALSE) {
[17:39:38.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.548]     }
[17:39:38.548]     ...future.result <- base::tryCatch({
[17:39:38.548]         base::withCallingHandlers({
[17:39:38.548]             ...future.value <- base::withVisible(base::local({
[17:39:38.548]                 ...future.makeSendCondition <- base::local({
[17:39:38.548]                   sendCondition <- NULL
[17:39:38.548]                   function(frame = 1L) {
[17:39:38.548]                     if (is.function(sendCondition)) 
[17:39:38.548]                       return(sendCondition)
[17:39:38.548]                     ns <- getNamespace("parallel")
[17:39:38.548]                     if (exists("sendData", mode = "function", 
[17:39:38.548]                       envir = ns)) {
[17:39:38.548]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.548]                         envir = ns)
[17:39:38.548]                       envir <- sys.frame(frame)
[17:39:38.548]                       master <- NULL
[17:39:38.548]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.548]                         !identical(envir, emptyenv())) {
[17:39:38.548]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.548]                           inherits = FALSE)) {
[17:39:38.548]                           master <- get("master", mode = "list", 
[17:39:38.548]                             envir = envir, inherits = FALSE)
[17:39:38.548]                           if (inherits(master, c("SOCKnode", 
[17:39:38.548]                             "SOCK0node"))) {
[17:39:38.548]                             sendCondition <<- function(cond) {
[17:39:38.548]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.548]                                 success = TRUE)
[17:39:38.548]                               parallel_sendData(master, data)
[17:39:38.548]                             }
[17:39:38.548]                             return(sendCondition)
[17:39:38.548]                           }
[17:39:38.548]                         }
[17:39:38.548]                         frame <- frame + 1L
[17:39:38.548]                         envir <- sys.frame(frame)
[17:39:38.548]                       }
[17:39:38.548]                     }
[17:39:38.548]                     sendCondition <<- function(cond) NULL
[17:39:38.548]                   }
[17:39:38.548]                 })
[17:39:38.548]                 withCallingHandlers({
[17:39:38.548]                   {
[17:39:38.548]                     4
[17:39:38.548]                   }
[17:39:38.548]                 }, immediateCondition = function(cond) {
[17:39:38.548]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.548]                   sendCondition(cond)
[17:39:38.548]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.548]                   {
[17:39:38.548]                     inherits <- base::inherits
[17:39:38.548]                     invokeRestart <- base::invokeRestart
[17:39:38.548]                     is.null <- base::is.null
[17:39:38.548]                     muffled <- FALSE
[17:39:38.548]                     if (inherits(cond, "message")) {
[17:39:38.548]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.548]                       if (muffled) 
[17:39:38.548]                         invokeRestart("muffleMessage")
[17:39:38.548]                     }
[17:39:38.548]                     else if (inherits(cond, "warning")) {
[17:39:38.548]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.548]                       if (muffled) 
[17:39:38.548]                         invokeRestart("muffleWarning")
[17:39:38.548]                     }
[17:39:38.548]                     else if (inherits(cond, "condition")) {
[17:39:38.548]                       if (!is.null(pattern)) {
[17:39:38.548]                         computeRestarts <- base::computeRestarts
[17:39:38.548]                         grepl <- base::grepl
[17:39:38.548]                         restarts <- computeRestarts(cond)
[17:39:38.548]                         for (restart in restarts) {
[17:39:38.548]                           name <- restart$name
[17:39:38.548]                           if (is.null(name)) 
[17:39:38.548]                             next
[17:39:38.548]                           if (!grepl(pattern, name)) 
[17:39:38.548]                             next
[17:39:38.548]                           invokeRestart(restart)
[17:39:38.548]                           muffled <- TRUE
[17:39:38.548]                           break
[17:39:38.548]                         }
[17:39:38.548]                       }
[17:39:38.548]                     }
[17:39:38.548]                     invisible(muffled)
[17:39:38.548]                   }
[17:39:38.548]                   muffleCondition(cond)
[17:39:38.548]                 })
[17:39:38.548]             }))
[17:39:38.548]             future::FutureResult(value = ...future.value$value, 
[17:39:38.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.548]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.548]                     ...future.globalenv.names))
[17:39:38.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.548]         }, condition = base::local({
[17:39:38.548]             c <- base::c
[17:39:38.548]             inherits <- base::inherits
[17:39:38.548]             invokeRestart <- base::invokeRestart
[17:39:38.548]             length <- base::length
[17:39:38.548]             list <- base::list
[17:39:38.548]             seq.int <- base::seq.int
[17:39:38.548]             signalCondition <- base::signalCondition
[17:39:38.548]             sys.calls <- base::sys.calls
[17:39:38.548]             `[[` <- base::`[[`
[17:39:38.548]             `+` <- base::`+`
[17:39:38.548]             `<<-` <- base::`<<-`
[17:39:38.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.548]                   3L)]
[17:39:38.548]             }
[17:39:38.548]             function(cond) {
[17:39:38.548]                 is_error <- inherits(cond, "error")
[17:39:38.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.548]                   NULL)
[17:39:38.548]                 if (is_error) {
[17:39:38.548]                   sessionInformation <- function() {
[17:39:38.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.548]                       search = base::search(), system = base::Sys.info())
[17:39:38.548]                   }
[17:39:38.548]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.548]                     cond$call), session = sessionInformation(), 
[17:39:38.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.548]                   signalCondition(cond)
[17:39:38.548]                 }
[17:39:38.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.548]                 "immediateCondition"))) {
[17:39:38.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.548]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.548]                   if (TRUE && !signal) {
[17:39:38.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.548]                     {
[17:39:38.548]                       inherits <- base::inherits
[17:39:38.548]                       invokeRestart <- base::invokeRestart
[17:39:38.548]                       is.null <- base::is.null
[17:39:38.548]                       muffled <- FALSE
[17:39:38.548]                       if (inherits(cond, "message")) {
[17:39:38.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.548]                         if (muffled) 
[17:39:38.548]                           invokeRestart("muffleMessage")
[17:39:38.548]                       }
[17:39:38.548]                       else if (inherits(cond, "warning")) {
[17:39:38.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.548]                         if (muffled) 
[17:39:38.548]                           invokeRestart("muffleWarning")
[17:39:38.548]                       }
[17:39:38.548]                       else if (inherits(cond, "condition")) {
[17:39:38.548]                         if (!is.null(pattern)) {
[17:39:38.548]                           computeRestarts <- base::computeRestarts
[17:39:38.548]                           grepl <- base::grepl
[17:39:38.548]                           restarts <- computeRestarts(cond)
[17:39:38.548]                           for (restart in restarts) {
[17:39:38.548]                             name <- restart$name
[17:39:38.548]                             if (is.null(name)) 
[17:39:38.548]                               next
[17:39:38.548]                             if (!grepl(pattern, name)) 
[17:39:38.548]                               next
[17:39:38.548]                             invokeRestart(restart)
[17:39:38.548]                             muffled <- TRUE
[17:39:38.548]                             break
[17:39:38.548]                           }
[17:39:38.548]                         }
[17:39:38.548]                       }
[17:39:38.548]                       invisible(muffled)
[17:39:38.548]                     }
[17:39:38.548]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.548]                   }
[17:39:38.548]                 }
[17:39:38.548]                 else {
[17:39:38.548]                   if (TRUE) {
[17:39:38.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.548]                     {
[17:39:38.548]                       inherits <- base::inherits
[17:39:38.548]                       invokeRestart <- base::invokeRestart
[17:39:38.548]                       is.null <- base::is.null
[17:39:38.548]                       muffled <- FALSE
[17:39:38.548]                       if (inherits(cond, "message")) {
[17:39:38.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.548]                         if (muffled) 
[17:39:38.548]                           invokeRestart("muffleMessage")
[17:39:38.548]                       }
[17:39:38.548]                       else if (inherits(cond, "warning")) {
[17:39:38.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.548]                         if (muffled) 
[17:39:38.548]                           invokeRestart("muffleWarning")
[17:39:38.548]                       }
[17:39:38.548]                       else if (inherits(cond, "condition")) {
[17:39:38.548]                         if (!is.null(pattern)) {
[17:39:38.548]                           computeRestarts <- base::computeRestarts
[17:39:38.548]                           grepl <- base::grepl
[17:39:38.548]                           restarts <- computeRestarts(cond)
[17:39:38.548]                           for (restart in restarts) {
[17:39:38.548]                             name <- restart$name
[17:39:38.548]                             if (is.null(name)) 
[17:39:38.548]                               next
[17:39:38.548]                             if (!grepl(pattern, name)) 
[17:39:38.548]                               next
[17:39:38.548]                             invokeRestart(restart)
[17:39:38.548]                             muffled <- TRUE
[17:39:38.548]                             break
[17:39:38.548]                           }
[17:39:38.548]                         }
[17:39:38.548]                       }
[17:39:38.548]                       invisible(muffled)
[17:39:38.548]                     }
[17:39:38.548]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.548]                   }
[17:39:38.548]                 }
[17:39:38.548]             }
[17:39:38.548]         }))
[17:39:38.548]     }, error = function(ex) {
[17:39:38.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.548]                 ...future.rng), started = ...future.startTime, 
[17:39:38.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.548]             version = "1.8"), class = "FutureResult")
[17:39:38.548]     }, finally = {
[17:39:38.548]         if (!identical(...future.workdir, getwd())) 
[17:39:38.548]             setwd(...future.workdir)
[17:39:38.548]         {
[17:39:38.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.548]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.548]             }
[17:39:38.548]             base::options(...future.oldOptions)
[17:39:38.548]             if (.Platform$OS.type == "windows") {
[17:39:38.548]                 old_names <- names(...future.oldEnvVars)
[17:39:38.548]                 envs <- base::Sys.getenv()
[17:39:38.548]                 names <- names(envs)
[17:39:38.548]                 common <- intersect(names, old_names)
[17:39:38.548]                 added <- setdiff(names, old_names)
[17:39:38.548]                 removed <- setdiff(old_names, names)
[17:39:38.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.548]                   envs[common]]
[17:39:38.548]                 NAMES <- toupper(changed)
[17:39:38.548]                 args <- list()
[17:39:38.548]                 for (kk in seq_along(NAMES)) {
[17:39:38.548]                   name <- changed[[kk]]
[17:39:38.548]                   NAME <- NAMES[[kk]]
[17:39:38.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.548]                     next
[17:39:38.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.548]                 }
[17:39:38.548]                 NAMES <- toupper(added)
[17:39:38.548]                 for (kk in seq_along(NAMES)) {
[17:39:38.548]                   name <- added[[kk]]
[17:39:38.548]                   NAME <- NAMES[[kk]]
[17:39:38.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.548]                     next
[17:39:38.548]                   args[[name]] <- ""
[17:39:38.548]                 }
[17:39:38.548]                 NAMES <- toupper(removed)
[17:39:38.548]                 for (kk in seq_along(NAMES)) {
[17:39:38.548]                   name <- removed[[kk]]
[17:39:38.548]                   NAME <- NAMES[[kk]]
[17:39:38.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.548]                     next
[17:39:38.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.548]                 }
[17:39:38.548]                 if (length(args) > 0) 
[17:39:38.548]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.548]             }
[17:39:38.548]             else {
[17:39:38.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.548]             }
[17:39:38.548]             {
[17:39:38.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.548]                   0L) {
[17:39:38.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.548]                   base::options(opts)
[17:39:38.548]                 }
[17:39:38.548]                 {
[17:39:38.548]                   {
[17:39:38.548]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.548]                     NULL
[17:39:38.548]                   }
[17:39:38.548]                   options(future.plan = NULL)
[17:39:38.548]                   if (is.na(NA_character_)) 
[17:39:38.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.548]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.548]                     .init = FALSE)
[17:39:38.548]                 }
[17:39:38.548]             }
[17:39:38.548]         }
[17:39:38.548]     })
[17:39:38.548]     if (TRUE) {
[17:39:38.548]         base::sink(type = "output", split = FALSE)
[17:39:38.548]         if (TRUE) {
[17:39:38.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.548]         }
[17:39:38.548]         else {
[17:39:38.548]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.548]         }
[17:39:38.548]         base::close(...future.stdout)
[17:39:38.548]         ...future.stdout <- NULL
[17:39:38.548]     }
[17:39:38.548]     ...future.result$conditions <- ...future.conditions
[17:39:38.548]     ...future.result$finished <- base::Sys.time()
[17:39:38.548]     ...future.result
[17:39:38.548] }
[17:39:38.550] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:38.561] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.561] - Validating connection of MultisessionFuture
[17:39:38.561] - received message: FutureResult
[17:39:38.561] - Received FutureResult
[17:39:38.561] - Erased future from FutureRegistry
[17:39:38.562] result() for ClusterFuture ...
[17:39:38.562] - result already collected: FutureResult
[17:39:38.562] result() for ClusterFuture ... done
[17:39:38.562] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.562] result() for ClusterFuture ...
[17:39:38.562] - result already collected: FutureResult
[17:39:38.562] result() for ClusterFuture ... done
[17:39:38.562] result() for ClusterFuture ...
[17:39:38.562] - result already collected: FutureResult
[17:39:38.562] result() for ClusterFuture ... done
[17:39:38.563] MultisessionFuture started
[17:39:38.564] - Launch lazy future ... done
[17:39:38.564] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adeffb4478> 
Classes 'listenv', 'environment' <environment: 0x55adf1703000> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:38.568] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.568] - Validating connection of MultisessionFuture
[17:39:38.568] - received message: FutureResult
[17:39:38.568] - Received FutureResult
[17:39:38.568] - Erased future from FutureRegistry
[17:39:38.569] result() for ClusterFuture ...
[17:39:38.569] - result already collected: FutureResult
[17:39:38.569] result() for ClusterFuture ... done
[17:39:38.569] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.569] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.569] - Validating connection of MultisessionFuture
[17:39:38.570] - received message: FutureResult
[17:39:38.570] - Received FutureResult
[17:39:38.570] - Erased future from FutureRegistry
[17:39:38.570] result() for ClusterFuture ...
[17:39:38.570] - result already collected: FutureResult
[17:39:38.570] result() for ClusterFuture ... done
[17:39:38.570] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:38.573] resolve() on list environment ...
[17:39:38.573]  recursive: 0
[17:39:38.574]  length: 6
[17:39:38.574]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:38.574] signalConditionsASAP(numeric, pos=1) ...
[17:39:38.574] - nx: 6
[17:39:38.574] - relay: TRUE
[17:39:38.574] - stdout: TRUE
[17:39:38.574] - signal: TRUE
[17:39:38.574] - resignal: FALSE
[17:39:38.574] - force: TRUE
[17:39:38.574] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.575] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.575]  - until=2
[17:39:38.575]  - relaying element #2
[17:39:38.575] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.575] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.575] signalConditionsASAP(NULL, pos=1) ... done
[17:39:38.575]  length: 5 (resolved future 1)
[17:39:38.575] Future #2
[17:39:38.575] result() for ClusterFuture ...
[17:39:38.575] - result already collected: FutureResult
[17:39:38.575] result() for ClusterFuture ... done
[17:39:38.576] result() for ClusterFuture ...
[17:39:38.576] - result already collected: FutureResult
[17:39:38.576] result() for ClusterFuture ... done
[17:39:38.576] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:38.576] - nx: 6
[17:39:38.576] - relay: TRUE
[17:39:38.576] - stdout: TRUE
[17:39:38.576] - signal: TRUE
[17:39:38.576] - resignal: FALSE
[17:39:38.576] - force: TRUE
[17:39:38.576] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.577] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.577]  - until=2
[17:39:38.577]  - relaying element #2
[17:39:38.577] result() for ClusterFuture ...
[17:39:38.577] - result already collected: FutureResult
[17:39:38.577] result() for ClusterFuture ... done
[17:39:38.577] result() for ClusterFuture ...
[17:39:38.577] - result already collected: FutureResult
[17:39:38.577] result() for ClusterFuture ... done
[17:39:38.577] result() for ClusterFuture ...
[17:39:38.577] - result already collected: FutureResult
[17:39:38.578] result() for ClusterFuture ... done
[17:39:38.578] result() for ClusterFuture ...
[17:39:38.578] - result already collected: FutureResult
[17:39:38.578] result() for ClusterFuture ... done
[17:39:38.578] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.578] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.578] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:38.578]  length: 4 (resolved future 2)
[17:39:38.578] Future #3
[17:39:38.578] result() for ClusterFuture ...
[17:39:38.578] - result already collected: FutureResult
[17:39:38.579] result() for ClusterFuture ... done
[17:39:38.579] result() for ClusterFuture ...
[17:39:38.579] - result already collected: FutureResult
[17:39:38.579] result() for ClusterFuture ... done
[17:39:38.579] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:38.579] - nx: 6
[17:39:38.579] - relay: TRUE
[17:39:38.579] - stdout: TRUE
[17:39:38.579] - signal: TRUE
[17:39:38.579] - resignal: FALSE
[17:39:38.579] - force: TRUE
[17:39:38.579] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.580] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.580]  - until=3
[17:39:38.580]  - relaying element #3
[17:39:38.580] result() for ClusterFuture ...
[17:39:38.580] - result already collected: FutureResult
[17:39:38.580] result() for ClusterFuture ... done
[17:39:38.580] result() for ClusterFuture ...
[17:39:38.580] - result already collected: FutureResult
[17:39:38.580] result() for ClusterFuture ... done
[17:39:38.580] result() for ClusterFuture ...
[17:39:38.580] - result already collected: FutureResult
[17:39:38.581] result() for ClusterFuture ... done
[17:39:38.581] result() for ClusterFuture ...
[17:39:38.581] - result already collected: FutureResult
[17:39:38.581] result() for ClusterFuture ... done
[17:39:38.581] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.581] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.581] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:38.581]  length: 3 (resolved future 3)
[17:39:38.581] Future #4
[17:39:38.581] result() for ClusterFuture ...
[17:39:38.581] - result already collected: FutureResult
[17:39:38.582] result() for ClusterFuture ... done
[17:39:38.582] result() for ClusterFuture ...
[17:39:38.582] - result already collected: FutureResult
[17:39:38.582] result() for ClusterFuture ... done
[17:39:38.582] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:38.582] - nx: 6
[17:39:38.582] - relay: TRUE
[17:39:38.582] - stdout: TRUE
[17:39:38.582] - signal: TRUE
[17:39:38.582] - resignal: FALSE
[17:39:38.582] - force: TRUE
[17:39:38.582] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.583] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.583]  - until=4
[17:39:38.583]  - relaying element #4
[17:39:38.583] result() for ClusterFuture ...
[17:39:38.583] - result already collected: FutureResult
[17:39:38.583] result() for ClusterFuture ... done
[17:39:38.583] result() for ClusterFuture ...
[17:39:38.583] - result already collected: FutureResult
[17:39:38.583] result() for ClusterFuture ... done
[17:39:38.583] result() for ClusterFuture ...
[17:39:38.583] - result already collected: FutureResult
[17:39:38.583] result() for ClusterFuture ... done
[17:39:38.584] result() for ClusterFuture ...
[17:39:38.584] - result already collected: FutureResult
[17:39:38.584] result() for ClusterFuture ... done
[17:39:38.584] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.584] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.584] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:38.584]  length: 2 (resolved future 4)
[17:39:38.584] signalConditionsASAP(NULL, pos=5) ...
[17:39:38.584] - nx: 6
[17:39:38.584] - relay: TRUE
[17:39:38.584] - stdout: TRUE
[17:39:38.585] - signal: TRUE
[17:39:38.585] - resignal: FALSE
[17:39:38.585] - force: TRUE
[17:39:38.585] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.585] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.585]  - until=6
[17:39:38.585]  - relaying element #6
[17:39:38.585] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.585] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.585] signalConditionsASAP(NULL, pos=5) ... done
[17:39:38.585]  length: 1 (resolved future 5)
[17:39:38.586] signalConditionsASAP(numeric, pos=6) ...
[17:39:38.586] - nx: 6
[17:39:38.586] - relay: TRUE
[17:39:38.586] - stdout: TRUE
[17:39:38.586] - signal: TRUE
[17:39:38.586] - resignal: FALSE
[17:39:38.586] - force: TRUE
[17:39:38.589] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.589] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.589]  - until=6
[17:39:38.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.590] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.590] signalConditionsASAP(numeric, pos=6) ... done
[17:39:38.590]  length: 0 (resolved future 6)
[17:39:38.590] Relaying remaining futures
[17:39:38.590] signalConditionsASAP(NULL, pos=0) ...
[17:39:38.590] - nx: 6
[17:39:38.590] - relay: TRUE
[17:39:38.590] - stdout: TRUE
[17:39:38.590] - signal: TRUE
[17:39:38.590] - resignal: FALSE
[17:39:38.591] - force: TRUE
[17:39:38.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.591] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:38.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.591] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.591] signalConditionsASAP(NULL, pos=0) ... done
[17:39:38.591] resolve() on list environment ... DONE
[17:39:38.591] result() for ClusterFuture ...
[17:39:38.591] - result already collected: FutureResult
[17:39:38.591] result() for ClusterFuture ... done
[17:39:38.592] result() for ClusterFuture ...
[17:39:38.592] - result already collected: FutureResult
[17:39:38.592] result() for ClusterFuture ... done
[17:39:38.592] result() for ClusterFuture ...
[17:39:38.592] - result already collected: FutureResult
[17:39:38.592] result() for ClusterFuture ... done
[17:39:38.592] result() for ClusterFuture ...
[17:39:38.592] - result already collected: FutureResult
[17:39:38.592] result() for ClusterFuture ... done
[17:39:38.592] result() for ClusterFuture ...
[17:39:38.593] - result already collected: FutureResult
[17:39:38.593] result() for ClusterFuture ... done
[17:39:38.593] result() for ClusterFuture ...
[17:39:38.593] - result already collected: FutureResult
[17:39:38.593] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf1bd2280> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:39:38.595] getGlobalsAndPackages() ...
[17:39:38.595] Searching for globals...
[17:39:38.595] 
[17:39:38.595] Searching for globals ... DONE
[17:39:38.595] - globals: [0] <none>
[17:39:38.595] getGlobalsAndPackages() ... DONE
[17:39:38.596] run() for ‘Future’ ...
[17:39:38.596] - state: ‘created’
[17:39:38.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.610]   - Field: ‘node’
[17:39:38.610]   - Field: ‘label’
[17:39:38.610]   - Field: ‘local’
[17:39:38.610]   - Field: ‘owner’
[17:39:38.610]   - Field: ‘envir’
[17:39:38.610]   - Field: ‘workers’
[17:39:38.610]   - Field: ‘packages’
[17:39:38.611]   - Field: ‘gc’
[17:39:38.611]   - Field: ‘conditions’
[17:39:38.611]   - Field: ‘persistent’
[17:39:38.611]   - Field: ‘expr’
[17:39:38.611]   - Field: ‘uuid’
[17:39:38.611]   - Field: ‘seed’
[17:39:38.611]   - Field: ‘version’
[17:39:38.611]   - Field: ‘result’
[17:39:38.611]   - Field: ‘asynchronous’
[17:39:38.611]   - Field: ‘calls’
[17:39:38.611]   - Field: ‘globals’
[17:39:38.612]   - Field: ‘stdout’
[17:39:38.612]   - Field: ‘earlySignal’
[17:39:38.612]   - Field: ‘lazy’
[17:39:38.612]   - Field: ‘state’
[17:39:38.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.612] - Launch lazy future ...
[17:39:38.612] Packages needed by the future expression (n = 0): <none>
[17:39:38.612] Packages needed by future strategies (n = 0): <none>
[17:39:38.613] {
[17:39:38.613]     {
[17:39:38.613]         {
[17:39:38.613]             ...future.startTime <- base::Sys.time()
[17:39:38.613]             {
[17:39:38.613]                 {
[17:39:38.613]                   {
[17:39:38.613]                     {
[17:39:38.613]                       base::local({
[17:39:38.613]                         has_future <- base::requireNamespace("future", 
[17:39:38.613]                           quietly = TRUE)
[17:39:38.613]                         if (has_future) {
[17:39:38.613]                           ns <- base::getNamespace("future")
[17:39:38.613]                           version <- ns[[".package"]][["version"]]
[17:39:38.613]                           if (is.null(version)) 
[17:39:38.613]                             version <- utils::packageVersion("future")
[17:39:38.613]                         }
[17:39:38.613]                         else {
[17:39:38.613]                           version <- NULL
[17:39:38.613]                         }
[17:39:38.613]                         if (!has_future || version < "1.8.0") {
[17:39:38.613]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.613]                             "", base::R.version$version.string), 
[17:39:38.613]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.613]                               "release", "version")], collapse = " "), 
[17:39:38.613]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.613]                             info)
[17:39:38.613]                           info <- base::paste(info, collapse = "; ")
[17:39:38.613]                           if (!has_future) {
[17:39:38.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.613]                               info)
[17:39:38.613]                           }
[17:39:38.613]                           else {
[17:39:38.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.613]                               info, version)
[17:39:38.613]                           }
[17:39:38.613]                           base::stop(msg)
[17:39:38.613]                         }
[17:39:38.613]                       })
[17:39:38.613]                     }
[17:39:38.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.613]                     base::options(mc.cores = 1L)
[17:39:38.613]                   }
[17:39:38.613]                   ...future.strategy.old <- future::plan("list")
[17:39:38.613]                   options(future.plan = NULL)
[17:39:38.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.613]                 }
[17:39:38.613]                 ...future.workdir <- getwd()
[17:39:38.613]             }
[17:39:38.613]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.613]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.613]         }
[17:39:38.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.613]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.613]             base::names(...future.oldOptions))
[17:39:38.613]     }
[17:39:38.613]     if (FALSE) {
[17:39:38.613]     }
[17:39:38.613]     else {
[17:39:38.613]         if (TRUE) {
[17:39:38.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.613]                 open = "w")
[17:39:38.613]         }
[17:39:38.613]         else {
[17:39:38.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.613]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.613]         }
[17:39:38.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.613]             base::sink(type = "output", split = FALSE)
[17:39:38.613]             base::close(...future.stdout)
[17:39:38.613]         }, add = TRUE)
[17:39:38.613]     }
[17:39:38.613]     ...future.frame <- base::sys.nframe()
[17:39:38.613]     ...future.conditions <- base::list()
[17:39:38.613]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.613]     if (FALSE) {
[17:39:38.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.613]     }
[17:39:38.613]     ...future.result <- base::tryCatch({
[17:39:38.613]         base::withCallingHandlers({
[17:39:38.613]             ...future.value <- base::withVisible(base::local({
[17:39:38.613]                 ...future.makeSendCondition <- base::local({
[17:39:38.613]                   sendCondition <- NULL
[17:39:38.613]                   function(frame = 1L) {
[17:39:38.613]                     if (is.function(sendCondition)) 
[17:39:38.613]                       return(sendCondition)
[17:39:38.613]                     ns <- getNamespace("parallel")
[17:39:38.613]                     if (exists("sendData", mode = "function", 
[17:39:38.613]                       envir = ns)) {
[17:39:38.613]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.613]                         envir = ns)
[17:39:38.613]                       envir <- sys.frame(frame)
[17:39:38.613]                       master <- NULL
[17:39:38.613]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.613]                         !identical(envir, emptyenv())) {
[17:39:38.613]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.613]                           inherits = FALSE)) {
[17:39:38.613]                           master <- get("master", mode = "list", 
[17:39:38.613]                             envir = envir, inherits = FALSE)
[17:39:38.613]                           if (inherits(master, c("SOCKnode", 
[17:39:38.613]                             "SOCK0node"))) {
[17:39:38.613]                             sendCondition <<- function(cond) {
[17:39:38.613]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.613]                                 success = TRUE)
[17:39:38.613]                               parallel_sendData(master, data)
[17:39:38.613]                             }
[17:39:38.613]                             return(sendCondition)
[17:39:38.613]                           }
[17:39:38.613]                         }
[17:39:38.613]                         frame <- frame + 1L
[17:39:38.613]                         envir <- sys.frame(frame)
[17:39:38.613]                       }
[17:39:38.613]                     }
[17:39:38.613]                     sendCondition <<- function(cond) NULL
[17:39:38.613]                   }
[17:39:38.613]                 })
[17:39:38.613]                 withCallingHandlers({
[17:39:38.613]                   2
[17:39:38.613]                 }, immediateCondition = function(cond) {
[17:39:38.613]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.613]                   sendCondition(cond)
[17:39:38.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.613]                   {
[17:39:38.613]                     inherits <- base::inherits
[17:39:38.613]                     invokeRestart <- base::invokeRestart
[17:39:38.613]                     is.null <- base::is.null
[17:39:38.613]                     muffled <- FALSE
[17:39:38.613]                     if (inherits(cond, "message")) {
[17:39:38.613]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.613]                       if (muffled) 
[17:39:38.613]                         invokeRestart("muffleMessage")
[17:39:38.613]                     }
[17:39:38.613]                     else if (inherits(cond, "warning")) {
[17:39:38.613]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.613]                       if (muffled) 
[17:39:38.613]                         invokeRestart("muffleWarning")
[17:39:38.613]                     }
[17:39:38.613]                     else if (inherits(cond, "condition")) {
[17:39:38.613]                       if (!is.null(pattern)) {
[17:39:38.613]                         computeRestarts <- base::computeRestarts
[17:39:38.613]                         grepl <- base::grepl
[17:39:38.613]                         restarts <- computeRestarts(cond)
[17:39:38.613]                         for (restart in restarts) {
[17:39:38.613]                           name <- restart$name
[17:39:38.613]                           if (is.null(name)) 
[17:39:38.613]                             next
[17:39:38.613]                           if (!grepl(pattern, name)) 
[17:39:38.613]                             next
[17:39:38.613]                           invokeRestart(restart)
[17:39:38.613]                           muffled <- TRUE
[17:39:38.613]                           break
[17:39:38.613]                         }
[17:39:38.613]                       }
[17:39:38.613]                     }
[17:39:38.613]                     invisible(muffled)
[17:39:38.613]                   }
[17:39:38.613]                   muffleCondition(cond)
[17:39:38.613]                 })
[17:39:38.613]             }))
[17:39:38.613]             future::FutureResult(value = ...future.value$value, 
[17:39:38.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.613]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.613]                     ...future.globalenv.names))
[17:39:38.613]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.613]         }, condition = base::local({
[17:39:38.613]             c <- base::c
[17:39:38.613]             inherits <- base::inherits
[17:39:38.613]             invokeRestart <- base::invokeRestart
[17:39:38.613]             length <- base::length
[17:39:38.613]             list <- base::list
[17:39:38.613]             seq.int <- base::seq.int
[17:39:38.613]             signalCondition <- base::signalCondition
[17:39:38.613]             sys.calls <- base::sys.calls
[17:39:38.613]             `[[` <- base::`[[`
[17:39:38.613]             `+` <- base::`+`
[17:39:38.613]             `<<-` <- base::`<<-`
[17:39:38.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.613]                   3L)]
[17:39:38.613]             }
[17:39:38.613]             function(cond) {
[17:39:38.613]                 is_error <- inherits(cond, "error")
[17:39:38.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.613]                   NULL)
[17:39:38.613]                 if (is_error) {
[17:39:38.613]                   sessionInformation <- function() {
[17:39:38.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.613]                       search = base::search(), system = base::Sys.info())
[17:39:38.613]                   }
[17:39:38.613]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.613]                     cond$call), session = sessionInformation(), 
[17:39:38.613]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.613]                   signalCondition(cond)
[17:39:38.613]                 }
[17:39:38.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.613]                 "immediateCondition"))) {
[17:39:38.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.613]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.613]                   if (TRUE && !signal) {
[17:39:38.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.613]                     {
[17:39:38.613]                       inherits <- base::inherits
[17:39:38.613]                       invokeRestart <- base::invokeRestart
[17:39:38.613]                       is.null <- base::is.null
[17:39:38.613]                       muffled <- FALSE
[17:39:38.613]                       if (inherits(cond, "message")) {
[17:39:38.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.613]                         if (muffled) 
[17:39:38.613]                           invokeRestart("muffleMessage")
[17:39:38.613]                       }
[17:39:38.613]                       else if (inherits(cond, "warning")) {
[17:39:38.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.613]                         if (muffled) 
[17:39:38.613]                           invokeRestart("muffleWarning")
[17:39:38.613]                       }
[17:39:38.613]                       else if (inherits(cond, "condition")) {
[17:39:38.613]                         if (!is.null(pattern)) {
[17:39:38.613]                           computeRestarts <- base::computeRestarts
[17:39:38.613]                           grepl <- base::grepl
[17:39:38.613]                           restarts <- computeRestarts(cond)
[17:39:38.613]                           for (restart in restarts) {
[17:39:38.613]                             name <- restart$name
[17:39:38.613]                             if (is.null(name)) 
[17:39:38.613]                               next
[17:39:38.613]                             if (!grepl(pattern, name)) 
[17:39:38.613]                               next
[17:39:38.613]                             invokeRestart(restart)
[17:39:38.613]                             muffled <- TRUE
[17:39:38.613]                             break
[17:39:38.613]                           }
[17:39:38.613]                         }
[17:39:38.613]                       }
[17:39:38.613]                       invisible(muffled)
[17:39:38.613]                     }
[17:39:38.613]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.613]                   }
[17:39:38.613]                 }
[17:39:38.613]                 else {
[17:39:38.613]                   if (TRUE) {
[17:39:38.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.613]                     {
[17:39:38.613]                       inherits <- base::inherits
[17:39:38.613]                       invokeRestart <- base::invokeRestart
[17:39:38.613]                       is.null <- base::is.null
[17:39:38.613]                       muffled <- FALSE
[17:39:38.613]                       if (inherits(cond, "message")) {
[17:39:38.613]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.613]                         if (muffled) 
[17:39:38.613]                           invokeRestart("muffleMessage")
[17:39:38.613]                       }
[17:39:38.613]                       else if (inherits(cond, "warning")) {
[17:39:38.613]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.613]                         if (muffled) 
[17:39:38.613]                           invokeRestart("muffleWarning")
[17:39:38.613]                       }
[17:39:38.613]                       else if (inherits(cond, "condition")) {
[17:39:38.613]                         if (!is.null(pattern)) {
[17:39:38.613]                           computeRestarts <- base::computeRestarts
[17:39:38.613]                           grepl <- base::grepl
[17:39:38.613]                           restarts <- computeRestarts(cond)
[17:39:38.613]                           for (restart in restarts) {
[17:39:38.613]                             name <- restart$name
[17:39:38.613]                             if (is.null(name)) 
[17:39:38.613]                               next
[17:39:38.613]                             if (!grepl(pattern, name)) 
[17:39:38.613]                               next
[17:39:38.613]                             invokeRestart(restart)
[17:39:38.613]                             muffled <- TRUE
[17:39:38.613]                             break
[17:39:38.613]                           }
[17:39:38.613]                         }
[17:39:38.613]                       }
[17:39:38.613]                       invisible(muffled)
[17:39:38.613]                     }
[17:39:38.613]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.613]                   }
[17:39:38.613]                 }
[17:39:38.613]             }
[17:39:38.613]         }))
[17:39:38.613]     }, error = function(ex) {
[17:39:38.613]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.613]                 ...future.rng), started = ...future.startTime, 
[17:39:38.613]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.613]             version = "1.8"), class = "FutureResult")
[17:39:38.613]     }, finally = {
[17:39:38.613]         if (!identical(...future.workdir, getwd())) 
[17:39:38.613]             setwd(...future.workdir)
[17:39:38.613]         {
[17:39:38.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.613]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.613]             }
[17:39:38.613]             base::options(...future.oldOptions)
[17:39:38.613]             if (.Platform$OS.type == "windows") {
[17:39:38.613]                 old_names <- names(...future.oldEnvVars)
[17:39:38.613]                 envs <- base::Sys.getenv()
[17:39:38.613]                 names <- names(envs)
[17:39:38.613]                 common <- intersect(names, old_names)
[17:39:38.613]                 added <- setdiff(names, old_names)
[17:39:38.613]                 removed <- setdiff(old_names, names)
[17:39:38.613]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.613]                   envs[common]]
[17:39:38.613]                 NAMES <- toupper(changed)
[17:39:38.613]                 args <- list()
[17:39:38.613]                 for (kk in seq_along(NAMES)) {
[17:39:38.613]                   name <- changed[[kk]]
[17:39:38.613]                   NAME <- NAMES[[kk]]
[17:39:38.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.613]                     next
[17:39:38.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.613]                 }
[17:39:38.613]                 NAMES <- toupper(added)
[17:39:38.613]                 for (kk in seq_along(NAMES)) {
[17:39:38.613]                   name <- added[[kk]]
[17:39:38.613]                   NAME <- NAMES[[kk]]
[17:39:38.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.613]                     next
[17:39:38.613]                   args[[name]] <- ""
[17:39:38.613]                 }
[17:39:38.613]                 NAMES <- toupper(removed)
[17:39:38.613]                 for (kk in seq_along(NAMES)) {
[17:39:38.613]                   name <- removed[[kk]]
[17:39:38.613]                   NAME <- NAMES[[kk]]
[17:39:38.613]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.613]                     next
[17:39:38.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.613]                 }
[17:39:38.613]                 if (length(args) > 0) 
[17:39:38.613]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.613]             }
[17:39:38.613]             else {
[17:39:38.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.613]             }
[17:39:38.613]             {
[17:39:38.613]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.613]                   0L) {
[17:39:38.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.613]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.613]                   base::options(opts)
[17:39:38.613]                 }
[17:39:38.613]                 {
[17:39:38.613]                   {
[17:39:38.613]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.613]                     NULL
[17:39:38.613]                   }
[17:39:38.613]                   options(future.plan = NULL)
[17:39:38.613]                   if (is.na(NA_character_)) 
[17:39:38.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.613]                     .init = FALSE)
[17:39:38.613]                 }
[17:39:38.613]             }
[17:39:38.613]         }
[17:39:38.613]     })
[17:39:38.613]     if (TRUE) {
[17:39:38.613]         base::sink(type = "output", split = FALSE)
[17:39:38.613]         if (TRUE) {
[17:39:38.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.613]         }
[17:39:38.613]         else {
[17:39:38.613]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.613]         }
[17:39:38.613]         base::close(...future.stdout)
[17:39:38.613]         ...future.stdout <- NULL
[17:39:38.613]     }
[17:39:38.613]     ...future.result$conditions <- ...future.conditions
[17:39:38.613]     ...future.result$finished <- base::Sys.time()
[17:39:38.613]     ...future.result
[17:39:38.613] }
[17:39:38.616] MultisessionFuture started
[17:39:38.616] - Launch lazy future ... done
[17:39:38.616] run() for ‘MultisessionFuture’ ... done
[17:39:38.616] getGlobalsAndPackages() ...
[17:39:38.616] Searching for globals...
[17:39:38.617] 
[17:39:38.617] Searching for globals ... DONE
[17:39:38.617] - globals: [0] <none>
[17:39:38.617] getGlobalsAndPackages() ... DONE
[17:39:38.617] run() for ‘Future’ ...
[17:39:38.617] - state: ‘created’
[17:39:38.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.631]   - Field: ‘node’
[17:39:38.631]   - Field: ‘label’
[17:39:38.631]   - Field: ‘local’
[17:39:38.631]   - Field: ‘owner’
[17:39:38.631]   - Field: ‘envir’
[17:39:38.631]   - Field: ‘workers’
[17:39:38.631]   - Field: ‘packages’
[17:39:38.631]   - Field: ‘gc’
[17:39:38.632]   - Field: ‘conditions’
[17:39:38.632]   - Field: ‘persistent’
[17:39:38.632]   - Field: ‘expr’
[17:39:38.632]   - Field: ‘uuid’
[17:39:38.632]   - Field: ‘seed’
[17:39:38.632]   - Field: ‘version’
[17:39:38.632]   - Field: ‘result’
[17:39:38.632]   - Field: ‘asynchronous’
[17:39:38.632]   - Field: ‘calls’
[17:39:38.632]   - Field: ‘globals’
[17:39:38.633]   - Field: ‘stdout’
[17:39:38.633]   - Field: ‘earlySignal’
[17:39:38.633]   - Field: ‘lazy’
[17:39:38.633]   - Field: ‘state’
[17:39:38.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.633] - Launch lazy future ...
[17:39:38.633] Packages needed by the future expression (n = 0): <none>
[17:39:38.633] Packages needed by future strategies (n = 0): <none>
[17:39:38.634] {
[17:39:38.634]     {
[17:39:38.634]         {
[17:39:38.634]             ...future.startTime <- base::Sys.time()
[17:39:38.634]             {
[17:39:38.634]                 {
[17:39:38.634]                   {
[17:39:38.634]                     {
[17:39:38.634]                       base::local({
[17:39:38.634]                         has_future <- base::requireNamespace("future", 
[17:39:38.634]                           quietly = TRUE)
[17:39:38.634]                         if (has_future) {
[17:39:38.634]                           ns <- base::getNamespace("future")
[17:39:38.634]                           version <- ns[[".package"]][["version"]]
[17:39:38.634]                           if (is.null(version)) 
[17:39:38.634]                             version <- utils::packageVersion("future")
[17:39:38.634]                         }
[17:39:38.634]                         else {
[17:39:38.634]                           version <- NULL
[17:39:38.634]                         }
[17:39:38.634]                         if (!has_future || version < "1.8.0") {
[17:39:38.634]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.634]                             "", base::R.version$version.string), 
[17:39:38.634]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.634]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.634]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.634]                               "release", "version")], collapse = " "), 
[17:39:38.634]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.634]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.634]                             info)
[17:39:38.634]                           info <- base::paste(info, collapse = "; ")
[17:39:38.634]                           if (!has_future) {
[17:39:38.634]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.634]                               info)
[17:39:38.634]                           }
[17:39:38.634]                           else {
[17:39:38.634]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.634]                               info, version)
[17:39:38.634]                           }
[17:39:38.634]                           base::stop(msg)
[17:39:38.634]                         }
[17:39:38.634]                       })
[17:39:38.634]                     }
[17:39:38.634]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.634]                     base::options(mc.cores = 1L)
[17:39:38.634]                   }
[17:39:38.634]                   ...future.strategy.old <- future::plan("list")
[17:39:38.634]                   options(future.plan = NULL)
[17:39:38.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.634]                 }
[17:39:38.634]                 ...future.workdir <- getwd()
[17:39:38.634]             }
[17:39:38.634]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.634]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.634]         }
[17:39:38.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.634]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.634]             base::names(...future.oldOptions))
[17:39:38.634]     }
[17:39:38.634]     if (FALSE) {
[17:39:38.634]     }
[17:39:38.634]     else {
[17:39:38.634]         if (TRUE) {
[17:39:38.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.634]                 open = "w")
[17:39:38.634]         }
[17:39:38.634]         else {
[17:39:38.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.634]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.634]         }
[17:39:38.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.634]             base::sink(type = "output", split = FALSE)
[17:39:38.634]             base::close(...future.stdout)
[17:39:38.634]         }, add = TRUE)
[17:39:38.634]     }
[17:39:38.634]     ...future.frame <- base::sys.nframe()
[17:39:38.634]     ...future.conditions <- base::list()
[17:39:38.634]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.634]     if (FALSE) {
[17:39:38.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.634]     }
[17:39:38.634]     ...future.result <- base::tryCatch({
[17:39:38.634]         base::withCallingHandlers({
[17:39:38.634]             ...future.value <- base::withVisible(base::local({
[17:39:38.634]                 ...future.makeSendCondition <- base::local({
[17:39:38.634]                   sendCondition <- NULL
[17:39:38.634]                   function(frame = 1L) {
[17:39:38.634]                     if (is.function(sendCondition)) 
[17:39:38.634]                       return(sendCondition)
[17:39:38.634]                     ns <- getNamespace("parallel")
[17:39:38.634]                     if (exists("sendData", mode = "function", 
[17:39:38.634]                       envir = ns)) {
[17:39:38.634]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.634]                         envir = ns)
[17:39:38.634]                       envir <- sys.frame(frame)
[17:39:38.634]                       master <- NULL
[17:39:38.634]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.634]                         !identical(envir, emptyenv())) {
[17:39:38.634]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.634]                           inherits = FALSE)) {
[17:39:38.634]                           master <- get("master", mode = "list", 
[17:39:38.634]                             envir = envir, inherits = FALSE)
[17:39:38.634]                           if (inherits(master, c("SOCKnode", 
[17:39:38.634]                             "SOCK0node"))) {
[17:39:38.634]                             sendCondition <<- function(cond) {
[17:39:38.634]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.634]                                 success = TRUE)
[17:39:38.634]                               parallel_sendData(master, data)
[17:39:38.634]                             }
[17:39:38.634]                             return(sendCondition)
[17:39:38.634]                           }
[17:39:38.634]                         }
[17:39:38.634]                         frame <- frame + 1L
[17:39:38.634]                         envir <- sys.frame(frame)
[17:39:38.634]                       }
[17:39:38.634]                     }
[17:39:38.634]                     sendCondition <<- function(cond) NULL
[17:39:38.634]                   }
[17:39:38.634]                 })
[17:39:38.634]                 withCallingHandlers({
[17:39:38.634]                   NULL
[17:39:38.634]                 }, immediateCondition = function(cond) {
[17:39:38.634]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.634]                   sendCondition(cond)
[17:39:38.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.634]                   {
[17:39:38.634]                     inherits <- base::inherits
[17:39:38.634]                     invokeRestart <- base::invokeRestart
[17:39:38.634]                     is.null <- base::is.null
[17:39:38.634]                     muffled <- FALSE
[17:39:38.634]                     if (inherits(cond, "message")) {
[17:39:38.634]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.634]                       if (muffled) 
[17:39:38.634]                         invokeRestart("muffleMessage")
[17:39:38.634]                     }
[17:39:38.634]                     else if (inherits(cond, "warning")) {
[17:39:38.634]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.634]                       if (muffled) 
[17:39:38.634]                         invokeRestart("muffleWarning")
[17:39:38.634]                     }
[17:39:38.634]                     else if (inherits(cond, "condition")) {
[17:39:38.634]                       if (!is.null(pattern)) {
[17:39:38.634]                         computeRestarts <- base::computeRestarts
[17:39:38.634]                         grepl <- base::grepl
[17:39:38.634]                         restarts <- computeRestarts(cond)
[17:39:38.634]                         for (restart in restarts) {
[17:39:38.634]                           name <- restart$name
[17:39:38.634]                           if (is.null(name)) 
[17:39:38.634]                             next
[17:39:38.634]                           if (!grepl(pattern, name)) 
[17:39:38.634]                             next
[17:39:38.634]                           invokeRestart(restart)
[17:39:38.634]                           muffled <- TRUE
[17:39:38.634]                           break
[17:39:38.634]                         }
[17:39:38.634]                       }
[17:39:38.634]                     }
[17:39:38.634]                     invisible(muffled)
[17:39:38.634]                   }
[17:39:38.634]                   muffleCondition(cond)
[17:39:38.634]                 })
[17:39:38.634]             }))
[17:39:38.634]             future::FutureResult(value = ...future.value$value, 
[17:39:38.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.634]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.634]                     ...future.globalenv.names))
[17:39:38.634]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.634]         }, condition = base::local({
[17:39:38.634]             c <- base::c
[17:39:38.634]             inherits <- base::inherits
[17:39:38.634]             invokeRestart <- base::invokeRestart
[17:39:38.634]             length <- base::length
[17:39:38.634]             list <- base::list
[17:39:38.634]             seq.int <- base::seq.int
[17:39:38.634]             signalCondition <- base::signalCondition
[17:39:38.634]             sys.calls <- base::sys.calls
[17:39:38.634]             `[[` <- base::`[[`
[17:39:38.634]             `+` <- base::`+`
[17:39:38.634]             `<<-` <- base::`<<-`
[17:39:38.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.634]                   3L)]
[17:39:38.634]             }
[17:39:38.634]             function(cond) {
[17:39:38.634]                 is_error <- inherits(cond, "error")
[17:39:38.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.634]                   NULL)
[17:39:38.634]                 if (is_error) {
[17:39:38.634]                   sessionInformation <- function() {
[17:39:38.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.634]                       search = base::search(), system = base::Sys.info())
[17:39:38.634]                   }
[17:39:38.634]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.634]                     cond$call), session = sessionInformation(), 
[17:39:38.634]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.634]                   signalCondition(cond)
[17:39:38.634]                 }
[17:39:38.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.634]                 "immediateCondition"))) {
[17:39:38.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.634]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.634]                   if (TRUE && !signal) {
[17:39:38.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.634]                     {
[17:39:38.634]                       inherits <- base::inherits
[17:39:38.634]                       invokeRestart <- base::invokeRestart
[17:39:38.634]                       is.null <- base::is.null
[17:39:38.634]                       muffled <- FALSE
[17:39:38.634]                       if (inherits(cond, "message")) {
[17:39:38.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.634]                         if (muffled) 
[17:39:38.634]                           invokeRestart("muffleMessage")
[17:39:38.634]                       }
[17:39:38.634]                       else if (inherits(cond, "warning")) {
[17:39:38.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.634]                         if (muffled) 
[17:39:38.634]                           invokeRestart("muffleWarning")
[17:39:38.634]                       }
[17:39:38.634]                       else if (inherits(cond, "condition")) {
[17:39:38.634]                         if (!is.null(pattern)) {
[17:39:38.634]                           computeRestarts <- base::computeRestarts
[17:39:38.634]                           grepl <- base::grepl
[17:39:38.634]                           restarts <- computeRestarts(cond)
[17:39:38.634]                           for (restart in restarts) {
[17:39:38.634]                             name <- restart$name
[17:39:38.634]                             if (is.null(name)) 
[17:39:38.634]                               next
[17:39:38.634]                             if (!grepl(pattern, name)) 
[17:39:38.634]                               next
[17:39:38.634]                             invokeRestart(restart)
[17:39:38.634]                             muffled <- TRUE
[17:39:38.634]                             break
[17:39:38.634]                           }
[17:39:38.634]                         }
[17:39:38.634]                       }
[17:39:38.634]                       invisible(muffled)
[17:39:38.634]                     }
[17:39:38.634]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.634]                   }
[17:39:38.634]                 }
[17:39:38.634]                 else {
[17:39:38.634]                   if (TRUE) {
[17:39:38.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.634]                     {
[17:39:38.634]                       inherits <- base::inherits
[17:39:38.634]                       invokeRestart <- base::invokeRestart
[17:39:38.634]                       is.null <- base::is.null
[17:39:38.634]                       muffled <- FALSE
[17:39:38.634]                       if (inherits(cond, "message")) {
[17:39:38.634]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.634]                         if (muffled) 
[17:39:38.634]                           invokeRestart("muffleMessage")
[17:39:38.634]                       }
[17:39:38.634]                       else if (inherits(cond, "warning")) {
[17:39:38.634]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.634]                         if (muffled) 
[17:39:38.634]                           invokeRestart("muffleWarning")
[17:39:38.634]                       }
[17:39:38.634]                       else if (inherits(cond, "condition")) {
[17:39:38.634]                         if (!is.null(pattern)) {
[17:39:38.634]                           computeRestarts <- base::computeRestarts
[17:39:38.634]                           grepl <- base::grepl
[17:39:38.634]                           restarts <- computeRestarts(cond)
[17:39:38.634]                           for (restart in restarts) {
[17:39:38.634]                             name <- restart$name
[17:39:38.634]                             if (is.null(name)) 
[17:39:38.634]                               next
[17:39:38.634]                             if (!grepl(pattern, name)) 
[17:39:38.634]                               next
[17:39:38.634]                             invokeRestart(restart)
[17:39:38.634]                             muffled <- TRUE
[17:39:38.634]                             break
[17:39:38.634]                           }
[17:39:38.634]                         }
[17:39:38.634]                       }
[17:39:38.634]                       invisible(muffled)
[17:39:38.634]                     }
[17:39:38.634]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.634]                   }
[17:39:38.634]                 }
[17:39:38.634]             }
[17:39:38.634]         }))
[17:39:38.634]     }, error = function(ex) {
[17:39:38.634]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.634]                 ...future.rng), started = ...future.startTime, 
[17:39:38.634]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.634]             version = "1.8"), class = "FutureResult")
[17:39:38.634]     }, finally = {
[17:39:38.634]         if (!identical(...future.workdir, getwd())) 
[17:39:38.634]             setwd(...future.workdir)
[17:39:38.634]         {
[17:39:38.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.634]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.634]             }
[17:39:38.634]             base::options(...future.oldOptions)
[17:39:38.634]             if (.Platform$OS.type == "windows") {
[17:39:38.634]                 old_names <- names(...future.oldEnvVars)
[17:39:38.634]                 envs <- base::Sys.getenv()
[17:39:38.634]                 names <- names(envs)
[17:39:38.634]                 common <- intersect(names, old_names)
[17:39:38.634]                 added <- setdiff(names, old_names)
[17:39:38.634]                 removed <- setdiff(old_names, names)
[17:39:38.634]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.634]                   envs[common]]
[17:39:38.634]                 NAMES <- toupper(changed)
[17:39:38.634]                 args <- list()
[17:39:38.634]                 for (kk in seq_along(NAMES)) {
[17:39:38.634]                   name <- changed[[kk]]
[17:39:38.634]                   NAME <- NAMES[[kk]]
[17:39:38.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.634]                     next
[17:39:38.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.634]                 }
[17:39:38.634]                 NAMES <- toupper(added)
[17:39:38.634]                 for (kk in seq_along(NAMES)) {
[17:39:38.634]                   name <- added[[kk]]
[17:39:38.634]                   NAME <- NAMES[[kk]]
[17:39:38.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.634]                     next
[17:39:38.634]                   args[[name]] <- ""
[17:39:38.634]                 }
[17:39:38.634]                 NAMES <- toupper(removed)
[17:39:38.634]                 for (kk in seq_along(NAMES)) {
[17:39:38.634]                   name <- removed[[kk]]
[17:39:38.634]                   NAME <- NAMES[[kk]]
[17:39:38.634]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.634]                     next
[17:39:38.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.634]                 }
[17:39:38.634]                 if (length(args) > 0) 
[17:39:38.634]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.634]             }
[17:39:38.634]             else {
[17:39:38.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.634]             }
[17:39:38.634]             {
[17:39:38.634]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.634]                   0L) {
[17:39:38.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.634]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.634]                   base::options(opts)
[17:39:38.634]                 }
[17:39:38.634]                 {
[17:39:38.634]                   {
[17:39:38.634]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.634]                     NULL
[17:39:38.634]                   }
[17:39:38.634]                   options(future.plan = NULL)
[17:39:38.634]                   if (is.na(NA_character_)) 
[17:39:38.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.634]                     .init = FALSE)
[17:39:38.634]                 }
[17:39:38.634]             }
[17:39:38.634]         }
[17:39:38.634]     })
[17:39:38.634]     if (TRUE) {
[17:39:38.634]         base::sink(type = "output", split = FALSE)
[17:39:38.634]         if (TRUE) {
[17:39:38.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.634]         }
[17:39:38.634]         else {
[17:39:38.634]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.634]         }
[17:39:38.634]         base::close(...future.stdout)
[17:39:38.634]         ...future.stdout <- NULL
[17:39:38.634]     }
[17:39:38.634]     ...future.result$conditions <- ...future.conditions
[17:39:38.634]     ...future.result$finished <- base::Sys.time()
[17:39:38.634]     ...future.result
[17:39:38.634] }
[17:39:38.637] MultisessionFuture started
[17:39:38.637] - Launch lazy future ... done
[17:39:38.637] run() for ‘MultisessionFuture’ ... done
[17:39:38.637] getGlobalsAndPackages() ...
[17:39:38.638] Searching for globals...
[17:39:38.638] - globals found: [1] ‘{’
[17:39:38.638] Searching for globals ... DONE
[17:39:38.638] Resolving globals: FALSE
[17:39:38.639] 
[17:39:38.639] 
[17:39:38.639] getGlobalsAndPackages() ... DONE
[17:39:38.639] run() for ‘Future’ ...
[17:39:38.639] - state: ‘created’
[17:39:38.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:39:38.654] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:39:38.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:39:38.654]   - Field: ‘node’
[17:39:38.654]   - Field: ‘label’
[17:39:38.654]   - Field: ‘local’
[17:39:38.654]   - Field: ‘owner’
[17:39:38.654]   - Field: ‘envir’
[17:39:38.655]   - Field: ‘workers’
[17:39:38.655]   - Field: ‘packages’
[17:39:38.655]   - Field: ‘gc’
[17:39:38.655]   - Field: ‘conditions’
[17:39:38.655]   - Field: ‘persistent’
[17:39:38.655]   - Field: ‘expr’
[17:39:38.655]   - Field: ‘uuid’
[17:39:38.655]   - Field: ‘seed’
[17:39:38.655]   - Field: ‘version’
[17:39:38.655]   - Field: ‘result’
[17:39:38.655]   - Field: ‘asynchronous’
[17:39:38.655]   - Field: ‘calls’
[17:39:38.656]   - Field: ‘globals’
[17:39:38.656]   - Field: ‘stdout’
[17:39:38.656]   - Field: ‘earlySignal’
[17:39:38.656]   - Field: ‘lazy’
[17:39:38.656]   - Field: ‘state’
[17:39:38.656] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:39:38.656] - Launch lazy future ...
[17:39:38.656] Packages needed by the future expression (n = 0): <none>
[17:39:38.657] Packages needed by future strategies (n = 0): <none>
[17:39:38.657] {
[17:39:38.657]     {
[17:39:38.657]         {
[17:39:38.657]             ...future.startTime <- base::Sys.time()
[17:39:38.657]             {
[17:39:38.657]                 {
[17:39:38.657]                   {
[17:39:38.657]                     {
[17:39:38.657]                       base::local({
[17:39:38.657]                         has_future <- base::requireNamespace("future", 
[17:39:38.657]                           quietly = TRUE)
[17:39:38.657]                         if (has_future) {
[17:39:38.657]                           ns <- base::getNamespace("future")
[17:39:38.657]                           version <- ns[[".package"]][["version"]]
[17:39:38.657]                           if (is.null(version)) 
[17:39:38.657]                             version <- utils::packageVersion("future")
[17:39:38.657]                         }
[17:39:38.657]                         else {
[17:39:38.657]                           version <- NULL
[17:39:38.657]                         }
[17:39:38.657]                         if (!has_future || version < "1.8.0") {
[17:39:38.657]                           info <- base::c(r_version = base::gsub("R version ", 
[17:39:38.657]                             "", base::R.version$version.string), 
[17:39:38.657]                             platform = base::sprintf("%s (%s-bit)", 
[17:39:38.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:39:38.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:39:38.657]                               "release", "version")], collapse = " "), 
[17:39:38.657]                             hostname = base::Sys.info()[["nodename"]])
[17:39:38.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:39:38.657]                             info)
[17:39:38.657]                           info <- base::paste(info, collapse = "; ")
[17:39:38.657]                           if (!has_future) {
[17:39:38.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:39:38.657]                               info)
[17:39:38.657]                           }
[17:39:38.657]                           else {
[17:39:38.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:39:38.657]                               info, version)
[17:39:38.657]                           }
[17:39:38.657]                           base::stop(msg)
[17:39:38.657]                         }
[17:39:38.657]                       })
[17:39:38.657]                     }
[17:39:38.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:39:38.657]                     base::options(mc.cores = 1L)
[17:39:38.657]                   }
[17:39:38.657]                   ...future.strategy.old <- future::plan("list")
[17:39:38.657]                   options(future.plan = NULL)
[17:39:38.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:39:38.657]                 }
[17:39:38.657]                 ...future.workdir <- getwd()
[17:39:38.657]             }
[17:39:38.657]             ...future.oldOptions <- base::as.list(base::.Options)
[17:39:38.657]             ...future.oldEnvVars <- base::Sys.getenv()
[17:39:38.657]         }
[17:39:38.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:39:38.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:39:38.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:39:38.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:39:38.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:39:38.657]             future.stdout.windows.reencode = NULL, width = 80L)
[17:39:38.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:39:38.657]             base::names(...future.oldOptions))
[17:39:38.657]     }
[17:39:38.657]     if (FALSE) {
[17:39:38.657]     }
[17:39:38.657]     else {
[17:39:38.657]         if (TRUE) {
[17:39:38.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:39:38.657]                 open = "w")
[17:39:38.657]         }
[17:39:38.657]         else {
[17:39:38.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:39:38.657]                 windows = "NUL", "/dev/null"), open = "w")
[17:39:38.657]         }
[17:39:38.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:39:38.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:39:38.657]             base::sink(type = "output", split = FALSE)
[17:39:38.657]             base::close(...future.stdout)
[17:39:38.657]         }, add = TRUE)
[17:39:38.657]     }
[17:39:38.657]     ...future.frame <- base::sys.nframe()
[17:39:38.657]     ...future.conditions <- base::list()
[17:39:38.657]     ...future.rng <- base::globalenv()$.Random.seed
[17:39:38.657]     if (FALSE) {
[17:39:38.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:39:38.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:39:38.657]     }
[17:39:38.657]     ...future.result <- base::tryCatch({
[17:39:38.657]         base::withCallingHandlers({
[17:39:38.657]             ...future.value <- base::withVisible(base::local({
[17:39:38.657]                 ...future.makeSendCondition <- base::local({
[17:39:38.657]                   sendCondition <- NULL
[17:39:38.657]                   function(frame = 1L) {
[17:39:38.657]                     if (is.function(sendCondition)) 
[17:39:38.657]                       return(sendCondition)
[17:39:38.657]                     ns <- getNamespace("parallel")
[17:39:38.657]                     if (exists("sendData", mode = "function", 
[17:39:38.657]                       envir = ns)) {
[17:39:38.657]                       parallel_sendData <- get("sendData", mode = "function", 
[17:39:38.657]                         envir = ns)
[17:39:38.657]                       envir <- sys.frame(frame)
[17:39:38.657]                       master <- NULL
[17:39:38.657]                       while (!identical(envir, .GlobalEnv) && 
[17:39:38.657]                         !identical(envir, emptyenv())) {
[17:39:38.657]                         if (exists("master", mode = "list", envir = envir, 
[17:39:38.657]                           inherits = FALSE)) {
[17:39:38.657]                           master <- get("master", mode = "list", 
[17:39:38.657]                             envir = envir, inherits = FALSE)
[17:39:38.657]                           if (inherits(master, c("SOCKnode", 
[17:39:38.657]                             "SOCK0node"))) {
[17:39:38.657]                             sendCondition <<- function(cond) {
[17:39:38.657]                               data <- list(type = "VALUE", value = cond, 
[17:39:38.657]                                 success = TRUE)
[17:39:38.657]                               parallel_sendData(master, data)
[17:39:38.657]                             }
[17:39:38.657]                             return(sendCondition)
[17:39:38.657]                           }
[17:39:38.657]                         }
[17:39:38.657]                         frame <- frame + 1L
[17:39:38.657]                         envir <- sys.frame(frame)
[17:39:38.657]                       }
[17:39:38.657]                     }
[17:39:38.657]                     sendCondition <<- function(cond) NULL
[17:39:38.657]                   }
[17:39:38.657]                 })
[17:39:38.657]                 withCallingHandlers({
[17:39:38.657]                   {
[17:39:38.657]                     4
[17:39:38.657]                   }
[17:39:38.657]                 }, immediateCondition = function(cond) {
[17:39:38.657]                   sendCondition <- ...future.makeSendCondition()
[17:39:38.657]                   sendCondition(cond)
[17:39:38.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.657]                   {
[17:39:38.657]                     inherits <- base::inherits
[17:39:38.657]                     invokeRestart <- base::invokeRestart
[17:39:38.657]                     is.null <- base::is.null
[17:39:38.657]                     muffled <- FALSE
[17:39:38.657]                     if (inherits(cond, "message")) {
[17:39:38.657]                       muffled <- grepl(pattern, "muffleMessage")
[17:39:38.657]                       if (muffled) 
[17:39:38.657]                         invokeRestart("muffleMessage")
[17:39:38.657]                     }
[17:39:38.657]                     else if (inherits(cond, "warning")) {
[17:39:38.657]                       muffled <- grepl(pattern, "muffleWarning")
[17:39:38.657]                       if (muffled) 
[17:39:38.657]                         invokeRestart("muffleWarning")
[17:39:38.657]                     }
[17:39:38.657]                     else if (inherits(cond, "condition")) {
[17:39:38.657]                       if (!is.null(pattern)) {
[17:39:38.657]                         computeRestarts <- base::computeRestarts
[17:39:38.657]                         grepl <- base::grepl
[17:39:38.657]                         restarts <- computeRestarts(cond)
[17:39:38.657]                         for (restart in restarts) {
[17:39:38.657]                           name <- restart$name
[17:39:38.657]                           if (is.null(name)) 
[17:39:38.657]                             next
[17:39:38.657]                           if (!grepl(pattern, name)) 
[17:39:38.657]                             next
[17:39:38.657]                           invokeRestart(restart)
[17:39:38.657]                           muffled <- TRUE
[17:39:38.657]                           break
[17:39:38.657]                         }
[17:39:38.657]                       }
[17:39:38.657]                     }
[17:39:38.657]                     invisible(muffled)
[17:39:38.657]                   }
[17:39:38.657]                   muffleCondition(cond)
[17:39:38.657]                 })
[17:39:38.657]             }))
[17:39:38.657]             future::FutureResult(value = ...future.value$value, 
[17:39:38.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.657]                   ...future.rng), globalenv = if (FALSE) 
[17:39:38.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:39:38.657]                     ...future.globalenv.names))
[17:39:38.657]                 else NULL, started = ...future.startTime, version = "1.8")
[17:39:38.657]         }, condition = base::local({
[17:39:38.657]             c <- base::c
[17:39:38.657]             inherits <- base::inherits
[17:39:38.657]             invokeRestart <- base::invokeRestart
[17:39:38.657]             length <- base::length
[17:39:38.657]             list <- base::list
[17:39:38.657]             seq.int <- base::seq.int
[17:39:38.657]             signalCondition <- base::signalCondition
[17:39:38.657]             sys.calls <- base::sys.calls
[17:39:38.657]             `[[` <- base::`[[`
[17:39:38.657]             `+` <- base::`+`
[17:39:38.657]             `<<-` <- base::`<<-`
[17:39:38.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:39:38.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:39:38.657]                   3L)]
[17:39:38.657]             }
[17:39:38.657]             function(cond) {
[17:39:38.657]                 is_error <- inherits(cond, "error")
[17:39:38.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:39:38.657]                   NULL)
[17:39:38.657]                 if (is_error) {
[17:39:38.657]                   sessionInformation <- function() {
[17:39:38.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:39:38.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:39:38.657]                       search = base::search(), system = base::Sys.info())
[17:39:38.657]                   }
[17:39:38.657]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:39:38.657]                     cond$call), session = sessionInformation(), 
[17:39:38.657]                     timestamp = base::Sys.time(), signaled = 0L)
[17:39:38.657]                   signalCondition(cond)
[17:39:38.657]                 }
[17:39:38.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:39:38.657]                 "immediateCondition"))) {
[17:39:38.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:39:38.657]                   ...future.conditions[[length(...future.conditions) + 
[17:39:38.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:39:38.657]                   if (TRUE && !signal) {
[17:39:38.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.657]                     {
[17:39:38.657]                       inherits <- base::inherits
[17:39:38.657]                       invokeRestart <- base::invokeRestart
[17:39:38.657]                       is.null <- base::is.null
[17:39:38.657]                       muffled <- FALSE
[17:39:38.657]                       if (inherits(cond, "message")) {
[17:39:38.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.657]                         if (muffled) 
[17:39:38.657]                           invokeRestart("muffleMessage")
[17:39:38.657]                       }
[17:39:38.657]                       else if (inherits(cond, "warning")) {
[17:39:38.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.657]                         if (muffled) 
[17:39:38.657]                           invokeRestart("muffleWarning")
[17:39:38.657]                       }
[17:39:38.657]                       else if (inherits(cond, "condition")) {
[17:39:38.657]                         if (!is.null(pattern)) {
[17:39:38.657]                           computeRestarts <- base::computeRestarts
[17:39:38.657]                           grepl <- base::grepl
[17:39:38.657]                           restarts <- computeRestarts(cond)
[17:39:38.657]                           for (restart in restarts) {
[17:39:38.657]                             name <- restart$name
[17:39:38.657]                             if (is.null(name)) 
[17:39:38.657]                               next
[17:39:38.657]                             if (!grepl(pattern, name)) 
[17:39:38.657]                               next
[17:39:38.657]                             invokeRestart(restart)
[17:39:38.657]                             muffled <- TRUE
[17:39:38.657]                             break
[17:39:38.657]                           }
[17:39:38.657]                         }
[17:39:38.657]                       }
[17:39:38.657]                       invisible(muffled)
[17:39:38.657]                     }
[17:39:38.657]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.657]                   }
[17:39:38.657]                 }
[17:39:38.657]                 else {
[17:39:38.657]                   if (TRUE) {
[17:39:38.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:39:38.657]                     {
[17:39:38.657]                       inherits <- base::inherits
[17:39:38.657]                       invokeRestart <- base::invokeRestart
[17:39:38.657]                       is.null <- base::is.null
[17:39:38.657]                       muffled <- FALSE
[17:39:38.657]                       if (inherits(cond, "message")) {
[17:39:38.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:39:38.657]                         if (muffled) 
[17:39:38.657]                           invokeRestart("muffleMessage")
[17:39:38.657]                       }
[17:39:38.657]                       else if (inherits(cond, "warning")) {
[17:39:38.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:39:38.657]                         if (muffled) 
[17:39:38.657]                           invokeRestart("muffleWarning")
[17:39:38.657]                       }
[17:39:38.657]                       else if (inherits(cond, "condition")) {
[17:39:38.657]                         if (!is.null(pattern)) {
[17:39:38.657]                           computeRestarts <- base::computeRestarts
[17:39:38.657]                           grepl <- base::grepl
[17:39:38.657]                           restarts <- computeRestarts(cond)
[17:39:38.657]                           for (restart in restarts) {
[17:39:38.657]                             name <- restart$name
[17:39:38.657]                             if (is.null(name)) 
[17:39:38.657]                               next
[17:39:38.657]                             if (!grepl(pattern, name)) 
[17:39:38.657]                               next
[17:39:38.657]                             invokeRestart(restart)
[17:39:38.657]                             muffled <- TRUE
[17:39:38.657]                             break
[17:39:38.657]                           }
[17:39:38.657]                         }
[17:39:38.657]                       }
[17:39:38.657]                       invisible(muffled)
[17:39:38.657]                     }
[17:39:38.657]                     muffleCondition(cond, pattern = "^muffle")
[17:39:38.657]                   }
[17:39:38.657]                 }
[17:39:38.657]             }
[17:39:38.657]         }))
[17:39:38.657]     }, error = function(ex) {
[17:39:38.657]         base::structure(base::list(value = NULL, visible = NULL, 
[17:39:38.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:39:38.657]                 ...future.rng), started = ...future.startTime, 
[17:39:38.657]             finished = Sys.time(), session_uuid = NA_character_, 
[17:39:38.657]             version = "1.8"), class = "FutureResult")
[17:39:38.657]     }, finally = {
[17:39:38.657]         if (!identical(...future.workdir, getwd())) 
[17:39:38.657]             setwd(...future.workdir)
[17:39:38.657]         {
[17:39:38.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:39:38.657]                 ...future.oldOptions$nwarnings <- NULL
[17:39:38.657]             }
[17:39:38.657]             base::options(...future.oldOptions)
[17:39:38.657]             if (.Platform$OS.type == "windows") {
[17:39:38.657]                 old_names <- names(...future.oldEnvVars)
[17:39:38.657]                 envs <- base::Sys.getenv()
[17:39:38.657]                 names <- names(envs)
[17:39:38.657]                 common <- intersect(names, old_names)
[17:39:38.657]                 added <- setdiff(names, old_names)
[17:39:38.657]                 removed <- setdiff(old_names, names)
[17:39:38.657]                 changed <- common[...future.oldEnvVars[common] != 
[17:39:38.657]                   envs[common]]
[17:39:38.657]                 NAMES <- toupper(changed)
[17:39:38.657]                 args <- list()
[17:39:38.657]                 for (kk in seq_along(NAMES)) {
[17:39:38.657]                   name <- changed[[kk]]
[17:39:38.657]                   NAME <- NAMES[[kk]]
[17:39:38.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.657]                     next
[17:39:38.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.657]                 }
[17:39:38.657]                 NAMES <- toupper(added)
[17:39:38.657]                 for (kk in seq_along(NAMES)) {
[17:39:38.657]                   name <- added[[kk]]
[17:39:38.657]                   NAME <- NAMES[[kk]]
[17:39:38.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.657]                     next
[17:39:38.657]                   args[[name]] <- ""
[17:39:38.657]                 }
[17:39:38.657]                 NAMES <- toupper(removed)
[17:39:38.657]                 for (kk in seq_along(NAMES)) {
[17:39:38.657]                   name <- removed[[kk]]
[17:39:38.657]                   NAME <- NAMES[[kk]]
[17:39:38.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:39:38.657]                     next
[17:39:38.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:39:38.657]                 }
[17:39:38.657]                 if (length(args) > 0) 
[17:39:38.657]                   base::do.call(base::Sys.setenv, args = args)
[17:39:38.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:39:38.657]             }
[17:39:38.657]             else {
[17:39:38.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:39:38.657]             }
[17:39:38.657]             {
[17:39:38.657]                 if (base::length(...future.futureOptionsAdded) > 
[17:39:38.657]                   0L) {
[17:39:38.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:39:38.657]                   base::names(opts) <- ...future.futureOptionsAdded
[17:39:38.657]                   base::options(opts)
[17:39:38.657]                 }
[17:39:38.657]                 {
[17:39:38.657]                   {
[17:39:38.657]                     base::options(mc.cores = ...future.mc.cores.old)
[17:39:38.657]                     NULL
[17:39:38.657]                   }
[17:39:38.657]                   options(future.plan = NULL)
[17:39:38.657]                   if (is.na(NA_character_)) 
[17:39:38.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:39:38.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:39:38.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:39:38.657]                     .init = FALSE)
[17:39:38.657]                 }
[17:39:38.657]             }
[17:39:38.657]         }
[17:39:38.657]     })
[17:39:38.657]     if (TRUE) {
[17:39:38.657]         base::sink(type = "output", split = FALSE)
[17:39:38.657]         if (TRUE) {
[17:39:38.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:39:38.657]         }
[17:39:38.657]         else {
[17:39:38.657]             ...future.result["stdout"] <- base::list(NULL)
[17:39:38.657]         }
[17:39:38.657]         base::close(...future.stdout)
[17:39:38.657]         ...future.stdout <- NULL
[17:39:38.657]     }
[17:39:38.657]     ...future.result$conditions <- ...future.conditions
[17:39:38.657]     ...future.result$finished <- base::Sys.time()
[17:39:38.657]     ...future.result
[17:39:38.657] }
[17:39:38.659] Poll #1 (0): usedNodes() = 2, workers = 2
[17:39:38.670] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.670] - Validating connection of MultisessionFuture
[17:39:38.670] - received message: FutureResult
[17:39:38.670] - Received FutureResult
[17:39:38.670] - Erased future from FutureRegistry
[17:39:38.670] result() for ClusterFuture ...
[17:39:38.671] - result already collected: FutureResult
[17:39:38.671] result() for ClusterFuture ... done
[17:39:38.671] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.671] result() for ClusterFuture ...
[17:39:38.671] - result already collected: FutureResult
[17:39:38.671] result() for ClusterFuture ... done
[17:39:38.671] result() for ClusterFuture ...
[17:39:38.671] - result already collected: FutureResult
[17:39:38.671] result() for ClusterFuture ... done
[17:39:38.672] MultisessionFuture started
[17:39:38.672] - Launch lazy future ... done
[17:39:38.672] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55adf05518f8> 
Classes 'listenv', 'environment' <environment: 0x55adf12d5100> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:39:38.677] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.677] - Validating connection of MultisessionFuture
[17:39:38.677] - received message: FutureResult
[17:39:38.677] - Received FutureResult
[17:39:38.677] - Erased future from FutureRegistry
[17:39:38.678] result() for ClusterFuture ...
[17:39:38.678] - result already collected: FutureResult
[17:39:38.678] result() for ClusterFuture ... done
[17:39:38.678] receiveMessageFromWorker() for ClusterFuture ... done
[17:39:38.678] receiveMessageFromWorker() for ClusterFuture ...
[17:39:38.678] - Validating connection of MultisessionFuture
[17:39:38.679] - received message: FutureResult
[17:39:38.679] - Received FutureResult
[17:39:38.679] - Erased future from FutureRegistry
[17:39:38.679] result() for ClusterFuture ...
[17:39:38.679] - result already collected: FutureResult
[17:39:38.679] result() for ClusterFuture ... done
[17:39:38.679] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:39:38.682] resolve() on list environment ...
[17:39:38.682]  recursive: 0
[17:39:38.683]  length: 6
[17:39:38.683]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:39:38.683] signalConditionsASAP(numeric, pos=1) ...
[17:39:38.683] - nx: 6
[17:39:38.683] - relay: TRUE
[17:39:38.683] - stdout: TRUE
[17:39:38.683] - signal: TRUE
[17:39:38.683] - resignal: FALSE
[17:39:38.684] - force: TRUE
[17:39:38.684] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.684] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.684]  - until=2
[17:39:38.684]  - relaying element #2
[17:39:38.684] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.684] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.684] signalConditionsASAP(NULL, pos=1) ... done
[17:39:38.684]  length: 5 (resolved future 1)
[17:39:38.684] Future #2
[17:39:38.685] result() for ClusterFuture ...
[17:39:38.685] - result already collected: FutureResult
[17:39:38.685] result() for ClusterFuture ... done
[17:39:38.685] result() for ClusterFuture ...
[17:39:38.685] - result already collected: FutureResult
[17:39:38.685] result() for ClusterFuture ... done
[17:39:38.685] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:39:38.685] - nx: 6
[17:39:38.685] - relay: TRUE
[17:39:38.685] - stdout: TRUE
[17:39:38.685] - signal: TRUE
[17:39:38.685] - resignal: FALSE
[17:39:38.686] - force: TRUE
[17:39:38.686] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.686] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:39:38.686]  - until=2
[17:39:38.686]  - relaying element #2
[17:39:38.686] result() for ClusterFuture ...
[17:39:38.686] - result already collected: FutureResult
[17:39:38.686] result() for ClusterFuture ... done
[17:39:38.686] result() for ClusterFuture ...
[17:39:38.686] - result already collected: FutureResult
[17:39:38.686] result() for ClusterFuture ... done
[17:39:38.686] result() for ClusterFuture ...
[17:39:38.687] - result already collected: FutureResult
[17:39:38.687] result() for ClusterFuture ... done
[17:39:38.687] result() for ClusterFuture ...
[17:39:38.687] - result already collected: FutureResult
[17:39:38.687] result() for ClusterFuture ... done
[17:39:38.687] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.687] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.687] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:39:38.687]  length: 4 (resolved future 2)
[17:39:38.687] Future #3
[17:39:38.688] result() for ClusterFuture ...
[17:39:38.688] - result already collected: FutureResult
[17:39:38.688] result() for ClusterFuture ... done
[17:39:38.688] result() for ClusterFuture ...
[17:39:38.688] - result already collected: FutureResult
[17:39:38.688] result() for ClusterFuture ... done
[17:39:38.688] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:39:38.688] - nx: 6
[17:39:38.688] - relay: TRUE
[17:39:38.688] - stdout: TRUE
[17:39:38.688] - signal: TRUE
[17:39:38.689] - resignal: FALSE
[17:39:38.689] - force: TRUE
[17:39:38.689] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.689] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:39:38.689]  - until=3
[17:39:38.689]  - relaying element #3
[17:39:38.689] result() for ClusterFuture ...
[17:39:38.689] - result already collected: FutureResult
[17:39:38.689] result() for ClusterFuture ... done
[17:39:38.689] result() for ClusterFuture ...
[17:39:38.689] - result already collected: FutureResult
[17:39:38.689] result() for ClusterFuture ... done
[17:39:38.690] result() for ClusterFuture ...
[17:39:38.690] - result already collected: FutureResult
[17:39:38.690] result() for ClusterFuture ... done
[17:39:38.690] result() for ClusterFuture ...
[17:39:38.690] - result already collected: FutureResult
[17:39:38.690] result() for ClusterFuture ... done
[17:39:38.690] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.690] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.690] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:39:38.690]  length: 3 (resolved future 3)
[17:39:38.690] Future #4
[17:39:38.691] result() for ClusterFuture ...
[17:39:38.691] - result already collected: FutureResult
[17:39:38.691] result() for ClusterFuture ... done
[17:39:38.691] result() for ClusterFuture ...
[17:39:38.691] - result already collected: FutureResult
[17:39:38.691] result() for ClusterFuture ... done
[17:39:38.691] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:39:38.691] - nx: 6
[17:39:38.691] - relay: TRUE
[17:39:38.691] - stdout: TRUE
[17:39:38.691] - signal: TRUE
[17:39:38.691] - resignal: FALSE
[17:39:38.692] - force: TRUE
[17:39:38.692] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.692] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:39:38.692]  - until=4
[17:39:38.692]  - relaying element #4
[17:39:38.692] result() for ClusterFuture ...
[17:39:38.692] - result already collected: FutureResult
[17:39:38.692] result() for ClusterFuture ... done
[17:39:38.692] result() for ClusterFuture ...
[17:39:38.692] - result already collected: FutureResult
[17:39:38.692] result() for ClusterFuture ... done
[17:39:38.693] result() for ClusterFuture ...
[17:39:38.693] - result already collected: FutureResult
[17:39:38.693] result() for ClusterFuture ... done
[17:39:38.693] result() for ClusterFuture ...
[17:39:38.693] - result already collected: FutureResult
[17:39:38.693] result() for ClusterFuture ... done
[17:39:38.693] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.693] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.693] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:39:38.693]  length: 2 (resolved future 4)
[17:39:38.693] signalConditionsASAP(NULL, pos=5) ...
[17:39:38.694] - nx: 6
[17:39:38.694] - relay: TRUE
[17:39:38.694] - stdout: TRUE
[17:39:38.694] - signal: TRUE
[17:39:38.694] - resignal: FALSE
[17:39:38.694] - force: TRUE
[17:39:38.694] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.694] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.694]  - until=6
[17:39:38.694]  - relaying element #6
[17:39:38.694] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.694] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.695] signalConditionsASAP(NULL, pos=5) ... done
[17:39:38.695]  length: 1 (resolved future 5)
[17:39:38.695] signalConditionsASAP(numeric, pos=6) ...
[17:39:38.695] - nx: 6
[17:39:38.695] - relay: TRUE
[17:39:38.695] - stdout: TRUE
[17:39:38.695] - signal: TRUE
[17:39:38.695] - resignal: FALSE
[17:39:38.695] - force: TRUE
[17:39:38.695] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:39:38.695] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.695]  - until=6
[17:39:38.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.696] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.696] signalConditionsASAP(numeric, pos=6) ... done
[17:39:38.696]  length: 0 (resolved future 6)
[17:39:38.696] Relaying remaining futures
[17:39:38.696] signalConditionsASAP(NULL, pos=0) ...
[17:39:38.696] - nx: 6
[17:39:38.696] - relay: TRUE
[17:39:38.696] - stdout: TRUE
[17:39:38.696] - signal: TRUE
[17:39:38.696] - resignal: FALSE
[17:39:38.696] - force: TRUE
[17:39:38.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.697] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:39:38.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:39:38.697] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:39:38.697] signalConditionsASAP(NULL, pos=0) ... done
[17:39:38.697] resolve() on list environment ... DONE
[17:39:38.697] result() for ClusterFuture ...
[17:39:38.697] - result already collected: FutureResult
[17:39:38.697] result() for ClusterFuture ... done
[17:39:38.697] result() for ClusterFuture ...
[17:39:38.698] - result already collected: FutureResult
[17:39:38.698] result() for ClusterFuture ... done
[17:39:38.698] result() for ClusterFuture ...
[17:39:38.698] - result already collected: FutureResult
[17:39:38.698] result() for ClusterFuture ... done
[17:39:38.698] result() for ClusterFuture ...
[17:39:38.698] - result already collected: FutureResult
[17:39:38.698] result() for ClusterFuture ... done
[17:39:38.698] result() for ClusterFuture ...
[17:39:38.698] - result already collected: FutureResult
[17:39:38.699] result() for ClusterFuture ... done
[17:39:38.699] result() for ClusterFuture ...
[17:39:38.699] - result already collected: FutureResult
[17:39:38.699] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55adf17a7ad8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[17:39:38.702] plan(): Setting new future strategy stack:
[17:39:38.705] List of future strategies:
[17:39:38.705] 1. FutureStrategy:
[17:39:38.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:39:38.705]    - tweaked: FALSE
[17:39:38.705]    - call: future::plan(oplan)
[17:39:38.706] plan(): nbrOfWorkers() = 1
> 
