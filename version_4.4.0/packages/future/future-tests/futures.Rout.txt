
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:11.425] plan(): Setting new future strategy stack:
[09:31:11.425] List of future strategies:
[09:31:11.425] 1. sequential:
[09:31:11.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.425]    - tweaked: FALSE
[09:31:11.425]    - call: future::plan("sequential")
[09:31:11.436] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[09:31:11.488] plan(): Setting new future strategy stack:
[09:31:11.488] List of future strategies:
[09:31:11.488] 1. sequential:
[09:31:11.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.488]    - tweaked: FALSE
[09:31:11.488]    - call: plan(strategy)
[09:31:11.499] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[09:31:11.499] getGlobalsAndPackages() ...
[09:31:11.500] Searching for globals...
[09:31:11.502] 
[09:31:11.502] Searching for globals ... DONE
[09:31:11.503] - globals: [0] <none>
[09:31:11.503] getGlobalsAndPackages() ... DONE
[09:31:11.503] run() for ‘Future’ ...
[09:31:11.503] - state: ‘created’
[09:31:11.504] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.504] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.504]   - Field: ‘label’
[09:31:11.504]   - Field: ‘local’
[09:31:11.504]   - Field: ‘owner’
[09:31:11.504]   - Field: ‘envir’
[09:31:11.505]   - Field: ‘packages’
[09:31:11.505]   - Field: ‘gc’
[09:31:11.505]   - Field: ‘conditions’
[09:31:11.505]   - Field: ‘expr’
[09:31:11.505]   - Field: ‘uuid’
[09:31:11.505]   - Field: ‘seed’
[09:31:11.505]   - Field: ‘version’
[09:31:11.505]   - Field: ‘result’
[09:31:11.505]   - Field: ‘asynchronous’
[09:31:11.505]   - Field: ‘calls’
[09:31:11.505]   - Field: ‘globals’
[09:31:11.505]   - Field: ‘stdout’
[09:31:11.506]   - Field: ‘earlySignal’
[09:31:11.506]   - Field: ‘lazy’
[09:31:11.506]   - Field: ‘state’
[09:31:11.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.506] - Launch lazy future ...
[09:31:11.507] Packages needed by the future expression (n = 0): <none>
[09:31:11.507] Packages needed by future strategies (n = 0): <none>
[09:31:11.507] {
[09:31:11.507]     {
[09:31:11.507]         {
[09:31:11.507]             ...future.startTime <- base::Sys.time()
[09:31:11.507]             {
[09:31:11.507]                 {
[09:31:11.507]                   {
[09:31:11.507]                     base::local({
[09:31:11.507]                       has_future <- base::requireNamespace("future", 
[09:31:11.507]                         quietly = TRUE)
[09:31:11.507]                       if (has_future) {
[09:31:11.507]                         ns <- base::getNamespace("future")
[09:31:11.507]                         version <- ns[[".package"]][["version"]]
[09:31:11.507]                         if (is.null(version)) 
[09:31:11.507]                           version <- utils::packageVersion("future")
[09:31:11.507]                       }
[09:31:11.507]                       else {
[09:31:11.507]                         version <- NULL
[09:31:11.507]                       }
[09:31:11.507]                       if (!has_future || version < "1.8.0") {
[09:31:11.507]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.507]                           "", base::R.version$version.string), 
[09:31:11.507]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.507]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.507]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.507]                             "release", "version")], collapse = " "), 
[09:31:11.507]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.507]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.507]                           info)
[09:31:11.507]                         info <- base::paste(info, collapse = "; ")
[09:31:11.507]                         if (!has_future) {
[09:31:11.507]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.507]                             info)
[09:31:11.507]                         }
[09:31:11.507]                         else {
[09:31:11.507]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.507]                             info, version)
[09:31:11.507]                         }
[09:31:11.507]                         base::stop(msg)
[09:31:11.507]                       }
[09:31:11.507]                     })
[09:31:11.507]                   }
[09:31:11.507]                   ...future.strategy.old <- future::plan("list")
[09:31:11.507]                   options(future.plan = NULL)
[09:31:11.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.507]                 }
[09:31:11.507]                 ...future.workdir <- getwd()
[09:31:11.507]             }
[09:31:11.507]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.507]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.507]         }
[09:31:11.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.507]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.507]             base::names(...future.oldOptions))
[09:31:11.507]     }
[09:31:11.507]     if (FALSE) {
[09:31:11.507]     }
[09:31:11.507]     else {
[09:31:11.507]         if (TRUE) {
[09:31:11.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.507]                 open = "w")
[09:31:11.507]         }
[09:31:11.507]         else {
[09:31:11.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.507]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.507]         }
[09:31:11.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.507]             base::sink(type = "output", split = FALSE)
[09:31:11.507]             base::close(...future.stdout)
[09:31:11.507]         }, add = TRUE)
[09:31:11.507]     }
[09:31:11.507]     ...future.frame <- base::sys.nframe()
[09:31:11.507]     ...future.conditions <- base::list()
[09:31:11.507]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.507]     if (FALSE) {
[09:31:11.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.507]     }
[09:31:11.507]     ...future.result <- base::tryCatch({
[09:31:11.507]         base::withCallingHandlers({
[09:31:11.507]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.507]             future::FutureResult(value = ...future.value$value, 
[09:31:11.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.507]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.507]                     ...future.globalenv.names))
[09:31:11.507]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.507]         }, condition = base::local({
[09:31:11.507]             c <- base::c
[09:31:11.507]             inherits <- base::inherits
[09:31:11.507]             invokeRestart <- base::invokeRestart
[09:31:11.507]             length <- base::length
[09:31:11.507]             list <- base::list
[09:31:11.507]             seq.int <- base::seq.int
[09:31:11.507]             signalCondition <- base::signalCondition
[09:31:11.507]             sys.calls <- base::sys.calls
[09:31:11.507]             `[[` <- base::`[[`
[09:31:11.507]             `+` <- base::`+`
[09:31:11.507]             `<<-` <- base::`<<-`
[09:31:11.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.507]                   3L)]
[09:31:11.507]             }
[09:31:11.507]             function(cond) {
[09:31:11.507]                 is_error <- inherits(cond, "error")
[09:31:11.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.507]                   NULL)
[09:31:11.507]                 if (is_error) {
[09:31:11.507]                   sessionInformation <- function() {
[09:31:11.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.507]                       search = base::search(), system = base::Sys.info())
[09:31:11.507]                   }
[09:31:11.507]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.507]                     cond$call), session = sessionInformation(), 
[09:31:11.507]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.507]                   signalCondition(cond)
[09:31:11.507]                 }
[09:31:11.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.507]                 "immediateCondition"))) {
[09:31:11.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.507]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.507]                   if (TRUE && !signal) {
[09:31:11.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.507]                     {
[09:31:11.507]                       inherits <- base::inherits
[09:31:11.507]                       invokeRestart <- base::invokeRestart
[09:31:11.507]                       is.null <- base::is.null
[09:31:11.507]                       muffled <- FALSE
[09:31:11.507]                       if (inherits(cond, "message")) {
[09:31:11.507]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.507]                         if (muffled) 
[09:31:11.507]                           invokeRestart("muffleMessage")
[09:31:11.507]                       }
[09:31:11.507]                       else if (inherits(cond, "warning")) {
[09:31:11.507]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.507]                         if (muffled) 
[09:31:11.507]                           invokeRestart("muffleWarning")
[09:31:11.507]                       }
[09:31:11.507]                       else if (inherits(cond, "condition")) {
[09:31:11.507]                         if (!is.null(pattern)) {
[09:31:11.507]                           computeRestarts <- base::computeRestarts
[09:31:11.507]                           grepl <- base::grepl
[09:31:11.507]                           restarts <- computeRestarts(cond)
[09:31:11.507]                           for (restart in restarts) {
[09:31:11.507]                             name <- restart$name
[09:31:11.507]                             if (is.null(name)) 
[09:31:11.507]                               next
[09:31:11.507]                             if (!grepl(pattern, name)) 
[09:31:11.507]                               next
[09:31:11.507]                             invokeRestart(restart)
[09:31:11.507]                             muffled <- TRUE
[09:31:11.507]                             break
[09:31:11.507]                           }
[09:31:11.507]                         }
[09:31:11.507]                       }
[09:31:11.507]                       invisible(muffled)
[09:31:11.507]                     }
[09:31:11.507]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.507]                   }
[09:31:11.507]                 }
[09:31:11.507]                 else {
[09:31:11.507]                   if (TRUE) {
[09:31:11.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.507]                     {
[09:31:11.507]                       inherits <- base::inherits
[09:31:11.507]                       invokeRestart <- base::invokeRestart
[09:31:11.507]                       is.null <- base::is.null
[09:31:11.507]                       muffled <- FALSE
[09:31:11.507]                       if (inherits(cond, "message")) {
[09:31:11.507]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.507]                         if (muffled) 
[09:31:11.507]                           invokeRestart("muffleMessage")
[09:31:11.507]                       }
[09:31:11.507]                       else if (inherits(cond, "warning")) {
[09:31:11.507]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.507]                         if (muffled) 
[09:31:11.507]                           invokeRestart("muffleWarning")
[09:31:11.507]                       }
[09:31:11.507]                       else if (inherits(cond, "condition")) {
[09:31:11.507]                         if (!is.null(pattern)) {
[09:31:11.507]                           computeRestarts <- base::computeRestarts
[09:31:11.507]                           grepl <- base::grepl
[09:31:11.507]                           restarts <- computeRestarts(cond)
[09:31:11.507]                           for (restart in restarts) {
[09:31:11.507]                             name <- restart$name
[09:31:11.507]                             if (is.null(name)) 
[09:31:11.507]                               next
[09:31:11.507]                             if (!grepl(pattern, name)) 
[09:31:11.507]                               next
[09:31:11.507]                             invokeRestart(restart)
[09:31:11.507]                             muffled <- TRUE
[09:31:11.507]                             break
[09:31:11.507]                           }
[09:31:11.507]                         }
[09:31:11.507]                       }
[09:31:11.507]                       invisible(muffled)
[09:31:11.507]                     }
[09:31:11.507]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.507]                   }
[09:31:11.507]                 }
[09:31:11.507]             }
[09:31:11.507]         }))
[09:31:11.507]     }, error = function(ex) {
[09:31:11.507]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.507]                 ...future.rng), started = ...future.startTime, 
[09:31:11.507]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.507]             version = "1.8"), class = "FutureResult")
[09:31:11.507]     }, finally = {
[09:31:11.507]         if (!identical(...future.workdir, getwd())) 
[09:31:11.507]             setwd(...future.workdir)
[09:31:11.507]         {
[09:31:11.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.507]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.507]             }
[09:31:11.507]             base::options(...future.oldOptions)
[09:31:11.507]             if (.Platform$OS.type == "windows") {
[09:31:11.507]                 old_names <- names(...future.oldEnvVars)
[09:31:11.507]                 envs <- base::Sys.getenv()
[09:31:11.507]                 names <- names(envs)
[09:31:11.507]                 common <- intersect(names, old_names)
[09:31:11.507]                 added <- setdiff(names, old_names)
[09:31:11.507]                 removed <- setdiff(old_names, names)
[09:31:11.507]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.507]                   envs[common]]
[09:31:11.507]                 NAMES <- toupper(changed)
[09:31:11.507]                 args <- list()
[09:31:11.507]                 for (kk in seq_along(NAMES)) {
[09:31:11.507]                   name <- changed[[kk]]
[09:31:11.507]                   NAME <- NAMES[[kk]]
[09:31:11.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.507]                     next
[09:31:11.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.507]                 }
[09:31:11.507]                 NAMES <- toupper(added)
[09:31:11.507]                 for (kk in seq_along(NAMES)) {
[09:31:11.507]                   name <- added[[kk]]
[09:31:11.507]                   NAME <- NAMES[[kk]]
[09:31:11.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.507]                     next
[09:31:11.507]                   args[[name]] <- ""
[09:31:11.507]                 }
[09:31:11.507]                 NAMES <- toupper(removed)
[09:31:11.507]                 for (kk in seq_along(NAMES)) {
[09:31:11.507]                   name <- removed[[kk]]
[09:31:11.507]                   NAME <- NAMES[[kk]]
[09:31:11.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.507]                     next
[09:31:11.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.507]                 }
[09:31:11.507]                 if (length(args) > 0) 
[09:31:11.507]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.507]             }
[09:31:11.507]             else {
[09:31:11.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.507]             }
[09:31:11.507]             {
[09:31:11.507]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.507]                   0L) {
[09:31:11.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.507]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.507]                   base::options(opts)
[09:31:11.507]                 }
[09:31:11.507]                 {
[09:31:11.507]                   {
[09:31:11.507]                     NULL
[09:31:11.507]                     RNGkind("Mersenne-Twister")
[09:31:11.507]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.507]                       inherits = FALSE)
[09:31:11.507]                   }
[09:31:11.507]                   options(future.plan = NULL)
[09:31:11.507]                   if (is.na(NA_character_)) 
[09:31:11.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.507]                     .init = FALSE)
[09:31:11.507]                 }
[09:31:11.507]             }
[09:31:11.507]         }
[09:31:11.507]     })
[09:31:11.507]     if (TRUE) {
[09:31:11.507]         base::sink(type = "output", split = FALSE)
[09:31:11.507]         if (TRUE) {
[09:31:11.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.507]         }
[09:31:11.507]         else {
[09:31:11.507]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.507]         }
[09:31:11.507]         base::close(...future.stdout)
[09:31:11.507]         ...future.stdout <- NULL
[09:31:11.507]     }
[09:31:11.507]     ...future.result$conditions <- ...future.conditions
[09:31:11.507]     ...future.result$finished <- base::Sys.time()
[09:31:11.507]     ...future.result
[09:31:11.507] }
[09:31:11.509] plan(): Setting new future strategy stack:
[09:31:11.509] List of future strategies:
[09:31:11.509] 1. sequential:
[09:31:11.509]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.509]    - tweaked: FALSE
[09:31:11.509]    - call: NULL
[09:31:11.510] plan(): nbrOfWorkers() = 1
[09:31:11.511] plan(): Setting new future strategy stack:
[09:31:11.511] List of future strategies:
[09:31:11.511] 1. sequential:
[09:31:11.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.511]    - tweaked: FALSE
[09:31:11.511]    - call: plan(strategy)
[09:31:11.511] plan(): nbrOfWorkers() = 1
[09:31:11.511] SequentialFuture started (and completed)
[09:31:11.512] - Launch lazy future ... done
[09:31:11.512] run() for ‘SequentialFuture’ ... done
[09:31:11.512] getGlobalsAndPackages() ...
[09:31:11.512] Searching for globals...
[09:31:11.512] 
[09:31:11.513] Searching for globals ... DONE
[09:31:11.513] - globals: [0] <none>
[09:31:11.513] getGlobalsAndPackages() ... DONE
[09:31:11.513] run() for ‘Future’ ...
[09:31:11.513] - state: ‘created’
[09:31:11.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.514]   - Field: ‘label’
[09:31:11.514]   - Field: ‘local’
[09:31:11.514]   - Field: ‘owner’
[09:31:11.514]   - Field: ‘envir’
[09:31:11.514]   - Field: ‘packages’
[09:31:11.514]   - Field: ‘gc’
[09:31:11.514]   - Field: ‘conditions’
[09:31:11.514]   - Field: ‘expr’
[09:31:11.514]   - Field: ‘uuid’
[09:31:11.514]   - Field: ‘seed’
[09:31:11.514]   - Field: ‘version’
[09:31:11.515]   - Field: ‘result’
[09:31:11.515]   - Field: ‘asynchronous’
[09:31:11.515]   - Field: ‘calls’
[09:31:11.515]   - Field: ‘globals’
[09:31:11.515]   - Field: ‘stdout’
[09:31:11.515]   - Field: ‘earlySignal’
[09:31:11.515]   - Field: ‘lazy’
[09:31:11.515]   - Field: ‘state’
[09:31:11.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.515] - Launch lazy future ...
[09:31:11.515] Packages needed by the future expression (n = 0): <none>
[09:31:11.516] Packages needed by future strategies (n = 0): <none>
[09:31:11.516] {
[09:31:11.516]     {
[09:31:11.516]         {
[09:31:11.516]             ...future.startTime <- base::Sys.time()
[09:31:11.516]             {
[09:31:11.516]                 {
[09:31:11.516]                   {
[09:31:11.516]                     base::local({
[09:31:11.516]                       has_future <- base::requireNamespace("future", 
[09:31:11.516]                         quietly = TRUE)
[09:31:11.516]                       if (has_future) {
[09:31:11.516]                         ns <- base::getNamespace("future")
[09:31:11.516]                         version <- ns[[".package"]][["version"]]
[09:31:11.516]                         if (is.null(version)) 
[09:31:11.516]                           version <- utils::packageVersion("future")
[09:31:11.516]                       }
[09:31:11.516]                       else {
[09:31:11.516]                         version <- NULL
[09:31:11.516]                       }
[09:31:11.516]                       if (!has_future || version < "1.8.0") {
[09:31:11.516]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.516]                           "", base::R.version$version.string), 
[09:31:11.516]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.516]                             "release", "version")], collapse = " "), 
[09:31:11.516]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.516]                           info)
[09:31:11.516]                         info <- base::paste(info, collapse = "; ")
[09:31:11.516]                         if (!has_future) {
[09:31:11.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.516]                             info)
[09:31:11.516]                         }
[09:31:11.516]                         else {
[09:31:11.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.516]                             info, version)
[09:31:11.516]                         }
[09:31:11.516]                         base::stop(msg)
[09:31:11.516]                       }
[09:31:11.516]                     })
[09:31:11.516]                   }
[09:31:11.516]                   ...future.strategy.old <- future::plan("list")
[09:31:11.516]                   options(future.plan = NULL)
[09:31:11.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.516]                 }
[09:31:11.516]                 ...future.workdir <- getwd()
[09:31:11.516]             }
[09:31:11.516]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.516]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.516]         }
[09:31:11.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.516]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.516]             base::names(...future.oldOptions))
[09:31:11.516]     }
[09:31:11.516]     if (FALSE) {
[09:31:11.516]     }
[09:31:11.516]     else {
[09:31:11.516]         if (TRUE) {
[09:31:11.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.516]                 open = "w")
[09:31:11.516]         }
[09:31:11.516]         else {
[09:31:11.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.516]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.516]         }
[09:31:11.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.516]             base::sink(type = "output", split = FALSE)
[09:31:11.516]             base::close(...future.stdout)
[09:31:11.516]         }, add = TRUE)
[09:31:11.516]     }
[09:31:11.516]     ...future.frame <- base::sys.nframe()
[09:31:11.516]     ...future.conditions <- base::list()
[09:31:11.516]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.516]     if (FALSE) {
[09:31:11.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.516]     }
[09:31:11.516]     ...future.result <- base::tryCatch({
[09:31:11.516]         base::withCallingHandlers({
[09:31:11.516]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.516]             future::FutureResult(value = ...future.value$value, 
[09:31:11.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.516]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.516]                     ...future.globalenv.names))
[09:31:11.516]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.516]         }, condition = base::local({
[09:31:11.516]             c <- base::c
[09:31:11.516]             inherits <- base::inherits
[09:31:11.516]             invokeRestart <- base::invokeRestart
[09:31:11.516]             length <- base::length
[09:31:11.516]             list <- base::list
[09:31:11.516]             seq.int <- base::seq.int
[09:31:11.516]             signalCondition <- base::signalCondition
[09:31:11.516]             sys.calls <- base::sys.calls
[09:31:11.516]             `[[` <- base::`[[`
[09:31:11.516]             `+` <- base::`+`
[09:31:11.516]             `<<-` <- base::`<<-`
[09:31:11.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.516]                   3L)]
[09:31:11.516]             }
[09:31:11.516]             function(cond) {
[09:31:11.516]                 is_error <- inherits(cond, "error")
[09:31:11.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.516]                   NULL)
[09:31:11.516]                 if (is_error) {
[09:31:11.516]                   sessionInformation <- function() {
[09:31:11.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.516]                       search = base::search(), system = base::Sys.info())
[09:31:11.516]                   }
[09:31:11.516]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.516]                     cond$call), session = sessionInformation(), 
[09:31:11.516]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.516]                   signalCondition(cond)
[09:31:11.516]                 }
[09:31:11.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.516]                 "immediateCondition"))) {
[09:31:11.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.516]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.516]                   if (TRUE && !signal) {
[09:31:11.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.516]                     {
[09:31:11.516]                       inherits <- base::inherits
[09:31:11.516]                       invokeRestart <- base::invokeRestart
[09:31:11.516]                       is.null <- base::is.null
[09:31:11.516]                       muffled <- FALSE
[09:31:11.516]                       if (inherits(cond, "message")) {
[09:31:11.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.516]                         if (muffled) 
[09:31:11.516]                           invokeRestart("muffleMessage")
[09:31:11.516]                       }
[09:31:11.516]                       else if (inherits(cond, "warning")) {
[09:31:11.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.516]                         if (muffled) 
[09:31:11.516]                           invokeRestart("muffleWarning")
[09:31:11.516]                       }
[09:31:11.516]                       else if (inherits(cond, "condition")) {
[09:31:11.516]                         if (!is.null(pattern)) {
[09:31:11.516]                           computeRestarts <- base::computeRestarts
[09:31:11.516]                           grepl <- base::grepl
[09:31:11.516]                           restarts <- computeRestarts(cond)
[09:31:11.516]                           for (restart in restarts) {
[09:31:11.516]                             name <- restart$name
[09:31:11.516]                             if (is.null(name)) 
[09:31:11.516]                               next
[09:31:11.516]                             if (!grepl(pattern, name)) 
[09:31:11.516]                               next
[09:31:11.516]                             invokeRestart(restart)
[09:31:11.516]                             muffled <- TRUE
[09:31:11.516]                             break
[09:31:11.516]                           }
[09:31:11.516]                         }
[09:31:11.516]                       }
[09:31:11.516]                       invisible(muffled)
[09:31:11.516]                     }
[09:31:11.516]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.516]                   }
[09:31:11.516]                 }
[09:31:11.516]                 else {
[09:31:11.516]                   if (TRUE) {
[09:31:11.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.516]                     {
[09:31:11.516]                       inherits <- base::inherits
[09:31:11.516]                       invokeRestart <- base::invokeRestart
[09:31:11.516]                       is.null <- base::is.null
[09:31:11.516]                       muffled <- FALSE
[09:31:11.516]                       if (inherits(cond, "message")) {
[09:31:11.516]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.516]                         if (muffled) 
[09:31:11.516]                           invokeRestart("muffleMessage")
[09:31:11.516]                       }
[09:31:11.516]                       else if (inherits(cond, "warning")) {
[09:31:11.516]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.516]                         if (muffled) 
[09:31:11.516]                           invokeRestart("muffleWarning")
[09:31:11.516]                       }
[09:31:11.516]                       else if (inherits(cond, "condition")) {
[09:31:11.516]                         if (!is.null(pattern)) {
[09:31:11.516]                           computeRestarts <- base::computeRestarts
[09:31:11.516]                           grepl <- base::grepl
[09:31:11.516]                           restarts <- computeRestarts(cond)
[09:31:11.516]                           for (restart in restarts) {
[09:31:11.516]                             name <- restart$name
[09:31:11.516]                             if (is.null(name)) 
[09:31:11.516]                               next
[09:31:11.516]                             if (!grepl(pattern, name)) 
[09:31:11.516]                               next
[09:31:11.516]                             invokeRestart(restart)
[09:31:11.516]                             muffled <- TRUE
[09:31:11.516]                             break
[09:31:11.516]                           }
[09:31:11.516]                         }
[09:31:11.516]                       }
[09:31:11.516]                       invisible(muffled)
[09:31:11.516]                     }
[09:31:11.516]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.516]                   }
[09:31:11.516]                 }
[09:31:11.516]             }
[09:31:11.516]         }))
[09:31:11.516]     }, error = function(ex) {
[09:31:11.516]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.516]                 ...future.rng), started = ...future.startTime, 
[09:31:11.516]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.516]             version = "1.8"), class = "FutureResult")
[09:31:11.516]     }, finally = {
[09:31:11.516]         if (!identical(...future.workdir, getwd())) 
[09:31:11.516]             setwd(...future.workdir)
[09:31:11.516]         {
[09:31:11.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.516]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.516]             }
[09:31:11.516]             base::options(...future.oldOptions)
[09:31:11.516]             if (.Platform$OS.type == "windows") {
[09:31:11.516]                 old_names <- names(...future.oldEnvVars)
[09:31:11.516]                 envs <- base::Sys.getenv()
[09:31:11.516]                 names <- names(envs)
[09:31:11.516]                 common <- intersect(names, old_names)
[09:31:11.516]                 added <- setdiff(names, old_names)
[09:31:11.516]                 removed <- setdiff(old_names, names)
[09:31:11.516]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.516]                   envs[common]]
[09:31:11.516]                 NAMES <- toupper(changed)
[09:31:11.516]                 args <- list()
[09:31:11.516]                 for (kk in seq_along(NAMES)) {
[09:31:11.516]                   name <- changed[[kk]]
[09:31:11.516]                   NAME <- NAMES[[kk]]
[09:31:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.516]                     next
[09:31:11.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.516]                 }
[09:31:11.516]                 NAMES <- toupper(added)
[09:31:11.516]                 for (kk in seq_along(NAMES)) {
[09:31:11.516]                   name <- added[[kk]]
[09:31:11.516]                   NAME <- NAMES[[kk]]
[09:31:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.516]                     next
[09:31:11.516]                   args[[name]] <- ""
[09:31:11.516]                 }
[09:31:11.516]                 NAMES <- toupper(removed)
[09:31:11.516]                 for (kk in seq_along(NAMES)) {
[09:31:11.516]                   name <- removed[[kk]]
[09:31:11.516]                   NAME <- NAMES[[kk]]
[09:31:11.516]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.516]                     next
[09:31:11.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.516]                 }
[09:31:11.516]                 if (length(args) > 0) 
[09:31:11.516]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.516]             }
[09:31:11.516]             else {
[09:31:11.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.516]             }
[09:31:11.516]             {
[09:31:11.516]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.516]                   0L) {
[09:31:11.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.516]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.516]                   base::options(opts)
[09:31:11.516]                 }
[09:31:11.516]                 {
[09:31:11.516]                   {
[09:31:11.516]                     NULL
[09:31:11.516]                     RNGkind("Mersenne-Twister")
[09:31:11.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.516]                       inherits = FALSE)
[09:31:11.516]                   }
[09:31:11.516]                   options(future.plan = NULL)
[09:31:11.516]                   if (is.na(NA_character_)) 
[09:31:11.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.516]                     .init = FALSE)
[09:31:11.516]                 }
[09:31:11.516]             }
[09:31:11.516]         }
[09:31:11.516]     })
[09:31:11.516]     if (TRUE) {
[09:31:11.516]         base::sink(type = "output", split = FALSE)
[09:31:11.516]         if (TRUE) {
[09:31:11.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.516]         }
[09:31:11.516]         else {
[09:31:11.516]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.516]         }
[09:31:11.516]         base::close(...future.stdout)
[09:31:11.516]         ...future.stdout <- NULL
[09:31:11.516]     }
[09:31:11.516]     ...future.result$conditions <- ...future.conditions
[09:31:11.516]     ...future.result$finished <- base::Sys.time()
[09:31:11.516]     ...future.result
[09:31:11.516] }
[09:31:11.518] plan(): Setting new future strategy stack:
[09:31:11.518] List of future strategies:
[09:31:11.518] 1. sequential:
[09:31:11.518]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.518]    - tweaked: FALSE
[09:31:11.518]    - call: NULL
[09:31:11.518] plan(): nbrOfWorkers() = 1
[09:31:11.519] plan(): Setting new future strategy stack:
[09:31:11.519] List of future strategies:
[09:31:11.519] 1. sequential:
[09:31:11.519]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.519]    - tweaked: FALSE
[09:31:11.519]    - call: plan(strategy)
[09:31:11.519] plan(): nbrOfWorkers() = 1
[09:31:11.519] SequentialFuture started (and completed)
[09:31:11.519] - Launch lazy future ... done
[09:31:11.520] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c9710818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c94ca3b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c9710818> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c94ca3b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[09:31:11.525] resolved() for ‘SequentialFuture’ ...
[09:31:11.525] - state: ‘finished’
[09:31:11.525] - run: TRUE
[09:31:11.525] - result: ‘FutureResult’
[09:31:11.526] resolved() for ‘SequentialFuture’ ... done
[09:31:11.526] resolved() for ‘SequentialFuture’ ...
[09:31:11.526] - state: ‘finished’
[09:31:11.526] - run: TRUE
[09:31:11.526] - result: ‘FutureResult’
[09:31:11.526] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:11.527] resolve() on list ...
[09:31:11.527]  recursive: 0
[09:31:11.527]  length: 6
[09:31:11.527]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:11.527] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.528] - nx: 6
[09:31:11.528] - relay: TRUE
[09:31:11.528] - stdout: TRUE
[09:31:11.528] - signal: TRUE
[09:31:11.528] - resignal: FALSE
[09:31:11.528] - force: TRUE
[09:31:11.528] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.528] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.528]  - until=2
[09:31:11.528]  - relaying element #2
[09:31:11.528] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.528] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.529] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.529]  length: 5 (resolved future 1)
[09:31:11.529] resolved() for ‘SequentialFuture’ ...
[09:31:11.529] - state: ‘finished’
[09:31:11.529] - run: TRUE
[09:31:11.529] - result: ‘FutureResult’
[09:31:11.529] resolved() for ‘SequentialFuture’ ... done
[09:31:11.529] Future #2
[09:31:11.530] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.530] - nx: 6
[09:31:11.530] - relay: TRUE
[09:31:11.530] - stdout: TRUE
[09:31:11.530] - signal: TRUE
[09:31:11.530] - resignal: FALSE
[09:31:11.530] - force: TRUE
[09:31:11.530] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.530] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.530]  - until=2
[09:31:11.530]  - relaying element #2
[09:31:11.530] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.531] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.531] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.531]  length: 4 (resolved future 2)
[09:31:11.531] resolved() for ‘SequentialFuture’ ...
[09:31:11.531] - state: ‘finished’
[09:31:11.531] - run: TRUE
[09:31:11.531] - result: ‘FutureResult’
[09:31:11.531] resolved() for ‘SequentialFuture’ ... done
[09:31:11.531] Future #3
[09:31:11.532] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.532] - nx: 6
[09:31:11.532] - relay: TRUE
[09:31:11.532] - stdout: TRUE
[09:31:11.532] - signal: TRUE
[09:31:11.532] - resignal: FALSE
[09:31:11.532] - force: TRUE
[09:31:11.532] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.532] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.532]  - until=3
[09:31:11.532]  - relaying element #3
[09:31:11.533] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.533] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.533] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.533]  length: 3 (resolved future 3)
[09:31:11.533] signalConditionsASAP(NULL, pos=4) ...
[09:31:11.533] - nx: 6
[09:31:11.533] - relay: TRUE
[09:31:11.533] - stdout: TRUE
[09:31:11.533] - signal: TRUE
[09:31:11.533] - resignal: FALSE
[09:31:11.533] - force: TRUE
[09:31:11.533] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.533] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.534]  - until=5
[09:31:11.534]  - relaying element #5
[09:31:11.534] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.534] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.534] signalConditionsASAP(NULL, pos=4) ... done
[09:31:11.534]  length: 2 (resolved future 4)
[09:31:11.534] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.534] - nx: 6
[09:31:11.534] - relay: TRUE
[09:31:11.534] - stdout: TRUE
[09:31:11.534] - signal: TRUE
[09:31:11.534] - resignal: FALSE
[09:31:11.535] - force: TRUE
[09:31:11.535] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.535] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.535]  - until=6
[09:31:11.535]  - relaying element #6
[09:31:11.535] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.535] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.535] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.535]  length: 1 (resolved future 5)
[09:31:11.535] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.535] - nx: 6
[09:31:11.535] - relay: TRUE
[09:31:11.537] - stdout: TRUE
[09:31:11.537] - signal: TRUE
[09:31:11.537] - resignal: FALSE
[09:31:11.537] - force: TRUE
[09:31:11.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.537] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.537]  - until=6
[09:31:11.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.538] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.538] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.538]  length: 0 (resolved future 6)
[09:31:11.538] Relaying remaining futures
[09:31:11.538] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.538] - nx: 6
[09:31:11.538] - relay: TRUE
[09:31:11.538] - stdout: TRUE
[09:31:11.538] - signal: TRUE
[09:31:11.538] - resignal: FALSE
[09:31:11.538] - force: TRUE
[09:31:11.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:11.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.539] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.539] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.539] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[09:31:11.541] getGlobalsAndPackages() ...
[09:31:11.541] Searching for globals...
[09:31:11.541] 
[09:31:11.541] Searching for globals ... DONE
[09:31:11.542] - globals: [0] <none>
[09:31:11.542] getGlobalsAndPackages() ... DONE
[09:31:11.542] run() for ‘Future’ ...
[09:31:11.542] - state: ‘created’
[09:31:11.542] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.543] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.543]   - Field: ‘label’
[09:31:11.543]   - Field: ‘local’
[09:31:11.543]   - Field: ‘owner’
[09:31:11.543]   - Field: ‘envir’
[09:31:11.543]   - Field: ‘packages’
[09:31:11.543]   - Field: ‘gc’
[09:31:11.544]   - Field: ‘conditions’
[09:31:11.544]   - Field: ‘expr’
[09:31:11.544]   - Field: ‘uuid’
[09:31:11.544]   - Field: ‘seed’
[09:31:11.544]   - Field: ‘version’
[09:31:11.544]   - Field: ‘result’
[09:31:11.544]   - Field: ‘asynchronous’
[09:31:11.544]   - Field: ‘calls’
[09:31:11.545]   - Field: ‘globals’
[09:31:11.545]   - Field: ‘stdout’
[09:31:11.545]   - Field: ‘earlySignal’
[09:31:11.545]   - Field: ‘lazy’
[09:31:11.545]   - Field: ‘state’
[09:31:11.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.545] - Launch lazy future ...
[09:31:11.545] Packages needed by the future expression (n = 0): <none>
[09:31:11.545] Packages needed by future strategies (n = 0): <none>
[09:31:11.546] {
[09:31:11.546]     {
[09:31:11.546]         {
[09:31:11.546]             ...future.startTime <- base::Sys.time()
[09:31:11.546]             {
[09:31:11.546]                 {
[09:31:11.546]                   {
[09:31:11.546]                     base::local({
[09:31:11.546]                       has_future <- base::requireNamespace("future", 
[09:31:11.546]                         quietly = TRUE)
[09:31:11.546]                       if (has_future) {
[09:31:11.546]                         ns <- base::getNamespace("future")
[09:31:11.546]                         version <- ns[[".package"]][["version"]]
[09:31:11.546]                         if (is.null(version)) 
[09:31:11.546]                           version <- utils::packageVersion("future")
[09:31:11.546]                       }
[09:31:11.546]                       else {
[09:31:11.546]                         version <- NULL
[09:31:11.546]                       }
[09:31:11.546]                       if (!has_future || version < "1.8.0") {
[09:31:11.546]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.546]                           "", base::R.version$version.string), 
[09:31:11.546]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.546]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.546]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.546]                             "release", "version")], collapse = " "), 
[09:31:11.546]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.546]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.546]                           info)
[09:31:11.546]                         info <- base::paste(info, collapse = "; ")
[09:31:11.546]                         if (!has_future) {
[09:31:11.546]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.546]                             info)
[09:31:11.546]                         }
[09:31:11.546]                         else {
[09:31:11.546]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.546]                             info, version)
[09:31:11.546]                         }
[09:31:11.546]                         base::stop(msg)
[09:31:11.546]                       }
[09:31:11.546]                     })
[09:31:11.546]                   }
[09:31:11.546]                   ...future.strategy.old <- future::plan("list")
[09:31:11.546]                   options(future.plan = NULL)
[09:31:11.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.546]                 }
[09:31:11.546]                 ...future.workdir <- getwd()
[09:31:11.546]             }
[09:31:11.546]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.546]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.546]         }
[09:31:11.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.546]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.546]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.546]             base::names(...future.oldOptions))
[09:31:11.546]     }
[09:31:11.546]     if (FALSE) {
[09:31:11.546]     }
[09:31:11.546]     else {
[09:31:11.546]         if (TRUE) {
[09:31:11.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.546]                 open = "w")
[09:31:11.546]         }
[09:31:11.546]         else {
[09:31:11.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.546]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.546]         }
[09:31:11.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.546]             base::sink(type = "output", split = FALSE)
[09:31:11.546]             base::close(...future.stdout)
[09:31:11.546]         }, add = TRUE)
[09:31:11.546]     }
[09:31:11.546]     ...future.frame <- base::sys.nframe()
[09:31:11.546]     ...future.conditions <- base::list()
[09:31:11.546]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.546]     if (FALSE) {
[09:31:11.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.546]     }
[09:31:11.546]     ...future.result <- base::tryCatch({
[09:31:11.546]         base::withCallingHandlers({
[09:31:11.546]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.546]             future::FutureResult(value = ...future.value$value, 
[09:31:11.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.546]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.546]                     ...future.globalenv.names))
[09:31:11.546]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.546]         }, condition = base::local({
[09:31:11.546]             c <- base::c
[09:31:11.546]             inherits <- base::inherits
[09:31:11.546]             invokeRestart <- base::invokeRestart
[09:31:11.546]             length <- base::length
[09:31:11.546]             list <- base::list
[09:31:11.546]             seq.int <- base::seq.int
[09:31:11.546]             signalCondition <- base::signalCondition
[09:31:11.546]             sys.calls <- base::sys.calls
[09:31:11.546]             `[[` <- base::`[[`
[09:31:11.546]             `+` <- base::`+`
[09:31:11.546]             `<<-` <- base::`<<-`
[09:31:11.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.546]                   3L)]
[09:31:11.546]             }
[09:31:11.546]             function(cond) {
[09:31:11.546]                 is_error <- inherits(cond, "error")
[09:31:11.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.546]                   NULL)
[09:31:11.546]                 if (is_error) {
[09:31:11.546]                   sessionInformation <- function() {
[09:31:11.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.546]                       search = base::search(), system = base::Sys.info())
[09:31:11.546]                   }
[09:31:11.546]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.546]                     cond$call), session = sessionInformation(), 
[09:31:11.546]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.546]                   signalCondition(cond)
[09:31:11.546]                 }
[09:31:11.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.546]                 "immediateCondition"))) {
[09:31:11.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.546]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.546]                   if (TRUE && !signal) {
[09:31:11.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.546]                     {
[09:31:11.546]                       inherits <- base::inherits
[09:31:11.546]                       invokeRestart <- base::invokeRestart
[09:31:11.546]                       is.null <- base::is.null
[09:31:11.546]                       muffled <- FALSE
[09:31:11.546]                       if (inherits(cond, "message")) {
[09:31:11.546]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.546]                         if (muffled) 
[09:31:11.546]                           invokeRestart("muffleMessage")
[09:31:11.546]                       }
[09:31:11.546]                       else if (inherits(cond, "warning")) {
[09:31:11.546]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.546]                         if (muffled) 
[09:31:11.546]                           invokeRestart("muffleWarning")
[09:31:11.546]                       }
[09:31:11.546]                       else if (inherits(cond, "condition")) {
[09:31:11.546]                         if (!is.null(pattern)) {
[09:31:11.546]                           computeRestarts <- base::computeRestarts
[09:31:11.546]                           grepl <- base::grepl
[09:31:11.546]                           restarts <- computeRestarts(cond)
[09:31:11.546]                           for (restart in restarts) {
[09:31:11.546]                             name <- restart$name
[09:31:11.546]                             if (is.null(name)) 
[09:31:11.546]                               next
[09:31:11.546]                             if (!grepl(pattern, name)) 
[09:31:11.546]                               next
[09:31:11.546]                             invokeRestart(restart)
[09:31:11.546]                             muffled <- TRUE
[09:31:11.546]                             break
[09:31:11.546]                           }
[09:31:11.546]                         }
[09:31:11.546]                       }
[09:31:11.546]                       invisible(muffled)
[09:31:11.546]                     }
[09:31:11.546]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.546]                   }
[09:31:11.546]                 }
[09:31:11.546]                 else {
[09:31:11.546]                   if (TRUE) {
[09:31:11.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.546]                     {
[09:31:11.546]                       inherits <- base::inherits
[09:31:11.546]                       invokeRestart <- base::invokeRestart
[09:31:11.546]                       is.null <- base::is.null
[09:31:11.546]                       muffled <- FALSE
[09:31:11.546]                       if (inherits(cond, "message")) {
[09:31:11.546]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.546]                         if (muffled) 
[09:31:11.546]                           invokeRestart("muffleMessage")
[09:31:11.546]                       }
[09:31:11.546]                       else if (inherits(cond, "warning")) {
[09:31:11.546]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.546]                         if (muffled) 
[09:31:11.546]                           invokeRestart("muffleWarning")
[09:31:11.546]                       }
[09:31:11.546]                       else if (inherits(cond, "condition")) {
[09:31:11.546]                         if (!is.null(pattern)) {
[09:31:11.546]                           computeRestarts <- base::computeRestarts
[09:31:11.546]                           grepl <- base::grepl
[09:31:11.546]                           restarts <- computeRestarts(cond)
[09:31:11.546]                           for (restart in restarts) {
[09:31:11.546]                             name <- restart$name
[09:31:11.546]                             if (is.null(name)) 
[09:31:11.546]                               next
[09:31:11.546]                             if (!grepl(pattern, name)) 
[09:31:11.546]                               next
[09:31:11.546]                             invokeRestart(restart)
[09:31:11.546]                             muffled <- TRUE
[09:31:11.546]                             break
[09:31:11.546]                           }
[09:31:11.546]                         }
[09:31:11.546]                       }
[09:31:11.546]                       invisible(muffled)
[09:31:11.546]                     }
[09:31:11.546]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.546]                   }
[09:31:11.546]                 }
[09:31:11.546]             }
[09:31:11.546]         }))
[09:31:11.546]     }, error = function(ex) {
[09:31:11.546]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.546]                 ...future.rng), started = ...future.startTime, 
[09:31:11.546]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.546]             version = "1.8"), class = "FutureResult")
[09:31:11.546]     }, finally = {
[09:31:11.546]         if (!identical(...future.workdir, getwd())) 
[09:31:11.546]             setwd(...future.workdir)
[09:31:11.546]         {
[09:31:11.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.546]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.546]             }
[09:31:11.546]             base::options(...future.oldOptions)
[09:31:11.546]             if (.Platform$OS.type == "windows") {
[09:31:11.546]                 old_names <- names(...future.oldEnvVars)
[09:31:11.546]                 envs <- base::Sys.getenv()
[09:31:11.546]                 names <- names(envs)
[09:31:11.546]                 common <- intersect(names, old_names)
[09:31:11.546]                 added <- setdiff(names, old_names)
[09:31:11.546]                 removed <- setdiff(old_names, names)
[09:31:11.546]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.546]                   envs[common]]
[09:31:11.546]                 NAMES <- toupper(changed)
[09:31:11.546]                 args <- list()
[09:31:11.546]                 for (kk in seq_along(NAMES)) {
[09:31:11.546]                   name <- changed[[kk]]
[09:31:11.546]                   NAME <- NAMES[[kk]]
[09:31:11.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.546]                     next
[09:31:11.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.546]                 }
[09:31:11.546]                 NAMES <- toupper(added)
[09:31:11.546]                 for (kk in seq_along(NAMES)) {
[09:31:11.546]                   name <- added[[kk]]
[09:31:11.546]                   NAME <- NAMES[[kk]]
[09:31:11.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.546]                     next
[09:31:11.546]                   args[[name]] <- ""
[09:31:11.546]                 }
[09:31:11.546]                 NAMES <- toupper(removed)
[09:31:11.546]                 for (kk in seq_along(NAMES)) {
[09:31:11.546]                   name <- removed[[kk]]
[09:31:11.546]                   NAME <- NAMES[[kk]]
[09:31:11.546]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.546]                     next
[09:31:11.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.546]                 }
[09:31:11.546]                 if (length(args) > 0) 
[09:31:11.546]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.546]             }
[09:31:11.546]             else {
[09:31:11.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.546]             }
[09:31:11.546]             {
[09:31:11.546]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.546]                   0L) {
[09:31:11.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.546]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.546]                   base::options(opts)
[09:31:11.546]                 }
[09:31:11.546]                 {
[09:31:11.546]                   {
[09:31:11.546]                     NULL
[09:31:11.546]                     RNGkind("Mersenne-Twister")
[09:31:11.546]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.546]                       inherits = FALSE)
[09:31:11.546]                   }
[09:31:11.546]                   options(future.plan = NULL)
[09:31:11.546]                   if (is.na(NA_character_)) 
[09:31:11.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.546]                     .init = FALSE)
[09:31:11.546]                 }
[09:31:11.546]             }
[09:31:11.546]         }
[09:31:11.546]     })
[09:31:11.546]     if (TRUE) {
[09:31:11.546]         base::sink(type = "output", split = FALSE)
[09:31:11.546]         if (TRUE) {
[09:31:11.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.546]         }
[09:31:11.546]         else {
[09:31:11.546]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.546]         }
[09:31:11.546]         base::close(...future.stdout)
[09:31:11.546]         ...future.stdout <- NULL
[09:31:11.546]     }
[09:31:11.546]     ...future.result$conditions <- ...future.conditions
[09:31:11.546]     ...future.result$finished <- base::Sys.time()
[09:31:11.546]     ...future.result
[09:31:11.546] }
[09:31:11.548] plan(): Setting new future strategy stack:
[09:31:11.548] List of future strategies:
[09:31:11.548] 1. sequential:
[09:31:11.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.548]    - tweaked: FALSE
[09:31:11.548]    - call: NULL
[09:31:11.548] plan(): nbrOfWorkers() = 1
[09:31:11.549] plan(): Setting new future strategy stack:
[09:31:11.549] List of future strategies:
[09:31:11.549] 1. sequential:
[09:31:11.549]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.549]    - tweaked: FALSE
[09:31:11.549]    - call: plan(strategy)
[09:31:11.549] plan(): nbrOfWorkers() = 1
[09:31:11.549] SequentialFuture started (and completed)
[09:31:11.550] - Launch lazy future ... done
[09:31:11.550] run() for ‘SequentialFuture’ ... done
[09:31:11.550] getGlobalsAndPackages() ...
[09:31:11.550] Searching for globals...
[09:31:11.550] 
[09:31:11.550] Searching for globals ... DONE
[09:31:11.550] - globals: [0] <none>
[09:31:11.550] getGlobalsAndPackages() ... DONE
[09:31:11.551] run() for ‘Future’ ...
[09:31:11.551] - state: ‘created’
[09:31:11.551] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.551] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.551] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.551]   - Field: ‘label’
[09:31:11.551]   - Field: ‘local’
[09:31:11.551]   - Field: ‘owner’
[09:31:11.552]   - Field: ‘envir’
[09:31:11.552]   - Field: ‘packages’
[09:31:11.552]   - Field: ‘gc’
[09:31:11.552]   - Field: ‘conditions’
[09:31:11.552]   - Field: ‘expr’
[09:31:11.552]   - Field: ‘uuid’
[09:31:11.552]   - Field: ‘seed’
[09:31:11.552]   - Field: ‘version’
[09:31:11.552]   - Field: ‘result’
[09:31:11.552]   - Field: ‘asynchronous’
[09:31:11.553]   - Field: ‘calls’
[09:31:11.553]   - Field: ‘globals’
[09:31:11.553]   - Field: ‘stdout’
[09:31:11.553]   - Field: ‘earlySignal’
[09:31:11.553]   - Field: ‘lazy’
[09:31:11.553]   - Field: ‘state’
[09:31:11.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.553] - Launch lazy future ...
[09:31:11.553] Packages needed by the future expression (n = 0): <none>
[09:31:11.553] Packages needed by future strategies (n = 0): <none>
[09:31:11.554] {
[09:31:11.554]     {
[09:31:11.554]         {
[09:31:11.554]             ...future.startTime <- base::Sys.time()
[09:31:11.554]             {
[09:31:11.554]                 {
[09:31:11.554]                   {
[09:31:11.554]                     base::local({
[09:31:11.554]                       has_future <- base::requireNamespace("future", 
[09:31:11.554]                         quietly = TRUE)
[09:31:11.554]                       if (has_future) {
[09:31:11.554]                         ns <- base::getNamespace("future")
[09:31:11.554]                         version <- ns[[".package"]][["version"]]
[09:31:11.554]                         if (is.null(version)) 
[09:31:11.554]                           version <- utils::packageVersion("future")
[09:31:11.554]                       }
[09:31:11.554]                       else {
[09:31:11.554]                         version <- NULL
[09:31:11.554]                       }
[09:31:11.554]                       if (!has_future || version < "1.8.0") {
[09:31:11.554]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.554]                           "", base::R.version$version.string), 
[09:31:11.554]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.554]                             "release", "version")], collapse = " "), 
[09:31:11.554]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.554]                           info)
[09:31:11.554]                         info <- base::paste(info, collapse = "; ")
[09:31:11.554]                         if (!has_future) {
[09:31:11.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.554]                             info)
[09:31:11.554]                         }
[09:31:11.554]                         else {
[09:31:11.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.554]                             info, version)
[09:31:11.554]                         }
[09:31:11.554]                         base::stop(msg)
[09:31:11.554]                       }
[09:31:11.554]                     })
[09:31:11.554]                   }
[09:31:11.554]                   ...future.strategy.old <- future::plan("list")
[09:31:11.554]                   options(future.plan = NULL)
[09:31:11.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.554]                 }
[09:31:11.554]                 ...future.workdir <- getwd()
[09:31:11.554]             }
[09:31:11.554]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.554]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.554]         }
[09:31:11.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.554]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.554]             base::names(...future.oldOptions))
[09:31:11.554]     }
[09:31:11.554]     if (FALSE) {
[09:31:11.554]     }
[09:31:11.554]     else {
[09:31:11.554]         if (TRUE) {
[09:31:11.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.554]                 open = "w")
[09:31:11.554]         }
[09:31:11.554]         else {
[09:31:11.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.554]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.554]         }
[09:31:11.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.554]             base::sink(type = "output", split = FALSE)
[09:31:11.554]             base::close(...future.stdout)
[09:31:11.554]         }, add = TRUE)
[09:31:11.554]     }
[09:31:11.554]     ...future.frame <- base::sys.nframe()
[09:31:11.554]     ...future.conditions <- base::list()
[09:31:11.554]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.554]     if (FALSE) {
[09:31:11.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.554]     }
[09:31:11.554]     ...future.result <- base::tryCatch({
[09:31:11.554]         base::withCallingHandlers({
[09:31:11.554]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.554]             future::FutureResult(value = ...future.value$value, 
[09:31:11.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.554]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.554]                     ...future.globalenv.names))
[09:31:11.554]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.554]         }, condition = base::local({
[09:31:11.554]             c <- base::c
[09:31:11.554]             inherits <- base::inherits
[09:31:11.554]             invokeRestart <- base::invokeRestart
[09:31:11.554]             length <- base::length
[09:31:11.554]             list <- base::list
[09:31:11.554]             seq.int <- base::seq.int
[09:31:11.554]             signalCondition <- base::signalCondition
[09:31:11.554]             sys.calls <- base::sys.calls
[09:31:11.554]             `[[` <- base::`[[`
[09:31:11.554]             `+` <- base::`+`
[09:31:11.554]             `<<-` <- base::`<<-`
[09:31:11.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.554]                   3L)]
[09:31:11.554]             }
[09:31:11.554]             function(cond) {
[09:31:11.554]                 is_error <- inherits(cond, "error")
[09:31:11.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.554]                   NULL)
[09:31:11.554]                 if (is_error) {
[09:31:11.554]                   sessionInformation <- function() {
[09:31:11.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.554]                       search = base::search(), system = base::Sys.info())
[09:31:11.554]                   }
[09:31:11.554]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.554]                     cond$call), session = sessionInformation(), 
[09:31:11.554]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.554]                   signalCondition(cond)
[09:31:11.554]                 }
[09:31:11.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.554]                 "immediateCondition"))) {
[09:31:11.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.554]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.554]                   if (TRUE && !signal) {
[09:31:11.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.554]                     {
[09:31:11.554]                       inherits <- base::inherits
[09:31:11.554]                       invokeRestart <- base::invokeRestart
[09:31:11.554]                       is.null <- base::is.null
[09:31:11.554]                       muffled <- FALSE
[09:31:11.554]                       if (inherits(cond, "message")) {
[09:31:11.554]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.554]                         if (muffled) 
[09:31:11.554]                           invokeRestart("muffleMessage")
[09:31:11.554]                       }
[09:31:11.554]                       else if (inherits(cond, "warning")) {
[09:31:11.554]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.554]                         if (muffled) 
[09:31:11.554]                           invokeRestart("muffleWarning")
[09:31:11.554]                       }
[09:31:11.554]                       else if (inherits(cond, "condition")) {
[09:31:11.554]                         if (!is.null(pattern)) {
[09:31:11.554]                           computeRestarts <- base::computeRestarts
[09:31:11.554]                           grepl <- base::grepl
[09:31:11.554]                           restarts <- computeRestarts(cond)
[09:31:11.554]                           for (restart in restarts) {
[09:31:11.554]                             name <- restart$name
[09:31:11.554]                             if (is.null(name)) 
[09:31:11.554]                               next
[09:31:11.554]                             if (!grepl(pattern, name)) 
[09:31:11.554]                               next
[09:31:11.554]                             invokeRestart(restart)
[09:31:11.554]                             muffled <- TRUE
[09:31:11.554]                             break
[09:31:11.554]                           }
[09:31:11.554]                         }
[09:31:11.554]                       }
[09:31:11.554]                       invisible(muffled)
[09:31:11.554]                     }
[09:31:11.554]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.554]                   }
[09:31:11.554]                 }
[09:31:11.554]                 else {
[09:31:11.554]                   if (TRUE) {
[09:31:11.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.554]                     {
[09:31:11.554]                       inherits <- base::inherits
[09:31:11.554]                       invokeRestart <- base::invokeRestart
[09:31:11.554]                       is.null <- base::is.null
[09:31:11.554]                       muffled <- FALSE
[09:31:11.554]                       if (inherits(cond, "message")) {
[09:31:11.554]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.554]                         if (muffled) 
[09:31:11.554]                           invokeRestart("muffleMessage")
[09:31:11.554]                       }
[09:31:11.554]                       else if (inherits(cond, "warning")) {
[09:31:11.554]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.554]                         if (muffled) 
[09:31:11.554]                           invokeRestart("muffleWarning")
[09:31:11.554]                       }
[09:31:11.554]                       else if (inherits(cond, "condition")) {
[09:31:11.554]                         if (!is.null(pattern)) {
[09:31:11.554]                           computeRestarts <- base::computeRestarts
[09:31:11.554]                           grepl <- base::grepl
[09:31:11.554]                           restarts <- computeRestarts(cond)
[09:31:11.554]                           for (restart in restarts) {
[09:31:11.554]                             name <- restart$name
[09:31:11.554]                             if (is.null(name)) 
[09:31:11.554]                               next
[09:31:11.554]                             if (!grepl(pattern, name)) 
[09:31:11.554]                               next
[09:31:11.554]                             invokeRestart(restart)
[09:31:11.554]                             muffled <- TRUE
[09:31:11.554]                             break
[09:31:11.554]                           }
[09:31:11.554]                         }
[09:31:11.554]                       }
[09:31:11.554]                       invisible(muffled)
[09:31:11.554]                     }
[09:31:11.554]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.554]                   }
[09:31:11.554]                 }
[09:31:11.554]             }
[09:31:11.554]         }))
[09:31:11.554]     }, error = function(ex) {
[09:31:11.554]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.554]                 ...future.rng), started = ...future.startTime, 
[09:31:11.554]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.554]             version = "1.8"), class = "FutureResult")
[09:31:11.554]     }, finally = {
[09:31:11.554]         if (!identical(...future.workdir, getwd())) 
[09:31:11.554]             setwd(...future.workdir)
[09:31:11.554]         {
[09:31:11.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.554]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.554]             }
[09:31:11.554]             base::options(...future.oldOptions)
[09:31:11.554]             if (.Platform$OS.type == "windows") {
[09:31:11.554]                 old_names <- names(...future.oldEnvVars)
[09:31:11.554]                 envs <- base::Sys.getenv()
[09:31:11.554]                 names <- names(envs)
[09:31:11.554]                 common <- intersect(names, old_names)
[09:31:11.554]                 added <- setdiff(names, old_names)
[09:31:11.554]                 removed <- setdiff(old_names, names)
[09:31:11.554]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.554]                   envs[common]]
[09:31:11.554]                 NAMES <- toupper(changed)
[09:31:11.554]                 args <- list()
[09:31:11.554]                 for (kk in seq_along(NAMES)) {
[09:31:11.554]                   name <- changed[[kk]]
[09:31:11.554]                   NAME <- NAMES[[kk]]
[09:31:11.554]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.554]                     next
[09:31:11.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.554]                 }
[09:31:11.554]                 NAMES <- toupper(added)
[09:31:11.554]                 for (kk in seq_along(NAMES)) {
[09:31:11.554]                   name <- added[[kk]]
[09:31:11.554]                   NAME <- NAMES[[kk]]
[09:31:11.554]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.554]                     next
[09:31:11.554]                   args[[name]] <- ""
[09:31:11.554]                 }
[09:31:11.554]                 NAMES <- toupper(removed)
[09:31:11.554]                 for (kk in seq_along(NAMES)) {
[09:31:11.554]                   name <- removed[[kk]]
[09:31:11.554]                   NAME <- NAMES[[kk]]
[09:31:11.554]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.554]                     next
[09:31:11.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.554]                 }
[09:31:11.554]                 if (length(args) > 0) 
[09:31:11.554]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.554]             }
[09:31:11.554]             else {
[09:31:11.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.554]             }
[09:31:11.554]             {
[09:31:11.554]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.554]                   0L) {
[09:31:11.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.554]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.554]                   base::options(opts)
[09:31:11.554]                 }
[09:31:11.554]                 {
[09:31:11.554]                   {
[09:31:11.554]                     NULL
[09:31:11.554]                     RNGkind("Mersenne-Twister")
[09:31:11.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.554]                       inherits = FALSE)
[09:31:11.554]                   }
[09:31:11.554]                   options(future.plan = NULL)
[09:31:11.554]                   if (is.na(NA_character_)) 
[09:31:11.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.554]                     .init = FALSE)
[09:31:11.554]                 }
[09:31:11.554]             }
[09:31:11.554]         }
[09:31:11.554]     })
[09:31:11.554]     if (TRUE) {
[09:31:11.554]         base::sink(type = "output", split = FALSE)
[09:31:11.554]         if (TRUE) {
[09:31:11.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.554]         }
[09:31:11.554]         else {
[09:31:11.554]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.554]         }
[09:31:11.554]         base::close(...future.stdout)
[09:31:11.554]         ...future.stdout <- NULL
[09:31:11.554]     }
[09:31:11.554]     ...future.result$conditions <- ...future.conditions
[09:31:11.554]     ...future.result$finished <- base::Sys.time()
[09:31:11.554]     ...future.result
[09:31:11.554] }
[09:31:11.555] plan(): Setting new future strategy stack:
[09:31:11.556] List of future strategies:
[09:31:11.556] 1. sequential:
[09:31:11.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.556]    - tweaked: FALSE
[09:31:11.556]    - call: NULL
[09:31:11.556] plan(): nbrOfWorkers() = 1
[09:31:11.557] plan(): Setting new future strategy stack:
[09:31:11.557] List of future strategies:
[09:31:11.557] 1. sequential:
[09:31:11.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.557]    - tweaked: FALSE
[09:31:11.557]    - call: plan(strategy)
[09:31:11.557] plan(): nbrOfWorkers() = 1
[09:31:11.557] SequentialFuture started (and completed)
[09:31:11.557] - Launch lazy future ... done
[09:31:11.558] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c88182a8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca7b37a8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c88182a8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca7b37a8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[09:31:11.562] resolved() for ‘SequentialFuture’ ...
[09:31:11.562] - state: ‘finished’
[09:31:11.562] - run: TRUE
[09:31:11.563] - result: ‘FutureResult’
[09:31:11.563] resolved() for ‘SequentialFuture’ ... done
[09:31:11.563] resolved() for ‘SequentialFuture’ ...
[09:31:11.563] - state: ‘finished’
[09:31:11.563] - run: TRUE
[09:31:11.563] - result: ‘FutureResult’
[09:31:11.563] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:11.565] resolve() on list ...
[09:31:11.565]  recursive: 0
[09:31:11.565]  length: 6
[09:31:11.565]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:11.565] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.565] - nx: 6
[09:31:11.565] - relay: TRUE
[09:31:11.565] - stdout: TRUE
[09:31:11.566] - signal: TRUE
[09:31:11.566] - resignal: FALSE
[09:31:11.566] - force: TRUE
[09:31:11.566] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.566] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.566]  - until=2
[09:31:11.566]  - relaying element #2
[09:31:11.566] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.566] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.566] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.566]  length: 5 (resolved future 1)
[09:31:11.567] resolved() for ‘SequentialFuture’ ...
[09:31:11.567] - state: ‘finished’
[09:31:11.567] - run: TRUE
[09:31:11.567] - result: ‘FutureResult’
[09:31:11.567] resolved() for ‘SequentialFuture’ ... done
[09:31:11.567] Future #2
[09:31:11.567] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.567] - nx: 6
[09:31:11.569] - relay: TRUE
[09:31:11.569] - stdout: TRUE
[09:31:11.569] - signal: TRUE
[09:31:11.569] - resignal: FALSE
[09:31:11.569] - force: TRUE
[09:31:11.569] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.569] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.569]  - until=2
[09:31:11.569]  - relaying element #2
[09:31:11.569] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.570] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.570] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.570]  length: 4 (resolved future 2)
[09:31:11.570] resolved() for ‘SequentialFuture’ ...
[09:31:11.570] - state: ‘finished’
[09:31:11.570] - run: TRUE
[09:31:11.570] - result: ‘FutureResult’
[09:31:11.570] resolved() for ‘SequentialFuture’ ... done
[09:31:11.570] Future #3
[09:31:11.570] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.570] - nx: 6
[09:31:11.571] - relay: TRUE
[09:31:11.571] - stdout: TRUE
[09:31:11.571] - signal: TRUE
[09:31:11.571] - resignal: FALSE
[09:31:11.571] - force: TRUE
[09:31:11.571] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.571] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.571]  - until=3
[09:31:11.571]  - relaying element #3
[09:31:11.571] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.571] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.572] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.572]  length: 3 (resolved future 3)
[09:31:11.572] signalConditionsASAP(NULL, pos=4) ...
[09:31:11.572] - nx: 6
[09:31:11.572] - relay: TRUE
[09:31:11.572] - stdout: TRUE
[09:31:11.572] - signal: TRUE
[09:31:11.572] - resignal: FALSE
[09:31:11.572] - force: TRUE
[09:31:11.572] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.572] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.572]  - until=5
[09:31:11.573]  - relaying element #5
[09:31:11.573] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.573] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.573] signalConditionsASAP(NULL, pos=4) ... done
[09:31:11.573]  length: 2 (resolved future 4)
[09:31:11.573] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.573] - nx: 6
[09:31:11.573] - relay: TRUE
[09:31:11.573] - stdout: TRUE
[09:31:11.573] - signal: TRUE
[09:31:11.573] - resignal: FALSE
[09:31:11.573] - force: TRUE
[09:31:11.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.574] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.574]  - until=6
[09:31:11.574]  - relaying element #6
[09:31:11.574] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.574] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.574] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.574]  length: 1 (resolved future 5)
[09:31:11.574] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.574] - nx: 6
[09:31:11.574] - relay: TRUE
[09:31:11.574] - stdout: TRUE
[09:31:11.574] - signal: TRUE
[09:31:11.575] - resignal: FALSE
[09:31:11.575] - force: TRUE
[09:31:11.575] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.575] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.575]  - until=6
[09:31:11.575] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.575] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.575] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.575]  length: 0 (resolved future 6)
[09:31:11.575] Relaying remaining futures
[09:31:11.575] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.575] - nx: 6
[09:31:11.576] - relay: TRUE
[09:31:11.576] - stdout: TRUE
[09:31:11.576] - signal: TRUE
[09:31:11.576] - resignal: FALSE
[09:31:11.576] - force: TRUE
[09:31:11.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.576] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:11.576] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.576] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.576] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.576] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:11.579] getGlobalsAndPackages() ...
[09:31:11.579] Searching for globals...
[09:31:11.580] 
[09:31:11.580] Searching for globals ... DONE
[09:31:11.580] - globals: [0] <none>
[09:31:11.580] getGlobalsAndPackages() ... DONE
[09:31:11.580] run() for ‘Future’ ...
[09:31:11.580] - state: ‘created’
[09:31:11.580] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.581]   - Field: ‘label’
[09:31:11.581]   - Field: ‘local’
[09:31:11.581]   - Field: ‘owner’
[09:31:11.581]   - Field: ‘envir’
[09:31:11.581]   - Field: ‘packages’
[09:31:11.581]   - Field: ‘gc’
[09:31:11.581]   - Field: ‘conditions’
[09:31:11.582]   - Field: ‘expr’
[09:31:11.582]   - Field: ‘uuid’
[09:31:11.582]   - Field: ‘seed’
[09:31:11.582]   - Field: ‘version’
[09:31:11.582]   - Field: ‘result’
[09:31:11.582]   - Field: ‘asynchronous’
[09:31:11.582]   - Field: ‘calls’
[09:31:11.582]   - Field: ‘globals’
[09:31:11.582]   - Field: ‘stdout’
[09:31:11.582]   - Field: ‘earlySignal’
[09:31:11.582]   - Field: ‘lazy’
[09:31:11.582]   - Field: ‘state’
[09:31:11.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.583] - Launch lazy future ...
[09:31:11.583] Packages needed by the future expression (n = 0): <none>
[09:31:11.583] Packages needed by future strategies (n = 0): <none>
[09:31:11.583] {
[09:31:11.583]     {
[09:31:11.583]         {
[09:31:11.583]             ...future.startTime <- base::Sys.time()
[09:31:11.583]             {
[09:31:11.583]                 {
[09:31:11.583]                   {
[09:31:11.583]                     base::local({
[09:31:11.583]                       has_future <- base::requireNamespace("future", 
[09:31:11.583]                         quietly = TRUE)
[09:31:11.583]                       if (has_future) {
[09:31:11.583]                         ns <- base::getNamespace("future")
[09:31:11.583]                         version <- ns[[".package"]][["version"]]
[09:31:11.583]                         if (is.null(version)) 
[09:31:11.583]                           version <- utils::packageVersion("future")
[09:31:11.583]                       }
[09:31:11.583]                       else {
[09:31:11.583]                         version <- NULL
[09:31:11.583]                       }
[09:31:11.583]                       if (!has_future || version < "1.8.0") {
[09:31:11.583]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.583]                           "", base::R.version$version.string), 
[09:31:11.583]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.583]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.583]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.583]                             "release", "version")], collapse = " "), 
[09:31:11.583]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.583]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.583]                           info)
[09:31:11.583]                         info <- base::paste(info, collapse = "; ")
[09:31:11.583]                         if (!has_future) {
[09:31:11.583]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.583]                             info)
[09:31:11.583]                         }
[09:31:11.583]                         else {
[09:31:11.583]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.583]                             info, version)
[09:31:11.583]                         }
[09:31:11.583]                         base::stop(msg)
[09:31:11.583]                       }
[09:31:11.583]                     })
[09:31:11.583]                   }
[09:31:11.583]                   ...future.strategy.old <- future::plan("list")
[09:31:11.583]                   options(future.plan = NULL)
[09:31:11.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.583]                 }
[09:31:11.583]                 ...future.workdir <- getwd()
[09:31:11.583]             }
[09:31:11.583]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.583]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.583]         }
[09:31:11.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.583]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.583]             base::names(...future.oldOptions))
[09:31:11.583]     }
[09:31:11.583]     if (FALSE) {
[09:31:11.583]     }
[09:31:11.583]     else {
[09:31:11.583]         if (TRUE) {
[09:31:11.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.583]                 open = "w")
[09:31:11.583]         }
[09:31:11.583]         else {
[09:31:11.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.583]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.583]         }
[09:31:11.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.583]             base::sink(type = "output", split = FALSE)
[09:31:11.583]             base::close(...future.stdout)
[09:31:11.583]         }, add = TRUE)
[09:31:11.583]     }
[09:31:11.583]     ...future.frame <- base::sys.nframe()
[09:31:11.583]     ...future.conditions <- base::list()
[09:31:11.583]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.583]     if (FALSE) {
[09:31:11.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.583]     }
[09:31:11.583]     ...future.result <- base::tryCatch({
[09:31:11.583]         base::withCallingHandlers({
[09:31:11.583]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.583]             future::FutureResult(value = ...future.value$value, 
[09:31:11.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.583]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.583]                     ...future.globalenv.names))
[09:31:11.583]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.583]         }, condition = base::local({
[09:31:11.583]             c <- base::c
[09:31:11.583]             inherits <- base::inherits
[09:31:11.583]             invokeRestart <- base::invokeRestart
[09:31:11.583]             length <- base::length
[09:31:11.583]             list <- base::list
[09:31:11.583]             seq.int <- base::seq.int
[09:31:11.583]             signalCondition <- base::signalCondition
[09:31:11.583]             sys.calls <- base::sys.calls
[09:31:11.583]             `[[` <- base::`[[`
[09:31:11.583]             `+` <- base::`+`
[09:31:11.583]             `<<-` <- base::`<<-`
[09:31:11.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.583]                   3L)]
[09:31:11.583]             }
[09:31:11.583]             function(cond) {
[09:31:11.583]                 is_error <- inherits(cond, "error")
[09:31:11.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.583]                   NULL)
[09:31:11.583]                 if (is_error) {
[09:31:11.583]                   sessionInformation <- function() {
[09:31:11.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.583]                       search = base::search(), system = base::Sys.info())
[09:31:11.583]                   }
[09:31:11.583]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.583]                     cond$call), session = sessionInformation(), 
[09:31:11.583]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.583]                   signalCondition(cond)
[09:31:11.583]                 }
[09:31:11.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.583]                 "immediateCondition"))) {
[09:31:11.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.583]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.583]                   if (TRUE && !signal) {
[09:31:11.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.583]                     {
[09:31:11.583]                       inherits <- base::inherits
[09:31:11.583]                       invokeRestart <- base::invokeRestart
[09:31:11.583]                       is.null <- base::is.null
[09:31:11.583]                       muffled <- FALSE
[09:31:11.583]                       if (inherits(cond, "message")) {
[09:31:11.583]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.583]                         if (muffled) 
[09:31:11.583]                           invokeRestart("muffleMessage")
[09:31:11.583]                       }
[09:31:11.583]                       else if (inherits(cond, "warning")) {
[09:31:11.583]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.583]                         if (muffled) 
[09:31:11.583]                           invokeRestart("muffleWarning")
[09:31:11.583]                       }
[09:31:11.583]                       else if (inherits(cond, "condition")) {
[09:31:11.583]                         if (!is.null(pattern)) {
[09:31:11.583]                           computeRestarts <- base::computeRestarts
[09:31:11.583]                           grepl <- base::grepl
[09:31:11.583]                           restarts <- computeRestarts(cond)
[09:31:11.583]                           for (restart in restarts) {
[09:31:11.583]                             name <- restart$name
[09:31:11.583]                             if (is.null(name)) 
[09:31:11.583]                               next
[09:31:11.583]                             if (!grepl(pattern, name)) 
[09:31:11.583]                               next
[09:31:11.583]                             invokeRestart(restart)
[09:31:11.583]                             muffled <- TRUE
[09:31:11.583]                             break
[09:31:11.583]                           }
[09:31:11.583]                         }
[09:31:11.583]                       }
[09:31:11.583]                       invisible(muffled)
[09:31:11.583]                     }
[09:31:11.583]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.583]                   }
[09:31:11.583]                 }
[09:31:11.583]                 else {
[09:31:11.583]                   if (TRUE) {
[09:31:11.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.583]                     {
[09:31:11.583]                       inherits <- base::inherits
[09:31:11.583]                       invokeRestart <- base::invokeRestart
[09:31:11.583]                       is.null <- base::is.null
[09:31:11.583]                       muffled <- FALSE
[09:31:11.583]                       if (inherits(cond, "message")) {
[09:31:11.583]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.583]                         if (muffled) 
[09:31:11.583]                           invokeRestart("muffleMessage")
[09:31:11.583]                       }
[09:31:11.583]                       else if (inherits(cond, "warning")) {
[09:31:11.583]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.583]                         if (muffled) 
[09:31:11.583]                           invokeRestart("muffleWarning")
[09:31:11.583]                       }
[09:31:11.583]                       else if (inherits(cond, "condition")) {
[09:31:11.583]                         if (!is.null(pattern)) {
[09:31:11.583]                           computeRestarts <- base::computeRestarts
[09:31:11.583]                           grepl <- base::grepl
[09:31:11.583]                           restarts <- computeRestarts(cond)
[09:31:11.583]                           for (restart in restarts) {
[09:31:11.583]                             name <- restart$name
[09:31:11.583]                             if (is.null(name)) 
[09:31:11.583]                               next
[09:31:11.583]                             if (!grepl(pattern, name)) 
[09:31:11.583]                               next
[09:31:11.583]                             invokeRestart(restart)
[09:31:11.583]                             muffled <- TRUE
[09:31:11.583]                             break
[09:31:11.583]                           }
[09:31:11.583]                         }
[09:31:11.583]                       }
[09:31:11.583]                       invisible(muffled)
[09:31:11.583]                     }
[09:31:11.583]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.583]                   }
[09:31:11.583]                 }
[09:31:11.583]             }
[09:31:11.583]         }))
[09:31:11.583]     }, error = function(ex) {
[09:31:11.583]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.583]                 ...future.rng), started = ...future.startTime, 
[09:31:11.583]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.583]             version = "1.8"), class = "FutureResult")
[09:31:11.583]     }, finally = {
[09:31:11.583]         if (!identical(...future.workdir, getwd())) 
[09:31:11.583]             setwd(...future.workdir)
[09:31:11.583]         {
[09:31:11.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.583]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.583]             }
[09:31:11.583]             base::options(...future.oldOptions)
[09:31:11.583]             if (.Platform$OS.type == "windows") {
[09:31:11.583]                 old_names <- names(...future.oldEnvVars)
[09:31:11.583]                 envs <- base::Sys.getenv()
[09:31:11.583]                 names <- names(envs)
[09:31:11.583]                 common <- intersect(names, old_names)
[09:31:11.583]                 added <- setdiff(names, old_names)
[09:31:11.583]                 removed <- setdiff(old_names, names)
[09:31:11.583]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.583]                   envs[common]]
[09:31:11.583]                 NAMES <- toupper(changed)
[09:31:11.583]                 args <- list()
[09:31:11.583]                 for (kk in seq_along(NAMES)) {
[09:31:11.583]                   name <- changed[[kk]]
[09:31:11.583]                   NAME <- NAMES[[kk]]
[09:31:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.583]                     next
[09:31:11.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.583]                 }
[09:31:11.583]                 NAMES <- toupper(added)
[09:31:11.583]                 for (kk in seq_along(NAMES)) {
[09:31:11.583]                   name <- added[[kk]]
[09:31:11.583]                   NAME <- NAMES[[kk]]
[09:31:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.583]                     next
[09:31:11.583]                   args[[name]] <- ""
[09:31:11.583]                 }
[09:31:11.583]                 NAMES <- toupper(removed)
[09:31:11.583]                 for (kk in seq_along(NAMES)) {
[09:31:11.583]                   name <- removed[[kk]]
[09:31:11.583]                   NAME <- NAMES[[kk]]
[09:31:11.583]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.583]                     next
[09:31:11.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.583]                 }
[09:31:11.583]                 if (length(args) > 0) 
[09:31:11.583]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.583]             }
[09:31:11.583]             else {
[09:31:11.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.583]             }
[09:31:11.583]             {
[09:31:11.583]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.583]                   0L) {
[09:31:11.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.583]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.583]                   base::options(opts)
[09:31:11.583]                 }
[09:31:11.583]                 {
[09:31:11.583]                   {
[09:31:11.583]                     NULL
[09:31:11.583]                     RNGkind("Mersenne-Twister")
[09:31:11.583]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.583]                       inherits = FALSE)
[09:31:11.583]                   }
[09:31:11.583]                   options(future.plan = NULL)
[09:31:11.583]                   if (is.na(NA_character_)) 
[09:31:11.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.583]                     .init = FALSE)
[09:31:11.583]                 }
[09:31:11.583]             }
[09:31:11.583]         }
[09:31:11.583]     })
[09:31:11.583]     if (TRUE) {
[09:31:11.583]         base::sink(type = "output", split = FALSE)
[09:31:11.583]         if (TRUE) {
[09:31:11.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.583]         }
[09:31:11.583]         else {
[09:31:11.583]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.583]         }
[09:31:11.583]         base::close(...future.stdout)
[09:31:11.583]         ...future.stdout <- NULL
[09:31:11.583]     }
[09:31:11.583]     ...future.result$conditions <- ...future.conditions
[09:31:11.583]     ...future.result$finished <- base::Sys.time()
[09:31:11.583]     ...future.result
[09:31:11.583] }
[09:31:11.585] plan(): Setting new future strategy stack:
[09:31:11.585] List of future strategies:
[09:31:11.585] 1. sequential:
[09:31:11.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.585]    - tweaked: FALSE
[09:31:11.585]    - call: NULL
[09:31:11.585] plan(): nbrOfWorkers() = 1
[09:31:11.586] plan(): Setting new future strategy stack:
[09:31:11.586] List of future strategies:
[09:31:11.586] 1. sequential:
[09:31:11.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.586]    - tweaked: FALSE
[09:31:11.586]    - call: plan(strategy)
[09:31:11.587] plan(): nbrOfWorkers() = 1
[09:31:11.587] SequentialFuture started (and completed)
[09:31:11.587] - Launch lazy future ... done
[09:31:11.587] run() for ‘SequentialFuture’ ... done
[09:31:11.587] getGlobalsAndPackages() ...
[09:31:11.587] Searching for globals...
[09:31:11.587] 
[09:31:11.587] Searching for globals ... DONE
[09:31:11.588] - globals: [0] <none>
[09:31:11.588] getGlobalsAndPackages() ... DONE
[09:31:11.588] run() for ‘Future’ ...
[09:31:11.588] - state: ‘created’
[09:31:11.588] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.588] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.589]   - Field: ‘label’
[09:31:11.589]   - Field: ‘local’
[09:31:11.589]   - Field: ‘owner’
[09:31:11.589]   - Field: ‘envir’
[09:31:11.589]   - Field: ‘packages’
[09:31:11.589]   - Field: ‘gc’
[09:31:11.589]   - Field: ‘conditions’
[09:31:11.589]   - Field: ‘expr’
[09:31:11.589]   - Field: ‘uuid’
[09:31:11.589]   - Field: ‘seed’
[09:31:11.589]   - Field: ‘version’
[09:31:11.589]   - Field: ‘result’
[09:31:11.590]   - Field: ‘asynchronous’
[09:31:11.590]   - Field: ‘calls’
[09:31:11.590]   - Field: ‘globals’
[09:31:11.590]   - Field: ‘stdout’
[09:31:11.590]   - Field: ‘earlySignal’
[09:31:11.590]   - Field: ‘lazy’
[09:31:11.590]   - Field: ‘state’
[09:31:11.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.590] - Launch lazy future ...
[09:31:11.590] Packages needed by the future expression (n = 0): <none>
[09:31:11.591] Packages needed by future strategies (n = 0): <none>
[09:31:11.591] {
[09:31:11.591]     {
[09:31:11.591]         {
[09:31:11.591]             ...future.startTime <- base::Sys.time()
[09:31:11.591]             {
[09:31:11.591]                 {
[09:31:11.591]                   {
[09:31:11.591]                     base::local({
[09:31:11.591]                       has_future <- base::requireNamespace("future", 
[09:31:11.591]                         quietly = TRUE)
[09:31:11.591]                       if (has_future) {
[09:31:11.591]                         ns <- base::getNamespace("future")
[09:31:11.591]                         version <- ns[[".package"]][["version"]]
[09:31:11.591]                         if (is.null(version)) 
[09:31:11.591]                           version <- utils::packageVersion("future")
[09:31:11.591]                       }
[09:31:11.591]                       else {
[09:31:11.591]                         version <- NULL
[09:31:11.591]                       }
[09:31:11.591]                       if (!has_future || version < "1.8.0") {
[09:31:11.591]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.591]                           "", base::R.version$version.string), 
[09:31:11.591]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.591]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.591]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.591]                             "release", "version")], collapse = " "), 
[09:31:11.591]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.591]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.591]                           info)
[09:31:11.591]                         info <- base::paste(info, collapse = "; ")
[09:31:11.591]                         if (!has_future) {
[09:31:11.591]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.591]                             info)
[09:31:11.591]                         }
[09:31:11.591]                         else {
[09:31:11.591]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.591]                             info, version)
[09:31:11.591]                         }
[09:31:11.591]                         base::stop(msg)
[09:31:11.591]                       }
[09:31:11.591]                     })
[09:31:11.591]                   }
[09:31:11.591]                   ...future.strategy.old <- future::plan("list")
[09:31:11.591]                   options(future.plan = NULL)
[09:31:11.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.591]                 }
[09:31:11.591]                 ...future.workdir <- getwd()
[09:31:11.591]             }
[09:31:11.591]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.591]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.591]         }
[09:31:11.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.591]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.591]             base::names(...future.oldOptions))
[09:31:11.591]     }
[09:31:11.591]     if (FALSE) {
[09:31:11.591]     }
[09:31:11.591]     else {
[09:31:11.591]         if (TRUE) {
[09:31:11.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.591]                 open = "w")
[09:31:11.591]         }
[09:31:11.591]         else {
[09:31:11.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.591]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.591]         }
[09:31:11.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.591]             base::sink(type = "output", split = FALSE)
[09:31:11.591]             base::close(...future.stdout)
[09:31:11.591]         }, add = TRUE)
[09:31:11.591]     }
[09:31:11.591]     ...future.frame <- base::sys.nframe()
[09:31:11.591]     ...future.conditions <- base::list()
[09:31:11.591]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.591]     if (FALSE) {
[09:31:11.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.591]     }
[09:31:11.591]     ...future.result <- base::tryCatch({
[09:31:11.591]         base::withCallingHandlers({
[09:31:11.591]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.591]             future::FutureResult(value = ...future.value$value, 
[09:31:11.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.591]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.591]                     ...future.globalenv.names))
[09:31:11.591]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.591]         }, condition = base::local({
[09:31:11.591]             c <- base::c
[09:31:11.591]             inherits <- base::inherits
[09:31:11.591]             invokeRestart <- base::invokeRestart
[09:31:11.591]             length <- base::length
[09:31:11.591]             list <- base::list
[09:31:11.591]             seq.int <- base::seq.int
[09:31:11.591]             signalCondition <- base::signalCondition
[09:31:11.591]             sys.calls <- base::sys.calls
[09:31:11.591]             `[[` <- base::`[[`
[09:31:11.591]             `+` <- base::`+`
[09:31:11.591]             `<<-` <- base::`<<-`
[09:31:11.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.591]                   3L)]
[09:31:11.591]             }
[09:31:11.591]             function(cond) {
[09:31:11.591]                 is_error <- inherits(cond, "error")
[09:31:11.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.591]                   NULL)
[09:31:11.591]                 if (is_error) {
[09:31:11.591]                   sessionInformation <- function() {
[09:31:11.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.591]                       search = base::search(), system = base::Sys.info())
[09:31:11.591]                   }
[09:31:11.591]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.591]                     cond$call), session = sessionInformation(), 
[09:31:11.591]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.591]                   signalCondition(cond)
[09:31:11.591]                 }
[09:31:11.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.591]                 "immediateCondition"))) {
[09:31:11.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.591]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.591]                   if (TRUE && !signal) {
[09:31:11.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.591]                     {
[09:31:11.591]                       inherits <- base::inherits
[09:31:11.591]                       invokeRestart <- base::invokeRestart
[09:31:11.591]                       is.null <- base::is.null
[09:31:11.591]                       muffled <- FALSE
[09:31:11.591]                       if (inherits(cond, "message")) {
[09:31:11.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.591]                         if (muffled) 
[09:31:11.591]                           invokeRestart("muffleMessage")
[09:31:11.591]                       }
[09:31:11.591]                       else if (inherits(cond, "warning")) {
[09:31:11.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.591]                         if (muffled) 
[09:31:11.591]                           invokeRestart("muffleWarning")
[09:31:11.591]                       }
[09:31:11.591]                       else if (inherits(cond, "condition")) {
[09:31:11.591]                         if (!is.null(pattern)) {
[09:31:11.591]                           computeRestarts <- base::computeRestarts
[09:31:11.591]                           grepl <- base::grepl
[09:31:11.591]                           restarts <- computeRestarts(cond)
[09:31:11.591]                           for (restart in restarts) {
[09:31:11.591]                             name <- restart$name
[09:31:11.591]                             if (is.null(name)) 
[09:31:11.591]                               next
[09:31:11.591]                             if (!grepl(pattern, name)) 
[09:31:11.591]                               next
[09:31:11.591]                             invokeRestart(restart)
[09:31:11.591]                             muffled <- TRUE
[09:31:11.591]                             break
[09:31:11.591]                           }
[09:31:11.591]                         }
[09:31:11.591]                       }
[09:31:11.591]                       invisible(muffled)
[09:31:11.591]                     }
[09:31:11.591]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.591]                   }
[09:31:11.591]                 }
[09:31:11.591]                 else {
[09:31:11.591]                   if (TRUE) {
[09:31:11.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.591]                     {
[09:31:11.591]                       inherits <- base::inherits
[09:31:11.591]                       invokeRestart <- base::invokeRestart
[09:31:11.591]                       is.null <- base::is.null
[09:31:11.591]                       muffled <- FALSE
[09:31:11.591]                       if (inherits(cond, "message")) {
[09:31:11.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.591]                         if (muffled) 
[09:31:11.591]                           invokeRestart("muffleMessage")
[09:31:11.591]                       }
[09:31:11.591]                       else if (inherits(cond, "warning")) {
[09:31:11.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.591]                         if (muffled) 
[09:31:11.591]                           invokeRestart("muffleWarning")
[09:31:11.591]                       }
[09:31:11.591]                       else if (inherits(cond, "condition")) {
[09:31:11.591]                         if (!is.null(pattern)) {
[09:31:11.591]                           computeRestarts <- base::computeRestarts
[09:31:11.591]                           grepl <- base::grepl
[09:31:11.591]                           restarts <- computeRestarts(cond)
[09:31:11.591]                           for (restart in restarts) {
[09:31:11.591]                             name <- restart$name
[09:31:11.591]                             if (is.null(name)) 
[09:31:11.591]                               next
[09:31:11.591]                             if (!grepl(pattern, name)) 
[09:31:11.591]                               next
[09:31:11.591]                             invokeRestart(restart)
[09:31:11.591]                             muffled <- TRUE
[09:31:11.591]                             break
[09:31:11.591]                           }
[09:31:11.591]                         }
[09:31:11.591]                       }
[09:31:11.591]                       invisible(muffled)
[09:31:11.591]                     }
[09:31:11.591]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.591]                   }
[09:31:11.591]                 }
[09:31:11.591]             }
[09:31:11.591]         }))
[09:31:11.591]     }, error = function(ex) {
[09:31:11.591]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.591]                 ...future.rng), started = ...future.startTime, 
[09:31:11.591]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.591]             version = "1.8"), class = "FutureResult")
[09:31:11.591]     }, finally = {
[09:31:11.591]         if (!identical(...future.workdir, getwd())) 
[09:31:11.591]             setwd(...future.workdir)
[09:31:11.591]         {
[09:31:11.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.591]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.591]             }
[09:31:11.591]             base::options(...future.oldOptions)
[09:31:11.591]             if (.Platform$OS.type == "windows") {
[09:31:11.591]                 old_names <- names(...future.oldEnvVars)
[09:31:11.591]                 envs <- base::Sys.getenv()
[09:31:11.591]                 names <- names(envs)
[09:31:11.591]                 common <- intersect(names, old_names)
[09:31:11.591]                 added <- setdiff(names, old_names)
[09:31:11.591]                 removed <- setdiff(old_names, names)
[09:31:11.591]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.591]                   envs[common]]
[09:31:11.591]                 NAMES <- toupper(changed)
[09:31:11.591]                 args <- list()
[09:31:11.591]                 for (kk in seq_along(NAMES)) {
[09:31:11.591]                   name <- changed[[kk]]
[09:31:11.591]                   NAME <- NAMES[[kk]]
[09:31:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.591]                     next
[09:31:11.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.591]                 }
[09:31:11.591]                 NAMES <- toupper(added)
[09:31:11.591]                 for (kk in seq_along(NAMES)) {
[09:31:11.591]                   name <- added[[kk]]
[09:31:11.591]                   NAME <- NAMES[[kk]]
[09:31:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.591]                     next
[09:31:11.591]                   args[[name]] <- ""
[09:31:11.591]                 }
[09:31:11.591]                 NAMES <- toupper(removed)
[09:31:11.591]                 for (kk in seq_along(NAMES)) {
[09:31:11.591]                   name <- removed[[kk]]
[09:31:11.591]                   NAME <- NAMES[[kk]]
[09:31:11.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.591]                     next
[09:31:11.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.591]                 }
[09:31:11.591]                 if (length(args) > 0) 
[09:31:11.591]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.591]             }
[09:31:11.591]             else {
[09:31:11.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.591]             }
[09:31:11.591]             {
[09:31:11.591]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.591]                   0L) {
[09:31:11.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.591]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.591]                   base::options(opts)
[09:31:11.591]                 }
[09:31:11.591]                 {
[09:31:11.591]                   {
[09:31:11.591]                     NULL
[09:31:11.591]                     RNGkind("Mersenne-Twister")
[09:31:11.591]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.591]                       inherits = FALSE)
[09:31:11.591]                   }
[09:31:11.591]                   options(future.plan = NULL)
[09:31:11.591]                   if (is.na(NA_character_)) 
[09:31:11.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.591]                     .init = FALSE)
[09:31:11.591]                 }
[09:31:11.591]             }
[09:31:11.591]         }
[09:31:11.591]     })
[09:31:11.591]     if (TRUE) {
[09:31:11.591]         base::sink(type = "output", split = FALSE)
[09:31:11.591]         if (TRUE) {
[09:31:11.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.591]         }
[09:31:11.591]         else {
[09:31:11.591]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.591]         }
[09:31:11.591]         base::close(...future.stdout)
[09:31:11.591]         ...future.stdout <- NULL
[09:31:11.591]     }
[09:31:11.591]     ...future.result$conditions <- ...future.conditions
[09:31:11.591]     ...future.result$finished <- base::Sys.time()
[09:31:11.591]     ...future.result
[09:31:11.591] }
[09:31:11.593] plan(): Setting new future strategy stack:
[09:31:11.593] List of future strategies:
[09:31:11.593] 1. sequential:
[09:31:11.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.593]    - tweaked: FALSE
[09:31:11.593]    - call: NULL
[09:31:11.593] plan(): nbrOfWorkers() = 1
[09:31:11.594] plan(): Setting new future strategy stack:
[09:31:11.594] List of future strategies:
[09:31:11.594] 1. sequential:
[09:31:11.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.594]    - tweaked: FALSE
[09:31:11.594]    - call: plan(strategy)
[09:31:11.594] plan(): nbrOfWorkers() = 1
[09:31:11.594] SequentialFuture started (and completed)
[09:31:11.594] - Launch lazy future ... done
[09:31:11.595] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca9a2470> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3cae0f908> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca9a2470> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3cae0f908> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[09:31:11.600] resolved() for ‘SequentialFuture’ ...
[09:31:11.600] - state: ‘finished’
[09:31:11.600] - run: TRUE
[09:31:11.600] - result: ‘FutureResult’
[09:31:11.601] resolved() for ‘SequentialFuture’ ... done
[09:31:11.601] resolved() for ‘SequentialFuture’ ...
[09:31:11.601] - state: ‘finished’
[09:31:11.601] - run: TRUE
[09:31:11.601] - result: ‘FutureResult’
[09:31:11.601] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:11.602] resolve() on list ...
[09:31:11.602]  recursive: 0
[09:31:11.603]  length: 6
[09:31:11.603]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:11.603] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.603] - nx: 6
[09:31:11.603] - relay: TRUE
[09:31:11.603] - stdout: TRUE
[09:31:11.603] - signal: TRUE
[09:31:11.603] - resignal: FALSE
[09:31:11.603] - force: TRUE
[09:31:11.603] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.603] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.603]  - until=2
[09:31:11.604]  - relaying element #2
[09:31:11.604] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.604] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.604] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.604]  length: 5 (resolved future 1)
[09:31:11.604] resolved() for ‘SequentialFuture’ ...
[09:31:11.604] - state: ‘finished’
[09:31:11.604] - run: TRUE
[09:31:11.604] - result: ‘FutureResult’
[09:31:11.604] resolved() for ‘SequentialFuture’ ... done
[09:31:11.604] Future #2
[09:31:11.605] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.605] - nx: 6
[09:31:11.605] - relay: TRUE
[09:31:11.605] - stdout: TRUE
[09:31:11.605] - signal: TRUE
[09:31:11.605] - resignal: FALSE
[09:31:11.605] - force: TRUE
[09:31:11.605] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.605] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.605]  - until=2
[09:31:11.605]  - relaying element #2
[09:31:11.606] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.606] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.606] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.606]  length: 4 (resolved future 2)
[09:31:11.606] resolved() for ‘SequentialFuture’ ...
[09:31:11.606] - state: ‘finished’
[09:31:11.606] - run: TRUE
[09:31:11.606] - result: ‘FutureResult’
[09:31:11.606] resolved() for ‘SequentialFuture’ ... done
[09:31:11.606] Future #3
[09:31:11.606] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.607] - nx: 6
[09:31:11.607] - relay: TRUE
[09:31:11.607] - stdout: TRUE
[09:31:11.607] - signal: TRUE
[09:31:11.607] - resignal: FALSE
[09:31:11.607] - force: TRUE
[09:31:11.607] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.607] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.607]  - until=3
[09:31:11.607]  - relaying element #3
[09:31:11.607] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.607] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.608] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.608]  length: 3 (resolved future 3)
[09:31:11.608] signalConditionsASAP(NULL, pos=4) ...
[09:31:11.608] - nx: 6
[09:31:11.608] - relay: TRUE
[09:31:11.608] - stdout: TRUE
[09:31:11.608] - signal: TRUE
[09:31:11.608] - resignal: FALSE
[09:31:11.608] - force: TRUE
[09:31:11.608] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.608] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.608]  - until=5
[09:31:11.609]  - relaying element #5
[09:31:11.609] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.609] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.609] signalConditionsASAP(NULL, pos=4) ... done
[09:31:11.609]  length: 2 (resolved future 4)
[09:31:11.609] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.609] - nx: 6
[09:31:11.609] - relay: TRUE
[09:31:11.609] - stdout: TRUE
[09:31:11.609] - signal: TRUE
[09:31:11.609] - resignal: FALSE
[09:31:11.609] - force: TRUE
[09:31:11.610] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.610] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.610]  - until=6
[09:31:11.610]  - relaying element #6
[09:31:11.610] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.610] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.610] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.610]  length: 1 (resolved future 5)
[09:31:11.610] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.610] - nx: 6
[09:31:11.610] - relay: TRUE
[09:31:11.610] - stdout: TRUE
[09:31:11.610] - signal: TRUE
[09:31:11.611] - resignal: FALSE
[09:31:11.611] - force: TRUE
[09:31:11.611] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.611] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.611]  - until=6
[09:31:11.611] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.611] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.611] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.611]  length: 0 (resolved future 6)
[09:31:11.611] Relaying remaining futures
[09:31:11.611] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.611] - nx: 6
[09:31:11.612] - relay: TRUE
[09:31:11.612] - stdout: TRUE
[09:31:11.612] - signal: TRUE
[09:31:11.612] - resignal: FALSE
[09:31:11.612] - force: TRUE
[09:31:11.612] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.612] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:11.612] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.612] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.612] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.612] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:11.615] getGlobalsAndPackages() ...
[09:31:11.615] Searching for globals...
[09:31:11.616] 
[09:31:11.616] Searching for globals ... DONE
[09:31:11.616] - globals: [0] <none>
[09:31:11.616] getGlobalsAndPackages() ... DONE
[09:31:11.616] run() for ‘Future’ ...
[09:31:11.616] - state: ‘created’
[09:31:11.616] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.617] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.617]   - Field: ‘label’
[09:31:11.617]   - Field: ‘local’
[09:31:11.617]   - Field: ‘owner’
[09:31:11.617]   - Field: ‘envir’
[09:31:11.617]   - Field: ‘packages’
[09:31:11.617]   - Field: ‘gc’
[09:31:11.617]   - Field: ‘conditions’
[09:31:11.617]   - Field: ‘expr’
[09:31:11.618]   - Field: ‘uuid’
[09:31:11.618]   - Field: ‘seed’
[09:31:11.618]   - Field: ‘version’
[09:31:11.618]   - Field: ‘result’
[09:31:11.618]   - Field: ‘asynchronous’
[09:31:11.618]   - Field: ‘calls’
[09:31:11.618]   - Field: ‘globals’
[09:31:11.618]   - Field: ‘stdout’
[09:31:11.618]   - Field: ‘earlySignal’
[09:31:11.618]   - Field: ‘lazy’
[09:31:11.618]   - Field: ‘state’
[09:31:11.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.619] - Launch lazy future ...
[09:31:11.619] Packages needed by the future expression (n = 0): <none>
[09:31:11.619] Packages needed by future strategies (n = 0): <none>
[09:31:11.619] {
[09:31:11.619]     {
[09:31:11.619]         {
[09:31:11.619]             ...future.startTime <- base::Sys.time()
[09:31:11.619]             {
[09:31:11.619]                 {
[09:31:11.619]                   {
[09:31:11.619]                     base::local({
[09:31:11.619]                       has_future <- base::requireNamespace("future", 
[09:31:11.619]                         quietly = TRUE)
[09:31:11.619]                       if (has_future) {
[09:31:11.619]                         ns <- base::getNamespace("future")
[09:31:11.619]                         version <- ns[[".package"]][["version"]]
[09:31:11.619]                         if (is.null(version)) 
[09:31:11.619]                           version <- utils::packageVersion("future")
[09:31:11.619]                       }
[09:31:11.619]                       else {
[09:31:11.619]                         version <- NULL
[09:31:11.619]                       }
[09:31:11.619]                       if (!has_future || version < "1.8.0") {
[09:31:11.619]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.619]                           "", base::R.version$version.string), 
[09:31:11.619]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.619]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.619]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.619]                             "release", "version")], collapse = " "), 
[09:31:11.619]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.619]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.619]                           info)
[09:31:11.619]                         info <- base::paste(info, collapse = "; ")
[09:31:11.619]                         if (!has_future) {
[09:31:11.619]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.619]                             info)
[09:31:11.619]                         }
[09:31:11.619]                         else {
[09:31:11.619]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.619]                             info, version)
[09:31:11.619]                         }
[09:31:11.619]                         base::stop(msg)
[09:31:11.619]                       }
[09:31:11.619]                     })
[09:31:11.619]                   }
[09:31:11.619]                   ...future.strategy.old <- future::plan("list")
[09:31:11.619]                   options(future.plan = NULL)
[09:31:11.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.619]                 }
[09:31:11.619]                 ...future.workdir <- getwd()
[09:31:11.619]             }
[09:31:11.619]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.619]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.619]         }
[09:31:11.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.619]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.619]             base::names(...future.oldOptions))
[09:31:11.619]     }
[09:31:11.619]     if (FALSE) {
[09:31:11.619]     }
[09:31:11.619]     else {
[09:31:11.619]         if (TRUE) {
[09:31:11.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.619]                 open = "w")
[09:31:11.619]         }
[09:31:11.619]         else {
[09:31:11.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.619]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.619]         }
[09:31:11.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.619]             base::sink(type = "output", split = FALSE)
[09:31:11.619]             base::close(...future.stdout)
[09:31:11.619]         }, add = TRUE)
[09:31:11.619]     }
[09:31:11.619]     ...future.frame <- base::sys.nframe()
[09:31:11.619]     ...future.conditions <- base::list()
[09:31:11.619]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.619]     if (FALSE) {
[09:31:11.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.619]     }
[09:31:11.619]     ...future.result <- base::tryCatch({
[09:31:11.619]         base::withCallingHandlers({
[09:31:11.619]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.619]             future::FutureResult(value = ...future.value$value, 
[09:31:11.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.619]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.619]                     ...future.globalenv.names))
[09:31:11.619]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.619]         }, condition = base::local({
[09:31:11.619]             c <- base::c
[09:31:11.619]             inherits <- base::inherits
[09:31:11.619]             invokeRestart <- base::invokeRestart
[09:31:11.619]             length <- base::length
[09:31:11.619]             list <- base::list
[09:31:11.619]             seq.int <- base::seq.int
[09:31:11.619]             signalCondition <- base::signalCondition
[09:31:11.619]             sys.calls <- base::sys.calls
[09:31:11.619]             `[[` <- base::`[[`
[09:31:11.619]             `+` <- base::`+`
[09:31:11.619]             `<<-` <- base::`<<-`
[09:31:11.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.619]                   3L)]
[09:31:11.619]             }
[09:31:11.619]             function(cond) {
[09:31:11.619]                 is_error <- inherits(cond, "error")
[09:31:11.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.619]                   NULL)
[09:31:11.619]                 if (is_error) {
[09:31:11.619]                   sessionInformation <- function() {
[09:31:11.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.619]                       search = base::search(), system = base::Sys.info())
[09:31:11.619]                   }
[09:31:11.619]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.619]                     cond$call), session = sessionInformation(), 
[09:31:11.619]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.619]                   signalCondition(cond)
[09:31:11.619]                 }
[09:31:11.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.619]                 "immediateCondition"))) {
[09:31:11.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.619]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.619]                   if (TRUE && !signal) {
[09:31:11.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.619]                     {
[09:31:11.619]                       inherits <- base::inherits
[09:31:11.619]                       invokeRestart <- base::invokeRestart
[09:31:11.619]                       is.null <- base::is.null
[09:31:11.619]                       muffled <- FALSE
[09:31:11.619]                       if (inherits(cond, "message")) {
[09:31:11.619]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.619]                         if (muffled) 
[09:31:11.619]                           invokeRestart("muffleMessage")
[09:31:11.619]                       }
[09:31:11.619]                       else if (inherits(cond, "warning")) {
[09:31:11.619]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.619]                         if (muffled) 
[09:31:11.619]                           invokeRestart("muffleWarning")
[09:31:11.619]                       }
[09:31:11.619]                       else if (inherits(cond, "condition")) {
[09:31:11.619]                         if (!is.null(pattern)) {
[09:31:11.619]                           computeRestarts <- base::computeRestarts
[09:31:11.619]                           grepl <- base::grepl
[09:31:11.619]                           restarts <- computeRestarts(cond)
[09:31:11.619]                           for (restart in restarts) {
[09:31:11.619]                             name <- restart$name
[09:31:11.619]                             if (is.null(name)) 
[09:31:11.619]                               next
[09:31:11.619]                             if (!grepl(pattern, name)) 
[09:31:11.619]                               next
[09:31:11.619]                             invokeRestart(restart)
[09:31:11.619]                             muffled <- TRUE
[09:31:11.619]                             break
[09:31:11.619]                           }
[09:31:11.619]                         }
[09:31:11.619]                       }
[09:31:11.619]                       invisible(muffled)
[09:31:11.619]                     }
[09:31:11.619]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.619]                   }
[09:31:11.619]                 }
[09:31:11.619]                 else {
[09:31:11.619]                   if (TRUE) {
[09:31:11.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.619]                     {
[09:31:11.619]                       inherits <- base::inherits
[09:31:11.619]                       invokeRestart <- base::invokeRestart
[09:31:11.619]                       is.null <- base::is.null
[09:31:11.619]                       muffled <- FALSE
[09:31:11.619]                       if (inherits(cond, "message")) {
[09:31:11.619]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.619]                         if (muffled) 
[09:31:11.619]                           invokeRestart("muffleMessage")
[09:31:11.619]                       }
[09:31:11.619]                       else if (inherits(cond, "warning")) {
[09:31:11.619]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.619]                         if (muffled) 
[09:31:11.619]                           invokeRestart("muffleWarning")
[09:31:11.619]                       }
[09:31:11.619]                       else if (inherits(cond, "condition")) {
[09:31:11.619]                         if (!is.null(pattern)) {
[09:31:11.619]                           computeRestarts <- base::computeRestarts
[09:31:11.619]                           grepl <- base::grepl
[09:31:11.619]                           restarts <- computeRestarts(cond)
[09:31:11.619]                           for (restart in restarts) {
[09:31:11.619]                             name <- restart$name
[09:31:11.619]                             if (is.null(name)) 
[09:31:11.619]                               next
[09:31:11.619]                             if (!grepl(pattern, name)) 
[09:31:11.619]                               next
[09:31:11.619]                             invokeRestart(restart)
[09:31:11.619]                             muffled <- TRUE
[09:31:11.619]                             break
[09:31:11.619]                           }
[09:31:11.619]                         }
[09:31:11.619]                       }
[09:31:11.619]                       invisible(muffled)
[09:31:11.619]                     }
[09:31:11.619]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.619]                   }
[09:31:11.619]                 }
[09:31:11.619]             }
[09:31:11.619]         }))
[09:31:11.619]     }, error = function(ex) {
[09:31:11.619]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.619]                 ...future.rng), started = ...future.startTime, 
[09:31:11.619]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.619]             version = "1.8"), class = "FutureResult")
[09:31:11.619]     }, finally = {
[09:31:11.619]         if (!identical(...future.workdir, getwd())) 
[09:31:11.619]             setwd(...future.workdir)
[09:31:11.619]         {
[09:31:11.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.619]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.619]             }
[09:31:11.619]             base::options(...future.oldOptions)
[09:31:11.619]             if (.Platform$OS.type == "windows") {
[09:31:11.619]                 old_names <- names(...future.oldEnvVars)
[09:31:11.619]                 envs <- base::Sys.getenv()
[09:31:11.619]                 names <- names(envs)
[09:31:11.619]                 common <- intersect(names, old_names)
[09:31:11.619]                 added <- setdiff(names, old_names)
[09:31:11.619]                 removed <- setdiff(old_names, names)
[09:31:11.619]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.619]                   envs[common]]
[09:31:11.619]                 NAMES <- toupper(changed)
[09:31:11.619]                 args <- list()
[09:31:11.619]                 for (kk in seq_along(NAMES)) {
[09:31:11.619]                   name <- changed[[kk]]
[09:31:11.619]                   NAME <- NAMES[[kk]]
[09:31:11.619]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.619]                     next
[09:31:11.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.619]                 }
[09:31:11.619]                 NAMES <- toupper(added)
[09:31:11.619]                 for (kk in seq_along(NAMES)) {
[09:31:11.619]                   name <- added[[kk]]
[09:31:11.619]                   NAME <- NAMES[[kk]]
[09:31:11.619]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.619]                     next
[09:31:11.619]                   args[[name]] <- ""
[09:31:11.619]                 }
[09:31:11.619]                 NAMES <- toupper(removed)
[09:31:11.619]                 for (kk in seq_along(NAMES)) {
[09:31:11.619]                   name <- removed[[kk]]
[09:31:11.619]                   NAME <- NAMES[[kk]]
[09:31:11.619]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.619]                     next
[09:31:11.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.619]                 }
[09:31:11.619]                 if (length(args) > 0) 
[09:31:11.619]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.619]             }
[09:31:11.619]             else {
[09:31:11.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.619]             }
[09:31:11.619]             {
[09:31:11.619]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.619]                   0L) {
[09:31:11.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.619]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.619]                   base::options(opts)
[09:31:11.619]                 }
[09:31:11.619]                 {
[09:31:11.619]                   {
[09:31:11.619]                     NULL
[09:31:11.619]                     RNGkind("Mersenne-Twister")
[09:31:11.619]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.619]                       inherits = FALSE)
[09:31:11.619]                   }
[09:31:11.619]                   options(future.plan = NULL)
[09:31:11.619]                   if (is.na(NA_character_)) 
[09:31:11.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.619]                     .init = FALSE)
[09:31:11.619]                 }
[09:31:11.619]             }
[09:31:11.619]         }
[09:31:11.619]     })
[09:31:11.619]     if (TRUE) {
[09:31:11.619]         base::sink(type = "output", split = FALSE)
[09:31:11.619]         if (TRUE) {
[09:31:11.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.619]         }
[09:31:11.619]         else {
[09:31:11.619]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.619]         }
[09:31:11.619]         base::close(...future.stdout)
[09:31:11.619]         ...future.stdout <- NULL
[09:31:11.619]     }
[09:31:11.619]     ...future.result$conditions <- ...future.conditions
[09:31:11.619]     ...future.result$finished <- base::Sys.time()
[09:31:11.619]     ...future.result
[09:31:11.619] }
[09:31:11.621] plan(): Setting new future strategy stack:
[09:31:11.621] List of future strategies:
[09:31:11.621] 1. sequential:
[09:31:11.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.621]    - tweaked: FALSE
[09:31:11.621]    - call: NULL
[09:31:11.621] plan(): nbrOfWorkers() = 1
[09:31:11.622] plan(): Setting new future strategy stack:
[09:31:11.622] List of future strategies:
[09:31:11.622] 1. sequential:
[09:31:11.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.622]    - tweaked: FALSE
[09:31:11.622]    - call: plan(strategy)
[09:31:11.622] plan(): nbrOfWorkers() = 1
[09:31:11.623] SequentialFuture started (and completed)
[09:31:11.623] - Launch lazy future ... done
[09:31:11.623] run() for ‘SequentialFuture’ ... done
[09:31:11.623] getGlobalsAndPackages() ...
[09:31:11.623] Searching for globals...
[09:31:11.623] 
[09:31:11.623] Searching for globals ... DONE
[09:31:11.623] - globals: [0] <none>
[09:31:11.625] getGlobalsAndPackages() ... DONE
[09:31:11.625] run() for ‘Future’ ...
[09:31:11.625] - state: ‘created’
[09:31:11.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.625] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.625]   - Field: ‘label’
[09:31:11.626]   - Field: ‘local’
[09:31:11.626]   - Field: ‘owner’
[09:31:11.626]   - Field: ‘envir’
[09:31:11.626]   - Field: ‘packages’
[09:31:11.626]   - Field: ‘gc’
[09:31:11.626]   - Field: ‘conditions’
[09:31:11.626]   - Field: ‘expr’
[09:31:11.626]   - Field: ‘uuid’
[09:31:11.626]   - Field: ‘seed’
[09:31:11.626]   - Field: ‘version’
[09:31:11.626]   - Field: ‘result’
[09:31:11.626]   - Field: ‘asynchronous’
[09:31:11.627]   - Field: ‘calls’
[09:31:11.627]   - Field: ‘globals’
[09:31:11.627]   - Field: ‘stdout’
[09:31:11.627]   - Field: ‘earlySignal’
[09:31:11.627]   - Field: ‘lazy’
[09:31:11.627]   - Field: ‘state’
[09:31:11.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.627] - Launch lazy future ...
[09:31:11.627] Packages needed by the future expression (n = 0): <none>
[09:31:11.627] Packages needed by future strategies (n = 0): <none>
[09:31:11.628] {
[09:31:11.628]     {
[09:31:11.628]         {
[09:31:11.628]             ...future.startTime <- base::Sys.time()
[09:31:11.628]             {
[09:31:11.628]                 {
[09:31:11.628]                   {
[09:31:11.628]                     base::local({
[09:31:11.628]                       has_future <- base::requireNamespace("future", 
[09:31:11.628]                         quietly = TRUE)
[09:31:11.628]                       if (has_future) {
[09:31:11.628]                         ns <- base::getNamespace("future")
[09:31:11.628]                         version <- ns[[".package"]][["version"]]
[09:31:11.628]                         if (is.null(version)) 
[09:31:11.628]                           version <- utils::packageVersion("future")
[09:31:11.628]                       }
[09:31:11.628]                       else {
[09:31:11.628]                         version <- NULL
[09:31:11.628]                       }
[09:31:11.628]                       if (!has_future || version < "1.8.0") {
[09:31:11.628]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.628]                           "", base::R.version$version.string), 
[09:31:11.628]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.628]                             "release", "version")], collapse = " "), 
[09:31:11.628]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.628]                           info)
[09:31:11.628]                         info <- base::paste(info, collapse = "; ")
[09:31:11.628]                         if (!has_future) {
[09:31:11.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.628]                             info)
[09:31:11.628]                         }
[09:31:11.628]                         else {
[09:31:11.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.628]                             info, version)
[09:31:11.628]                         }
[09:31:11.628]                         base::stop(msg)
[09:31:11.628]                       }
[09:31:11.628]                     })
[09:31:11.628]                   }
[09:31:11.628]                   ...future.strategy.old <- future::plan("list")
[09:31:11.628]                   options(future.plan = NULL)
[09:31:11.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.628]                 }
[09:31:11.628]                 ...future.workdir <- getwd()
[09:31:11.628]             }
[09:31:11.628]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.628]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.628]         }
[09:31:11.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.628]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.628]             base::names(...future.oldOptions))
[09:31:11.628]     }
[09:31:11.628]     if (FALSE) {
[09:31:11.628]     }
[09:31:11.628]     else {
[09:31:11.628]         if (TRUE) {
[09:31:11.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.628]                 open = "w")
[09:31:11.628]         }
[09:31:11.628]         else {
[09:31:11.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.628]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.628]         }
[09:31:11.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.628]             base::sink(type = "output", split = FALSE)
[09:31:11.628]             base::close(...future.stdout)
[09:31:11.628]         }, add = TRUE)
[09:31:11.628]     }
[09:31:11.628]     ...future.frame <- base::sys.nframe()
[09:31:11.628]     ...future.conditions <- base::list()
[09:31:11.628]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.628]     if (FALSE) {
[09:31:11.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.628]     }
[09:31:11.628]     ...future.result <- base::tryCatch({
[09:31:11.628]         base::withCallingHandlers({
[09:31:11.628]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.628]             future::FutureResult(value = ...future.value$value, 
[09:31:11.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.628]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.628]                     ...future.globalenv.names))
[09:31:11.628]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.628]         }, condition = base::local({
[09:31:11.628]             c <- base::c
[09:31:11.628]             inherits <- base::inherits
[09:31:11.628]             invokeRestart <- base::invokeRestart
[09:31:11.628]             length <- base::length
[09:31:11.628]             list <- base::list
[09:31:11.628]             seq.int <- base::seq.int
[09:31:11.628]             signalCondition <- base::signalCondition
[09:31:11.628]             sys.calls <- base::sys.calls
[09:31:11.628]             `[[` <- base::`[[`
[09:31:11.628]             `+` <- base::`+`
[09:31:11.628]             `<<-` <- base::`<<-`
[09:31:11.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.628]                   3L)]
[09:31:11.628]             }
[09:31:11.628]             function(cond) {
[09:31:11.628]                 is_error <- inherits(cond, "error")
[09:31:11.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.628]                   NULL)
[09:31:11.628]                 if (is_error) {
[09:31:11.628]                   sessionInformation <- function() {
[09:31:11.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.628]                       search = base::search(), system = base::Sys.info())
[09:31:11.628]                   }
[09:31:11.628]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.628]                     cond$call), session = sessionInformation(), 
[09:31:11.628]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.628]                   signalCondition(cond)
[09:31:11.628]                 }
[09:31:11.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.628]                 "immediateCondition"))) {
[09:31:11.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.628]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.628]                   if (TRUE && !signal) {
[09:31:11.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.628]                     {
[09:31:11.628]                       inherits <- base::inherits
[09:31:11.628]                       invokeRestart <- base::invokeRestart
[09:31:11.628]                       is.null <- base::is.null
[09:31:11.628]                       muffled <- FALSE
[09:31:11.628]                       if (inherits(cond, "message")) {
[09:31:11.628]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.628]                         if (muffled) 
[09:31:11.628]                           invokeRestart("muffleMessage")
[09:31:11.628]                       }
[09:31:11.628]                       else if (inherits(cond, "warning")) {
[09:31:11.628]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.628]                         if (muffled) 
[09:31:11.628]                           invokeRestart("muffleWarning")
[09:31:11.628]                       }
[09:31:11.628]                       else if (inherits(cond, "condition")) {
[09:31:11.628]                         if (!is.null(pattern)) {
[09:31:11.628]                           computeRestarts <- base::computeRestarts
[09:31:11.628]                           grepl <- base::grepl
[09:31:11.628]                           restarts <- computeRestarts(cond)
[09:31:11.628]                           for (restart in restarts) {
[09:31:11.628]                             name <- restart$name
[09:31:11.628]                             if (is.null(name)) 
[09:31:11.628]                               next
[09:31:11.628]                             if (!grepl(pattern, name)) 
[09:31:11.628]                               next
[09:31:11.628]                             invokeRestart(restart)
[09:31:11.628]                             muffled <- TRUE
[09:31:11.628]                             break
[09:31:11.628]                           }
[09:31:11.628]                         }
[09:31:11.628]                       }
[09:31:11.628]                       invisible(muffled)
[09:31:11.628]                     }
[09:31:11.628]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.628]                   }
[09:31:11.628]                 }
[09:31:11.628]                 else {
[09:31:11.628]                   if (TRUE) {
[09:31:11.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.628]                     {
[09:31:11.628]                       inherits <- base::inherits
[09:31:11.628]                       invokeRestart <- base::invokeRestart
[09:31:11.628]                       is.null <- base::is.null
[09:31:11.628]                       muffled <- FALSE
[09:31:11.628]                       if (inherits(cond, "message")) {
[09:31:11.628]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.628]                         if (muffled) 
[09:31:11.628]                           invokeRestart("muffleMessage")
[09:31:11.628]                       }
[09:31:11.628]                       else if (inherits(cond, "warning")) {
[09:31:11.628]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.628]                         if (muffled) 
[09:31:11.628]                           invokeRestart("muffleWarning")
[09:31:11.628]                       }
[09:31:11.628]                       else if (inherits(cond, "condition")) {
[09:31:11.628]                         if (!is.null(pattern)) {
[09:31:11.628]                           computeRestarts <- base::computeRestarts
[09:31:11.628]                           grepl <- base::grepl
[09:31:11.628]                           restarts <- computeRestarts(cond)
[09:31:11.628]                           for (restart in restarts) {
[09:31:11.628]                             name <- restart$name
[09:31:11.628]                             if (is.null(name)) 
[09:31:11.628]                               next
[09:31:11.628]                             if (!grepl(pattern, name)) 
[09:31:11.628]                               next
[09:31:11.628]                             invokeRestart(restart)
[09:31:11.628]                             muffled <- TRUE
[09:31:11.628]                             break
[09:31:11.628]                           }
[09:31:11.628]                         }
[09:31:11.628]                       }
[09:31:11.628]                       invisible(muffled)
[09:31:11.628]                     }
[09:31:11.628]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.628]                   }
[09:31:11.628]                 }
[09:31:11.628]             }
[09:31:11.628]         }))
[09:31:11.628]     }, error = function(ex) {
[09:31:11.628]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.628]                 ...future.rng), started = ...future.startTime, 
[09:31:11.628]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.628]             version = "1.8"), class = "FutureResult")
[09:31:11.628]     }, finally = {
[09:31:11.628]         if (!identical(...future.workdir, getwd())) 
[09:31:11.628]             setwd(...future.workdir)
[09:31:11.628]         {
[09:31:11.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.628]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.628]             }
[09:31:11.628]             base::options(...future.oldOptions)
[09:31:11.628]             if (.Platform$OS.type == "windows") {
[09:31:11.628]                 old_names <- names(...future.oldEnvVars)
[09:31:11.628]                 envs <- base::Sys.getenv()
[09:31:11.628]                 names <- names(envs)
[09:31:11.628]                 common <- intersect(names, old_names)
[09:31:11.628]                 added <- setdiff(names, old_names)
[09:31:11.628]                 removed <- setdiff(old_names, names)
[09:31:11.628]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.628]                   envs[common]]
[09:31:11.628]                 NAMES <- toupper(changed)
[09:31:11.628]                 args <- list()
[09:31:11.628]                 for (kk in seq_along(NAMES)) {
[09:31:11.628]                   name <- changed[[kk]]
[09:31:11.628]                   NAME <- NAMES[[kk]]
[09:31:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.628]                     next
[09:31:11.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.628]                 }
[09:31:11.628]                 NAMES <- toupper(added)
[09:31:11.628]                 for (kk in seq_along(NAMES)) {
[09:31:11.628]                   name <- added[[kk]]
[09:31:11.628]                   NAME <- NAMES[[kk]]
[09:31:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.628]                     next
[09:31:11.628]                   args[[name]] <- ""
[09:31:11.628]                 }
[09:31:11.628]                 NAMES <- toupper(removed)
[09:31:11.628]                 for (kk in seq_along(NAMES)) {
[09:31:11.628]                   name <- removed[[kk]]
[09:31:11.628]                   NAME <- NAMES[[kk]]
[09:31:11.628]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.628]                     next
[09:31:11.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.628]                 }
[09:31:11.628]                 if (length(args) > 0) 
[09:31:11.628]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.628]             }
[09:31:11.628]             else {
[09:31:11.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.628]             }
[09:31:11.628]             {
[09:31:11.628]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.628]                   0L) {
[09:31:11.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.628]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.628]                   base::options(opts)
[09:31:11.628]                 }
[09:31:11.628]                 {
[09:31:11.628]                   {
[09:31:11.628]                     NULL
[09:31:11.628]                     RNGkind("Mersenne-Twister")
[09:31:11.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.628]                       inherits = FALSE)
[09:31:11.628]                   }
[09:31:11.628]                   options(future.plan = NULL)
[09:31:11.628]                   if (is.na(NA_character_)) 
[09:31:11.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.628]                     .init = FALSE)
[09:31:11.628]                 }
[09:31:11.628]             }
[09:31:11.628]         }
[09:31:11.628]     })
[09:31:11.628]     if (TRUE) {
[09:31:11.628]         base::sink(type = "output", split = FALSE)
[09:31:11.628]         if (TRUE) {
[09:31:11.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.628]         }
[09:31:11.628]         else {
[09:31:11.628]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.628]         }
[09:31:11.628]         base::close(...future.stdout)
[09:31:11.628]         ...future.stdout <- NULL
[09:31:11.628]     }
[09:31:11.628]     ...future.result$conditions <- ...future.conditions
[09:31:11.628]     ...future.result$finished <- base::Sys.time()
[09:31:11.628]     ...future.result
[09:31:11.628] }
[09:31:11.629] plan(): Setting new future strategy stack:
[09:31:11.630] List of future strategies:
[09:31:11.630] 1. sequential:
[09:31:11.630]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.630]    - tweaked: FALSE
[09:31:11.630]    - call: NULL
[09:31:11.630] plan(): nbrOfWorkers() = 1
[09:31:11.631] plan(): Setting new future strategy stack:
[09:31:11.631] List of future strategies:
[09:31:11.631] 1. sequential:
[09:31:11.631]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.631]    - tweaked: FALSE
[09:31:11.631]    - call: plan(strategy)
[09:31:11.631] plan(): nbrOfWorkers() = 1
[09:31:11.631] SequentialFuture started (and completed)
[09:31:11.631] - Launch lazy future ... done
[09:31:11.631] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3caef1c18> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca06d248> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3caef1c18> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca06d248> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:11.636] resolved() for ‘SequentialFuture’ ...
[09:31:11.636] - state: ‘finished’
[09:31:11.636] - run: TRUE
[09:31:11.636] - result: ‘FutureResult’
[09:31:11.637] resolved() for ‘SequentialFuture’ ... done
[09:31:11.637] resolved() for ‘SequentialFuture’ ...
[09:31:11.637] - state: ‘finished’
[09:31:11.637] - run: TRUE
[09:31:11.637] - result: ‘FutureResult’
[09:31:11.637] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:11.639] resolve() on list ...
[09:31:11.639]  recursive: 0
[09:31:11.639]  length: 6
[09:31:11.639]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:11.639] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.639] - nx: 6
[09:31:11.639] - relay: TRUE
[09:31:11.639] - stdout: TRUE
[09:31:11.639] - signal: TRUE
[09:31:11.639] - resignal: FALSE
[09:31:11.639] - force: TRUE
[09:31:11.639] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.640] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.640]  - until=2
[09:31:11.640]  - relaying element #2
[09:31:11.640] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.640] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.640] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.640]  length: 5 (resolved future 1)
[09:31:11.640] resolved() for ‘SequentialFuture’ ...
[09:31:11.640] - state: ‘finished’
[09:31:11.640] - run: TRUE
[09:31:11.640] - result: ‘FutureResult’
[09:31:11.641] resolved() for ‘SequentialFuture’ ... done
[09:31:11.641] Future #2
[09:31:11.641] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.641] - nx: 6
[09:31:11.641] - relay: TRUE
[09:31:11.641] - stdout: TRUE
[09:31:11.641] - signal: TRUE
[09:31:11.641] - resignal: FALSE
[09:31:11.641] - force: TRUE
[09:31:11.641] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.641] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.641]  - until=2
[09:31:11.642]  - relaying element #2
[09:31:11.642] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.642] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.642] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.642]  length: 4 (resolved future 2)
[09:31:11.642] resolved() for ‘SequentialFuture’ ...
[09:31:11.642] - state: ‘finished’
[09:31:11.642] - run: TRUE
[09:31:11.642] - result: ‘FutureResult’
[09:31:11.642] resolved() for ‘SequentialFuture’ ... done
[09:31:11.643] Future #3
[09:31:11.643] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.643] - nx: 6
[09:31:11.643] - relay: TRUE
[09:31:11.643] - stdout: TRUE
[09:31:11.643] - signal: TRUE
[09:31:11.643] - resignal: FALSE
[09:31:11.643] - force: TRUE
[09:31:11.643] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.643] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.643]  - until=3
[09:31:11.643]  - relaying element #3
[09:31:11.644] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.644] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.644] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.644]  length: 3 (resolved future 3)
[09:31:11.644] signalConditionsASAP(NULL, pos=4) ...
[09:31:11.644] - nx: 6
[09:31:11.644] - relay: TRUE
[09:31:11.644] - stdout: TRUE
[09:31:11.644] - signal: TRUE
[09:31:11.644] - resignal: FALSE
[09:31:11.644] - force: TRUE
[09:31:11.644] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.645] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.645]  - until=5
[09:31:11.645]  - relaying element #5
[09:31:11.645] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.645] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.645] signalConditionsASAP(NULL, pos=4) ... done
[09:31:11.645]  length: 2 (resolved future 4)
[09:31:11.645] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.645] - nx: 6
[09:31:11.645] - relay: TRUE
[09:31:11.645] - stdout: TRUE
[09:31:11.645] - signal: TRUE
[09:31:11.646] - resignal: FALSE
[09:31:11.646] - force: TRUE
[09:31:11.646] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.646] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.646]  - until=6
[09:31:11.646]  - relaying element #6
[09:31:11.646] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.646] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.646] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.646]  length: 1 (resolved future 5)
[09:31:11.646] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.646] - nx: 6
[09:31:11.646] - relay: TRUE
[09:31:11.647] - stdout: TRUE
[09:31:11.647] - signal: TRUE
[09:31:11.647] - resignal: FALSE
[09:31:11.647] - force: TRUE
[09:31:11.647] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.647] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.647]  - until=6
[09:31:11.647] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.647] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.647] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.647]  length: 0 (resolved future 6)
[09:31:11.647] Relaying remaining futures
[09:31:11.648] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.648] - nx: 6
[09:31:11.648] - relay: TRUE
[09:31:11.648] - stdout: TRUE
[09:31:11.648] - signal: TRUE
[09:31:11.648] - resignal: FALSE
[09:31:11.648] - force: TRUE
[09:31:11.648] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.648] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:11.648] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.648] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.648] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.649] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:11.653] getGlobalsAndPackages() ...
[09:31:11.653] Searching for globals...
[09:31:11.653] 
[09:31:11.653] Searching for globals ... DONE
[09:31:11.653] - globals: [0] <none>
[09:31:11.653] getGlobalsAndPackages() ... DONE
[09:31:11.654] run() for ‘Future’ ...
[09:31:11.654] - state: ‘created’
[09:31:11.654] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.654] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.654]   - Field: ‘label’
[09:31:11.654]   - Field: ‘local’
[09:31:11.654]   - Field: ‘owner’
[09:31:11.655]   - Field: ‘envir’
[09:31:11.655]   - Field: ‘packages’
[09:31:11.655]   - Field: ‘gc’
[09:31:11.655]   - Field: ‘conditions’
[09:31:11.655]   - Field: ‘expr’
[09:31:11.655]   - Field: ‘uuid’
[09:31:11.655]   - Field: ‘seed’
[09:31:11.655]   - Field: ‘version’
[09:31:11.655]   - Field: ‘result’
[09:31:11.655]   - Field: ‘asynchronous’
[09:31:11.655]   - Field: ‘calls’
[09:31:11.655]   - Field: ‘globals’
[09:31:11.656]   - Field: ‘stdout’
[09:31:11.656]   - Field: ‘earlySignal’
[09:31:11.656]   - Field: ‘lazy’
[09:31:11.656]   - Field: ‘state’
[09:31:11.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.656] - Launch lazy future ...
[09:31:11.656] Packages needed by the future expression (n = 0): <none>
[09:31:11.656] Packages needed by future strategies (n = 0): <none>
[09:31:11.657] {
[09:31:11.657]     {
[09:31:11.657]         {
[09:31:11.657]             ...future.startTime <- base::Sys.time()
[09:31:11.657]             {
[09:31:11.657]                 {
[09:31:11.657]                   {
[09:31:11.657]                     base::local({
[09:31:11.657]                       has_future <- base::requireNamespace("future", 
[09:31:11.657]                         quietly = TRUE)
[09:31:11.657]                       if (has_future) {
[09:31:11.657]                         ns <- base::getNamespace("future")
[09:31:11.657]                         version <- ns[[".package"]][["version"]]
[09:31:11.657]                         if (is.null(version)) 
[09:31:11.657]                           version <- utils::packageVersion("future")
[09:31:11.657]                       }
[09:31:11.657]                       else {
[09:31:11.657]                         version <- NULL
[09:31:11.657]                       }
[09:31:11.657]                       if (!has_future || version < "1.8.0") {
[09:31:11.657]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.657]                           "", base::R.version$version.string), 
[09:31:11.657]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.657]                             "release", "version")], collapse = " "), 
[09:31:11.657]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.657]                           info)
[09:31:11.657]                         info <- base::paste(info, collapse = "; ")
[09:31:11.657]                         if (!has_future) {
[09:31:11.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.657]                             info)
[09:31:11.657]                         }
[09:31:11.657]                         else {
[09:31:11.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.657]                             info, version)
[09:31:11.657]                         }
[09:31:11.657]                         base::stop(msg)
[09:31:11.657]                       }
[09:31:11.657]                     })
[09:31:11.657]                   }
[09:31:11.657]                   ...future.strategy.old <- future::plan("list")
[09:31:11.657]                   options(future.plan = NULL)
[09:31:11.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.657]                 }
[09:31:11.657]                 ...future.workdir <- getwd()
[09:31:11.657]             }
[09:31:11.657]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.657]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.657]         }
[09:31:11.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.657]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.657]             base::names(...future.oldOptions))
[09:31:11.657]     }
[09:31:11.657]     if (FALSE) {
[09:31:11.657]     }
[09:31:11.657]     else {
[09:31:11.657]         if (TRUE) {
[09:31:11.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.657]                 open = "w")
[09:31:11.657]         }
[09:31:11.657]         else {
[09:31:11.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.657]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.657]         }
[09:31:11.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.657]             base::sink(type = "output", split = FALSE)
[09:31:11.657]             base::close(...future.stdout)
[09:31:11.657]         }, add = TRUE)
[09:31:11.657]     }
[09:31:11.657]     ...future.frame <- base::sys.nframe()
[09:31:11.657]     ...future.conditions <- base::list()
[09:31:11.657]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.657]     if (FALSE) {
[09:31:11.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.657]     }
[09:31:11.657]     ...future.result <- base::tryCatch({
[09:31:11.657]         base::withCallingHandlers({
[09:31:11.657]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.657]             future::FutureResult(value = ...future.value$value, 
[09:31:11.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.657]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.657]                     ...future.globalenv.names))
[09:31:11.657]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.657]         }, condition = base::local({
[09:31:11.657]             c <- base::c
[09:31:11.657]             inherits <- base::inherits
[09:31:11.657]             invokeRestart <- base::invokeRestart
[09:31:11.657]             length <- base::length
[09:31:11.657]             list <- base::list
[09:31:11.657]             seq.int <- base::seq.int
[09:31:11.657]             signalCondition <- base::signalCondition
[09:31:11.657]             sys.calls <- base::sys.calls
[09:31:11.657]             `[[` <- base::`[[`
[09:31:11.657]             `+` <- base::`+`
[09:31:11.657]             `<<-` <- base::`<<-`
[09:31:11.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.657]                   3L)]
[09:31:11.657]             }
[09:31:11.657]             function(cond) {
[09:31:11.657]                 is_error <- inherits(cond, "error")
[09:31:11.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.657]                   NULL)
[09:31:11.657]                 if (is_error) {
[09:31:11.657]                   sessionInformation <- function() {
[09:31:11.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.657]                       search = base::search(), system = base::Sys.info())
[09:31:11.657]                   }
[09:31:11.657]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.657]                     cond$call), session = sessionInformation(), 
[09:31:11.657]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.657]                   signalCondition(cond)
[09:31:11.657]                 }
[09:31:11.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.657]                 "immediateCondition"))) {
[09:31:11.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.657]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.657]                   if (TRUE && !signal) {
[09:31:11.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.657]                     {
[09:31:11.657]                       inherits <- base::inherits
[09:31:11.657]                       invokeRestart <- base::invokeRestart
[09:31:11.657]                       is.null <- base::is.null
[09:31:11.657]                       muffled <- FALSE
[09:31:11.657]                       if (inherits(cond, "message")) {
[09:31:11.657]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.657]                         if (muffled) 
[09:31:11.657]                           invokeRestart("muffleMessage")
[09:31:11.657]                       }
[09:31:11.657]                       else if (inherits(cond, "warning")) {
[09:31:11.657]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.657]                         if (muffled) 
[09:31:11.657]                           invokeRestart("muffleWarning")
[09:31:11.657]                       }
[09:31:11.657]                       else if (inherits(cond, "condition")) {
[09:31:11.657]                         if (!is.null(pattern)) {
[09:31:11.657]                           computeRestarts <- base::computeRestarts
[09:31:11.657]                           grepl <- base::grepl
[09:31:11.657]                           restarts <- computeRestarts(cond)
[09:31:11.657]                           for (restart in restarts) {
[09:31:11.657]                             name <- restart$name
[09:31:11.657]                             if (is.null(name)) 
[09:31:11.657]                               next
[09:31:11.657]                             if (!grepl(pattern, name)) 
[09:31:11.657]                               next
[09:31:11.657]                             invokeRestart(restart)
[09:31:11.657]                             muffled <- TRUE
[09:31:11.657]                             break
[09:31:11.657]                           }
[09:31:11.657]                         }
[09:31:11.657]                       }
[09:31:11.657]                       invisible(muffled)
[09:31:11.657]                     }
[09:31:11.657]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.657]                   }
[09:31:11.657]                 }
[09:31:11.657]                 else {
[09:31:11.657]                   if (TRUE) {
[09:31:11.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.657]                     {
[09:31:11.657]                       inherits <- base::inherits
[09:31:11.657]                       invokeRestart <- base::invokeRestart
[09:31:11.657]                       is.null <- base::is.null
[09:31:11.657]                       muffled <- FALSE
[09:31:11.657]                       if (inherits(cond, "message")) {
[09:31:11.657]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.657]                         if (muffled) 
[09:31:11.657]                           invokeRestart("muffleMessage")
[09:31:11.657]                       }
[09:31:11.657]                       else if (inherits(cond, "warning")) {
[09:31:11.657]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.657]                         if (muffled) 
[09:31:11.657]                           invokeRestart("muffleWarning")
[09:31:11.657]                       }
[09:31:11.657]                       else if (inherits(cond, "condition")) {
[09:31:11.657]                         if (!is.null(pattern)) {
[09:31:11.657]                           computeRestarts <- base::computeRestarts
[09:31:11.657]                           grepl <- base::grepl
[09:31:11.657]                           restarts <- computeRestarts(cond)
[09:31:11.657]                           for (restart in restarts) {
[09:31:11.657]                             name <- restart$name
[09:31:11.657]                             if (is.null(name)) 
[09:31:11.657]                               next
[09:31:11.657]                             if (!grepl(pattern, name)) 
[09:31:11.657]                               next
[09:31:11.657]                             invokeRestart(restart)
[09:31:11.657]                             muffled <- TRUE
[09:31:11.657]                             break
[09:31:11.657]                           }
[09:31:11.657]                         }
[09:31:11.657]                       }
[09:31:11.657]                       invisible(muffled)
[09:31:11.657]                     }
[09:31:11.657]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.657]                   }
[09:31:11.657]                 }
[09:31:11.657]             }
[09:31:11.657]         }))
[09:31:11.657]     }, error = function(ex) {
[09:31:11.657]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.657]                 ...future.rng), started = ...future.startTime, 
[09:31:11.657]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.657]             version = "1.8"), class = "FutureResult")
[09:31:11.657]     }, finally = {
[09:31:11.657]         if (!identical(...future.workdir, getwd())) 
[09:31:11.657]             setwd(...future.workdir)
[09:31:11.657]         {
[09:31:11.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.657]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.657]             }
[09:31:11.657]             base::options(...future.oldOptions)
[09:31:11.657]             if (.Platform$OS.type == "windows") {
[09:31:11.657]                 old_names <- names(...future.oldEnvVars)
[09:31:11.657]                 envs <- base::Sys.getenv()
[09:31:11.657]                 names <- names(envs)
[09:31:11.657]                 common <- intersect(names, old_names)
[09:31:11.657]                 added <- setdiff(names, old_names)
[09:31:11.657]                 removed <- setdiff(old_names, names)
[09:31:11.657]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.657]                   envs[common]]
[09:31:11.657]                 NAMES <- toupper(changed)
[09:31:11.657]                 args <- list()
[09:31:11.657]                 for (kk in seq_along(NAMES)) {
[09:31:11.657]                   name <- changed[[kk]]
[09:31:11.657]                   NAME <- NAMES[[kk]]
[09:31:11.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.657]                     next
[09:31:11.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.657]                 }
[09:31:11.657]                 NAMES <- toupper(added)
[09:31:11.657]                 for (kk in seq_along(NAMES)) {
[09:31:11.657]                   name <- added[[kk]]
[09:31:11.657]                   NAME <- NAMES[[kk]]
[09:31:11.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.657]                     next
[09:31:11.657]                   args[[name]] <- ""
[09:31:11.657]                 }
[09:31:11.657]                 NAMES <- toupper(removed)
[09:31:11.657]                 for (kk in seq_along(NAMES)) {
[09:31:11.657]                   name <- removed[[kk]]
[09:31:11.657]                   NAME <- NAMES[[kk]]
[09:31:11.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.657]                     next
[09:31:11.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.657]                 }
[09:31:11.657]                 if (length(args) > 0) 
[09:31:11.657]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.657]             }
[09:31:11.657]             else {
[09:31:11.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.657]             }
[09:31:11.657]             {
[09:31:11.657]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.657]                   0L) {
[09:31:11.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.657]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.657]                   base::options(opts)
[09:31:11.657]                 }
[09:31:11.657]                 {
[09:31:11.657]                   {
[09:31:11.657]                     NULL
[09:31:11.657]                     RNGkind("Mersenne-Twister")
[09:31:11.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.657]                       inherits = FALSE)
[09:31:11.657]                   }
[09:31:11.657]                   options(future.plan = NULL)
[09:31:11.657]                   if (is.na(NA_character_)) 
[09:31:11.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.657]                     .init = FALSE)
[09:31:11.657]                 }
[09:31:11.657]             }
[09:31:11.657]         }
[09:31:11.657]     })
[09:31:11.657]     if (TRUE) {
[09:31:11.657]         base::sink(type = "output", split = FALSE)
[09:31:11.657]         if (TRUE) {
[09:31:11.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.657]         }
[09:31:11.657]         else {
[09:31:11.657]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.657]         }
[09:31:11.657]         base::close(...future.stdout)
[09:31:11.657]         ...future.stdout <- NULL
[09:31:11.657]     }
[09:31:11.657]     ...future.result$conditions <- ...future.conditions
[09:31:11.657]     ...future.result$finished <- base::Sys.time()
[09:31:11.657]     ...future.result
[09:31:11.657] }
[09:31:11.658] plan(): Setting new future strategy stack:
[09:31:11.658] List of future strategies:
[09:31:11.658] 1. sequential:
[09:31:11.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.658]    - tweaked: FALSE
[09:31:11.658]    - call: NULL
[09:31:11.659] plan(): nbrOfWorkers() = 1
[09:31:11.659] plan(): Setting new future strategy stack:
[09:31:11.659] List of future strategies:
[09:31:11.659] 1. sequential:
[09:31:11.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.659]    - tweaked: FALSE
[09:31:11.659]    - call: plan(strategy)
[09:31:11.660] plan(): nbrOfWorkers() = 1
[09:31:11.660] SequentialFuture started (and completed)
[09:31:11.660] - Launch lazy future ... done
[09:31:11.660] run() for ‘SequentialFuture’ ... done
[09:31:11.660] getGlobalsAndPackages() ...
[09:31:11.660] Searching for globals...
[09:31:11.661] 
[09:31:11.661] Searching for globals ... DONE
[09:31:11.661] - globals: [0] <none>
[09:31:11.661] getGlobalsAndPackages() ... DONE
[09:31:11.661] run() for ‘Future’ ...
[09:31:11.661] - state: ‘created’
[09:31:11.661] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.662] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.662]   - Field: ‘label’
[09:31:11.662]   - Field: ‘local’
[09:31:11.662]   - Field: ‘owner’
[09:31:11.662]   - Field: ‘envir’
[09:31:11.662]   - Field: ‘packages’
[09:31:11.662]   - Field: ‘gc’
[09:31:11.662]   - Field: ‘conditions’
[09:31:11.662]   - Field: ‘expr’
[09:31:11.663]   - Field: ‘uuid’
[09:31:11.663]   - Field: ‘seed’
[09:31:11.663]   - Field: ‘version’
[09:31:11.663]   - Field: ‘result’
[09:31:11.663]   - Field: ‘asynchronous’
[09:31:11.663]   - Field: ‘calls’
[09:31:11.663]   - Field: ‘globals’
[09:31:11.663]   - Field: ‘stdout’
[09:31:11.663]   - Field: ‘earlySignal’
[09:31:11.663]   - Field: ‘lazy’
[09:31:11.663]   - Field: ‘state’
[09:31:11.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.664] - Launch lazy future ...
[09:31:11.664] Packages needed by the future expression (n = 0): <none>
[09:31:11.664] Packages needed by future strategies (n = 0): <none>
[09:31:11.664] {
[09:31:11.664]     {
[09:31:11.664]         {
[09:31:11.664]             ...future.startTime <- base::Sys.time()
[09:31:11.664]             {
[09:31:11.664]                 {
[09:31:11.664]                   {
[09:31:11.664]                     base::local({
[09:31:11.664]                       has_future <- base::requireNamespace("future", 
[09:31:11.664]                         quietly = TRUE)
[09:31:11.664]                       if (has_future) {
[09:31:11.664]                         ns <- base::getNamespace("future")
[09:31:11.664]                         version <- ns[[".package"]][["version"]]
[09:31:11.664]                         if (is.null(version)) 
[09:31:11.664]                           version <- utils::packageVersion("future")
[09:31:11.664]                       }
[09:31:11.664]                       else {
[09:31:11.664]                         version <- NULL
[09:31:11.664]                       }
[09:31:11.664]                       if (!has_future || version < "1.8.0") {
[09:31:11.664]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.664]                           "", base::R.version$version.string), 
[09:31:11.664]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.664]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.664]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.664]                             "release", "version")], collapse = " "), 
[09:31:11.664]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.664]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.664]                           info)
[09:31:11.664]                         info <- base::paste(info, collapse = "; ")
[09:31:11.664]                         if (!has_future) {
[09:31:11.664]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.664]                             info)
[09:31:11.664]                         }
[09:31:11.664]                         else {
[09:31:11.664]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.664]                             info, version)
[09:31:11.664]                         }
[09:31:11.664]                         base::stop(msg)
[09:31:11.664]                       }
[09:31:11.664]                     })
[09:31:11.664]                   }
[09:31:11.664]                   ...future.strategy.old <- future::plan("list")
[09:31:11.664]                   options(future.plan = NULL)
[09:31:11.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.664]                 }
[09:31:11.664]                 ...future.workdir <- getwd()
[09:31:11.664]             }
[09:31:11.664]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.664]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.664]         }
[09:31:11.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.664]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.664]             base::names(...future.oldOptions))
[09:31:11.664]     }
[09:31:11.664]     if (FALSE) {
[09:31:11.664]     }
[09:31:11.664]     else {
[09:31:11.664]         if (TRUE) {
[09:31:11.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.664]                 open = "w")
[09:31:11.664]         }
[09:31:11.664]         else {
[09:31:11.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.664]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.664]         }
[09:31:11.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.664]             base::sink(type = "output", split = FALSE)
[09:31:11.664]             base::close(...future.stdout)
[09:31:11.664]         }, add = TRUE)
[09:31:11.664]     }
[09:31:11.664]     ...future.frame <- base::sys.nframe()
[09:31:11.664]     ...future.conditions <- base::list()
[09:31:11.664]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.664]     if (FALSE) {
[09:31:11.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.664]     }
[09:31:11.664]     ...future.result <- base::tryCatch({
[09:31:11.664]         base::withCallingHandlers({
[09:31:11.664]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.664]             future::FutureResult(value = ...future.value$value, 
[09:31:11.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.664]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.664]                     ...future.globalenv.names))
[09:31:11.664]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.664]         }, condition = base::local({
[09:31:11.664]             c <- base::c
[09:31:11.664]             inherits <- base::inherits
[09:31:11.664]             invokeRestart <- base::invokeRestart
[09:31:11.664]             length <- base::length
[09:31:11.664]             list <- base::list
[09:31:11.664]             seq.int <- base::seq.int
[09:31:11.664]             signalCondition <- base::signalCondition
[09:31:11.664]             sys.calls <- base::sys.calls
[09:31:11.664]             `[[` <- base::`[[`
[09:31:11.664]             `+` <- base::`+`
[09:31:11.664]             `<<-` <- base::`<<-`
[09:31:11.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.664]                   3L)]
[09:31:11.664]             }
[09:31:11.664]             function(cond) {
[09:31:11.664]                 is_error <- inherits(cond, "error")
[09:31:11.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.664]                   NULL)
[09:31:11.664]                 if (is_error) {
[09:31:11.664]                   sessionInformation <- function() {
[09:31:11.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.664]                       search = base::search(), system = base::Sys.info())
[09:31:11.664]                   }
[09:31:11.664]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.664]                     cond$call), session = sessionInformation(), 
[09:31:11.664]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.664]                   signalCondition(cond)
[09:31:11.664]                 }
[09:31:11.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.664]                 "immediateCondition"))) {
[09:31:11.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.664]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.664]                   if (TRUE && !signal) {
[09:31:11.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.664]                     {
[09:31:11.664]                       inherits <- base::inherits
[09:31:11.664]                       invokeRestart <- base::invokeRestart
[09:31:11.664]                       is.null <- base::is.null
[09:31:11.664]                       muffled <- FALSE
[09:31:11.664]                       if (inherits(cond, "message")) {
[09:31:11.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.664]                         if (muffled) 
[09:31:11.664]                           invokeRestart("muffleMessage")
[09:31:11.664]                       }
[09:31:11.664]                       else if (inherits(cond, "warning")) {
[09:31:11.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.664]                         if (muffled) 
[09:31:11.664]                           invokeRestart("muffleWarning")
[09:31:11.664]                       }
[09:31:11.664]                       else if (inherits(cond, "condition")) {
[09:31:11.664]                         if (!is.null(pattern)) {
[09:31:11.664]                           computeRestarts <- base::computeRestarts
[09:31:11.664]                           grepl <- base::grepl
[09:31:11.664]                           restarts <- computeRestarts(cond)
[09:31:11.664]                           for (restart in restarts) {
[09:31:11.664]                             name <- restart$name
[09:31:11.664]                             if (is.null(name)) 
[09:31:11.664]                               next
[09:31:11.664]                             if (!grepl(pattern, name)) 
[09:31:11.664]                               next
[09:31:11.664]                             invokeRestart(restart)
[09:31:11.664]                             muffled <- TRUE
[09:31:11.664]                             break
[09:31:11.664]                           }
[09:31:11.664]                         }
[09:31:11.664]                       }
[09:31:11.664]                       invisible(muffled)
[09:31:11.664]                     }
[09:31:11.664]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.664]                   }
[09:31:11.664]                 }
[09:31:11.664]                 else {
[09:31:11.664]                   if (TRUE) {
[09:31:11.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.664]                     {
[09:31:11.664]                       inherits <- base::inherits
[09:31:11.664]                       invokeRestart <- base::invokeRestart
[09:31:11.664]                       is.null <- base::is.null
[09:31:11.664]                       muffled <- FALSE
[09:31:11.664]                       if (inherits(cond, "message")) {
[09:31:11.664]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.664]                         if (muffled) 
[09:31:11.664]                           invokeRestart("muffleMessage")
[09:31:11.664]                       }
[09:31:11.664]                       else if (inherits(cond, "warning")) {
[09:31:11.664]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.664]                         if (muffled) 
[09:31:11.664]                           invokeRestart("muffleWarning")
[09:31:11.664]                       }
[09:31:11.664]                       else if (inherits(cond, "condition")) {
[09:31:11.664]                         if (!is.null(pattern)) {
[09:31:11.664]                           computeRestarts <- base::computeRestarts
[09:31:11.664]                           grepl <- base::grepl
[09:31:11.664]                           restarts <- computeRestarts(cond)
[09:31:11.664]                           for (restart in restarts) {
[09:31:11.664]                             name <- restart$name
[09:31:11.664]                             if (is.null(name)) 
[09:31:11.664]                               next
[09:31:11.664]                             if (!grepl(pattern, name)) 
[09:31:11.664]                               next
[09:31:11.664]                             invokeRestart(restart)
[09:31:11.664]                             muffled <- TRUE
[09:31:11.664]                             break
[09:31:11.664]                           }
[09:31:11.664]                         }
[09:31:11.664]                       }
[09:31:11.664]                       invisible(muffled)
[09:31:11.664]                     }
[09:31:11.664]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.664]                   }
[09:31:11.664]                 }
[09:31:11.664]             }
[09:31:11.664]         }))
[09:31:11.664]     }, error = function(ex) {
[09:31:11.664]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.664]                 ...future.rng), started = ...future.startTime, 
[09:31:11.664]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.664]             version = "1.8"), class = "FutureResult")
[09:31:11.664]     }, finally = {
[09:31:11.664]         if (!identical(...future.workdir, getwd())) 
[09:31:11.664]             setwd(...future.workdir)
[09:31:11.664]         {
[09:31:11.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.664]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.664]             }
[09:31:11.664]             base::options(...future.oldOptions)
[09:31:11.664]             if (.Platform$OS.type == "windows") {
[09:31:11.664]                 old_names <- names(...future.oldEnvVars)
[09:31:11.664]                 envs <- base::Sys.getenv()
[09:31:11.664]                 names <- names(envs)
[09:31:11.664]                 common <- intersect(names, old_names)
[09:31:11.664]                 added <- setdiff(names, old_names)
[09:31:11.664]                 removed <- setdiff(old_names, names)
[09:31:11.664]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.664]                   envs[common]]
[09:31:11.664]                 NAMES <- toupper(changed)
[09:31:11.664]                 args <- list()
[09:31:11.664]                 for (kk in seq_along(NAMES)) {
[09:31:11.664]                   name <- changed[[kk]]
[09:31:11.664]                   NAME <- NAMES[[kk]]
[09:31:11.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.664]                     next
[09:31:11.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.664]                 }
[09:31:11.664]                 NAMES <- toupper(added)
[09:31:11.664]                 for (kk in seq_along(NAMES)) {
[09:31:11.664]                   name <- added[[kk]]
[09:31:11.664]                   NAME <- NAMES[[kk]]
[09:31:11.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.664]                     next
[09:31:11.664]                   args[[name]] <- ""
[09:31:11.664]                 }
[09:31:11.664]                 NAMES <- toupper(removed)
[09:31:11.664]                 for (kk in seq_along(NAMES)) {
[09:31:11.664]                   name <- removed[[kk]]
[09:31:11.664]                   NAME <- NAMES[[kk]]
[09:31:11.664]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.664]                     next
[09:31:11.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.664]                 }
[09:31:11.664]                 if (length(args) > 0) 
[09:31:11.664]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.664]             }
[09:31:11.664]             else {
[09:31:11.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.664]             }
[09:31:11.664]             {
[09:31:11.664]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.664]                   0L) {
[09:31:11.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.664]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.664]                   base::options(opts)
[09:31:11.664]                 }
[09:31:11.664]                 {
[09:31:11.664]                   {
[09:31:11.664]                     NULL
[09:31:11.664]                     RNGkind("Mersenne-Twister")
[09:31:11.664]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.664]                       inherits = FALSE)
[09:31:11.664]                   }
[09:31:11.664]                   options(future.plan = NULL)
[09:31:11.664]                   if (is.na(NA_character_)) 
[09:31:11.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.664]                     .init = FALSE)
[09:31:11.664]                 }
[09:31:11.664]             }
[09:31:11.664]         }
[09:31:11.664]     })
[09:31:11.664]     if (TRUE) {
[09:31:11.664]         base::sink(type = "output", split = FALSE)
[09:31:11.664]         if (TRUE) {
[09:31:11.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.664]         }
[09:31:11.664]         else {
[09:31:11.664]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.664]         }
[09:31:11.664]         base::close(...future.stdout)
[09:31:11.664]         ...future.stdout <- NULL
[09:31:11.664]     }
[09:31:11.664]     ...future.result$conditions <- ...future.conditions
[09:31:11.664]     ...future.result$finished <- base::Sys.time()
[09:31:11.664]     ...future.result
[09:31:11.664] }
[09:31:11.666] plan(): Setting new future strategy stack:
[09:31:11.666] List of future strategies:
[09:31:11.666] 1. sequential:
[09:31:11.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.666]    - tweaked: FALSE
[09:31:11.666]    - call: NULL
[09:31:11.666] plan(): nbrOfWorkers() = 1
[09:31:11.667] plan(): Setting new future strategy stack:
[09:31:11.667] List of future strategies:
[09:31:11.667] 1. sequential:
[09:31:11.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.667]    - tweaked: FALSE
[09:31:11.667]    - call: plan(strategy)
[09:31:11.667] plan(): nbrOfWorkers() = 1
[09:31:11.668] SequentialFuture started (and completed)
[09:31:11.668] - Launch lazy future ... done
[09:31:11.668] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c9202610> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca5ef0a8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3c9202610> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a3ca5ef0a8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:11.673] resolved() for ‘SequentialFuture’ ...
[09:31:11.673] - state: ‘finished’
[09:31:11.673] - run: TRUE
[09:31:11.673] - result: ‘FutureResult’
[09:31:11.673] resolved() for ‘SequentialFuture’ ... done
[09:31:11.673] resolved() for ‘SequentialFuture’ ...
[09:31:11.673] - state: ‘finished’
[09:31:11.673] - run: TRUE
[09:31:11.673] - result: ‘FutureResult’
[09:31:11.674] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:11.675] resolve() on list ...
[09:31:11.675]  recursive: 0
[09:31:11.676]  length: 6
[09:31:11.676]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:11.676] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.676] - nx: 6
[09:31:11.676] - relay: TRUE
[09:31:11.676] - stdout: TRUE
[09:31:11.676] - signal: TRUE
[09:31:11.676] - resignal: FALSE
[09:31:11.676] - force: TRUE
[09:31:11.676] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.676] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.677]  - until=2
[09:31:11.677]  - relaying element #2
[09:31:11.677] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.677] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.677] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.677]  length: 5 (resolved future 1)
[09:31:11.677] resolved() for ‘SequentialFuture’ ...
[09:31:11.677] - state: ‘finished’
[09:31:11.677] - run: TRUE
[09:31:11.677] - result: ‘FutureResult’
[09:31:11.677] resolved() for ‘SequentialFuture’ ... done
[09:31:11.677] Future #2
[09:31:11.678] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.678] - nx: 6
[09:31:11.678] - relay: TRUE
[09:31:11.678] - stdout: TRUE
[09:31:11.678] - signal: TRUE
[09:31:11.678] - resignal: FALSE
[09:31:11.678] - force: TRUE
[09:31:11.678] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.678] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.678]  - until=2
[09:31:11.678]  - relaying element #2
[09:31:11.679] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.679] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.679] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.679]  length: 4 (resolved future 2)
[09:31:11.680] resolved() for ‘SequentialFuture’ ...
[09:31:11.680] - state: ‘finished’
[09:31:11.680] - run: TRUE
[09:31:11.680] - result: ‘FutureResult’
[09:31:11.680] resolved() for ‘SequentialFuture’ ... done
[09:31:11.680] Future #3
[09:31:11.680] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.681] - nx: 6
[09:31:11.681] - relay: TRUE
[09:31:11.681] - stdout: TRUE
[09:31:11.681] - signal: TRUE
[09:31:11.681] - resignal: FALSE
[09:31:11.681] - force: TRUE
[09:31:11.681] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.681] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.681]  - until=3
[09:31:11.681]  - relaying element #3
[09:31:11.681] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.682] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.682] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.682]  length: 3 (resolved future 3)
[09:31:11.682] signalConditionsASAP(NULL, pos=4) ...
[09:31:11.682] - nx: 6
[09:31:11.682] - relay: TRUE
[09:31:11.682] - stdout: TRUE
[09:31:11.682] - signal: TRUE
[09:31:11.682] - resignal: FALSE
[09:31:11.682] - force: TRUE
[09:31:11.682] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.682] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.682]  - until=5
[09:31:11.683]  - relaying element #5
[09:31:11.683] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.683] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.683] signalConditionsASAP(NULL, pos=4) ... done
[09:31:11.683]  length: 2 (resolved future 4)
[09:31:11.683] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.683] - nx: 6
[09:31:11.683] - relay: TRUE
[09:31:11.683] - stdout: TRUE
[09:31:11.683] - signal: TRUE
[09:31:11.683] - resignal: FALSE
[09:31:11.683] - force: TRUE
[09:31:11.684] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.684] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.684]  - until=6
[09:31:11.684]  - relaying element #6
[09:31:11.684] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.684] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.684] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.684]  length: 1 (resolved future 5)
[09:31:11.684] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.684] - nx: 6
[09:31:11.684] - relay: TRUE
[09:31:11.684] - stdout: TRUE
[09:31:11.685] - signal: TRUE
[09:31:11.685] - resignal: FALSE
[09:31:11.685] - force: TRUE
[09:31:11.685] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.685] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.685]  - until=6
[09:31:11.685] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.685] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.685] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.685]  length: 0 (resolved future 6)
[09:31:11.685] Relaying remaining futures
[09:31:11.685] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.685] - nx: 6
[09:31:11.686] - relay: TRUE
[09:31:11.686] - stdout: TRUE
[09:31:11.686] - signal: TRUE
[09:31:11.686] - resignal: FALSE
[09:31:11.686] - force: TRUE
[09:31:11.686] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.686] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:11.686] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.686] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.686] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.686] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[09:31:11.694] plan(): Setting new future strategy stack:
[09:31:11.695] List of future strategies:
[09:31:11.695] 1. sequential:
[09:31:11.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.695]    - tweaked: FALSE
[09:31:11.695]    - call: plan(strategy)
[09:31:11.695] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[09:31:11.695] getGlobalsAndPackages() ...
[09:31:11.695] Searching for globals...
[09:31:11.695] 
[09:31:11.696] Searching for globals ... DONE
[09:31:11.696] - globals: [0] <none>
[09:31:11.696] getGlobalsAndPackages() ... DONE
[09:31:11.696] run() for ‘Future’ ...
[09:31:11.696] - state: ‘created’
[09:31:11.696] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.696] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.697]   - Field: ‘label’
[09:31:11.697]   - Field: ‘local’
[09:31:11.697]   - Field: ‘owner’
[09:31:11.697]   - Field: ‘envir’
[09:31:11.697]   - Field: ‘packages’
[09:31:11.697]   - Field: ‘gc’
[09:31:11.697]   - Field: ‘conditions’
[09:31:11.697]   - Field: ‘expr’
[09:31:11.697]   - Field: ‘uuid’
[09:31:11.697]   - Field: ‘seed’
[09:31:11.697]   - Field: ‘version’
[09:31:11.698]   - Field: ‘result’
[09:31:11.698]   - Field: ‘asynchronous’
[09:31:11.698]   - Field: ‘calls’
[09:31:11.698]   - Field: ‘globals’
[09:31:11.698]   - Field: ‘stdout’
[09:31:11.698]   - Field: ‘earlySignal’
[09:31:11.698]   - Field: ‘lazy’
[09:31:11.698]   - Field: ‘state’
[09:31:11.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.698] - Launch lazy future ...
[09:31:11.698] Packages needed by the future expression (n = 0): <none>
[09:31:11.699] Packages needed by future strategies (n = 0): <none>
[09:31:11.699] {
[09:31:11.699]     {
[09:31:11.699]         {
[09:31:11.699]             ...future.startTime <- base::Sys.time()
[09:31:11.699]             {
[09:31:11.699]                 {
[09:31:11.699]                   {
[09:31:11.699]                     base::local({
[09:31:11.699]                       has_future <- base::requireNamespace("future", 
[09:31:11.699]                         quietly = TRUE)
[09:31:11.699]                       if (has_future) {
[09:31:11.699]                         ns <- base::getNamespace("future")
[09:31:11.699]                         version <- ns[[".package"]][["version"]]
[09:31:11.699]                         if (is.null(version)) 
[09:31:11.699]                           version <- utils::packageVersion("future")
[09:31:11.699]                       }
[09:31:11.699]                       else {
[09:31:11.699]                         version <- NULL
[09:31:11.699]                       }
[09:31:11.699]                       if (!has_future || version < "1.8.0") {
[09:31:11.699]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.699]                           "", base::R.version$version.string), 
[09:31:11.699]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.699]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.699]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.699]                             "release", "version")], collapse = " "), 
[09:31:11.699]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.699]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.699]                           info)
[09:31:11.699]                         info <- base::paste(info, collapse = "; ")
[09:31:11.699]                         if (!has_future) {
[09:31:11.699]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.699]                             info)
[09:31:11.699]                         }
[09:31:11.699]                         else {
[09:31:11.699]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.699]                             info, version)
[09:31:11.699]                         }
[09:31:11.699]                         base::stop(msg)
[09:31:11.699]                       }
[09:31:11.699]                     })
[09:31:11.699]                   }
[09:31:11.699]                   ...future.strategy.old <- future::plan("list")
[09:31:11.699]                   options(future.plan = NULL)
[09:31:11.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.699]                 }
[09:31:11.699]                 ...future.workdir <- getwd()
[09:31:11.699]             }
[09:31:11.699]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.699]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.699]         }
[09:31:11.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.699]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.699]             base::names(...future.oldOptions))
[09:31:11.699]     }
[09:31:11.699]     if (FALSE) {
[09:31:11.699]     }
[09:31:11.699]     else {
[09:31:11.699]         if (TRUE) {
[09:31:11.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.699]                 open = "w")
[09:31:11.699]         }
[09:31:11.699]         else {
[09:31:11.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.699]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.699]         }
[09:31:11.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.699]             base::sink(type = "output", split = FALSE)
[09:31:11.699]             base::close(...future.stdout)
[09:31:11.699]         }, add = TRUE)
[09:31:11.699]     }
[09:31:11.699]     ...future.frame <- base::sys.nframe()
[09:31:11.699]     ...future.conditions <- base::list()
[09:31:11.699]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.699]     if (FALSE) {
[09:31:11.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.699]     }
[09:31:11.699]     ...future.result <- base::tryCatch({
[09:31:11.699]         base::withCallingHandlers({
[09:31:11.699]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.699]             future::FutureResult(value = ...future.value$value, 
[09:31:11.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.699]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.699]                     ...future.globalenv.names))
[09:31:11.699]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.699]         }, condition = base::local({
[09:31:11.699]             c <- base::c
[09:31:11.699]             inherits <- base::inherits
[09:31:11.699]             invokeRestart <- base::invokeRestart
[09:31:11.699]             length <- base::length
[09:31:11.699]             list <- base::list
[09:31:11.699]             seq.int <- base::seq.int
[09:31:11.699]             signalCondition <- base::signalCondition
[09:31:11.699]             sys.calls <- base::sys.calls
[09:31:11.699]             `[[` <- base::`[[`
[09:31:11.699]             `+` <- base::`+`
[09:31:11.699]             `<<-` <- base::`<<-`
[09:31:11.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.699]                   3L)]
[09:31:11.699]             }
[09:31:11.699]             function(cond) {
[09:31:11.699]                 is_error <- inherits(cond, "error")
[09:31:11.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.699]                   NULL)
[09:31:11.699]                 if (is_error) {
[09:31:11.699]                   sessionInformation <- function() {
[09:31:11.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.699]                       search = base::search(), system = base::Sys.info())
[09:31:11.699]                   }
[09:31:11.699]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.699]                     cond$call), session = sessionInformation(), 
[09:31:11.699]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.699]                   signalCondition(cond)
[09:31:11.699]                 }
[09:31:11.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.699]                 "immediateCondition"))) {
[09:31:11.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.699]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.699]                   if (TRUE && !signal) {
[09:31:11.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.699]                     {
[09:31:11.699]                       inherits <- base::inherits
[09:31:11.699]                       invokeRestart <- base::invokeRestart
[09:31:11.699]                       is.null <- base::is.null
[09:31:11.699]                       muffled <- FALSE
[09:31:11.699]                       if (inherits(cond, "message")) {
[09:31:11.699]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.699]                         if (muffled) 
[09:31:11.699]                           invokeRestart("muffleMessage")
[09:31:11.699]                       }
[09:31:11.699]                       else if (inherits(cond, "warning")) {
[09:31:11.699]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.699]                         if (muffled) 
[09:31:11.699]                           invokeRestart("muffleWarning")
[09:31:11.699]                       }
[09:31:11.699]                       else if (inherits(cond, "condition")) {
[09:31:11.699]                         if (!is.null(pattern)) {
[09:31:11.699]                           computeRestarts <- base::computeRestarts
[09:31:11.699]                           grepl <- base::grepl
[09:31:11.699]                           restarts <- computeRestarts(cond)
[09:31:11.699]                           for (restart in restarts) {
[09:31:11.699]                             name <- restart$name
[09:31:11.699]                             if (is.null(name)) 
[09:31:11.699]                               next
[09:31:11.699]                             if (!grepl(pattern, name)) 
[09:31:11.699]                               next
[09:31:11.699]                             invokeRestart(restart)
[09:31:11.699]                             muffled <- TRUE
[09:31:11.699]                             break
[09:31:11.699]                           }
[09:31:11.699]                         }
[09:31:11.699]                       }
[09:31:11.699]                       invisible(muffled)
[09:31:11.699]                     }
[09:31:11.699]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.699]                   }
[09:31:11.699]                 }
[09:31:11.699]                 else {
[09:31:11.699]                   if (TRUE) {
[09:31:11.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.699]                     {
[09:31:11.699]                       inherits <- base::inherits
[09:31:11.699]                       invokeRestart <- base::invokeRestart
[09:31:11.699]                       is.null <- base::is.null
[09:31:11.699]                       muffled <- FALSE
[09:31:11.699]                       if (inherits(cond, "message")) {
[09:31:11.699]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.699]                         if (muffled) 
[09:31:11.699]                           invokeRestart("muffleMessage")
[09:31:11.699]                       }
[09:31:11.699]                       else if (inherits(cond, "warning")) {
[09:31:11.699]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.699]                         if (muffled) 
[09:31:11.699]                           invokeRestart("muffleWarning")
[09:31:11.699]                       }
[09:31:11.699]                       else if (inherits(cond, "condition")) {
[09:31:11.699]                         if (!is.null(pattern)) {
[09:31:11.699]                           computeRestarts <- base::computeRestarts
[09:31:11.699]                           grepl <- base::grepl
[09:31:11.699]                           restarts <- computeRestarts(cond)
[09:31:11.699]                           for (restart in restarts) {
[09:31:11.699]                             name <- restart$name
[09:31:11.699]                             if (is.null(name)) 
[09:31:11.699]                               next
[09:31:11.699]                             if (!grepl(pattern, name)) 
[09:31:11.699]                               next
[09:31:11.699]                             invokeRestart(restart)
[09:31:11.699]                             muffled <- TRUE
[09:31:11.699]                             break
[09:31:11.699]                           }
[09:31:11.699]                         }
[09:31:11.699]                       }
[09:31:11.699]                       invisible(muffled)
[09:31:11.699]                     }
[09:31:11.699]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.699]                   }
[09:31:11.699]                 }
[09:31:11.699]             }
[09:31:11.699]         }))
[09:31:11.699]     }, error = function(ex) {
[09:31:11.699]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.699]                 ...future.rng), started = ...future.startTime, 
[09:31:11.699]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.699]             version = "1.8"), class = "FutureResult")
[09:31:11.699]     }, finally = {
[09:31:11.699]         if (!identical(...future.workdir, getwd())) 
[09:31:11.699]             setwd(...future.workdir)
[09:31:11.699]         {
[09:31:11.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.699]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.699]             }
[09:31:11.699]             base::options(...future.oldOptions)
[09:31:11.699]             if (.Platform$OS.type == "windows") {
[09:31:11.699]                 old_names <- names(...future.oldEnvVars)
[09:31:11.699]                 envs <- base::Sys.getenv()
[09:31:11.699]                 names <- names(envs)
[09:31:11.699]                 common <- intersect(names, old_names)
[09:31:11.699]                 added <- setdiff(names, old_names)
[09:31:11.699]                 removed <- setdiff(old_names, names)
[09:31:11.699]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.699]                   envs[common]]
[09:31:11.699]                 NAMES <- toupper(changed)
[09:31:11.699]                 args <- list()
[09:31:11.699]                 for (kk in seq_along(NAMES)) {
[09:31:11.699]                   name <- changed[[kk]]
[09:31:11.699]                   NAME <- NAMES[[kk]]
[09:31:11.699]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.699]                     next
[09:31:11.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.699]                 }
[09:31:11.699]                 NAMES <- toupper(added)
[09:31:11.699]                 for (kk in seq_along(NAMES)) {
[09:31:11.699]                   name <- added[[kk]]
[09:31:11.699]                   NAME <- NAMES[[kk]]
[09:31:11.699]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.699]                     next
[09:31:11.699]                   args[[name]] <- ""
[09:31:11.699]                 }
[09:31:11.699]                 NAMES <- toupper(removed)
[09:31:11.699]                 for (kk in seq_along(NAMES)) {
[09:31:11.699]                   name <- removed[[kk]]
[09:31:11.699]                   NAME <- NAMES[[kk]]
[09:31:11.699]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.699]                     next
[09:31:11.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.699]                 }
[09:31:11.699]                 if (length(args) > 0) 
[09:31:11.699]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.699]             }
[09:31:11.699]             else {
[09:31:11.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.699]             }
[09:31:11.699]             {
[09:31:11.699]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.699]                   0L) {
[09:31:11.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.699]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.699]                   base::options(opts)
[09:31:11.699]                 }
[09:31:11.699]                 {
[09:31:11.699]                   {
[09:31:11.699]                     NULL
[09:31:11.699]                     RNGkind("Mersenne-Twister")
[09:31:11.699]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.699]                       inherits = FALSE)
[09:31:11.699]                   }
[09:31:11.699]                   options(future.plan = NULL)
[09:31:11.699]                   if (is.na(NA_character_)) 
[09:31:11.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.699]                     .init = FALSE)
[09:31:11.699]                 }
[09:31:11.699]             }
[09:31:11.699]         }
[09:31:11.699]     })
[09:31:11.699]     if (TRUE) {
[09:31:11.699]         base::sink(type = "output", split = FALSE)
[09:31:11.699]         if (TRUE) {
[09:31:11.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.699]         }
[09:31:11.699]         else {
[09:31:11.699]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.699]         }
[09:31:11.699]         base::close(...future.stdout)
[09:31:11.699]         ...future.stdout <- NULL
[09:31:11.699]     }
[09:31:11.699]     ...future.result$conditions <- ...future.conditions
[09:31:11.699]     ...future.result$finished <- base::Sys.time()
[09:31:11.699]     ...future.result
[09:31:11.699] }
[09:31:11.701] plan(): Setting new future strategy stack:
[09:31:11.701] List of future strategies:
[09:31:11.701] 1. sequential:
[09:31:11.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.701]    - tweaked: FALSE
[09:31:11.701]    - call: NULL
[09:31:11.701] plan(): nbrOfWorkers() = 1
[09:31:11.702] plan(): Setting new future strategy stack:
[09:31:11.702] List of future strategies:
[09:31:11.702] 1. sequential:
[09:31:11.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.702]    - tweaked: FALSE
[09:31:11.702]    - call: plan(strategy)
[09:31:11.702] plan(): nbrOfWorkers() = 1
[09:31:11.702] SequentialFuture started (and completed)
[09:31:11.703] - Launch lazy future ... done
[09:31:11.703] run() for ‘SequentialFuture’ ... done
[09:31:11.703] getGlobalsAndPackages() ...
[09:31:11.703] Searching for globals...
[09:31:11.703] 
[09:31:11.703] Searching for globals ... DONE
[09:31:11.703] - globals: [0] <none>
[09:31:11.703] getGlobalsAndPackages() ... DONE
[09:31:11.704] run() for ‘Future’ ...
[09:31:11.704] - state: ‘created’
[09:31:11.704] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.704] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.704]   - Field: ‘label’
[09:31:11.705]   - Field: ‘local’
[09:31:11.705]   - Field: ‘owner’
[09:31:11.705]   - Field: ‘envir’
[09:31:11.706]   - Field: ‘packages’
[09:31:11.706]   - Field: ‘gc’
[09:31:11.706]   - Field: ‘conditions’
[09:31:11.706]   - Field: ‘expr’
[09:31:11.706]   - Field: ‘uuid’
[09:31:11.706]   - Field: ‘seed’
[09:31:11.706]   - Field: ‘version’
[09:31:11.706]   - Field: ‘result’
[09:31:11.706]   - Field: ‘asynchronous’
[09:31:11.706]   - Field: ‘calls’
[09:31:11.706]   - Field: ‘globals’
[09:31:11.706]   - Field: ‘stdout’
[09:31:11.707]   - Field: ‘earlySignal’
[09:31:11.707]   - Field: ‘lazy’
[09:31:11.707]   - Field: ‘state’
[09:31:11.707] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.707] - Launch lazy future ...
[09:31:11.707] Packages needed by the future expression (n = 0): <none>
[09:31:11.707] Packages needed by future strategies (n = 0): <none>
[09:31:11.708] {
[09:31:11.708]     {
[09:31:11.708]         {
[09:31:11.708]             ...future.startTime <- base::Sys.time()
[09:31:11.708]             {
[09:31:11.708]                 {
[09:31:11.708]                   {
[09:31:11.708]                     base::local({
[09:31:11.708]                       has_future <- base::requireNamespace("future", 
[09:31:11.708]                         quietly = TRUE)
[09:31:11.708]                       if (has_future) {
[09:31:11.708]                         ns <- base::getNamespace("future")
[09:31:11.708]                         version <- ns[[".package"]][["version"]]
[09:31:11.708]                         if (is.null(version)) 
[09:31:11.708]                           version <- utils::packageVersion("future")
[09:31:11.708]                       }
[09:31:11.708]                       else {
[09:31:11.708]                         version <- NULL
[09:31:11.708]                       }
[09:31:11.708]                       if (!has_future || version < "1.8.0") {
[09:31:11.708]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.708]                           "", base::R.version$version.string), 
[09:31:11.708]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.708]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.708]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.708]                             "release", "version")], collapse = " "), 
[09:31:11.708]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.708]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.708]                           info)
[09:31:11.708]                         info <- base::paste(info, collapse = "; ")
[09:31:11.708]                         if (!has_future) {
[09:31:11.708]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.708]                             info)
[09:31:11.708]                         }
[09:31:11.708]                         else {
[09:31:11.708]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.708]                             info, version)
[09:31:11.708]                         }
[09:31:11.708]                         base::stop(msg)
[09:31:11.708]                       }
[09:31:11.708]                     })
[09:31:11.708]                   }
[09:31:11.708]                   ...future.strategy.old <- future::plan("list")
[09:31:11.708]                   options(future.plan = NULL)
[09:31:11.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.708]                 }
[09:31:11.708]                 ...future.workdir <- getwd()
[09:31:11.708]             }
[09:31:11.708]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.708]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.708]         }
[09:31:11.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.708]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.708]             base::names(...future.oldOptions))
[09:31:11.708]     }
[09:31:11.708]     if (FALSE) {
[09:31:11.708]     }
[09:31:11.708]     else {
[09:31:11.708]         if (TRUE) {
[09:31:11.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.708]                 open = "w")
[09:31:11.708]         }
[09:31:11.708]         else {
[09:31:11.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.708]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.708]         }
[09:31:11.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.708]             base::sink(type = "output", split = FALSE)
[09:31:11.708]             base::close(...future.stdout)
[09:31:11.708]         }, add = TRUE)
[09:31:11.708]     }
[09:31:11.708]     ...future.frame <- base::sys.nframe()
[09:31:11.708]     ...future.conditions <- base::list()
[09:31:11.708]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.708]     if (FALSE) {
[09:31:11.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.708]     }
[09:31:11.708]     ...future.result <- base::tryCatch({
[09:31:11.708]         base::withCallingHandlers({
[09:31:11.708]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.708]             future::FutureResult(value = ...future.value$value, 
[09:31:11.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.708]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.708]                     ...future.globalenv.names))
[09:31:11.708]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.708]         }, condition = base::local({
[09:31:11.708]             c <- base::c
[09:31:11.708]             inherits <- base::inherits
[09:31:11.708]             invokeRestart <- base::invokeRestart
[09:31:11.708]             length <- base::length
[09:31:11.708]             list <- base::list
[09:31:11.708]             seq.int <- base::seq.int
[09:31:11.708]             signalCondition <- base::signalCondition
[09:31:11.708]             sys.calls <- base::sys.calls
[09:31:11.708]             `[[` <- base::`[[`
[09:31:11.708]             `+` <- base::`+`
[09:31:11.708]             `<<-` <- base::`<<-`
[09:31:11.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.708]                   3L)]
[09:31:11.708]             }
[09:31:11.708]             function(cond) {
[09:31:11.708]                 is_error <- inherits(cond, "error")
[09:31:11.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.708]                   NULL)
[09:31:11.708]                 if (is_error) {
[09:31:11.708]                   sessionInformation <- function() {
[09:31:11.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.708]                       search = base::search(), system = base::Sys.info())
[09:31:11.708]                   }
[09:31:11.708]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.708]                     cond$call), session = sessionInformation(), 
[09:31:11.708]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.708]                   signalCondition(cond)
[09:31:11.708]                 }
[09:31:11.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.708]                 "immediateCondition"))) {
[09:31:11.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.708]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.708]                   if (TRUE && !signal) {
[09:31:11.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.708]                     {
[09:31:11.708]                       inherits <- base::inherits
[09:31:11.708]                       invokeRestart <- base::invokeRestart
[09:31:11.708]                       is.null <- base::is.null
[09:31:11.708]                       muffled <- FALSE
[09:31:11.708]                       if (inherits(cond, "message")) {
[09:31:11.708]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.708]                         if (muffled) 
[09:31:11.708]                           invokeRestart("muffleMessage")
[09:31:11.708]                       }
[09:31:11.708]                       else if (inherits(cond, "warning")) {
[09:31:11.708]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.708]                         if (muffled) 
[09:31:11.708]                           invokeRestart("muffleWarning")
[09:31:11.708]                       }
[09:31:11.708]                       else if (inherits(cond, "condition")) {
[09:31:11.708]                         if (!is.null(pattern)) {
[09:31:11.708]                           computeRestarts <- base::computeRestarts
[09:31:11.708]                           grepl <- base::grepl
[09:31:11.708]                           restarts <- computeRestarts(cond)
[09:31:11.708]                           for (restart in restarts) {
[09:31:11.708]                             name <- restart$name
[09:31:11.708]                             if (is.null(name)) 
[09:31:11.708]                               next
[09:31:11.708]                             if (!grepl(pattern, name)) 
[09:31:11.708]                               next
[09:31:11.708]                             invokeRestart(restart)
[09:31:11.708]                             muffled <- TRUE
[09:31:11.708]                             break
[09:31:11.708]                           }
[09:31:11.708]                         }
[09:31:11.708]                       }
[09:31:11.708]                       invisible(muffled)
[09:31:11.708]                     }
[09:31:11.708]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.708]                   }
[09:31:11.708]                 }
[09:31:11.708]                 else {
[09:31:11.708]                   if (TRUE) {
[09:31:11.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.708]                     {
[09:31:11.708]                       inherits <- base::inherits
[09:31:11.708]                       invokeRestart <- base::invokeRestart
[09:31:11.708]                       is.null <- base::is.null
[09:31:11.708]                       muffled <- FALSE
[09:31:11.708]                       if (inherits(cond, "message")) {
[09:31:11.708]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.708]                         if (muffled) 
[09:31:11.708]                           invokeRestart("muffleMessage")
[09:31:11.708]                       }
[09:31:11.708]                       else if (inherits(cond, "warning")) {
[09:31:11.708]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.708]                         if (muffled) 
[09:31:11.708]                           invokeRestart("muffleWarning")
[09:31:11.708]                       }
[09:31:11.708]                       else if (inherits(cond, "condition")) {
[09:31:11.708]                         if (!is.null(pattern)) {
[09:31:11.708]                           computeRestarts <- base::computeRestarts
[09:31:11.708]                           grepl <- base::grepl
[09:31:11.708]                           restarts <- computeRestarts(cond)
[09:31:11.708]                           for (restart in restarts) {
[09:31:11.708]                             name <- restart$name
[09:31:11.708]                             if (is.null(name)) 
[09:31:11.708]                               next
[09:31:11.708]                             if (!grepl(pattern, name)) 
[09:31:11.708]                               next
[09:31:11.708]                             invokeRestart(restart)
[09:31:11.708]                             muffled <- TRUE
[09:31:11.708]                             break
[09:31:11.708]                           }
[09:31:11.708]                         }
[09:31:11.708]                       }
[09:31:11.708]                       invisible(muffled)
[09:31:11.708]                     }
[09:31:11.708]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.708]                   }
[09:31:11.708]                 }
[09:31:11.708]             }
[09:31:11.708]         }))
[09:31:11.708]     }, error = function(ex) {
[09:31:11.708]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.708]                 ...future.rng), started = ...future.startTime, 
[09:31:11.708]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.708]             version = "1.8"), class = "FutureResult")
[09:31:11.708]     }, finally = {
[09:31:11.708]         if (!identical(...future.workdir, getwd())) 
[09:31:11.708]             setwd(...future.workdir)
[09:31:11.708]         {
[09:31:11.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.708]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.708]             }
[09:31:11.708]             base::options(...future.oldOptions)
[09:31:11.708]             if (.Platform$OS.type == "windows") {
[09:31:11.708]                 old_names <- names(...future.oldEnvVars)
[09:31:11.708]                 envs <- base::Sys.getenv()
[09:31:11.708]                 names <- names(envs)
[09:31:11.708]                 common <- intersect(names, old_names)
[09:31:11.708]                 added <- setdiff(names, old_names)
[09:31:11.708]                 removed <- setdiff(old_names, names)
[09:31:11.708]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.708]                   envs[common]]
[09:31:11.708]                 NAMES <- toupper(changed)
[09:31:11.708]                 args <- list()
[09:31:11.708]                 for (kk in seq_along(NAMES)) {
[09:31:11.708]                   name <- changed[[kk]]
[09:31:11.708]                   NAME <- NAMES[[kk]]
[09:31:11.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.708]                     next
[09:31:11.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.708]                 }
[09:31:11.708]                 NAMES <- toupper(added)
[09:31:11.708]                 for (kk in seq_along(NAMES)) {
[09:31:11.708]                   name <- added[[kk]]
[09:31:11.708]                   NAME <- NAMES[[kk]]
[09:31:11.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.708]                     next
[09:31:11.708]                   args[[name]] <- ""
[09:31:11.708]                 }
[09:31:11.708]                 NAMES <- toupper(removed)
[09:31:11.708]                 for (kk in seq_along(NAMES)) {
[09:31:11.708]                   name <- removed[[kk]]
[09:31:11.708]                   NAME <- NAMES[[kk]]
[09:31:11.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.708]                     next
[09:31:11.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.708]                 }
[09:31:11.708]                 if (length(args) > 0) 
[09:31:11.708]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.708]             }
[09:31:11.708]             else {
[09:31:11.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.708]             }
[09:31:11.708]             {
[09:31:11.708]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.708]                   0L) {
[09:31:11.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.708]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.708]                   base::options(opts)
[09:31:11.708]                 }
[09:31:11.708]                 {
[09:31:11.708]                   {
[09:31:11.708]                     NULL
[09:31:11.708]                     RNGkind("Mersenne-Twister")
[09:31:11.708]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.708]                       inherits = FALSE)
[09:31:11.708]                   }
[09:31:11.708]                   options(future.plan = NULL)
[09:31:11.708]                   if (is.na(NA_character_)) 
[09:31:11.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.708]                     .init = FALSE)
[09:31:11.708]                 }
[09:31:11.708]             }
[09:31:11.708]         }
[09:31:11.708]     })
[09:31:11.708]     if (TRUE) {
[09:31:11.708]         base::sink(type = "output", split = FALSE)
[09:31:11.708]         if (TRUE) {
[09:31:11.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.708]         }
[09:31:11.708]         else {
[09:31:11.708]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.708]         }
[09:31:11.708]         base::close(...future.stdout)
[09:31:11.708]         ...future.stdout <- NULL
[09:31:11.708]     }
[09:31:11.708]     ...future.result$conditions <- ...future.conditions
[09:31:11.708]     ...future.result$finished <- base::Sys.time()
[09:31:11.708]     ...future.result
[09:31:11.708] }
[09:31:11.709] plan(): Setting new future strategy stack:
[09:31:11.709] List of future strategies:
[09:31:11.709] 1. sequential:
[09:31:11.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.709]    - tweaked: FALSE
[09:31:11.709]    - call: NULL
[09:31:11.710] plan(): nbrOfWorkers() = 1
[09:31:11.710] plan(): Setting new future strategy stack:
[09:31:11.710] List of future strategies:
[09:31:11.710] 1. sequential:
[09:31:11.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.710]    - tweaked: FALSE
[09:31:11.710]    - call: plan(strategy)
[09:31:11.711] plan(): nbrOfWorkers() = 1
[09:31:11.711] SequentialFuture started (and completed)
[09:31:11.711] - Launch lazy future ... done
[09:31:11.711] run() for ‘SequentialFuture’ ... done
[09:31:11.712] getGlobalsAndPackages() ...
[09:31:11.712] Searching for globals...
[09:31:11.714] - globals found: [1] ‘{’
[09:31:11.714] Searching for globals ... DONE
[09:31:11.714] Resolving globals: FALSE
[09:31:11.714] 
[09:31:11.714] 
[09:31:11.714] getGlobalsAndPackages() ... DONE
[09:31:11.715] run() for ‘Future’ ...
[09:31:11.715] - state: ‘created’
[09:31:11.715] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.715] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.715]   - Field: ‘label’
[09:31:11.715]   - Field: ‘local’
[09:31:11.715]   - Field: ‘owner’
[09:31:11.715]   - Field: ‘envir’
[09:31:11.716]   - Field: ‘packages’
[09:31:11.716]   - Field: ‘gc’
[09:31:11.716]   - Field: ‘conditions’
[09:31:11.716]   - Field: ‘expr’
[09:31:11.716]   - Field: ‘uuid’
[09:31:11.716]   - Field: ‘seed’
[09:31:11.716]   - Field: ‘version’
[09:31:11.716]   - Field: ‘result’
[09:31:11.716]   - Field: ‘asynchronous’
[09:31:11.716]   - Field: ‘calls’
[09:31:11.716]   - Field: ‘globals’
[09:31:11.717]   - Field: ‘stdout’
[09:31:11.717]   - Field: ‘earlySignal’
[09:31:11.717]   - Field: ‘lazy’
[09:31:11.717]   - Field: ‘state’
[09:31:11.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.717] - Launch lazy future ...
[09:31:11.717] Packages needed by the future expression (n = 0): <none>
[09:31:11.717] Packages needed by future strategies (n = 0): <none>
[09:31:11.718] {
[09:31:11.718]     {
[09:31:11.718]         {
[09:31:11.718]             ...future.startTime <- base::Sys.time()
[09:31:11.718]             {
[09:31:11.718]                 {
[09:31:11.718]                   {
[09:31:11.718]                     base::local({
[09:31:11.718]                       has_future <- base::requireNamespace("future", 
[09:31:11.718]                         quietly = TRUE)
[09:31:11.718]                       if (has_future) {
[09:31:11.718]                         ns <- base::getNamespace("future")
[09:31:11.718]                         version <- ns[[".package"]][["version"]]
[09:31:11.718]                         if (is.null(version)) 
[09:31:11.718]                           version <- utils::packageVersion("future")
[09:31:11.718]                       }
[09:31:11.718]                       else {
[09:31:11.718]                         version <- NULL
[09:31:11.718]                       }
[09:31:11.718]                       if (!has_future || version < "1.8.0") {
[09:31:11.718]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.718]                           "", base::R.version$version.string), 
[09:31:11.718]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.718]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.718]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.718]                             "release", "version")], collapse = " "), 
[09:31:11.718]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.718]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.718]                           info)
[09:31:11.718]                         info <- base::paste(info, collapse = "; ")
[09:31:11.718]                         if (!has_future) {
[09:31:11.718]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.718]                             info)
[09:31:11.718]                         }
[09:31:11.718]                         else {
[09:31:11.718]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.718]                             info, version)
[09:31:11.718]                         }
[09:31:11.718]                         base::stop(msg)
[09:31:11.718]                       }
[09:31:11.718]                     })
[09:31:11.718]                   }
[09:31:11.718]                   ...future.strategy.old <- future::plan("list")
[09:31:11.718]                   options(future.plan = NULL)
[09:31:11.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.718]                 }
[09:31:11.718]                 ...future.workdir <- getwd()
[09:31:11.718]             }
[09:31:11.718]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.718]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.718]         }
[09:31:11.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.718]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.718]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.718]             base::names(...future.oldOptions))
[09:31:11.718]     }
[09:31:11.718]     if (FALSE) {
[09:31:11.718]     }
[09:31:11.718]     else {
[09:31:11.718]         if (TRUE) {
[09:31:11.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.718]                 open = "w")
[09:31:11.718]         }
[09:31:11.718]         else {
[09:31:11.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.718]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.718]         }
[09:31:11.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.718]             base::sink(type = "output", split = FALSE)
[09:31:11.718]             base::close(...future.stdout)
[09:31:11.718]         }, add = TRUE)
[09:31:11.718]     }
[09:31:11.718]     ...future.frame <- base::sys.nframe()
[09:31:11.718]     ...future.conditions <- base::list()
[09:31:11.718]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.718]     if (FALSE) {
[09:31:11.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.718]     }
[09:31:11.718]     ...future.result <- base::tryCatch({
[09:31:11.718]         base::withCallingHandlers({
[09:31:11.718]             ...future.value <- base::withVisible(base::local({
[09:31:11.718]                 4
[09:31:11.718]             }))
[09:31:11.718]             future::FutureResult(value = ...future.value$value, 
[09:31:11.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.718]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.718]                     ...future.globalenv.names))
[09:31:11.718]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.718]         }, condition = base::local({
[09:31:11.718]             c <- base::c
[09:31:11.718]             inherits <- base::inherits
[09:31:11.718]             invokeRestart <- base::invokeRestart
[09:31:11.718]             length <- base::length
[09:31:11.718]             list <- base::list
[09:31:11.718]             seq.int <- base::seq.int
[09:31:11.718]             signalCondition <- base::signalCondition
[09:31:11.718]             sys.calls <- base::sys.calls
[09:31:11.718]             `[[` <- base::`[[`
[09:31:11.718]             `+` <- base::`+`
[09:31:11.718]             `<<-` <- base::`<<-`
[09:31:11.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.718]                   3L)]
[09:31:11.718]             }
[09:31:11.718]             function(cond) {
[09:31:11.718]                 is_error <- inherits(cond, "error")
[09:31:11.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.718]                   NULL)
[09:31:11.718]                 if (is_error) {
[09:31:11.718]                   sessionInformation <- function() {
[09:31:11.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.718]                       search = base::search(), system = base::Sys.info())
[09:31:11.718]                   }
[09:31:11.718]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.718]                     cond$call), session = sessionInformation(), 
[09:31:11.718]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.718]                   signalCondition(cond)
[09:31:11.718]                 }
[09:31:11.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.718]                 "immediateCondition"))) {
[09:31:11.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.718]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.718]                   if (TRUE && !signal) {
[09:31:11.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.718]                     {
[09:31:11.718]                       inherits <- base::inherits
[09:31:11.718]                       invokeRestart <- base::invokeRestart
[09:31:11.718]                       is.null <- base::is.null
[09:31:11.718]                       muffled <- FALSE
[09:31:11.718]                       if (inherits(cond, "message")) {
[09:31:11.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.718]                         if (muffled) 
[09:31:11.718]                           invokeRestart("muffleMessage")
[09:31:11.718]                       }
[09:31:11.718]                       else if (inherits(cond, "warning")) {
[09:31:11.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.718]                         if (muffled) 
[09:31:11.718]                           invokeRestart("muffleWarning")
[09:31:11.718]                       }
[09:31:11.718]                       else if (inherits(cond, "condition")) {
[09:31:11.718]                         if (!is.null(pattern)) {
[09:31:11.718]                           computeRestarts <- base::computeRestarts
[09:31:11.718]                           grepl <- base::grepl
[09:31:11.718]                           restarts <- computeRestarts(cond)
[09:31:11.718]                           for (restart in restarts) {
[09:31:11.718]                             name <- restart$name
[09:31:11.718]                             if (is.null(name)) 
[09:31:11.718]                               next
[09:31:11.718]                             if (!grepl(pattern, name)) 
[09:31:11.718]                               next
[09:31:11.718]                             invokeRestart(restart)
[09:31:11.718]                             muffled <- TRUE
[09:31:11.718]                             break
[09:31:11.718]                           }
[09:31:11.718]                         }
[09:31:11.718]                       }
[09:31:11.718]                       invisible(muffled)
[09:31:11.718]                     }
[09:31:11.718]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.718]                   }
[09:31:11.718]                 }
[09:31:11.718]                 else {
[09:31:11.718]                   if (TRUE) {
[09:31:11.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.718]                     {
[09:31:11.718]                       inherits <- base::inherits
[09:31:11.718]                       invokeRestart <- base::invokeRestart
[09:31:11.718]                       is.null <- base::is.null
[09:31:11.718]                       muffled <- FALSE
[09:31:11.718]                       if (inherits(cond, "message")) {
[09:31:11.718]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.718]                         if (muffled) 
[09:31:11.718]                           invokeRestart("muffleMessage")
[09:31:11.718]                       }
[09:31:11.718]                       else if (inherits(cond, "warning")) {
[09:31:11.718]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.718]                         if (muffled) 
[09:31:11.718]                           invokeRestart("muffleWarning")
[09:31:11.718]                       }
[09:31:11.718]                       else if (inherits(cond, "condition")) {
[09:31:11.718]                         if (!is.null(pattern)) {
[09:31:11.718]                           computeRestarts <- base::computeRestarts
[09:31:11.718]                           grepl <- base::grepl
[09:31:11.718]                           restarts <- computeRestarts(cond)
[09:31:11.718]                           for (restart in restarts) {
[09:31:11.718]                             name <- restart$name
[09:31:11.718]                             if (is.null(name)) 
[09:31:11.718]                               next
[09:31:11.718]                             if (!grepl(pattern, name)) 
[09:31:11.718]                               next
[09:31:11.718]                             invokeRestart(restart)
[09:31:11.718]                             muffled <- TRUE
[09:31:11.718]                             break
[09:31:11.718]                           }
[09:31:11.718]                         }
[09:31:11.718]                       }
[09:31:11.718]                       invisible(muffled)
[09:31:11.718]                     }
[09:31:11.718]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.718]                   }
[09:31:11.718]                 }
[09:31:11.718]             }
[09:31:11.718]         }))
[09:31:11.718]     }, error = function(ex) {
[09:31:11.718]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.718]                 ...future.rng), started = ...future.startTime, 
[09:31:11.718]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.718]             version = "1.8"), class = "FutureResult")
[09:31:11.718]     }, finally = {
[09:31:11.718]         if (!identical(...future.workdir, getwd())) 
[09:31:11.718]             setwd(...future.workdir)
[09:31:11.718]         {
[09:31:11.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.718]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.718]             }
[09:31:11.718]             base::options(...future.oldOptions)
[09:31:11.718]             if (.Platform$OS.type == "windows") {
[09:31:11.718]                 old_names <- names(...future.oldEnvVars)
[09:31:11.718]                 envs <- base::Sys.getenv()
[09:31:11.718]                 names <- names(envs)
[09:31:11.718]                 common <- intersect(names, old_names)
[09:31:11.718]                 added <- setdiff(names, old_names)
[09:31:11.718]                 removed <- setdiff(old_names, names)
[09:31:11.718]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.718]                   envs[common]]
[09:31:11.718]                 NAMES <- toupper(changed)
[09:31:11.718]                 args <- list()
[09:31:11.718]                 for (kk in seq_along(NAMES)) {
[09:31:11.718]                   name <- changed[[kk]]
[09:31:11.718]                   NAME <- NAMES[[kk]]
[09:31:11.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.718]                     next
[09:31:11.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.718]                 }
[09:31:11.718]                 NAMES <- toupper(added)
[09:31:11.718]                 for (kk in seq_along(NAMES)) {
[09:31:11.718]                   name <- added[[kk]]
[09:31:11.718]                   NAME <- NAMES[[kk]]
[09:31:11.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.718]                     next
[09:31:11.718]                   args[[name]] <- ""
[09:31:11.718]                 }
[09:31:11.718]                 NAMES <- toupper(removed)
[09:31:11.718]                 for (kk in seq_along(NAMES)) {
[09:31:11.718]                   name <- removed[[kk]]
[09:31:11.718]                   NAME <- NAMES[[kk]]
[09:31:11.718]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.718]                     next
[09:31:11.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.718]                 }
[09:31:11.718]                 if (length(args) > 0) 
[09:31:11.718]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.718]             }
[09:31:11.718]             else {
[09:31:11.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.718]             }
[09:31:11.718]             {
[09:31:11.718]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.718]                   0L) {
[09:31:11.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.718]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.718]                   base::options(opts)
[09:31:11.718]                 }
[09:31:11.718]                 {
[09:31:11.718]                   {
[09:31:11.718]                     NULL
[09:31:11.718]                     RNGkind("Mersenne-Twister")
[09:31:11.718]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.718]                       inherits = FALSE)
[09:31:11.718]                   }
[09:31:11.718]                   options(future.plan = NULL)
[09:31:11.718]                   if (is.na(NA_character_)) 
[09:31:11.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.718]                     .init = FALSE)
[09:31:11.718]                 }
[09:31:11.718]             }
[09:31:11.718]         }
[09:31:11.718]     })
[09:31:11.718]     if (TRUE) {
[09:31:11.718]         base::sink(type = "output", split = FALSE)
[09:31:11.718]         if (TRUE) {
[09:31:11.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.718]         }
[09:31:11.718]         else {
[09:31:11.718]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.718]         }
[09:31:11.718]         base::close(...future.stdout)
[09:31:11.718]         ...future.stdout <- NULL
[09:31:11.718]     }
[09:31:11.718]     ...future.result$conditions <- ...future.conditions
[09:31:11.718]     ...future.result$finished <- base::Sys.time()
[09:31:11.718]     ...future.result
[09:31:11.718] }
[09:31:11.719] plan(): Setting new future strategy stack:
[09:31:11.719] List of future strategies:
[09:31:11.719] 1. sequential:
[09:31:11.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.719]    - tweaked: FALSE
[09:31:11.719]    - call: NULL
[09:31:11.720] plan(): nbrOfWorkers() = 1
[09:31:11.720] plan(): Setting new future strategy stack:
[09:31:11.720] List of future strategies:
[09:31:11.720] 1. sequential:
[09:31:11.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.720]    - tweaked: FALSE
[09:31:11.720]    - call: plan(strategy)
[09:31:11.721] plan(): nbrOfWorkers() = 1
[09:31:11.721] SequentialFuture started (and completed)
[09:31:11.721] - Launch lazy future ... done
[09:31:11.721] run() for ‘SequentialFuture’ ... done
<environment: 0x55a3cadcb538> 
<environment: 0x55a3caaa0df0> 
[09:31:11.723] resolved() for ‘SequentialFuture’ ...
[09:31:11.723] - state: ‘finished’
[09:31:11.723] - run: TRUE
[09:31:11.723] - result: ‘FutureResult’
[09:31:11.723] resolved() for ‘SequentialFuture’ ... done
[09:31:11.723] resolved() for ‘SequentialFuture’ ...
[09:31:11.723] - state: ‘finished’
[09:31:11.723] - run: TRUE
[09:31:11.723] - result: ‘FutureResult’
[09:31:11.723] resolved() for ‘SequentialFuture’ ... done
[09:31:11.723] resolved() for ‘SequentialFuture’ ...
[09:31:11.724] - state: ‘finished’
[09:31:11.724] - run: TRUE
[09:31:11.724] - result: ‘FutureResult’
[09:31:11.724] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:11.725] resolve() on environment ...
[09:31:11.725]  recursive: 0
[09:31:11.726]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:11.726] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.726] - nx: 4
[09:31:11.726] - relay: TRUE
[09:31:11.726] - stdout: TRUE
[09:31:11.726] - signal: TRUE
[09:31:11.726] - resignal: FALSE
[09:31:11.726] - force: TRUE
[09:31:11.726] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.726] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.726]  - until=2
[09:31:11.727]  - relaying element #2
[09:31:11.727] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.727] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.727] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.727]  length: 3 (resolved future 1)
[09:31:11.727] resolved() for ‘SequentialFuture’ ...
[09:31:11.727] - state: ‘finished’
[09:31:11.727] - run: TRUE
[09:31:11.727] - result: ‘FutureResult’
[09:31:11.727] resolved() for ‘SequentialFuture’ ... done
[09:31:11.727] Future #2
[09:31:11.728] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.728] - nx: 4
[09:31:11.728] - relay: TRUE
[09:31:11.728] - stdout: TRUE
[09:31:11.728] - signal: TRUE
[09:31:11.728] - resignal: FALSE
[09:31:11.728] - force: TRUE
[09:31:11.728] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.728] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.728]  - until=2
[09:31:11.728]  - relaying element #2
[09:31:11.729] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.729] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.729] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.729]  length: 2 (resolved future 2)
[09:31:11.729] resolved() for ‘SequentialFuture’ ...
[09:31:11.729] - state: ‘finished’
[09:31:11.729] - run: TRUE
[09:31:11.729] - result: ‘FutureResult’
[09:31:11.729] resolved() for ‘SequentialFuture’ ... done
[09:31:11.729] Future #3
[09:31:11.729] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.730] - nx: 4
[09:31:11.730] - relay: TRUE
[09:31:11.730] - stdout: TRUE
[09:31:11.730] - signal: TRUE
[09:31:11.730] - resignal: FALSE
[09:31:11.730] - force: TRUE
[09:31:11.730] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.730] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.730]  - until=3
[09:31:11.730]  - relaying element #3
[09:31:11.730] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.731] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.731] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.731]  length: 1 (resolved future 3)
[09:31:11.731] resolved() for ‘SequentialFuture’ ...
[09:31:11.731] - state: ‘finished’
[09:31:11.731] - run: TRUE
[09:31:11.731] - result: ‘FutureResult’
[09:31:11.731] resolved() for ‘SequentialFuture’ ... done
[09:31:11.731] Future #4
[09:31:11.731] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.731] - nx: 4
[09:31:11.731] - relay: TRUE
[09:31:11.732] - stdout: TRUE
[09:31:11.732] - signal: TRUE
[09:31:11.732] - resignal: FALSE
[09:31:11.732] - force: TRUE
[09:31:11.732] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.732] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.732]  - until=4
[09:31:11.732]  - relaying element #4
[09:31:11.732] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.732] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.733] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.733]  length: 0 (resolved future 4)
[09:31:11.733] Relaying remaining futures
[09:31:11.733] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.733] - nx: 4
[09:31:11.733] - relay: TRUE
[09:31:11.733] - stdout: TRUE
[09:31:11.733] - signal: TRUE
[09:31:11.733] - resignal: FALSE
[09:31:11.733] - force: TRUE
[09:31:11.735] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.735] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:11.735] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.735] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.735] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.735] resolve() on environment ... DONE
<environment: 0x55a3cacbb4a0> 
Dimensions: c(1, 6)
[09:31:11.736] getGlobalsAndPackages() ...
[09:31:11.736] Searching for globals...
[09:31:11.736] 
[09:31:11.736] Searching for globals ... DONE
[09:31:11.736] - globals: [0] <none>
[09:31:11.736] getGlobalsAndPackages() ... DONE
[09:31:11.736] run() for ‘Future’ ...
[09:31:11.737] - state: ‘created’
[09:31:11.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.737]   - Field: ‘label’
[09:31:11.737]   - Field: ‘local’
[09:31:11.737]   - Field: ‘owner’
[09:31:11.737]   - Field: ‘envir’
[09:31:11.737]   - Field: ‘packages’
[09:31:11.738]   - Field: ‘gc’
[09:31:11.738]   - Field: ‘conditions’
[09:31:11.738]   - Field: ‘expr’
[09:31:11.738]   - Field: ‘uuid’
[09:31:11.738]   - Field: ‘seed’
[09:31:11.738]   - Field: ‘version’
[09:31:11.738]   - Field: ‘result’
[09:31:11.738]   - Field: ‘asynchronous’
[09:31:11.738]   - Field: ‘calls’
[09:31:11.738]   - Field: ‘globals’
[09:31:11.738]   - Field: ‘stdout’
[09:31:11.739]   - Field: ‘earlySignal’
[09:31:11.739]   - Field: ‘lazy’
[09:31:11.739]   - Field: ‘state’
[09:31:11.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.739] - Launch lazy future ...
[09:31:11.739] Packages needed by the future expression (n = 0): <none>
[09:31:11.739] Packages needed by future strategies (n = 0): <none>
[09:31:11.739] {
[09:31:11.739]     {
[09:31:11.739]         {
[09:31:11.739]             ...future.startTime <- base::Sys.time()
[09:31:11.739]             {
[09:31:11.739]                 {
[09:31:11.739]                   {
[09:31:11.739]                     base::local({
[09:31:11.739]                       has_future <- base::requireNamespace("future", 
[09:31:11.739]                         quietly = TRUE)
[09:31:11.739]                       if (has_future) {
[09:31:11.739]                         ns <- base::getNamespace("future")
[09:31:11.739]                         version <- ns[[".package"]][["version"]]
[09:31:11.739]                         if (is.null(version)) 
[09:31:11.739]                           version <- utils::packageVersion("future")
[09:31:11.739]                       }
[09:31:11.739]                       else {
[09:31:11.739]                         version <- NULL
[09:31:11.739]                       }
[09:31:11.739]                       if (!has_future || version < "1.8.0") {
[09:31:11.739]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.739]                           "", base::R.version$version.string), 
[09:31:11.739]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.739]                             "release", "version")], collapse = " "), 
[09:31:11.739]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.739]                           info)
[09:31:11.739]                         info <- base::paste(info, collapse = "; ")
[09:31:11.739]                         if (!has_future) {
[09:31:11.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.739]                             info)
[09:31:11.739]                         }
[09:31:11.739]                         else {
[09:31:11.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.739]                             info, version)
[09:31:11.739]                         }
[09:31:11.739]                         base::stop(msg)
[09:31:11.739]                       }
[09:31:11.739]                     })
[09:31:11.739]                   }
[09:31:11.739]                   ...future.strategy.old <- future::plan("list")
[09:31:11.739]                   options(future.plan = NULL)
[09:31:11.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.739]                 }
[09:31:11.739]                 ...future.workdir <- getwd()
[09:31:11.739]             }
[09:31:11.739]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.739]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.739]         }
[09:31:11.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.739]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.739]             base::names(...future.oldOptions))
[09:31:11.739]     }
[09:31:11.739]     if (FALSE) {
[09:31:11.739]     }
[09:31:11.739]     else {
[09:31:11.739]         if (TRUE) {
[09:31:11.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.739]                 open = "w")
[09:31:11.739]         }
[09:31:11.739]         else {
[09:31:11.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.739]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.739]         }
[09:31:11.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.739]             base::sink(type = "output", split = FALSE)
[09:31:11.739]             base::close(...future.stdout)
[09:31:11.739]         }, add = TRUE)
[09:31:11.739]     }
[09:31:11.739]     ...future.frame <- base::sys.nframe()
[09:31:11.739]     ...future.conditions <- base::list()
[09:31:11.739]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.739]     if (FALSE) {
[09:31:11.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.739]     }
[09:31:11.739]     ...future.result <- base::tryCatch({
[09:31:11.739]         base::withCallingHandlers({
[09:31:11.739]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.739]             future::FutureResult(value = ...future.value$value, 
[09:31:11.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.739]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.739]                     ...future.globalenv.names))
[09:31:11.739]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.739]         }, condition = base::local({
[09:31:11.739]             c <- base::c
[09:31:11.739]             inherits <- base::inherits
[09:31:11.739]             invokeRestart <- base::invokeRestart
[09:31:11.739]             length <- base::length
[09:31:11.739]             list <- base::list
[09:31:11.739]             seq.int <- base::seq.int
[09:31:11.739]             signalCondition <- base::signalCondition
[09:31:11.739]             sys.calls <- base::sys.calls
[09:31:11.739]             `[[` <- base::`[[`
[09:31:11.739]             `+` <- base::`+`
[09:31:11.739]             `<<-` <- base::`<<-`
[09:31:11.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.739]                   3L)]
[09:31:11.739]             }
[09:31:11.739]             function(cond) {
[09:31:11.739]                 is_error <- inherits(cond, "error")
[09:31:11.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.739]                   NULL)
[09:31:11.739]                 if (is_error) {
[09:31:11.739]                   sessionInformation <- function() {
[09:31:11.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.739]                       search = base::search(), system = base::Sys.info())
[09:31:11.739]                   }
[09:31:11.739]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.739]                     cond$call), session = sessionInformation(), 
[09:31:11.739]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.739]                   signalCondition(cond)
[09:31:11.739]                 }
[09:31:11.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.739]                 "immediateCondition"))) {
[09:31:11.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.739]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.739]                   if (TRUE && !signal) {
[09:31:11.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.739]                     {
[09:31:11.739]                       inherits <- base::inherits
[09:31:11.739]                       invokeRestart <- base::invokeRestart
[09:31:11.739]                       is.null <- base::is.null
[09:31:11.739]                       muffled <- FALSE
[09:31:11.739]                       if (inherits(cond, "message")) {
[09:31:11.739]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.739]                         if (muffled) 
[09:31:11.739]                           invokeRestart("muffleMessage")
[09:31:11.739]                       }
[09:31:11.739]                       else if (inherits(cond, "warning")) {
[09:31:11.739]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.739]                         if (muffled) 
[09:31:11.739]                           invokeRestart("muffleWarning")
[09:31:11.739]                       }
[09:31:11.739]                       else if (inherits(cond, "condition")) {
[09:31:11.739]                         if (!is.null(pattern)) {
[09:31:11.739]                           computeRestarts <- base::computeRestarts
[09:31:11.739]                           grepl <- base::grepl
[09:31:11.739]                           restarts <- computeRestarts(cond)
[09:31:11.739]                           for (restart in restarts) {
[09:31:11.739]                             name <- restart$name
[09:31:11.739]                             if (is.null(name)) 
[09:31:11.739]                               next
[09:31:11.739]                             if (!grepl(pattern, name)) 
[09:31:11.739]                               next
[09:31:11.739]                             invokeRestart(restart)
[09:31:11.739]                             muffled <- TRUE
[09:31:11.739]                             break
[09:31:11.739]                           }
[09:31:11.739]                         }
[09:31:11.739]                       }
[09:31:11.739]                       invisible(muffled)
[09:31:11.739]                     }
[09:31:11.739]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.739]                   }
[09:31:11.739]                 }
[09:31:11.739]                 else {
[09:31:11.739]                   if (TRUE) {
[09:31:11.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.739]                     {
[09:31:11.739]                       inherits <- base::inherits
[09:31:11.739]                       invokeRestart <- base::invokeRestart
[09:31:11.739]                       is.null <- base::is.null
[09:31:11.739]                       muffled <- FALSE
[09:31:11.739]                       if (inherits(cond, "message")) {
[09:31:11.739]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.739]                         if (muffled) 
[09:31:11.739]                           invokeRestart("muffleMessage")
[09:31:11.739]                       }
[09:31:11.739]                       else if (inherits(cond, "warning")) {
[09:31:11.739]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.739]                         if (muffled) 
[09:31:11.739]                           invokeRestart("muffleWarning")
[09:31:11.739]                       }
[09:31:11.739]                       else if (inherits(cond, "condition")) {
[09:31:11.739]                         if (!is.null(pattern)) {
[09:31:11.739]                           computeRestarts <- base::computeRestarts
[09:31:11.739]                           grepl <- base::grepl
[09:31:11.739]                           restarts <- computeRestarts(cond)
[09:31:11.739]                           for (restart in restarts) {
[09:31:11.739]                             name <- restart$name
[09:31:11.739]                             if (is.null(name)) 
[09:31:11.739]                               next
[09:31:11.739]                             if (!grepl(pattern, name)) 
[09:31:11.739]                               next
[09:31:11.739]                             invokeRestart(restart)
[09:31:11.739]                             muffled <- TRUE
[09:31:11.739]                             break
[09:31:11.739]                           }
[09:31:11.739]                         }
[09:31:11.739]                       }
[09:31:11.739]                       invisible(muffled)
[09:31:11.739]                     }
[09:31:11.739]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.739]                   }
[09:31:11.739]                 }
[09:31:11.739]             }
[09:31:11.739]         }))
[09:31:11.739]     }, error = function(ex) {
[09:31:11.739]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.739]                 ...future.rng), started = ...future.startTime, 
[09:31:11.739]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.739]             version = "1.8"), class = "FutureResult")
[09:31:11.739]     }, finally = {
[09:31:11.739]         if (!identical(...future.workdir, getwd())) 
[09:31:11.739]             setwd(...future.workdir)
[09:31:11.739]         {
[09:31:11.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.739]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.739]             }
[09:31:11.739]             base::options(...future.oldOptions)
[09:31:11.739]             if (.Platform$OS.type == "windows") {
[09:31:11.739]                 old_names <- names(...future.oldEnvVars)
[09:31:11.739]                 envs <- base::Sys.getenv()
[09:31:11.739]                 names <- names(envs)
[09:31:11.739]                 common <- intersect(names, old_names)
[09:31:11.739]                 added <- setdiff(names, old_names)
[09:31:11.739]                 removed <- setdiff(old_names, names)
[09:31:11.739]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.739]                   envs[common]]
[09:31:11.739]                 NAMES <- toupper(changed)
[09:31:11.739]                 args <- list()
[09:31:11.739]                 for (kk in seq_along(NAMES)) {
[09:31:11.739]                   name <- changed[[kk]]
[09:31:11.739]                   NAME <- NAMES[[kk]]
[09:31:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.739]                     next
[09:31:11.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.739]                 }
[09:31:11.739]                 NAMES <- toupper(added)
[09:31:11.739]                 for (kk in seq_along(NAMES)) {
[09:31:11.739]                   name <- added[[kk]]
[09:31:11.739]                   NAME <- NAMES[[kk]]
[09:31:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.739]                     next
[09:31:11.739]                   args[[name]] <- ""
[09:31:11.739]                 }
[09:31:11.739]                 NAMES <- toupper(removed)
[09:31:11.739]                 for (kk in seq_along(NAMES)) {
[09:31:11.739]                   name <- removed[[kk]]
[09:31:11.739]                   NAME <- NAMES[[kk]]
[09:31:11.739]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.739]                     next
[09:31:11.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.739]                 }
[09:31:11.739]                 if (length(args) > 0) 
[09:31:11.739]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.739]             }
[09:31:11.739]             else {
[09:31:11.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.739]             }
[09:31:11.739]             {
[09:31:11.739]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.739]                   0L) {
[09:31:11.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.739]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.739]                   base::options(opts)
[09:31:11.739]                 }
[09:31:11.739]                 {
[09:31:11.739]                   {
[09:31:11.739]                     NULL
[09:31:11.739]                     RNGkind("Mersenne-Twister")
[09:31:11.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.739]                       inherits = FALSE)
[09:31:11.739]                   }
[09:31:11.739]                   options(future.plan = NULL)
[09:31:11.739]                   if (is.na(NA_character_)) 
[09:31:11.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.739]                     .init = FALSE)
[09:31:11.739]                 }
[09:31:11.739]             }
[09:31:11.739]         }
[09:31:11.739]     })
[09:31:11.739]     if (TRUE) {
[09:31:11.739]         base::sink(type = "output", split = FALSE)
[09:31:11.739]         if (TRUE) {
[09:31:11.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.739]         }
[09:31:11.739]         else {
[09:31:11.739]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.739]         }
[09:31:11.739]         base::close(...future.stdout)
[09:31:11.739]         ...future.stdout <- NULL
[09:31:11.739]     }
[09:31:11.739]     ...future.result$conditions <- ...future.conditions
[09:31:11.739]     ...future.result$finished <- base::Sys.time()
[09:31:11.739]     ...future.result
[09:31:11.739] }
[09:31:11.741] plan(): Setting new future strategy stack:
[09:31:11.741] List of future strategies:
[09:31:11.741] 1. sequential:
[09:31:11.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.741]    - tweaked: FALSE
[09:31:11.741]    - call: NULL
[09:31:11.742] plan(): nbrOfWorkers() = 1
[09:31:11.742] plan(): Setting new future strategy stack:
[09:31:11.742] List of future strategies:
[09:31:11.742] 1. sequential:
[09:31:11.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.742]    - tweaked: FALSE
[09:31:11.742]    - call: plan(strategy)
[09:31:11.743] plan(): nbrOfWorkers() = 1
[09:31:11.743] SequentialFuture started (and completed)
[09:31:11.743] - Launch lazy future ... done
[09:31:11.743] run() for ‘SequentialFuture’ ... done
[09:31:11.743] getGlobalsAndPackages() ...
[09:31:11.743] Searching for globals...
[09:31:11.744] 
[09:31:11.744] Searching for globals ... DONE
[09:31:11.744] - globals: [0] <none>
[09:31:11.744] getGlobalsAndPackages() ... DONE
[09:31:11.744] run() for ‘Future’ ...
[09:31:11.744] - state: ‘created’
[09:31:11.744] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.745] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.745]   - Field: ‘label’
[09:31:11.745]   - Field: ‘local’
[09:31:11.745]   - Field: ‘owner’
[09:31:11.745]   - Field: ‘envir’
[09:31:11.745]   - Field: ‘packages’
[09:31:11.745]   - Field: ‘gc’
[09:31:11.745]   - Field: ‘conditions’
[09:31:11.745]   - Field: ‘expr’
[09:31:11.745]   - Field: ‘uuid’
[09:31:11.746]   - Field: ‘seed’
[09:31:11.746]   - Field: ‘version’
[09:31:11.746]   - Field: ‘result’
[09:31:11.746]   - Field: ‘asynchronous’
[09:31:11.746]   - Field: ‘calls’
[09:31:11.746]   - Field: ‘globals’
[09:31:11.746]   - Field: ‘stdout’
[09:31:11.746]   - Field: ‘earlySignal’
[09:31:11.746]   - Field: ‘lazy’
[09:31:11.746]   - Field: ‘state’
[09:31:11.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.746] - Launch lazy future ...
[09:31:11.747] Packages needed by the future expression (n = 0): <none>
[09:31:11.747] Packages needed by future strategies (n = 0): <none>
[09:31:11.747] {
[09:31:11.747]     {
[09:31:11.747]         {
[09:31:11.747]             ...future.startTime <- base::Sys.time()
[09:31:11.747]             {
[09:31:11.747]                 {
[09:31:11.747]                   {
[09:31:11.747]                     base::local({
[09:31:11.747]                       has_future <- base::requireNamespace("future", 
[09:31:11.747]                         quietly = TRUE)
[09:31:11.747]                       if (has_future) {
[09:31:11.747]                         ns <- base::getNamespace("future")
[09:31:11.747]                         version <- ns[[".package"]][["version"]]
[09:31:11.747]                         if (is.null(version)) 
[09:31:11.747]                           version <- utils::packageVersion("future")
[09:31:11.747]                       }
[09:31:11.747]                       else {
[09:31:11.747]                         version <- NULL
[09:31:11.747]                       }
[09:31:11.747]                       if (!has_future || version < "1.8.0") {
[09:31:11.747]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.747]                           "", base::R.version$version.string), 
[09:31:11.747]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.747]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.747]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.747]                             "release", "version")], collapse = " "), 
[09:31:11.747]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.747]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.747]                           info)
[09:31:11.747]                         info <- base::paste(info, collapse = "; ")
[09:31:11.747]                         if (!has_future) {
[09:31:11.747]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.747]                             info)
[09:31:11.747]                         }
[09:31:11.747]                         else {
[09:31:11.747]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.747]                             info, version)
[09:31:11.747]                         }
[09:31:11.747]                         base::stop(msg)
[09:31:11.747]                       }
[09:31:11.747]                     })
[09:31:11.747]                   }
[09:31:11.747]                   ...future.strategy.old <- future::plan("list")
[09:31:11.747]                   options(future.plan = NULL)
[09:31:11.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.747]                 }
[09:31:11.747]                 ...future.workdir <- getwd()
[09:31:11.747]             }
[09:31:11.747]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.747]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.747]         }
[09:31:11.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.747]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.747]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.747]             base::names(...future.oldOptions))
[09:31:11.747]     }
[09:31:11.747]     if (FALSE) {
[09:31:11.747]     }
[09:31:11.747]     else {
[09:31:11.747]         if (TRUE) {
[09:31:11.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.747]                 open = "w")
[09:31:11.747]         }
[09:31:11.747]         else {
[09:31:11.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.747]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.747]         }
[09:31:11.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.747]             base::sink(type = "output", split = FALSE)
[09:31:11.747]             base::close(...future.stdout)
[09:31:11.747]         }, add = TRUE)
[09:31:11.747]     }
[09:31:11.747]     ...future.frame <- base::sys.nframe()
[09:31:11.747]     ...future.conditions <- base::list()
[09:31:11.747]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.747]     if (FALSE) {
[09:31:11.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.747]     }
[09:31:11.747]     ...future.result <- base::tryCatch({
[09:31:11.747]         base::withCallingHandlers({
[09:31:11.747]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.747]             future::FutureResult(value = ...future.value$value, 
[09:31:11.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.747]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.747]                     ...future.globalenv.names))
[09:31:11.747]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.747]         }, condition = base::local({
[09:31:11.747]             c <- base::c
[09:31:11.747]             inherits <- base::inherits
[09:31:11.747]             invokeRestart <- base::invokeRestart
[09:31:11.747]             length <- base::length
[09:31:11.747]             list <- base::list
[09:31:11.747]             seq.int <- base::seq.int
[09:31:11.747]             signalCondition <- base::signalCondition
[09:31:11.747]             sys.calls <- base::sys.calls
[09:31:11.747]             `[[` <- base::`[[`
[09:31:11.747]             `+` <- base::`+`
[09:31:11.747]             `<<-` <- base::`<<-`
[09:31:11.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.747]                   3L)]
[09:31:11.747]             }
[09:31:11.747]             function(cond) {
[09:31:11.747]                 is_error <- inherits(cond, "error")
[09:31:11.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.747]                   NULL)
[09:31:11.747]                 if (is_error) {
[09:31:11.747]                   sessionInformation <- function() {
[09:31:11.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.747]                       search = base::search(), system = base::Sys.info())
[09:31:11.747]                   }
[09:31:11.747]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.747]                     cond$call), session = sessionInformation(), 
[09:31:11.747]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.747]                   signalCondition(cond)
[09:31:11.747]                 }
[09:31:11.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.747]                 "immediateCondition"))) {
[09:31:11.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.747]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.747]                   if (TRUE && !signal) {
[09:31:11.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.747]                     {
[09:31:11.747]                       inherits <- base::inherits
[09:31:11.747]                       invokeRestart <- base::invokeRestart
[09:31:11.747]                       is.null <- base::is.null
[09:31:11.747]                       muffled <- FALSE
[09:31:11.747]                       if (inherits(cond, "message")) {
[09:31:11.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.747]                         if (muffled) 
[09:31:11.747]                           invokeRestart("muffleMessage")
[09:31:11.747]                       }
[09:31:11.747]                       else if (inherits(cond, "warning")) {
[09:31:11.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.747]                         if (muffled) 
[09:31:11.747]                           invokeRestart("muffleWarning")
[09:31:11.747]                       }
[09:31:11.747]                       else if (inherits(cond, "condition")) {
[09:31:11.747]                         if (!is.null(pattern)) {
[09:31:11.747]                           computeRestarts <- base::computeRestarts
[09:31:11.747]                           grepl <- base::grepl
[09:31:11.747]                           restarts <- computeRestarts(cond)
[09:31:11.747]                           for (restart in restarts) {
[09:31:11.747]                             name <- restart$name
[09:31:11.747]                             if (is.null(name)) 
[09:31:11.747]                               next
[09:31:11.747]                             if (!grepl(pattern, name)) 
[09:31:11.747]                               next
[09:31:11.747]                             invokeRestart(restart)
[09:31:11.747]                             muffled <- TRUE
[09:31:11.747]                             break
[09:31:11.747]                           }
[09:31:11.747]                         }
[09:31:11.747]                       }
[09:31:11.747]                       invisible(muffled)
[09:31:11.747]                     }
[09:31:11.747]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.747]                   }
[09:31:11.747]                 }
[09:31:11.747]                 else {
[09:31:11.747]                   if (TRUE) {
[09:31:11.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.747]                     {
[09:31:11.747]                       inherits <- base::inherits
[09:31:11.747]                       invokeRestart <- base::invokeRestart
[09:31:11.747]                       is.null <- base::is.null
[09:31:11.747]                       muffled <- FALSE
[09:31:11.747]                       if (inherits(cond, "message")) {
[09:31:11.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.747]                         if (muffled) 
[09:31:11.747]                           invokeRestart("muffleMessage")
[09:31:11.747]                       }
[09:31:11.747]                       else if (inherits(cond, "warning")) {
[09:31:11.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.747]                         if (muffled) 
[09:31:11.747]                           invokeRestart("muffleWarning")
[09:31:11.747]                       }
[09:31:11.747]                       else if (inherits(cond, "condition")) {
[09:31:11.747]                         if (!is.null(pattern)) {
[09:31:11.747]                           computeRestarts <- base::computeRestarts
[09:31:11.747]                           grepl <- base::grepl
[09:31:11.747]                           restarts <- computeRestarts(cond)
[09:31:11.747]                           for (restart in restarts) {
[09:31:11.747]                             name <- restart$name
[09:31:11.747]                             if (is.null(name)) 
[09:31:11.747]                               next
[09:31:11.747]                             if (!grepl(pattern, name)) 
[09:31:11.747]                               next
[09:31:11.747]                             invokeRestart(restart)
[09:31:11.747]                             muffled <- TRUE
[09:31:11.747]                             break
[09:31:11.747]                           }
[09:31:11.747]                         }
[09:31:11.747]                       }
[09:31:11.747]                       invisible(muffled)
[09:31:11.747]                     }
[09:31:11.747]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.747]                   }
[09:31:11.747]                 }
[09:31:11.747]             }
[09:31:11.747]         }))
[09:31:11.747]     }, error = function(ex) {
[09:31:11.747]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.747]                 ...future.rng), started = ...future.startTime, 
[09:31:11.747]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.747]             version = "1.8"), class = "FutureResult")
[09:31:11.747]     }, finally = {
[09:31:11.747]         if (!identical(...future.workdir, getwd())) 
[09:31:11.747]             setwd(...future.workdir)
[09:31:11.747]         {
[09:31:11.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.747]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.747]             }
[09:31:11.747]             base::options(...future.oldOptions)
[09:31:11.747]             if (.Platform$OS.type == "windows") {
[09:31:11.747]                 old_names <- names(...future.oldEnvVars)
[09:31:11.747]                 envs <- base::Sys.getenv()
[09:31:11.747]                 names <- names(envs)
[09:31:11.747]                 common <- intersect(names, old_names)
[09:31:11.747]                 added <- setdiff(names, old_names)
[09:31:11.747]                 removed <- setdiff(old_names, names)
[09:31:11.747]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.747]                   envs[common]]
[09:31:11.747]                 NAMES <- toupper(changed)
[09:31:11.747]                 args <- list()
[09:31:11.747]                 for (kk in seq_along(NAMES)) {
[09:31:11.747]                   name <- changed[[kk]]
[09:31:11.747]                   NAME <- NAMES[[kk]]
[09:31:11.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.747]                     next
[09:31:11.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.747]                 }
[09:31:11.747]                 NAMES <- toupper(added)
[09:31:11.747]                 for (kk in seq_along(NAMES)) {
[09:31:11.747]                   name <- added[[kk]]
[09:31:11.747]                   NAME <- NAMES[[kk]]
[09:31:11.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.747]                     next
[09:31:11.747]                   args[[name]] <- ""
[09:31:11.747]                 }
[09:31:11.747]                 NAMES <- toupper(removed)
[09:31:11.747]                 for (kk in seq_along(NAMES)) {
[09:31:11.747]                   name <- removed[[kk]]
[09:31:11.747]                   NAME <- NAMES[[kk]]
[09:31:11.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.747]                     next
[09:31:11.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.747]                 }
[09:31:11.747]                 if (length(args) > 0) 
[09:31:11.747]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.747]             }
[09:31:11.747]             else {
[09:31:11.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.747]             }
[09:31:11.747]             {
[09:31:11.747]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.747]                   0L) {
[09:31:11.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.747]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.747]                   base::options(opts)
[09:31:11.747]                 }
[09:31:11.747]                 {
[09:31:11.747]                   {
[09:31:11.747]                     NULL
[09:31:11.747]                     RNGkind("Mersenne-Twister")
[09:31:11.747]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.747]                       inherits = FALSE)
[09:31:11.747]                   }
[09:31:11.747]                   options(future.plan = NULL)
[09:31:11.747]                   if (is.na(NA_character_)) 
[09:31:11.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.747]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.747]                     .init = FALSE)
[09:31:11.747]                 }
[09:31:11.747]             }
[09:31:11.747]         }
[09:31:11.747]     })
[09:31:11.747]     if (TRUE) {
[09:31:11.747]         base::sink(type = "output", split = FALSE)
[09:31:11.747]         if (TRUE) {
[09:31:11.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.747]         }
[09:31:11.747]         else {
[09:31:11.747]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.747]         }
[09:31:11.747]         base::close(...future.stdout)
[09:31:11.747]         ...future.stdout <- NULL
[09:31:11.747]     }
[09:31:11.747]     ...future.result$conditions <- ...future.conditions
[09:31:11.747]     ...future.result$finished <- base::Sys.time()
[09:31:11.747]     ...future.result
[09:31:11.747] }
[09:31:11.749] plan(): Setting new future strategy stack:
[09:31:11.749] List of future strategies:
[09:31:11.749] 1. sequential:
[09:31:11.749]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.749]    - tweaked: FALSE
[09:31:11.749]    - call: NULL
[09:31:11.749] plan(): nbrOfWorkers() = 1
[09:31:11.750] plan(): Setting new future strategy stack:
[09:31:11.750] List of future strategies:
[09:31:11.750] 1. sequential:
[09:31:11.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.750]    - tweaked: FALSE
[09:31:11.750]    - call: plan(strategy)
[09:31:11.750] plan(): nbrOfWorkers() = 1
[09:31:11.750] SequentialFuture started (and completed)
[09:31:11.751] - Launch lazy future ... done
[09:31:11.751] run() for ‘SequentialFuture’ ... done
[09:31:11.751] getGlobalsAndPackages() ...
[09:31:11.751] Searching for globals...
[09:31:11.752] - globals found: [1] ‘{’
[09:31:11.752] Searching for globals ... DONE
[09:31:11.752] Resolving globals: FALSE
[09:31:11.752] 
[09:31:11.752] 
[09:31:11.752] getGlobalsAndPackages() ... DONE
[09:31:11.752] run() for ‘Future’ ...
[09:31:11.752] - state: ‘created’
[09:31:11.753] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.753] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.753] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.753]   - Field: ‘label’
[09:31:11.753]   - Field: ‘local’
[09:31:11.753]   - Field: ‘owner’
[09:31:11.753]   - Field: ‘envir’
[09:31:11.753]   - Field: ‘packages’
[09:31:11.753]   - Field: ‘gc’
[09:31:11.754]   - Field: ‘conditions’
[09:31:11.754]   - Field: ‘expr’
[09:31:11.754]   - Field: ‘uuid’
[09:31:11.754]   - Field: ‘seed’
[09:31:11.754]   - Field: ‘version’
[09:31:11.754]   - Field: ‘result’
[09:31:11.754]   - Field: ‘asynchronous’
[09:31:11.754]   - Field: ‘calls’
[09:31:11.754]   - Field: ‘globals’
[09:31:11.754]   - Field: ‘stdout’
[09:31:11.754]   - Field: ‘earlySignal’
[09:31:11.754]   - Field: ‘lazy’
[09:31:11.755]   - Field: ‘state’
[09:31:11.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.755] - Launch lazy future ...
[09:31:11.755] Packages needed by the future expression (n = 0): <none>
[09:31:11.755] Packages needed by future strategies (n = 0): <none>
[09:31:11.755] {
[09:31:11.755]     {
[09:31:11.755]         {
[09:31:11.755]             ...future.startTime <- base::Sys.time()
[09:31:11.755]             {
[09:31:11.755]                 {
[09:31:11.755]                   {
[09:31:11.755]                     base::local({
[09:31:11.755]                       has_future <- base::requireNamespace("future", 
[09:31:11.755]                         quietly = TRUE)
[09:31:11.755]                       if (has_future) {
[09:31:11.755]                         ns <- base::getNamespace("future")
[09:31:11.755]                         version <- ns[[".package"]][["version"]]
[09:31:11.755]                         if (is.null(version)) 
[09:31:11.755]                           version <- utils::packageVersion("future")
[09:31:11.755]                       }
[09:31:11.755]                       else {
[09:31:11.755]                         version <- NULL
[09:31:11.755]                       }
[09:31:11.755]                       if (!has_future || version < "1.8.0") {
[09:31:11.755]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.755]                           "", base::R.version$version.string), 
[09:31:11.755]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.755]                             "release", "version")], collapse = " "), 
[09:31:11.755]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.755]                           info)
[09:31:11.755]                         info <- base::paste(info, collapse = "; ")
[09:31:11.755]                         if (!has_future) {
[09:31:11.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.755]                             info)
[09:31:11.755]                         }
[09:31:11.755]                         else {
[09:31:11.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.755]                             info, version)
[09:31:11.755]                         }
[09:31:11.755]                         base::stop(msg)
[09:31:11.755]                       }
[09:31:11.755]                     })
[09:31:11.755]                   }
[09:31:11.755]                   ...future.strategy.old <- future::plan("list")
[09:31:11.755]                   options(future.plan = NULL)
[09:31:11.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.755]                 }
[09:31:11.755]                 ...future.workdir <- getwd()
[09:31:11.755]             }
[09:31:11.755]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.755]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.755]         }
[09:31:11.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.755]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.755]             base::names(...future.oldOptions))
[09:31:11.755]     }
[09:31:11.755]     if (FALSE) {
[09:31:11.755]     }
[09:31:11.755]     else {
[09:31:11.755]         if (TRUE) {
[09:31:11.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.755]                 open = "w")
[09:31:11.755]         }
[09:31:11.755]         else {
[09:31:11.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.755]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.755]         }
[09:31:11.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.755]             base::sink(type = "output", split = FALSE)
[09:31:11.755]             base::close(...future.stdout)
[09:31:11.755]         }, add = TRUE)
[09:31:11.755]     }
[09:31:11.755]     ...future.frame <- base::sys.nframe()
[09:31:11.755]     ...future.conditions <- base::list()
[09:31:11.755]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.755]     if (FALSE) {
[09:31:11.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.755]     }
[09:31:11.755]     ...future.result <- base::tryCatch({
[09:31:11.755]         base::withCallingHandlers({
[09:31:11.755]             ...future.value <- base::withVisible(base::local({
[09:31:11.755]                 4
[09:31:11.755]             }))
[09:31:11.755]             future::FutureResult(value = ...future.value$value, 
[09:31:11.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.755]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.755]                     ...future.globalenv.names))
[09:31:11.755]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.755]         }, condition = base::local({
[09:31:11.755]             c <- base::c
[09:31:11.755]             inherits <- base::inherits
[09:31:11.755]             invokeRestart <- base::invokeRestart
[09:31:11.755]             length <- base::length
[09:31:11.755]             list <- base::list
[09:31:11.755]             seq.int <- base::seq.int
[09:31:11.755]             signalCondition <- base::signalCondition
[09:31:11.755]             sys.calls <- base::sys.calls
[09:31:11.755]             `[[` <- base::`[[`
[09:31:11.755]             `+` <- base::`+`
[09:31:11.755]             `<<-` <- base::`<<-`
[09:31:11.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.755]                   3L)]
[09:31:11.755]             }
[09:31:11.755]             function(cond) {
[09:31:11.755]                 is_error <- inherits(cond, "error")
[09:31:11.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.755]                   NULL)
[09:31:11.755]                 if (is_error) {
[09:31:11.755]                   sessionInformation <- function() {
[09:31:11.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.755]                       search = base::search(), system = base::Sys.info())
[09:31:11.755]                   }
[09:31:11.755]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.755]                     cond$call), session = sessionInformation(), 
[09:31:11.755]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.755]                   signalCondition(cond)
[09:31:11.755]                 }
[09:31:11.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.755]                 "immediateCondition"))) {
[09:31:11.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.755]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.755]                   if (TRUE && !signal) {
[09:31:11.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.755]                     {
[09:31:11.755]                       inherits <- base::inherits
[09:31:11.755]                       invokeRestart <- base::invokeRestart
[09:31:11.755]                       is.null <- base::is.null
[09:31:11.755]                       muffled <- FALSE
[09:31:11.755]                       if (inherits(cond, "message")) {
[09:31:11.755]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.755]                         if (muffled) 
[09:31:11.755]                           invokeRestart("muffleMessage")
[09:31:11.755]                       }
[09:31:11.755]                       else if (inherits(cond, "warning")) {
[09:31:11.755]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.755]                         if (muffled) 
[09:31:11.755]                           invokeRestart("muffleWarning")
[09:31:11.755]                       }
[09:31:11.755]                       else if (inherits(cond, "condition")) {
[09:31:11.755]                         if (!is.null(pattern)) {
[09:31:11.755]                           computeRestarts <- base::computeRestarts
[09:31:11.755]                           grepl <- base::grepl
[09:31:11.755]                           restarts <- computeRestarts(cond)
[09:31:11.755]                           for (restart in restarts) {
[09:31:11.755]                             name <- restart$name
[09:31:11.755]                             if (is.null(name)) 
[09:31:11.755]                               next
[09:31:11.755]                             if (!grepl(pattern, name)) 
[09:31:11.755]                               next
[09:31:11.755]                             invokeRestart(restart)
[09:31:11.755]                             muffled <- TRUE
[09:31:11.755]                             break
[09:31:11.755]                           }
[09:31:11.755]                         }
[09:31:11.755]                       }
[09:31:11.755]                       invisible(muffled)
[09:31:11.755]                     }
[09:31:11.755]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.755]                   }
[09:31:11.755]                 }
[09:31:11.755]                 else {
[09:31:11.755]                   if (TRUE) {
[09:31:11.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.755]                     {
[09:31:11.755]                       inherits <- base::inherits
[09:31:11.755]                       invokeRestart <- base::invokeRestart
[09:31:11.755]                       is.null <- base::is.null
[09:31:11.755]                       muffled <- FALSE
[09:31:11.755]                       if (inherits(cond, "message")) {
[09:31:11.755]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.755]                         if (muffled) 
[09:31:11.755]                           invokeRestart("muffleMessage")
[09:31:11.755]                       }
[09:31:11.755]                       else if (inherits(cond, "warning")) {
[09:31:11.755]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.755]                         if (muffled) 
[09:31:11.755]                           invokeRestart("muffleWarning")
[09:31:11.755]                       }
[09:31:11.755]                       else if (inherits(cond, "condition")) {
[09:31:11.755]                         if (!is.null(pattern)) {
[09:31:11.755]                           computeRestarts <- base::computeRestarts
[09:31:11.755]                           grepl <- base::grepl
[09:31:11.755]                           restarts <- computeRestarts(cond)
[09:31:11.755]                           for (restart in restarts) {
[09:31:11.755]                             name <- restart$name
[09:31:11.755]                             if (is.null(name)) 
[09:31:11.755]                               next
[09:31:11.755]                             if (!grepl(pattern, name)) 
[09:31:11.755]                               next
[09:31:11.755]                             invokeRestart(restart)
[09:31:11.755]                             muffled <- TRUE
[09:31:11.755]                             break
[09:31:11.755]                           }
[09:31:11.755]                         }
[09:31:11.755]                       }
[09:31:11.755]                       invisible(muffled)
[09:31:11.755]                     }
[09:31:11.755]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.755]                   }
[09:31:11.755]                 }
[09:31:11.755]             }
[09:31:11.755]         }))
[09:31:11.755]     }, error = function(ex) {
[09:31:11.755]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.755]                 ...future.rng), started = ...future.startTime, 
[09:31:11.755]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.755]             version = "1.8"), class = "FutureResult")
[09:31:11.755]     }, finally = {
[09:31:11.755]         if (!identical(...future.workdir, getwd())) 
[09:31:11.755]             setwd(...future.workdir)
[09:31:11.755]         {
[09:31:11.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.755]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.755]             }
[09:31:11.755]             base::options(...future.oldOptions)
[09:31:11.755]             if (.Platform$OS.type == "windows") {
[09:31:11.755]                 old_names <- names(...future.oldEnvVars)
[09:31:11.755]                 envs <- base::Sys.getenv()
[09:31:11.755]                 names <- names(envs)
[09:31:11.755]                 common <- intersect(names, old_names)
[09:31:11.755]                 added <- setdiff(names, old_names)
[09:31:11.755]                 removed <- setdiff(old_names, names)
[09:31:11.755]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.755]                   envs[common]]
[09:31:11.755]                 NAMES <- toupper(changed)
[09:31:11.755]                 args <- list()
[09:31:11.755]                 for (kk in seq_along(NAMES)) {
[09:31:11.755]                   name <- changed[[kk]]
[09:31:11.755]                   NAME <- NAMES[[kk]]
[09:31:11.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.755]                     next
[09:31:11.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.755]                 }
[09:31:11.755]                 NAMES <- toupper(added)
[09:31:11.755]                 for (kk in seq_along(NAMES)) {
[09:31:11.755]                   name <- added[[kk]]
[09:31:11.755]                   NAME <- NAMES[[kk]]
[09:31:11.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.755]                     next
[09:31:11.755]                   args[[name]] <- ""
[09:31:11.755]                 }
[09:31:11.755]                 NAMES <- toupper(removed)
[09:31:11.755]                 for (kk in seq_along(NAMES)) {
[09:31:11.755]                   name <- removed[[kk]]
[09:31:11.755]                   NAME <- NAMES[[kk]]
[09:31:11.755]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.755]                     next
[09:31:11.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.755]                 }
[09:31:11.755]                 if (length(args) > 0) 
[09:31:11.755]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.755]             }
[09:31:11.755]             else {
[09:31:11.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.755]             }
[09:31:11.755]             {
[09:31:11.755]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.755]                   0L) {
[09:31:11.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.755]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.755]                   base::options(opts)
[09:31:11.755]                 }
[09:31:11.755]                 {
[09:31:11.755]                   {
[09:31:11.755]                     NULL
[09:31:11.755]                     RNGkind("Mersenne-Twister")
[09:31:11.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.755]                       inherits = FALSE)
[09:31:11.755]                   }
[09:31:11.755]                   options(future.plan = NULL)
[09:31:11.755]                   if (is.na(NA_character_)) 
[09:31:11.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.755]                     .init = FALSE)
[09:31:11.755]                 }
[09:31:11.755]             }
[09:31:11.755]         }
[09:31:11.755]     })
[09:31:11.755]     if (TRUE) {
[09:31:11.755]         base::sink(type = "output", split = FALSE)
[09:31:11.755]         if (TRUE) {
[09:31:11.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.755]         }
[09:31:11.755]         else {
[09:31:11.755]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.755]         }
[09:31:11.755]         base::close(...future.stdout)
[09:31:11.755]         ...future.stdout <- NULL
[09:31:11.755]     }
[09:31:11.755]     ...future.result$conditions <- ...future.conditions
[09:31:11.755]     ...future.result$finished <- base::Sys.time()
[09:31:11.755]     ...future.result
[09:31:11.755] }
[09:31:11.757] plan(): Setting new future strategy stack:
[09:31:11.757] List of future strategies:
[09:31:11.757] 1. sequential:
[09:31:11.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.757]    - tweaked: FALSE
[09:31:11.757]    - call: NULL
[09:31:11.757] plan(): nbrOfWorkers() = 1
[09:31:11.758] plan(): Setting new future strategy stack:
[09:31:11.758] List of future strategies:
[09:31:11.758] 1. sequential:
[09:31:11.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.758]    - tweaked: FALSE
[09:31:11.758]    - call: plan(strategy)
[09:31:11.759] plan(): nbrOfWorkers() = 1
[09:31:11.759] SequentialFuture started (and completed)
[09:31:11.759] - Launch lazy future ... done
[09:31:11.759] run() for ‘SequentialFuture’ ... done
<environment: 0x55a3c953bc70> 
<environment: 0x55a3cb069b68> 
[09:31:11.760] resolved() for ‘SequentialFuture’ ...
[09:31:11.760] - state: ‘finished’
[09:31:11.760] - run: TRUE
[09:31:11.760] - result: ‘FutureResult’
[09:31:11.760] resolved() for ‘SequentialFuture’ ... done
[09:31:11.761] resolved() for ‘SequentialFuture’ ...
[09:31:11.761] - state: ‘finished’
[09:31:11.761] - run: TRUE
[09:31:11.761] - result: ‘FutureResult’
[09:31:11.761] resolved() for ‘SequentialFuture’ ... done
[09:31:11.761] resolved() for ‘SequentialFuture’ ...
[09:31:11.761] - state: ‘finished’
[09:31:11.761] - run: TRUE
[09:31:11.761] - result: ‘FutureResult’
[09:31:11.761] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:11.763] resolve() on environment ...
[09:31:11.763]  recursive: 0
[09:31:11.764]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:11.764] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.764] - nx: 4
[09:31:11.764] - relay: TRUE
[09:31:11.764] - stdout: TRUE
[09:31:11.764] - signal: TRUE
[09:31:11.765] - resignal: FALSE
[09:31:11.765] - force: TRUE
[09:31:11.765] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.765] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.765]  - until=2
[09:31:11.765]  - relaying element #2
[09:31:11.765] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.765] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.765] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.765]  length: 3 (resolved future 1)
[09:31:11.765] resolved() for ‘SequentialFuture’ ...
[09:31:11.765] - state: ‘finished’
[09:31:11.766] - run: TRUE
[09:31:11.766] - result: ‘FutureResult’
[09:31:11.766] resolved() for ‘SequentialFuture’ ... done
[09:31:11.766] Future #2
[09:31:11.766] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.766] - nx: 4
[09:31:11.766] - relay: TRUE
[09:31:11.766] - stdout: TRUE
[09:31:11.766] - signal: TRUE
[09:31:11.766] - resignal: FALSE
[09:31:11.766] - force: TRUE
[09:31:11.766] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.767] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.767]  - until=2
[09:31:11.767]  - relaying element #2
[09:31:11.767] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.767] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.767] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.767]  length: 2 (resolved future 2)
[09:31:11.767] resolved() for ‘SequentialFuture’ ...
[09:31:11.767] - state: ‘finished’
[09:31:11.767] - run: TRUE
[09:31:11.768] - result: ‘FutureResult’
[09:31:11.768] resolved() for ‘SequentialFuture’ ... done
[09:31:11.768] Future #3
[09:31:11.768] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.768] - nx: 4
[09:31:11.768] - relay: TRUE
[09:31:11.768] - stdout: TRUE
[09:31:11.768] - signal: TRUE
[09:31:11.768] - resignal: FALSE
[09:31:11.768] - force: TRUE
[09:31:11.768] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.769] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.769]  - until=3
[09:31:11.769]  - relaying element #3
[09:31:11.769] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.769] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.769] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.769]  length: 1 (resolved future 3)
[09:31:11.769] resolved() for ‘SequentialFuture’ ...
[09:31:11.769] - state: ‘finished’
[09:31:11.769] - run: TRUE
[09:31:11.770] - result: ‘FutureResult’
[09:31:11.770] resolved() for ‘SequentialFuture’ ... done
[09:31:11.770] Future #4
[09:31:11.770] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.770] - nx: 4
[09:31:11.770] - relay: TRUE
[09:31:11.770] - stdout: TRUE
[09:31:11.770] - signal: TRUE
[09:31:11.770] - resignal: FALSE
[09:31:11.770] - force: TRUE
[09:31:11.770] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.770] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.770]  - until=4
[09:31:11.771]  - relaying element #4
[09:31:11.771] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.771] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.771] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.771]  length: 0 (resolved future 4)
[09:31:11.771] Relaying remaining futures
[09:31:11.771] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.771] - nx: 4
[09:31:11.771] - relay: TRUE
[09:31:11.771] - stdout: TRUE
[09:31:11.771] - signal: TRUE
[09:31:11.772] - resignal: FALSE
[09:31:11.772] - force: TRUE
[09:31:11.772] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.772] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:11.772] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.772] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.772] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.772] resolve() on environment ... DONE
<environment: 0x55a3ca12f528> 
Dimensions: c(2, 3)
[09:31:11.773] getGlobalsAndPackages() ...
[09:31:11.773] Searching for globals...
[09:31:11.773] 
[09:31:11.773] Searching for globals ... DONE
[09:31:11.773] - globals: [0] <none>
[09:31:11.773] getGlobalsAndPackages() ... DONE
[09:31:11.773] run() for ‘Future’ ...
[09:31:11.774] - state: ‘created’
[09:31:11.774] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.774] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.774] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.774]   - Field: ‘label’
[09:31:11.774]   - Field: ‘local’
[09:31:11.774]   - Field: ‘owner’
[09:31:11.774]   - Field: ‘envir’
[09:31:11.774]   - Field: ‘packages’
[09:31:11.775]   - Field: ‘gc’
[09:31:11.775]   - Field: ‘conditions’
[09:31:11.775]   - Field: ‘expr’
[09:31:11.775]   - Field: ‘uuid’
[09:31:11.775]   - Field: ‘seed’
[09:31:11.775]   - Field: ‘version’
[09:31:11.775]   - Field: ‘result’
[09:31:11.775]   - Field: ‘asynchronous’
[09:31:11.775]   - Field: ‘calls’
[09:31:11.775]   - Field: ‘globals’
[09:31:11.775]   - Field: ‘stdout’
[09:31:11.775]   - Field: ‘earlySignal’
[09:31:11.775]   - Field: ‘lazy’
[09:31:11.776]   - Field: ‘state’
[09:31:11.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.776] - Launch lazy future ...
[09:31:11.776] Packages needed by the future expression (n = 0): <none>
[09:31:11.776] Packages needed by future strategies (n = 0): <none>
[09:31:11.776] {
[09:31:11.776]     {
[09:31:11.776]         {
[09:31:11.776]             ...future.startTime <- base::Sys.time()
[09:31:11.776]             {
[09:31:11.776]                 {
[09:31:11.776]                   {
[09:31:11.776]                     base::local({
[09:31:11.776]                       has_future <- base::requireNamespace("future", 
[09:31:11.776]                         quietly = TRUE)
[09:31:11.776]                       if (has_future) {
[09:31:11.776]                         ns <- base::getNamespace("future")
[09:31:11.776]                         version <- ns[[".package"]][["version"]]
[09:31:11.776]                         if (is.null(version)) 
[09:31:11.776]                           version <- utils::packageVersion("future")
[09:31:11.776]                       }
[09:31:11.776]                       else {
[09:31:11.776]                         version <- NULL
[09:31:11.776]                       }
[09:31:11.776]                       if (!has_future || version < "1.8.0") {
[09:31:11.776]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.776]                           "", base::R.version$version.string), 
[09:31:11.776]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.776]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.776]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.776]                             "release", "version")], collapse = " "), 
[09:31:11.776]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.776]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.776]                           info)
[09:31:11.776]                         info <- base::paste(info, collapse = "; ")
[09:31:11.776]                         if (!has_future) {
[09:31:11.776]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.776]                             info)
[09:31:11.776]                         }
[09:31:11.776]                         else {
[09:31:11.776]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.776]                             info, version)
[09:31:11.776]                         }
[09:31:11.776]                         base::stop(msg)
[09:31:11.776]                       }
[09:31:11.776]                     })
[09:31:11.776]                   }
[09:31:11.776]                   ...future.strategy.old <- future::plan("list")
[09:31:11.776]                   options(future.plan = NULL)
[09:31:11.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.776]                 }
[09:31:11.776]                 ...future.workdir <- getwd()
[09:31:11.776]             }
[09:31:11.776]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.776]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.776]         }
[09:31:11.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.776]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.776]             base::names(...future.oldOptions))
[09:31:11.776]     }
[09:31:11.776]     if (FALSE) {
[09:31:11.776]     }
[09:31:11.776]     else {
[09:31:11.776]         if (TRUE) {
[09:31:11.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.776]                 open = "w")
[09:31:11.776]         }
[09:31:11.776]         else {
[09:31:11.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.776]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.776]         }
[09:31:11.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.776]             base::sink(type = "output", split = FALSE)
[09:31:11.776]             base::close(...future.stdout)
[09:31:11.776]         }, add = TRUE)
[09:31:11.776]     }
[09:31:11.776]     ...future.frame <- base::sys.nframe()
[09:31:11.776]     ...future.conditions <- base::list()
[09:31:11.776]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.776]     if (FALSE) {
[09:31:11.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.776]     }
[09:31:11.776]     ...future.result <- base::tryCatch({
[09:31:11.776]         base::withCallingHandlers({
[09:31:11.776]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.776]             future::FutureResult(value = ...future.value$value, 
[09:31:11.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.776]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.776]                     ...future.globalenv.names))
[09:31:11.776]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.776]         }, condition = base::local({
[09:31:11.776]             c <- base::c
[09:31:11.776]             inherits <- base::inherits
[09:31:11.776]             invokeRestart <- base::invokeRestart
[09:31:11.776]             length <- base::length
[09:31:11.776]             list <- base::list
[09:31:11.776]             seq.int <- base::seq.int
[09:31:11.776]             signalCondition <- base::signalCondition
[09:31:11.776]             sys.calls <- base::sys.calls
[09:31:11.776]             `[[` <- base::`[[`
[09:31:11.776]             `+` <- base::`+`
[09:31:11.776]             `<<-` <- base::`<<-`
[09:31:11.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.776]                   3L)]
[09:31:11.776]             }
[09:31:11.776]             function(cond) {
[09:31:11.776]                 is_error <- inherits(cond, "error")
[09:31:11.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.776]                   NULL)
[09:31:11.776]                 if (is_error) {
[09:31:11.776]                   sessionInformation <- function() {
[09:31:11.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.776]                       search = base::search(), system = base::Sys.info())
[09:31:11.776]                   }
[09:31:11.776]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.776]                     cond$call), session = sessionInformation(), 
[09:31:11.776]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.776]                   signalCondition(cond)
[09:31:11.776]                 }
[09:31:11.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.776]                 "immediateCondition"))) {
[09:31:11.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.776]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.776]                   if (TRUE && !signal) {
[09:31:11.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.776]                     {
[09:31:11.776]                       inherits <- base::inherits
[09:31:11.776]                       invokeRestart <- base::invokeRestart
[09:31:11.776]                       is.null <- base::is.null
[09:31:11.776]                       muffled <- FALSE
[09:31:11.776]                       if (inherits(cond, "message")) {
[09:31:11.776]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.776]                         if (muffled) 
[09:31:11.776]                           invokeRestart("muffleMessage")
[09:31:11.776]                       }
[09:31:11.776]                       else if (inherits(cond, "warning")) {
[09:31:11.776]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.776]                         if (muffled) 
[09:31:11.776]                           invokeRestart("muffleWarning")
[09:31:11.776]                       }
[09:31:11.776]                       else if (inherits(cond, "condition")) {
[09:31:11.776]                         if (!is.null(pattern)) {
[09:31:11.776]                           computeRestarts <- base::computeRestarts
[09:31:11.776]                           grepl <- base::grepl
[09:31:11.776]                           restarts <- computeRestarts(cond)
[09:31:11.776]                           for (restart in restarts) {
[09:31:11.776]                             name <- restart$name
[09:31:11.776]                             if (is.null(name)) 
[09:31:11.776]                               next
[09:31:11.776]                             if (!grepl(pattern, name)) 
[09:31:11.776]                               next
[09:31:11.776]                             invokeRestart(restart)
[09:31:11.776]                             muffled <- TRUE
[09:31:11.776]                             break
[09:31:11.776]                           }
[09:31:11.776]                         }
[09:31:11.776]                       }
[09:31:11.776]                       invisible(muffled)
[09:31:11.776]                     }
[09:31:11.776]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.776]                   }
[09:31:11.776]                 }
[09:31:11.776]                 else {
[09:31:11.776]                   if (TRUE) {
[09:31:11.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.776]                     {
[09:31:11.776]                       inherits <- base::inherits
[09:31:11.776]                       invokeRestart <- base::invokeRestart
[09:31:11.776]                       is.null <- base::is.null
[09:31:11.776]                       muffled <- FALSE
[09:31:11.776]                       if (inherits(cond, "message")) {
[09:31:11.776]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.776]                         if (muffled) 
[09:31:11.776]                           invokeRestart("muffleMessage")
[09:31:11.776]                       }
[09:31:11.776]                       else if (inherits(cond, "warning")) {
[09:31:11.776]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.776]                         if (muffled) 
[09:31:11.776]                           invokeRestart("muffleWarning")
[09:31:11.776]                       }
[09:31:11.776]                       else if (inherits(cond, "condition")) {
[09:31:11.776]                         if (!is.null(pattern)) {
[09:31:11.776]                           computeRestarts <- base::computeRestarts
[09:31:11.776]                           grepl <- base::grepl
[09:31:11.776]                           restarts <- computeRestarts(cond)
[09:31:11.776]                           for (restart in restarts) {
[09:31:11.776]                             name <- restart$name
[09:31:11.776]                             if (is.null(name)) 
[09:31:11.776]                               next
[09:31:11.776]                             if (!grepl(pattern, name)) 
[09:31:11.776]                               next
[09:31:11.776]                             invokeRestart(restart)
[09:31:11.776]                             muffled <- TRUE
[09:31:11.776]                             break
[09:31:11.776]                           }
[09:31:11.776]                         }
[09:31:11.776]                       }
[09:31:11.776]                       invisible(muffled)
[09:31:11.776]                     }
[09:31:11.776]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.776]                   }
[09:31:11.776]                 }
[09:31:11.776]             }
[09:31:11.776]         }))
[09:31:11.776]     }, error = function(ex) {
[09:31:11.776]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.776]                 ...future.rng), started = ...future.startTime, 
[09:31:11.776]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.776]             version = "1.8"), class = "FutureResult")
[09:31:11.776]     }, finally = {
[09:31:11.776]         if (!identical(...future.workdir, getwd())) 
[09:31:11.776]             setwd(...future.workdir)
[09:31:11.776]         {
[09:31:11.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.776]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.776]             }
[09:31:11.776]             base::options(...future.oldOptions)
[09:31:11.776]             if (.Platform$OS.type == "windows") {
[09:31:11.776]                 old_names <- names(...future.oldEnvVars)
[09:31:11.776]                 envs <- base::Sys.getenv()
[09:31:11.776]                 names <- names(envs)
[09:31:11.776]                 common <- intersect(names, old_names)
[09:31:11.776]                 added <- setdiff(names, old_names)
[09:31:11.776]                 removed <- setdiff(old_names, names)
[09:31:11.776]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.776]                   envs[common]]
[09:31:11.776]                 NAMES <- toupper(changed)
[09:31:11.776]                 args <- list()
[09:31:11.776]                 for (kk in seq_along(NAMES)) {
[09:31:11.776]                   name <- changed[[kk]]
[09:31:11.776]                   NAME <- NAMES[[kk]]
[09:31:11.776]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.776]                     next
[09:31:11.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.776]                 }
[09:31:11.776]                 NAMES <- toupper(added)
[09:31:11.776]                 for (kk in seq_along(NAMES)) {
[09:31:11.776]                   name <- added[[kk]]
[09:31:11.776]                   NAME <- NAMES[[kk]]
[09:31:11.776]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.776]                     next
[09:31:11.776]                   args[[name]] <- ""
[09:31:11.776]                 }
[09:31:11.776]                 NAMES <- toupper(removed)
[09:31:11.776]                 for (kk in seq_along(NAMES)) {
[09:31:11.776]                   name <- removed[[kk]]
[09:31:11.776]                   NAME <- NAMES[[kk]]
[09:31:11.776]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.776]                     next
[09:31:11.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.776]                 }
[09:31:11.776]                 if (length(args) > 0) 
[09:31:11.776]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.776]             }
[09:31:11.776]             else {
[09:31:11.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.776]             }
[09:31:11.776]             {
[09:31:11.776]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.776]                   0L) {
[09:31:11.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.776]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.776]                   base::options(opts)
[09:31:11.776]                 }
[09:31:11.776]                 {
[09:31:11.776]                   {
[09:31:11.776]                     NULL
[09:31:11.776]                     RNGkind("Mersenne-Twister")
[09:31:11.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.776]                       inherits = FALSE)
[09:31:11.776]                   }
[09:31:11.776]                   options(future.plan = NULL)
[09:31:11.776]                   if (is.na(NA_character_)) 
[09:31:11.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.776]                     .init = FALSE)
[09:31:11.776]                 }
[09:31:11.776]             }
[09:31:11.776]         }
[09:31:11.776]     })
[09:31:11.776]     if (TRUE) {
[09:31:11.776]         base::sink(type = "output", split = FALSE)
[09:31:11.776]         if (TRUE) {
[09:31:11.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.776]         }
[09:31:11.776]         else {
[09:31:11.776]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.776]         }
[09:31:11.776]         base::close(...future.stdout)
[09:31:11.776]         ...future.stdout <- NULL
[09:31:11.776]     }
[09:31:11.776]     ...future.result$conditions <- ...future.conditions
[09:31:11.776]     ...future.result$finished <- base::Sys.time()
[09:31:11.776]     ...future.result
[09:31:11.776] }
[09:31:11.778] plan(): Setting new future strategy stack:
[09:31:11.778] List of future strategies:
[09:31:11.778] 1. sequential:
[09:31:11.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.778]    - tweaked: FALSE
[09:31:11.778]    - call: NULL
[09:31:11.779] plan(): nbrOfWorkers() = 1
[09:31:11.779] plan(): Setting new future strategy stack:
[09:31:11.779] List of future strategies:
[09:31:11.779] 1. sequential:
[09:31:11.779]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.779]    - tweaked: FALSE
[09:31:11.779]    - call: plan(strategy)
[09:31:11.780] plan(): nbrOfWorkers() = 1
[09:31:11.780] SequentialFuture started (and completed)
[09:31:11.780] - Launch lazy future ... done
[09:31:11.780] run() for ‘SequentialFuture’ ... done
[09:31:11.780] getGlobalsAndPackages() ...
[09:31:11.780] Searching for globals...
[09:31:11.780] 
[09:31:11.781] Searching for globals ... DONE
[09:31:11.781] - globals: [0] <none>
[09:31:11.781] getGlobalsAndPackages() ... DONE
[09:31:11.781] run() for ‘Future’ ...
[09:31:11.781] - state: ‘created’
[09:31:11.781] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.782]   - Field: ‘label’
[09:31:11.782]   - Field: ‘local’
[09:31:11.782]   - Field: ‘owner’
[09:31:11.782]   - Field: ‘envir’
[09:31:11.782]   - Field: ‘packages’
[09:31:11.782]   - Field: ‘gc’
[09:31:11.782]   - Field: ‘conditions’
[09:31:11.782]   - Field: ‘expr’
[09:31:11.782]   - Field: ‘uuid’
[09:31:11.782]   - Field: ‘seed’
[09:31:11.782]   - Field: ‘version’
[09:31:11.783]   - Field: ‘result’
[09:31:11.783]   - Field: ‘asynchronous’
[09:31:11.783]   - Field: ‘calls’
[09:31:11.783]   - Field: ‘globals’
[09:31:11.783]   - Field: ‘stdout’
[09:31:11.783]   - Field: ‘earlySignal’
[09:31:11.783]   - Field: ‘lazy’
[09:31:11.783]   - Field: ‘state’
[09:31:11.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.783] - Launch lazy future ...
[09:31:11.783] Packages needed by the future expression (n = 0): <none>
[09:31:11.784] Packages needed by future strategies (n = 0): <none>
[09:31:11.784] {
[09:31:11.784]     {
[09:31:11.784]         {
[09:31:11.784]             ...future.startTime <- base::Sys.time()
[09:31:11.784]             {
[09:31:11.784]                 {
[09:31:11.784]                   {
[09:31:11.784]                     base::local({
[09:31:11.784]                       has_future <- base::requireNamespace("future", 
[09:31:11.784]                         quietly = TRUE)
[09:31:11.784]                       if (has_future) {
[09:31:11.784]                         ns <- base::getNamespace("future")
[09:31:11.784]                         version <- ns[[".package"]][["version"]]
[09:31:11.784]                         if (is.null(version)) 
[09:31:11.784]                           version <- utils::packageVersion("future")
[09:31:11.784]                       }
[09:31:11.784]                       else {
[09:31:11.784]                         version <- NULL
[09:31:11.784]                       }
[09:31:11.784]                       if (!has_future || version < "1.8.0") {
[09:31:11.784]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.784]                           "", base::R.version$version.string), 
[09:31:11.784]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.784]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.784]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.784]                             "release", "version")], collapse = " "), 
[09:31:11.784]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.784]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.784]                           info)
[09:31:11.784]                         info <- base::paste(info, collapse = "; ")
[09:31:11.784]                         if (!has_future) {
[09:31:11.784]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.784]                             info)
[09:31:11.784]                         }
[09:31:11.784]                         else {
[09:31:11.784]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.784]                             info, version)
[09:31:11.784]                         }
[09:31:11.784]                         base::stop(msg)
[09:31:11.784]                       }
[09:31:11.784]                     })
[09:31:11.784]                   }
[09:31:11.784]                   ...future.strategy.old <- future::plan("list")
[09:31:11.784]                   options(future.plan = NULL)
[09:31:11.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.784]                 }
[09:31:11.784]                 ...future.workdir <- getwd()
[09:31:11.784]             }
[09:31:11.784]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.784]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.784]         }
[09:31:11.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.784]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.784]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.784]             base::names(...future.oldOptions))
[09:31:11.784]     }
[09:31:11.784]     if (FALSE) {
[09:31:11.784]     }
[09:31:11.784]     else {
[09:31:11.784]         if (TRUE) {
[09:31:11.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.784]                 open = "w")
[09:31:11.784]         }
[09:31:11.784]         else {
[09:31:11.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.784]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.784]         }
[09:31:11.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.784]             base::sink(type = "output", split = FALSE)
[09:31:11.784]             base::close(...future.stdout)
[09:31:11.784]         }, add = TRUE)
[09:31:11.784]     }
[09:31:11.784]     ...future.frame <- base::sys.nframe()
[09:31:11.784]     ...future.conditions <- base::list()
[09:31:11.784]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.784]     if (FALSE) {
[09:31:11.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.784]     }
[09:31:11.784]     ...future.result <- base::tryCatch({
[09:31:11.784]         base::withCallingHandlers({
[09:31:11.784]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.784]             future::FutureResult(value = ...future.value$value, 
[09:31:11.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.784]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.784]                     ...future.globalenv.names))
[09:31:11.784]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.784]         }, condition = base::local({
[09:31:11.784]             c <- base::c
[09:31:11.784]             inherits <- base::inherits
[09:31:11.784]             invokeRestart <- base::invokeRestart
[09:31:11.784]             length <- base::length
[09:31:11.784]             list <- base::list
[09:31:11.784]             seq.int <- base::seq.int
[09:31:11.784]             signalCondition <- base::signalCondition
[09:31:11.784]             sys.calls <- base::sys.calls
[09:31:11.784]             `[[` <- base::`[[`
[09:31:11.784]             `+` <- base::`+`
[09:31:11.784]             `<<-` <- base::`<<-`
[09:31:11.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.784]                   3L)]
[09:31:11.784]             }
[09:31:11.784]             function(cond) {
[09:31:11.784]                 is_error <- inherits(cond, "error")
[09:31:11.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.784]                   NULL)
[09:31:11.784]                 if (is_error) {
[09:31:11.784]                   sessionInformation <- function() {
[09:31:11.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.784]                       search = base::search(), system = base::Sys.info())
[09:31:11.784]                   }
[09:31:11.784]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.784]                     cond$call), session = sessionInformation(), 
[09:31:11.784]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.784]                   signalCondition(cond)
[09:31:11.784]                 }
[09:31:11.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.784]                 "immediateCondition"))) {
[09:31:11.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.784]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.784]                   if (TRUE && !signal) {
[09:31:11.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.784]                     {
[09:31:11.784]                       inherits <- base::inherits
[09:31:11.784]                       invokeRestart <- base::invokeRestart
[09:31:11.784]                       is.null <- base::is.null
[09:31:11.784]                       muffled <- FALSE
[09:31:11.784]                       if (inherits(cond, "message")) {
[09:31:11.784]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.784]                         if (muffled) 
[09:31:11.784]                           invokeRestart("muffleMessage")
[09:31:11.784]                       }
[09:31:11.784]                       else if (inherits(cond, "warning")) {
[09:31:11.784]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.784]                         if (muffled) 
[09:31:11.784]                           invokeRestart("muffleWarning")
[09:31:11.784]                       }
[09:31:11.784]                       else if (inherits(cond, "condition")) {
[09:31:11.784]                         if (!is.null(pattern)) {
[09:31:11.784]                           computeRestarts <- base::computeRestarts
[09:31:11.784]                           grepl <- base::grepl
[09:31:11.784]                           restarts <- computeRestarts(cond)
[09:31:11.784]                           for (restart in restarts) {
[09:31:11.784]                             name <- restart$name
[09:31:11.784]                             if (is.null(name)) 
[09:31:11.784]                               next
[09:31:11.784]                             if (!grepl(pattern, name)) 
[09:31:11.784]                               next
[09:31:11.784]                             invokeRestart(restart)
[09:31:11.784]                             muffled <- TRUE
[09:31:11.784]                             break
[09:31:11.784]                           }
[09:31:11.784]                         }
[09:31:11.784]                       }
[09:31:11.784]                       invisible(muffled)
[09:31:11.784]                     }
[09:31:11.784]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.784]                   }
[09:31:11.784]                 }
[09:31:11.784]                 else {
[09:31:11.784]                   if (TRUE) {
[09:31:11.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.784]                     {
[09:31:11.784]                       inherits <- base::inherits
[09:31:11.784]                       invokeRestart <- base::invokeRestart
[09:31:11.784]                       is.null <- base::is.null
[09:31:11.784]                       muffled <- FALSE
[09:31:11.784]                       if (inherits(cond, "message")) {
[09:31:11.784]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.784]                         if (muffled) 
[09:31:11.784]                           invokeRestart("muffleMessage")
[09:31:11.784]                       }
[09:31:11.784]                       else if (inherits(cond, "warning")) {
[09:31:11.784]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.784]                         if (muffled) 
[09:31:11.784]                           invokeRestart("muffleWarning")
[09:31:11.784]                       }
[09:31:11.784]                       else if (inherits(cond, "condition")) {
[09:31:11.784]                         if (!is.null(pattern)) {
[09:31:11.784]                           computeRestarts <- base::computeRestarts
[09:31:11.784]                           grepl <- base::grepl
[09:31:11.784]                           restarts <- computeRestarts(cond)
[09:31:11.784]                           for (restart in restarts) {
[09:31:11.784]                             name <- restart$name
[09:31:11.784]                             if (is.null(name)) 
[09:31:11.784]                               next
[09:31:11.784]                             if (!grepl(pattern, name)) 
[09:31:11.784]                               next
[09:31:11.784]                             invokeRestart(restart)
[09:31:11.784]                             muffled <- TRUE
[09:31:11.784]                             break
[09:31:11.784]                           }
[09:31:11.784]                         }
[09:31:11.784]                       }
[09:31:11.784]                       invisible(muffled)
[09:31:11.784]                     }
[09:31:11.784]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.784]                   }
[09:31:11.784]                 }
[09:31:11.784]             }
[09:31:11.784]         }))
[09:31:11.784]     }, error = function(ex) {
[09:31:11.784]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.784]                 ...future.rng), started = ...future.startTime, 
[09:31:11.784]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.784]             version = "1.8"), class = "FutureResult")
[09:31:11.784]     }, finally = {
[09:31:11.784]         if (!identical(...future.workdir, getwd())) 
[09:31:11.784]             setwd(...future.workdir)
[09:31:11.784]         {
[09:31:11.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.784]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.784]             }
[09:31:11.784]             base::options(...future.oldOptions)
[09:31:11.784]             if (.Platform$OS.type == "windows") {
[09:31:11.784]                 old_names <- names(...future.oldEnvVars)
[09:31:11.784]                 envs <- base::Sys.getenv()
[09:31:11.784]                 names <- names(envs)
[09:31:11.784]                 common <- intersect(names, old_names)
[09:31:11.784]                 added <- setdiff(names, old_names)
[09:31:11.784]                 removed <- setdiff(old_names, names)
[09:31:11.784]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.784]                   envs[common]]
[09:31:11.784]                 NAMES <- toupper(changed)
[09:31:11.784]                 args <- list()
[09:31:11.784]                 for (kk in seq_along(NAMES)) {
[09:31:11.784]                   name <- changed[[kk]]
[09:31:11.784]                   NAME <- NAMES[[kk]]
[09:31:11.784]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.784]                     next
[09:31:11.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.784]                 }
[09:31:11.784]                 NAMES <- toupper(added)
[09:31:11.784]                 for (kk in seq_along(NAMES)) {
[09:31:11.784]                   name <- added[[kk]]
[09:31:11.784]                   NAME <- NAMES[[kk]]
[09:31:11.784]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.784]                     next
[09:31:11.784]                   args[[name]] <- ""
[09:31:11.784]                 }
[09:31:11.784]                 NAMES <- toupper(removed)
[09:31:11.784]                 for (kk in seq_along(NAMES)) {
[09:31:11.784]                   name <- removed[[kk]]
[09:31:11.784]                   NAME <- NAMES[[kk]]
[09:31:11.784]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.784]                     next
[09:31:11.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.784]                 }
[09:31:11.784]                 if (length(args) > 0) 
[09:31:11.784]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.784]             }
[09:31:11.784]             else {
[09:31:11.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.784]             }
[09:31:11.784]             {
[09:31:11.784]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.784]                   0L) {
[09:31:11.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.784]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.784]                   base::options(opts)
[09:31:11.784]                 }
[09:31:11.784]                 {
[09:31:11.784]                   {
[09:31:11.784]                     NULL
[09:31:11.784]                     RNGkind("Mersenne-Twister")
[09:31:11.784]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.784]                       inherits = FALSE)
[09:31:11.784]                   }
[09:31:11.784]                   options(future.plan = NULL)
[09:31:11.784]                   if (is.na(NA_character_)) 
[09:31:11.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.784]                     .init = FALSE)
[09:31:11.784]                 }
[09:31:11.784]             }
[09:31:11.784]         }
[09:31:11.784]     })
[09:31:11.784]     if (TRUE) {
[09:31:11.784]         base::sink(type = "output", split = FALSE)
[09:31:11.784]         if (TRUE) {
[09:31:11.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.784]         }
[09:31:11.784]         else {
[09:31:11.784]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.784]         }
[09:31:11.784]         base::close(...future.stdout)
[09:31:11.784]         ...future.stdout <- NULL
[09:31:11.784]     }
[09:31:11.784]     ...future.result$conditions <- ...future.conditions
[09:31:11.784]     ...future.result$finished <- base::Sys.time()
[09:31:11.784]     ...future.result
[09:31:11.784] }
[09:31:11.786] plan(): Setting new future strategy stack:
[09:31:11.786] List of future strategies:
[09:31:11.786] 1. sequential:
[09:31:11.786]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.786]    - tweaked: FALSE
[09:31:11.786]    - call: NULL
[09:31:11.786] plan(): nbrOfWorkers() = 1
[09:31:11.787] plan(): Setting new future strategy stack:
[09:31:11.787] List of future strategies:
[09:31:11.787] 1. sequential:
[09:31:11.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.787]    - tweaked: FALSE
[09:31:11.787]    - call: plan(strategy)
[09:31:11.787] plan(): nbrOfWorkers() = 1
[09:31:11.787] SequentialFuture started (and completed)
[09:31:11.787] - Launch lazy future ... done
[09:31:11.788] run() for ‘SequentialFuture’ ... done
[09:31:11.788] getGlobalsAndPackages() ...
[09:31:11.788] Searching for globals...
[09:31:11.788] - globals found: [1] ‘{’
[09:31:11.788] Searching for globals ... DONE
[09:31:11.789] Resolving globals: FALSE
[09:31:11.789] 
[09:31:11.789] 
[09:31:11.790] getGlobalsAndPackages() ... DONE
[09:31:11.790] run() for ‘Future’ ...
[09:31:11.790] - state: ‘created’
[09:31:11.790] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.791] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.791]   - Field: ‘label’
[09:31:11.791]   - Field: ‘local’
[09:31:11.791]   - Field: ‘owner’
[09:31:11.791]   - Field: ‘envir’
[09:31:11.791]   - Field: ‘packages’
[09:31:11.791]   - Field: ‘gc’
[09:31:11.791]   - Field: ‘conditions’
[09:31:11.792]   - Field: ‘expr’
[09:31:11.792]   - Field: ‘uuid’
[09:31:11.792]   - Field: ‘seed’
[09:31:11.792]   - Field: ‘version’
[09:31:11.792]   - Field: ‘result’
[09:31:11.792]   - Field: ‘asynchronous’
[09:31:11.792]   - Field: ‘calls’
[09:31:11.792]   - Field: ‘globals’
[09:31:11.792]   - Field: ‘stdout’
[09:31:11.792]   - Field: ‘earlySignal’
[09:31:11.792]   - Field: ‘lazy’
[09:31:11.792]   - Field: ‘state’
[09:31:11.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.793] - Launch lazy future ...
[09:31:11.793] Packages needed by the future expression (n = 0): <none>
[09:31:11.793] Packages needed by future strategies (n = 0): <none>
[09:31:11.793] {
[09:31:11.793]     {
[09:31:11.793]         {
[09:31:11.793]             ...future.startTime <- base::Sys.time()
[09:31:11.793]             {
[09:31:11.793]                 {
[09:31:11.793]                   {
[09:31:11.793]                     base::local({
[09:31:11.793]                       has_future <- base::requireNamespace("future", 
[09:31:11.793]                         quietly = TRUE)
[09:31:11.793]                       if (has_future) {
[09:31:11.793]                         ns <- base::getNamespace("future")
[09:31:11.793]                         version <- ns[[".package"]][["version"]]
[09:31:11.793]                         if (is.null(version)) 
[09:31:11.793]                           version <- utils::packageVersion("future")
[09:31:11.793]                       }
[09:31:11.793]                       else {
[09:31:11.793]                         version <- NULL
[09:31:11.793]                       }
[09:31:11.793]                       if (!has_future || version < "1.8.0") {
[09:31:11.793]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.793]                           "", base::R.version$version.string), 
[09:31:11.793]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.793]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.793]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.793]                             "release", "version")], collapse = " "), 
[09:31:11.793]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.793]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.793]                           info)
[09:31:11.793]                         info <- base::paste(info, collapse = "; ")
[09:31:11.793]                         if (!has_future) {
[09:31:11.793]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.793]                             info)
[09:31:11.793]                         }
[09:31:11.793]                         else {
[09:31:11.793]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.793]                             info, version)
[09:31:11.793]                         }
[09:31:11.793]                         base::stop(msg)
[09:31:11.793]                       }
[09:31:11.793]                     })
[09:31:11.793]                   }
[09:31:11.793]                   ...future.strategy.old <- future::plan("list")
[09:31:11.793]                   options(future.plan = NULL)
[09:31:11.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.793]                 }
[09:31:11.793]                 ...future.workdir <- getwd()
[09:31:11.793]             }
[09:31:11.793]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.793]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.793]         }
[09:31:11.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.793]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.793]             base::names(...future.oldOptions))
[09:31:11.793]     }
[09:31:11.793]     if (FALSE) {
[09:31:11.793]     }
[09:31:11.793]     else {
[09:31:11.793]         if (TRUE) {
[09:31:11.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.793]                 open = "w")
[09:31:11.793]         }
[09:31:11.793]         else {
[09:31:11.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.793]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.793]         }
[09:31:11.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.793]             base::sink(type = "output", split = FALSE)
[09:31:11.793]             base::close(...future.stdout)
[09:31:11.793]         }, add = TRUE)
[09:31:11.793]     }
[09:31:11.793]     ...future.frame <- base::sys.nframe()
[09:31:11.793]     ...future.conditions <- base::list()
[09:31:11.793]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.793]     if (FALSE) {
[09:31:11.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.793]     }
[09:31:11.793]     ...future.result <- base::tryCatch({
[09:31:11.793]         base::withCallingHandlers({
[09:31:11.793]             ...future.value <- base::withVisible(base::local({
[09:31:11.793]                 4
[09:31:11.793]             }))
[09:31:11.793]             future::FutureResult(value = ...future.value$value, 
[09:31:11.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.793]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.793]                     ...future.globalenv.names))
[09:31:11.793]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.793]         }, condition = base::local({
[09:31:11.793]             c <- base::c
[09:31:11.793]             inherits <- base::inherits
[09:31:11.793]             invokeRestart <- base::invokeRestart
[09:31:11.793]             length <- base::length
[09:31:11.793]             list <- base::list
[09:31:11.793]             seq.int <- base::seq.int
[09:31:11.793]             signalCondition <- base::signalCondition
[09:31:11.793]             sys.calls <- base::sys.calls
[09:31:11.793]             `[[` <- base::`[[`
[09:31:11.793]             `+` <- base::`+`
[09:31:11.793]             `<<-` <- base::`<<-`
[09:31:11.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.793]                   3L)]
[09:31:11.793]             }
[09:31:11.793]             function(cond) {
[09:31:11.793]                 is_error <- inherits(cond, "error")
[09:31:11.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.793]                   NULL)
[09:31:11.793]                 if (is_error) {
[09:31:11.793]                   sessionInformation <- function() {
[09:31:11.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.793]                       search = base::search(), system = base::Sys.info())
[09:31:11.793]                   }
[09:31:11.793]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.793]                     cond$call), session = sessionInformation(), 
[09:31:11.793]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.793]                   signalCondition(cond)
[09:31:11.793]                 }
[09:31:11.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.793]                 "immediateCondition"))) {
[09:31:11.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.793]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.793]                   if (TRUE && !signal) {
[09:31:11.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.793]                     {
[09:31:11.793]                       inherits <- base::inherits
[09:31:11.793]                       invokeRestart <- base::invokeRestart
[09:31:11.793]                       is.null <- base::is.null
[09:31:11.793]                       muffled <- FALSE
[09:31:11.793]                       if (inherits(cond, "message")) {
[09:31:11.793]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.793]                         if (muffled) 
[09:31:11.793]                           invokeRestart("muffleMessage")
[09:31:11.793]                       }
[09:31:11.793]                       else if (inherits(cond, "warning")) {
[09:31:11.793]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.793]                         if (muffled) 
[09:31:11.793]                           invokeRestart("muffleWarning")
[09:31:11.793]                       }
[09:31:11.793]                       else if (inherits(cond, "condition")) {
[09:31:11.793]                         if (!is.null(pattern)) {
[09:31:11.793]                           computeRestarts <- base::computeRestarts
[09:31:11.793]                           grepl <- base::grepl
[09:31:11.793]                           restarts <- computeRestarts(cond)
[09:31:11.793]                           for (restart in restarts) {
[09:31:11.793]                             name <- restart$name
[09:31:11.793]                             if (is.null(name)) 
[09:31:11.793]                               next
[09:31:11.793]                             if (!grepl(pattern, name)) 
[09:31:11.793]                               next
[09:31:11.793]                             invokeRestart(restart)
[09:31:11.793]                             muffled <- TRUE
[09:31:11.793]                             break
[09:31:11.793]                           }
[09:31:11.793]                         }
[09:31:11.793]                       }
[09:31:11.793]                       invisible(muffled)
[09:31:11.793]                     }
[09:31:11.793]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.793]                   }
[09:31:11.793]                 }
[09:31:11.793]                 else {
[09:31:11.793]                   if (TRUE) {
[09:31:11.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.793]                     {
[09:31:11.793]                       inherits <- base::inherits
[09:31:11.793]                       invokeRestart <- base::invokeRestart
[09:31:11.793]                       is.null <- base::is.null
[09:31:11.793]                       muffled <- FALSE
[09:31:11.793]                       if (inherits(cond, "message")) {
[09:31:11.793]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.793]                         if (muffled) 
[09:31:11.793]                           invokeRestart("muffleMessage")
[09:31:11.793]                       }
[09:31:11.793]                       else if (inherits(cond, "warning")) {
[09:31:11.793]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.793]                         if (muffled) 
[09:31:11.793]                           invokeRestart("muffleWarning")
[09:31:11.793]                       }
[09:31:11.793]                       else if (inherits(cond, "condition")) {
[09:31:11.793]                         if (!is.null(pattern)) {
[09:31:11.793]                           computeRestarts <- base::computeRestarts
[09:31:11.793]                           grepl <- base::grepl
[09:31:11.793]                           restarts <- computeRestarts(cond)
[09:31:11.793]                           for (restart in restarts) {
[09:31:11.793]                             name <- restart$name
[09:31:11.793]                             if (is.null(name)) 
[09:31:11.793]                               next
[09:31:11.793]                             if (!grepl(pattern, name)) 
[09:31:11.793]                               next
[09:31:11.793]                             invokeRestart(restart)
[09:31:11.793]                             muffled <- TRUE
[09:31:11.793]                             break
[09:31:11.793]                           }
[09:31:11.793]                         }
[09:31:11.793]                       }
[09:31:11.793]                       invisible(muffled)
[09:31:11.793]                     }
[09:31:11.793]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.793]                   }
[09:31:11.793]                 }
[09:31:11.793]             }
[09:31:11.793]         }))
[09:31:11.793]     }, error = function(ex) {
[09:31:11.793]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.793]                 ...future.rng), started = ...future.startTime, 
[09:31:11.793]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.793]             version = "1.8"), class = "FutureResult")
[09:31:11.793]     }, finally = {
[09:31:11.793]         if (!identical(...future.workdir, getwd())) 
[09:31:11.793]             setwd(...future.workdir)
[09:31:11.793]         {
[09:31:11.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.793]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.793]             }
[09:31:11.793]             base::options(...future.oldOptions)
[09:31:11.793]             if (.Platform$OS.type == "windows") {
[09:31:11.793]                 old_names <- names(...future.oldEnvVars)
[09:31:11.793]                 envs <- base::Sys.getenv()
[09:31:11.793]                 names <- names(envs)
[09:31:11.793]                 common <- intersect(names, old_names)
[09:31:11.793]                 added <- setdiff(names, old_names)
[09:31:11.793]                 removed <- setdiff(old_names, names)
[09:31:11.793]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.793]                   envs[common]]
[09:31:11.793]                 NAMES <- toupper(changed)
[09:31:11.793]                 args <- list()
[09:31:11.793]                 for (kk in seq_along(NAMES)) {
[09:31:11.793]                   name <- changed[[kk]]
[09:31:11.793]                   NAME <- NAMES[[kk]]
[09:31:11.793]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.793]                     next
[09:31:11.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.793]                 }
[09:31:11.793]                 NAMES <- toupper(added)
[09:31:11.793]                 for (kk in seq_along(NAMES)) {
[09:31:11.793]                   name <- added[[kk]]
[09:31:11.793]                   NAME <- NAMES[[kk]]
[09:31:11.793]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.793]                     next
[09:31:11.793]                   args[[name]] <- ""
[09:31:11.793]                 }
[09:31:11.793]                 NAMES <- toupper(removed)
[09:31:11.793]                 for (kk in seq_along(NAMES)) {
[09:31:11.793]                   name <- removed[[kk]]
[09:31:11.793]                   NAME <- NAMES[[kk]]
[09:31:11.793]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.793]                     next
[09:31:11.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.793]                 }
[09:31:11.793]                 if (length(args) > 0) 
[09:31:11.793]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.793]             }
[09:31:11.793]             else {
[09:31:11.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.793]             }
[09:31:11.793]             {
[09:31:11.793]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.793]                   0L) {
[09:31:11.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.793]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.793]                   base::options(opts)
[09:31:11.793]                 }
[09:31:11.793]                 {
[09:31:11.793]                   {
[09:31:11.793]                     NULL
[09:31:11.793]                     RNGkind("Mersenne-Twister")
[09:31:11.793]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.793]                       inherits = FALSE)
[09:31:11.793]                   }
[09:31:11.793]                   options(future.plan = NULL)
[09:31:11.793]                   if (is.na(NA_character_)) 
[09:31:11.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.793]                     .init = FALSE)
[09:31:11.793]                 }
[09:31:11.793]             }
[09:31:11.793]         }
[09:31:11.793]     })
[09:31:11.793]     if (TRUE) {
[09:31:11.793]         base::sink(type = "output", split = FALSE)
[09:31:11.793]         if (TRUE) {
[09:31:11.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.793]         }
[09:31:11.793]         else {
[09:31:11.793]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.793]         }
[09:31:11.793]         base::close(...future.stdout)
[09:31:11.793]         ...future.stdout <- NULL
[09:31:11.793]     }
[09:31:11.793]     ...future.result$conditions <- ...future.conditions
[09:31:11.793]     ...future.result$finished <- base::Sys.time()
[09:31:11.793]     ...future.result
[09:31:11.793] }
[09:31:11.795] plan(): Setting new future strategy stack:
[09:31:11.795] List of future strategies:
[09:31:11.795] 1. sequential:
[09:31:11.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.795]    - tweaked: FALSE
[09:31:11.795]    - call: NULL
[09:31:11.795] plan(): nbrOfWorkers() = 1
[09:31:11.796] plan(): Setting new future strategy stack:
[09:31:11.796] List of future strategies:
[09:31:11.796] 1. sequential:
[09:31:11.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.796]    - tweaked: FALSE
[09:31:11.796]    - call: plan(strategy)
[09:31:11.797] plan(): nbrOfWorkers() = 1
[09:31:11.797] SequentialFuture started (and completed)
[09:31:11.797] - Launch lazy future ... done
[09:31:11.797] run() for ‘SequentialFuture’ ... done
<environment: 0x55a3ca76edd8> 
<environment: 0x55a3c8db52a0> 
[09:31:11.798] resolved() for ‘SequentialFuture’ ...
[09:31:11.798] - state: ‘finished’
[09:31:11.798] - run: TRUE
[09:31:11.798] - result: ‘FutureResult’
[09:31:11.798] resolved() for ‘SequentialFuture’ ... done
[09:31:11.799] resolved() for ‘SequentialFuture’ ...
[09:31:11.799] - state: ‘finished’
[09:31:11.799] - run: TRUE
[09:31:11.799] - result: ‘FutureResult’
[09:31:11.799] resolved() for ‘SequentialFuture’ ... done
[09:31:11.799] resolved() for ‘SequentialFuture’ ...
[09:31:11.799] - state: ‘finished’
[09:31:11.799] - run: TRUE
[09:31:11.799] - result: ‘FutureResult’
[09:31:11.799] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:11.800] resolve() on environment ...
[09:31:11.800]  recursive: 0
[09:31:11.801]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:11.801] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.801] - nx: 4
[09:31:11.801] - relay: TRUE
[09:31:11.801] - stdout: TRUE
[09:31:11.801] - signal: TRUE
[09:31:11.801] - resignal: FALSE
[09:31:11.801] - force: TRUE
[09:31:11.802] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.802] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.802]  - until=2
[09:31:11.802]  - relaying element #2
[09:31:11.802] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.802] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.802] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.802]  length: 3 (resolved future 1)
[09:31:11.802] resolved() for ‘SequentialFuture’ ...
[09:31:11.802] - state: ‘finished’
[09:31:11.802] - run: TRUE
[09:31:11.802] - result: ‘FutureResult’
[09:31:11.803] resolved() for ‘SequentialFuture’ ... done
[09:31:11.803] Future #2
[09:31:11.803] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.803] - nx: 4
[09:31:11.803] - relay: TRUE
[09:31:11.803] - stdout: TRUE
[09:31:11.803] - signal: TRUE
[09:31:11.803] - resignal: FALSE
[09:31:11.803] - force: TRUE
[09:31:11.803] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.803] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.803]  - until=2
[09:31:11.804]  - relaying element #2
[09:31:11.804] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.804] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.804] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.804]  length: 2 (resolved future 2)
[09:31:11.804] resolved() for ‘SequentialFuture’ ...
[09:31:11.804] - state: ‘finished’
[09:31:11.804] - run: TRUE
[09:31:11.804] - result: ‘FutureResult’
[09:31:11.804] resolved() for ‘SequentialFuture’ ... done
[09:31:11.805] Future #3
[09:31:11.805] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.805] - nx: 4
[09:31:11.805] - relay: TRUE
[09:31:11.805] - stdout: TRUE
[09:31:11.805] - signal: TRUE
[09:31:11.805] - resignal: FALSE
[09:31:11.805] - force: TRUE
[09:31:11.805] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.805] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.805]  - until=3
[09:31:11.805]  - relaying element #3
[09:31:11.806] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.806] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.806] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.806]  length: 1 (resolved future 3)
[09:31:11.806] resolved() for ‘SequentialFuture’ ...
[09:31:11.806] - state: ‘finished’
[09:31:11.806] - run: TRUE
[09:31:11.806] - result: ‘FutureResult’
[09:31:11.806] resolved() for ‘SequentialFuture’ ... done
[09:31:11.806] Future #4
[09:31:11.806] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.807] - nx: 4
[09:31:11.807] - relay: TRUE
[09:31:11.807] - stdout: TRUE
[09:31:11.807] - signal: TRUE
[09:31:11.807] - resignal: FALSE
[09:31:11.807] - force: TRUE
[09:31:11.807] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.807] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.807]  - until=4
[09:31:11.807]  - relaying element #4
[09:31:11.807] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.807] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.808] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.808]  length: 0 (resolved future 4)
[09:31:11.808] Relaying remaining futures
[09:31:11.808] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.808] - nx: 4
[09:31:11.808] - relay: TRUE
[09:31:11.808] - stdout: TRUE
[09:31:11.808] - signal: TRUE
[09:31:11.808] - resignal: FALSE
[09:31:11.808] - force: TRUE
[09:31:11.808] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.808] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:11.809] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.809] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.809] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.809] resolve() on environment ... DONE
<environment: 0x55a3ca6f4438> 
Dimensions: c(2, 3, 1)
[09:31:11.809] getGlobalsAndPackages() ...
[09:31:11.809] Searching for globals...
[09:31:11.810] 
[09:31:11.810] Searching for globals ... DONE
[09:31:11.810] - globals: [0] <none>
[09:31:11.810] getGlobalsAndPackages() ... DONE
[09:31:11.810] run() for ‘Future’ ...
[09:31:11.810] - state: ‘created’
[09:31:11.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.811] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.811]   - Field: ‘label’
[09:31:11.811]   - Field: ‘local’
[09:31:11.811]   - Field: ‘owner’
[09:31:11.811]   - Field: ‘envir’
[09:31:11.811]   - Field: ‘packages’
[09:31:11.811]   - Field: ‘gc’
[09:31:11.811]   - Field: ‘conditions’
[09:31:11.811]   - Field: ‘expr’
[09:31:11.811]   - Field: ‘uuid’
[09:31:11.812]   - Field: ‘seed’
[09:31:11.812]   - Field: ‘version’
[09:31:11.812]   - Field: ‘result’
[09:31:11.812]   - Field: ‘asynchronous’
[09:31:11.812]   - Field: ‘calls’
[09:31:11.812]   - Field: ‘globals’
[09:31:11.812]   - Field: ‘stdout’
[09:31:11.812]   - Field: ‘earlySignal’
[09:31:11.812]   - Field: ‘lazy’
[09:31:11.812]   - Field: ‘state’
[09:31:11.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.812] - Launch lazy future ...
[09:31:11.813] Packages needed by the future expression (n = 0): <none>
[09:31:11.813] Packages needed by future strategies (n = 0): <none>
[09:31:11.813] {
[09:31:11.813]     {
[09:31:11.813]         {
[09:31:11.813]             ...future.startTime <- base::Sys.time()
[09:31:11.813]             {
[09:31:11.813]                 {
[09:31:11.813]                   {
[09:31:11.813]                     base::local({
[09:31:11.813]                       has_future <- base::requireNamespace("future", 
[09:31:11.813]                         quietly = TRUE)
[09:31:11.813]                       if (has_future) {
[09:31:11.813]                         ns <- base::getNamespace("future")
[09:31:11.813]                         version <- ns[[".package"]][["version"]]
[09:31:11.813]                         if (is.null(version)) 
[09:31:11.813]                           version <- utils::packageVersion("future")
[09:31:11.813]                       }
[09:31:11.813]                       else {
[09:31:11.813]                         version <- NULL
[09:31:11.813]                       }
[09:31:11.813]                       if (!has_future || version < "1.8.0") {
[09:31:11.813]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.813]                           "", base::R.version$version.string), 
[09:31:11.813]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.813]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.813]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.813]                             "release", "version")], collapse = " "), 
[09:31:11.813]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.813]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.813]                           info)
[09:31:11.813]                         info <- base::paste(info, collapse = "; ")
[09:31:11.813]                         if (!has_future) {
[09:31:11.813]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.813]                             info)
[09:31:11.813]                         }
[09:31:11.813]                         else {
[09:31:11.813]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.813]                             info, version)
[09:31:11.813]                         }
[09:31:11.813]                         base::stop(msg)
[09:31:11.813]                       }
[09:31:11.813]                     })
[09:31:11.813]                   }
[09:31:11.813]                   ...future.strategy.old <- future::plan("list")
[09:31:11.813]                   options(future.plan = NULL)
[09:31:11.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.813]                 }
[09:31:11.813]                 ...future.workdir <- getwd()
[09:31:11.813]             }
[09:31:11.813]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.813]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.813]         }
[09:31:11.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.813]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.813]             base::names(...future.oldOptions))
[09:31:11.813]     }
[09:31:11.813]     if (FALSE) {
[09:31:11.813]     }
[09:31:11.813]     else {
[09:31:11.813]         if (TRUE) {
[09:31:11.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.813]                 open = "w")
[09:31:11.813]         }
[09:31:11.813]         else {
[09:31:11.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.813]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.813]         }
[09:31:11.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.813]             base::sink(type = "output", split = FALSE)
[09:31:11.813]             base::close(...future.stdout)
[09:31:11.813]         }, add = TRUE)
[09:31:11.813]     }
[09:31:11.813]     ...future.frame <- base::sys.nframe()
[09:31:11.813]     ...future.conditions <- base::list()
[09:31:11.813]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.813]     if (FALSE) {
[09:31:11.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.813]     }
[09:31:11.813]     ...future.result <- base::tryCatch({
[09:31:11.813]         base::withCallingHandlers({
[09:31:11.813]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.813]             future::FutureResult(value = ...future.value$value, 
[09:31:11.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.813]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.813]                     ...future.globalenv.names))
[09:31:11.813]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.813]         }, condition = base::local({
[09:31:11.813]             c <- base::c
[09:31:11.813]             inherits <- base::inherits
[09:31:11.813]             invokeRestart <- base::invokeRestart
[09:31:11.813]             length <- base::length
[09:31:11.813]             list <- base::list
[09:31:11.813]             seq.int <- base::seq.int
[09:31:11.813]             signalCondition <- base::signalCondition
[09:31:11.813]             sys.calls <- base::sys.calls
[09:31:11.813]             `[[` <- base::`[[`
[09:31:11.813]             `+` <- base::`+`
[09:31:11.813]             `<<-` <- base::`<<-`
[09:31:11.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.813]                   3L)]
[09:31:11.813]             }
[09:31:11.813]             function(cond) {
[09:31:11.813]                 is_error <- inherits(cond, "error")
[09:31:11.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.813]                   NULL)
[09:31:11.813]                 if (is_error) {
[09:31:11.813]                   sessionInformation <- function() {
[09:31:11.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.813]                       search = base::search(), system = base::Sys.info())
[09:31:11.813]                   }
[09:31:11.813]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.813]                     cond$call), session = sessionInformation(), 
[09:31:11.813]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.813]                   signalCondition(cond)
[09:31:11.813]                 }
[09:31:11.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.813]                 "immediateCondition"))) {
[09:31:11.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.813]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.813]                   if (TRUE && !signal) {
[09:31:11.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.813]                     {
[09:31:11.813]                       inherits <- base::inherits
[09:31:11.813]                       invokeRestart <- base::invokeRestart
[09:31:11.813]                       is.null <- base::is.null
[09:31:11.813]                       muffled <- FALSE
[09:31:11.813]                       if (inherits(cond, "message")) {
[09:31:11.813]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.813]                         if (muffled) 
[09:31:11.813]                           invokeRestart("muffleMessage")
[09:31:11.813]                       }
[09:31:11.813]                       else if (inherits(cond, "warning")) {
[09:31:11.813]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.813]                         if (muffled) 
[09:31:11.813]                           invokeRestart("muffleWarning")
[09:31:11.813]                       }
[09:31:11.813]                       else if (inherits(cond, "condition")) {
[09:31:11.813]                         if (!is.null(pattern)) {
[09:31:11.813]                           computeRestarts <- base::computeRestarts
[09:31:11.813]                           grepl <- base::grepl
[09:31:11.813]                           restarts <- computeRestarts(cond)
[09:31:11.813]                           for (restart in restarts) {
[09:31:11.813]                             name <- restart$name
[09:31:11.813]                             if (is.null(name)) 
[09:31:11.813]                               next
[09:31:11.813]                             if (!grepl(pattern, name)) 
[09:31:11.813]                               next
[09:31:11.813]                             invokeRestart(restart)
[09:31:11.813]                             muffled <- TRUE
[09:31:11.813]                             break
[09:31:11.813]                           }
[09:31:11.813]                         }
[09:31:11.813]                       }
[09:31:11.813]                       invisible(muffled)
[09:31:11.813]                     }
[09:31:11.813]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.813]                   }
[09:31:11.813]                 }
[09:31:11.813]                 else {
[09:31:11.813]                   if (TRUE) {
[09:31:11.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.813]                     {
[09:31:11.813]                       inherits <- base::inherits
[09:31:11.813]                       invokeRestart <- base::invokeRestart
[09:31:11.813]                       is.null <- base::is.null
[09:31:11.813]                       muffled <- FALSE
[09:31:11.813]                       if (inherits(cond, "message")) {
[09:31:11.813]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.813]                         if (muffled) 
[09:31:11.813]                           invokeRestart("muffleMessage")
[09:31:11.813]                       }
[09:31:11.813]                       else if (inherits(cond, "warning")) {
[09:31:11.813]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.813]                         if (muffled) 
[09:31:11.813]                           invokeRestart("muffleWarning")
[09:31:11.813]                       }
[09:31:11.813]                       else if (inherits(cond, "condition")) {
[09:31:11.813]                         if (!is.null(pattern)) {
[09:31:11.813]                           computeRestarts <- base::computeRestarts
[09:31:11.813]                           grepl <- base::grepl
[09:31:11.813]                           restarts <- computeRestarts(cond)
[09:31:11.813]                           for (restart in restarts) {
[09:31:11.813]                             name <- restart$name
[09:31:11.813]                             if (is.null(name)) 
[09:31:11.813]                               next
[09:31:11.813]                             if (!grepl(pattern, name)) 
[09:31:11.813]                               next
[09:31:11.813]                             invokeRestart(restart)
[09:31:11.813]                             muffled <- TRUE
[09:31:11.813]                             break
[09:31:11.813]                           }
[09:31:11.813]                         }
[09:31:11.813]                       }
[09:31:11.813]                       invisible(muffled)
[09:31:11.813]                     }
[09:31:11.813]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.813]                   }
[09:31:11.813]                 }
[09:31:11.813]             }
[09:31:11.813]         }))
[09:31:11.813]     }, error = function(ex) {
[09:31:11.813]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.813]                 ...future.rng), started = ...future.startTime, 
[09:31:11.813]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.813]             version = "1.8"), class = "FutureResult")
[09:31:11.813]     }, finally = {
[09:31:11.813]         if (!identical(...future.workdir, getwd())) 
[09:31:11.813]             setwd(...future.workdir)
[09:31:11.813]         {
[09:31:11.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.813]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.813]             }
[09:31:11.813]             base::options(...future.oldOptions)
[09:31:11.813]             if (.Platform$OS.type == "windows") {
[09:31:11.813]                 old_names <- names(...future.oldEnvVars)
[09:31:11.813]                 envs <- base::Sys.getenv()
[09:31:11.813]                 names <- names(envs)
[09:31:11.813]                 common <- intersect(names, old_names)
[09:31:11.813]                 added <- setdiff(names, old_names)
[09:31:11.813]                 removed <- setdiff(old_names, names)
[09:31:11.813]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.813]                   envs[common]]
[09:31:11.813]                 NAMES <- toupper(changed)
[09:31:11.813]                 args <- list()
[09:31:11.813]                 for (kk in seq_along(NAMES)) {
[09:31:11.813]                   name <- changed[[kk]]
[09:31:11.813]                   NAME <- NAMES[[kk]]
[09:31:11.813]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.813]                     next
[09:31:11.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.813]                 }
[09:31:11.813]                 NAMES <- toupper(added)
[09:31:11.813]                 for (kk in seq_along(NAMES)) {
[09:31:11.813]                   name <- added[[kk]]
[09:31:11.813]                   NAME <- NAMES[[kk]]
[09:31:11.813]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.813]                     next
[09:31:11.813]                   args[[name]] <- ""
[09:31:11.813]                 }
[09:31:11.813]                 NAMES <- toupper(removed)
[09:31:11.813]                 for (kk in seq_along(NAMES)) {
[09:31:11.813]                   name <- removed[[kk]]
[09:31:11.813]                   NAME <- NAMES[[kk]]
[09:31:11.813]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.813]                     next
[09:31:11.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.813]                 }
[09:31:11.813]                 if (length(args) > 0) 
[09:31:11.813]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.813]             }
[09:31:11.813]             else {
[09:31:11.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.813]             }
[09:31:11.813]             {
[09:31:11.813]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.813]                   0L) {
[09:31:11.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.813]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.813]                   base::options(opts)
[09:31:11.813]                 }
[09:31:11.813]                 {
[09:31:11.813]                   {
[09:31:11.813]                     NULL
[09:31:11.813]                     RNGkind("Mersenne-Twister")
[09:31:11.813]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.813]                       inherits = FALSE)
[09:31:11.813]                   }
[09:31:11.813]                   options(future.plan = NULL)
[09:31:11.813]                   if (is.na(NA_character_)) 
[09:31:11.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.813]                     .init = FALSE)
[09:31:11.813]                 }
[09:31:11.813]             }
[09:31:11.813]         }
[09:31:11.813]     })
[09:31:11.813]     if (TRUE) {
[09:31:11.813]         base::sink(type = "output", split = FALSE)
[09:31:11.813]         if (TRUE) {
[09:31:11.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.813]         }
[09:31:11.813]         else {
[09:31:11.813]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.813]         }
[09:31:11.813]         base::close(...future.stdout)
[09:31:11.813]         ...future.stdout <- NULL
[09:31:11.813]     }
[09:31:11.813]     ...future.result$conditions <- ...future.conditions
[09:31:11.813]     ...future.result$finished <- base::Sys.time()
[09:31:11.813]     ...future.result
[09:31:11.813] }
[09:31:11.815] plan(): Setting new future strategy stack:
[09:31:11.815] List of future strategies:
[09:31:11.815] 1. sequential:
[09:31:11.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.815]    - tweaked: FALSE
[09:31:11.815]    - call: NULL
[09:31:11.816] plan(): nbrOfWorkers() = 1
[09:31:11.817] plan(): Setting new future strategy stack:
[09:31:11.817] List of future strategies:
[09:31:11.817] 1. sequential:
[09:31:11.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.817]    - tweaked: FALSE
[09:31:11.817]    - call: plan(strategy)
[09:31:11.818] plan(): nbrOfWorkers() = 1
[09:31:11.818] SequentialFuture started (and completed)
[09:31:11.818] - Launch lazy future ... done
[09:31:11.818] run() for ‘SequentialFuture’ ... done
[09:31:11.818] getGlobalsAndPackages() ...
[09:31:11.818] Searching for globals...
[09:31:11.818] 
[09:31:11.818] Searching for globals ... DONE
[09:31:11.819] - globals: [0] <none>
[09:31:11.819] getGlobalsAndPackages() ... DONE
[09:31:11.819] run() for ‘Future’ ...
[09:31:11.819] - state: ‘created’
[09:31:11.819] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.819]   - Field: ‘label’
[09:31:11.820]   - Field: ‘local’
[09:31:11.820]   - Field: ‘owner’
[09:31:11.820]   - Field: ‘envir’
[09:31:11.820]   - Field: ‘packages’
[09:31:11.820]   - Field: ‘gc’
[09:31:11.820]   - Field: ‘conditions’
[09:31:11.820]   - Field: ‘expr’
[09:31:11.820]   - Field: ‘uuid’
[09:31:11.820]   - Field: ‘seed’
[09:31:11.820]   - Field: ‘version’
[09:31:11.820]   - Field: ‘result’
[09:31:11.820]   - Field: ‘asynchronous’
[09:31:11.821]   - Field: ‘calls’
[09:31:11.821]   - Field: ‘globals’
[09:31:11.821]   - Field: ‘stdout’
[09:31:11.821]   - Field: ‘earlySignal’
[09:31:11.821]   - Field: ‘lazy’
[09:31:11.821]   - Field: ‘state’
[09:31:11.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.821] - Launch lazy future ...
[09:31:11.821] Packages needed by the future expression (n = 0): <none>
[09:31:11.821] Packages needed by future strategies (n = 0): <none>
[09:31:11.822] {
[09:31:11.822]     {
[09:31:11.822]         {
[09:31:11.822]             ...future.startTime <- base::Sys.time()
[09:31:11.822]             {
[09:31:11.822]                 {
[09:31:11.822]                   {
[09:31:11.822]                     base::local({
[09:31:11.822]                       has_future <- base::requireNamespace("future", 
[09:31:11.822]                         quietly = TRUE)
[09:31:11.822]                       if (has_future) {
[09:31:11.822]                         ns <- base::getNamespace("future")
[09:31:11.822]                         version <- ns[[".package"]][["version"]]
[09:31:11.822]                         if (is.null(version)) 
[09:31:11.822]                           version <- utils::packageVersion("future")
[09:31:11.822]                       }
[09:31:11.822]                       else {
[09:31:11.822]                         version <- NULL
[09:31:11.822]                       }
[09:31:11.822]                       if (!has_future || version < "1.8.0") {
[09:31:11.822]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.822]                           "", base::R.version$version.string), 
[09:31:11.822]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.822]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.822]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.822]                             "release", "version")], collapse = " "), 
[09:31:11.822]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.822]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.822]                           info)
[09:31:11.822]                         info <- base::paste(info, collapse = "; ")
[09:31:11.822]                         if (!has_future) {
[09:31:11.822]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.822]                             info)
[09:31:11.822]                         }
[09:31:11.822]                         else {
[09:31:11.822]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.822]                             info, version)
[09:31:11.822]                         }
[09:31:11.822]                         base::stop(msg)
[09:31:11.822]                       }
[09:31:11.822]                     })
[09:31:11.822]                   }
[09:31:11.822]                   ...future.strategy.old <- future::plan("list")
[09:31:11.822]                   options(future.plan = NULL)
[09:31:11.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.822]                 }
[09:31:11.822]                 ...future.workdir <- getwd()
[09:31:11.822]             }
[09:31:11.822]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.822]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.822]         }
[09:31:11.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.822]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.822]             base::names(...future.oldOptions))
[09:31:11.822]     }
[09:31:11.822]     if (FALSE) {
[09:31:11.822]     }
[09:31:11.822]     else {
[09:31:11.822]         if (TRUE) {
[09:31:11.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.822]                 open = "w")
[09:31:11.822]         }
[09:31:11.822]         else {
[09:31:11.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.822]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.822]         }
[09:31:11.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.822]             base::sink(type = "output", split = FALSE)
[09:31:11.822]             base::close(...future.stdout)
[09:31:11.822]         }, add = TRUE)
[09:31:11.822]     }
[09:31:11.822]     ...future.frame <- base::sys.nframe()
[09:31:11.822]     ...future.conditions <- base::list()
[09:31:11.822]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.822]     if (FALSE) {
[09:31:11.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.822]     }
[09:31:11.822]     ...future.result <- base::tryCatch({
[09:31:11.822]         base::withCallingHandlers({
[09:31:11.822]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.822]             future::FutureResult(value = ...future.value$value, 
[09:31:11.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.822]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.822]                     ...future.globalenv.names))
[09:31:11.822]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.822]         }, condition = base::local({
[09:31:11.822]             c <- base::c
[09:31:11.822]             inherits <- base::inherits
[09:31:11.822]             invokeRestart <- base::invokeRestart
[09:31:11.822]             length <- base::length
[09:31:11.822]             list <- base::list
[09:31:11.822]             seq.int <- base::seq.int
[09:31:11.822]             signalCondition <- base::signalCondition
[09:31:11.822]             sys.calls <- base::sys.calls
[09:31:11.822]             `[[` <- base::`[[`
[09:31:11.822]             `+` <- base::`+`
[09:31:11.822]             `<<-` <- base::`<<-`
[09:31:11.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.822]                   3L)]
[09:31:11.822]             }
[09:31:11.822]             function(cond) {
[09:31:11.822]                 is_error <- inherits(cond, "error")
[09:31:11.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.822]                   NULL)
[09:31:11.822]                 if (is_error) {
[09:31:11.822]                   sessionInformation <- function() {
[09:31:11.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.822]                       search = base::search(), system = base::Sys.info())
[09:31:11.822]                   }
[09:31:11.822]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.822]                     cond$call), session = sessionInformation(), 
[09:31:11.822]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.822]                   signalCondition(cond)
[09:31:11.822]                 }
[09:31:11.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.822]                 "immediateCondition"))) {
[09:31:11.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.822]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.822]                   if (TRUE && !signal) {
[09:31:11.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.822]                     {
[09:31:11.822]                       inherits <- base::inherits
[09:31:11.822]                       invokeRestart <- base::invokeRestart
[09:31:11.822]                       is.null <- base::is.null
[09:31:11.822]                       muffled <- FALSE
[09:31:11.822]                       if (inherits(cond, "message")) {
[09:31:11.822]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.822]                         if (muffled) 
[09:31:11.822]                           invokeRestart("muffleMessage")
[09:31:11.822]                       }
[09:31:11.822]                       else if (inherits(cond, "warning")) {
[09:31:11.822]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.822]                         if (muffled) 
[09:31:11.822]                           invokeRestart("muffleWarning")
[09:31:11.822]                       }
[09:31:11.822]                       else if (inherits(cond, "condition")) {
[09:31:11.822]                         if (!is.null(pattern)) {
[09:31:11.822]                           computeRestarts <- base::computeRestarts
[09:31:11.822]                           grepl <- base::grepl
[09:31:11.822]                           restarts <- computeRestarts(cond)
[09:31:11.822]                           for (restart in restarts) {
[09:31:11.822]                             name <- restart$name
[09:31:11.822]                             if (is.null(name)) 
[09:31:11.822]                               next
[09:31:11.822]                             if (!grepl(pattern, name)) 
[09:31:11.822]                               next
[09:31:11.822]                             invokeRestart(restart)
[09:31:11.822]                             muffled <- TRUE
[09:31:11.822]                             break
[09:31:11.822]                           }
[09:31:11.822]                         }
[09:31:11.822]                       }
[09:31:11.822]                       invisible(muffled)
[09:31:11.822]                     }
[09:31:11.822]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.822]                   }
[09:31:11.822]                 }
[09:31:11.822]                 else {
[09:31:11.822]                   if (TRUE) {
[09:31:11.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.822]                     {
[09:31:11.822]                       inherits <- base::inherits
[09:31:11.822]                       invokeRestart <- base::invokeRestart
[09:31:11.822]                       is.null <- base::is.null
[09:31:11.822]                       muffled <- FALSE
[09:31:11.822]                       if (inherits(cond, "message")) {
[09:31:11.822]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.822]                         if (muffled) 
[09:31:11.822]                           invokeRestart("muffleMessage")
[09:31:11.822]                       }
[09:31:11.822]                       else if (inherits(cond, "warning")) {
[09:31:11.822]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.822]                         if (muffled) 
[09:31:11.822]                           invokeRestart("muffleWarning")
[09:31:11.822]                       }
[09:31:11.822]                       else if (inherits(cond, "condition")) {
[09:31:11.822]                         if (!is.null(pattern)) {
[09:31:11.822]                           computeRestarts <- base::computeRestarts
[09:31:11.822]                           grepl <- base::grepl
[09:31:11.822]                           restarts <- computeRestarts(cond)
[09:31:11.822]                           for (restart in restarts) {
[09:31:11.822]                             name <- restart$name
[09:31:11.822]                             if (is.null(name)) 
[09:31:11.822]                               next
[09:31:11.822]                             if (!grepl(pattern, name)) 
[09:31:11.822]                               next
[09:31:11.822]                             invokeRestart(restart)
[09:31:11.822]                             muffled <- TRUE
[09:31:11.822]                             break
[09:31:11.822]                           }
[09:31:11.822]                         }
[09:31:11.822]                       }
[09:31:11.822]                       invisible(muffled)
[09:31:11.822]                     }
[09:31:11.822]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.822]                   }
[09:31:11.822]                 }
[09:31:11.822]             }
[09:31:11.822]         }))
[09:31:11.822]     }, error = function(ex) {
[09:31:11.822]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.822]                 ...future.rng), started = ...future.startTime, 
[09:31:11.822]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.822]             version = "1.8"), class = "FutureResult")
[09:31:11.822]     }, finally = {
[09:31:11.822]         if (!identical(...future.workdir, getwd())) 
[09:31:11.822]             setwd(...future.workdir)
[09:31:11.822]         {
[09:31:11.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.822]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.822]             }
[09:31:11.822]             base::options(...future.oldOptions)
[09:31:11.822]             if (.Platform$OS.type == "windows") {
[09:31:11.822]                 old_names <- names(...future.oldEnvVars)
[09:31:11.822]                 envs <- base::Sys.getenv()
[09:31:11.822]                 names <- names(envs)
[09:31:11.822]                 common <- intersect(names, old_names)
[09:31:11.822]                 added <- setdiff(names, old_names)
[09:31:11.822]                 removed <- setdiff(old_names, names)
[09:31:11.822]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.822]                   envs[common]]
[09:31:11.822]                 NAMES <- toupper(changed)
[09:31:11.822]                 args <- list()
[09:31:11.822]                 for (kk in seq_along(NAMES)) {
[09:31:11.822]                   name <- changed[[kk]]
[09:31:11.822]                   NAME <- NAMES[[kk]]
[09:31:11.822]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.822]                     next
[09:31:11.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.822]                 }
[09:31:11.822]                 NAMES <- toupper(added)
[09:31:11.822]                 for (kk in seq_along(NAMES)) {
[09:31:11.822]                   name <- added[[kk]]
[09:31:11.822]                   NAME <- NAMES[[kk]]
[09:31:11.822]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.822]                     next
[09:31:11.822]                   args[[name]] <- ""
[09:31:11.822]                 }
[09:31:11.822]                 NAMES <- toupper(removed)
[09:31:11.822]                 for (kk in seq_along(NAMES)) {
[09:31:11.822]                   name <- removed[[kk]]
[09:31:11.822]                   NAME <- NAMES[[kk]]
[09:31:11.822]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.822]                     next
[09:31:11.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.822]                 }
[09:31:11.822]                 if (length(args) > 0) 
[09:31:11.822]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.822]             }
[09:31:11.822]             else {
[09:31:11.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.822]             }
[09:31:11.822]             {
[09:31:11.822]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.822]                   0L) {
[09:31:11.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.822]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.822]                   base::options(opts)
[09:31:11.822]                 }
[09:31:11.822]                 {
[09:31:11.822]                   {
[09:31:11.822]                     NULL
[09:31:11.822]                     RNGkind("Mersenne-Twister")
[09:31:11.822]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.822]                       inherits = FALSE)
[09:31:11.822]                   }
[09:31:11.822]                   options(future.plan = NULL)
[09:31:11.822]                   if (is.na(NA_character_)) 
[09:31:11.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.822]                     .init = FALSE)
[09:31:11.822]                 }
[09:31:11.822]             }
[09:31:11.822]         }
[09:31:11.822]     })
[09:31:11.822]     if (TRUE) {
[09:31:11.822]         base::sink(type = "output", split = FALSE)
[09:31:11.822]         if (TRUE) {
[09:31:11.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.822]         }
[09:31:11.822]         else {
[09:31:11.822]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.822]         }
[09:31:11.822]         base::close(...future.stdout)
[09:31:11.822]         ...future.stdout <- NULL
[09:31:11.822]     }
[09:31:11.822]     ...future.result$conditions <- ...future.conditions
[09:31:11.822]     ...future.result$finished <- base::Sys.time()
[09:31:11.822]     ...future.result
[09:31:11.822] }
[09:31:11.823] plan(): Setting new future strategy stack:
[09:31:11.823] List of future strategies:
[09:31:11.823] 1. sequential:
[09:31:11.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.823]    - tweaked: FALSE
[09:31:11.823]    - call: NULL
[09:31:11.824] plan(): nbrOfWorkers() = 1
[09:31:11.825] plan(): Setting new future strategy stack:
[09:31:11.825] List of future strategies:
[09:31:11.825] 1. sequential:
[09:31:11.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.825]    - tweaked: FALSE
[09:31:11.825]    - call: plan(strategy)
[09:31:11.825] plan(): nbrOfWorkers() = 1
[09:31:11.825] SequentialFuture started (and completed)
[09:31:11.825] - Launch lazy future ... done
[09:31:11.825] run() for ‘SequentialFuture’ ... done
[09:31:11.826] getGlobalsAndPackages() ...
[09:31:11.826] Searching for globals...
[09:31:11.826] - globals found: [1] ‘{’
[09:31:11.826] Searching for globals ... DONE
[09:31:11.826] Resolving globals: FALSE
[09:31:11.827] 
[09:31:11.827] 
[09:31:11.827] getGlobalsAndPackages() ... DONE
[09:31:11.827] run() for ‘Future’ ...
[09:31:11.827] - state: ‘created’
[09:31:11.827] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.828]   - Field: ‘label’
[09:31:11.828]   - Field: ‘local’
[09:31:11.828]   - Field: ‘owner’
[09:31:11.828]   - Field: ‘envir’
[09:31:11.828]   - Field: ‘packages’
[09:31:11.828]   - Field: ‘gc’
[09:31:11.828]   - Field: ‘conditions’
[09:31:11.828]   - Field: ‘expr’
[09:31:11.828]   - Field: ‘uuid’
[09:31:11.828]   - Field: ‘seed’
[09:31:11.829]   - Field: ‘version’
[09:31:11.829]   - Field: ‘result’
[09:31:11.829]   - Field: ‘asynchronous’
[09:31:11.829]   - Field: ‘calls’
[09:31:11.829]   - Field: ‘globals’
[09:31:11.829]   - Field: ‘stdout’
[09:31:11.829]   - Field: ‘earlySignal’
[09:31:11.829]   - Field: ‘lazy’
[09:31:11.829]   - Field: ‘state’
[09:31:11.829] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.829] - Launch lazy future ...
[09:31:11.830] Packages needed by the future expression (n = 0): <none>
[09:31:11.830] Packages needed by future strategies (n = 0): <none>
[09:31:11.830] {
[09:31:11.830]     {
[09:31:11.830]         {
[09:31:11.830]             ...future.startTime <- base::Sys.time()
[09:31:11.830]             {
[09:31:11.830]                 {
[09:31:11.830]                   {
[09:31:11.830]                     base::local({
[09:31:11.830]                       has_future <- base::requireNamespace("future", 
[09:31:11.830]                         quietly = TRUE)
[09:31:11.830]                       if (has_future) {
[09:31:11.830]                         ns <- base::getNamespace("future")
[09:31:11.830]                         version <- ns[[".package"]][["version"]]
[09:31:11.830]                         if (is.null(version)) 
[09:31:11.830]                           version <- utils::packageVersion("future")
[09:31:11.830]                       }
[09:31:11.830]                       else {
[09:31:11.830]                         version <- NULL
[09:31:11.830]                       }
[09:31:11.830]                       if (!has_future || version < "1.8.0") {
[09:31:11.830]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.830]                           "", base::R.version$version.string), 
[09:31:11.830]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.830]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.830]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.830]                             "release", "version")], collapse = " "), 
[09:31:11.830]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.830]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.830]                           info)
[09:31:11.830]                         info <- base::paste(info, collapse = "; ")
[09:31:11.830]                         if (!has_future) {
[09:31:11.830]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.830]                             info)
[09:31:11.830]                         }
[09:31:11.830]                         else {
[09:31:11.830]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.830]                             info, version)
[09:31:11.830]                         }
[09:31:11.830]                         base::stop(msg)
[09:31:11.830]                       }
[09:31:11.830]                     })
[09:31:11.830]                   }
[09:31:11.830]                   ...future.strategy.old <- future::plan("list")
[09:31:11.830]                   options(future.plan = NULL)
[09:31:11.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.830]                 }
[09:31:11.830]                 ...future.workdir <- getwd()
[09:31:11.830]             }
[09:31:11.830]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.830]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.830]         }
[09:31:11.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.830]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.830]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.830]             base::names(...future.oldOptions))
[09:31:11.830]     }
[09:31:11.830]     if (FALSE) {
[09:31:11.830]     }
[09:31:11.830]     else {
[09:31:11.830]         if (TRUE) {
[09:31:11.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.830]                 open = "w")
[09:31:11.830]         }
[09:31:11.830]         else {
[09:31:11.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.830]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.830]         }
[09:31:11.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.830]             base::sink(type = "output", split = FALSE)
[09:31:11.830]             base::close(...future.stdout)
[09:31:11.830]         }, add = TRUE)
[09:31:11.830]     }
[09:31:11.830]     ...future.frame <- base::sys.nframe()
[09:31:11.830]     ...future.conditions <- base::list()
[09:31:11.830]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.830]     if (FALSE) {
[09:31:11.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.830]     }
[09:31:11.830]     ...future.result <- base::tryCatch({
[09:31:11.830]         base::withCallingHandlers({
[09:31:11.830]             ...future.value <- base::withVisible(base::local({
[09:31:11.830]                 4
[09:31:11.830]             }))
[09:31:11.830]             future::FutureResult(value = ...future.value$value, 
[09:31:11.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.830]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.830]                     ...future.globalenv.names))
[09:31:11.830]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.830]         }, condition = base::local({
[09:31:11.830]             c <- base::c
[09:31:11.830]             inherits <- base::inherits
[09:31:11.830]             invokeRestart <- base::invokeRestart
[09:31:11.830]             length <- base::length
[09:31:11.830]             list <- base::list
[09:31:11.830]             seq.int <- base::seq.int
[09:31:11.830]             signalCondition <- base::signalCondition
[09:31:11.830]             sys.calls <- base::sys.calls
[09:31:11.830]             `[[` <- base::`[[`
[09:31:11.830]             `+` <- base::`+`
[09:31:11.830]             `<<-` <- base::`<<-`
[09:31:11.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.830]                   3L)]
[09:31:11.830]             }
[09:31:11.830]             function(cond) {
[09:31:11.830]                 is_error <- inherits(cond, "error")
[09:31:11.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.830]                   NULL)
[09:31:11.830]                 if (is_error) {
[09:31:11.830]                   sessionInformation <- function() {
[09:31:11.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.830]                       search = base::search(), system = base::Sys.info())
[09:31:11.830]                   }
[09:31:11.830]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.830]                     cond$call), session = sessionInformation(), 
[09:31:11.830]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.830]                   signalCondition(cond)
[09:31:11.830]                 }
[09:31:11.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.830]                 "immediateCondition"))) {
[09:31:11.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.830]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.830]                   if (TRUE && !signal) {
[09:31:11.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.830]                     {
[09:31:11.830]                       inherits <- base::inherits
[09:31:11.830]                       invokeRestart <- base::invokeRestart
[09:31:11.830]                       is.null <- base::is.null
[09:31:11.830]                       muffled <- FALSE
[09:31:11.830]                       if (inherits(cond, "message")) {
[09:31:11.830]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.830]                         if (muffled) 
[09:31:11.830]                           invokeRestart("muffleMessage")
[09:31:11.830]                       }
[09:31:11.830]                       else if (inherits(cond, "warning")) {
[09:31:11.830]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.830]                         if (muffled) 
[09:31:11.830]                           invokeRestart("muffleWarning")
[09:31:11.830]                       }
[09:31:11.830]                       else if (inherits(cond, "condition")) {
[09:31:11.830]                         if (!is.null(pattern)) {
[09:31:11.830]                           computeRestarts <- base::computeRestarts
[09:31:11.830]                           grepl <- base::grepl
[09:31:11.830]                           restarts <- computeRestarts(cond)
[09:31:11.830]                           for (restart in restarts) {
[09:31:11.830]                             name <- restart$name
[09:31:11.830]                             if (is.null(name)) 
[09:31:11.830]                               next
[09:31:11.830]                             if (!grepl(pattern, name)) 
[09:31:11.830]                               next
[09:31:11.830]                             invokeRestart(restart)
[09:31:11.830]                             muffled <- TRUE
[09:31:11.830]                             break
[09:31:11.830]                           }
[09:31:11.830]                         }
[09:31:11.830]                       }
[09:31:11.830]                       invisible(muffled)
[09:31:11.830]                     }
[09:31:11.830]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.830]                   }
[09:31:11.830]                 }
[09:31:11.830]                 else {
[09:31:11.830]                   if (TRUE) {
[09:31:11.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.830]                     {
[09:31:11.830]                       inherits <- base::inherits
[09:31:11.830]                       invokeRestart <- base::invokeRestart
[09:31:11.830]                       is.null <- base::is.null
[09:31:11.830]                       muffled <- FALSE
[09:31:11.830]                       if (inherits(cond, "message")) {
[09:31:11.830]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.830]                         if (muffled) 
[09:31:11.830]                           invokeRestart("muffleMessage")
[09:31:11.830]                       }
[09:31:11.830]                       else if (inherits(cond, "warning")) {
[09:31:11.830]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.830]                         if (muffled) 
[09:31:11.830]                           invokeRestart("muffleWarning")
[09:31:11.830]                       }
[09:31:11.830]                       else if (inherits(cond, "condition")) {
[09:31:11.830]                         if (!is.null(pattern)) {
[09:31:11.830]                           computeRestarts <- base::computeRestarts
[09:31:11.830]                           grepl <- base::grepl
[09:31:11.830]                           restarts <- computeRestarts(cond)
[09:31:11.830]                           for (restart in restarts) {
[09:31:11.830]                             name <- restart$name
[09:31:11.830]                             if (is.null(name)) 
[09:31:11.830]                               next
[09:31:11.830]                             if (!grepl(pattern, name)) 
[09:31:11.830]                               next
[09:31:11.830]                             invokeRestart(restart)
[09:31:11.830]                             muffled <- TRUE
[09:31:11.830]                             break
[09:31:11.830]                           }
[09:31:11.830]                         }
[09:31:11.830]                       }
[09:31:11.830]                       invisible(muffled)
[09:31:11.830]                     }
[09:31:11.830]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.830]                   }
[09:31:11.830]                 }
[09:31:11.830]             }
[09:31:11.830]         }))
[09:31:11.830]     }, error = function(ex) {
[09:31:11.830]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.830]                 ...future.rng), started = ...future.startTime, 
[09:31:11.830]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.830]             version = "1.8"), class = "FutureResult")
[09:31:11.830]     }, finally = {
[09:31:11.830]         if (!identical(...future.workdir, getwd())) 
[09:31:11.830]             setwd(...future.workdir)
[09:31:11.830]         {
[09:31:11.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.830]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.830]             }
[09:31:11.830]             base::options(...future.oldOptions)
[09:31:11.830]             if (.Platform$OS.type == "windows") {
[09:31:11.830]                 old_names <- names(...future.oldEnvVars)
[09:31:11.830]                 envs <- base::Sys.getenv()
[09:31:11.830]                 names <- names(envs)
[09:31:11.830]                 common <- intersect(names, old_names)
[09:31:11.830]                 added <- setdiff(names, old_names)
[09:31:11.830]                 removed <- setdiff(old_names, names)
[09:31:11.830]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.830]                   envs[common]]
[09:31:11.830]                 NAMES <- toupper(changed)
[09:31:11.830]                 args <- list()
[09:31:11.830]                 for (kk in seq_along(NAMES)) {
[09:31:11.830]                   name <- changed[[kk]]
[09:31:11.830]                   NAME <- NAMES[[kk]]
[09:31:11.830]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.830]                     next
[09:31:11.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.830]                 }
[09:31:11.830]                 NAMES <- toupper(added)
[09:31:11.830]                 for (kk in seq_along(NAMES)) {
[09:31:11.830]                   name <- added[[kk]]
[09:31:11.830]                   NAME <- NAMES[[kk]]
[09:31:11.830]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.830]                     next
[09:31:11.830]                   args[[name]] <- ""
[09:31:11.830]                 }
[09:31:11.830]                 NAMES <- toupper(removed)
[09:31:11.830]                 for (kk in seq_along(NAMES)) {
[09:31:11.830]                   name <- removed[[kk]]
[09:31:11.830]                   NAME <- NAMES[[kk]]
[09:31:11.830]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.830]                     next
[09:31:11.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.830]                 }
[09:31:11.830]                 if (length(args) > 0) 
[09:31:11.830]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.830]             }
[09:31:11.830]             else {
[09:31:11.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.830]             }
[09:31:11.830]             {
[09:31:11.830]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.830]                   0L) {
[09:31:11.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.830]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.830]                   base::options(opts)
[09:31:11.830]                 }
[09:31:11.830]                 {
[09:31:11.830]                   {
[09:31:11.830]                     NULL
[09:31:11.830]                     RNGkind("Mersenne-Twister")
[09:31:11.830]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.830]                       inherits = FALSE)
[09:31:11.830]                   }
[09:31:11.830]                   options(future.plan = NULL)
[09:31:11.830]                   if (is.na(NA_character_)) 
[09:31:11.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.830]                     .init = FALSE)
[09:31:11.830]                 }
[09:31:11.830]             }
[09:31:11.830]         }
[09:31:11.830]     })
[09:31:11.830]     if (TRUE) {
[09:31:11.830]         base::sink(type = "output", split = FALSE)
[09:31:11.830]         if (TRUE) {
[09:31:11.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.830]         }
[09:31:11.830]         else {
[09:31:11.830]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.830]         }
[09:31:11.830]         base::close(...future.stdout)
[09:31:11.830]         ...future.stdout <- NULL
[09:31:11.830]     }
[09:31:11.830]     ...future.result$conditions <- ...future.conditions
[09:31:11.830]     ...future.result$finished <- base::Sys.time()
[09:31:11.830]     ...future.result
[09:31:11.830] }
[09:31:11.832] plan(): Setting new future strategy stack:
[09:31:11.832] List of future strategies:
[09:31:11.832] 1. sequential:
[09:31:11.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.832]    - tweaked: FALSE
[09:31:11.832]    - call: NULL
[09:31:11.832] plan(): nbrOfWorkers() = 1
[09:31:11.833] plan(): Setting new future strategy stack:
[09:31:11.833] List of future strategies:
[09:31:11.833] 1. sequential:
[09:31:11.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.833]    - tweaked: FALSE
[09:31:11.833]    - call: plan(strategy)
[09:31:11.833] plan(): nbrOfWorkers() = 1
[09:31:11.833] SequentialFuture started (and completed)
[09:31:11.834] - Launch lazy future ... done
[09:31:11.834] run() for ‘SequentialFuture’ ... done
<environment: 0x55a3caef0ba0> 
<environment: 0x55a3cace31a0> 
[09:31:11.835] resolved() for ‘SequentialFuture’ ...
[09:31:11.835] - state: ‘finished’
[09:31:11.835] - run: TRUE
[09:31:11.835] - result: ‘FutureResult’
[09:31:11.835] resolved() for ‘SequentialFuture’ ... done
[09:31:11.835] resolved() for ‘SequentialFuture’ ...
[09:31:11.835] - state: ‘finished’
[09:31:11.835] - run: TRUE
[09:31:11.835] - result: ‘FutureResult’
[09:31:11.836] resolved() for ‘SequentialFuture’ ... done
[09:31:11.836] resolved() for ‘SequentialFuture’ ...
[09:31:11.836] - state: ‘finished’
[09:31:11.836] - run: TRUE
[09:31:11.836] - result: ‘FutureResult’
[09:31:11.836] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:11.837] resolve() on environment ...
[09:31:11.837]  recursive: 0
[09:31:11.838]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:11.838] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.838] - nx: 4
[09:31:11.838] - relay: TRUE
[09:31:11.838] - stdout: TRUE
[09:31:11.838] - signal: TRUE
[09:31:11.838] - resignal: FALSE
[09:31:11.838] - force: TRUE
[09:31:11.838] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.838] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.838]  - until=2
[09:31:11.838]  - relaying element #2
[09:31:11.839] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.839] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.839] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.839]  length: 3 (resolved future 1)
[09:31:11.839] resolved() for ‘SequentialFuture’ ...
[09:31:11.839] - state: ‘finished’
[09:31:11.839] - run: TRUE
[09:31:11.839] - result: ‘FutureResult’
[09:31:11.839] resolved() for ‘SequentialFuture’ ... done
[09:31:11.839] Future #2
[09:31:11.839] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.840] - nx: 4
[09:31:11.840] - relay: TRUE
[09:31:11.840] - stdout: TRUE
[09:31:11.840] - signal: TRUE
[09:31:11.840] - resignal: FALSE
[09:31:11.840] - force: TRUE
[09:31:11.840] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.840] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.840]  - until=2
[09:31:11.840]  - relaying element #2
[09:31:11.840] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.840] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.841] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.841]  length: 2 (resolved future 2)
[09:31:11.841] resolved() for ‘SequentialFuture’ ...
[09:31:11.841] - state: ‘finished’
[09:31:11.841] - run: TRUE
[09:31:11.841] - result: ‘FutureResult’
[09:31:11.841] resolved() for ‘SequentialFuture’ ... done
[09:31:11.841] Future #3
[09:31:11.841] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.841] - nx: 4
[09:31:11.841] - relay: TRUE
[09:31:11.842] - stdout: TRUE
[09:31:11.842] - signal: TRUE
[09:31:11.842] - resignal: FALSE
[09:31:11.842] - force: TRUE
[09:31:11.843] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.843] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.843]  - until=3
[09:31:11.843]  - relaying element #3
[09:31:11.843] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.843] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.844] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.844]  length: 1 (resolved future 3)
[09:31:11.844] resolved() for ‘SequentialFuture’ ...
[09:31:11.844] - state: ‘finished’
[09:31:11.844] - run: TRUE
[09:31:11.844] - result: ‘FutureResult’
[09:31:11.844] resolved() for ‘SequentialFuture’ ... done
[09:31:11.844] Future #4
[09:31:11.844] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.844] - nx: 4
[09:31:11.844] - relay: TRUE
[09:31:11.845] - stdout: TRUE
[09:31:11.845] - signal: TRUE
[09:31:11.845] - resignal: FALSE
[09:31:11.845] - force: TRUE
[09:31:11.845] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.845] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.845]  - until=4
[09:31:11.845]  - relaying element #4
[09:31:11.845] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.845] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.845] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.846]  length: 0 (resolved future 4)
[09:31:11.846] Relaying remaining futures
[09:31:11.846] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.846] - nx: 4
[09:31:11.846] - relay: TRUE
[09:31:11.846] - stdout: TRUE
[09:31:11.846] - signal: TRUE
[09:31:11.846] - resignal: FALSE
[09:31:11.846] - force: TRUE
[09:31:11.846] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.846] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:11.846] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.847] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.847] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.847] resolve() on environment ... DONE
<environment: 0x55a3cae803a8> 
Dimensions: c(2, 1, 3, 1)
[09:31:11.847] getGlobalsAndPackages() ...
[09:31:11.847] Searching for globals...
[09:31:11.848] 
[09:31:11.848] Searching for globals ... DONE
[09:31:11.848] - globals: [0] <none>
[09:31:11.848] getGlobalsAndPackages() ... DONE
[09:31:11.848] run() for ‘Future’ ...
[09:31:11.848] - state: ‘created’
[09:31:11.848] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.848] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.849]   - Field: ‘label’
[09:31:11.849]   - Field: ‘local’
[09:31:11.849]   - Field: ‘owner’
[09:31:11.849]   - Field: ‘envir’
[09:31:11.849]   - Field: ‘packages’
[09:31:11.849]   - Field: ‘gc’
[09:31:11.849]   - Field: ‘conditions’
[09:31:11.849]   - Field: ‘expr’
[09:31:11.849]   - Field: ‘uuid’
[09:31:11.849]   - Field: ‘seed’
[09:31:11.850]   - Field: ‘version’
[09:31:11.850]   - Field: ‘result’
[09:31:11.850]   - Field: ‘asynchronous’
[09:31:11.850]   - Field: ‘calls’
[09:31:11.850]   - Field: ‘globals’
[09:31:11.850]   - Field: ‘stdout’
[09:31:11.850]   - Field: ‘earlySignal’
[09:31:11.850]   - Field: ‘lazy’
[09:31:11.850]   - Field: ‘state’
[09:31:11.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.850] - Launch lazy future ...
[09:31:11.851] Packages needed by the future expression (n = 0): <none>
[09:31:11.851] Packages needed by future strategies (n = 0): <none>
[09:31:11.851] {
[09:31:11.851]     {
[09:31:11.851]         {
[09:31:11.851]             ...future.startTime <- base::Sys.time()
[09:31:11.851]             {
[09:31:11.851]                 {
[09:31:11.851]                   {
[09:31:11.851]                     base::local({
[09:31:11.851]                       has_future <- base::requireNamespace("future", 
[09:31:11.851]                         quietly = TRUE)
[09:31:11.851]                       if (has_future) {
[09:31:11.851]                         ns <- base::getNamespace("future")
[09:31:11.851]                         version <- ns[[".package"]][["version"]]
[09:31:11.851]                         if (is.null(version)) 
[09:31:11.851]                           version <- utils::packageVersion("future")
[09:31:11.851]                       }
[09:31:11.851]                       else {
[09:31:11.851]                         version <- NULL
[09:31:11.851]                       }
[09:31:11.851]                       if (!has_future || version < "1.8.0") {
[09:31:11.851]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.851]                           "", base::R.version$version.string), 
[09:31:11.851]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.851]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.851]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.851]                             "release", "version")], collapse = " "), 
[09:31:11.851]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.851]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.851]                           info)
[09:31:11.851]                         info <- base::paste(info, collapse = "; ")
[09:31:11.851]                         if (!has_future) {
[09:31:11.851]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.851]                             info)
[09:31:11.851]                         }
[09:31:11.851]                         else {
[09:31:11.851]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.851]                             info, version)
[09:31:11.851]                         }
[09:31:11.851]                         base::stop(msg)
[09:31:11.851]                       }
[09:31:11.851]                     })
[09:31:11.851]                   }
[09:31:11.851]                   ...future.strategy.old <- future::plan("list")
[09:31:11.851]                   options(future.plan = NULL)
[09:31:11.851]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.851]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.851]                 }
[09:31:11.851]                 ...future.workdir <- getwd()
[09:31:11.851]             }
[09:31:11.851]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.851]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.851]         }
[09:31:11.851]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.851]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.851]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.851]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.851]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.851]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.851]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.851]             base::names(...future.oldOptions))
[09:31:11.851]     }
[09:31:11.851]     if (FALSE) {
[09:31:11.851]     }
[09:31:11.851]     else {
[09:31:11.851]         if (TRUE) {
[09:31:11.851]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.851]                 open = "w")
[09:31:11.851]         }
[09:31:11.851]         else {
[09:31:11.851]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.851]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.851]         }
[09:31:11.851]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.851]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.851]             base::sink(type = "output", split = FALSE)
[09:31:11.851]             base::close(...future.stdout)
[09:31:11.851]         }, add = TRUE)
[09:31:11.851]     }
[09:31:11.851]     ...future.frame <- base::sys.nframe()
[09:31:11.851]     ...future.conditions <- base::list()
[09:31:11.851]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.851]     if (FALSE) {
[09:31:11.851]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.851]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.851]     }
[09:31:11.851]     ...future.result <- base::tryCatch({
[09:31:11.851]         base::withCallingHandlers({
[09:31:11.851]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.851]             future::FutureResult(value = ...future.value$value, 
[09:31:11.851]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.851]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.851]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.851]                     ...future.globalenv.names))
[09:31:11.851]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.851]         }, condition = base::local({
[09:31:11.851]             c <- base::c
[09:31:11.851]             inherits <- base::inherits
[09:31:11.851]             invokeRestart <- base::invokeRestart
[09:31:11.851]             length <- base::length
[09:31:11.851]             list <- base::list
[09:31:11.851]             seq.int <- base::seq.int
[09:31:11.851]             signalCondition <- base::signalCondition
[09:31:11.851]             sys.calls <- base::sys.calls
[09:31:11.851]             `[[` <- base::`[[`
[09:31:11.851]             `+` <- base::`+`
[09:31:11.851]             `<<-` <- base::`<<-`
[09:31:11.851]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.851]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.851]                   3L)]
[09:31:11.851]             }
[09:31:11.851]             function(cond) {
[09:31:11.851]                 is_error <- inherits(cond, "error")
[09:31:11.851]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.851]                   NULL)
[09:31:11.851]                 if (is_error) {
[09:31:11.851]                   sessionInformation <- function() {
[09:31:11.851]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.851]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.851]                       search = base::search(), system = base::Sys.info())
[09:31:11.851]                   }
[09:31:11.851]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.851]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.851]                     cond$call), session = sessionInformation(), 
[09:31:11.851]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.851]                   signalCondition(cond)
[09:31:11.851]                 }
[09:31:11.851]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.851]                 "immediateCondition"))) {
[09:31:11.851]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.851]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.851]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.851]                   if (TRUE && !signal) {
[09:31:11.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.851]                     {
[09:31:11.851]                       inherits <- base::inherits
[09:31:11.851]                       invokeRestart <- base::invokeRestart
[09:31:11.851]                       is.null <- base::is.null
[09:31:11.851]                       muffled <- FALSE
[09:31:11.851]                       if (inherits(cond, "message")) {
[09:31:11.851]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.851]                         if (muffled) 
[09:31:11.851]                           invokeRestart("muffleMessage")
[09:31:11.851]                       }
[09:31:11.851]                       else if (inherits(cond, "warning")) {
[09:31:11.851]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.851]                         if (muffled) 
[09:31:11.851]                           invokeRestart("muffleWarning")
[09:31:11.851]                       }
[09:31:11.851]                       else if (inherits(cond, "condition")) {
[09:31:11.851]                         if (!is.null(pattern)) {
[09:31:11.851]                           computeRestarts <- base::computeRestarts
[09:31:11.851]                           grepl <- base::grepl
[09:31:11.851]                           restarts <- computeRestarts(cond)
[09:31:11.851]                           for (restart in restarts) {
[09:31:11.851]                             name <- restart$name
[09:31:11.851]                             if (is.null(name)) 
[09:31:11.851]                               next
[09:31:11.851]                             if (!grepl(pattern, name)) 
[09:31:11.851]                               next
[09:31:11.851]                             invokeRestart(restart)
[09:31:11.851]                             muffled <- TRUE
[09:31:11.851]                             break
[09:31:11.851]                           }
[09:31:11.851]                         }
[09:31:11.851]                       }
[09:31:11.851]                       invisible(muffled)
[09:31:11.851]                     }
[09:31:11.851]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.851]                   }
[09:31:11.851]                 }
[09:31:11.851]                 else {
[09:31:11.851]                   if (TRUE) {
[09:31:11.851]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.851]                     {
[09:31:11.851]                       inherits <- base::inherits
[09:31:11.851]                       invokeRestart <- base::invokeRestart
[09:31:11.851]                       is.null <- base::is.null
[09:31:11.851]                       muffled <- FALSE
[09:31:11.851]                       if (inherits(cond, "message")) {
[09:31:11.851]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.851]                         if (muffled) 
[09:31:11.851]                           invokeRestart("muffleMessage")
[09:31:11.851]                       }
[09:31:11.851]                       else if (inherits(cond, "warning")) {
[09:31:11.851]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.851]                         if (muffled) 
[09:31:11.851]                           invokeRestart("muffleWarning")
[09:31:11.851]                       }
[09:31:11.851]                       else if (inherits(cond, "condition")) {
[09:31:11.851]                         if (!is.null(pattern)) {
[09:31:11.851]                           computeRestarts <- base::computeRestarts
[09:31:11.851]                           grepl <- base::grepl
[09:31:11.851]                           restarts <- computeRestarts(cond)
[09:31:11.851]                           for (restart in restarts) {
[09:31:11.851]                             name <- restart$name
[09:31:11.851]                             if (is.null(name)) 
[09:31:11.851]                               next
[09:31:11.851]                             if (!grepl(pattern, name)) 
[09:31:11.851]                               next
[09:31:11.851]                             invokeRestart(restart)
[09:31:11.851]                             muffled <- TRUE
[09:31:11.851]                             break
[09:31:11.851]                           }
[09:31:11.851]                         }
[09:31:11.851]                       }
[09:31:11.851]                       invisible(muffled)
[09:31:11.851]                     }
[09:31:11.851]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.851]                   }
[09:31:11.851]                 }
[09:31:11.851]             }
[09:31:11.851]         }))
[09:31:11.851]     }, error = function(ex) {
[09:31:11.851]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.851]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.851]                 ...future.rng), started = ...future.startTime, 
[09:31:11.851]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.851]             version = "1.8"), class = "FutureResult")
[09:31:11.851]     }, finally = {
[09:31:11.851]         if (!identical(...future.workdir, getwd())) 
[09:31:11.851]             setwd(...future.workdir)
[09:31:11.851]         {
[09:31:11.851]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.851]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.851]             }
[09:31:11.851]             base::options(...future.oldOptions)
[09:31:11.851]             if (.Platform$OS.type == "windows") {
[09:31:11.851]                 old_names <- names(...future.oldEnvVars)
[09:31:11.851]                 envs <- base::Sys.getenv()
[09:31:11.851]                 names <- names(envs)
[09:31:11.851]                 common <- intersect(names, old_names)
[09:31:11.851]                 added <- setdiff(names, old_names)
[09:31:11.851]                 removed <- setdiff(old_names, names)
[09:31:11.851]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.851]                   envs[common]]
[09:31:11.851]                 NAMES <- toupper(changed)
[09:31:11.851]                 args <- list()
[09:31:11.851]                 for (kk in seq_along(NAMES)) {
[09:31:11.851]                   name <- changed[[kk]]
[09:31:11.851]                   NAME <- NAMES[[kk]]
[09:31:11.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.851]                     next
[09:31:11.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.851]                 }
[09:31:11.851]                 NAMES <- toupper(added)
[09:31:11.851]                 for (kk in seq_along(NAMES)) {
[09:31:11.851]                   name <- added[[kk]]
[09:31:11.851]                   NAME <- NAMES[[kk]]
[09:31:11.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.851]                     next
[09:31:11.851]                   args[[name]] <- ""
[09:31:11.851]                 }
[09:31:11.851]                 NAMES <- toupper(removed)
[09:31:11.851]                 for (kk in seq_along(NAMES)) {
[09:31:11.851]                   name <- removed[[kk]]
[09:31:11.851]                   NAME <- NAMES[[kk]]
[09:31:11.851]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.851]                     next
[09:31:11.851]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.851]                 }
[09:31:11.851]                 if (length(args) > 0) 
[09:31:11.851]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.851]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.851]             }
[09:31:11.851]             else {
[09:31:11.851]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.851]             }
[09:31:11.851]             {
[09:31:11.851]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.851]                   0L) {
[09:31:11.851]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.851]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.851]                   base::options(opts)
[09:31:11.851]                 }
[09:31:11.851]                 {
[09:31:11.851]                   {
[09:31:11.851]                     NULL
[09:31:11.851]                     RNGkind("Mersenne-Twister")
[09:31:11.851]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.851]                       inherits = FALSE)
[09:31:11.851]                   }
[09:31:11.851]                   options(future.plan = NULL)
[09:31:11.851]                   if (is.na(NA_character_)) 
[09:31:11.851]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.851]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.851]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.851]                     .init = FALSE)
[09:31:11.851]                 }
[09:31:11.851]             }
[09:31:11.851]         }
[09:31:11.851]     })
[09:31:11.851]     if (TRUE) {
[09:31:11.851]         base::sink(type = "output", split = FALSE)
[09:31:11.851]         if (TRUE) {
[09:31:11.851]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.851]         }
[09:31:11.851]         else {
[09:31:11.851]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.851]         }
[09:31:11.851]         base::close(...future.stdout)
[09:31:11.851]         ...future.stdout <- NULL
[09:31:11.851]     }
[09:31:11.851]     ...future.result$conditions <- ...future.conditions
[09:31:11.851]     ...future.result$finished <- base::Sys.time()
[09:31:11.851]     ...future.result
[09:31:11.851] }
[09:31:11.853] plan(): Setting new future strategy stack:
[09:31:11.853] List of future strategies:
[09:31:11.853] 1. sequential:
[09:31:11.853]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.853]    - tweaked: FALSE
[09:31:11.853]    - call: NULL
[09:31:11.853] plan(): nbrOfWorkers() = 1
[09:31:11.854] plan(): Setting new future strategy stack:
[09:31:11.854] List of future strategies:
[09:31:11.854] 1. sequential:
[09:31:11.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.854]    - tweaked: FALSE
[09:31:11.854]    - call: plan(strategy)
[09:31:11.854] plan(): nbrOfWorkers() = 1
[09:31:11.854] SequentialFuture started (and completed)
[09:31:11.855] - Launch lazy future ... done
[09:31:11.855] run() for ‘SequentialFuture’ ... done
[09:31:11.855] getGlobalsAndPackages() ...
[09:31:11.855] Searching for globals...
[09:31:11.855] 
[09:31:11.855] Searching for globals ... DONE
[09:31:11.855] - globals: [0] <none>
[09:31:11.855] getGlobalsAndPackages() ... DONE
[09:31:11.856] run() for ‘Future’ ...
[09:31:11.856] - state: ‘created’
[09:31:11.856] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.856] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.856]   - Field: ‘label’
[09:31:11.856]   - Field: ‘local’
[09:31:11.856]   - Field: ‘owner’
[09:31:11.857]   - Field: ‘envir’
[09:31:11.857]   - Field: ‘packages’
[09:31:11.857]   - Field: ‘gc’
[09:31:11.857]   - Field: ‘conditions’
[09:31:11.857]   - Field: ‘expr’
[09:31:11.857]   - Field: ‘uuid’
[09:31:11.857]   - Field: ‘seed’
[09:31:11.857]   - Field: ‘version’
[09:31:11.857]   - Field: ‘result’
[09:31:11.857]   - Field: ‘asynchronous’
[09:31:11.857]   - Field: ‘calls’
[09:31:11.858]   - Field: ‘globals’
[09:31:11.858]   - Field: ‘stdout’
[09:31:11.858]   - Field: ‘earlySignal’
[09:31:11.858]   - Field: ‘lazy’
[09:31:11.858]   - Field: ‘state’
[09:31:11.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.858] - Launch lazy future ...
[09:31:11.858] Packages needed by the future expression (n = 0): <none>
[09:31:11.858] Packages needed by future strategies (n = 0): <none>
[09:31:11.859] {
[09:31:11.859]     {
[09:31:11.859]         {
[09:31:11.859]             ...future.startTime <- base::Sys.time()
[09:31:11.859]             {
[09:31:11.859]                 {
[09:31:11.859]                   {
[09:31:11.859]                     base::local({
[09:31:11.859]                       has_future <- base::requireNamespace("future", 
[09:31:11.859]                         quietly = TRUE)
[09:31:11.859]                       if (has_future) {
[09:31:11.859]                         ns <- base::getNamespace("future")
[09:31:11.859]                         version <- ns[[".package"]][["version"]]
[09:31:11.859]                         if (is.null(version)) 
[09:31:11.859]                           version <- utils::packageVersion("future")
[09:31:11.859]                       }
[09:31:11.859]                       else {
[09:31:11.859]                         version <- NULL
[09:31:11.859]                       }
[09:31:11.859]                       if (!has_future || version < "1.8.0") {
[09:31:11.859]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.859]                           "", base::R.version$version.string), 
[09:31:11.859]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.859]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.859]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.859]                             "release", "version")], collapse = " "), 
[09:31:11.859]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.859]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.859]                           info)
[09:31:11.859]                         info <- base::paste(info, collapse = "; ")
[09:31:11.859]                         if (!has_future) {
[09:31:11.859]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.859]                             info)
[09:31:11.859]                         }
[09:31:11.859]                         else {
[09:31:11.859]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.859]                             info, version)
[09:31:11.859]                         }
[09:31:11.859]                         base::stop(msg)
[09:31:11.859]                       }
[09:31:11.859]                     })
[09:31:11.859]                   }
[09:31:11.859]                   ...future.strategy.old <- future::plan("list")
[09:31:11.859]                   options(future.plan = NULL)
[09:31:11.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.859]                 }
[09:31:11.859]                 ...future.workdir <- getwd()
[09:31:11.859]             }
[09:31:11.859]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.859]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.859]         }
[09:31:11.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.859]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.859]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.859]             base::names(...future.oldOptions))
[09:31:11.859]     }
[09:31:11.859]     if (FALSE) {
[09:31:11.859]     }
[09:31:11.859]     else {
[09:31:11.859]         if (TRUE) {
[09:31:11.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.859]                 open = "w")
[09:31:11.859]         }
[09:31:11.859]         else {
[09:31:11.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.859]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.859]         }
[09:31:11.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.859]             base::sink(type = "output", split = FALSE)
[09:31:11.859]             base::close(...future.stdout)
[09:31:11.859]         }, add = TRUE)
[09:31:11.859]     }
[09:31:11.859]     ...future.frame <- base::sys.nframe()
[09:31:11.859]     ...future.conditions <- base::list()
[09:31:11.859]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.859]     if (FALSE) {
[09:31:11.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.859]     }
[09:31:11.859]     ...future.result <- base::tryCatch({
[09:31:11.859]         base::withCallingHandlers({
[09:31:11.859]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.859]             future::FutureResult(value = ...future.value$value, 
[09:31:11.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.859]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.859]                     ...future.globalenv.names))
[09:31:11.859]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.859]         }, condition = base::local({
[09:31:11.859]             c <- base::c
[09:31:11.859]             inherits <- base::inherits
[09:31:11.859]             invokeRestart <- base::invokeRestart
[09:31:11.859]             length <- base::length
[09:31:11.859]             list <- base::list
[09:31:11.859]             seq.int <- base::seq.int
[09:31:11.859]             signalCondition <- base::signalCondition
[09:31:11.859]             sys.calls <- base::sys.calls
[09:31:11.859]             `[[` <- base::`[[`
[09:31:11.859]             `+` <- base::`+`
[09:31:11.859]             `<<-` <- base::`<<-`
[09:31:11.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.859]                   3L)]
[09:31:11.859]             }
[09:31:11.859]             function(cond) {
[09:31:11.859]                 is_error <- inherits(cond, "error")
[09:31:11.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.859]                   NULL)
[09:31:11.859]                 if (is_error) {
[09:31:11.859]                   sessionInformation <- function() {
[09:31:11.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.859]                       search = base::search(), system = base::Sys.info())
[09:31:11.859]                   }
[09:31:11.859]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.859]                     cond$call), session = sessionInformation(), 
[09:31:11.859]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.859]                   signalCondition(cond)
[09:31:11.859]                 }
[09:31:11.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.859]                 "immediateCondition"))) {
[09:31:11.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.859]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.859]                   if (TRUE && !signal) {
[09:31:11.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.859]                     {
[09:31:11.859]                       inherits <- base::inherits
[09:31:11.859]                       invokeRestart <- base::invokeRestart
[09:31:11.859]                       is.null <- base::is.null
[09:31:11.859]                       muffled <- FALSE
[09:31:11.859]                       if (inherits(cond, "message")) {
[09:31:11.859]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.859]                         if (muffled) 
[09:31:11.859]                           invokeRestart("muffleMessage")
[09:31:11.859]                       }
[09:31:11.859]                       else if (inherits(cond, "warning")) {
[09:31:11.859]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.859]                         if (muffled) 
[09:31:11.859]                           invokeRestart("muffleWarning")
[09:31:11.859]                       }
[09:31:11.859]                       else if (inherits(cond, "condition")) {
[09:31:11.859]                         if (!is.null(pattern)) {
[09:31:11.859]                           computeRestarts <- base::computeRestarts
[09:31:11.859]                           grepl <- base::grepl
[09:31:11.859]                           restarts <- computeRestarts(cond)
[09:31:11.859]                           for (restart in restarts) {
[09:31:11.859]                             name <- restart$name
[09:31:11.859]                             if (is.null(name)) 
[09:31:11.859]                               next
[09:31:11.859]                             if (!grepl(pattern, name)) 
[09:31:11.859]                               next
[09:31:11.859]                             invokeRestart(restart)
[09:31:11.859]                             muffled <- TRUE
[09:31:11.859]                             break
[09:31:11.859]                           }
[09:31:11.859]                         }
[09:31:11.859]                       }
[09:31:11.859]                       invisible(muffled)
[09:31:11.859]                     }
[09:31:11.859]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.859]                   }
[09:31:11.859]                 }
[09:31:11.859]                 else {
[09:31:11.859]                   if (TRUE) {
[09:31:11.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.859]                     {
[09:31:11.859]                       inherits <- base::inherits
[09:31:11.859]                       invokeRestart <- base::invokeRestart
[09:31:11.859]                       is.null <- base::is.null
[09:31:11.859]                       muffled <- FALSE
[09:31:11.859]                       if (inherits(cond, "message")) {
[09:31:11.859]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.859]                         if (muffled) 
[09:31:11.859]                           invokeRestart("muffleMessage")
[09:31:11.859]                       }
[09:31:11.859]                       else if (inherits(cond, "warning")) {
[09:31:11.859]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.859]                         if (muffled) 
[09:31:11.859]                           invokeRestart("muffleWarning")
[09:31:11.859]                       }
[09:31:11.859]                       else if (inherits(cond, "condition")) {
[09:31:11.859]                         if (!is.null(pattern)) {
[09:31:11.859]                           computeRestarts <- base::computeRestarts
[09:31:11.859]                           grepl <- base::grepl
[09:31:11.859]                           restarts <- computeRestarts(cond)
[09:31:11.859]                           for (restart in restarts) {
[09:31:11.859]                             name <- restart$name
[09:31:11.859]                             if (is.null(name)) 
[09:31:11.859]                               next
[09:31:11.859]                             if (!grepl(pattern, name)) 
[09:31:11.859]                               next
[09:31:11.859]                             invokeRestart(restart)
[09:31:11.859]                             muffled <- TRUE
[09:31:11.859]                             break
[09:31:11.859]                           }
[09:31:11.859]                         }
[09:31:11.859]                       }
[09:31:11.859]                       invisible(muffled)
[09:31:11.859]                     }
[09:31:11.859]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.859]                   }
[09:31:11.859]                 }
[09:31:11.859]             }
[09:31:11.859]         }))
[09:31:11.859]     }, error = function(ex) {
[09:31:11.859]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.859]                 ...future.rng), started = ...future.startTime, 
[09:31:11.859]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.859]             version = "1.8"), class = "FutureResult")
[09:31:11.859]     }, finally = {
[09:31:11.859]         if (!identical(...future.workdir, getwd())) 
[09:31:11.859]             setwd(...future.workdir)
[09:31:11.859]         {
[09:31:11.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.859]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.859]             }
[09:31:11.859]             base::options(...future.oldOptions)
[09:31:11.859]             if (.Platform$OS.type == "windows") {
[09:31:11.859]                 old_names <- names(...future.oldEnvVars)
[09:31:11.859]                 envs <- base::Sys.getenv()
[09:31:11.859]                 names <- names(envs)
[09:31:11.859]                 common <- intersect(names, old_names)
[09:31:11.859]                 added <- setdiff(names, old_names)
[09:31:11.859]                 removed <- setdiff(old_names, names)
[09:31:11.859]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.859]                   envs[common]]
[09:31:11.859]                 NAMES <- toupper(changed)
[09:31:11.859]                 args <- list()
[09:31:11.859]                 for (kk in seq_along(NAMES)) {
[09:31:11.859]                   name <- changed[[kk]]
[09:31:11.859]                   NAME <- NAMES[[kk]]
[09:31:11.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.859]                     next
[09:31:11.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.859]                 }
[09:31:11.859]                 NAMES <- toupper(added)
[09:31:11.859]                 for (kk in seq_along(NAMES)) {
[09:31:11.859]                   name <- added[[kk]]
[09:31:11.859]                   NAME <- NAMES[[kk]]
[09:31:11.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.859]                     next
[09:31:11.859]                   args[[name]] <- ""
[09:31:11.859]                 }
[09:31:11.859]                 NAMES <- toupper(removed)
[09:31:11.859]                 for (kk in seq_along(NAMES)) {
[09:31:11.859]                   name <- removed[[kk]]
[09:31:11.859]                   NAME <- NAMES[[kk]]
[09:31:11.859]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.859]                     next
[09:31:11.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.859]                 }
[09:31:11.859]                 if (length(args) > 0) 
[09:31:11.859]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.859]             }
[09:31:11.859]             else {
[09:31:11.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.859]             }
[09:31:11.859]             {
[09:31:11.859]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.859]                   0L) {
[09:31:11.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.859]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.859]                   base::options(opts)
[09:31:11.859]                 }
[09:31:11.859]                 {
[09:31:11.859]                   {
[09:31:11.859]                     NULL
[09:31:11.859]                     RNGkind("Mersenne-Twister")
[09:31:11.859]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.859]                       inherits = FALSE)
[09:31:11.859]                   }
[09:31:11.859]                   options(future.plan = NULL)
[09:31:11.859]                   if (is.na(NA_character_)) 
[09:31:11.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.859]                     .init = FALSE)
[09:31:11.859]                 }
[09:31:11.859]             }
[09:31:11.859]         }
[09:31:11.859]     })
[09:31:11.859]     if (TRUE) {
[09:31:11.859]         base::sink(type = "output", split = FALSE)
[09:31:11.859]         if (TRUE) {
[09:31:11.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.859]         }
[09:31:11.859]         else {
[09:31:11.859]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.859]         }
[09:31:11.859]         base::close(...future.stdout)
[09:31:11.859]         ...future.stdout <- NULL
[09:31:11.859]     }
[09:31:11.859]     ...future.result$conditions <- ...future.conditions
[09:31:11.859]     ...future.result$finished <- base::Sys.time()
[09:31:11.859]     ...future.result
[09:31:11.859] }
[09:31:11.860] plan(): Setting new future strategy stack:
[09:31:11.860] List of future strategies:
[09:31:11.860] 1. sequential:
[09:31:11.860]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.860]    - tweaked: FALSE
[09:31:11.860]    - call: NULL
[09:31:11.861] plan(): nbrOfWorkers() = 1
[09:31:11.861] plan(): Setting new future strategy stack:
[09:31:11.862] List of future strategies:
[09:31:11.862] 1. sequential:
[09:31:11.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.862]    - tweaked: FALSE
[09:31:11.862]    - call: plan(strategy)
[09:31:11.862] plan(): nbrOfWorkers() = 1
[09:31:11.862] SequentialFuture started (and completed)
[09:31:11.862] - Launch lazy future ... done
[09:31:11.862] run() for ‘SequentialFuture’ ... done
[09:31:11.863] getGlobalsAndPackages() ...
[09:31:11.863] Searching for globals...
[09:31:11.863] - globals found: [1] ‘{’
[09:31:11.863] Searching for globals ... DONE
[09:31:11.863] Resolving globals: FALSE
[09:31:11.864] 
[09:31:11.864] 
[09:31:11.864] getGlobalsAndPackages() ... DONE
[09:31:11.864] run() for ‘Future’ ...
[09:31:11.864] - state: ‘created’
[09:31:11.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.864] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.865]   - Field: ‘label’
[09:31:11.865]   - Field: ‘local’
[09:31:11.865]   - Field: ‘owner’
[09:31:11.865]   - Field: ‘envir’
[09:31:11.865]   - Field: ‘packages’
[09:31:11.865]   - Field: ‘gc’
[09:31:11.865]   - Field: ‘conditions’
[09:31:11.865]   - Field: ‘expr’
[09:31:11.865]   - Field: ‘uuid’
[09:31:11.865]   - Field: ‘seed’
[09:31:11.865]   - Field: ‘version’
[09:31:11.866]   - Field: ‘result’
[09:31:11.866]   - Field: ‘asynchronous’
[09:31:11.866]   - Field: ‘calls’
[09:31:11.866]   - Field: ‘globals’
[09:31:11.866]   - Field: ‘stdout’
[09:31:11.866]   - Field: ‘earlySignal’
[09:31:11.866]   - Field: ‘lazy’
[09:31:11.866]   - Field: ‘state’
[09:31:11.866] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.866] - Launch lazy future ...
[09:31:11.866] Packages needed by the future expression (n = 0): <none>
[09:31:11.867] Packages needed by future strategies (n = 0): <none>
[09:31:11.867] {
[09:31:11.867]     {
[09:31:11.867]         {
[09:31:11.867]             ...future.startTime <- base::Sys.time()
[09:31:11.867]             {
[09:31:11.867]                 {
[09:31:11.867]                   {
[09:31:11.867]                     base::local({
[09:31:11.867]                       has_future <- base::requireNamespace("future", 
[09:31:11.867]                         quietly = TRUE)
[09:31:11.867]                       if (has_future) {
[09:31:11.867]                         ns <- base::getNamespace("future")
[09:31:11.867]                         version <- ns[[".package"]][["version"]]
[09:31:11.867]                         if (is.null(version)) 
[09:31:11.867]                           version <- utils::packageVersion("future")
[09:31:11.867]                       }
[09:31:11.867]                       else {
[09:31:11.867]                         version <- NULL
[09:31:11.867]                       }
[09:31:11.867]                       if (!has_future || version < "1.8.0") {
[09:31:11.867]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.867]                           "", base::R.version$version.string), 
[09:31:11.867]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.867]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.867]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.867]                             "release", "version")], collapse = " "), 
[09:31:11.867]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.867]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.867]                           info)
[09:31:11.867]                         info <- base::paste(info, collapse = "; ")
[09:31:11.867]                         if (!has_future) {
[09:31:11.867]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.867]                             info)
[09:31:11.867]                         }
[09:31:11.867]                         else {
[09:31:11.867]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.867]                             info, version)
[09:31:11.867]                         }
[09:31:11.867]                         base::stop(msg)
[09:31:11.867]                       }
[09:31:11.867]                     })
[09:31:11.867]                   }
[09:31:11.867]                   ...future.strategy.old <- future::plan("list")
[09:31:11.867]                   options(future.plan = NULL)
[09:31:11.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.867]                 }
[09:31:11.867]                 ...future.workdir <- getwd()
[09:31:11.867]             }
[09:31:11.867]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.867]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.867]         }
[09:31:11.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.867]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.867]             base::names(...future.oldOptions))
[09:31:11.867]     }
[09:31:11.867]     if (FALSE) {
[09:31:11.867]     }
[09:31:11.867]     else {
[09:31:11.867]         if (TRUE) {
[09:31:11.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.867]                 open = "w")
[09:31:11.867]         }
[09:31:11.867]         else {
[09:31:11.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.867]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.867]         }
[09:31:11.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.867]             base::sink(type = "output", split = FALSE)
[09:31:11.867]             base::close(...future.stdout)
[09:31:11.867]         }, add = TRUE)
[09:31:11.867]     }
[09:31:11.867]     ...future.frame <- base::sys.nframe()
[09:31:11.867]     ...future.conditions <- base::list()
[09:31:11.867]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.867]     if (FALSE) {
[09:31:11.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.867]     }
[09:31:11.867]     ...future.result <- base::tryCatch({
[09:31:11.867]         base::withCallingHandlers({
[09:31:11.867]             ...future.value <- base::withVisible(base::local({
[09:31:11.867]                 4
[09:31:11.867]             }))
[09:31:11.867]             future::FutureResult(value = ...future.value$value, 
[09:31:11.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.867]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.867]                     ...future.globalenv.names))
[09:31:11.867]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.867]         }, condition = base::local({
[09:31:11.867]             c <- base::c
[09:31:11.867]             inherits <- base::inherits
[09:31:11.867]             invokeRestart <- base::invokeRestart
[09:31:11.867]             length <- base::length
[09:31:11.867]             list <- base::list
[09:31:11.867]             seq.int <- base::seq.int
[09:31:11.867]             signalCondition <- base::signalCondition
[09:31:11.867]             sys.calls <- base::sys.calls
[09:31:11.867]             `[[` <- base::`[[`
[09:31:11.867]             `+` <- base::`+`
[09:31:11.867]             `<<-` <- base::`<<-`
[09:31:11.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.867]                   3L)]
[09:31:11.867]             }
[09:31:11.867]             function(cond) {
[09:31:11.867]                 is_error <- inherits(cond, "error")
[09:31:11.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.867]                   NULL)
[09:31:11.867]                 if (is_error) {
[09:31:11.867]                   sessionInformation <- function() {
[09:31:11.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.867]                       search = base::search(), system = base::Sys.info())
[09:31:11.867]                   }
[09:31:11.867]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.867]                     cond$call), session = sessionInformation(), 
[09:31:11.867]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.867]                   signalCondition(cond)
[09:31:11.867]                 }
[09:31:11.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.867]                 "immediateCondition"))) {
[09:31:11.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.867]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.867]                   if (TRUE && !signal) {
[09:31:11.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.867]                     {
[09:31:11.867]                       inherits <- base::inherits
[09:31:11.867]                       invokeRestart <- base::invokeRestart
[09:31:11.867]                       is.null <- base::is.null
[09:31:11.867]                       muffled <- FALSE
[09:31:11.867]                       if (inherits(cond, "message")) {
[09:31:11.867]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.867]                         if (muffled) 
[09:31:11.867]                           invokeRestart("muffleMessage")
[09:31:11.867]                       }
[09:31:11.867]                       else if (inherits(cond, "warning")) {
[09:31:11.867]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.867]                         if (muffled) 
[09:31:11.867]                           invokeRestart("muffleWarning")
[09:31:11.867]                       }
[09:31:11.867]                       else if (inherits(cond, "condition")) {
[09:31:11.867]                         if (!is.null(pattern)) {
[09:31:11.867]                           computeRestarts <- base::computeRestarts
[09:31:11.867]                           grepl <- base::grepl
[09:31:11.867]                           restarts <- computeRestarts(cond)
[09:31:11.867]                           for (restart in restarts) {
[09:31:11.867]                             name <- restart$name
[09:31:11.867]                             if (is.null(name)) 
[09:31:11.867]                               next
[09:31:11.867]                             if (!grepl(pattern, name)) 
[09:31:11.867]                               next
[09:31:11.867]                             invokeRestart(restart)
[09:31:11.867]                             muffled <- TRUE
[09:31:11.867]                             break
[09:31:11.867]                           }
[09:31:11.867]                         }
[09:31:11.867]                       }
[09:31:11.867]                       invisible(muffled)
[09:31:11.867]                     }
[09:31:11.867]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.867]                   }
[09:31:11.867]                 }
[09:31:11.867]                 else {
[09:31:11.867]                   if (TRUE) {
[09:31:11.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.867]                     {
[09:31:11.867]                       inherits <- base::inherits
[09:31:11.867]                       invokeRestart <- base::invokeRestart
[09:31:11.867]                       is.null <- base::is.null
[09:31:11.867]                       muffled <- FALSE
[09:31:11.867]                       if (inherits(cond, "message")) {
[09:31:11.867]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.867]                         if (muffled) 
[09:31:11.867]                           invokeRestart("muffleMessage")
[09:31:11.867]                       }
[09:31:11.867]                       else if (inherits(cond, "warning")) {
[09:31:11.867]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.867]                         if (muffled) 
[09:31:11.867]                           invokeRestart("muffleWarning")
[09:31:11.867]                       }
[09:31:11.867]                       else if (inherits(cond, "condition")) {
[09:31:11.867]                         if (!is.null(pattern)) {
[09:31:11.867]                           computeRestarts <- base::computeRestarts
[09:31:11.867]                           grepl <- base::grepl
[09:31:11.867]                           restarts <- computeRestarts(cond)
[09:31:11.867]                           for (restart in restarts) {
[09:31:11.867]                             name <- restart$name
[09:31:11.867]                             if (is.null(name)) 
[09:31:11.867]                               next
[09:31:11.867]                             if (!grepl(pattern, name)) 
[09:31:11.867]                               next
[09:31:11.867]                             invokeRestart(restart)
[09:31:11.867]                             muffled <- TRUE
[09:31:11.867]                             break
[09:31:11.867]                           }
[09:31:11.867]                         }
[09:31:11.867]                       }
[09:31:11.867]                       invisible(muffled)
[09:31:11.867]                     }
[09:31:11.867]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.867]                   }
[09:31:11.867]                 }
[09:31:11.867]             }
[09:31:11.867]         }))
[09:31:11.867]     }, error = function(ex) {
[09:31:11.867]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.867]                 ...future.rng), started = ...future.startTime, 
[09:31:11.867]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.867]             version = "1.8"), class = "FutureResult")
[09:31:11.867]     }, finally = {
[09:31:11.867]         if (!identical(...future.workdir, getwd())) 
[09:31:11.867]             setwd(...future.workdir)
[09:31:11.867]         {
[09:31:11.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.867]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.867]             }
[09:31:11.867]             base::options(...future.oldOptions)
[09:31:11.867]             if (.Platform$OS.type == "windows") {
[09:31:11.867]                 old_names <- names(...future.oldEnvVars)
[09:31:11.867]                 envs <- base::Sys.getenv()
[09:31:11.867]                 names <- names(envs)
[09:31:11.867]                 common <- intersect(names, old_names)
[09:31:11.867]                 added <- setdiff(names, old_names)
[09:31:11.867]                 removed <- setdiff(old_names, names)
[09:31:11.867]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.867]                   envs[common]]
[09:31:11.867]                 NAMES <- toupper(changed)
[09:31:11.867]                 args <- list()
[09:31:11.867]                 for (kk in seq_along(NAMES)) {
[09:31:11.867]                   name <- changed[[kk]]
[09:31:11.867]                   NAME <- NAMES[[kk]]
[09:31:11.867]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.867]                     next
[09:31:11.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.867]                 }
[09:31:11.867]                 NAMES <- toupper(added)
[09:31:11.867]                 for (kk in seq_along(NAMES)) {
[09:31:11.867]                   name <- added[[kk]]
[09:31:11.867]                   NAME <- NAMES[[kk]]
[09:31:11.867]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.867]                     next
[09:31:11.867]                   args[[name]] <- ""
[09:31:11.867]                 }
[09:31:11.867]                 NAMES <- toupper(removed)
[09:31:11.867]                 for (kk in seq_along(NAMES)) {
[09:31:11.867]                   name <- removed[[kk]]
[09:31:11.867]                   NAME <- NAMES[[kk]]
[09:31:11.867]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.867]                     next
[09:31:11.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.867]                 }
[09:31:11.867]                 if (length(args) > 0) 
[09:31:11.867]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.867]             }
[09:31:11.867]             else {
[09:31:11.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.867]             }
[09:31:11.867]             {
[09:31:11.867]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.867]                   0L) {
[09:31:11.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.867]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.867]                   base::options(opts)
[09:31:11.867]                 }
[09:31:11.867]                 {
[09:31:11.867]                   {
[09:31:11.867]                     NULL
[09:31:11.867]                     RNGkind("Mersenne-Twister")
[09:31:11.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.867]                       inherits = FALSE)
[09:31:11.867]                   }
[09:31:11.867]                   options(future.plan = NULL)
[09:31:11.867]                   if (is.na(NA_character_)) 
[09:31:11.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.867]                     .init = FALSE)
[09:31:11.867]                 }
[09:31:11.867]             }
[09:31:11.867]         }
[09:31:11.867]     })
[09:31:11.867]     if (TRUE) {
[09:31:11.867]         base::sink(type = "output", split = FALSE)
[09:31:11.867]         if (TRUE) {
[09:31:11.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.867]         }
[09:31:11.867]         else {
[09:31:11.867]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.867]         }
[09:31:11.867]         base::close(...future.stdout)
[09:31:11.867]         ...future.stdout <- NULL
[09:31:11.867]     }
[09:31:11.867]     ...future.result$conditions <- ...future.conditions
[09:31:11.867]     ...future.result$finished <- base::Sys.time()
[09:31:11.867]     ...future.result
[09:31:11.867] }
[09:31:11.869] plan(): Setting new future strategy stack:
[09:31:11.869] List of future strategies:
[09:31:11.869] 1. sequential:
[09:31:11.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.869]    - tweaked: FALSE
[09:31:11.869]    - call: NULL
[09:31:11.869] plan(): nbrOfWorkers() = 1
[09:31:11.871] plan(): Setting new future strategy stack:
[09:31:11.871] List of future strategies:
[09:31:11.871] 1. sequential:
[09:31:11.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.871]    - tweaked: FALSE
[09:31:11.871]    - call: plan(strategy)
[09:31:11.871] plan(): nbrOfWorkers() = 1
[09:31:11.872] SequentialFuture started (and completed)
[09:31:11.872] - Launch lazy future ... done
[09:31:11.872] run() for ‘SequentialFuture’ ... done
<environment: 0x55a3c88c6638> 
<environment: 0x55a3c942d530> 
[09:31:11.873] resolved() for ‘SequentialFuture’ ...
[09:31:11.873] - state: ‘finished’
[09:31:11.873] - run: TRUE
[09:31:11.873] - result: ‘FutureResult’
[09:31:11.873] resolved() for ‘SequentialFuture’ ... done
[09:31:11.873] resolved() for ‘SequentialFuture’ ...
[09:31:11.874] - state: ‘finished’
[09:31:11.874] - run: TRUE
[09:31:11.874] - result: ‘FutureResult’
[09:31:11.874] resolved() for ‘SequentialFuture’ ... done
[09:31:11.874] resolved() for ‘SequentialFuture’ ...
[09:31:11.874] - state: ‘finished’
[09:31:11.874] - run: TRUE
[09:31:11.874] - result: ‘FutureResult’
[09:31:11.874] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:11.875] resolve() on environment ...
[09:31:11.875]  recursive: 0
[09:31:11.876]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:11.876] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.876] - nx: 4
[09:31:11.876] - relay: TRUE
[09:31:11.876] - stdout: TRUE
[09:31:11.876] - signal: TRUE
[09:31:11.876] - resignal: FALSE
[09:31:11.876] - force: TRUE
[09:31:11.876] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.877] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.877]  - until=2
[09:31:11.877]  - relaying element #2
[09:31:11.877] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.877] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.877] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.877]  length: 3 (resolved future 1)
[09:31:11.877] resolved() for ‘SequentialFuture’ ...
[09:31:11.877] - state: ‘finished’
[09:31:11.877] - run: TRUE
[09:31:11.877] - result: ‘FutureResult’
[09:31:11.877] resolved() for ‘SequentialFuture’ ... done
[09:31:11.878] Future #2
[09:31:11.878] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.878] - nx: 4
[09:31:11.878] - relay: TRUE
[09:31:11.878] - stdout: TRUE
[09:31:11.878] - signal: TRUE
[09:31:11.878] - resignal: FALSE
[09:31:11.878] - force: TRUE
[09:31:11.878] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:11.878] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:11.878]  - until=2
[09:31:11.878]  - relaying element #2
[09:31:11.879] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.879] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.879] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.879]  length: 2 (resolved future 2)
[09:31:11.879] resolved() for ‘SequentialFuture’ ...
[09:31:11.879] - state: ‘finished’
[09:31:11.879] - run: TRUE
[09:31:11.879] - result: ‘FutureResult’
[09:31:11.879] resolved() for ‘SequentialFuture’ ... done
[09:31:11.879] Future #3
[09:31:11.880] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.880] - nx: 4
[09:31:11.880] - relay: TRUE
[09:31:11.880] - stdout: TRUE
[09:31:11.880] - signal: TRUE
[09:31:11.880] - resignal: FALSE
[09:31:11.880] - force: TRUE
[09:31:11.880] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:11.880] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:11.880]  - until=3
[09:31:11.880]  - relaying element #3
[09:31:11.880] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.881] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.881] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.881]  length: 1 (resolved future 3)
[09:31:11.881] resolved() for ‘SequentialFuture’ ...
[09:31:11.881] - state: ‘finished’
[09:31:11.881] - run: TRUE
[09:31:11.881] - result: ‘FutureResult’
[09:31:11.881] resolved() for ‘SequentialFuture’ ... done
[09:31:11.881] Future #4
[09:31:11.881] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.881] - nx: 4
[09:31:11.882] - relay: TRUE
[09:31:11.882] - stdout: TRUE
[09:31:11.882] - signal: TRUE
[09:31:11.882] - resignal: FALSE
[09:31:11.882] - force: TRUE
[09:31:11.882] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:11.882] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:11.882]  - until=4
[09:31:11.882]  - relaying element #4
[09:31:11.882] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.882] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.882] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.883]  length: 0 (resolved future 4)
[09:31:11.883] Relaying remaining futures
[09:31:11.883] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.883] - nx: 4
[09:31:11.883] - relay: TRUE
[09:31:11.883] - stdout: TRUE
[09:31:11.883] - signal: TRUE
[09:31:11.883] - resignal: FALSE
[09:31:11.883] - force: TRUE
[09:31:11.883] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.883] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:11.883] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:11.884] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:11.884] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.884] resolve() on environment ... DONE
<environment: 0x55a3c892d0b0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[09:31:11.884] plan(): Setting new future strategy stack:
[09:31:11.885] List of future strategies:
[09:31:11.885] 1. sequential:
[09:31:11.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.885]    - tweaked: FALSE
[09:31:11.885]    - call: plan(strategy)
[09:31:11.885] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[09:31:11.885] getGlobalsAndPackages() ...
[09:31:11.885] Searching for globals...
[09:31:11.886] 
[09:31:11.886] Searching for globals ... DONE
[09:31:11.886] - globals: [0] <none>
[09:31:11.886] getGlobalsAndPackages() ... DONE
[09:31:11.886] run() for ‘Future’ ...
[09:31:11.886] - state: ‘created’
[09:31:11.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.887] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.887] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.887]   - Field: ‘label’
[09:31:11.887]   - Field: ‘local’
[09:31:11.887]   - Field: ‘owner’
[09:31:11.887]   - Field: ‘envir’
[09:31:11.887]   - Field: ‘packages’
[09:31:11.887]   - Field: ‘gc’
[09:31:11.887]   - Field: ‘conditions’
[09:31:11.887]   - Field: ‘expr’
[09:31:11.888]   - Field: ‘uuid’
[09:31:11.888]   - Field: ‘seed’
[09:31:11.888]   - Field: ‘version’
[09:31:11.888]   - Field: ‘result’
[09:31:11.888]   - Field: ‘asynchronous’
[09:31:11.888]   - Field: ‘calls’
[09:31:11.888]   - Field: ‘globals’
[09:31:11.888]   - Field: ‘stdout’
[09:31:11.888]   - Field: ‘earlySignal’
[09:31:11.888]   - Field: ‘lazy’
[09:31:11.888]   - Field: ‘state’
[09:31:11.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.889] - Launch lazy future ...
[09:31:11.889] Packages needed by the future expression (n = 0): <none>
[09:31:11.889] Packages needed by future strategies (n = 0): <none>
[09:31:11.889] {
[09:31:11.889]     {
[09:31:11.889]         {
[09:31:11.889]             ...future.startTime <- base::Sys.time()
[09:31:11.889]             {
[09:31:11.889]                 {
[09:31:11.889]                   {
[09:31:11.889]                     base::local({
[09:31:11.889]                       has_future <- base::requireNamespace("future", 
[09:31:11.889]                         quietly = TRUE)
[09:31:11.889]                       if (has_future) {
[09:31:11.889]                         ns <- base::getNamespace("future")
[09:31:11.889]                         version <- ns[[".package"]][["version"]]
[09:31:11.889]                         if (is.null(version)) 
[09:31:11.889]                           version <- utils::packageVersion("future")
[09:31:11.889]                       }
[09:31:11.889]                       else {
[09:31:11.889]                         version <- NULL
[09:31:11.889]                       }
[09:31:11.889]                       if (!has_future || version < "1.8.0") {
[09:31:11.889]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.889]                           "", base::R.version$version.string), 
[09:31:11.889]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.889]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.889]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.889]                             "release", "version")], collapse = " "), 
[09:31:11.889]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.889]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.889]                           info)
[09:31:11.889]                         info <- base::paste(info, collapse = "; ")
[09:31:11.889]                         if (!has_future) {
[09:31:11.889]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.889]                             info)
[09:31:11.889]                         }
[09:31:11.889]                         else {
[09:31:11.889]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.889]                             info, version)
[09:31:11.889]                         }
[09:31:11.889]                         base::stop(msg)
[09:31:11.889]                       }
[09:31:11.889]                     })
[09:31:11.889]                   }
[09:31:11.889]                   ...future.strategy.old <- future::plan("list")
[09:31:11.889]                   options(future.plan = NULL)
[09:31:11.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.889]                 }
[09:31:11.889]                 ...future.workdir <- getwd()
[09:31:11.889]             }
[09:31:11.889]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.889]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.889]         }
[09:31:11.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.889]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.889]             base::names(...future.oldOptions))
[09:31:11.889]     }
[09:31:11.889]     if (FALSE) {
[09:31:11.889]     }
[09:31:11.889]     else {
[09:31:11.889]         if (TRUE) {
[09:31:11.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.889]                 open = "w")
[09:31:11.889]         }
[09:31:11.889]         else {
[09:31:11.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.889]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.889]         }
[09:31:11.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.889]             base::sink(type = "output", split = FALSE)
[09:31:11.889]             base::close(...future.stdout)
[09:31:11.889]         }, add = TRUE)
[09:31:11.889]     }
[09:31:11.889]     ...future.frame <- base::sys.nframe()
[09:31:11.889]     ...future.conditions <- base::list()
[09:31:11.889]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.889]     if (FALSE) {
[09:31:11.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.889]     }
[09:31:11.889]     ...future.result <- base::tryCatch({
[09:31:11.889]         base::withCallingHandlers({
[09:31:11.889]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.889]             future::FutureResult(value = ...future.value$value, 
[09:31:11.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.889]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.889]                     ...future.globalenv.names))
[09:31:11.889]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.889]         }, condition = base::local({
[09:31:11.889]             c <- base::c
[09:31:11.889]             inherits <- base::inherits
[09:31:11.889]             invokeRestart <- base::invokeRestart
[09:31:11.889]             length <- base::length
[09:31:11.889]             list <- base::list
[09:31:11.889]             seq.int <- base::seq.int
[09:31:11.889]             signalCondition <- base::signalCondition
[09:31:11.889]             sys.calls <- base::sys.calls
[09:31:11.889]             `[[` <- base::`[[`
[09:31:11.889]             `+` <- base::`+`
[09:31:11.889]             `<<-` <- base::`<<-`
[09:31:11.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.889]                   3L)]
[09:31:11.889]             }
[09:31:11.889]             function(cond) {
[09:31:11.889]                 is_error <- inherits(cond, "error")
[09:31:11.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.889]                   NULL)
[09:31:11.889]                 if (is_error) {
[09:31:11.889]                   sessionInformation <- function() {
[09:31:11.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.889]                       search = base::search(), system = base::Sys.info())
[09:31:11.889]                   }
[09:31:11.889]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.889]                     cond$call), session = sessionInformation(), 
[09:31:11.889]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.889]                   signalCondition(cond)
[09:31:11.889]                 }
[09:31:11.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.889]                 "immediateCondition"))) {
[09:31:11.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.889]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.889]                   if (TRUE && !signal) {
[09:31:11.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.889]                     {
[09:31:11.889]                       inherits <- base::inherits
[09:31:11.889]                       invokeRestart <- base::invokeRestart
[09:31:11.889]                       is.null <- base::is.null
[09:31:11.889]                       muffled <- FALSE
[09:31:11.889]                       if (inherits(cond, "message")) {
[09:31:11.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.889]                         if (muffled) 
[09:31:11.889]                           invokeRestart("muffleMessage")
[09:31:11.889]                       }
[09:31:11.889]                       else if (inherits(cond, "warning")) {
[09:31:11.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.889]                         if (muffled) 
[09:31:11.889]                           invokeRestart("muffleWarning")
[09:31:11.889]                       }
[09:31:11.889]                       else if (inherits(cond, "condition")) {
[09:31:11.889]                         if (!is.null(pattern)) {
[09:31:11.889]                           computeRestarts <- base::computeRestarts
[09:31:11.889]                           grepl <- base::grepl
[09:31:11.889]                           restarts <- computeRestarts(cond)
[09:31:11.889]                           for (restart in restarts) {
[09:31:11.889]                             name <- restart$name
[09:31:11.889]                             if (is.null(name)) 
[09:31:11.889]                               next
[09:31:11.889]                             if (!grepl(pattern, name)) 
[09:31:11.889]                               next
[09:31:11.889]                             invokeRestart(restart)
[09:31:11.889]                             muffled <- TRUE
[09:31:11.889]                             break
[09:31:11.889]                           }
[09:31:11.889]                         }
[09:31:11.889]                       }
[09:31:11.889]                       invisible(muffled)
[09:31:11.889]                     }
[09:31:11.889]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.889]                   }
[09:31:11.889]                 }
[09:31:11.889]                 else {
[09:31:11.889]                   if (TRUE) {
[09:31:11.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.889]                     {
[09:31:11.889]                       inherits <- base::inherits
[09:31:11.889]                       invokeRestart <- base::invokeRestart
[09:31:11.889]                       is.null <- base::is.null
[09:31:11.889]                       muffled <- FALSE
[09:31:11.889]                       if (inherits(cond, "message")) {
[09:31:11.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.889]                         if (muffled) 
[09:31:11.889]                           invokeRestart("muffleMessage")
[09:31:11.889]                       }
[09:31:11.889]                       else if (inherits(cond, "warning")) {
[09:31:11.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.889]                         if (muffled) 
[09:31:11.889]                           invokeRestart("muffleWarning")
[09:31:11.889]                       }
[09:31:11.889]                       else if (inherits(cond, "condition")) {
[09:31:11.889]                         if (!is.null(pattern)) {
[09:31:11.889]                           computeRestarts <- base::computeRestarts
[09:31:11.889]                           grepl <- base::grepl
[09:31:11.889]                           restarts <- computeRestarts(cond)
[09:31:11.889]                           for (restart in restarts) {
[09:31:11.889]                             name <- restart$name
[09:31:11.889]                             if (is.null(name)) 
[09:31:11.889]                               next
[09:31:11.889]                             if (!grepl(pattern, name)) 
[09:31:11.889]                               next
[09:31:11.889]                             invokeRestart(restart)
[09:31:11.889]                             muffled <- TRUE
[09:31:11.889]                             break
[09:31:11.889]                           }
[09:31:11.889]                         }
[09:31:11.889]                       }
[09:31:11.889]                       invisible(muffled)
[09:31:11.889]                     }
[09:31:11.889]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.889]                   }
[09:31:11.889]                 }
[09:31:11.889]             }
[09:31:11.889]         }))
[09:31:11.889]     }, error = function(ex) {
[09:31:11.889]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.889]                 ...future.rng), started = ...future.startTime, 
[09:31:11.889]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.889]             version = "1.8"), class = "FutureResult")
[09:31:11.889]     }, finally = {
[09:31:11.889]         if (!identical(...future.workdir, getwd())) 
[09:31:11.889]             setwd(...future.workdir)
[09:31:11.889]         {
[09:31:11.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.889]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.889]             }
[09:31:11.889]             base::options(...future.oldOptions)
[09:31:11.889]             if (.Platform$OS.type == "windows") {
[09:31:11.889]                 old_names <- names(...future.oldEnvVars)
[09:31:11.889]                 envs <- base::Sys.getenv()
[09:31:11.889]                 names <- names(envs)
[09:31:11.889]                 common <- intersect(names, old_names)
[09:31:11.889]                 added <- setdiff(names, old_names)
[09:31:11.889]                 removed <- setdiff(old_names, names)
[09:31:11.889]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.889]                   envs[common]]
[09:31:11.889]                 NAMES <- toupper(changed)
[09:31:11.889]                 args <- list()
[09:31:11.889]                 for (kk in seq_along(NAMES)) {
[09:31:11.889]                   name <- changed[[kk]]
[09:31:11.889]                   NAME <- NAMES[[kk]]
[09:31:11.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.889]                     next
[09:31:11.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.889]                 }
[09:31:11.889]                 NAMES <- toupper(added)
[09:31:11.889]                 for (kk in seq_along(NAMES)) {
[09:31:11.889]                   name <- added[[kk]]
[09:31:11.889]                   NAME <- NAMES[[kk]]
[09:31:11.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.889]                     next
[09:31:11.889]                   args[[name]] <- ""
[09:31:11.889]                 }
[09:31:11.889]                 NAMES <- toupper(removed)
[09:31:11.889]                 for (kk in seq_along(NAMES)) {
[09:31:11.889]                   name <- removed[[kk]]
[09:31:11.889]                   NAME <- NAMES[[kk]]
[09:31:11.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.889]                     next
[09:31:11.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.889]                 }
[09:31:11.889]                 if (length(args) > 0) 
[09:31:11.889]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.889]             }
[09:31:11.889]             else {
[09:31:11.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.889]             }
[09:31:11.889]             {
[09:31:11.889]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.889]                   0L) {
[09:31:11.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.889]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.889]                   base::options(opts)
[09:31:11.889]                 }
[09:31:11.889]                 {
[09:31:11.889]                   {
[09:31:11.889]                     NULL
[09:31:11.889]                     RNGkind("Mersenne-Twister")
[09:31:11.889]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.889]                       inherits = FALSE)
[09:31:11.889]                   }
[09:31:11.889]                   options(future.plan = NULL)
[09:31:11.889]                   if (is.na(NA_character_)) 
[09:31:11.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.889]                     .init = FALSE)
[09:31:11.889]                 }
[09:31:11.889]             }
[09:31:11.889]         }
[09:31:11.889]     })
[09:31:11.889]     if (TRUE) {
[09:31:11.889]         base::sink(type = "output", split = FALSE)
[09:31:11.889]         if (TRUE) {
[09:31:11.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.889]         }
[09:31:11.889]         else {
[09:31:11.889]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.889]         }
[09:31:11.889]         base::close(...future.stdout)
[09:31:11.889]         ...future.stdout <- NULL
[09:31:11.889]     }
[09:31:11.889]     ...future.result$conditions <- ...future.conditions
[09:31:11.889]     ...future.result$finished <- base::Sys.time()
[09:31:11.889]     ...future.result
[09:31:11.889] }
[09:31:11.891] plan(): Setting new future strategy stack:
[09:31:11.891] List of future strategies:
[09:31:11.891] 1. sequential:
[09:31:11.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.891]    - tweaked: FALSE
[09:31:11.891]    - call: NULL
[09:31:11.891] plan(): nbrOfWorkers() = 1
[09:31:11.892] plan(): Setting new future strategy stack:
[09:31:11.892] List of future strategies:
[09:31:11.892] 1. sequential:
[09:31:11.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.892]    - tweaked: FALSE
[09:31:11.892]    - call: plan(strategy)
[09:31:11.892] plan(): nbrOfWorkers() = 1
[09:31:11.893] SequentialFuture started (and completed)
[09:31:11.893] - Launch lazy future ... done
[09:31:11.893] run() for ‘SequentialFuture’ ... done
[09:31:11.893] getGlobalsAndPackages() ...
[09:31:11.893] Searching for globals...
[09:31:11.893] 
[09:31:11.893] Searching for globals ... DONE
[09:31:11.893] - globals: [0] <none>
[09:31:11.894] getGlobalsAndPackages() ... DONE
[09:31:11.894] run() for ‘Future’ ...
[09:31:11.894] - state: ‘created’
[09:31:11.894] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.894] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.894]   - Field: ‘label’
[09:31:11.894]   - Field: ‘local’
[09:31:11.896]   - Field: ‘owner’
[09:31:11.896]   - Field: ‘envir’
[09:31:11.896]   - Field: ‘packages’
[09:31:11.896]   - Field: ‘gc’
[09:31:11.896]   - Field: ‘conditions’
[09:31:11.896]   - Field: ‘expr’
[09:31:11.896]   - Field: ‘uuid’
[09:31:11.896]   - Field: ‘seed’
[09:31:11.896]   - Field: ‘version’
[09:31:11.897]   - Field: ‘result’
[09:31:11.897]   - Field: ‘asynchronous’
[09:31:11.897]   - Field: ‘calls’
[09:31:11.897]   - Field: ‘globals’
[09:31:11.897]   - Field: ‘stdout’
[09:31:11.897]   - Field: ‘earlySignal’
[09:31:11.897]   - Field: ‘lazy’
[09:31:11.897]   - Field: ‘state’
[09:31:11.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.897] - Launch lazy future ...
[09:31:11.897] Packages needed by the future expression (n = 0): <none>
[09:31:11.898] Packages needed by future strategies (n = 0): <none>
[09:31:11.898] {
[09:31:11.898]     {
[09:31:11.898]         {
[09:31:11.898]             ...future.startTime <- base::Sys.time()
[09:31:11.898]             {
[09:31:11.898]                 {
[09:31:11.898]                   {
[09:31:11.898]                     base::local({
[09:31:11.898]                       has_future <- base::requireNamespace("future", 
[09:31:11.898]                         quietly = TRUE)
[09:31:11.898]                       if (has_future) {
[09:31:11.898]                         ns <- base::getNamespace("future")
[09:31:11.898]                         version <- ns[[".package"]][["version"]]
[09:31:11.898]                         if (is.null(version)) 
[09:31:11.898]                           version <- utils::packageVersion("future")
[09:31:11.898]                       }
[09:31:11.898]                       else {
[09:31:11.898]                         version <- NULL
[09:31:11.898]                       }
[09:31:11.898]                       if (!has_future || version < "1.8.0") {
[09:31:11.898]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.898]                           "", base::R.version$version.string), 
[09:31:11.898]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.898]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.898]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.898]                             "release", "version")], collapse = " "), 
[09:31:11.898]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.898]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.898]                           info)
[09:31:11.898]                         info <- base::paste(info, collapse = "; ")
[09:31:11.898]                         if (!has_future) {
[09:31:11.898]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.898]                             info)
[09:31:11.898]                         }
[09:31:11.898]                         else {
[09:31:11.898]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.898]                             info, version)
[09:31:11.898]                         }
[09:31:11.898]                         base::stop(msg)
[09:31:11.898]                       }
[09:31:11.898]                     })
[09:31:11.898]                   }
[09:31:11.898]                   ...future.strategy.old <- future::plan("list")
[09:31:11.898]                   options(future.plan = NULL)
[09:31:11.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.898]                 }
[09:31:11.898]                 ...future.workdir <- getwd()
[09:31:11.898]             }
[09:31:11.898]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.898]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.898]         }
[09:31:11.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.898]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.898]             base::names(...future.oldOptions))
[09:31:11.898]     }
[09:31:11.898]     if (FALSE) {
[09:31:11.898]     }
[09:31:11.898]     else {
[09:31:11.898]         if (TRUE) {
[09:31:11.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.898]                 open = "w")
[09:31:11.898]         }
[09:31:11.898]         else {
[09:31:11.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.898]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.898]         }
[09:31:11.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.898]             base::sink(type = "output", split = FALSE)
[09:31:11.898]             base::close(...future.stdout)
[09:31:11.898]         }, add = TRUE)
[09:31:11.898]     }
[09:31:11.898]     ...future.frame <- base::sys.nframe()
[09:31:11.898]     ...future.conditions <- base::list()
[09:31:11.898]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.898]     if (FALSE) {
[09:31:11.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.898]     }
[09:31:11.898]     ...future.result <- base::tryCatch({
[09:31:11.898]         base::withCallingHandlers({
[09:31:11.898]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.898]             future::FutureResult(value = ...future.value$value, 
[09:31:11.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.898]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.898]                     ...future.globalenv.names))
[09:31:11.898]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.898]         }, condition = base::local({
[09:31:11.898]             c <- base::c
[09:31:11.898]             inherits <- base::inherits
[09:31:11.898]             invokeRestart <- base::invokeRestart
[09:31:11.898]             length <- base::length
[09:31:11.898]             list <- base::list
[09:31:11.898]             seq.int <- base::seq.int
[09:31:11.898]             signalCondition <- base::signalCondition
[09:31:11.898]             sys.calls <- base::sys.calls
[09:31:11.898]             `[[` <- base::`[[`
[09:31:11.898]             `+` <- base::`+`
[09:31:11.898]             `<<-` <- base::`<<-`
[09:31:11.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.898]                   3L)]
[09:31:11.898]             }
[09:31:11.898]             function(cond) {
[09:31:11.898]                 is_error <- inherits(cond, "error")
[09:31:11.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.898]                   NULL)
[09:31:11.898]                 if (is_error) {
[09:31:11.898]                   sessionInformation <- function() {
[09:31:11.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.898]                       search = base::search(), system = base::Sys.info())
[09:31:11.898]                   }
[09:31:11.898]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.898]                     cond$call), session = sessionInformation(), 
[09:31:11.898]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.898]                   signalCondition(cond)
[09:31:11.898]                 }
[09:31:11.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.898]                 "immediateCondition"))) {
[09:31:11.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.898]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.898]                   if (TRUE && !signal) {
[09:31:11.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.898]                     {
[09:31:11.898]                       inherits <- base::inherits
[09:31:11.898]                       invokeRestart <- base::invokeRestart
[09:31:11.898]                       is.null <- base::is.null
[09:31:11.898]                       muffled <- FALSE
[09:31:11.898]                       if (inherits(cond, "message")) {
[09:31:11.898]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.898]                         if (muffled) 
[09:31:11.898]                           invokeRestart("muffleMessage")
[09:31:11.898]                       }
[09:31:11.898]                       else if (inherits(cond, "warning")) {
[09:31:11.898]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.898]                         if (muffled) 
[09:31:11.898]                           invokeRestart("muffleWarning")
[09:31:11.898]                       }
[09:31:11.898]                       else if (inherits(cond, "condition")) {
[09:31:11.898]                         if (!is.null(pattern)) {
[09:31:11.898]                           computeRestarts <- base::computeRestarts
[09:31:11.898]                           grepl <- base::grepl
[09:31:11.898]                           restarts <- computeRestarts(cond)
[09:31:11.898]                           for (restart in restarts) {
[09:31:11.898]                             name <- restart$name
[09:31:11.898]                             if (is.null(name)) 
[09:31:11.898]                               next
[09:31:11.898]                             if (!grepl(pattern, name)) 
[09:31:11.898]                               next
[09:31:11.898]                             invokeRestart(restart)
[09:31:11.898]                             muffled <- TRUE
[09:31:11.898]                             break
[09:31:11.898]                           }
[09:31:11.898]                         }
[09:31:11.898]                       }
[09:31:11.898]                       invisible(muffled)
[09:31:11.898]                     }
[09:31:11.898]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.898]                   }
[09:31:11.898]                 }
[09:31:11.898]                 else {
[09:31:11.898]                   if (TRUE) {
[09:31:11.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.898]                     {
[09:31:11.898]                       inherits <- base::inherits
[09:31:11.898]                       invokeRestart <- base::invokeRestart
[09:31:11.898]                       is.null <- base::is.null
[09:31:11.898]                       muffled <- FALSE
[09:31:11.898]                       if (inherits(cond, "message")) {
[09:31:11.898]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.898]                         if (muffled) 
[09:31:11.898]                           invokeRestart("muffleMessage")
[09:31:11.898]                       }
[09:31:11.898]                       else if (inherits(cond, "warning")) {
[09:31:11.898]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.898]                         if (muffled) 
[09:31:11.898]                           invokeRestart("muffleWarning")
[09:31:11.898]                       }
[09:31:11.898]                       else if (inherits(cond, "condition")) {
[09:31:11.898]                         if (!is.null(pattern)) {
[09:31:11.898]                           computeRestarts <- base::computeRestarts
[09:31:11.898]                           grepl <- base::grepl
[09:31:11.898]                           restarts <- computeRestarts(cond)
[09:31:11.898]                           for (restart in restarts) {
[09:31:11.898]                             name <- restart$name
[09:31:11.898]                             if (is.null(name)) 
[09:31:11.898]                               next
[09:31:11.898]                             if (!grepl(pattern, name)) 
[09:31:11.898]                               next
[09:31:11.898]                             invokeRestart(restart)
[09:31:11.898]                             muffled <- TRUE
[09:31:11.898]                             break
[09:31:11.898]                           }
[09:31:11.898]                         }
[09:31:11.898]                       }
[09:31:11.898]                       invisible(muffled)
[09:31:11.898]                     }
[09:31:11.898]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.898]                   }
[09:31:11.898]                 }
[09:31:11.898]             }
[09:31:11.898]         }))
[09:31:11.898]     }, error = function(ex) {
[09:31:11.898]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.898]                 ...future.rng), started = ...future.startTime, 
[09:31:11.898]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.898]             version = "1.8"), class = "FutureResult")
[09:31:11.898]     }, finally = {
[09:31:11.898]         if (!identical(...future.workdir, getwd())) 
[09:31:11.898]             setwd(...future.workdir)
[09:31:11.898]         {
[09:31:11.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.898]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.898]             }
[09:31:11.898]             base::options(...future.oldOptions)
[09:31:11.898]             if (.Platform$OS.type == "windows") {
[09:31:11.898]                 old_names <- names(...future.oldEnvVars)
[09:31:11.898]                 envs <- base::Sys.getenv()
[09:31:11.898]                 names <- names(envs)
[09:31:11.898]                 common <- intersect(names, old_names)
[09:31:11.898]                 added <- setdiff(names, old_names)
[09:31:11.898]                 removed <- setdiff(old_names, names)
[09:31:11.898]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.898]                   envs[common]]
[09:31:11.898]                 NAMES <- toupper(changed)
[09:31:11.898]                 args <- list()
[09:31:11.898]                 for (kk in seq_along(NAMES)) {
[09:31:11.898]                   name <- changed[[kk]]
[09:31:11.898]                   NAME <- NAMES[[kk]]
[09:31:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.898]                     next
[09:31:11.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.898]                 }
[09:31:11.898]                 NAMES <- toupper(added)
[09:31:11.898]                 for (kk in seq_along(NAMES)) {
[09:31:11.898]                   name <- added[[kk]]
[09:31:11.898]                   NAME <- NAMES[[kk]]
[09:31:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.898]                     next
[09:31:11.898]                   args[[name]] <- ""
[09:31:11.898]                 }
[09:31:11.898]                 NAMES <- toupper(removed)
[09:31:11.898]                 for (kk in seq_along(NAMES)) {
[09:31:11.898]                   name <- removed[[kk]]
[09:31:11.898]                   NAME <- NAMES[[kk]]
[09:31:11.898]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.898]                     next
[09:31:11.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.898]                 }
[09:31:11.898]                 if (length(args) > 0) 
[09:31:11.898]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.898]             }
[09:31:11.898]             else {
[09:31:11.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.898]             }
[09:31:11.898]             {
[09:31:11.898]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.898]                   0L) {
[09:31:11.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.898]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.898]                   base::options(opts)
[09:31:11.898]                 }
[09:31:11.898]                 {
[09:31:11.898]                   {
[09:31:11.898]                     NULL
[09:31:11.898]                     RNGkind("Mersenne-Twister")
[09:31:11.898]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.898]                       inherits = FALSE)
[09:31:11.898]                   }
[09:31:11.898]                   options(future.plan = NULL)
[09:31:11.898]                   if (is.na(NA_character_)) 
[09:31:11.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.898]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.898]                     .init = FALSE)
[09:31:11.898]                 }
[09:31:11.898]             }
[09:31:11.898]         }
[09:31:11.898]     })
[09:31:11.898]     if (TRUE) {
[09:31:11.898]         base::sink(type = "output", split = FALSE)
[09:31:11.898]         if (TRUE) {
[09:31:11.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.898]         }
[09:31:11.898]         else {
[09:31:11.898]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.898]         }
[09:31:11.898]         base::close(...future.stdout)
[09:31:11.898]         ...future.stdout <- NULL
[09:31:11.898]     }
[09:31:11.898]     ...future.result$conditions <- ...future.conditions
[09:31:11.898]     ...future.result$finished <- base::Sys.time()
[09:31:11.898]     ...future.result
[09:31:11.898] }
[09:31:11.900] plan(): Setting new future strategy stack:
[09:31:11.900] List of future strategies:
[09:31:11.900] 1. sequential:
[09:31:11.900]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.900]    - tweaked: FALSE
[09:31:11.900]    - call: NULL
[09:31:11.900] plan(): nbrOfWorkers() = 1
[09:31:11.901] plan(): Setting new future strategy stack:
[09:31:11.901] List of future strategies:
[09:31:11.901] 1. sequential:
[09:31:11.901]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.901]    - tweaked: FALSE
[09:31:11.901]    - call: plan(strategy)
[09:31:11.901] plan(): nbrOfWorkers() = 1
[09:31:11.901] SequentialFuture started (and completed)
[09:31:11.901] - Launch lazy future ... done
[09:31:11.902] run() for ‘SequentialFuture’ ... done
[09:31:11.902] getGlobalsAndPackages() ...
[09:31:11.902] Searching for globals...
[09:31:11.903] - globals found: [1] ‘{’
[09:31:11.903] Searching for globals ... DONE
[09:31:11.903] Resolving globals: FALSE
[09:31:11.903] 
[09:31:11.903] 
[09:31:11.903] getGlobalsAndPackages() ... DONE
[09:31:11.903] run() for ‘Future’ ...
[09:31:11.904] - state: ‘created’
[09:31:11.904] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.904] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.904]   - Field: ‘label’
[09:31:11.904]   - Field: ‘local’
[09:31:11.904]   - Field: ‘owner’
[09:31:11.904]   - Field: ‘envir’
[09:31:11.905]   - Field: ‘packages’
[09:31:11.905]   - Field: ‘gc’
[09:31:11.905]   - Field: ‘conditions’
[09:31:11.905]   - Field: ‘expr’
[09:31:11.905]   - Field: ‘uuid’
[09:31:11.905]   - Field: ‘seed’
[09:31:11.905]   - Field: ‘version’
[09:31:11.905]   - Field: ‘result’
[09:31:11.905]   - Field: ‘asynchronous’
[09:31:11.905]   - Field: ‘calls’
[09:31:11.905]   - Field: ‘globals’
[09:31:11.905]   - Field: ‘stdout’
[09:31:11.906]   - Field: ‘earlySignal’
[09:31:11.906]   - Field: ‘lazy’
[09:31:11.906]   - Field: ‘state’
[09:31:11.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.906] - Launch lazy future ...
[09:31:11.906] Packages needed by the future expression (n = 0): <none>
[09:31:11.906] Packages needed by future strategies (n = 0): <none>
[09:31:11.906] {
[09:31:11.906]     {
[09:31:11.906]         {
[09:31:11.906]             ...future.startTime <- base::Sys.time()
[09:31:11.906]             {
[09:31:11.906]                 {
[09:31:11.906]                   {
[09:31:11.906]                     base::local({
[09:31:11.906]                       has_future <- base::requireNamespace("future", 
[09:31:11.906]                         quietly = TRUE)
[09:31:11.906]                       if (has_future) {
[09:31:11.906]                         ns <- base::getNamespace("future")
[09:31:11.906]                         version <- ns[[".package"]][["version"]]
[09:31:11.906]                         if (is.null(version)) 
[09:31:11.906]                           version <- utils::packageVersion("future")
[09:31:11.906]                       }
[09:31:11.906]                       else {
[09:31:11.906]                         version <- NULL
[09:31:11.906]                       }
[09:31:11.906]                       if (!has_future || version < "1.8.0") {
[09:31:11.906]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.906]                           "", base::R.version$version.string), 
[09:31:11.906]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.906]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.906]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.906]                             "release", "version")], collapse = " "), 
[09:31:11.906]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.906]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.906]                           info)
[09:31:11.906]                         info <- base::paste(info, collapse = "; ")
[09:31:11.906]                         if (!has_future) {
[09:31:11.906]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.906]                             info)
[09:31:11.906]                         }
[09:31:11.906]                         else {
[09:31:11.906]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.906]                             info, version)
[09:31:11.906]                         }
[09:31:11.906]                         base::stop(msg)
[09:31:11.906]                       }
[09:31:11.906]                     })
[09:31:11.906]                   }
[09:31:11.906]                   ...future.strategy.old <- future::plan("list")
[09:31:11.906]                   options(future.plan = NULL)
[09:31:11.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.906]                 }
[09:31:11.906]                 ...future.workdir <- getwd()
[09:31:11.906]             }
[09:31:11.906]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.906]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.906]         }
[09:31:11.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.906]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.906]             base::names(...future.oldOptions))
[09:31:11.906]     }
[09:31:11.906]     if (FALSE) {
[09:31:11.906]     }
[09:31:11.906]     else {
[09:31:11.906]         if (TRUE) {
[09:31:11.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.906]                 open = "w")
[09:31:11.906]         }
[09:31:11.906]         else {
[09:31:11.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.906]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.906]         }
[09:31:11.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.906]             base::sink(type = "output", split = FALSE)
[09:31:11.906]             base::close(...future.stdout)
[09:31:11.906]         }, add = TRUE)
[09:31:11.906]     }
[09:31:11.906]     ...future.frame <- base::sys.nframe()
[09:31:11.906]     ...future.conditions <- base::list()
[09:31:11.906]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.906]     if (FALSE) {
[09:31:11.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.906]     }
[09:31:11.906]     ...future.result <- base::tryCatch({
[09:31:11.906]         base::withCallingHandlers({
[09:31:11.906]             ...future.value <- base::withVisible(base::local({
[09:31:11.906]                 4
[09:31:11.906]             }))
[09:31:11.906]             future::FutureResult(value = ...future.value$value, 
[09:31:11.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.906]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.906]                     ...future.globalenv.names))
[09:31:11.906]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.906]         }, condition = base::local({
[09:31:11.906]             c <- base::c
[09:31:11.906]             inherits <- base::inherits
[09:31:11.906]             invokeRestart <- base::invokeRestart
[09:31:11.906]             length <- base::length
[09:31:11.906]             list <- base::list
[09:31:11.906]             seq.int <- base::seq.int
[09:31:11.906]             signalCondition <- base::signalCondition
[09:31:11.906]             sys.calls <- base::sys.calls
[09:31:11.906]             `[[` <- base::`[[`
[09:31:11.906]             `+` <- base::`+`
[09:31:11.906]             `<<-` <- base::`<<-`
[09:31:11.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.906]                   3L)]
[09:31:11.906]             }
[09:31:11.906]             function(cond) {
[09:31:11.906]                 is_error <- inherits(cond, "error")
[09:31:11.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.906]                   NULL)
[09:31:11.906]                 if (is_error) {
[09:31:11.906]                   sessionInformation <- function() {
[09:31:11.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.906]                       search = base::search(), system = base::Sys.info())
[09:31:11.906]                   }
[09:31:11.906]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.906]                     cond$call), session = sessionInformation(), 
[09:31:11.906]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.906]                   signalCondition(cond)
[09:31:11.906]                 }
[09:31:11.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.906]                 "immediateCondition"))) {
[09:31:11.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.906]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.906]                   if (TRUE && !signal) {
[09:31:11.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.906]                     {
[09:31:11.906]                       inherits <- base::inherits
[09:31:11.906]                       invokeRestart <- base::invokeRestart
[09:31:11.906]                       is.null <- base::is.null
[09:31:11.906]                       muffled <- FALSE
[09:31:11.906]                       if (inherits(cond, "message")) {
[09:31:11.906]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.906]                         if (muffled) 
[09:31:11.906]                           invokeRestart("muffleMessage")
[09:31:11.906]                       }
[09:31:11.906]                       else if (inherits(cond, "warning")) {
[09:31:11.906]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.906]                         if (muffled) 
[09:31:11.906]                           invokeRestart("muffleWarning")
[09:31:11.906]                       }
[09:31:11.906]                       else if (inherits(cond, "condition")) {
[09:31:11.906]                         if (!is.null(pattern)) {
[09:31:11.906]                           computeRestarts <- base::computeRestarts
[09:31:11.906]                           grepl <- base::grepl
[09:31:11.906]                           restarts <- computeRestarts(cond)
[09:31:11.906]                           for (restart in restarts) {
[09:31:11.906]                             name <- restart$name
[09:31:11.906]                             if (is.null(name)) 
[09:31:11.906]                               next
[09:31:11.906]                             if (!grepl(pattern, name)) 
[09:31:11.906]                               next
[09:31:11.906]                             invokeRestart(restart)
[09:31:11.906]                             muffled <- TRUE
[09:31:11.906]                             break
[09:31:11.906]                           }
[09:31:11.906]                         }
[09:31:11.906]                       }
[09:31:11.906]                       invisible(muffled)
[09:31:11.906]                     }
[09:31:11.906]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.906]                   }
[09:31:11.906]                 }
[09:31:11.906]                 else {
[09:31:11.906]                   if (TRUE) {
[09:31:11.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.906]                     {
[09:31:11.906]                       inherits <- base::inherits
[09:31:11.906]                       invokeRestart <- base::invokeRestart
[09:31:11.906]                       is.null <- base::is.null
[09:31:11.906]                       muffled <- FALSE
[09:31:11.906]                       if (inherits(cond, "message")) {
[09:31:11.906]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.906]                         if (muffled) 
[09:31:11.906]                           invokeRestart("muffleMessage")
[09:31:11.906]                       }
[09:31:11.906]                       else if (inherits(cond, "warning")) {
[09:31:11.906]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.906]                         if (muffled) 
[09:31:11.906]                           invokeRestart("muffleWarning")
[09:31:11.906]                       }
[09:31:11.906]                       else if (inherits(cond, "condition")) {
[09:31:11.906]                         if (!is.null(pattern)) {
[09:31:11.906]                           computeRestarts <- base::computeRestarts
[09:31:11.906]                           grepl <- base::grepl
[09:31:11.906]                           restarts <- computeRestarts(cond)
[09:31:11.906]                           for (restart in restarts) {
[09:31:11.906]                             name <- restart$name
[09:31:11.906]                             if (is.null(name)) 
[09:31:11.906]                               next
[09:31:11.906]                             if (!grepl(pattern, name)) 
[09:31:11.906]                               next
[09:31:11.906]                             invokeRestart(restart)
[09:31:11.906]                             muffled <- TRUE
[09:31:11.906]                             break
[09:31:11.906]                           }
[09:31:11.906]                         }
[09:31:11.906]                       }
[09:31:11.906]                       invisible(muffled)
[09:31:11.906]                     }
[09:31:11.906]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.906]                   }
[09:31:11.906]                 }
[09:31:11.906]             }
[09:31:11.906]         }))
[09:31:11.906]     }, error = function(ex) {
[09:31:11.906]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.906]                 ...future.rng), started = ...future.startTime, 
[09:31:11.906]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.906]             version = "1.8"), class = "FutureResult")
[09:31:11.906]     }, finally = {
[09:31:11.906]         if (!identical(...future.workdir, getwd())) 
[09:31:11.906]             setwd(...future.workdir)
[09:31:11.906]         {
[09:31:11.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.906]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.906]             }
[09:31:11.906]             base::options(...future.oldOptions)
[09:31:11.906]             if (.Platform$OS.type == "windows") {
[09:31:11.906]                 old_names <- names(...future.oldEnvVars)
[09:31:11.906]                 envs <- base::Sys.getenv()
[09:31:11.906]                 names <- names(envs)
[09:31:11.906]                 common <- intersect(names, old_names)
[09:31:11.906]                 added <- setdiff(names, old_names)
[09:31:11.906]                 removed <- setdiff(old_names, names)
[09:31:11.906]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.906]                   envs[common]]
[09:31:11.906]                 NAMES <- toupper(changed)
[09:31:11.906]                 args <- list()
[09:31:11.906]                 for (kk in seq_along(NAMES)) {
[09:31:11.906]                   name <- changed[[kk]]
[09:31:11.906]                   NAME <- NAMES[[kk]]
[09:31:11.906]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.906]                     next
[09:31:11.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.906]                 }
[09:31:11.906]                 NAMES <- toupper(added)
[09:31:11.906]                 for (kk in seq_along(NAMES)) {
[09:31:11.906]                   name <- added[[kk]]
[09:31:11.906]                   NAME <- NAMES[[kk]]
[09:31:11.906]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.906]                     next
[09:31:11.906]                   args[[name]] <- ""
[09:31:11.906]                 }
[09:31:11.906]                 NAMES <- toupper(removed)
[09:31:11.906]                 for (kk in seq_along(NAMES)) {
[09:31:11.906]                   name <- removed[[kk]]
[09:31:11.906]                   NAME <- NAMES[[kk]]
[09:31:11.906]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.906]                     next
[09:31:11.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.906]                 }
[09:31:11.906]                 if (length(args) > 0) 
[09:31:11.906]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.906]             }
[09:31:11.906]             else {
[09:31:11.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.906]             }
[09:31:11.906]             {
[09:31:11.906]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.906]                   0L) {
[09:31:11.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.906]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.906]                   base::options(opts)
[09:31:11.906]                 }
[09:31:11.906]                 {
[09:31:11.906]                   {
[09:31:11.906]                     NULL
[09:31:11.906]                     RNGkind("Mersenne-Twister")
[09:31:11.906]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.906]                       inherits = FALSE)
[09:31:11.906]                   }
[09:31:11.906]                   options(future.plan = NULL)
[09:31:11.906]                   if (is.na(NA_character_)) 
[09:31:11.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.906]                     .init = FALSE)
[09:31:11.906]                 }
[09:31:11.906]             }
[09:31:11.906]         }
[09:31:11.906]     })
[09:31:11.906]     if (TRUE) {
[09:31:11.906]         base::sink(type = "output", split = FALSE)
[09:31:11.906]         if (TRUE) {
[09:31:11.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.906]         }
[09:31:11.906]         else {
[09:31:11.906]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.906]         }
[09:31:11.906]         base::close(...future.stdout)
[09:31:11.906]         ...future.stdout <- NULL
[09:31:11.906]     }
[09:31:11.906]     ...future.result$conditions <- ...future.conditions
[09:31:11.906]     ...future.result$finished <- base::Sys.time()
[09:31:11.906]     ...future.result
[09:31:11.906] }
[09:31:11.908] plan(): Setting new future strategy stack:
[09:31:11.908] List of future strategies:
[09:31:11.908] 1. sequential:
[09:31:11.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.908]    - tweaked: FALSE
[09:31:11.908]    - call: NULL
[09:31:11.909] plan(): nbrOfWorkers() = 1
[09:31:11.909] plan(): Setting new future strategy stack:
[09:31:11.909] List of future strategies:
[09:31:11.909] 1. sequential:
[09:31:11.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.909]    - tweaked: FALSE
[09:31:11.909]    - call: plan(strategy)
[09:31:11.910] plan(): nbrOfWorkers() = 1
[09:31:11.910] SequentialFuture started (and completed)
[09:31:11.910] - Launch lazy future ... done
[09:31:11.910] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cacbb430> 
Classes 'listenv', 'environment' <environment: 0x55a3cab0f2b8> 
[09:31:11.913] resolved() for ‘SequentialFuture’ ...
[09:31:11.913] - state: ‘finished’
[09:31:11.913] - run: TRUE
[09:31:11.913] - result: ‘FutureResult’
[09:31:11.913] resolved() for ‘SequentialFuture’ ... done
[09:31:11.913] resolved() for ‘SequentialFuture’ ...
[09:31:11.914] - state: ‘finished’
[09:31:11.914] - run: TRUE
[09:31:11.914] - result: ‘FutureResult’
[09:31:11.914] resolved() for ‘SequentialFuture’ ... done
[09:31:11.914] resolved() for ‘SequentialFuture’ ...
[09:31:11.914] - state: ‘finished’
[09:31:11.914] - run: TRUE
[09:31:11.914] - result: ‘FutureResult’
[09:31:11.914] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:11.916] resolve() on list environment ...
[09:31:11.916]  recursive: 0
[09:31:11.917]  length: 6
[09:31:11.917]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:11.917] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.917] - nx: 6
[09:31:11.917] - relay: TRUE
[09:31:11.917] - stdout: TRUE
[09:31:11.917] - signal: TRUE
[09:31:11.917] - resignal: FALSE
[09:31:11.917] - force: TRUE
[09:31:11.917] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.918] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.918]  - until=2
[09:31:11.918]  - relaying element #2
[09:31:11.918] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.918] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.918] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.918]  length: 5 (resolved future 1)
[09:31:11.918] resolved() for ‘SequentialFuture’ ...
[09:31:11.918] - state: ‘finished’
[09:31:11.918] - run: TRUE
[09:31:11.919] - result: ‘FutureResult’
[09:31:11.919] resolved() for ‘SequentialFuture’ ... done
[09:31:11.919] Future #2
[09:31:11.919] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.919] - nx: 6
[09:31:11.919] - relay: TRUE
[09:31:11.919] - stdout: TRUE
[09:31:11.919] - signal: TRUE
[09:31:11.919] - resignal: FALSE
[09:31:11.919] - force: TRUE
[09:31:11.919] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.919] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.920]  - until=2
[09:31:11.920]  - relaying element #2
[09:31:11.920] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.920] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.920] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.920]  length: 4 (resolved future 2)
[09:31:11.920] resolved() for ‘SequentialFuture’ ...
[09:31:11.920] - state: ‘finished’
[09:31:11.920] - run: TRUE
[09:31:11.920] - result: ‘FutureResult’
[09:31:11.921] resolved() for ‘SequentialFuture’ ... done
[09:31:11.922] Future #3
[09:31:11.922] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.922] - nx: 6
[09:31:11.922] - relay: TRUE
[09:31:11.922] - stdout: TRUE
[09:31:11.922] - signal: TRUE
[09:31:11.922] - resignal: FALSE
[09:31:11.922] - force: TRUE
[09:31:11.923] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.923]  - until=3
[09:31:11.923]  - relaying element #3
[09:31:11.923] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.923] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.923] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.923]  length: 3 (resolved future 3)
[09:31:11.923] resolved() for ‘SequentialFuture’ ...
[09:31:11.923] - state: ‘finished’
[09:31:11.924] - run: TRUE
[09:31:11.924] - result: ‘FutureResult’
[09:31:11.924] resolved() for ‘SequentialFuture’ ... done
[09:31:11.924] Future #4
[09:31:11.924] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.924] - nx: 6
[09:31:11.924] - relay: TRUE
[09:31:11.924] - stdout: TRUE
[09:31:11.924] - signal: TRUE
[09:31:11.924] - resignal: FALSE
[09:31:11.924] - force: TRUE
[09:31:11.924] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.925] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.925]  - until=4
[09:31:11.925]  - relaying element #4
[09:31:11.925] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.925] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.925] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.925]  length: 2 (resolved future 4)
[09:31:11.925] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.925] - nx: 6
[09:31:11.925] - relay: TRUE
[09:31:11.925] - stdout: TRUE
[09:31:11.926] - signal: TRUE
[09:31:11.926] - resignal: FALSE
[09:31:11.926] - force: TRUE
[09:31:11.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.926] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.926]  - until=6
[09:31:11.926]  - relaying element #6
[09:31:11.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.926] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.926] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.926]  length: 1 (resolved future 5)
[09:31:11.926] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.927] - nx: 6
[09:31:11.927] - relay: TRUE
[09:31:11.927] - stdout: TRUE
[09:31:11.927] - signal: TRUE
[09:31:11.927] - resignal: FALSE
[09:31:11.927] - force: TRUE
[09:31:11.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.927] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.927]  - until=6
[09:31:11.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.927] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.927] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.927]  length: 0 (resolved future 6)
[09:31:11.928] Relaying remaining futures
[09:31:11.928] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.928] - nx: 6
[09:31:11.928] - relay: TRUE
[09:31:11.928] - stdout: TRUE
[09:31:11.928] - signal: TRUE
[09:31:11.928] - resignal: FALSE
[09:31:11.928] - force: TRUE
[09:31:11.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.928] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:11.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.928] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.929] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.929] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a3cadf0640> 
Dimensions: c(1, 6)
[09:31:11.929] getGlobalsAndPackages() ...
[09:31:11.929] Searching for globals...
[09:31:11.930] 
[09:31:11.930] Searching for globals ... DONE
[09:31:11.930] - globals: [0] <none>
[09:31:11.930] getGlobalsAndPackages() ... DONE
[09:31:11.930] run() for ‘Future’ ...
[09:31:11.930] - state: ‘created’
[09:31:11.930] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.931]   - Field: ‘label’
[09:31:11.931]   - Field: ‘local’
[09:31:11.931]   - Field: ‘owner’
[09:31:11.931]   - Field: ‘envir’
[09:31:11.931]   - Field: ‘packages’
[09:31:11.931]   - Field: ‘gc’
[09:31:11.931]   - Field: ‘conditions’
[09:31:11.931]   - Field: ‘expr’
[09:31:11.931]   - Field: ‘uuid’
[09:31:11.932]   - Field: ‘seed’
[09:31:11.932]   - Field: ‘version’
[09:31:11.932]   - Field: ‘result’
[09:31:11.932]   - Field: ‘asynchronous’
[09:31:11.932]   - Field: ‘calls’
[09:31:11.932]   - Field: ‘globals’
[09:31:11.932]   - Field: ‘stdout’
[09:31:11.932]   - Field: ‘earlySignal’
[09:31:11.932]   - Field: ‘lazy’
[09:31:11.932]   - Field: ‘state’
[09:31:11.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.933] - Launch lazy future ...
[09:31:11.933] Packages needed by the future expression (n = 0): <none>
[09:31:11.933] Packages needed by future strategies (n = 0): <none>
[09:31:11.933] {
[09:31:11.933]     {
[09:31:11.933]         {
[09:31:11.933]             ...future.startTime <- base::Sys.time()
[09:31:11.933]             {
[09:31:11.933]                 {
[09:31:11.933]                   {
[09:31:11.933]                     base::local({
[09:31:11.933]                       has_future <- base::requireNamespace("future", 
[09:31:11.933]                         quietly = TRUE)
[09:31:11.933]                       if (has_future) {
[09:31:11.933]                         ns <- base::getNamespace("future")
[09:31:11.933]                         version <- ns[[".package"]][["version"]]
[09:31:11.933]                         if (is.null(version)) 
[09:31:11.933]                           version <- utils::packageVersion("future")
[09:31:11.933]                       }
[09:31:11.933]                       else {
[09:31:11.933]                         version <- NULL
[09:31:11.933]                       }
[09:31:11.933]                       if (!has_future || version < "1.8.0") {
[09:31:11.933]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.933]                           "", base::R.version$version.string), 
[09:31:11.933]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.933]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.933]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.933]                             "release", "version")], collapse = " "), 
[09:31:11.933]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.933]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.933]                           info)
[09:31:11.933]                         info <- base::paste(info, collapse = "; ")
[09:31:11.933]                         if (!has_future) {
[09:31:11.933]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.933]                             info)
[09:31:11.933]                         }
[09:31:11.933]                         else {
[09:31:11.933]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.933]                             info, version)
[09:31:11.933]                         }
[09:31:11.933]                         base::stop(msg)
[09:31:11.933]                       }
[09:31:11.933]                     })
[09:31:11.933]                   }
[09:31:11.933]                   ...future.strategy.old <- future::plan("list")
[09:31:11.933]                   options(future.plan = NULL)
[09:31:11.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.933]                 }
[09:31:11.933]                 ...future.workdir <- getwd()
[09:31:11.933]             }
[09:31:11.933]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.933]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.933]         }
[09:31:11.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.933]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.933]             base::names(...future.oldOptions))
[09:31:11.933]     }
[09:31:11.933]     if (FALSE) {
[09:31:11.933]     }
[09:31:11.933]     else {
[09:31:11.933]         if (TRUE) {
[09:31:11.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.933]                 open = "w")
[09:31:11.933]         }
[09:31:11.933]         else {
[09:31:11.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.933]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.933]         }
[09:31:11.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.933]             base::sink(type = "output", split = FALSE)
[09:31:11.933]             base::close(...future.stdout)
[09:31:11.933]         }, add = TRUE)
[09:31:11.933]     }
[09:31:11.933]     ...future.frame <- base::sys.nframe()
[09:31:11.933]     ...future.conditions <- base::list()
[09:31:11.933]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.933]     if (FALSE) {
[09:31:11.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.933]     }
[09:31:11.933]     ...future.result <- base::tryCatch({
[09:31:11.933]         base::withCallingHandlers({
[09:31:11.933]             ...future.value <- base::withVisible(base::local(2))
[09:31:11.933]             future::FutureResult(value = ...future.value$value, 
[09:31:11.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.933]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.933]                     ...future.globalenv.names))
[09:31:11.933]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.933]         }, condition = base::local({
[09:31:11.933]             c <- base::c
[09:31:11.933]             inherits <- base::inherits
[09:31:11.933]             invokeRestart <- base::invokeRestart
[09:31:11.933]             length <- base::length
[09:31:11.933]             list <- base::list
[09:31:11.933]             seq.int <- base::seq.int
[09:31:11.933]             signalCondition <- base::signalCondition
[09:31:11.933]             sys.calls <- base::sys.calls
[09:31:11.933]             `[[` <- base::`[[`
[09:31:11.933]             `+` <- base::`+`
[09:31:11.933]             `<<-` <- base::`<<-`
[09:31:11.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.933]                   3L)]
[09:31:11.933]             }
[09:31:11.933]             function(cond) {
[09:31:11.933]                 is_error <- inherits(cond, "error")
[09:31:11.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.933]                   NULL)
[09:31:11.933]                 if (is_error) {
[09:31:11.933]                   sessionInformation <- function() {
[09:31:11.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.933]                       search = base::search(), system = base::Sys.info())
[09:31:11.933]                   }
[09:31:11.933]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.933]                     cond$call), session = sessionInformation(), 
[09:31:11.933]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.933]                   signalCondition(cond)
[09:31:11.933]                 }
[09:31:11.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.933]                 "immediateCondition"))) {
[09:31:11.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.933]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.933]                   if (TRUE && !signal) {
[09:31:11.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.933]                     {
[09:31:11.933]                       inherits <- base::inherits
[09:31:11.933]                       invokeRestart <- base::invokeRestart
[09:31:11.933]                       is.null <- base::is.null
[09:31:11.933]                       muffled <- FALSE
[09:31:11.933]                       if (inherits(cond, "message")) {
[09:31:11.933]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.933]                         if (muffled) 
[09:31:11.933]                           invokeRestart("muffleMessage")
[09:31:11.933]                       }
[09:31:11.933]                       else if (inherits(cond, "warning")) {
[09:31:11.933]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.933]                         if (muffled) 
[09:31:11.933]                           invokeRestart("muffleWarning")
[09:31:11.933]                       }
[09:31:11.933]                       else if (inherits(cond, "condition")) {
[09:31:11.933]                         if (!is.null(pattern)) {
[09:31:11.933]                           computeRestarts <- base::computeRestarts
[09:31:11.933]                           grepl <- base::grepl
[09:31:11.933]                           restarts <- computeRestarts(cond)
[09:31:11.933]                           for (restart in restarts) {
[09:31:11.933]                             name <- restart$name
[09:31:11.933]                             if (is.null(name)) 
[09:31:11.933]                               next
[09:31:11.933]                             if (!grepl(pattern, name)) 
[09:31:11.933]                               next
[09:31:11.933]                             invokeRestart(restart)
[09:31:11.933]                             muffled <- TRUE
[09:31:11.933]                             break
[09:31:11.933]                           }
[09:31:11.933]                         }
[09:31:11.933]                       }
[09:31:11.933]                       invisible(muffled)
[09:31:11.933]                     }
[09:31:11.933]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.933]                   }
[09:31:11.933]                 }
[09:31:11.933]                 else {
[09:31:11.933]                   if (TRUE) {
[09:31:11.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.933]                     {
[09:31:11.933]                       inherits <- base::inherits
[09:31:11.933]                       invokeRestart <- base::invokeRestart
[09:31:11.933]                       is.null <- base::is.null
[09:31:11.933]                       muffled <- FALSE
[09:31:11.933]                       if (inherits(cond, "message")) {
[09:31:11.933]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.933]                         if (muffled) 
[09:31:11.933]                           invokeRestart("muffleMessage")
[09:31:11.933]                       }
[09:31:11.933]                       else if (inherits(cond, "warning")) {
[09:31:11.933]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.933]                         if (muffled) 
[09:31:11.933]                           invokeRestart("muffleWarning")
[09:31:11.933]                       }
[09:31:11.933]                       else if (inherits(cond, "condition")) {
[09:31:11.933]                         if (!is.null(pattern)) {
[09:31:11.933]                           computeRestarts <- base::computeRestarts
[09:31:11.933]                           grepl <- base::grepl
[09:31:11.933]                           restarts <- computeRestarts(cond)
[09:31:11.933]                           for (restart in restarts) {
[09:31:11.933]                             name <- restart$name
[09:31:11.933]                             if (is.null(name)) 
[09:31:11.933]                               next
[09:31:11.933]                             if (!grepl(pattern, name)) 
[09:31:11.933]                               next
[09:31:11.933]                             invokeRestart(restart)
[09:31:11.933]                             muffled <- TRUE
[09:31:11.933]                             break
[09:31:11.933]                           }
[09:31:11.933]                         }
[09:31:11.933]                       }
[09:31:11.933]                       invisible(muffled)
[09:31:11.933]                     }
[09:31:11.933]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.933]                   }
[09:31:11.933]                 }
[09:31:11.933]             }
[09:31:11.933]         }))
[09:31:11.933]     }, error = function(ex) {
[09:31:11.933]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.933]                 ...future.rng), started = ...future.startTime, 
[09:31:11.933]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.933]             version = "1.8"), class = "FutureResult")
[09:31:11.933]     }, finally = {
[09:31:11.933]         if (!identical(...future.workdir, getwd())) 
[09:31:11.933]             setwd(...future.workdir)
[09:31:11.933]         {
[09:31:11.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.933]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.933]             }
[09:31:11.933]             base::options(...future.oldOptions)
[09:31:11.933]             if (.Platform$OS.type == "windows") {
[09:31:11.933]                 old_names <- names(...future.oldEnvVars)
[09:31:11.933]                 envs <- base::Sys.getenv()
[09:31:11.933]                 names <- names(envs)
[09:31:11.933]                 common <- intersect(names, old_names)
[09:31:11.933]                 added <- setdiff(names, old_names)
[09:31:11.933]                 removed <- setdiff(old_names, names)
[09:31:11.933]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.933]                   envs[common]]
[09:31:11.933]                 NAMES <- toupper(changed)
[09:31:11.933]                 args <- list()
[09:31:11.933]                 for (kk in seq_along(NAMES)) {
[09:31:11.933]                   name <- changed[[kk]]
[09:31:11.933]                   NAME <- NAMES[[kk]]
[09:31:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.933]                     next
[09:31:11.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.933]                 }
[09:31:11.933]                 NAMES <- toupper(added)
[09:31:11.933]                 for (kk in seq_along(NAMES)) {
[09:31:11.933]                   name <- added[[kk]]
[09:31:11.933]                   NAME <- NAMES[[kk]]
[09:31:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.933]                     next
[09:31:11.933]                   args[[name]] <- ""
[09:31:11.933]                 }
[09:31:11.933]                 NAMES <- toupper(removed)
[09:31:11.933]                 for (kk in seq_along(NAMES)) {
[09:31:11.933]                   name <- removed[[kk]]
[09:31:11.933]                   NAME <- NAMES[[kk]]
[09:31:11.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.933]                     next
[09:31:11.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.933]                 }
[09:31:11.933]                 if (length(args) > 0) 
[09:31:11.933]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.933]             }
[09:31:11.933]             else {
[09:31:11.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.933]             }
[09:31:11.933]             {
[09:31:11.933]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.933]                   0L) {
[09:31:11.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.933]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.933]                   base::options(opts)
[09:31:11.933]                 }
[09:31:11.933]                 {
[09:31:11.933]                   {
[09:31:11.933]                     NULL
[09:31:11.933]                     RNGkind("Mersenne-Twister")
[09:31:11.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.933]                       inherits = FALSE)
[09:31:11.933]                   }
[09:31:11.933]                   options(future.plan = NULL)
[09:31:11.933]                   if (is.na(NA_character_)) 
[09:31:11.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.933]                     .init = FALSE)
[09:31:11.933]                 }
[09:31:11.933]             }
[09:31:11.933]         }
[09:31:11.933]     })
[09:31:11.933]     if (TRUE) {
[09:31:11.933]         base::sink(type = "output", split = FALSE)
[09:31:11.933]         if (TRUE) {
[09:31:11.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.933]         }
[09:31:11.933]         else {
[09:31:11.933]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.933]         }
[09:31:11.933]         base::close(...future.stdout)
[09:31:11.933]         ...future.stdout <- NULL
[09:31:11.933]     }
[09:31:11.933]     ...future.result$conditions <- ...future.conditions
[09:31:11.933]     ...future.result$finished <- base::Sys.time()
[09:31:11.933]     ...future.result
[09:31:11.933] }
[09:31:11.935] plan(): Setting new future strategy stack:
[09:31:11.935] List of future strategies:
[09:31:11.935] 1. sequential:
[09:31:11.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.935]    - tweaked: FALSE
[09:31:11.935]    - call: NULL
[09:31:11.935] plan(): nbrOfWorkers() = 1
[09:31:11.936] plan(): Setting new future strategy stack:
[09:31:11.936] List of future strategies:
[09:31:11.936] 1. sequential:
[09:31:11.936]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.936]    - tweaked: FALSE
[09:31:11.936]    - call: plan(strategy)
[09:31:11.936] plan(): nbrOfWorkers() = 1
[09:31:11.937] SequentialFuture started (and completed)
[09:31:11.937] - Launch lazy future ... done
[09:31:11.937] run() for ‘SequentialFuture’ ... done
[09:31:11.937] getGlobalsAndPackages() ...
[09:31:11.937] Searching for globals...
[09:31:11.937] 
[09:31:11.937] Searching for globals ... DONE
[09:31:11.937] - globals: [0] <none>
[09:31:11.938] getGlobalsAndPackages() ... DONE
[09:31:11.938] run() for ‘Future’ ...
[09:31:11.938] - state: ‘created’
[09:31:11.938] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.938] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.938] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.938]   - Field: ‘label’
[09:31:11.938]   - Field: ‘local’
[09:31:11.939]   - Field: ‘owner’
[09:31:11.939]   - Field: ‘envir’
[09:31:11.939]   - Field: ‘packages’
[09:31:11.939]   - Field: ‘gc’
[09:31:11.939]   - Field: ‘conditions’
[09:31:11.939]   - Field: ‘expr’
[09:31:11.939]   - Field: ‘uuid’
[09:31:11.939]   - Field: ‘seed’
[09:31:11.939]   - Field: ‘version’
[09:31:11.939]   - Field: ‘result’
[09:31:11.939]   - Field: ‘asynchronous’
[09:31:11.939]   - Field: ‘calls’
[09:31:11.940]   - Field: ‘globals’
[09:31:11.940]   - Field: ‘stdout’
[09:31:11.940]   - Field: ‘earlySignal’
[09:31:11.940]   - Field: ‘lazy’
[09:31:11.940]   - Field: ‘state’
[09:31:11.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.940] - Launch lazy future ...
[09:31:11.940] Packages needed by the future expression (n = 0): <none>
[09:31:11.940] Packages needed by future strategies (n = 0): <none>
[09:31:11.941] {
[09:31:11.941]     {
[09:31:11.941]         {
[09:31:11.941]             ...future.startTime <- base::Sys.time()
[09:31:11.941]             {
[09:31:11.941]                 {
[09:31:11.941]                   {
[09:31:11.941]                     base::local({
[09:31:11.941]                       has_future <- base::requireNamespace("future", 
[09:31:11.941]                         quietly = TRUE)
[09:31:11.941]                       if (has_future) {
[09:31:11.941]                         ns <- base::getNamespace("future")
[09:31:11.941]                         version <- ns[[".package"]][["version"]]
[09:31:11.941]                         if (is.null(version)) 
[09:31:11.941]                           version <- utils::packageVersion("future")
[09:31:11.941]                       }
[09:31:11.941]                       else {
[09:31:11.941]                         version <- NULL
[09:31:11.941]                       }
[09:31:11.941]                       if (!has_future || version < "1.8.0") {
[09:31:11.941]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.941]                           "", base::R.version$version.string), 
[09:31:11.941]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.941]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.941]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.941]                             "release", "version")], collapse = " "), 
[09:31:11.941]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.941]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.941]                           info)
[09:31:11.941]                         info <- base::paste(info, collapse = "; ")
[09:31:11.941]                         if (!has_future) {
[09:31:11.941]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.941]                             info)
[09:31:11.941]                         }
[09:31:11.941]                         else {
[09:31:11.941]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.941]                             info, version)
[09:31:11.941]                         }
[09:31:11.941]                         base::stop(msg)
[09:31:11.941]                       }
[09:31:11.941]                     })
[09:31:11.941]                   }
[09:31:11.941]                   ...future.strategy.old <- future::plan("list")
[09:31:11.941]                   options(future.plan = NULL)
[09:31:11.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.941]                 }
[09:31:11.941]                 ...future.workdir <- getwd()
[09:31:11.941]             }
[09:31:11.941]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.941]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.941]         }
[09:31:11.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.941]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.941]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.941]             base::names(...future.oldOptions))
[09:31:11.941]     }
[09:31:11.941]     if (FALSE) {
[09:31:11.941]     }
[09:31:11.941]     else {
[09:31:11.941]         if (TRUE) {
[09:31:11.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.941]                 open = "w")
[09:31:11.941]         }
[09:31:11.941]         else {
[09:31:11.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.941]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.941]         }
[09:31:11.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.941]             base::sink(type = "output", split = FALSE)
[09:31:11.941]             base::close(...future.stdout)
[09:31:11.941]         }, add = TRUE)
[09:31:11.941]     }
[09:31:11.941]     ...future.frame <- base::sys.nframe()
[09:31:11.941]     ...future.conditions <- base::list()
[09:31:11.941]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.941]     if (FALSE) {
[09:31:11.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.941]     }
[09:31:11.941]     ...future.result <- base::tryCatch({
[09:31:11.941]         base::withCallingHandlers({
[09:31:11.941]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:11.941]             future::FutureResult(value = ...future.value$value, 
[09:31:11.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.941]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.941]                     ...future.globalenv.names))
[09:31:11.941]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.941]         }, condition = base::local({
[09:31:11.941]             c <- base::c
[09:31:11.941]             inherits <- base::inherits
[09:31:11.941]             invokeRestart <- base::invokeRestart
[09:31:11.941]             length <- base::length
[09:31:11.941]             list <- base::list
[09:31:11.941]             seq.int <- base::seq.int
[09:31:11.941]             signalCondition <- base::signalCondition
[09:31:11.941]             sys.calls <- base::sys.calls
[09:31:11.941]             `[[` <- base::`[[`
[09:31:11.941]             `+` <- base::`+`
[09:31:11.941]             `<<-` <- base::`<<-`
[09:31:11.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.941]                   3L)]
[09:31:11.941]             }
[09:31:11.941]             function(cond) {
[09:31:11.941]                 is_error <- inherits(cond, "error")
[09:31:11.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.941]                   NULL)
[09:31:11.941]                 if (is_error) {
[09:31:11.941]                   sessionInformation <- function() {
[09:31:11.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.941]                       search = base::search(), system = base::Sys.info())
[09:31:11.941]                   }
[09:31:11.941]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.941]                     cond$call), session = sessionInformation(), 
[09:31:11.941]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.941]                   signalCondition(cond)
[09:31:11.941]                 }
[09:31:11.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.941]                 "immediateCondition"))) {
[09:31:11.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.941]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.941]                   if (TRUE && !signal) {
[09:31:11.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.941]                     {
[09:31:11.941]                       inherits <- base::inherits
[09:31:11.941]                       invokeRestart <- base::invokeRestart
[09:31:11.941]                       is.null <- base::is.null
[09:31:11.941]                       muffled <- FALSE
[09:31:11.941]                       if (inherits(cond, "message")) {
[09:31:11.941]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.941]                         if (muffled) 
[09:31:11.941]                           invokeRestart("muffleMessage")
[09:31:11.941]                       }
[09:31:11.941]                       else if (inherits(cond, "warning")) {
[09:31:11.941]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.941]                         if (muffled) 
[09:31:11.941]                           invokeRestart("muffleWarning")
[09:31:11.941]                       }
[09:31:11.941]                       else if (inherits(cond, "condition")) {
[09:31:11.941]                         if (!is.null(pattern)) {
[09:31:11.941]                           computeRestarts <- base::computeRestarts
[09:31:11.941]                           grepl <- base::grepl
[09:31:11.941]                           restarts <- computeRestarts(cond)
[09:31:11.941]                           for (restart in restarts) {
[09:31:11.941]                             name <- restart$name
[09:31:11.941]                             if (is.null(name)) 
[09:31:11.941]                               next
[09:31:11.941]                             if (!grepl(pattern, name)) 
[09:31:11.941]                               next
[09:31:11.941]                             invokeRestart(restart)
[09:31:11.941]                             muffled <- TRUE
[09:31:11.941]                             break
[09:31:11.941]                           }
[09:31:11.941]                         }
[09:31:11.941]                       }
[09:31:11.941]                       invisible(muffled)
[09:31:11.941]                     }
[09:31:11.941]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.941]                   }
[09:31:11.941]                 }
[09:31:11.941]                 else {
[09:31:11.941]                   if (TRUE) {
[09:31:11.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.941]                     {
[09:31:11.941]                       inherits <- base::inherits
[09:31:11.941]                       invokeRestart <- base::invokeRestart
[09:31:11.941]                       is.null <- base::is.null
[09:31:11.941]                       muffled <- FALSE
[09:31:11.941]                       if (inherits(cond, "message")) {
[09:31:11.941]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.941]                         if (muffled) 
[09:31:11.941]                           invokeRestart("muffleMessage")
[09:31:11.941]                       }
[09:31:11.941]                       else if (inherits(cond, "warning")) {
[09:31:11.941]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.941]                         if (muffled) 
[09:31:11.941]                           invokeRestart("muffleWarning")
[09:31:11.941]                       }
[09:31:11.941]                       else if (inherits(cond, "condition")) {
[09:31:11.941]                         if (!is.null(pattern)) {
[09:31:11.941]                           computeRestarts <- base::computeRestarts
[09:31:11.941]                           grepl <- base::grepl
[09:31:11.941]                           restarts <- computeRestarts(cond)
[09:31:11.941]                           for (restart in restarts) {
[09:31:11.941]                             name <- restart$name
[09:31:11.941]                             if (is.null(name)) 
[09:31:11.941]                               next
[09:31:11.941]                             if (!grepl(pattern, name)) 
[09:31:11.941]                               next
[09:31:11.941]                             invokeRestart(restart)
[09:31:11.941]                             muffled <- TRUE
[09:31:11.941]                             break
[09:31:11.941]                           }
[09:31:11.941]                         }
[09:31:11.941]                       }
[09:31:11.941]                       invisible(muffled)
[09:31:11.941]                     }
[09:31:11.941]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.941]                   }
[09:31:11.941]                 }
[09:31:11.941]             }
[09:31:11.941]         }))
[09:31:11.941]     }, error = function(ex) {
[09:31:11.941]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.941]                 ...future.rng), started = ...future.startTime, 
[09:31:11.941]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.941]             version = "1.8"), class = "FutureResult")
[09:31:11.941]     }, finally = {
[09:31:11.941]         if (!identical(...future.workdir, getwd())) 
[09:31:11.941]             setwd(...future.workdir)
[09:31:11.941]         {
[09:31:11.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.941]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.941]             }
[09:31:11.941]             base::options(...future.oldOptions)
[09:31:11.941]             if (.Platform$OS.type == "windows") {
[09:31:11.941]                 old_names <- names(...future.oldEnvVars)
[09:31:11.941]                 envs <- base::Sys.getenv()
[09:31:11.941]                 names <- names(envs)
[09:31:11.941]                 common <- intersect(names, old_names)
[09:31:11.941]                 added <- setdiff(names, old_names)
[09:31:11.941]                 removed <- setdiff(old_names, names)
[09:31:11.941]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.941]                   envs[common]]
[09:31:11.941]                 NAMES <- toupper(changed)
[09:31:11.941]                 args <- list()
[09:31:11.941]                 for (kk in seq_along(NAMES)) {
[09:31:11.941]                   name <- changed[[kk]]
[09:31:11.941]                   NAME <- NAMES[[kk]]
[09:31:11.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.941]                     next
[09:31:11.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.941]                 }
[09:31:11.941]                 NAMES <- toupper(added)
[09:31:11.941]                 for (kk in seq_along(NAMES)) {
[09:31:11.941]                   name <- added[[kk]]
[09:31:11.941]                   NAME <- NAMES[[kk]]
[09:31:11.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.941]                     next
[09:31:11.941]                   args[[name]] <- ""
[09:31:11.941]                 }
[09:31:11.941]                 NAMES <- toupper(removed)
[09:31:11.941]                 for (kk in seq_along(NAMES)) {
[09:31:11.941]                   name <- removed[[kk]]
[09:31:11.941]                   NAME <- NAMES[[kk]]
[09:31:11.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.941]                     next
[09:31:11.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.941]                 }
[09:31:11.941]                 if (length(args) > 0) 
[09:31:11.941]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.941]             }
[09:31:11.941]             else {
[09:31:11.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.941]             }
[09:31:11.941]             {
[09:31:11.941]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.941]                   0L) {
[09:31:11.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.941]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.941]                   base::options(opts)
[09:31:11.941]                 }
[09:31:11.941]                 {
[09:31:11.941]                   {
[09:31:11.941]                     NULL
[09:31:11.941]                     RNGkind("Mersenne-Twister")
[09:31:11.941]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.941]                       inherits = FALSE)
[09:31:11.941]                   }
[09:31:11.941]                   options(future.plan = NULL)
[09:31:11.941]                   if (is.na(NA_character_)) 
[09:31:11.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.941]                     .init = FALSE)
[09:31:11.941]                 }
[09:31:11.941]             }
[09:31:11.941]         }
[09:31:11.941]     })
[09:31:11.941]     if (TRUE) {
[09:31:11.941]         base::sink(type = "output", split = FALSE)
[09:31:11.941]         if (TRUE) {
[09:31:11.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.941]         }
[09:31:11.941]         else {
[09:31:11.941]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.941]         }
[09:31:11.941]         base::close(...future.stdout)
[09:31:11.941]         ...future.stdout <- NULL
[09:31:11.941]     }
[09:31:11.941]     ...future.result$conditions <- ...future.conditions
[09:31:11.941]     ...future.result$finished <- base::Sys.time()
[09:31:11.941]     ...future.result
[09:31:11.941] }
[09:31:11.942] plan(): Setting new future strategy stack:
[09:31:11.942] List of future strategies:
[09:31:11.942] 1. sequential:
[09:31:11.942]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.942]    - tweaked: FALSE
[09:31:11.942]    - call: NULL
[09:31:11.943] plan(): nbrOfWorkers() = 1
[09:31:11.943] plan(): Setting new future strategy stack:
[09:31:11.944] List of future strategies:
[09:31:11.944] 1. sequential:
[09:31:11.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.944]    - tweaked: FALSE
[09:31:11.944]    - call: plan(strategy)
[09:31:11.944] plan(): nbrOfWorkers() = 1
[09:31:11.944] SequentialFuture started (and completed)
[09:31:11.944] - Launch lazy future ... done
[09:31:11.944] run() for ‘SequentialFuture’ ... done
[09:31:11.945] getGlobalsAndPackages() ...
[09:31:11.945] Searching for globals...
[09:31:11.945] - globals found: [1] ‘{’
[09:31:11.945] Searching for globals ... DONE
[09:31:11.945] Resolving globals: FALSE
[09:31:11.946] 
[09:31:11.947] 
[09:31:11.947] getGlobalsAndPackages() ... DONE
[09:31:11.947] run() for ‘Future’ ...
[09:31:11.947] - state: ‘created’
[09:31:11.947] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.948] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.948]   - Field: ‘label’
[09:31:11.948]   - Field: ‘local’
[09:31:11.948]   - Field: ‘owner’
[09:31:11.948]   - Field: ‘envir’
[09:31:11.948]   - Field: ‘packages’
[09:31:11.948]   - Field: ‘gc’
[09:31:11.949]   - Field: ‘conditions’
[09:31:11.949]   - Field: ‘expr’
[09:31:11.949]   - Field: ‘uuid’
[09:31:11.949]   - Field: ‘seed’
[09:31:11.949]   - Field: ‘version’
[09:31:11.949]   - Field: ‘result’
[09:31:11.949]   - Field: ‘asynchronous’
[09:31:11.949]   - Field: ‘calls’
[09:31:11.949]   - Field: ‘globals’
[09:31:11.949]   - Field: ‘stdout’
[09:31:11.949]   - Field: ‘earlySignal’
[09:31:11.949]   - Field: ‘lazy’
[09:31:11.950]   - Field: ‘state’
[09:31:11.950] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.950] - Launch lazy future ...
[09:31:11.950] Packages needed by the future expression (n = 0): <none>
[09:31:11.950] Packages needed by future strategies (n = 0): <none>
[09:31:11.950] {
[09:31:11.950]     {
[09:31:11.950]         {
[09:31:11.950]             ...future.startTime <- base::Sys.time()
[09:31:11.950]             {
[09:31:11.950]                 {
[09:31:11.950]                   {
[09:31:11.950]                     base::local({
[09:31:11.950]                       has_future <- base::requireNamespace("future", 
[09:31:11.950]                         quietly = TRUE)
[09:31:11.950]                       if (has_future) {
[09:31:11.950]                         ns <- base::getNamespace("future")
[09:31:11.950]                         version <- ns[[".package"]][["version"]]
[09:31:11.950]                         if (is.null(version)) 
[09:31:11.950]                           version <- utils::packageVersion("future")
[09:31:11.950]                       }
[09:31:11.950]                       else {
[09:31:11.950]                         version <- NULL
[09:31:11.950]                       }
[09:31:11.950]                       if (!has_future || version < "1.8.0") {
[09:31:11.950]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.950]                           "", base::R.version$version.string), 
[09:31:11.950]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.950]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.950]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.950]                             "release", "version")], collapse = " "), 
[09:31:11.950]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.950]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.950]                           info)
[09:31:11.950]                         info <- base::paste(info, collapse = "; ")
[09:31:11.950]                         if (!has_future) {
[09:31:11.950]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.950]                             info)
[09:31:11.950]                         }
[09:31:11.950]                         else {
[09:31:11.950]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.950]                             info, version)
[09:31:11.950]                         }
[09:31:11.950]                         base::stop(msg)
[09:31:11.950]                       }
[09:31:11.950]                     })
[09:31:11.950]                   }
[09:31:11.950]                   ...future.strategy.old <- future::plan("list")
[09:31:11.950]                   options(future.plan = NULL)
[09:31:11.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.950]                 }
[09:31:11.950]                 ...future.workdir <- getwd()
[09:31:11.950]             }
[09:31:11.950]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.950]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.950]         }
[09:31:11.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.950]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.950]             base::names(...future.oldOptions))
[09:31:11.950]     }
[09:31:11.950]     if (FALSE) {
[09:31:11.950]     }
[09:31:11.950]     else {
[09:31:11.950]         if (TRUE) {
[09:31:11.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.950]                 open = "w")
[09:31:11.950]         }
[09:31:11.950]         else {
[09:31:11.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.950]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.950]         }
[09:31:11.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.950]             base::sink(type = "output", split = FALSE)
[09:31:11.950]             base::close(...future.stdout)
[09:31:11.950]         }, add = TRUE)
[09:31:11.950]     }
[09:31:11.950]     ...future.frame <- base::sys.nframe()
[09:31:11.950]     ...future.conditions <- base::list()
[09:31:11.950]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.950]     if (FALSE) {
[09:31:11.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.950]     }
[09:31:11.950]     ...future.result <- base::tryCatch({
[09:31:11.950]         base::withCallingHandlers({
[09:31:11.950]             ...future.value <- base::withVisible(base::local({
[09:31:11.950]                 4
[09:31:11.950]             }))
[09:31:11.950]             future::FutureResult(value = ...future.value$value, 
[09:31:11.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.950]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.950]                     ...future.globalenv.names))
[09:31:11.950]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.950]         }, condition = base::local({
[09:31:11.950]             c <- base::c
[09:31:11.950]             inherits <- base::inherits
[09:31:11.950]             invokeRestart <- base::invokeRestart
[09:31:11.950]             length <- base::length
[09:31:11.950]             list <- base::list
[09:31:11.950]             seq.int <- base::seq.int
[09:31:11.950]             signalCondition <- base::signalCondition
[09:31:11.950]             sys.calls <- base::sys.calls
[09:31:11.950]             `[[` <- base::`[[`
[09:31:11.950]             `+` <- base::`+`
[09:31:11.950]             `<<-` <- base::`<<-`
[09:31:11.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.950]                   3L)]
[09:31:11.950]             }
[09:31:11.950]             function(cond) {
[09:31:11.950]                 is_error <- inherits(cond, "error")
[09:31:11.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.950]                   NULL)
[09:31:11.950]                 if (is_error) {
[09:31:11.950]                   sessionInformation <- function() {
[09:31:11.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.950]                       search = base::search(), system = base::Sys.info())
[09:31:11.950]                   }
[09:31:11.950]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.950]                     cond$call), session = sessionInformation(), 
[09:31:11.950]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.950]                   signalCondition(cond)
[09:31:11.950]                 }
[09:31:11.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.950]                 "immediateCondition"))) {
[09:31:11.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.950]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.950]                   if (TRUE && !signal) {
[09:31:11.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.950]                     {
[09:31:11.950]                       inherits <- base::inherits
[09:31:11.950]                       invokeRestart <- base::invokeRestart
[09:31:11.950]                       is.null <- base::is.null
[09:31:11.950]                       muffled <- FALSE
[09:31:11.950]                       if (inherits(cond, "message")) {
[09:31:11.950]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.950]                         if (muffled) 
[09:31:11.950]                           invokeRestart("muffleMessage")
[09:31:11.950]                       }
[09:31:11.950]                       else if (inherits(cond, "warning")) {
[09:31:11.950]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.950]                         if (muffled) 
[09:31:11.950]                           invokeRestart("muffleWarning")
[09:31:11.950]                       }
[09:31:11.950]                       else if (inherits(cond, "condition")) {
[09:31:11.950]                         if (!is.null(pattern)) {
[09:31:11.950]                           computeRestarts <- base::computeRestarts
[09:31:11.950]                           grepl <- base::grepl
[09:31:11.950]                           restarts <- computeRestarts(cond)
[09:31:11.950]                           for (restart in restarts) {
[09:31:11.950]                             name <- restart$name
[09:31:11.950]                             if (is.null(name)) 
[09:31:11.950]                               next
[09:31:11.950]                             if (!grepl(pattern, name)) 
[09:31:11.950]                               next
[09:31:11.950]                             invokeRestart(restart)
[09:31:11.950]                             muffled <- TRUE
[09:31:11.950]                             break
[09:31:11.950]                           }
[09:31:11.950]                         }
[09:31:11.950]                       }
[09:31:11.950]                       invisible(muffled)
[09:31:11.950]                     }
[09:31:11.950]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.950]                   }
[09:31:11.950]                 }
[09:31:11.950]                 else {
[09:31:11.950]                   if (TRUE) {
[09:31:11.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.950]                     {
[09:31:11.950]                       inherits <- base::inherits
[09:31:11.950]                       invokeRestart <- base::invokeRestart
[09:31:11.950]                       is.null <- base::is.null
[09:31:11.950]                       muffled <- FALSE
[09:31:11.950]                       if (inherits(cond, "message")) {
[09:31:11.950]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.950]                         if (muffled) 
[09:31:11.950]                           invokeRestart("muffleMessage")
[09:31:11.950]                       }
[09:31:11.950]                       else if (inherits(cond, "warning")) {
[09:31:11.950]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.950]                         if (muffled) 
[09:31:11.950]                           invokeRestart("muffleWarning")
[09:31:11.950]                       }
[09:31:11.950]                       else if (inherits(cond, "condition")) {
[09:31:11.950]                         if (!is.null(pattern)) {
[09:31:11.950]                           computeRestarts <- base::computeRestarts
[09:31:11.950]                           grepl <- base::grepl
[09:31:11.950]                           restarts <- computeRestarts(cond)
[09:31:11.950]                           for (restart in restarts) {
[09:31:11.950]                             name <- restart$name
[09:31:11.950]                             if (is.null(name)) 
[09:31:11.950]                               next
[09:31:11.950]                             if (!grepl(pattern, name)) 
[09:31:11.950]                               next
[09:31:11.950]                             invokeRestart(restart)
[09:31:11.950]                             muffled <- TRUE
[09:31:11.950]                             break
[09:31:11.950]                           }
[09:31:11.950]                         }
[09:31:11.950]                       }
[09:31:11.950]                       invisible(muffled)
[09:31:11.950]                     }
[09:31:11.950]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.950]                   }
[09:31:11.950]                 }
[09:31:11.950]             }
[09:31:11.950]         }))
[09:31:11.950]     }, error = function(ex) {
[09:31:11.950]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.950]                 ...future.rng), started = ...future.startTime, 
[09:31:11.950]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.950]             version = "1.8"), class = "FutureResult")
[09:31:11.950]     }, finally = {
[09:31:11.950]         if (!identical(...future.workdir, getwd())) 
[09:31:11.950]             setwd(...future.workdir)
[09:31:11.950]         {
[09:31:11.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.950]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.950]             }
[09:31:11.950]             base::options(...future.oldOptions)
[09:31:11.950]             if (.Platform$OS.type == "windows") {
[09:31:11.950]                 old_names <- names(...future.oldEnvVars)
[09:31:11.950]                 envs <- base::Sys.getenv()
[09:31:11.950]                 names <- names(envs)
[09:31:11.950]                 common <- intersect(names, old_names)
[09:31:11.950]                 added <- setdiff(names, old_names)
[09:31:11.950]                 removed <- setdiff(old_names, names)
[09:31:11.950]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.950]                   envs[common]]
[09:31:11.950]                 NAMES <- toupper(changed)
[09:31:11.950]                 args <- list()
[09:31:11.950]                 for (kk in seq_along(NAMES)) {
[09:31:11.950]                   name <- changed[[kk]]
[09:31:11.950]                   NAME <- NAMES[[kk]]
[09:31:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.950]                     next
[09:31:11.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.950]                 }
[09:31:11.950]                 NAMES <- toupper(added)
[09:31:11.950]                 for (kk in seq_along(NAMES)) {
[09:31:11.950]                   name <- added[[kk]]
[09:31:11.950]                   NAME <- NAMES[[kk]]
[09:31:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.950]                     next
[09:31:11.950]                   args[[name]] <- ""
[09:31:11.950]                 }
[09:31:11.950]                 NAMES <- toupper(removed)
[09:31:11.950]                 for (kk in seq_along(NAMES)) {
[09:31:11.950]                   name <- removed[[kk]]
[09:31:11.950]                   NAME <- NAMES[[kk]]
[09:31:11.950]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.950]                     next
[09:31:11.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.950]                 }
[09:31:11.950]                 if (length(args) > 0) 
[09:31:11.950]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.950]             }
[09:31:11.950]             else {
[09:31:11.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.950]             }
[09:31:11.950]             {
[09:31:11.950]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.950]                   0L) {
[09:31:11.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.950]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.950]                   base::options(opts)
[09:31:11.950]                 }
[09:31:11.950]                 {
[09:31:11.950]                   {
[09:31:11.950]                     NULL
[09:31:11.950]                     RNGkind("Mersenne-Twister")
[09:31:11.950]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.950]                       inherits = FALSE)
[09:31:11.950]                   }
[09:31:11.950]                   options(future.plan = NULL)
[09:31:11.950]                   if (is.na(NA_character_)) 
[09:31:11.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.950]                     .init = FALSE)
[09:31:11.950]                 }
[09:31:11.950]             }
[09:31:11.950]         }
[09:31:11.950]     })
[09:31:11.950]     if (TRUE) {
[09:31:11.950]         base::sink(type = "output", split = FALSE)
[09:31:11.950]         if (TRUE) {
[09:31:11.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.950]         }
[09:31:11.950]         else {
[09:31:11.950]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.950]         }
[09:31:11.950]         base::close(...future.stdout)
[09:31:11.950]         ...future.stdout <- NULL
[09:31:11.950]     }
[09:31:11.950]     ...future.result$conditions <- ...future.conditions
[09:31:11.950]     ...future.result$finished <- base::Sys.time()
[09:31:11.950]     ...future.result
[09:31:11.950] }
[09:31:11.952] plan(): Setting new future strategy stack:
[09:31:11.952] List of future strategies:
[09:31:11.952] 1. sequential:
[09:31:11.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.952]    - tweaked: FALSE
[09:31:11.952]    - call: NULL
[09:31:11.952] plan(): nbrOfWorkers() = 1
[09:31:11.953] plan(): Setting new future strategy stack:
[09:31:11.953] List of future strategies:
[09:31:11.953] 1. sequential:
[09:31:11.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.953]    - tweaked: FALSE
[09:31:11.953]    - call: plan(strategy)
[09:31:11.954] plan(): nbrOfWorkers() = 1
[09:31:11.954] SequentialFuture started (and completed)
[09:31:11.954] - Launch lazy future ... done
[09:31:11.954] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3ca699730> 
Classes 'listenv', 'environment' <environment: 0x55a3c947b258> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[09:31:11.957] resolved() for ‘SequentialFuture’ ...
[09:31:11.957] - state: ‘finished’
[09:31:11.957] - run: TRUE
[09:31:11.958] - result: ‘FutureResult’
[09:31:11.958] resolved() for ‘SequentialFuture’ ... done
[09:31:11.958] resolved() for ‘SequentialFuture’ ...
[09:31:11.958] - state: ‘finished’
[09:31:11.958] - run: TRUE
[09:31:11.958] - result: ‘FutureResult’
[09:31:11.958] resolved() for ‘SequentialFuture’ ... done
[09:31:11.958] resolved() for ‘SequentialFuture’ ...
[09:31:11.958] - state: ‘finished’
[09:31:11.958] - run: TRUE
[09:31:11.958] - result: ‘FutureResult’
[09:31:11.958] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:11.961] resolve() on list environment ...
[09:31:11.961]  recursive: 0
[09:31:11.962]  length: 6
[09:31:11.962]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:11.962] signalConditionsASAP(numeric, pos=1) ...
[09:31:11.962] - nx: 6
[09:31:11.962] - relay: TRUE
[09:31:11.962] - stdout: TRUE
[09:31:11.962] - signal: TRUE
[09:31:11.962] - resignal: FALSE
[09:31:11.962] - force: TRUE
[09:31:11.962] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.962] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.962]  - until=2
[09:31:11.963]  - relaying element #2
[09:31:11.963] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.963] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.963] signalConditionsASAP(NULL, pos=1) ... done
[09:31:11.963]  length: 5 (resolved future 1)
[09:31:11.963] resolved() for ‘SequentialFuture’ ...
[09:31:11.963] - state: ‘finished’
[09:31:11.963] - run: TRUE
[09:31:11.963] - result: ‘FutureResult’
[09:31:11.963] resolved() for ‘SequentialFuture’ ... done
[09:31:11.963] Future #2
[09:31:11.964] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:11.964] - nx: 6
[09:31:11.964] - relay: TRUE
[09:31:11.964] - stdout: TRUE
[09:31:11.964] - signal: TRUE
[09:31:11.964] - resignal: FALSE
[09:31:11.964] - force: TRUE
[09:31:11.964] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.964] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:11.964]  - until=2
[09:31:11.964]  - relaying element #2
[09:31:11.965] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.965] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.965] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:11.965]  length: 4 (resolved future 2)
[09:31:11.965] resolved() for ‘SequentialFuture’ ...
[09:31:11.965] - state: ‘finished’
[09:31:11.965] - run: TRUE
[09:31:11.965] - result: ‘FutureResult’
[09:31:11.965] resolved() for ‘SequentialFuture’ ... done
[09:31:11.965] Future #3
[09:31:11.965] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:11.966] - nx: 6
[09:31:11.966] - relay: TRUE
[09:31:11.966] - stdout: TRUE
[09:31:11.966] - signal: TRUE
[09:31:11.966] - resignal: FALSE
[09:31:11.966] - force: TRUE
[09:31:11.966] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.966] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:11.966]  - until=3
[09:31:11.966]  - relaying element #3
[09:31:11.966] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.966] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.967] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:11.967]  length: 3 (resolved future 3)
[09:31:11.967] resolved() for ‘SequentialFuture’ ...
[09:31:11.967] - state: ‘finished’
[09:31:11.967] - run: TRUE
[09:31:11.967] - result: ‘FutureResult’
[09:31:11.967] resolved() for ‘SequentialFuture’ ... done
[09:31:11.967] Future #4
[09:31:11.967] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:11.967] - nx: 6
[09:31:11.967] - relay: TRUE
[09:31:11.968] - stdout: TRUE
[09:31:11.968] - signal: TRUE
[09:31:11.968] - resignal: FALSE
[09:31:11.968] - force: TRUE
[09:31:11.968] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:11.968]  - until=4
[09:31:11.968]  - relaying element #4
[09:31:11.968] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.968] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.968] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:11.969]  length: 2 (resolved future 4)
[09:31:11.969] signalConditionsASAP(NULL, pos=5) ...
[09:31:11.992] - nx: 6
[09:31:11.992] - relay: TRUE
[09:31:11.992] - stdout: TRUE
[09:31:11.992] - signal: TRUE
[09:31:11.992] - resignal: FALSE
[09:31:11.992] - force: TRUE
[09:31:11.992] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.992] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.993]  - until=6
[09:31:11.993]  - relaying element #6
[09:31:11.993] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.993] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.993] signalConditionsASAP(NULL, pos=5) ... done
[09:31:11.993]  length: 1 (resolved future 5)
[09:31:11.993] signalConditionsASAP(numeric, pos=6) ...
[09:31:11.993] - nx: 6
[09:31:11.993] - relay: TRUE
[09:31:11.994] - stdout: TRUE
[09:31:11.994] - signal: TRUE
[09:31:11.994] - resignal: FALSE
[09:31:11.994] - force: TRUE
[09:31:11.994] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:11.994] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.994]  - until=6
[09:31:11.994] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.994] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.994] signalConditionsASAP(numeric, pos=6) ... done
[09:31:11.994]  length: 0 (resolved future 6)
[09:31:11.994] Relaying remaining futures
[09:31:11.995] signalConditionsASAP(NULL, pos=0) ...
[09:31:11.995] - nx: 6
[09:31:11.995] - relay: TRUE
[09:31:11.995] - stdout: TRUE
[09:31:11.995] - signal: TRUE
[09:31:11.995] - resignal: FALSE
[09:31:11.995] - force: TRUE
[09:31:11.995] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.995] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:11.995] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:11.995] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:11.995] signalConditionsASAP(NULL, pos=0) ... done
[09:31:11.996] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a3cab52ab8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:11.998] getGlobalsAndPackages() ...
[09:31:11.998] Searching for globals...
[09:31:11.998] 
[09:31:11.998] Searching for globals ... DONE
[09:31:11.998] - globals: [0] <none>
[09:31:11.998] getGlobalsAndPackages() ... DONE
[09:31:11.998] run() for ‘Future’ ...
[09:31:11.999] - state: ‘created’
[09:31:11.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.999]   - Field: ‘label’
[09:31:11.999]   - Field: ‘local’
[09:31:11.999]   - Field: ‘owner’
[09:31:11.999]   - Field: ‘envir’
[09:31:11.999]   - Field: ‘packages’
[09:31:12.000]   - Field: ‘gc’
[09:31:12.000]   - Field: ‘conditions’
[09:31:12.000]   - Field: ‘expr’
[09:31:12.000]   - Field: ‘uuid’
[09:31:12.000]   - Field: ‘seed’
[09:31:12.000]   - Field: ‘version’
[09:31:12.000]   - Field: ‘result’
[09:31:12.000]   - Field: ‘asynchronous’
[09:31:12.000]   - Field: ‘calls’
[09:31:12.000]   - Field: ‘globals’
[09:31:12.000]   - Field: ‘stdout’
[09:31:12.000]   - Field: ‘earlySignal’
[09:31:12.001]   - Field: ‘lazy’
[09:31:12.001]   - Field: ‘state’
[09:31:12.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.001] - Launch lazy future ...
[09:31:12.001] Packages needed by the future expression (n = 0): <none>
[09:31:12.001] Packages needed by future strategies (n = 0): <none>
[09:31:12.002] {
[09:31:12.002]     {
[09:31:12.002]         {
[09:31:12.002]             ...future.startTime <- base::Sys.time()
[09:31:12.002]             {
[09:31:12.002]                 {
[09:31:12.002]                   {
[09:31:12.002]                     base::local({
[09:31:12.002]                       has_future <- base::requireNamespace("future", 
[09:31:12.002]                         quietly = TRUE)
[09:31:12.002]                       if (has_future) {
[09:31:12.002]                         ns <- base::getNamespace("future")
[09:31:12.002]                         version <- ns[[".package"]][["version"]]
[09:31:12.002]                         if (is.null(version)) 
[09:31:12.002]                           version <- utils::packageVersion("future")
[09:31:12.002]                       }
[09:31:12.002]                       else {
[09:31:12.002]                         version <- NULL
[09:31:12.002]                       }
[09:31:12.002]                       if (!has_future || version < "1.8.0") {
[09:31:12.002]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.002]                           "", base::R.version$version.string), 
[09:31:12.002]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.002]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.002]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.002]                             "release", "version")], collapse = " "), 
[09:31:12.002]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.002]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.002]                           info)
[09:31:12.002]                         info <- base::paste(info, collapse = "; ")
[09:31:12.002]                         if (!has_future) {
[09:31:12.002]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.002]                             info)
[09:31:12.002]                         }
[09:31:12.002]                         else {
[09:31:12.002]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.002]                             info, version)
[09:31:12.002]                         }
[09:31:12.002]                         base::stop(msg)
[09:31:12.002]                       }
[09:31:12.002]                     })
[09:31:12.002]                   }
[09:31:12.002]                   ...future.strategy.old <- future::plan("list")
[09:31:12.002]                   options(future.plan = NULL)
[09:31:12.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.002]                 }
[09:31:12.002]                 ...future.workdir <- getwd()
[09:31:12.002]             }
[09:31:12.002]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.002]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.002]         }
[09:31:12.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.002]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.002]             base::names(...future.oldOptions))
[09:31:12.002]     }
[09:31:12.002]     if (FALSE) {
[09:31:12.002]     }
[09:31:12.002]     else {
[09:31:12.002]         if (TRUE) {
[09:31:12.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.002]                 open = "w")
[09:31:12.002]         }
[09:31:12.002]         else {
[09:31:12.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.002]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.002]         }
[09:31:12.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.002]             base::sink(type = "output", split = FALSE)
[09:31:12.002]             base::close(...future.stdout)
[09:31:12.002]         }, add = TRUE)
[09:31:12.002]     }
[09:31:12.002]     ...future.frame <- base::sys.nframe()
[09:31:12.002]     ...future.conditions <- base::list()
[09:31:12.002]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.002]     if (FALSE) {
[09:31:12.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.002]     }
[09:31:12.002]     ...future.result <- base::tryCatch({
[09:31:12.002]         base::withCallingHandlers({
[09:31:12.002]             ...future.value <- base::withVisible(base::local(2))
[09:31:12.002]             future::FutureResult(value = ...future.value$value, 
[09:31:12.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.002]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.002]                     ...future.globalenv.names))
[09:31:12.002]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.002]         }, condition = base::local({
[09:31:12.002]             c <- base::c
[09:31:12.002]             inherits <- base::inherits
[09:31:12.002]             invokeRestart <- base::invokeRestart
[09:31:12.002]             length <- base::length
[09:31:12.002]             list <- base::list
[09:31:12.002]             seq.int <- base::seq.int
[09:31:12.002]             signalCondition <- base::signalCondition
[09:31:12.002]             sys.calls <- base::sys.calls
[09:31:12.002]             `[[` <- base::`[[`
[09:31:12.002]             `+` <- base::`+`
[09:31:12.002]             `<<-` <- base::`<<-`
[09:31:12.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.002]                   3L)]
[09:31:12.002]             }
[09:31:12.002]             function(cond) {
[09:31:12.002]                 is_error <- inherits(cond, "error")
[09:31:12.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.002]                   NULL)
[09:31:12.002]                 if (is_error) {
[09:31:12.002]                   sessionInformation <- function() {
[09:31:12.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.002]                       search = base::search(), system = base::Sys.info())
[09:31:12.002]                   }
[09:31:12.002]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.002]                     cond$call), session = sessionInformation(), 
[09:31:12.002]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.002]                   signalCondition(cond)
[09:31:12.002]                 }
[09:31:12.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.002]                 "immediateCondition"))) {
[09:31:12.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.002]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.002]                   if (TRUE && !signal) {
[09:31:12.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.002]                     {
[09:31:12.002]                       inherits <- base::inherits
[09:31:12.002]                       invokeRestart <- base::invokeRestart
[09:31:12.002]                       is.null <- base::is.null
[09:31:12.002]                       muffled <- FALSE
[09:31:12.002]                       if (inherits(cond, "message")) {
[09:31:12.002]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.002]                         if (muffled) 
[09:31:12.002]                           invokeRestart("muffleMessage")
[09:31:12.002]                       }
[09:31:12.002]                       else if (inherits(cond, "warning")) {
[09:31:12.002]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.002]                         if (muffled) 
[09:31:12.002]                           invokeRestart("muffleWarning")
[09:31:12.002]                       }
[09:31:12.002]                       else if (inherits(cond, "condition")) {
[09:31:12.002]                         if (!is.null(pattern)) {
[09:31:12.002]                           computeRestarts <- base::computeRestarts
[09:31:12.002]                           grepl <- base::grepl
[09:31:12.002]                           restarts <- computeRestarts(cond)
[09:31:12.002]                           for (restart in restarts) {
[09:31:12.002]                             name <- restart$name
[09:31:12.002]                             if (is.null(name)) 
[09:31:12.002]                               next
[09:31:12.002]                             if (!grepl(pattern, name)) 
[09:31:12.002]                               next
[09:31:12.002]                             invokeRestart(restart)
[09:31:12.002]                             muffled <- TRUE
[09:31:12.002]                             break
[09:31:12.002]                           }
[09:31:12.002]                         }
[09:31:12.002]                       }
[09:31:12.002]                       invisible(muffled)
[09:31:12.002]                     }
[09:31:12.002]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.002]                   }
[09:31:12.002]                 }
[09:31:12.002]                 else {
[09:31:12.002]                   if (TRUE) {
[09:31:12.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.002]                     {
[09:31:12.002]                       inherits <- base::inherits
[09:31:12.002]                       invokeRestart <- base::invokeRestart
[09:31:12.002]                       is.null <- base::is.null
[09:31:12.002]                       muffled <- FALSE
[09:31:12.002]                       if (inherits(cond, "message")) {
[09:31:12.002]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.002]                         if (muffled) 
[09:31:12.002]                           invokeRestart("muffleMessage")
[09:31:12.002]                       }
[09:31:12.002]                       else if (inherits(cond, "warning")) {
[09:31:12.002]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.002]                         if (muffled) 
[09:31:12.002]                           invokeRestart("muffleWarning")
[09:31:12.002]                       }
[09:31:12.002]                       else if (inherits(cond, "condition")) {
[09:31:12.002]                         if (!is.null(pattern)) {
[09:31:12.002]                           computeRestarts <- base::computeRestarts
[09:31:12.002]                           grepl <- base::grepl
[09:31:12.002]                           restarts <- computeRestarts(cond)
[09:31:12.002]                           for (restart in restarts) {
[09:31:12.002]                             name <- restart$name
[09:31:12.002]                             if (is.null(name)) 
[09:31:12.002]                               next
[09:31:12.002]                             if (!grepl(pattern, name)) 
[09:31:12.002]                               next
[09:31:12.002]                             invokeRestart(restart)
[09:31:12.002]                             muffled <- TRUE
[09:31:12.002]                             break
[09:31:12.002]                           }
[09:31:12.002]                         }
[09:31:12.002]                       }
[09:31:12.002]                       invisible(muffled)
[09:31:12.002]                     }
[09:31:12.002]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.002]                   }
[09:31:12.002]                 }
[09:31:12.002]             }
[09:31:12.002]         }))
[09:31:12.002]     }, error = function(ex) {
[09:31:12.002]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.002]                 ...future.rng), started = ...future.startTime, 
[09:31:12.002]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.002]             version = "1.8"), class = "FutureResult")
[09:31:12.002]     }, finally = {
[09:31:12.002]         if (!identical(...future.workdir, getwd())) 
[09:31:12.002]             setwd(...future.workdir)
[09:31:12.002]         {
[09:31:12.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.002]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.002]             }
[09:31:12.002]             base::options(...future.oldOptions)
[09:31:12.002]             if (.Platform$OS.type == "windows") {
[09:31:12.002]                 old_names <- names(...future.oldEnvVars)
[09:31:12.002]                 envs <- base::Sys.getenv()
[09:31:12.002]                 names <- names(envs)
[09:31:12.002]                 common <- intersect(names, old_names)
[09:31:12.002]                 added <- setdiff(names, old_names)
[09:31:12.002]                 removed <- setdiff(old_names, names)
[09:31:12.002]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.002]                   envs[common]]
[09:31:12.002]                 NAMES <- toupper(changed)
[09:31:12.002]                 args <- list()
[09:31:12.002]                 for (kk in seq_along(NAMES)) {
[09:31:12.002]                   name <- changed[[kk]]
[09:31:12.002]                   NAME <- NAMES[[kk]]
[09:31:12.002]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.002]                     next
[09:31:12.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.002]                 }
[09:31:12.002]                 NAMES <- toupper(added)
[09:31:12.002]                 for (kk in seq_along(NAMES)) {
[09:31:12.002]                   name <- added[[kk]]
[09:31:12.002]                   NAME <- NAMES[[kk]]
[09:31:12.002]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.002]                     next
[09:31:12.002]                   args[[name]] <- ""
[09:31:12.002]                 }
[09:31:12.002]                 NAMES <- toupper(removed)
[09:31:12.002]                 for (kk in seq_along(NAMES)) {
[09:31:12.002]                   name <- removed[[kk]]
[09:31:12.002]                   NAME <- NAMES[[kk]]
[09:31:12.002]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.002]                     next
[09:31:12.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.002]                 }
[09:31:12.002]                 if (length(args) > 0) 
[09:31:12.002]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.002]             }
[09:31:12.002]             else {
[09:31:12.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.002]             }
[09:31:12.002]             {
[09:31:12.002]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.002]                   0L) {
[09:31:12.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.002]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.002]                   base::options(opts)
[09:31:12.002]                 }
[09:31:12.002]                 {
[09:31:12.002]                   {
[09:31:12.002]                     NULL
[09:31:12.002]                     RNGkind("Mersenne-Twister")
[09:31:12.002]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.002]                       inherits = FALSE)
[09:31:12.002]                   }
[09:31:12.002]                   options(future.plan = NULL)
[09:31:12.002]                   if (is.na(NA_character_)) 
[09:31:12.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.002]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.002]                     .init = FALSE)
[09:31:12.002]                 }
[09:31:12.002]             }
[09:31:12.002]         }
[09:31:12.002]     })
[09:31:12.002]     if (TRUE) {
[09:31:12.002]         base::sink(type = "output", split = FALSE)
[09:31:12.002]         if (TRUE) {
[09:31:12.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.002]         }
[09:31:12.002]         else {
[09:31:12.002]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.002]         }
[09:31:12.002]         base::close(...future.stdout)
[09:31:12.002]         ...future.stdout <- NULL
[09:31:12.002]     }
[09:31:12.002]     ...future.result$conditions <- ...future.conditions
[09:31:12.002]     ...future.result$finished <- base::Sys.time()
[09:31:12.002]     ...future.result
[09:31:12.002] }
[09:31:12.003] plan(): Setting new future strategy stack:
[09:31:12.003] List of future strategies:
[09:31:12.003] 1. sequential:
[09:31:12.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.003]    - tweaked: FALSE
[09:31:12.003]    - call: NULL
[09:31:12.004] plan(): nbrOfWorkers() = 1
[09:31:12.004] plan(): Setting new future strategy stack:
[09:31:12.005] List of future strategies:
[09:31:12.005] 1. sequential:
[09:31:12.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.005]    - tweaked: FALSE
[09:31:12.005]    - call: plan(strategy)
[09:31:12.005] plan(): nbrOfWorkers() = 1
[09:31:12.005] SequentialFuture started (and completed)
[09:31:12.005] - Launch lazy future ... done
[09:31:12.005] run() for ‘SequentialFuture’ ... done
[09:31:12.005] getGlobalsAndPackages() ...
[09:31:12.006] Searching for globals...
[09:31:12.006] 
[09:31:12.006] Searching for globals ... DONE
[09:31:12.006] - globals: [0] <none>
[09:31:12.006] getGlobalsAndPackages() ... DONE
[09:31:12.006] run() for ‘Future’ ...
[09:31:12.006] - state: ‘created’
[09:31:12.007] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.007] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.007]   - Field: ‘label’
[09:31:12.007]   - Field: ‘local’
[09:31:12.007]   - Field: ‘owner’
[09:31:12.007]   - Field: ‘envir’
[09:31:12.007]   - Field: ‘packages’
[09:31:12.007]   - Field: ‘gc’
[09:31:12.008]   - Field: ‘conditions’
[09:31:12.008]   - Field: ‘expr’
[09:31:12.008]   - Field: ‘uuid’
[09:31:12.008]   - Field: ‘seed’
[09:31:12.008]   - Field: ‘version’
[09:31:12.008]   - Field: ‘result’
[09:31:12.008]   - Field: ‘asynchronous’
[09:31:12.008]   - Field: ‘calls’
[09:31:12.008]   - Field: ‘globals’
[09:31:12.008]   - Field: ‘stdout’
[09:31:12.008]   - Field: ‘earlySignal’
[09:31:12.008]   - Field: ‘lazy’
[09:31:12.009]   - Field: ‘state’
[09:31:12.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.009] - Launch lazy future ...
[09:31:12.009] Packages needed by the future expression (n = 0): <none>
[09:31:12.009] Packages needed by future strategies (n = 0): <none>
[09:31:12.009] {
[09:31:12.009]     {
[09:31:12.009]         {
[09:31:12.009]             ...future.startTime <- base::Sys.time()
[09:31:12.009]             {
[09:31:12.009]                 {
[09:31:12.009]                   {
[09:31:12.009]                     base::local({
[09:31:12.009]                       has_future <- base::requireNamespace("future", 
[09:31:12.009]                         quietly = TRUE)
[09:31:12.009]                       if (has_future) {
[09:31:12.009]                         ns <- base::getNamespace("future")
[09:31:12.009]                         version <- ns[[".package"]][["version"]]
[09:31:12.009]                         if (is.null(version)) 
[09:31:12.009]                           version <- utils::packageVersion("future")
[09:31:12.009]                       }
[09:31:12.009]                       else {
[09:31:12.009]                         version <- NULL
[09:31:12.009]                       }
[09:31:12.009]                       if (!has_future || version < "1.8.0") {
[09:31:12.009]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.009]                           "", base::R.version$version.string), 
[09:31:12.009]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.009]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.009]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.009]                             "release", "version")], collapse = " "), 
[09:31:12.009]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.009]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.009]                           info)
[09:31:12.009]                         info <- base::paste(info, collapse = "; ")
[09:31:12.009]                         if (!has_future) {
[09:31:12.009]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.009]                             info)
[09:31:12.009]                         }
[09:31:12.009]                         else {
[09:31:12.009]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.009]                             info, version)
[09:31:12.009]                         }
[09:31:12.009]                         base::stop(msg)
[09:31:12.009]                       }
[09:31:12.009]                     })
[09:31:12.009]                   }
[09:31:12.009]                   ...future.strategy.old <- future::plan("list")
[09:31:12.009]                   options(future.plan = NULL)
[09:31:12.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.009]                 }
[09:31:12.009]                 ...future.workdir <- getwd()
[09:31:12.009]             }
[09:31:12.009]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.009]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.009]         }
[09:31:12.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.009]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.009]             base::names(...future.oldOptions))
[09:31:12.009]     }
[09:31:12.009]     if (FALSE) {
[09:31:12.009]     }
[09:31:12.009]     else {
[09:31:12.009]         if (TRUE) {
[09:31:12.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.009]                 open = "w")
[09:31:12.009]         }
[09:31:12.009]         else {
[09:31:12.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.009]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.009]         }
[09:31:12.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.009]             base::sink(type = "output", split = FALSE)
[09:31:12.009]             base::close(...future.stdout)
[09:31:12.009]         }, add = TRUE)
[09:31:12.009]     }
[09:31:12.009]     ...future.frame <- base::sys.nframe()
[09:31:12.009]     ...future.conditions <- base::list()
[09:31:12.009]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.009]     if (FALSE) {
[09:31:12.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.009]     }
[09:31:12.009]     ...future.result <- base::tryCatch({
[09:31:12.009]         base::withCallingHandlers({
[09:31:12.009]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:12.009]             future::FutureResult(value = ...future.value$value, 
[09:31:12.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.009]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.009]                     ...future.globalenv.names))
[09:31:12.009]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.009]         }, condition = base::local({
[09:31:12.009]             c <- base::c
[09:31:12.009]             inherits <- base::inherits
[09:31:12.009]             invokeRestart <- base::invokeRestart
[09:31:12.009]             length <- base::length
[09:31:12.009]             list <- base::list
[09:31:12.009]             seq.int <- base::seq.int
[09:31:12.009]             signalCondition <- base::signalCondition
[09:31:12.009]             sys.calls <- base::sys.calls
[09:31:12.009]             `[[` <- base::`[[`
[09:31:12.009]             `+` <- base::`+`
[09:31:12.009]             `<<-` <- base::`<<-`
[09:31:12.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.009]                   3L)]
[09:31:12.009]             }
[09:31:12.009]             function(cond) {
[09:31:12.009]                 is_error <- inherits(cond, "error")
[09:31:12.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.009]                   NULL)
[09:31:12.009]                 if (is_error) {
[09:31:12.009]                   sessionInformation <- function() {
[09:31:12.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.009]                       search = base::search(), system = base::Sys.info())
[09:31:12.009]                   }
[09:31:12.009]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.009]                     cond$call), session = sessionInformation(), 
[09:31:12.009]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.009]                   signalCondition(cond)
[09:31:12.009]                 }
[09:31:12.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.009]                 "immediateCondition"))) {
[09:31:12.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.009]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.009]                   if (TRUE && !signal) {
[09:31:12.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.009]                     {
[09:31:12.009]                       inherits <- base::inherits
[09:31:12.009]                       invokeRestart <- base::invokeRestart
[09:31:12.009]                       is.null <- base::is.null
[09:31:12.009]                       muffled <- FALSE
[09:31:12.009]                       if (inherits(cond, "message")) {
[09:31:12.009]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.009]                         if (muffled) 
[09:31:12.009]                           invokeRestart("muffleMessage")
[09:31:12.009]                       }
[09:31:12.009]                       else if (inherits(cond, "warning")) {
[09:31:12.009]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.009]                         if (muffled) 
[09:31:12.009]                           invokeRestart("muffleWarning")
[09:31:12.009]                       }
[09:31:12.009]                       else if (inherits(cond, "condition")) {
[09:31:12.009]                         if (!is.null(pattern)) {
[09:31:12.009]                           computeRestarts <- base::computeRestarts
[09:31:12.009]                           grepl <- base::grepl
[09:31:12.009]                           restarts <- computeRestarts(cond)
[09:31:12.009]                           for (restart in restarts) {
[09:31:12.009]                             name <- restart$name
[09:31:12.009]                             if (is.null(name)) 
[09:31:12.009]                               next
[09:31:12.009]                             if (!grepl(pattern, name)) 
[09:31:12.009]                               next
[09:31:12.009]                             invokeRestart(restart)
[09:31:12.009]                             muffled <- TRUE
[09:31:12.009]                             break
[09:31:12.009]                           }
[09:31:12.009]                         }
[09:31:12.009]                       }
[09:31:12.009]                       invisible(muffled)
[09:31:12.009]                     }
[09:31:12.009]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.009]                   }
[09:31:12.009]                 }
[09:31:12.009]                 else {
[09:31:12.009]                   if (TRUE) {
[09:31:12.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.009]                     {
[09:31:12.009]                       inherits <- base::inherits
[09:31:12.009]                       invokeRestart <- base::invokeRestart
[09:31:12.009]                       is.null <- base::is.null
[09:31:12.009]                       muffled <- FALSE
[09:31:12.009]                       if (inherits(cond, "message")) {
[09:31:12.009]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.009]                         if (muffled) 
[09:31:12.009]                           invokeRestart("muffleMessage")
[09:31:12.009]                       }
[09:31:12.009]                       else if (inherits(cond, "warning")) {
[09:31:12.009]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.009]                         if (muffled) 
[09:31:12.009]                           invokeRestart("muffleWarning")
[09:31:12.009]                       }
[09:31:12.009]                       else if (inherits(cond, "condition")) {
[09:31:12.009]                         if (!is.null(pattern)) {
[09:31:12.009]                           computeRestarts <- base::computeRestarts
[09:31:12.009]                           grepl <- base::grepl
[09:31:12.009]                           restarts <- computeRestarts(cond)
[09:31:12.009]                           for (restart in restarts) {
[09:31:12.009]                             name <- restart$name
[09:31:12.009]                             if (is.null(name)) 
[09:31:12.009]                               next
[09:31:12.009]                             if (!grepl(pattern, name)) 
[09:31:12.009]                               next
[09:31:12.009]                             invokeRestart(restart)
[09:31:12.009]                             muffled <- TRUE
[09:31:12.009]                             break
[09:31:12.009]                           }
[09:31:12.009]                         }
[09:31:12.009]                       }
[09:31:12.009]                       invisible(muffled)
[09:31:12.009]                     }
[09:31:12.009]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.009]                   }
[09:31:12.009]                 }
[09:31:12.009]             }
[09:31:12.009]         }))
[09:31:12.009]     }, error = function(ex) {
[09:31:12.009]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.009]                 ...future.rng), started = ...future.startTime, 
[09:31:12.009]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.009]             version = "1.8"), class = "FutureResult")
[09:31:12.009]     }, finally = {
[09:31:12.009]         if (!identical(...future.workdir, getwd())) 
[09:31:12.009]             setwd(...future.workdir)
[09:31:12.009]         {
[09:31:12.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.009]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.009]             }
[09:31:12.009]             base::options(...future.oldOptions)
[09:31:12.009]             if (.Platform$OS.type == "windows") {
[09:31:12.009]                 old_names <- names(...future.oldEnvVars)
[09:31:12.009]                 envs <- base::Sys.getenv()
[09:31:12.009]                 names <- names(envs)
[09:31:12.009]                 common <- intersect(names, old_names)
[09:31:12.009]                 added <- setdiff(names, old_names)
[09:31:12.009]                 removed <- setdiff(old_names, names)
[09:31:12.009]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.009]                   envs[common]]
[09:31:12.009]                 NAMES <- toupper(changed)
[09:31:12.009]                 args <- list()
[09:31:12.009]                 for (kk in seq_along(NAMES)) {
[09:31:12.009]                   name <- changed[[kk]]
[09:31:12.009]                   NAME <- NAMES[[kk]]
[09:31:12.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.009]                     next
[09:31:12.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.009]                 }
[09:31:12.009]                 NAMES <- toupper(added)
[09:31:12.009]                 for (kk in seq_along(NAMES)) {
[09:31:12.009]                   name <- added[[kk]]
[09:31:12.009]                   NAME <- NAMES[[kk]]
[09:31:12.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.009]                     next
[09:31:12.009]                   args[[name]] <- ""
[09:31:12.009]                 }
[09:31:12.009]                 NAMES <- toupper(removed)
[09:31:12.009]                 for (kk in seq_along(NAMES)) {
[09:31:12.009]                   name <- removed[[kk]]
[09:31:12.009]                   NAME <- NAMES[[kk]]
[09:31:12.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.009]                     next
[09:31:12.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.009]                 }
[09:31:12.009]                 if (length(args) > 0) 
[09:31:12.009]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.009]             }
[09:31:12.009]             else {
[09:31:12.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.009]             }
[09:31:12.009]             {
[09:31:12.009]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.009]                   0L) {
[09:31:12.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.009]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.009]                   base::options(opts)
[09:31:12.009]                 }
[09:31:12.009]                 {
[09:31:12.009]                   {
[09:31:12.009]                     NULL
[09:31:12.009]                     RNGkind("Mersenne-Twister")
[09:31:12.009]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.009]                       inherits = FALSE)
[09:31:12.009]                   }
[09:31:12.009]                   options(future.plan = NULL)
[09:31:12.009]                   if (is.na(NA_character_)) 
[09:31:12.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.009]                     .init = FALSE)
[09:31:12.009]                 }
[09:31:12.009]             }
[09:31:12.009]         }
[09:31:12.009]     })
[09:31:12.009]     if (TRUE) {
[09:31:12.009]         base::sink(type = "output", split = FALSE)
[09:31:12.009]         if (TRUE) {
[09:31:12.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.009]         }
[09:31:12.009]         else {
[09:31:12.009]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.009]         }
[09:31:12.009]         base::close(...future.stdout)
[09:31:12.009]         ...future.stdout <- NULL
[09:31:12.009]     }
[09:31:12.009]     ...future.result$conditions <- ...future.conditions
[09:31:12.009]     ...future.result$finished <- base::Sys.time()
[09:31:12.009]     ...future.result
[09:31:12.009] }
[09:31:12.011] plan(): Setting new future strategy stack:
[09:31:12.011] List of future strategies:
[09:31:12.011] 1. sequential:
[09:31:12.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.011]    - tweaked: FALSE
[09:31:12.011]    - call: NULL
[09:31:12.012] plan(): nbrOfWorkers() = 1
[09:31:12.012] plan(): Setting new future strategy stack:
[09:31:12.012] List of future strategies:
[09:31:12.012] 1. sequential:
[09:31:12.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.012]    - tweaked: FALSE
[09:31:12.012]    - call: plan(strategy)
[09:31:12.013] plan(): nbrOfWorkers() = 1
[09:31:12.013] SequentialFuture started (and completed)
[09:31:12.013] - Launch lazy future ... done
[09:31:12.013] run() for ‘SequentialFuture’ ... done
[09:31:12.013] getGlobalsAndPackages() ...
[09:31:12.014] Searching for globals...
[09:31:12.014] - globals found: [1] ‘{’
[09:31:12.014] Searching for globals ... DONE
[09:31:12.014] Resolving globals: FALSE
[09:31:12.015] 
[09:31:12.015] 
[09:31:12.015] getGlobalsAndPackages() ... DONE
[09:31:12.015] run() for ‘Future’ ...
[09:31:12.015] - state: ‘created’
[09:31:12.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.016]   - Field: ‘label’
[09:31:12.016]   - Field: ‘local’
[09:31:12.016]   - Field: ‘owner’
[09:31:12.016]   - Field: ‘envir’
[09:31:12.016]   - Field: ‘packages’
[09:31:12.016]   - Field: ‘gc’
[09:31:12.016]   - Field: ‘conditions’
[09:31:12.016]   - Field: ‘expr’
[09:31:12.016]   - Field: ‘uuid’
[09:31:12.016]   - Field: ‘seed’
[09:31:12.017]   - Field: ‘version’
[09:31:12.017]   - Field: ‘result’
[09:31:12.017]   - Field: ‘asynchronous’
[09:31:12.017]   - Field: ‘calls’
[09:31:12.017]   - Field: ‘globals’
[09:31:12.017]   - Field: ‘stdout’
[09:31:12.017]   - Field: ‘earlySignal’
[09:31:12.017]   - Field: ‘lazy’
[09:31:12.017]   - Field: ‘state’
[09:31:12.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.017] - Launch lazy future ...
[09:31:12.018] Packages needed by the future expression (n = 0): <none>
[09:31:12.018] Packages needed by future strategies (n = 0): <none>
[09:31:12.018] {
[09:31:12.018]     {
[09:31:12.018]         {
[09:31:12.018]             ...future.startTime <- base::Sys.time()
[09:31:12.018]             {
[09:31:12.018]                 {
[09:31:12.018]                   {
[09:31:12.018]                     base::local({
[09:31:12.018]                       has_future <- base::requireNamespace("future", 
[09:31:12.018]                         quietly = TRUE)
[09:31:12.018]                       if (has_future) {
[09:31:12.018]                         ns <- base::getNamespace("future")
[09:31:12.018]                         version <- ns[[".package"]][["version"]]
[09:31:12.018]                         if (is.null(version)) 
[09:31:12.018]                           version <- utils::packageVersion("future")
[09:31:12.018]                       }
[09:31:12.018]                       else {
[09:31:12.018]                         version <- NULL
[09:31:12.018]                       }
[09:31:12.018]                       if (!has_future || version < "1.8.0") {
[09:31:12.018]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.018]                           "", base::R.version$version.string), 
[09:31:12.018]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.018]                             "release", "version")], collapse = " "), 
[09:31:12.018]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.018]                           info)
[09:31:12.018]                         info <- base::paste(info, collapse = "; ")
[09:31:12.018]                         if (!has_future) {
[09:31:12.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.018]                             info)
[09:31:12.018]                         }
[09:31:12.018]                         else {
[09:31:12.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.018]                             info, version)
[09:31:12.018]                         }
[09:31:12.018]                         base::stop(msg)
[09:31:12.018]                       }
[09:31:12.018]                     })
[09:31:12.018]                   }
[09:31:12.018]                   ...future.strategy.old <- future::plan("list")
[09:31:12.018]                   options(future.plan = NULL)
[09:31:12.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.018]                 }
[09:31:12.018]                 ...future.workdir <- getwd()
[09:31:12.018]             }
[09:31:12.018]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.018]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.018]         }
[09:31:12.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.018]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.018]             base::names(...future.oldOptions))
[09:31:12.018]     }
[09:31:12.018]     if (FALSE) {
[09:31:12.018]     }
[09:31:12.018]     else {
[09:31:12.018]         if (TRUE) {
[09:31:12.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.018]                 open = "w")
[09:31:12.018]         }
[09:31:12.018]         else {
[09:31:12.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.018]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.018]         }
[09:31:12.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.018]             base::sink(type = "output", split = FALSE)
[09:31:12.018]             base::close(...future.stdout)
[09:31:12.018]         }, add = TRUE)
[09:31:12.018]     }
[09:31:12.018]     ...future.frame <- base::sys.nframe()
[09:31:12.018]     ...future.conditions <- base::list()
[09:31:12.018]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.018]     if (FALSE) {
[09:31:12.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.018]     }
[09:31:12.018]     ...future.result <- base::tryCatch({
[09:31:12.018]         base::withCallingHandlers({
[09:31:12.018]             ...future.value <- base::withVisible(base::local({
[09:31:12.018]                 4
[09:31:12.018]             }))
[09:31:12.018]             future::FutureResult(value = ...future.value$value, 
[09:31:12.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.018]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.018]                     ...future.globalenv.names))
[09:31:12.018]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.018]         }, condition = base::local({
[09:31:12.018]             c <- base::c
[09:31:12.018]             inherits <- base::inherits
[09:31:12.018]             invokeRestart <- base::invokeRestart
[09:31:12.018]             length <- base::length
[09:31:12.018]             list <- base::list
[09:31:12.018]             seq.int <- base::seq.int
[09:31:12.018]             signalCondition <- base::signalCondition
[09:31:12.018]             sys.calls <- base::sys.calls
[09:31:12.018]             `[[` <- base::`[[`
[09:31:12.018]             `+` <- base::`+`
[09:31:12.018]             `<<-` <- base::`<<-`
[09:31:12.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.018]                   3L)]
[09:31:12.018]             }
[09:31:12.018]             function(cond) {
[09:31:12.018]                 is_error <- inherits(cond, "error")
[09:31:12.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.018]                   NULL)
[09:31:12.018]                 if (is_error) {
[09:31:12.018]                   sessionInformation <- function() {
[09:31:12.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.018]                       search = base::search(), system = base::Sys.info())
[09:31:12.018]                   }
[09:31:12.018]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.018]                     cond$call), session = sessionInformation(), 
[09:31:12.018]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.018]                   signalCondition(cond)
[09:31:12.018]                 }
[09:31:12.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.018]                 "immediateCondition"))) {
[09:31:12.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.018]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.018]                   if (TRUE && !signal) {
[09:31:12.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.018]                     {
[09:31:12.018]                       inherits <- base::inherits
[09:31:12.018]                       invokeRestart <- base::invokeRestart
[09:31:12.018]                       is.null <- base::is.null
[09:31:12.018]                       muffled <- FALSE
[09:31:12.018]                       if (inherits(cond, "message")) {
[09:31:12.018]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.018]                         if (muffled) 
[09:31:12.018]                           invokeRestart("muffleMessage")
[09:31:12.018]                       }
[09:31:12.018]                       else if (inherits(cond, "warning")) {
[09:31:12.018]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.018]                         if (muffled) 
[09:31:12.018]                           invokeRestart("muffleWarning")
[09:31:12.018]                       }
[09:31:12.018]                       else if (inherits(cond, "condition")) {
[09:31:12.018]                         if (!is.null(pattern)) {
[09:31:12.018]                           computeRestarts <- base::computeRestarts
[09:31:12.018]                           grepl <- base::grepl
[09:31:12.018]                           restarts <- computeRestarts(cond)
[09:31:12.018]                           for (restart in restarts) {
[09:31:12.018]                             name <- restart$name
[09:31:12.018]                             if (is.null(name)) 
[09:31:12.018]                               next
[09:31:12.018]                             if (!grepl(pattern, name)) 
[09:31:12.018]                               next
[09:31:12.018]                             invokeRestart(restart)
[09:31:12.018]                             muffled <- TRUE
[09:31:12.018]                             break
[09:31:12.018]                           }
[09:31:12.018]                         }
[09:31:12.018]                       }
[09:31:12.018]                       invisible(muffled)
[09:31:12.018]                     }
[09:31:12.018]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.018]                   }
[09:31:12.018]                 }
[09:31:12.018]                 else {
[09:31:12.018]                   if (TRUE) {
[09:31:12.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.018]                     {
[09:31:12.018]                       inherits <- base::inherits
[09:31:12.018]                       invokeRestart <- base::invokeRestart
[09:31:12.018]                       is.null <- base::is.null
[09:31:12.018]                       muffled <- FALSE
[09:31:12.018]                       if (inherits(cond, "message")) {
[09:31:12.018]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.018]                         if (muffled) 
[09:31:12.018]                           invokeRestart("muffleMessage")
[09:31:12.018]                       }
[09:31:12.018]                       else if (inherits(cond, "warning")) {
[09:31:12.018]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.018]                         if (muffled) 
[09:31:12.018]                           invokeRestart("muffleWarning")
[09:31:12.018]                       }
[09:31:12.018]                       else if (inherits(cond, "condition")) {
[09:31:12.018]                         if (!is.null(pattern)) {
[09:31:12.018]                           computeRestarts <- base::computeRestarts
[09:31:12.018]                           grepl <- base::grepl
[09:31:12.018]                           restarts <- computeRestarts(cond)
[09:31:12.018]                           for (restart in restarts) {
[09:31:12.018]                             name <- restart$name
[09:31:12.018]                             if (is.null(name)) 
[09:31:12.018]                               next
[09:31:12.018]                             if (!grepl(pattern, name)) 
[09:31:12.018]                               next
[09:31:12.018]                             invokeRestart(restart)
[09:31:12.018]                             muffled <- TRUE
[09:31:12.018]                             break
[09:31:12.018]                           }
[09:31:12.018]                         }
[09:31:12.018]                       }
[09:31:12.018]                       invisible(muffled)
[09:31:12.018]                     }
[09:31:12.018]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.018]                   }
[09:31:12.018]                 }
[09:31:12.018]             }
[09:31:12.018]         }))
[09:31:12.018]     }, error = function(ex) {
[09:31:12.018]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.018]                 ...future.rng), started = ...future.startTime, 
[09:31:12.018]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.018]             version = "1.8"), class = "FutureResult")
[09:31:12.018]     }, finally = {
[09:31:12.018]         if (!identical(...future.workdir, getwd())) 
[09:31:12.018]             setwd(...future.workdir)
[09:31:12.018]         {
[09:31:12.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.018]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.018]             }
[09:31:12.018]             base::options(...future.oldOptions)
[09:31:12.018]             if (.Platform$OS.type == "windows") {
[09:31:12.018]                 old_names <- names(...future.oldEnvVars)
[09:31:12.018]                 envs <- base::Sys.getenv()
[09:31:12.018]                 names <- names(envs)
[09:31:12.018]                 common <- intersect(names, old_names)
[09:31:12.018]                 added <- setdiff(names, old_names)
[09:31:12.018]                 removed <- setdiff(old_names, names)
[09:31:12.018]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.018]                   envs[common]]
[09:31:12.018]                 NAMES <- toupper(changed)
[09:31:12.018]                 args <- list()
[09:31:12.018]                 for (kk in seq_along(NAMES)) {
[09:31:12.018]                   name <- changed[[kk]]
[09:31:12.018]                   NAME <- NAMES[[kk]]
[09:31:12.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.018]                     next
[09:31:12.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.018]                 }
[09:31:12.018]                 NAMES <- toupper(added)
[09:31:12.018]                 for (kk in seq_along(NAMES)) {
[09:31:12.018]                   name <- added[[kk]]
[09:31:12.018]                   NAME <- NAMES[[kk]]
[09:31:12.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.018]                     next
[09:31:12.018]                   args[[name]] <- ""
[09:31:12.018]                 }
[09:31:12.018]                 NAMES <- toupper(removed)
[09:31:12.018]                 for (kk in seq_along(NAMES)) {
[09:31:12.018]                   name <- removed[[kk]]
[09:31:12.018]                   NAME <- NAMES[[kk]]
[09:31:12.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.018]                     next
[09:31:12.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.018]                 }
[09:31:12.018]                 if (length(args) > 0) 
[09:31:12.018]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.018]             }
[09:31:12.018]             else {
[09:31:12.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.018]             }
[09:31:12.018]             {
[09:31:12.018]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.018]                   0L) {
[09:31:12.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.018]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.018]                   base::options(opts)
[09:31:12.018]                 }
[09:31:12.018]                 {
[09:31:12.018]                   {
[09:31:12.018]                     NULL
[09:31:12.018]                     RNGkind("Mersenne-Twister")
[09:31:12.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.018]                       inherits = FALSE)
[09:31:12.018]                   }
[09:31:12.018]                   options(future.plan = NULL)
[09:31:12.018]                   if (is.na(NA_character_)) 
[09:31:12.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.018]                     .init = FALSE)
[09:31:12.018]                 }
[09:31:12.018]             }
[09:31:12.018]         }
[09:31:12.018]     })
[09:31:12.018]     if (TRUE) {
[09:31:12.018]         base::sink(type = "output", split = FALSE)
[09:31:12.018]         if (TRUE) {
[09:31:12.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.018]         }
[09:31:12.018]         else {
[09:31:12.018]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.018]         }
[09:31:12.018]         base::close(...future.stdout)
[09:31:12.018]         ...future.stdout <- NULL
[09:31:12.018]     }
[09:31:12.018]     ...future.result$conditions <- ...future.conditions
[09:31:12.018]     ...future.result$finished <- base::Sys.time()
[09:31:12.018]     ...future.result
[09:31:12.018] }
[09:31:12.020] plan(): Setting new future strategy stack:
[09:31:12.020] List of future strategies:
[09:31:12.020] 1. sequential:
[09:31:12.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.020]    - tweaked: FALSE
[09:31:12.020]    - call: NULL
[09:31:12.020] plan(): nbrOfWorkers() = 1
[09:31:12.021] plan(): Setting new future strategy stack:
[09:31:12.021] List of future strategies:
[09:31:12.021] 1. sequential:
[09:31:12.021]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.021]    - tweaked: FALSE
[09:31:12.021]    - call: plan(strategy)
[09:31:12.021] plan(): nbrOfWorkers() = 1
[09:31:12.022] SequentialFuture started (and completed)
[09:31:12.022] - Launch lazy future ... done
[09:31:12.023] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3c893b270> 
Classes 'listenv', 'environment' <environment: 0x55a3ca71e518> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[09:31:12.026] resolved() for ‘SequentialFuture’ ...
[09:31:12.026] - state: ‘finished’
[09:31:12.026] - run: TRUE
[09:31:12.026] - result: ‘FutureResult’
[09:31:12.026] resolved() for ‘SequentialFuture’ ... done
[09:31:12.027] resolved() for ‘SequentialFuture’ ...
[09:31:12.027] - state: ‘finished’
[09:31:12.027] - run: TRUE
[09:31:12.027] - result: ‘FutureResult’
[09:31:12.027] resolved() for ‘SequentialFuture’ ... done
[09:31:12.027] resolved() for ‘SequentialFuture’ ...
[09:31:12.027] - state: ‘finished’
[09:31:12.027] - run: TRUE
[09:31:12.027] - result: ‘FutureResult’
[09:31:12.027] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:12.030] resolve() on list environment ...
[09:31:12.030]  recursive: 0
[09:31:12.030]  length: 6
[09:31:12.031]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:12.031] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.031] - nx: 6
[09:31:12.031] - relay: TRUE
[09:31:12.031] - stdout: TRUE
[09:31:12.031] - signal: TRUE
[09:31:12.031] - resignal: FALSE
[09:31:12.031] - force: TRUE
[09:31:12.031] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.031] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.031]  - until=2
[09:31:12.031]  - relaying element #2
[09:31:12.032] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.032] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.032] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.032]  length: 5 (resolved future 1)
[09:31:12.032] resolved() for ‘SequentialFuture’ ...
[09:31:12.032] - state: ‘finished’
[09:31:12.032] - run: TRUE
[09:31:12.032] - result: ‘FutureResult’
[09:31:12.032] resolved() for ‘SequentialFuture’ ... done
[09:31:12.032] Future #2
[09:31:12.033] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:12.033] - nx: 6
[09:31:12.033] - relay: TRUE
[09:31:12.033] - stdout: TRUE
[09:31:12.033] - signal: TRUE
[09:31:12.033] - resignal: FALSE
[09:31:12.033] - force: TRUE
[09:31:12.033] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.033] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.033]  - until=2
[09:31:12.033]  - relaying element #2
[09:31:12.034] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.034] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.034] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:12.034]  length: 4 (resolved future 2)
[09:31:12.034] resolved() for ‘SequentialFuture’ ...
[09:31:12.034] - state: ‘finished’
[09:31:12.034] - run: TRUE
[09:31:12.034] - result: ‘FutureResult’
[09:31:12.034] resolved() for ‘SequentialFuture’ ... done
[09:31:12.034] Future #3
[09:31:12.034] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:12.035] - nx: 6
[09:31:12.035] - relay: TRUE
[09:31:12.035] - stdout: TRUE
[09:31:12.035] - signal: TRUE
[09:31:12.035] - resignal: FALSE
[09:31:12.035] - force: TRUE
[09:31:12.035] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.035] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.035]  - until=3
[09:31:12.035]  - relaying element #3
[09:31:12.035] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.035] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.036] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:12.036]  length: 3 (resolved future 3)
[09:31:12.036] resolved() for ‘SequentialFuture’ ...
[09:31:12.036] - state: ‘finished’
[09:31:12.036] - run: TRUE
[09:31:12.036] - result: ‘FutureResult’
[09:31:12.036] resolved() for ‘SequentialFuture’ ... done
[09:31:12.036] Future #4
[09:31:12.036] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:12.036] - nx: 6
[09:31:12.037] - relay: TRUE
[09:31:12.037] - stdout: TRUE
[09:31:12.037] - signal: TRUE
[09:31:12.037] - resignal: FALSE
[09:31:12.037] - force: TRUE
[09:31:12.037] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.037]  - until=4
[09:31:12.037]  - relaying element #4
[09:31:12.037] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.037] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.038] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:12.038]  length: 2 (resolved future 4)
[09:31:12.038] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.038] - nx: 6
[09:31:12.038] - relay: TRUE
[09:31:12.038] - stdout: TRUE
[09:31:12.038] - signal: TRUE
[09:31:12.038] - resignal: FALSE
[09:31:12.038] - force: TRUE
[09:31:12.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.038] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.038]  - until=6
[09:31:12.038]  - relaying element #6
[09:31:12.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.039] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.039] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.039]  length: 1 (resolved future 5)
[09:31:12.039] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.039] - nx: 6
[09:31:12.039] - relay: TRUE
[09:31:12.039] - stdout: TRUE
[09:31:12.039] - signal: TRUE
[09:31:12.039] - resignal: FALSE
[09:31:12.039] - force: TRUE
[09:31:12.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.039] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.040]  - until=6
[09:31:12.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.040] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.040] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.040]  length: 0 (resolved future 6)
[09:31:12.040] Relaying remaining futures
[09:31:12.040] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.040] - nx: 6
[09:31:12.040] - relay: TRUE
[09:31:12.040] - stdout: TRUE
[09:31:12.040] - signal: TRUE
[09:31:12.040] - resignal: FALSE
[09:31:12.041] - force: TRUE
[09:31:12.041] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.041] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:12.041] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.041] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.041] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.041] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a3c8d9ebc8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:12.043] getGlobalsAndPackages() ...
[09:31:12.043] Searching for globals...
[09:31:12.043] 
[09:31:12.043] Searching for globals ... DONE
[09:31:12.043] - globals: [0] <none>
[09:31:12.044] getGlobalsAndPackages() ... DONE
[09:31:12.044] run() for ‘Future’ ...
[09:31:12.044] - state: ‘created’
[09:31:12.044] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.044] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.044]   - Field: ‘label’
[09:31:12.045]   - Field: ‘local’
[09:31:12.045]   - Field: ‘owner’
[09:31:12.045]   - Field: ‘envir’
[09:31:12.045]   - Field: ‘packages’
[09:31:12.045]   - Field: ‘gc’
[09:31:12.045]   - Field: ‘conditions’
[09:31:12.045]   - Field: ‘expr’
[09:31:12.045]   - Field: ‘uuid’
[09:31:12.045]   - Field: ‘seed’
[09:31:12.045]   - Field: ‘version’
[09:31:12.045]   - Field: ‘result’
[09:31:12.045]   - Field: ‘asynchronous’
[09:31:12.046]   - Field: ‘calls’
[09:31:12.046]   - Field: ‘globals’
[09:31:12.046]   - Field: ‘stdout’
[09:31:12.047]   - Field: ‘earlySignal’
[09:31:12.047]   - Field: ‘lazy’
[09:31:12.047]   - Field: ‘state’
[09:31:12.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.047] - Launch lazy future ...
[09:31:12.047] Packages needed by the future expression (n = 0): <none>
[09:31:12.047] Packages needed by future strategies (n = 0): <none>
[09:31:12.048] {
[09:31:12.048]     {
[09:31:12.048]         {
[09:31:12.048]             ...future.startTime <- base::Sys.time()
[09:31:12.048]             {
[09:31:12.048]                 {
[09:31:12.048]                   {
[09:31:12.048]                     base::local({
[09:31:12.048]                       has_future <- base::requireNamespace("future", 
[09:31:12.048]                         quietly = TRUE)
[09:31:12.048]                       if (has_future) {
[09:31:12.048]                         ns <- base::getNamespace("future")
[09:31:12.048]                         version <- ns[[".package"]][["version"]]
[09:31:12.048]                         if (is.null(version)) 
[09:31:12.048]                           version <- utils::packageVersion("future")
[09:31:12.048]                       }
[09:31:12.048]                       else {
[09:31:12.048]                         version <- NULL
[09:31:12.048]                       }
[09:31:12.048]                       if (!has_future || version < "1.8.0") {
[09:31:12.048]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.048]                           "", base::R.version$version.string), 
[09:31:12.048]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.048]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.048]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.048]                             "release", "version")], collapse = " "), 
[09:31:12.048]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.048]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.048]                           info)
[09:31:12.048]                         info <- base::paste(info, collapse = "; ")
[09:31:12.048]                         if (!has_future) {
[09:31:12.048]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.048]                             info)
[09:31:12.048]                         }
[09:31:12.048]                         else {
[09:31:12.048]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.048]                             info, version)
[09:31:12.048]                         }
[09:31:12.048]                         base::stop(msg)
[09:31:12.048]                       }
[09:31:12.048]                     })
[09:31:12.048]                   }
[09:31:12.048]                   ...future.strategy.old <- future::plan("list")
[09:31:12.048]                   options(future.plan = NULL)
[09:31:12.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.048]                 }
[09:31:12.048]                 ...future.workdir <- getwd()
[09:31:12.048]             }
[09:31:12.048]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.048]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.048]         }
[09:31:12.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.048]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.048]             base::names(...future.oldOptions))
[09:31:12.048]     }
[09:31:12.048]     if (FALSE) {
[09:31:12.048]     }
[09:31:12.048]     else {
[09:31:12.048]         if (TRUE) {
[09:31:12.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.048]                 open = "w")
[09:31:12.048]         }
[09:31:12.048]         else {
[09:31:12.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.048]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.048]         }
[09:31:12.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.048]             base::sink(type = "output", split = FALSE)
[09:31:12.048]             base::close(...future.stdout)
[09:31:12.048]         }, add = TRUE)
[09:31:12.048]     }
[09:31:12.048]     ...future.frame <- base::sys.nframe()
[09:31:12.048]     ...future.conditions <- base::list()
[09:31:12.048]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.048]     if (FALSE) {
[09:31:12.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.048]     }
[09:31:12.048]     ...future.result <- base::tryCatch({
[09:31:12.048]         base::withCallingHandlers({
[09:31:12.048]             ...future.value <- base::withVisible(base::local(2))
[09:31:12.048]             future::FutureResult(value = ...future.value$value, 
[09:31:12.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.048]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.048]                     ...future.globalenv.names))
[09:31:12.048]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.048]         }, condition = base::local({
[09:31:12.048]             c <- base::c
[09:31:12.048]             inherits <- base::inherits
[09:31:12.048]             invokeRestart <- base::invokeRestart
[09:31:12.048]             length <- base::length
[09:31:12.048]             list <- base::list
[09:31:12.048]             seq.int <- base::seq.int
[09:31:12.048]             signalCondition <- base::signalCondition
[09:31:12.048]             sys.calls <- base::sys.calls
[09:31:12.048]             `[[` <- base::`[[`
[09:31:12.048]             `+` <- base::`+`
[09:31:12.048]             `<<-` <- base::`<<-`
[09:31:12.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.048]                   3L)]
[09:31:12.048]             }
[09:31:12.048]             function(cond) {
[09:31:12.048]                 is_error <- inherits(cond, "error")
[09:31:12.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.048]                   NULL)
[09:31:12.048]                 if (is_error) {
[09:31:12.048]                   sessionInformation <- function() {
[09:31:12.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.048]                       search = base::search(), system = base::Sys.info())
[09:31:12.048]                   }
[09:31:12.048]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.048]                     cond$call), session = sessionInformation(), 
[09:31:12.048]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.048]                   signalCondition(cond)
[09:31:12.048]                 }
[09:31:12.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.048]                 "immediateCondition"))) {
[09:31:12.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.048]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.048]                   if (TRUE && !signal) {
[09:31:12.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.048]                     {
[09:31:12.048]                       inherits <- base::inherits
[09:31:12.048]                       invokeRestart <- base::invokeRestart
[09:31:12.048]                       is.null <- base::is.null
[09:31:12.048]                       muffled <- FALSE
[09:31:12.048]                       if (inherits(cond, "message")) {
[09:31:12.048]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.048]                         if (muffled) 
[09:31:12.048]                           invokeRestart("muffleMessage")
[09:31:12.048]                       }
[09:31:12.048]                       else if (inherits(cond, "warning")) {
[09:31:12.048]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.048]                         if (muffled) 
[09:31:12.048]                           invokeRestart("muffleWarning")
[09:31:12.048]                       }
[09:31:12.048]                       else if (inherits(cond, "condition")) {
[09:31:12.048]                         if (!is.null(pattern)) {
[09:31:12.048]                           computeRestarts <- base::computeRestarts
[09:31:12.048]                           grepl <- base::grepl
[09:31:12.048]                           restarts <- computeRestarts(cond)
[09:31:12.048]                           for (restart in restarts) {
[09:31:12.048]                             name <- restart$name
[09:31:12.048]                             if (is.null(name)) 
[09:31:12.048]                               next
[09:31:12.048]                             if (!grepl(pattern, name)) 
[09:31:12.048]                               next
[09:31:12.048]                             invokeRestart(restart)
[09:31:12.048]                             muffled <- TRUE
[09:31:12.048]                             break
[09:31:12.048]                           }
[09:31:12.048]                         }
[09:31:12.048]                       }
[09:31:12.048]                       invisible(muffled)
[09:31:12.048]                     }
[09:31:12.048]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.048]                   }
[09:31:12.048]                 }
[09:31:12.048]                 else {
[09:31:12.048]                   if (TRUE) {
[09:31:12.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.048]                     {
[09:31:12.048]                       inherits <- base::inherits
[09:31:12.048]                       invokeRestart <- base::invokeRestart
[09:31:12.048]                       is.null <- base::is.null
[09:31:12.048]                       muffled <- FALSE
[09:31:12.048]                       if (inherits(cond, "message")) {
[09:31:12.048]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.048]                         if (muffled) 
[09:31:12.048]                           invokeRestart("muffleMessage")
[09:31:12.048]                       }
[09:31:12.048]                       else if (inherits(cond, "warning")) {
[09:31:12.048]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.048]                         if (muffled) 
[09:31:12.048]                           invokeRestart("muffleWarning")
[09:31:12.048]                       }
[09:31:12.048]                       else if (inherits(cond, "condition")) {
[09:31:12.048]                         if (!is.null(pattern)) {
[09:31:12.048]                           computeRestarts <- base::computeRestarts
[09:31:12.048]                           grepl <- base::grepl
[09:31:12.048]                           restarts <- computeRestarts(cond)
[09:31:12.048]                           for (restart in restarts) {
[09:31:12.048]                             name <- restart$name
[09:31:12.048]                             if (is.null(name)) 
[09:31:12.048]                               next
[09:31:12.048]                             if (!grepl(pattern, name)) 
[09:31:12.048]                               next
[09:31:12.048]                             invokeRestart(restart)
[09:31:12.048]                             muffled <- TRUE
[09:31:12.048]                             break
[09:31:12.048]                           }
[09:31:12.048]                         }
[09:31:12.048]                       }
[09:31:12.048]                       invisible(muffled)
[09:31:12.048]                     }
[09:31:12.048]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.048]                   }
[09:31:12.048]                 }
[09:31:12.048]             }
[09:31:12.048]         }))
[09:31:12.048]     }, error = function(ex) {
[09:31:12.048]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.048]                 ...future.rng), started = ...future.startTime, 
[09:31:12.048]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.048]             version = "1.8"), class = "FutureResult")
[09:31:12.048]     }, finally = {
[09:31:12.048]         if (!identical(...future.workdir, getwd())) 
[09:31:12.048]             setwd(...future.workdir)
[09:31:12.048]         {
[09:31:12.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.048]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.048]             }
[09:31:12.048]             base::options(...future.oldOptions)
[09:31:12.048]             if (.Platform$OS.type == "windows") {
[09:31:12.048]                 old_names <- names(...future.oldEnvVars)
[09:31:12.048]                 envs <- base::Sys.getenv()
[09:31:12.048]                 names <- names(envs)
[09:31:12.048]                 common <- intersect(names, old_names)
[09:31:12.048]                 added <- setdiff(names, old_names)
[09:31:12.048]                 removed <- setdiff(old_names, names)
[09:31:12.048]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.048]                   envs[common]]
[09:31:12.048]                 NAMES <- toupper(changed)
[09:31:12.048]                 args <- list()
[09:31:12.048]                 for (kk in seq_along(NAMES)) {
[09:31:12.048]                   name <- changed[[kk]]
[09:31:12.048]                   NAME <- NAMES[[kk]]
[09:31:12.048]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.048]                     next
[09:31:12.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.048]                 }
[09:31:12.048]                 NAMES <- toupper(added)
[09:31:12.048]                 for (kk in seq_along(NAMES)) {
[09:31:12.048]                   name <- added[[kk]]
[09:31:12.048]                   NAME <- NAMES[[kk]]
[09:31:12.048]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.048]                     next
[09:31:12.048]                   args[[name]] <- ""
[09:31:12.048]                 }
[09:31:12.048]                 NAMES <- toupper(removed)
[09:31:12.048]                 for (kk in seq_along(NAMES)) {
[09:31:12.048]                   name <- removed[[kk]]
[09:31:12.048]                   NAME <- NAMES[[kk]]
[09:31:12.048]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.048]                     next
[09:31:12.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.048]                 }
[09:31:12.048]                 if (length(args) > 0) 
[09:31:12.048]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.048]             }
[09:31:12.048]             else {
[09:31:12.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.048]             }
[09:31:12.048]             {
[09:31:12.048]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.048]                   0L) {
[09:31:12.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.048]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.048]                   base::options(opts)
[09:31:12.048]                 }
[09:31:12.048]                 {
[09:31:12.048]                   {
[09:31:12.048]                     NULL
[09:31:12.048]                     RNGkind("Mersenne-Twister")
[09:31:12.048]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.048]                       inherits = FALSE)
[09:31:12.048]                   }
[09:31:12.048]                   options(future.plan = NULL)
[09:31:12.048]                   if (is.na(NA_character_)) 
[09:31:12.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.048]                     .init = FALSE)
[09:31:12.048]                 }
[09:31:12.048]             }
[09:31:12.048]         }
[09:31:12.048]     })
[09:31:12.048]     if (TRUE) {
[09:31:12.048]         base::sink(type = "output", split = FALSE)
[09:31:12.048]         if (TRUE) {
[09:31:12.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.048]         }
[09:31:12.048]         else {
[09:31:12.048]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.048]         }
[09:31:12.048]         base::close(...future.stdout)
[09:31:12.048]         ...future.stdout <- NULL
[09:31:12.048]     }
[09:31:12.048]     ...future.result$conditions <- ...future.conditions
[09:31:12.048]     ...future.result$finished <- base::Sys.time()
[09:31:12.048]     ...future.result
[09:31:12.048] }
[09:31:12.049] plan(): Setting new future strategy stack:
[09:31:12.049] List of future strategies:
[09:31:12.049] 1. sequential:
[09:31:12.049]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.049]    - tweaked: FALSE
[09:31:12.049]    - call: NULL
[09:31:12.050] plan(): nbrOfWorkers() = 1
[09:31:12.051] plan(): Setting new future strategy stack:
[09:31:12.051] List of future strategies:
[09:31:12.051] 1. sequential:
[09:31:12.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.051]    - tweaked: FALSE
[09:31:12.051]    - call: plan(strategy)
[09:31:12.051] plan(): nbrOfWorkers() = 1
[09:31:12.051] SequentialFuture started (and completed)
[09:31:12.051] - Launch lazy future ... done
[09:31:12.051] run() for ‘SequentialFuture’ ... done
[09:31:12.052] getGlobalsAndPackages() ...
[09:31:12.052] Searching for globals...
[09:31:12.052] 
[09:31:12.052] Searching for globals ... DONE
[09:31:12.052] - globals: [0] <none>
[09:31:12.052] getGlobalsAndPackages() ... DONE
[09:31:12.052] run() for ‘Future’ ...
[09:31:12.052] - state: ‘created’
[09:31:12.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.053]   - Field: ‘label’
[09:31:12.053]   - Field: ‘local’
[09:31:12.053]   - Field: ‘owner’
[09:31:12.053]   - Field: ‘envir’
[09:31:12.053]   - Field: ‘packages’
[09:31:12.053]   - Field: ‘gc’
[09:31:12.054]   - Field: ‘conditions’
[09:31:12.054]   - Field: ‘expr’
[09:31:12.054]   - Field: ‘uuid’
[09:31:12.054]   - Field: ‘seed’
[09:31:12.054]   - Field: ‘version’
[09:31:12.054]   - Field: ‘result’
[09:31:12.054]   - Field: ‘asynchronous’
[09:31:12.054]   - Field: ‘calls’
[09:31:12.054]   - Field: ‘globals’
[09:31:12.054]   - Field: ‘stdout’
[09:31:12.054]   - Field: ‘earlySignal’
[09:31:12.055]   - Field: ‘lazy’
[09:31:12.055]   - Field: ‘state’
[09:31:12.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.055] - Launch lazy future ...
[09:31:12.055] Packages needed by the future expression (n = 0): <none>
[09:31:12.055] Packages needed by future strategies (n = 0): <none>
[09:31:12.055] {
[09:31:12.055]     {
[09:31:12.055]         {
[09:31:12.055]             ...future.startTime <- base::Sys.time()
[09:31:12.055]             {
[09:31:12.055]                 {
[09:31:12.055]                   {
[09:31:12.055]                     base::local({
[09:31:12.055]                       has_future <- base::requireNamespace("future", 
[09:31:12.055]                         quietly = TRUE)
[09:31:12.055]                       if (has_future) {
[09:31:12.055]                         ns <- base::getNamespace("future")
[09:31:12.055]                         version <- ns[[".package"]][["version"]]
[09:31:12.055]                         if (is.null(version)) 
[09:31:12.055]                           version <- utils::packageVersion("future")
[09:31:12.055]                       }
[09:31:12.055]                       else {
[09:31:12.055]                         version <- NULL
[09:31:12.055]                       }
[09:31:12.055]                       if (!has_future || version < "1.8.0") {
[09:31:12.055]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.055]                           "", base::R.version$version.string), 
[09:31:12.055]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.055]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.055]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.055]                             "release", "version")], collapse = " "), 
[09:31:12.055]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.055]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.055]                           info)
[09:31:12.055]                         info <- base::paste(info, collapse = "; ")
[09:31:12.055]                         if (!has_future) {
[09:31:12.055]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.055]                             info)
[09:31:12.055]                         }
[09:31:12.055]                         else {
[09:31:12.055]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.055]                             info, version)
[09:31:12.055]                         }
[09:31:12.055]                         base::stop(msg)
[09:31:12.055]                       }
[09:31:12.055]                     })
[09:31:12.055]                   }
[09:31:12.055]                   ...future.strategy.old <- future::plan("list")
[09:31:12.055]                   options(future.plan = NULL)
[09:31:12.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.055]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.055]                 }
[09:31:12.055]                 ...future.workdir <- getwd()
[09:31:12.055]             }
[09:31:12.055]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.055]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.055]         }
[09:31:12.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.055]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.055]             base::names(...future.oldOptions))
[09:31:12.055]     }
[09:31:12.055]     if (FALSE) {
[09:31:12.055]     }
[09:31:12.055]     else {
[09:31:12.055]         if (TRUE) {
[09:31:12.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.055]                 open = "w")
[09:31:12.055]         }
[09:31:12.055]         else {
[09:31:12.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.055]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.055]         }
[09:31:12.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.055]             base::sink(type = "output", split = FALSE)
[09:31:12.055]             base::close(...future.stdout)
[09:31:12.055]         }, add = TRUE)
[09:31:12.055]     }
[09:31:12.055]     ...future.frame <- base::sys.nframe()
[09:31:12.055]     ...future.conditions <- base::list()
[09:31:12.055]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.055]     if (FALSE) {
[09:31:12.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.055]     }
[09:31:12.055]     ...future.result <- base::tryCatch({
[09:31:12.055]         base::withCallingHandlers({
[09:31:12.055]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:12.055]             future::FutureResult(value = ...future.value$value, 
[09:31:12.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.055]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.055]                     ...future.globalenv.names))
[09:31:12.055]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.055]         }, condition = base::local({
[09:31:12.055]             c <- base::c
[09:31:12.055]             inherits <- base::inherits
[09:31:12.055]             invokeRestart <- base::invokeRestart
[09:31:12.055]             length <- base::length
[09:31:12.055]             list <- base::list
[09:31:12.055]             seq.int <- base::seq.int
[09:31:12.055]             signalCondition <- base::signalCondition
[09:31:12.055]             sys.calls <- base::sys.calls
[09:31:12.055]             `[[` <- base::`[[`
[09:31:12.055]             `+` <- base::`+`
[09:31:12.055]             `<<-` <- base::`<<-`
[09:31:12.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.055]                   3L)]
[09:31:12.055]             }
[09:31:12.055]             function(cond) {
[09:31:12.055]                 is_error <- inherits(cond, "error")
[09:31:12.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.055]                   NULL)
[09:31:12.055]                 if (is_error) {
[09:31:12.055]                   sessionInformation <- function() {
[09:31:12.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.055]                       search = base::search(), system = base::Sys.info())
[09:31:12.055]                   }
[09:31:12.055]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.055]                     cond$call), session = sessionInformation(), 
[09:31:12.055]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.055]                   signalCondition(cond)
[09:31:12.055]                 }
[09:31:12.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.055]                 "immediateCondition"))) {
[09:31:12.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.055]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.055]                   if (TRUE && !signal) {
[09:31:12.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.055]                     {
[09:31:12.055]                       inherits <- base::inherits
[09:31:12.055]                       invokeRestart <- base::invokeRestart
[09:31:12.055]                       is.null <- base::is.null
[09:31:12.055]                       muffled <- FALSE
[09:31:12.055]                       if (inherits(cond, "message")) {
[09:31:12.055]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.055]                         if (muffled) 
[09:31:12.055]                           invokeRestart("muffleMessage")
[09:31:12.055]                       }
[09:31:12.055]                       else if (inherits(cond, "warning")) {
[09:31:12.055]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.055]                         if (muffled) 
[09:31:12.055]                           invokeRestart("muffleWarning")
[09:31:12.055]                       }
[09:31:12.055]                       else if (inherits(cond, "condition")) {
[09:31:12.055]                         if (!is.null(pattern)) {
[09:31:12.055]                           computeRestarts <- base::computeRestarts
[09:31:12.055]                           grepl <- base::grepl
[09:31:12.055]                           restarts <- computeRestarts(cond)
[09:31:12.055]                           for (restart in restarts) {
[09:31:12.055]                             name <- restart$name
[09:31:12.055]                             if (is.null(name)) 
[09:31:12.055]                               next
[09:31:12.055]                             if (!grepl(pattern, name)) 
[09:31:12.055]                               next
[09:31:12.055]                             invokeRestart(restart)
[09:31:12.055]                             muffled <- TRUE
[09:31:12.055]                             break
[09:31:12.055]                           }
[09:31:12.055]                         }
[09:31:12.055]                       }
[09:31:12.055]                       invisible(muffled)
[09:31:12.055]                     }
[09:31:12.055]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.055]                   }
[09:31:12.055]                 }
[09:31:12.055]                 else {
[09:31:12.055]                   if (TRUE) {
[09:31:12.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.055]                     {
[09:31:12.055]                       inherits <- base::inherits
[09:31:12.055]                       invokeRestart <- base::invokeRestart
[09:31:12.055]                       is.null <- base::is.null
[09:31:12.055]                       muffled <- FALSE
[09:31:12.055]                       if (inherits(cond, "message")) {
[09:31:12.055]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.055]                         if (muffled) 
[09:31:12.055]                           invokeRestart("muffleMessage")
[09:31:12.055]                       }
[09:31:12.055]                       else if (inherits(cond, "warning")) {
[09:31:12.055]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.055]                         if (muffled) 
[09:31:12.055]                           invokeRestart("muffleWarning")
[09:31:12.055]                       }
[09:31:12.055]                       else if (inherits(cond, "condition")) {
[09:31:12.055]                         if (!is.null(pattern)) {
[09:31:12.055]                           computeRestarts <- base::computeRestarts
[09:31:12.055]                           grepl <- base::grepl
[09:31:12.055]                           restarts <- computeRestarts(cond)
[09:31:12.055]                           for (restart in restarts) {
[09:31:12.055]                             name <- restart$name
[09:31:12.055]                             if (is.null(name)) 
[09:31:12.055]                               next
[09:31:12.055]                             if (!grepl(pattern, name)) 
[09:31:12.055]                               next
[09:31:12.055]                             invokeRestart(restart)
[09:31:12.055]                             muffled <- TRUE
[09:31:12.055]                             break
[09:31:12.055]                           }
[09:31:12.055]                         }
[09:31:12.055]                       }
[09:31:12.055]                       invisible(muffled)
[09:31:12.055]                     }
[09:31:12.055]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.055]                   }
[09:31:12.055]                 }
[09:31:12.055]             }
[09:31:12.055]         }))
[09:31:12.055]     }, error = function(ex) {
[09:31:12.055]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.055]                 ...future.rng), started = ...future.startTime, 
[09:31:12.055]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.055]             version = "1.8"), class = "FutureResult")
[09:31:12.055]     }, finally = {
[09:31:12.055]         if (!identical(...future.workdir, getwd())) 
[09:31:12.055]             setwd(...future.workdir)
[09:31:12.055]         {
[09:31:12.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.055]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.055]             }
[09:31:12.055]             base::options(...future.oldOptions)
[09:31:12.055]             if (.Platform$OS.type == "windows") {
[09:31:12.055]                 old_names <- names(...future.oldEnvVars)
[09:31:12.055]                 envs <- base::Sys.getenv()
[09:31:12.055]                 names <- names(envs)
[09:31:12.055]                 common <- intersect(names, old_names)
[09:31:12.055]                 added <- setdiff(names, old_names)
[09:31:12.055]                 removed <- setdiff(old_names, names)
[09:31:12.055]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.055]                   envs[common]]
[09:31:12.055]                 NAMES <- toupper(changed)
[09:31:12.055]                 args <- list()
[09:31:12.055]                 for (kk in seq_along(NAMES)) {
[09:31:12.055]                   name <- changed[[kk]]
[09:31:12.055]                   NAME <- NAMES[[kk]]
[09:31:12.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.055]                     next
[09:31:12.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.055]                 }
[09:31:12.055]                 NAMES <- toupper(added)
[09:31:12.055]                 for (kk in seq_along(NAMES)) {
[09:31:12.055]                   name <- added[[kk]]
[09:31:12.055]                   NAME <- NAMES[[kk]]
[09:31:12.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.055]                     next
[09:31:12.055]                   args[[name]] <- ""
[09:31:12.055]                 }
[09:31:12.055]                 NAMES <- toupper(removed)
[09:31:12.055]                 for (kk in seq_along(NAMES)) {
[09:31:12.055]                   name <- removed[[kk]]
[09:31:12.055]                   NAME <- NAMES[[kk]]
[09:31:12.055]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.055]                     next
[09:31:12.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.055]                 }
[09:31:12.055]                 if (length(args) > 0) 
[09:31:12.055]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.055]             }
[09:31:12.055]             else {
[09:31:12.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.055]             }
[09:31:12.055]             {
[09:31:12.055]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.055]                   0L) {
[09:31:12.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.055]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.055]                   base::options(opts)
[09:31:12.055]                 }
[09:31:12.055]                 {
[09:31:12.055]                   {
[09:31:12.055]                     NULL
[09:31:12.055]                     RNGkind("Mersenne-Twister")
[09:31:12.055]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.055]                       inherits = FALSE)
[09:31:12.055]                   }
[09:31:12.055]                   options(future.plan = NULL)
[09:31:12.055]                   if (is.na(NA_character_)) 
[09:31:12.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.055]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.055]                     .init = FALSE)
[09:31:12.055]                 }
[09:31:12.055]             }
[09:31:12.055]         }
[09:31:12.055]     })
[09:31:12.055]     if (TRUE) {
[09:31:12.055]         base::sink(type = "output", split = FALSE)
[09:31:12.055]         if (TRUE) {
[09:31:12.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.055]         }
[09:31:12.055]         else {
[09:31:12.055]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.055]         }
[09:31:12.055]         base::close(...future.stdout)
[09:31:12.055]         ...future.stdout <- NULL
[09:31:12.055]     }
[09:31:12.055]     ...future.result$conditions <- ...future.conditions
[09:31:12.055]     ...future.result$finished <- base::Sys.time()
[09:31:12.055]     ...future.result
[09:31:12.055] }
[09:31:12.057] plan(): Setting new future strategy stack:
[09:31:12.057] List of future strategies:
[09:31:12.057] 1. sequential:
[09:31:12.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.057]    - tweaked: FALSE
[09:31:12.057]    - call: NULL
[09:31:12.058] plan(): nbrOfWorkers() = 1
[09:31:12.058] plan(): Setting new future strategy stack:
[09:31:12.058] List of future strategies:
[09:31:12.058] 1. sequential:
[09:31:12.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.058]    - tweaked: FALSE
[09:31:12.058]    - call: plan(strategy)
[09:31:12.059] plan(): nbrOfWorkers() = 1
[09:31:12.059] SequentialFuture started (and completed)
[09:31:12.059] - Launch lazy future ... done
[09:31:12.059] run() for ‘SequentialFuture’ ... done
[09:31:12.059] getGlobalsAndPackages() ...
[09:31:12.059] Searching for globals...
[09:31:12.060] - globals found: [1] ‘{’
[09:31:12.060] Searching for globals ... DONE
[09:31:12.060] Resolving globals: FALSE
[09:31:12.060] 
[09:31:12.061] 
[09:31:12.061] getGlobalsAndPackages() ... DONE
[09:31:12.061] run() for ‘Future’ ...
[09:31:12.061] - state: ‘created’
[09:31:12.061] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.061] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.062]   - Field: ‘label’
[09:31:12.062]   - Field: ‘local’
[09:31:12.062]   - Field: ‘owner’
[09:31:12.062]   - Field: ‘envir’
[09:31:12.062]   - Field: ‘packages’
[09:31:12.062]   - Field: ‘gc’
[09:31:12.062]   - Field: ‘conditions’
[09:31:12.062]   - Field: ‘expr’
[09:31:12.062]   - Field: ‘uuid’
[09:31:12.062]   - Field: ‘seed’
[09:31:12.062]   - Field: ‘version’
[09:31:12.062]   - Field: ‘result’
[09:31:12.063]   - Field: ‘asynchronous’
[09:31:12.063]   - Field: ‘calls’
[09:31:12.063]   - Field: ‘globals’
[09:31:12.063]   - Field: ‘stdout’
[09:31:12.063]   - Field: ‘earlySignal’
[09:31:12.063]   - Field: ‘lazy’
[09:31:12.063]   - Field: ‘state’
[09:31:12.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.063] - Launch lazy future ...
[09:31:12.063] Packages needed by the future expression (n = 0): <none>
[09:31:12.064] Packages needed by future strategies (n = 0): <none>
[09:31:12.064] {
[09:31:12.064]     {
[09:31:12.064]         {
[09:31:12.064]             ...future.startTime <- base::Sys.time()
[09:31:12.064]             {
[09:31:12.064]                 {
[09:31:12.064]                   {
[09:31:12.064]                     base::local({
[09:31:12.064]                       has_future <- base::requireNamespace("future", 
[09:31:12.064]                         quietly = TRUE)
[09:31:12.064]                       if (has_future) {
[09:31:12.064]                         ns <- base::getNamespace("future")
[09:31:12.064]                         version <- ns[[".package"]][["version"]]
[09:31:12.064]                         if (is.null(version)) 
[09:31:12.064]                           version <- utils::packageVersion("future")
[09:31:12.064]                       }
[09:31:12.064]                       else {
[09:31:12.064]                         version <- NULL
[09:31:12.064]                       }
[09:31:12.064]                       if (!has_future || version < "1.8.0") {
[09:31:12.064]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.064]                           "", base::R.version$version.string), 
[09:31:12.064]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.064]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.064]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.064]                             "release", "version")], collapse = " "), 
[09:31:12.064]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.064]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.064]                           info)
[09:31:12.064]                         info <- base::paste(info, collapse = "; ")
[09:31:12.064]                         if (!has_future) {
[09:31:12.064]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.064]                             info)
[09:31:12.064]                         }
[09:31:12.064]                         else {
[09:31:12.064]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.064]                             info, version)
[09:31:12.064]                         }
[09:31:12.064]                         base::stop(msg)
[09:31:12.064]                       }
[09:31:12.064]                     })
[09:31:12.064]                   }
[09:31:12.064]                   ...future.strategy.old <- future::plan("list")
[09:31:12.064]                   options(future.plan = NULL)
[09:31:12.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.064]                 }
[09:31:12.064]                 ...future.workdir <- getwd()
[09:31:12.064]             }
[09:31:12.064]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.064]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.064]         }
[09:31:12.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.064]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.064]             base::names(...future.oldOptions))
[09:31:12.064]     }
[09:31:12.064]     if (FALSE) {
[09:31:12.064]     }
[09:31:12.064]     else {
[09:31:12.064]         if (TRUE) {
[09:31:12.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.064]                 open = "w")
[09:31:12.064]         }
[09:31:12.064]         else {
[09:31:12.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.064]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.064]         }
[09:31:12.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.064]             base::sink(type = "output", split = FALSE)
[09:31:12.064]             base::close(...future.stdout)
[09:31:12.064]         }, add = TRUE)
[09:31:12.064]     }
[09:31:12.064]     ...future.frame <- base::sys.nframe()
[09:31:12.064]     ...future.conditions <- base::list()
[09:31:12.064]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.064]     if (FALSE) {
[09:31:12.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.064]     }
[09:31:12.064]     ...future.result <- base::tryCatch({
[09:31:12.064]         base::withCallingHandlers({
[09:31:12.064]             ...future.value <- base::withVisible(base::local({
[09:31:12.064]                 4
[09:31:12.064]             }))
[09:31:12.064]             future::FutureResult(value = ...future.value$value, 
[09:31:12.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.064]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.064]                     ...future.globalenv.names))
[09:31:12.064]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.064]         }, condition = base::local({
[09:31:12.064]             c <- base::c
[09:31:12.064]             inherits <- base::inherits
[09:31:12.064]             invokeRestart <- base::invokeRestart
[09:31:12.064]             length <- base::length
[09:31:12.064]             list <- base::list
[09:31:12.064]             seq.int <- base::seq.int
[09:31:12.064]             signalCondition <- base::signalCondition
[09:31:12.064]             sys.calls <- base::sys.calls
[09:31:12.064]             `[[` <- base::`[[`
[09:31:12.064]             `+` <- base::`+`
[09:31:12.064]             `<<-` <- base::`<<-`
[09:31:12.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.064]                   3L)]
[09:31:12.064]             }
[09:31:12.064]             function(cond) {
[09:31:12.064]                 is_error <- inherits(cond, "error")
[09:31:12.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.064]                   NULL)
[09:31:12.064]                 if (is_error) {
[09:31:12.064]                   sessionInformation <- function() {
[09:31:12.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.064]                       search = base::search(), system = base::Sys.info())
[09:31:12.064]                   }
[09:31:12.064]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.064]                     cond$call), session = sessionInformation(), 
[09:31:12.064]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.064]                   signalCondition(cond)
[09:31:12.064]                 }
[09:31:12.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.064]                 "immediateCondition"))) {
[09:31:12.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.064]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.064]                   if (TRUE && !signal) {
[09:31:12.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.064]                     {
[09:31:12.064]                       inherits <- base::inherits
[09:31:12.064]                       invokeRestart <- base::invokeRestart
[09:31:12.064]                       is.null <- base::is.null
[09:31:12.064]                       muffled <- FALSE
[09:31:12.064]                       if (inherits(cond, "message")) {
[09:31:12.064]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.064]                         if (muffled) 
[09:31:12.064]                           invokeRestart("muffleMessage")
[09:31:12.064]                       }
[09:31:12.064]                       else if (inherits(cond, "warning")) {
[09:31:12.064]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.064]                         if (muffled) 
[09:31:12.064]                           invokeRestart("muffleWarning")
[09:31:12.064]                       }
[09:31:12.064]                       else if (inherits(cond, "condition")) {
[09:31:12.064]                         if (!is.null(pattern)) {
[09:31:12.064]                           computeRestarts <- base::computeRestarts
[09:31:12.064]                           grepl <- base::grepl
[09:31:12.064]                           restarts <- computeRestarts(cond)
[09:31:12.064]                           for (restart in restarts) {
[09:31:12.064]                             name <- restart$name
[09:31:12.064]                             if (is.null(name)) 
[09:31:12.064]                               next
[09:31:12.064]                             if (!grepl(pattern, name)) 
[09:31:12.064]                               next
[09:31:12.064]                             invokeRestart(restart)
[09:31:12.064]                             muffled <- TRUE
[09:31:12.064]                             break
[09:31:12.064]                           }
[09:31:12.064]                         }
[09:31:12.064]                       }
[09:31:12.064]                       invisible(muffled)
[09:31:12.064]                     }
[09:31:12.064]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.064]                   }
[09:31:12.064]                 }
[09:31:12.064]                 else {
[09:31:12.064]                   if (TRUE) {
[09:31:12.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.064]                     {
[09:31:12.064]                       inherits <- base::inherits
[09:31:12.064]                       invokeRestart <- base::invokeRestart
[09:31:12.064]                       is.null <- base::is.null
[09:31:12.064]                       muffled <- FALSE
[09:31:12.064]                       if (inherits(cond, "message")) {
[09:31:12.064]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.064]                         if (muffled) 
[09:31:12.064]                           invokeRestart("muffleMessage")
[09:31:12.064]                       }
[09:31:12.064]                       else if (inherits(cond, "warning")) {
[09:31:12.064]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.064]                         if (muffled) 
[09:31:12.064]                           invokeRestart("muffleWarning")
[09:31:12.064]                       }
[09:31:12.064]                       else if (inherits(cond, "condition")) {
[09:31:12.064]                         if (!is.null(pattern)) {
[09:31:12.064]                           computeRestarts <- base::computeRestarts
[09:31:12.064]                           grepl <- base::grepl
[09:31:12.064]                           restarts <- computeRestarts(cond)
[09:31:12.064]                           for (restart in restarts) {
[09:31:12.064]                             name <- restart$name
[09:31:12.064]                             if (is.null(name)) 
[09:31:12.064]                               next
[09:31:12.064]                             if (!grepl(pattern, name)) 
[09:31:12.064]                               next
[09:31:12.064]                             invokeRestart(restart)
[09:31:12.064]                             muffled <- TRUE
[09:31:12.064]                             break
[09:31:12.064]                           }
[09:31:12.064]                         }
[09:31:12.064]                       }
[09:31:12.064]                       invisible(muffled)
[09:31:12.064]                     }
[09:31:12.064]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.064]                   }
[09:31:12.064]                 }
[09:31:12.064]             }
[09:31:12.064]         }))
[09:31:12.064]     }, error = function(ex) {
[09:31:12.064]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.064]                 ...future.rng), started = ...future.startTime, 
[09:31:12.064]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.064]             version = "1.8"), class = "FutureResult")
[09:31:12.064]     }, finally = {
[09:31:12.064]         if (!identical(...future.workdir, getwd())) 
[09:31:12.064]             setwd(...future.workdir)
[09:31:12.064]         {
[09:31:12.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.064]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.064]             }
[09:31:12.064]             base::options(...future.oldOptions)
[09:31:12.064]             if (.Platform$OS.type == "windows") {
[09:31:12.064]                 old_names <- names(...future.oldEnvVars)
[09:31:12.064]                 envs <- base::Sys.getenv()
[09:31:12.064]                 names <- names(envs)
[09:31:12.064]                 common <- intersect(names, old_names)
[09:31:12.064]                 added <- setdiff(names, old_names)
[09:31:12.064]                 removed <- setdiff(old_names, names)
[09:31:12.064]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.064]                   envs[common]]
[09:31:12.064]                 NAMES <- toupper(changed)
[09:31:12.064]                 args <- list()
[09:31:12.064]                 for (kk in seq_along(NAMES)) {
[09:31:12.064]                   name <- changed[[kk]]
[09:31:12.064]                   NAME <- NAMES[[kk]]
[09:31:12.064]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.064]                     next
[09:31:12.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.064]                 }
[09:31:12.064]                 NAMES <- toupper(added)
[09:31:12.064]                 for (kk in seq_along(NAMES)) {
[09:31:12.064]                   name <- added[[kk]]
[09:31:12.064]                   NAME <- NAMES[[kk]]
[09:31:12.064]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.064]                     next
[09:31:12.064]                   args[[name]] <- ""
[09:31:12.064]                 }
[09:31:12.064]                 NAMES <- toupper(removed)
[09:31:12.064]                 for (kk in seq_along(NAMES)) {
[09:31:12.064]                   name <- removed[[kk]]
[09:31:12.064]                   NAME <- NAMES[[kk]]
[09:31:12.064]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.064]                     next
[09:31:12.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.064]                 }
[09:31:12.064]                 if (length(args) > 0) 
[09:31:12.064]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.064]             }
[09:31:12.064]             else {
[09:31:12.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.064]             }
[09:31:12.064]             {
[09:31:12.064]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.064]                   0L) {
[09:31:12.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.064]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.064]                   base::options(opts)
[09:31:12.064]                 }
[09:31:12.064]                 {
[09:31:12.064]                   {
[09:31:12.064]                     NULL
[09:31:12.064]                     RNGkind("Mersenne-Twister")
[09:31:12.064]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.064]                       inherits = FALSE)
[09:31:12.064]                   }
[09:31:12.064]                   options(future.plan = NULL)
[09:31:12.064]                   if (is.na(NA_character_)) 
[09:31:12.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.064]                     .init = FALSE)
[09:31:12.064]                 }
[09:31:12.064]             }
[09:31:12.064]         }
[09:31:12.064]     })
[09:31:12.064]     if (TRUE) {
[09:31:12.064]         base::sink(type = "output", split = FALSE)
[09:31:12.064]         if (TRUE) {
[09:31:12.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.064]         }
[09:31:12.064]         else {
[09:31:12.064]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.064]         }
[09:31:12.064]         base::close(...future.stdout)
[09:31:12.064]         ...future.stdout <- NULL
[09:31:12.064]     }
[09:31:12.064]     ...future.result$conditions <- ...future.conditions
[09:31:12.064]     ...future.result$finished <- base::Sys.time()
[09:31:12.064]     ...future.result
[09:31:12.064] }
[09:31:12.066] plan(): Setting new future strategy stack:
[09:31:12.066] List of future strategies:
[09:31:12.066] 1. sequential:
[09:31:12.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.066]    - tweaked: FALSE
[09:31:12.066]    - call: NULL
[09:31:12.066] plan(): nbrOfWorkers() = 1
[09:31:12.067] plan(): Setting new future strategy stack:
[09:31:12.067] List of future strategies:
[09:31:12.067] 1. sequential:
[09:31:12.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.067]    - tweaked: FALSE
[09:31:12.067]    - call: plan(strategy)
[09:31:12.067] plan(): nbrOfWorkers() = 1
[09:31:12.067] SequentialFuture started (and completed)
[09:31:12.068] - Launch lazy future ... done
[09:31:12.068] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cb0c9f20> 
Classes 'listenv', 'environment' <environment: 0x55a3cadbe5f0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:12.071] resolved() for ‘SequentialFuture’ ...
[09:31:12.071] - state: ‘finished’
[09:31:12.071] - run: TRUE
[09:31:12.071] - result: ‘FutureResult’
[09:31:12.071] resolved() for ‘SequentialFuture’ ... done
[09:31:12.071] resolved() for ‘SequentialFuture’ ...
[09:31:12.072] - state: ‘finished’
[09:31:12.072] - run: TRUE
[09:31:12.072] - result: ‘FutureResult’
[09:31:12.072] resolved() for ‘SequentialFuture’ ... done
[09:31:12.072] resolved() for ‘SequentialFuture’ ...
[09:31:12.072] - state: ‘finished’
[09:31:12.072] - run: TRUE
[09:31:12.072] - result: ‘FutureResult’
[09:31:12.072] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:12.075] resolve() on list environment ...
[09:31:12.075]  recursive: 0
[09:31:12.077]  length: 6
[09:31:12.077]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:12.077] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.077] - nx: 6
[09:31:12.077] - relay: TRUE
[09:31:12.077] - stdout: TRUE
[09:31:12.077] - signal: TRUE
[09:31:12.077] - resignal: FALSE
[09:31:12.077] - force: TRUE
[09:31:12.077] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.077] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.078]  - until=2
[09:31:12.078]  - relaying element #2
[09:31:12.078] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.078] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.078] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.078]  length: 5 (resolved future 1)
[09:31:12.078] resolved() for ‘SequentialFuture’ ...
[09:31:12.078] - state: ‘finished’
[09:31:12.078] - run: TRUE
[09:31:12.078] - result: ‘FutureResult’
[09:31:12.078] resolved() for ‘SequentialFuture’ ... done
[09:31:12.078] Future #2
[09:31:12.079] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:12.079] - nx: 6
[09:31:12.079] - relay: TRUE
[09:31:12.079] - stdout: TRUE
[09:31:12.079] - signal: TRUE
[09:31:12.079] - resignal: FALSE
[09:31:12.079] - force: TRUE
[09:31:12.079] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.079] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.079]  - until=2
[09:31:12.079]  - relaying element #2
[09:31:12.080] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.080] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.080] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:12.080]  length: 4 (resolved future 2)
[09:31:12.080] resolved() for ‘SequentialFuture’ ...
[09:31:12.080] - state: ‘finished’
[09:31:12.080] - run: TRUE
[09:31:12.080] - result: ‘FutureResult’
[09:31:12.080] resolved() for ‘SequentialFuture’ ... done
[09:31:12.080] Future #3
[09:31:12.081] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:12.081] - nx: 6
[09:31:12.081] - relay: TRUE
[09:31:12.081] - stdout: TRUE
[09:31:12.081] - signal: TRUE
[09:31:12.081] - resignal: FALSE
[09:31:12.081] - force: TRUE
[09:31:12.081] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.081] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.081]  - until=3
[09:31:12.081]  - relaying element #3
[09:31:12.081] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.082] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.082] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:12.082]  length: 3 (resolved future 3)
[09:31:12.082] resolved() for ‘SequentialFuture’ ...
[09:31:12.082] - state: ‘finished’
[09:31:12.082] - run: TRUE
[09:31:12.082] - result: ‘FutureResult’
[09:31:12.082] resolved() for ‘SequentialFuture’ ... done
[09:31:12.082] Future #4
[09:31:12.082] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:12.083] - nx: 6
[09:31:12.083] - relay: TRUE
[09:31:12.083] - stdout: TRUE
[09:31:12.083] - signal: TRUE
[09:31:12.083] - resignal: FALSE
[09:31:12.083] - force: TRUE
[09:31:12.083] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.083] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.083]  - until=4
[09:31:12.083]  - relaying element #4
[09:31:12.083] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.083] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.084] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:12.084]  length: 2 (resolved future 4)
[09:31:12.084] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.084] - nx: 6
[09:31:12.084] - relay: TRUE
[09:31:12.084] - stdout: TRUE
[09:31:12.084] - signal: TRUE
[09:31:12.084] - resignal: FALSE
[09:31:12.084] - force: TRUE
[09:31:12.084] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.084] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.084]  - until=6
[09:31:12.085]  - relaying element #6
[09:31:12.085] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.085] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.085] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.085]  length: 1 (resolved future 5)
[09:31:12.085] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.085] - nx: 6
[09:31:12.085] - relay: TRUE
[09:31:12.085] - stdout: TRUE
[09:31:12.085] - signal: TRUE
[09:31:12.085] - resignal: FALSE
[09:31:12.085] - force: TRUE
[09:31:12.085] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.086] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.086]  - until=6
[09:31:12.086] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.086] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.086] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.086]  length: 0 (resolved future 6)
[09:31:12.086] Relaying remaining futures
[09:31:12.086] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.086] - nx: 6
[09:31:12.086] - relay: TRUE
[09:31:12.086] - stdout: TRUE
[09:31:12.086] - signal: TRUE
[09:31:12.087] - resignal: FALSE
[09:31:12.087] - force: TRUE
[09:31:12.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.087] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:12.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.087] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.087] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.087] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a3cb499a28> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:12.089] getGlobalsAndPackages() ...
[09:31:12.089] Searching for globals...
[09:31:12.090] 
[09:31:12.090] Searching for globals ... DONE
[09:31:12.090] - globals: [0] <none>
[09:31:12.090] getGlobalsAndPackages() ... DONE
[09:31:12.090] run() for ‘Future’ ...
[09:31:12.090] - state: ‘created’
[09:31:12.090] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.090] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.091]   - Field: ‘label’
[09:31:12.091]   - Field: ‘local’
[09:31:12.091]   - Field: ‘owner’
[09:31:12.091]   - Field: ‘envir’
[09:31:12.091]   - Field: ‘packages’
[09:31:12.091]   - Field: ‘gc’
[09:31:12.091]   - Field: ‘conditions’
[09:31:12.091]   - Field: ‘expr’
[09:31:12.091]   - Field: ‘uuid’
[09:31:12.091]   - Field: ‘seed’
[09:31:12.092]   - Field: ‘version’
[09:31:12.092]   - Field: ‘result’
[09:31:12.092]   - Field: ‘asynchronous’
[09:31:12.092]   - Field: ‘calls’
[09:31:12.092]   - Field: ‘globals’
[09:31:12.092]   - Field: ‘stdout’
[09:31:12.092]   - Field: ‘earlySignal’
[09:31:12.092]   - Field: ‘lazy’
[09:31:12.092]   - Field: ‘state’
[09:31:12.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.092] - Launch lazy future ...
[09:31:12.093] Packages needed by the future expression (n = 0): <none>
[09:31:12.093] Packages needed by future strategies (n = 0): <none>
[09:31:12.093] {
[09:31:12.093]     {
[09:31:12.093]         {
[09:31:12.093]             ...future.startTime <- base::Sys.time()
[09:31:12.093]             {
[09:31:12.093]                 {
[09:31:12.093]                   {
[09:31:12.093]                     base::local({
[09:31:12.093]                       has_future <- base::requireNamespace("future", 
[09:31:12.093]                         quietly = TRUE)
[09:31:12.093]                       if (has_future) {
[09:31:12.093]                         ns <- base::getNamespace("future")
[09:31:12.093]                         version <- ns[[".package"]][["version"]]
[09:31:12.093]                         if (is.null(version)) 
[09:31:12.093]                           version <- utils::packageVersion("future")
[09:31:12.093]                       }
[09:31:12.093]                       else {
[09:31:12.093]                         version <- NULL
[09:31:12.093]                       }
[09:31:12.093]                       if (!has_future || version < "1.8.0") {
[09:31:12.093]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.093]                           "", base::R.version$version.string), 
[09:31:12.093]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.093]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.093]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.093]                             "release", "version")], collapse = " "), 
[09:31:12.093]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.093]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.093]                           info)
[09:31:12.093]                         info <- base::paste(info, collapse = "; ")
[09:31:12.093]                         if (!has_future) {
[09:31:12.093]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.093]                             info)
[09:31:12.093]                         }
[09:31:12.093]                         else {
[09:31:12.093]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.093]                             info, version)
[09:31:12.093]                         }
[09:31:12.093]                         base::stop(msg)
[09:31:12.093]                       }
[09:31:12.093]                     })
[09:31:12.093]                   }
[09:31:12.093]                   ...future.strategy.old <- future::plan("list")
[09:31:12.093]                   options(future.plan = NULL)
[09:31:12.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.093]                 }
[09:31:12.093]                 ...future.workdir <- getwd()
[09:31:12.093]             }
[09:31:12.093]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.093]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.093]         }
[09:31:12.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.093]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.093]             base::names(...future.oldOptions))
[09:31:12.093]     }
[09:31:12.093]     if (FALSE) {
[09:31:12.093]     }
[09:31:12.093]     else {
[09:31:12.093]         if (TRUE) {
[09:31:12.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.093]                 open = "w")
[09:31:12.093]         }
[09:31:12.093]         else {
[09:31:12.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.093]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.093]         }
[09:31:12.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.093]             base::sink(type = "output", split = FALSE)
[09:31:12.093]             base::close(...future.stdout)
[09:31:12.093]         }, add = TRUE)
[09:31:12.093]     }
[09:31:12.093]     ...future.frame <- base::sys.nframe()
[09:31:12.093]     ...future.conditions <- base::list()
[09:31:12.093]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.093]     if (FALSE) {
[09:31:12.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.093]     }
[09:31:12.093]     ...future.result <- base::tryCatch({
[09:31:12.093]         base::withCallingHandlers({
[09:31:12.093]             ...future.value <- base::withVisible(base::local(2))
[09:31:12.093]             future::FutureResult(value = ...future.value$value, 
[09:31:12.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.093]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.093]                     ...future.globalenv.names))
[09:31:12.093]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.093]         }, condition = base::local({
[09:31:12.093]             c <- base::c
[09:31:12.093]             inherits <- base::inherits
[09:31:12.093]             invokeRestart <- base::invokeRestart
[09:31:12.093]             length <- base::length
[09:31:12.093]             list <- base::list
[09:31:12.093]             seq.int <- base::seq.int
[09:31:12.093]             signalCondition <- base::signalCondition
[09:31:12.093]             sys.calls <- base::sys.calls
[09:31:12.093]             `[[` <- base::`[[`
[09:31:12.093]             `+` <- base::`+`
[09:31:12.093]             `<<-` <- base::`<<-`
[09:31:12.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.093]                   3L)]
[09:31:12.093]             }
[09:31:12.093]             function(cond) {
[09:31:12.093]                 is_error <- inherits(cond, "error")
[09:31:12.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.093]                   NULL)
[09:31:12.093]                 if (is_error) {
[09:31:12.093]                   sessionInformation <- function() {
[09:31:12.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.093]                       search = base::search(), system = base::Sys.info())
[09:31:12.093]                   }
[09:31:12.093]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.093]                     cond$call), session = sessionInformation(), 
[09:31:12.093]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.093]                   signalCondition(cond)
[09:31:12.093]                 }
[09:31:12.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.093]                 "immediateCondition"))) {
[09:31:12.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.093]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.093]                   if (TRUE && !signal) {
[09:31:12.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.093]                     {
[09:31:12.093]                       inherits <- base::inherits
[09:31:12.093]                       invokeRestart <- base::invokeRestart
[09:31:12.093]                       is.null <- base::is.null
[09:31:12.093]                       muffled <- FALSE
[09:31:12.093]                       if (inherits(cond, "message")) {
[09:31:12.093]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.093]                         if (muffled) 
[09:31:12.093]                           invokeRestart("muffleMessage")
[09:31:12.093]                       }
[09:31:12.093]                       else if (inherits(cond, "warning")) {
[09:31:12.093]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.093]                         if (muffled) 
[09:31:12.093]                           invokeRestart("muffleWarning")
[09:31:12.093]                       }
[09:31:12.093]                       else if (inherits(cond, "condition")) {
[09:31:12.093]                         if (!is.null(pattern)) {
[09:31:12.093]                           computeRestarts <- base::computeRestarts
[09:31:12.093]                           grepl <- base::grepl
[09:31:12.093]                           restarts <- computeRestarts(cond)
[09:31:12.093]                           for (restart in restarts) {
[09:31:12.093]                             name <- restart$name
[09:31:12.093]                             if (is.null(name)) 
[09:31:12.093]                               next
[09:31:12.093]                             if (!grepl(pattern, name)) 
[09:31:12.093]                               next
[09:31:12.093]                             invokeRestart(restart)
[09:31:12.093]                             muffled <- TRUE
[09:31:12.093]                             break
[09:31:12.093]                           }
[09:31:12.093]                         }
[09:31:12.093]                       }
[09:31:12.093]                       invisible(muffled)
[09:31:12.093]                     }
[09:31:12.093]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.093]                   }
[09:31:12.093]                 }
[09:31:12.093]                 else {
[09:31:12.093]                   if (TRUE) {
[09:31:12.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.093]                     {
[09:31:12.093]                       inherits <- base::inherits
[09:31:12.093]                       invokeRestart <- base::invokeRestart
[09:31:12.093]                       is.null <- base::is.null
[09:31:12.093]                       muffled <- FALSE
[09:31:12.093]                       if (inherits(cond, "message")) {
[09:31:12.093]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.093]                         if (muffled) 
[09:31:12.093]                           invokeRestart("muffleMessage")
[09:31:12.093]                       }
[09:31:12.093]                       else if (inherits(cond, "warning")) {
[09:31:12.093]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.093]                         if (muffled) 
[09:31:12.093]                           invokeRestart("muffleWarning")
[09:31:12.093]                       }
[09:31:12.093]                       else if (inherits(cond, "condition")) {
[09:31:12.093]                         if (!is.null(pattern)) {
[09:31:12.093]                           computeRestarts <- base::computeRestarts
[09:31:12.093]                           grepl <- base::grepl
[09:31:12.093]                           restarts <- computeRestarts(cond)
[09:31:12.093]                           for (restart in restarts) {
[09:31:12.093]                             name <- restart$name
[09:31:12.093]                             if (is.null(name)) 
[09:31:12.093]                               next
[09:31:12.093]                             if (!grepl(pattern, name)) 
[09:31:12.093]                               next
[09:31:12.093]                             invokeRestart(restart)
[09:31:12.093]                             muffled <- TRUE
[09:31:12.093]                             break
[09:31:12.093]                           }
[09:31:12.093]                         }
[09:31:12.093]                       }
[09:31:12.093]                       invisible(muffled)
[09:31:12.093]                     }
[09:31:12.093]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.093]                   }
[09:31:12.093]                 }
[09:31:12.093]             }
[09:31:12.093]         }))
[09:31:12.093]     }, error = function(ex) {
[09:31:12.093]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.093]                 ...future.rng), started = ...future.startTime, 
[09:31:12.093]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.093]             version = "1.8"), class = "FutureResult")
[09:31:12.093]     }, finally = {
[09:31:12.093]         if (!identical(...future.workdir, getwd())) 
[09:31:12.093]             setwd(...future.workdir)
[09:31:12.093]         {
[09:31:12.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.093]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.093]             }
[09:31:12.093]             base::options(...future.oldOptions)
[09:31:12.093]             if (.Platform$OS.type == "windows") {
[09:31:12.093]                 old_names <- names(...future.oldEnvVars)
[09:31:12.093]                 envs <- base::Sys.getenv()
[09:31:12.093]                 names <- names(envs)
[09:31:12.093]                 common <- intersect(names, old_names)
[09:31:12.093]                 added <- setdiff(names, old_names)
[09:31:12.093]                 removed <- setdiff(old_names, names)
[09:31:12.093]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.093]                   envs[common]]
[09:31:12.093]                 NAMES <- toupper(changed)
[09:31:12.093]                 args <- list()
[09:31:12.093]                 for (kk in seq_along(NAMES)) {
[09:31:12.093]                   name <- changed[[kk]]
[09:31:12.093]                   NAME <- NAMES[[kk]]
[09:31:12.093]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.093]                     next
[09:31:12.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.093]                 }
[09:31:12.093]                 NAMES <- toupper(added)
[09:31:12.093]                 for (kk in seq_along(NAMES)) {
[09:31:12.093]                   name <- added[[kk]]
[09:31:12.093]                   NAME <- NAMES[[kk]]
[09:31:12.093]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.093]                     next
[09:31:12.093]                   args[[name]] <- ""
[09:31:12.093]                 }
[09:31:12.093]                 NAMES <- toupper(removed)
[09:31:12.093]                 for (kk in seq_along(NAMES)) {
[09:31:12.093]                   name <- removed[[kk]]
[09:31:12.093]                   NAME <- NAMES[[kk]]
[09:31:12.093]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.093]                     next
[09:31:12.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.093]                 }
[09:31:12.093]                 if (length(args) > 0) 
[09:31:12.093]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.093]             }
[09:31:12.093]             else {
[09:31:12.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.093]             }
[09:31:12.093]             {
[09:31:12.093]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.093]                   0L) {
[09:31:12.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.093]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.093]                   base::options(opts)
[09:31:12.093]                 }
[09:31:12.093]                 {
[09:31:12.093]                   {
[09:31:12.093]                     NULL
[09:31:12.093]                     RNGkind("Mersenne-Twister")
[09:31:12.093]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.093]                       inherits = FALSE)
[09:31:12.093]                   }
[09:31:12.093]                   options(future.plan = NULL)
[09:31:12.093]                   if (is.na(NA_character_)) 
[09:31:12.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.093]                     .init = FALSE)
[09:31:12.093]                 }
[09:31:12.093]             }
[09:31:12.093]         }
[09:31:12.093]     })
[09:31:12.093]     if (TRUE) {
[09:31:12.093]         base::sink(type = "output", split = FALSE)
[09:31:12.093]         if (TRUE) {
[09:31:12.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.093]         }
[09:31:12.093]         else {
[09:31:12.093]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.093]         }
[09:31:12.093]         base::close(...future.stdout)
[09:31:12.093]         ...future.stdout <- NULL
[09:31:12.093]     }
[09:31:12.093]     ...future.result$conditions <- ...future.conditions
[09:31:12.093]     ...future.result$finished <- base::Sys.time()
[09:31:12.093]     ...future.result
[09:31:12.093] }
[09:31:12.095] plan(): Setting new future strategy stack:
[09:31:12.095] List of future strategies:
[09:31:12.095] 1. sequential:
[09:31:12.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.095]    - tweaked: FALSE
[09:31:12.095]    - call: NULL
[09:31:12.095] plan(): nbrOfWorkers() = 1
[09:31:12.096] plan(): Setting new future strategy stack:
[09:31:12.096] List of future strategies:
[09:31:12.096] 1. sequential:
[09:31:12.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.096]    - tweaked: FALSE
[09:31:12.096]    - call: plan(strategy)
[09:31:12.096] plan(): nbrOfWorkers() = 1
[09:31:12.097] SequentialFuture started (and completed)
[09:31:12.097] - Launch lazy future ... done
[09:31:12.097] run() for ‘SequentialFuture’ ... done
[09:31:12.097] getGlobalsAndPackages() ...
[09:31:12.097] Searching for globals...
[09:31:12.097] 
[09:31:12.097] Searching for globals ... DONE
[09:31:12.097] - globals: [0] <none>
[09:31:12.097] getGlobalsAndPackages() ... DONE
[09:31:12.098] run() for ‘Future’ ...
[09:31:12.098] - state: ‘created’
[09:31:12.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.098]   - Field: ‘label’
[09:31:12.098]   - Field: ‘local’
[09:31:12.098]   - Field: ‘owner’
[09:31:12.099]   - Field: ‘envir’
[09:31:12.099]   - Field: ‘packages’
[09:31:12.099]   - Field: ‘gc’
[09:31:12.099]   - Field: ‘conditions’
[09:31:12.099]   - Field: ‘expr’
[09:31:12.099]   - Field: ‘uuid’
[09:31:12.099]   - Field: ‘seed’
[09:31:12.099]   - Field: ‘version’
[09:31:12.099]   - Field: ‘result’
[09:31:12.099]   - Field: ‘asynchronous’
[09:31:12.099]   - Field: ‘calls’
[09:31:12.100]   - Field: ‘globals’
[09:31:12.100]   - Field: ‘stdout’
[09:31:12.100]   - Field: ‘earlySignal’
[09:31:12.100]   - Field: ‘lazy’
[09:31:12.100]   - Field: ‘state’
[09:31:12.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.100] - Launch lazy future ...
[09:31:12.100] Packages needed by the future expression (n = 0): <none>
[09:31:12.100] Packages needed by future strategies (n = 0): <none>
[09:31:12.102] {
[09:31:12.102]     {
[09:31:12.102]         {
[09:31:12.102]             ...future.startTime <- base::Sys.time()
[09:31:12.102]             {
[09:31:12.102]                 {
[09:31:12.102]                   {
[09:31:12.102]                     base::local({
[09:31:12.102]                       has_future <- base::requireNamespace("future", 
[09:31:12.102]                         quietly = TRUE)
[09:31:12.102]                       if (has_future) {
[09:31:12.102]                         ns <- base::getNamespace("future")
[09:31:12.102]                         version <- ns[[".package"]][["version"]]
[09:31:12.102]                         if (is.null(version)) 
[09:31:12.102]                           version <- utils::packageVersion("future")
[09:31:12.102]                       }
[09:31:12.102]                       else {
[09:31:12.102]                         version <- NULL
[09:31:12.102]                       }
[09:31:12.102]                       if (!has_future || version < "1.8.0") {
[09:31:12.102]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.102]                           "", base::R.version$version.string), 
[09:31:12.102]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.102]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.102]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.102]                             "release", "version")], collapse = " "), 
[09:31:12.102]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.102]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.102]                           info)
[09:31:12.102]                         info <- base::paste(info, collapse = "; ")
[09:31:12.102]                         if (!has_future) {
[09:31:12.102]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.102]                             info)
[09:31:12.102]                         }
[09:31:12.102]                         else {
[09:31:12.102]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.102]                             info, version)
[09:31:12.102]                         }
[09:31:12.102]                         base::stop(msg)
[09:31:12.102]                       }
[09:31:12.102]                     })
[09:31:12.102]                   }
[09:31:12.102]                   ...future.strategy.old <- future::plan("list")
[09:31:12.102]                   options(future.plan = NULL)
[09:31:12.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.102]                 }
[09:31:12.102]                 ...future.workdir <- getwd()
[09:31:12.102]             }
[09:31:12.102]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.102]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.102]         }
[09:31:12.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.102]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.102]             base::names(...future.oldOptions))
[09:31:12.102]     }
[09:31:12.102]     if (FALSE) {
[09:31:12.102]     }
[09:31:12.102]     else {
[09:31:12.102]         if (TRUE) {
[09:31:12.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.102]                 open = "w")
[09:31:12.102]         }
[09:31:12.102]         else {
[09:31:12.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.102]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.102]         }
[09:31:12.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.102]             base::sink(type = "output", split = FALSE)
[09:31:12.102]             base::close(...future.stdout)
[09:31:12.102]         }, add = TRUE)
[09:31:12.102]     }
[09:31:12.102]     ...future.frame <- base::sys.nframe()
[09:31:12.102]     ...future.conditions <- base::list()
[09:31:12.102]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.102]     if (FALSE) {
[09:31:12.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.102]     }
[09:31:12.102]     ...future.result <- base::tryCatch({
[09:31:12.102]         base::withCallingHandlers({
[09:31:12.102]             ...future.value <- base::withVisible(base::local(NULL))
[09:31:12.102]             future::FutureResult(value = ...future.value$value, 
[09:31:12.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.102]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.102]                     ...future.globalenv.names))
[09:31:12.102]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.102]         }, condition = base::local({
[09:31:12.102]             c <- base::c
[09:31:12.102]             inherits <- base::inherits
[09:31:12.102]             invokeRestart <- base::invokeRestart
[09:31:12.102]             length <- base::length
[09:31:12.102]             list <- base::list
[09:31:12.102]             seq.int <- base::seq.int
[09:31:12.102]             signalCondition <- base::signalCondition
[09:31:12.102]             sys.calls <- base::sys.calls
[09:31:12.102]             `[[` <- base::`[[`
[09:31:12.102]             `+` <- base::`+`
[09:31:12.102]             `<<-` <- base::`<<-`
[09:31:12.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.102]                   3L)]
[09:31:12.102]             }
[09:31:12.102]             function(cond) {
[09:31:12.102]                 is_error <- inherits(cond, "error")
[09:31:12.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.102]                   NULL)
[09:31:12.102]                 if (is_error) {
[09:31:12.102]                   sessionInformation <- function() {
[09:31:12.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.102]                       search = base::search(), system = base::Sys.info())
[09:31:12.102]                   }
[09:31:12.102]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.102]                     cond$call), session = sessionInformation(), 
[09:31:12.102]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.102]                   signalCondition(cond)
[09:31:12.102]                 }
[09:31:12.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.102]                 "immediateCondition"))) {
[09:31:12.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.102]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.102]                   if (TRUE && !signal) {
[09:31:12.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.102]                     {
[09:31:12.102]                       inherits <- base::inherits
[09:31:12.102]                       invokeRestart <- base::invokeRestart
[09:31:12.102]                       is.null <- base::is.null
[09:31:12.102]                       muffled <- FALSE
[09:31:12.102]                       if (inherits(cond, "message")) {
[09:31:12.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.102]                         if (muffled) 
[09:31:12.102]                           invokeRestart("muffleMessage")
[09:31:12.102]                       }
[09:31:12.102]                       else if (inherits(cond, "warning")) {
[09:31:12.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.102]                         if (muffled) 
[09:31:12.102]                           invokeRestart("muffleWarning")
[09:31:12.102]                       }
[09:31:12.102]                       else if (inherits(cond, "condition")) {
[09:31:12.102]                         if (!is.null(pattern)) {
[09:31:12.102]                           computeRestarts <- base::computeRestarts
[09:31:12.102]                           grepl <- base::grepl
[09:31:12.102]                           restarts <- computeRestarts(cond)
[09:31:12.102]                           for (restart in restarts) {
[09:31:12.102]                             name <- restart$name
[09:31:12.102]                             if (is.null(name)) 
[09:31:12.102]                               next
[09:31:12.102]                             if (!grepl(pattern, name)) 
[09:31:12.102]                               next
[09:31:12.102]                             invokeRestart(restart)
[09:31:12.102]                             muffled <- TRUE
[09:31:12.102]                             break
[09:31:12.102]                           }
[09:31:12.102]                         }
[09:31:12.102]                       }
[09:31:12.102]                       invisible(muffled)
[09:31:12.102]                     }
[09:31:12.102]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.102]                   }
[09:31:12.102]                 }
[09:31:12.102]                 else {
[09:31:12.102]                   if (TRUE) {
[09:31:12.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.102]                     {
[09:31:12.102]                       inherits <- base::inherits
[09:31:12.102]                       invokeRestart <- base::invokeRestart
[09:31:12.102]                       is.null <- base::is.null
[09:31:12.102]                       muffled <- FALSE
[09:31:12.102]                       if (inherits(cond, "message")) {
[09:31:12.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.102]                         if (muffled) 
[09:31:12.102]                           invokeRestart("muffleMessage")
[09:31:12.102]                       }
[09:31:12.102]                       else if (inherits(cond, "warning")) {
[09:31:12.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.102]                         if (muffled) 
[09:31:12.102]                           invokeRestart("muffleWarning")
[09:31:12.102]                       }
[09:31:12.102]                       else if (inherits(cond, "condition")) {
[09:31:12.102]                         if (!is.null(pattern)) {
[09:31:12.102]                           computeRestarts <- base::computeRestarts
[09:31:12.102]                           grepl <- base::grepl
[09:31:12.102]                           restarts <- computeRestarts(cond)
[09:31:12.102]                           for (restart in restarts) {
[09:31:12.102]                             name <- restart$name
[09:31:12.102]                             if (is.null(name)) 
[09:31:12.102]                               next
[09:31:12.102]                             if (!grepl(pattern, name)) 
[09:31:12.102]                               next
[09:31:12.102]                             invokeRestart(restart)
[09:31:12.102]                             muffled <- TRUE
[09:31:12.102]                             break
[09:31:12.102]                           }
[09:31:12.102]                         }
[09:31:12.102]                       }
[09:31:12.102]                       invisible(muffled)
[09:31:12.102]                     }
[09:31:12.102]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.102]                   }
[09:31:12.102]                 }
[09:31:12.102]             }
[09:31:12.102]         }))
[09:31:12.102]     }, error = function(ex) {
[09:31:12.102]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.102]                 ...future.rng), started = ...future.startTime, 
[09:31:12.102]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.102]             version = "1.8"), class = "FutureResult")
[09:31:12.102]     }, finally = {
[09:31:12.102]         if (!identical(...future.workdir, getwd())) 
[09:31:12.102]             setwd(...future.workdir)
[09:31:12.102]         {
[09:31:12.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.102]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.102]             }
[09:31:12.102]             base::options(...future.oldOptions)
[09:31:12.102]             if (.Platform$OS.type == "windows") {
[09:31:12.102]                 old_names <- names(...future.oldEnvVars)
[09:31:12.102]                 envs <- base::Sys.getenv()
[09:31:12.102]                 names <- names(envs)
[09:31:12.102]                 common <- intersect(names, old_names)
[09:31:12.102]                 added <- setdiff(names, old_names)
[09:31:12.102]                 removed <- setdiff(old_names, names)
[09:31:12.102]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.102]                   envs[common]]
[09:31:12.102]                 NAMES <- toupper(changed)
[09:31:12.102]                 args <- list()
[09:31:12.102]                 for (kk in seq_along(NAMES)) {
[09:31:12.102]                   name <- changed[[kk]]
[09:31:12.102]                   NAME <- NAMES[[kk]]
[09:31:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.102]                     next
[09:31:12.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.102]                 }
[09:31:12.102]                 NAMES <- toupper(added)
[09:31:12.102]                 for (kk in seq_along(NAMES)) {
[09:31:12.102]                   name <- added[[kk]]
[09:31:12.102]                   NAME <- NAMES[[kk]]
[09:31:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.102]                     next
[09:31:12.102]                   args[[name]] <- ""
[09:31:12.102]                 }
[09:31:12.102]                 NAMES <- toupper(removed)
[09:31:12.102]                 for (kk in seq_along(NAMES)) {
[09:31:12.102]                   name <- removed[[kk]]
[09:31:12.102]                   NAME <- NAMES[[kk]]
[09:31:12.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.102]                     next
[09:31:12.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.102]                 }
[09:31:12.102]                 if (length(args) > 0) 
[09:31:12.102]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.102]             }
[09:31:12.102]             else {
[09:31:12.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.102]             }
[09:31:12.102]             {
[09:31:12.102]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.102]                   0L) {
[09:31:12.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.102]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.102]                   base::options(opts)
[09:31:12.102]                 }
[09:31:12.102]                 {
[09:31:12.102]                   {
[09:31:12.102]                     NULL
[09:31:12.102]                     RNGkind("Mersenne-Twister")
[09:31:12.102]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.102]                       inherits = FALSE)
[09:31:12.102]                   }
[09:31:12.102]                   options(future.plan = NULL)
[09:31:12.102]                   if (is.na(NA_character_)) 
[09:31:12.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.102]                     .init = FALSE)
[09:31:12.102]                 }
[09:31:12.102]             }
[09:31:12.102]         }
[09:31:12.102]     })
[09:31:12.102]     if (TRUE) {
[09:31:12.102]         base::sink(type = "output", split = FALSE)
[09:31:12.102]         if (TRUE) {
[09:31:12.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.102]         }
[09:31:12.102]         else {
[09:31:12.102]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.102]         }
[09:31:12.102]         base::close(...future.stdout)
[09:31:12.102]         ...future.stdout <- NULL
[09:31:12.102]     }
[09:31:12.102]     ...future.result$conditions <- ...future.conditions
[09:31:12.102]     ...future.result$finished <- base::Sys.time()
[09:31:12.102]     ...future.result
[09:31:12.102] }
[09:31:12.103] plan(): Setting new future strategy stack:
[09:31:12.103] List of future strategies:
[09:31:12.103] 1. sequential:
[09:31:12.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.103]    - tweaked: FALSE
[09:31:12.103]    - call: NULL
[09:31:12.104] plan(): nbrOfWorkers() = 1
[09:31:12.105] plan(): Setting new future strategy stack:
[09:31:12.105] List of future strategies:
[09:31:12.105] 1. sequential:
[09:31:12.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.105]    - tweaked: FALSE
[09:31:12.105]    - call: plan(strategy)
[09:31:12.105] plan(): nbrOfWorkers() = 1
[09:31:12.105] SequentialFuture started (and completed)
[09:31:12.105] - Launch lazy future ... done
[09:31:12.105] run() for ‘SequentialFuture’ ... done
[09:31:12.106] getGlobalsAndPackages() ...
[09:31:12.106] Searching for globals...
[09:31:12.106] - globals found: [1] ‘{’
[09:31:12.106] Searching for globals ... DONE
[09:31:12.107] Resolving globals: FALSE
[09:31:12.107] 
[09:31:12.107] 
[09:31:12.107] getGlobalsAndPackages() ... DONE
[09:31:12.107] run() for ‘Future’ ...
[09:31:12.107] - state: ‘created’
[09:31:12.107] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:12.108] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:12.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:12.108]   - Field: ‘label’
[09:31:12.108]   - Field: ‘local’
[09:31:12.108]   - Field: ‘owner’
[09:31:12.108]   - Field: ‘envir’
[09:31:12.108]   - Field: ‘packages’
[09:31:12.108]   - Field: ‘gc’
[09:31:12.108]   - Field: ‘conditions’
[09:31:12.108]   - Field: ‘expr’
[09:31:12.109]   - Field: ‘uuid’
[09:31:12.109]   - Field: ‘seed’
[09:31:12.109]   - Field: ‘version’
[09:31:12.109]   - Field: ‘result’
[09:31:12.109]   - Field: ‘asynchronous’
[09:31:12.109]   - Field: ‘calls’
[09:31:12.109]   - Field: ‘globals’
[09:31:12.109]   - Field: ‘stdout’
[09:31:12.109]   - Field: ‘earlySignal’
[09:31:12.109]   - Field: ‘lazy’
[09:31:12.109]   - Field: ‘state’
[09:31:12.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:12.110] - Launch lazy future ...
[09:31:12.110] Packages needed by the future expression (n = 0): <none>
[09:31:12.110] Packages needed by future strategies (n = 0): <none>
[09:31:12.110] {
[09:31:12.110]     {
[09:31:12.110]         {
[09:31:12.110]             ...future.startTime <- base::Sys.time()
[09:31:12.110]             {
[09:31:12.110]                 {
[09:31:12.110]                   {
[09:31:12.110]                     base::local({
[09:31:12.110]                       has_future <- base::requireNamespace("future", 
[09:31:12.110]                         quietly = TRUE)
[09:31:12.110]                       if (has_future) {
[09:31:12.110]                         ns <- base::getNamespace("future")
[09:31:12.110]                         version <- ns[[".package"]][["version"]]
[09:31:12.110]                         if (is.null(version)) 
[09:31:12.110]                           version <- utils::packageVersion("future")
[09:31:12.110]                       }
[09:31:12.110]                       else {
[09:31:12.110]                         version <- NULL
[09:31:12.110]                       }
[09:31:12.110]                       if (!has_future || version < "1.8.0") {
[09:31:12.110]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.110]                           "", base::R.version$version.string), 
[09:31:12.110]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:12.110]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.110]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.110]                             "release", "version")], collapse = " "), 
[09:31:12.110]                           hostname = base::Sys.info()[["nodename"]])
[09:31:12.110]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.110]                           info)
[09:31:12.110]                         info <- base::paste(info, collapse = "; ")
[09:31:12.110]                         if (!has_future) {
[09:31:12.110]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.110]                             info)
[09:31:12.110]                         }
[09:31:12.110]                         else {
[09:31:12.110]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.110]                             info, version)
[09:31:12.110]                         }
[09:31:12.110]                         base::stop(msg)
[09:31:12.110]                       }
[09:31:12.110]                     })
[09:31:12.110]                   }
[09:31:12.110]                   ...future.strategy.old <- future::plan("list")
[09:31:12.110]                   options(future.plan = NULL)
[09:31:12.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.110]                 }
[09:31:12.110]                 ...future.workdir <- getwd()
[09:31:12.110]             }
[09:31:12.110]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.110]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.110]         }
[09:31:12.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.110]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.110]             base::names(...future.oldOptions))
[09:31:12.110]     }
[09:31:12.110]     if (FALSE) {
[09:31:12.110]     }
[09:31:12.110]     else {
[09:31:12.110]         if (TRUE) {
[09:31:12.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.110]                 open = "w")
[09:31:12.110]         }
[09:31:12.110]         else {
[09:31:12.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.110]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.110]         }
[09:31:12.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.110]             base::sink(type = "output", split = FALSE)
[09:31:12.110]             base::close(...future.stdout)
[09:31:12.110]         }, add = TRUE)
[09:31:12.110]     }
[09:31:12.110]     ...future.frame <- base::sys.nframe()
[09:31:12.110]     ...future.conditions <- base::list()
[09:31:12.110]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.110]     if (FALSE) {
[09:31:12.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.110]     }
[09:31:12.110]     ...future.result <- base::tryCatch({
[09:31:12.110]         base::withCallingHandlers({
[09:31:12.110]             ...future.value <- base::withVisible(base::local({
[09:31:12.110]                 4
[09:31:12.110]             }))
[09:31:12.110]             future::FutureResult(value = ...future.value$value, 
[09:31:12.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.110]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.110]                     ...future.globalenv.names))
[09:31:12.110]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.110]         }, condition = base::local({
[09:31:12.110]             c <- base::c
[09:31:12.110]             inherits <- base::inherits
[09:31:12.110]             invokeRestart <- base::invokeRestart
[09:31:12.110]             length <- base::length
[09:31:12.110]             list <- base::list
[09:31:12.110]             seq.int <- base::seq.int
[09:31:12.110]             signalCondition <- base::signalCondition
[09:31:12.110]             sys.calls <- base::sys.calls
[09:31:12.110]             `[[` <- base::`[[`
[09:31:12.110]             `+` <- base::`+`
[09:31:12.110]             `<<-` <- base::`<<-`
[09:31:12.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.110]                   3L)]
[09:31:12.110]             }
[09:31:12.110]             function(cond) {
[09:31:12.110]                 is_error <- inherits(cond, "error")
[09:31:12.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.110]                   NULL)
[09:31:12.110]                 if (is_error) {
[09:31:12.110]                   sessionInformation <- function() {
[09:31:12.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.110]                       search = base::search(), system = base::Sys.info())
[09:31:12.110]                   }
[09:31:12.110]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.110]                     cond$call), session = sessionInformation(), 
[09:31:12.110]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.110]                   signalCondition(cond)
[09:31:12.110]                 }
[09:31:12.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.110]                 "immediateCondition"))) {
[09:31:12.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.110]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.110]                   if (TRUE && !signal) {
[09:31:12.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.110]                     {
[09:31:12.110]                       inherits <- base::inherits
[09:31:12.110]                       invokeRestart <- base::invokeRestart
[09:31:12.110]                       is.null <- base::is.null
[09:31:12.110]                       muffled <- FALSE
[09:31:12.110]                       if (inherits(cond, "message")) {
[09:31:12.110]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.110]                         if (muffled) 
[09:31:12.110]                           invokeRestart("muffleMessage")
[09:31:12.110]                       }
[09:31:12.110]                       else if (inherits(cond, "warning")) {
[09:31:12.110]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.110]                         if (muffled) 
[09:31:12.110]                           invokeRestart("muffleWarning")
[09:31:12.110]                       }
[09:31:12.110]                       else if (inherits(cond, "condition")) {
[09:31:12.110]                         if (!is.null(pattern)) {
[09:31:12.110]                           computeRestarts <- base::computeRestarts
[09:31:12.110]                           grepl <- base::grepl
[09:31:12.110]                           restarts <- computeRestarts(cond)
[09:31:12.110]                           for (restart in restarts) {
[09:31:12.110]                             name <- restart$name
[09:31:12.110]                             if (is.null(name)) 
[09:31:12.110]                               next
[09:31:12.110]                             if (!grepl(pattern, name)) 
[09:31:12.110]                               next
[09:31:12.110]                             invokeRestart(restart)
[09:31:12.110]                             muffled <- TRUE
[09:31:12.110]                             break
[09:31:12.110]                           }
[09:31:12.110]                         }
[09:31:12.110]                       }
[09:31:12.110]                       invisible(muffled)
[09:31:12.110]                     }
[09:31:12.110]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.110]                   }
[09:31:12.110]                 }
[09:31:12.110]                 else {
[09:31:12.110]                   if (TRUE) {
[09:31:12.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.110]                     {
[09:31:12.110]                       inherits <- base::inherits
[09:31:12.110]                       invokeRestart <- base::invokeRestart
[09:31:12.110]                       is.null <- base::is.null
[09:31:12.110]                       muffled <- FALSE
[09:31:12.110]                       if (inherits(cond, "message")) {
[09:31:12.110]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.110]                         if (muffled) 
[09:31:12.110]                           invokeRestart("muffleMessage")
[09:31:12.110]                       }
[09:31:12.110]                       else if (inherits(cond, "warning")) {
[09:31:12.110]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.110]                         if (muffled) 
[09:31:12.110]                           invokeRestart("muffleWarning")
[09:31:12.110]                       }
[09:31:12.110]                       else if (inherits(cond, "condition")) {
[09:31:12.110]                         if (!is.null(pattern)) {
[09:31:12.110]                           computeRestarts <- base::computeRestarts
[09:31:12.110]                           grepl <- base::grepl
[09:31:12.110]                           restarts <- computeRestarts(cond)
[09:31:12.110]                           for (restart in restarts) {
[09:31:12.110]                             name <- restart$name
[09:31:12.110]                             if (is.null(name)) 
[09:31:12.110]                               next
[09:31:12.110]                             if (!grepl(pattern, name)) 
[09:31:12.110]                               next
[09:31:12.110]                             invokeRestart(restart)
[09:31:12.110]                             muffled <- TRUE
[09:31:12.110]                             break
[09:31:12.110]                           }
[09:31:12.110]                         }
[09:31:12.110]                       }
[09:31:12.110]                       invisible(muffled)
[09:31:12.110]                     }
[09:31:12.110]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.110]                   }
[09:31:12.110]                 }
[09:31:12.110]             }
[09:31:12.110]         }))
[09:31:12.110]     }, error = function(ex) {
[09:31:12.110]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.110]                 ...future.rng), started = ...future.startTime, 
[09:31:12.110]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.110]             version = "1.8"), class = "FutureResult")
[09:31:12.110]     }, finally = {
[09:31:12.110]         if (!identical(...future.workdir, getwd())) 
[09:31:12.110]             setwd(...future.workdir)
[09:31:12.110]         {
[09:31:12.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.110]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.110]             }
[09:31:12.110]             base::options(...future.oldOptions)
[09:31:12.110]             if (.Platform$OS.type == "windows") {
[09:31:12.110]                 old_names <- names(...future.oldEnvVars)
[09:31:12.110]                 envs <- base::Sys.getenv()
[09:31:12.110]                 names <- names(envs)
[09:31:12.110]                 common <- intersect(names, old_names)
[09:31:12.110]                 added <- setdiff(names, old_names)
[09:31:12.110]                 removed <- setdiff(old_names, names)
[09:31:12.110]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.110]                   envs[common]]
[09:31:12.110]                 NAMES <- toupper(changed)
[09:31:12.110]                 args <- list()
[09:31:12.110]                 for (kk in seq_along(NAMES)) {
[09:31:12.110]                   name <- changed[[kk]]
[09:31:12.110]                   NAME <- NAMES[[kk]]
[09:31:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.110]                     next
[09:31:12.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.110]                 }
[09:31:12.110]                 NAMES <- toupper(added)
[09:31:12.110]                 for (kk in seq_along(NAMES)) {
[09:31:12.110]                   name <- added[[kk]]
[09:31:12.110]                   NAME <- NAMES[[kk]]
[09:31:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.110]                     next
[09:31:12.110]                   args[[name]] <- ""
[09:31:12.110]                 }
[09:31:12.110]                 NAMES <- toupper(removed)
[09:31:12.110]                 for (kk in seq_along(NAMES)) {
[09:31:12.110]                   name <- removed[[kk]]
[09:31:12.110]                   NAME <- NAMES[[kk]]
[09:31:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.110]                     next
[09:31:12.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.110]                 }
[09:31:12.110]                 if (length(args) > 0) 
[09:31:12.110]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.110]             }
[09:31:12.110]             else {
[09:31:12.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.110]             }
[09:31:12.110]             {
[09:31:12.110]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.110]                   0L) {
[09:31:12.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.110]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.110]                   base::options(opts)
[09:31:12.110]                 }
[09:31:12.110]                 {
[09:31:12.110]                   {
[09:31:12.110]                     NULL
[09:31:12.110]                     RNGkind("Mersenne-Twister")
[09:31:12.110]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:12.110]                       inherits = FALSE)
[09:31:12.110]                   }
[09:31:12.110]                   options(future.plan = NULL)
[09:31:12.110]                   if (is.na(NA_character_)) 
[09:31:12.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.110]                     .init = FALSE)
[09:31:12.110]                 }
[09:31:12.110]             }
[09:31:12.110]         }
[09:31:12.110]     })
[09:31:12.110]     if (TRUE) {
[09:31:12.110]         base::sink(type = "output", split = FALSE)
[09:31:12.110]         if (TRUE) {
[09:31:12.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.110]         }
[09:31:12.110]         else {
[09:31:12.110]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.110]         }
[09:31:12.110]         base::close(...future.stdout)
[09:31:12.110]         ...future.stdout <- NULL
[09:31:12.110]     }
[09:31:12.110]     ...future.result$conditions <- ...future.conditions
[09:31:12.110]     ...future.result$finished <- base::Sys.time()
[09:31:12.110]     ...future.result
[09:31:12.110] }
[09:31:12.112] plan(): Setting new future strategy stack:
[09:31:12.112] List of future strategies:
[09:31:12.112] 1. sequential:
[09:31:12.112]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.112]    - tweaked: FALSE
[09:31:12.112]    - call: NULL
[09:31:12.112] plan(): nbrOfWorkers() = 1
[09:31:12.113] plan(): Setting new future strategy stack:
[09:31:12.113] List of future strategies:
[09:31:12.113] 1. sequential:
[09:31:12.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.113]    - tweaked: FALSE
[09:31:12.113]    - call: plan(strategy)
[09:31:12.114] plan(): nbrOfWorkers() = 1
[09:31:12.114] SequentialFuture started (and completed)
[09:31:12.114] - Launch lazy future ... done
[09:31:12.114] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3caba8100> 
Classes 'listenv', 'environment' <environment: 0x55a3ca720838> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:12.118] resolved() for ‘SequentialFuture’ ...
[09:31:12.118] - state: ‘finished’
[09:31:12.118] - run: TRUE
[09:31:12.118] - result: ‘FutureResult’
[09:31:12.118] resolved() for ‘SequentialFuture’ ... done
[09:31:12.118] resolved() for ‘SequentialFuture’ ...
[09:31:12.118] - state: ‘finished’
[09:31:12.118] - run: TRUE
[09:31:12.118] - result: ‘FutureResult’
[09:31:12.118] resolved() for ‘SequentialFuture’ ... done
[09:31:12.118] resolved() for ‘SequentialFuture’ ...
[09:31:12.119] - state: ‘finished’
[09:31:12.119] - run: TRUE
[09:31:12.119] - result: ‘FutureResult’
[09:31:12.119] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:12.121] resolve() on list environment ...
[09:31:12.121]  recursive: 0
[09:31:12.122]  length: 6
[09:31:12.122]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:12.123] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.123] - nx: 6
[09:31:12.123] - relay: TRUE
[09:31:12.123] - stdout: TRUE
[09:31:12.123] - signal: TRUE
[09:31:12.123] - resignal: FALSE
[09:31:12.123] - force: TRUE
[09:31:12.123] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.123] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.123]  - until=2
[09:31:12.123]  - relaying element #2
[09:31:12.123] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.124] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.124] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.124]  length: 5 (resolved future 1)
[09:31:12.124] resolved() for ‘SequentialFuture’ ...
[09:31:12.124] - state: ‘finished’
[09:31:12.124] - run: TRUE
[09:31:12.124] - result: ‘FutureResult’
[09:31:12.124] resolved() for ‘SequentialFuture’ ... done
[09:31:12.124] Future #2
[09:31:12.124] signalConditionsASAP(SequentialFuture, pos=2) ...
[09:31:12.125] - nx: 6
[09:31:12.125] - relay: TRUE
[09:31:12.125] - stdout: TRUE
[09:31:12.125] - signal: TRUE
[09:31:12.125] - resignal: FALSE
[09:31:12.125] - force: TRUE
[09:31:12.125] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.125] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.125]  - until=2
[09:31:12.125]  - relaying element #2
[09:31:12.125] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.126] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.126] signalConditionsASAP(SequentialFuture, pos=2) ... done
[09:31:12.126]  length: 4 (resolved future 2)
[09:31:12.126] resolved() for ‘SequentialFuture’ ...
[09:31:12.126] - state: ‘finished’
[09:31:12.126] - run: TRUE
[09:31:12.126] - result: ‘FutureResult’
[09:31:12.126] resolved() for ‘SequentialFuture’ ... done
[09:31:12.126] Future #3
[09:31:12.126] signalConditionsASAP(SequentialFuture, pos=3) ...
[09:31:12.126] - nx: 6
[09:31:12.127] - relay: TRUE
[09:31:12.127] - stdout: TRUE
[09:31:12.127] - signal: TRUE
[09:31:12.127] - resignal: FALSE
[09:31:12.127] - force: TRUE
[09:31:12.127] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.127] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.127]  - until=3
[09:31:12.127]  - relaying element #3
[09:31:12.128] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.129] signalConditionsASAP(SequentialFuture, pos=3) ... done
[09:31:12.129]  length: 3 (resolved future 3)
[09:31:12.129] resolved() for ‘SequentialFuture’ ...
[09:31:12.129] - state: ‘finished’
[09:31:12.129] - run: TRUE
[09:31:12.129] - result: ‘FutureResult’
[09:31:12.129] resolved() for ‘SequentialFuture’ ... done
[09:31:12.129] Future #4
[09:31:12.129] signalConditionsASAP(SequentialFuture, pos=4) ...
[09:31:12.129] - nx: 6
[09:31:12.130] - relay: TRUE
[09:31:12.130] - stdout: TRUE
[09:31:12.130] - signal: TRUE
[09:31:12.130] - resignal: FALSE
[09:31:12.130] - force: TRUE
[09:31:12.130] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.130] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.130]  - until=4
[09:31:12.130]  - relaying element #4
[09:31:12.130] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.130] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.131] signalConditionsASAP(SequentialFuture, pos=4) ... done
[09:31:12.131]  length: 2 (resolved future 4)
[09:31:12.131] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.131] - nx: 6
[09:31:12.131] - relay: TRUE
[09:31:12.131] - stdout: TRUE
[09:31:12.131] - signal: TRUE
[09:31:12.131] - resignal: FALSE
[09:31:12.131] - force: TRUE
[09:31:12.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.131] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.131]  - until=6
[09:31:12.132]  - relaying element #6
[09:31:12.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.132] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.132] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.132]  length: 1 (resolved future 5)
[09:31:12.132] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.132] - nx: 6
[09:31:12.132] - relay: TRUE
[09:31:12.132] - stdout: TRUE
[09:31:12.132] - signal: TRUE
[09:31:12.132] - resignal: FALSE
[09:31:12.132] - force: TRUE
[09:31:12.133] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.133] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.133]  - until=6
[09:31:12.133] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.133] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.133] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.133]  length: 0 (resolved future 6)
[09:31:12.133] Relaying remaining futures
[09:31:12.133] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.133] - nx: 6
[09:31:12.133] - relay: TRUE
[09:31:12.133] - stdout: TRUE
[09:31:12.133] - signal: TRUE
[09:31:12.134] - resignal: FALSE
[09:31:12.134] - force: TRUE
[09:31:12.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.134] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:12.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.134] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.134] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.134] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a3cadd9978> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[09:31:12.137] plan(): Setting new future strategy stack:
[09:31:12.137] List of future strategies:
[09:31:12.137] 1. multicore:
[09:31:12.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.137]    - tweaked: FALSE
[09:31:12.137]    - call: plan(strategy)
[09:31:12.141] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:12.141] getGlobalsAndPackages() ...
[09:31:12.141] Searching for globals...
[09:31:12.141] 
[09:31:12.141] Searching for globals ... DONE
[09:31:12.141] - globals: [0] <none>
[09:31:12.142] getGlobalsAndPackages() ... DONE
[09:31:12.142] run() for ‘Future’ ...
[09:31:12.142] - state: ‘created’
[09:31:12.142] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.145] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.146]   - Field: ‘label’
[09:31:12.146]   - Field: ‘local’
[09:31:12.146]   - Field: ‘owner’
[09:31:12.146]   - Field: ‘envir’
[09:31:12.146]   - Field: ‘workers’
[09:31:12.146]   - Field: ‘packages’
[09:31:12.146]   - Field: ‘gc’
[09:31:12.146]   - Field: ‘job’
[09:31:12.146]   - Field: ‘conditions’
[09:31:12.146]   - Field: ‘expr’
[09:31:12.147]   - Field: ‘uuid’
[09:31:12.147]   - Field: ‘seed’
[09:31:12.147]   - Field: ‘version’
[09:31:12.147]   - Field: ‘result’
[09:31:12.147]   - Field: ‘asynchronous’
[09:31:12.147]   - Field: ‘calls’
[09:31:12.147]   - Field: ‘globals’
[09:31:12.147]   - Field: ‘stdout’
[09:31:12.147]   - Field: ‘earlySignal’
[09:31:12.147]   - Field: ‘lazy’
[09:31:12.147]   - Field: ‘state’
[09:31:12.147] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.148] - Launch lazy future ...
[09:31:12.148] Packages needed by the future expression (n = 0): <none>
[09:31:12.149] Packages needed by future strategies (n = 0): <none>
[09:31:12.149] {
[09:31:12.149]     {
[09:31:12.149]         {
[09:31:12.149]             ...future.startTime <- base::Sys.time()
[09:31:12.149]             {
[09:31:12.149]                 {
[09:31:12.149]                   {
[09:31:12.149]                     {
[09:31:12.149]                       base::local({
[09:31:12.149]                         has_future <- base::requireNamespace("future", 
[09:31:12.149]                           quietly = TRUE)
[09:31:12.149]                         if (has_future) {
[09:31:12.149]                           ns <- base::getNamespace("future")
[09:31:12.149]                           version <- ns[[".package"]][["version"]]
[09:31:12.149]                           if (is.null(version)) 
[09:31:12.149]                             version <- utils::packageVersion("future")
[09:31:12.149]                         }
[09:31:12.149]                         else {
[09:31:12.149]                           version <- NULL
[09:31:12.149]                         }
[09:31:12.149]                         if (!has_future || version < "1.8.0") {
[09:31:12.149]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.149]                             "", base::R.version$version.string), 
[09:31:12.149]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.149]                               "release", "version")], collapse = " "), 
[09:31:12.149]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.149]                             info)
[09:31:12.149]                           info <- base::paste(info, collapse = "; ")
[09:31:12.149]                           if (!has_future) {
[09:31:12.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.149]                               info)
[09:31:12.149]                           }
[09:31:12.149]                           else {
[09:31:12.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.149]                               info, version)
[09:31:12.149]                           }
[09:31:12.149]                           base::stop(msg)
[09:31:12.149]                         }
[09:31:12.149]                       })
[09:31:12.149]                     }
[09:31:12.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.149]                     base::options(mc.cores = 1L)
[09:31:12.149]                   }
[09:31:12.149]                   ...future.strategy.old <- future::plan("list")
[09:31:12.149]                   options(future.plan = NULL)
[09:31:12.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.149]                 }
[09:31:12.149]                 ...future.workdir <- getwd()
[09:31:12.149]             }
[09:31:12.149]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.149]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.149]         }
[09:31:12.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.149]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.149]             base::names(...future.oldOptions))
[09:31:12.149]     }
[09:31:12.149]     if (FALSE) {
[09:31:12.149]     }
[09:31:12.149]     else {
[09:31:12.149]         if (TRUE) {
[09:31:12.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.149]                 open = "w")
[09:31:12.149]         }
[09:31:12.149]         else {
[09:31:12.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.149]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.149]         }
[09:31:12.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.149]             base::sink(type = "output", split = FALSE)
[09:31:12.149]             base::close(...future.stdout)
[09:31:12.149]         }, add = TRUE)
[09:31:12.149]     }
[09:31:12.149]     ...future.frame <- base::sys.nframe()
[09:31:12.149]     ...future.conditions <- base::list()
[09:31:12.149]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.149]     if (FALSE) {
[09:31:12.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.149]     }
[09:31:12.149]     ...future.result <- base::tryCatch({
[09:31:12.149]         base::withCallingHandlers({
[09:31:12.149]             ...future.value <- base::withVisible(base::local({
[09:31:12.149]                 withCallingHandlers({
[09:31:12.149]                   2
[09:31:12.149]                 }, immediateCondition = function(cond) {
[09:31:12.149]                   save_rds <- function (object, pathname, ...) 
[09:31:12.149]                   {
[09:31:12.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.149]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.149]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.149]                         fi_tmp[["mtime"]])
[09:31:12.149]                     }
[09:31:12.149]                     tryCatch({
[09:31:12.149]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.149]                     }, error = function(ex) {
[09:31:12.149]                       msg <- conditionMessage(ex)
[09:31:12.149]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.149]                         fi_tmp[["mtime"]], msg)
[09:31:12.149]                       ex$message <- msg
[09:31:12.149]                       stop(ex)
[09:31:12.149]                     })
[09:31:12.149]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.149]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.149]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.149]                       fi <- file.info(pathname)
[09:31:12.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.149]                         fi[["size"]], fi[["mtime"]])
[09:31:12.149]                       stop(msg)
[09:31:12.149]                     }
[09:31:12.149]                     invisible(pathname)
[09:31:12.149]                   }
[09:31:12.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.149]                     rootPath = tempdir()) 
[09:31:12.149]                   {
[09:31:12.149]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.149]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.149]                       tmpdir = path, fileext = ".rds")
[09:31:12.149]                     save_rds(obj, file)
[09:31:12.149]                   }
[09:31:12.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.149]                   {
[09:31:12.149]                     inherits <- base::inherits
[09:31:12.149]                     invokeRestart <- base::invokeRestart
[09:31:12.149]                     is.null <- base::is.null
[09:31:12.149]                     muffled <- FALSE
[09:31:12.149]                     if (inherits(cond, "message")) {
[09:31:12.149]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.149]                       if (muffled) 
[09:31:12.149]                         invokeRestart("muffleMessage")
[09:31:12.149]                     }
[09:31:12.149]                     else if (inherits(cond, "warning")) {
[09:31:12.149]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.149]                       if (muffled) 
[09:31:12.149]                         invokeRestart("muffleWarning")
[09:31:12.149]                     }
[09:31:12.149]                     else if (inherits(cond, "condition")) {
[09:31:12.149]                       if (!is.null(pattern)) {
[09:31:12.149]                         computeRestarts <- base::computeRestarts
[09:31:12.149]                         grepl <- base::grepl
[09:31:12.149]                         restarts <- computeRestarts(cond)
[09:31:12.149]                         for (restart in restarts) {
[09:31:12.149]                           name <- restart$name
[09:31:12.149]                           if (is.null(name)) 
[09:31:12.149]                             next
[09:31:12.149]                           if (!grepl(pattern, name)) 
[09:31:12.149]                             next
[09:31:12.149]                           invokeRestart(restart)
[09:31:12.149]                           muffled <- TRUE
[09:31:12.149]                           break
[09:31:12.149]                         }
[09:31:12.149]                       }
[09:31:12.149]                     }
[09:31:12.149]                     invisible(muffled)
[09:31:12.149]                   }
[09:31:12.149]                   muffleCondition(cond)
[09:31:12.149]                 })
[09:31:12.149]             }))
[09:31:12.149]             future::FutureResult(value = ...future.value$value, 
[09:31:12.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.149]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.149]                     ...future.globalenv.names))
[09:31:12.149]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.149]         }, condition = base::local({
[09:31:12.149]             c <- base::c
[09:31:12.149]             inherits <- base::inherits
[09:31:12.149]             invokeRestart <- base::invokeRestart
[09:31:12.149]             length <- base::length
[09:31:12.149]             list <- base::list
[09:31:12.149]             seq.int <- base::seq.int
[09:31:12.149]             signalCondition <- base::signalCondition
[09:31:12.149]             sys.calls <- base::sys.calls
[09:31:12.149]             `[[` <- base::`[[`
[09:31:12.149]             `+` <- base::`+`
[09:31:12.149]             `<<-` <- base::`<<-`
[09:31:12.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.149]                   3L)]
[09:31:12.149]             }
[09:31:12.149]             function(cond) {
[09:31:12.149]                 is_error <- inherits(cond, "error")
[09:31:12.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.149]                   NULL)
[09:31:12.149]                 if (is_error) {
[09:31:12.149]                   sessionInformation <- function() {
[09:31:12.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.149]                       search = base::search(), system = base::Sys.info())
[09:31:12.149]                   }
[09:31:12.149]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.149]                     cond$call), session = sessionInformation(), 
[09:31:12.149]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.149]                   signalCondition(cond)
[09:31:12.149]                 }
[09:31:12.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.149]                 "immediateCondition"))) {
[09:31:12.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.149]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.149]                   if (TRUE && !signal) {
[09:31:12.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.149]                     {
[09:31:12.149]                       inherits <- base::inherits
[09:31:12.149]                       invokeRestart <- base::invokeRestart
[09:31:12.149]                       is.null <- base::is.null
[09:31:12.149]                       muffled <- FALSE
[09:31:12.149]                       if (inherits(cond, "message")) {
[09:31:12.149]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.149]                         if (muffled) 
[09:31:12.149]                           invokeRestart("muffleMessage")
[09:31:12.149]                       }
[09:31:12.149]                       else if (inherits(cond, "warning")) {
[09:31:12.149]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.149]                         if (muffled) 
[09:31:12.149]                           invokeRestart("muffleWarning")
[09:31:12.149]                       }
[09:31:12.149]                       else if (inherits(cond, "condition")) {
[09:31:12.149]                         if (!is.null(pattern)) {
[09:31:12.149]                           computeRestarts <- base::computeRestarts
[09:31:12.149]                           grepl <- base::grepl
[09:31:12.149]                           restarts <- computeRestarts(cond)
[09:31:12.149]                           for (restart in restarts) {
[09:31:12.149]                             name <- restart$name
[09:31:12.149]                             if (is.null(name)) 
[09:31:12.149]                               next
[09:31:12.149]                             if (!grepl(pattern, name)) 
[09:31:12.149]                               next
[09:31:12.149]                             invokeRestart(restart)
[09:31:12.149]                             muffled <- TRUE
[09:31:12.149]                             break
[09:31:12.149]                           }
[09:31:12.149]                         }
[09:31:12.149]                       }
[09:31:12.149]                       invisible(muffled)
[09:31:12.149]                     }
[09:31:12.149]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.149]                   }
[09:31:12.149]                 }
[09:31:12.149]                 else {
[09:31:12.149]                   if (TRUE) {
[09:31:12.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.149]                     {
[09:31:12.149]                       inherits <- base::inherits
[09:31:12.149]                       invokeRestart <- base::invokeRestart
[09:31:12.149]                       is.null <- base::is.null
[09:31:12.149]                       muffled <- FALSE
[09:31:12.149]                       if (inherits(cond, "message")) {
[09:31:12.149]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.149]                         if (muffled) 
[09:31:12.149]                           invokeRestart("muffleMessage")
[09:31:12.149]                       }
[09:31:12.149]                       else if (inherits(cond, "warning")) {
[09:31:12.149]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.149]                         if (muffled) 
[09:31:12.149]                           invokeRestart("muffleWarning")
[09:31:12.149]                       }
[09:31:12.149]                       else if (inherits(cond, "condition")) {
[09:31:12.149]                         if (!is.null(pattern)) {
[09:31:12.149]                           computeRestarts <- base::computeRestarts
[09:31:12.149]                           grepl <- base::grepl
[09:31:12.149]                           restarts <- computeRestarts(cond)
[09:31:12.149]                           for (restart in restarts) {
[09:31:12.149]                             name <- restart$name
[09:31:12.149]                             if (is.null(name)) 
[09:31:12.149]                               next
[09:31:12.149]                             if (!grepl(pattern, name)) 
[09:31:12.149]                               next
[09:31:12.149]                             invokeRestart(restart)
[09:31:12.149]                             muffled <- TRUE
[09:31:12.149]                             break
[09:31:12.149]                           }
[09:31:12.149]                         }
[09:31:12.149]                       }
[09:31:12.149]                       invisible(muffled)
[09:31:12.149]                     }
[09:31:12.149]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.149]                   }
[09:31:12.149]                 }
[09:31:12.149]             }
[09:31:12.149]         }))
[09:31:12.149]     }, error = function(ex) {
[09:31:12.149]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.149]                 ...future.rng), started = ...future.startTime, 
[09:31:12.149]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.149]             version = "1.8"), class = "FutureResult")
[09:31:12.149]     }, finally = {
[09:31:12.149]         if (!identical(...future.workdir, getwd())) 
[09:31:12.149]             setwd(...future.workdir)
[09:31:12.149]         {
[09:31:12.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.149]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.149]             }
[09:31:12.149]             base::options(...future.oldOptions)
[09:31:12.149]             if (.Platform$OS.type == "windows") {
[09:31:12.149]                 old_names <- names(...future.oldEnvVars)
[09:31:12.149]                 envs <- base::Sys.getenv()
[09:31:12.149]                 names <- names(envs)
[09:31:12.149]                 common <- intersect(names, old_names)
[09:31:12.149]                 added <- setdiff(names, old_names)
[09:31:12.149]                 removed <- setdiff(old_names, names)
[09:31:12.149]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.149]                   envs[common]]
[09:31:12.149]                 NAMES <- toupper(changed)
[09:31:12.149]                 args <- list()
[09:31:12.149]                 for (kk in seq_along(NAMES)) {
[09:31:12.149]                   name <- changed[[kk]]
[09:31:12.149]                   NAME <- NAMES[[kk]]
[09:31:12.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.149]                     next
[09:31:12.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.149]                 }
[09:31:12.149]                 NAMES <- toupper(added)
[09:31:12.149]                 for (kk in seq_along(NAMES)) {
[09:31:12.149]                   name <- added[[kk]]
[09:31:12.149]                   NAME <- NAMES[[kk]]
[09:31:12.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.149]                     next
[09:31:12.149]                   args[[name]] <- ""
[09:31:12.149]                 }
[09:31:12.149]                 NAMES <- toupper(removed)
[09:31:12.149]                 for (kk in seq_along(NAMES)) {
[09:31:12.149]                   name <- removed[[kk]]
[09:31:12.149]                   NAME <- NAMES[[kk]]
[09:31:12.149]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.149]                     next
[09:31:12.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.149]                 }
[09:31:12.149]                 if (length(args) > 0) 
[09:31:12.149]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.149]             }
[09:31:12.149]             else {
[09:31:12.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.149]             }
[09:31:12.149]             {
[09:31:12.149]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.149]                   0L) {
[09:31:12.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.149]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.149]                   base::options(opts)
[09:31:12.149]                 }
[09:31:12.149]                 {
[09:31:12.149]                   {
[09:31:12.149]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.149]                     NULL
[09:31:12.149]                   }
[09:31:12.149]                   options(future.plan = NULL)
[09:31:12.149]                   if (is.na(NA_character_)) 
[09:31:12.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.149]                     .init = FALSE)
[09:31:12.149]                 }
[09:31:12.149]             }
[09:31:12.149]         }
[09:31:12.149]     })
[09:31:12.149]     if (TRUE) {
[09:31:12.149]         base::sink(type = "output", split = FALSE)
[09:31:12.149]         if (TRUE) {
[09:31:12.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.149]         }
[09:31:12.149]         else {
[09:31:12.149]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.149]         }
[09:31:12.149]         base::close(...future.stdout)
[09:31:12.149]         ...future.stdout <- NULL
[09:31:12.149]     }
[09:31:12.149]     ...future.result$conditions <- ...future.conditions
[09:31:12.149]     ...future.result$finished <- base::Sys.time()
[09:31:12.149]     ...future.result
[09:31:12.149] }
[09:31:12.151] requestCore(): workers = 2
[09:31:12.154] MulticoreFuture started
[09:31:12.154] - Launch lazy future ... done
[09:31:12.155] plan(): Setting new future strategy stack:
[09:31:12.155] run() for ‘MulticoreFuture’ ... done
[09:31:12.155] getGlobalsAndPackages() ...
[09:31:12.155] Searching for globals...
[09:31:12.155] List of future strategies:
[09:31:12.155] 1. sequential:
[09:31:12.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.155]    - tweaked: FALSE
[09:31:12.155]    - call: NULL
[09:31:12.156] plan(): nbrOfWorkers() = 1
[09:31:12.156] 
[09:31:12.157] Searching for globals ... DONE
[09:31:12.157] - globals: [0] <none>
[09:31:12.157] getGlobalsAndPackages() ... DONE
[09:31:12.158] run() for ‘Future’ ...
[09:31:12.158] - state: ‘created’
[09:31:12.158] plan(): Setting new future strategy stack:
[09:31:12.158] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.158] List of future strategies:
[09:31:12.158] 1. multicore:
[09:31:12.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.158]    - tweaked: FALSE
[09:31:12.158]    - call: plan(strategy)
[09:31:12.163] plan(): nbrOfWorkers() = 2
[09:31:12.164] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.164]   - Field: ‘label’
[09:31:12.164]   - Field: ‘local’
[09:31:12.164]   - Field: ‘owner’
[09:31:12.164]   - Field: ‘envir’
[09:31:12.165]   - Field: ‘workers’
[09:31:12.165]   - Field: ‘packages’
[09:31:12.165]   - Field: ‘gc’
[09:31:12.165]   - Field: ‘job’
[09:31:12.165]   - Field: ‘conditions’
[09:31:12.165]   - Field: ‘expr’
[09:31:12.165]   - Field: ‘uuid’
[09:31:12.166]   - Field: ‘seed’
[09:31:12.166]   - Field: ‘version’
[09:31:12.166]   - Field: ‘result’
[09:31:12.166]   - Field: ‘asynchronous’
[09:31:12.166]   - Field: ‘calls’
[09:31:12.166]   - Field: ‘globals’
[09:31:12.166]   - Field: ‘stdout’
[09:31:12.167]   - Field: ‘earlySignal’
[09:31:12.167]   - Field: ‘lazy’
[09:31:12.167]   - Field: ‘state’
[09:31:12.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.167] - Launch lazy future ...
[09:31:12.168] Packages needed by the future expression (n = 0): <none>
[09:31:12.168] Packages needed by future strategies (n = 0): <none>
[09:31:12.169] {
[09:31:12.169]     {
[09:31:12.169]         {
[09:31:12.169]             ...future.startTime <- base::Sys.time()
[09:31:12.169]             {
[09:31:12.169]                 {
[09:31:12.169]                   {
[09:31:12.169]                     {
[09:31:12.169]                       base::local({
[09:31:12.169]                         has_future <- base::requireNamespace("future", 
[09:31:12.169]                           quietly = TRUE)
[09:31:12.169]                         if (has_future) {
[09:31:12.169]                           ns <- base::getNamespace("future")
[09:31:12.169]                           version <- ns[[".package"]][["version"]]
[09:31:12.169]                           if (is.null(version)) 
[09:31:12.169]                             version <- utils::packageVersion("future")
[09:31:12.169]                         }
[09:31:12.169]                         else {
[09:31:12.169]                           version <- NULL
[09:31:12.169]                         }
[09:31:12.169]                         if (!has_future || version < "1.8.0") {
[09:31:12.169]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.169]                             "", base::R.version$version.string), 
[09:31:12.169]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.169]                               "release", "version")], collapse = " "), 
[09:31:12.169]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.169]                             info)
[09:31:12.169]                           info <- base::paste(info, collapse = "; ")
[09:31:12.169]                           if (!has_future) {
[09:31:12.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.169]                               info)
[09:31:12.169]                           }
[09:31:12.169]                           else {
[09:31:12.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.169]                               info, version)
[09:31:12.169]                           }
[09:31:12.169]                           base::stop(msg)
[09:31:12.169]                         }
[09:31:12.169]                       })
[09:31:12.169]                     }
[09:31:12.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.169]                     base::options(mc.cores = 1L)
[09:31:12.169]                   }
[09:31:12.169]                   ...future.strategy.old <- future::plan("list")
[09:31:12.169]                   options(future.plan = NULL)
[09:31:12.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.169]                 }
[09:31:12.169]                 ...future.workdir <- getwd()
[09:31:12.169]             }
[09:31:12.169]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.169]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.169]         }
[09:31:12.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.169]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.169]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.169]             base::names(...future.oldOptions))
[09:31:12.169]     }
[09:31:12.169]     if (FALSE) {
[09:31:12.169]     }
[09:31:12.169]     else {
[09:31:12.169]         if (TRUE) {
[09:31:12.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.169]                 open = "w")
[09:31:12.169]         }
[09:31:12.169]         else {
[09:31:12.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.169]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.169]         }
[09:31:12.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.169]             base::sink(type = "output", split = FALSE)
[09:31:12.169]             base::close(...future.stdout)
[09:31:12.169]         }, add = TRUE)
[09:31:12.169]     }
[09:31:12.169]     ...future.frame <- base::sys.nframe()
[09:31:12.169]     ...future.conditions <- base::list()
[09:31:12.169]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.169]     if (FALSE) {
[09:31:12.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.169]     }
[09:31:12.169]     ...future.result <- base::tryCatch({
[09:31:12.169]         base::withCallingHandlers({
[09:31:12.169]             ...future.value <- base::withVisible(base::local({
[09:31:12.169]                 withCallingHandlers({
[09:31:12.169]                   NULL
[09:31:12.169]                 }, immediateCondition = function(cond) {
[09:31:12.169]                   save_rds <- function (object, pathname, ...) 
[09:31:12.169]                   {
[09:31:12.169]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.169]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.169]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.169]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.169]                         fi_tmp[["mtime"]])
[09:31:12.169]                     }
[09:31:12.169]                     tryCatch({
[09:31:12.169]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.169]                     }, error = function(ex) {
[09:31:12.169]                       msg <- conditionMessage(ex)
[09:31:12.169]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.169]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.169]                         fi_tmp[["mtime"]], msg)
[09:31:12.169]                       ex$message <- msg
[09:31:12.169]                       stop(ex)
[09:31:12.169]                     })
[09:31:12.169]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.169]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.169]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.169]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.169]                       fi <- file.info(pathname)
[09:31:12.169]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.169]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.169]                         fi[["size"]], fi[["mtime"]])
[09:31:12.169]                       stop(msg)
[09:31:12.169]                     }
[09:31:12.169]                     invisible(pathname)
[09:31:12.169]                   }
[09:31:12.169]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.169]                     rootPath = tempdir()) 
[09:31:12.169]                   {
[09:31:12.169]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.169]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.169]                       tmpdir = path, fileext = ".rds")
[09:31:12.169]                     save_rds(obj, file)
[09:31:12.169]                   }
[09:31:12.169]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.169]                   {
[09:31:12.169]                     inherits <- base::inherits
[09:31:12.169]                     invokeRestart <- base::invokeRestart
[09:31:12.169]                     is.null <- base::is.null
[09:31:12.169]                     muffled <- FALSE
[09:31:12.169]                     if (inherits(cond, "message")) {
[09:31:12.169]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.169]                       if (muffled) 
[09:31:12.169]                         invokeRestart("muffleMessage")
[09:31:12.169]                     }
[09:31:12.169]                     else if (inherits(cond, "warning")) {
[09:31:12.169]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.169]                       if (muffled) 
[09:31:12.169]                         invokeRestart("muffleWarning")
[09:31:12.169]                     }
[09:31:12.169]                     else if (inherits(cond, "condition")) {
[09:31:12.169]                       if (!is.null(pattern)) {
[09:31:12.169]                         computeRestarts <- base::computeRestarts
[09:31:12.169]                         grepl <- base::grepl
[09:31:12.169]                         restarts <- computeRestarts(cond)
[09:31:12.169]                         for (restart in restarts) {
[09:31:12.169]                           name <- restart$name
[09:31:12.169]                           if (is.null(name)) 
[09:31:12.169]                             next
[09:31:12.169]                           if (!grepl(pattern, name)) 
[09:31:12.169]                             next
[09:31:12.169]                           invokeRestart(restart)
[09:31:12.169]                           muffled <- TRUE
[09:31:12.169]                           break
[09:31:12.169]                         }
[09:31:12.169]                       }
[09:31:12.169]                     }
[09:31:12.169]                     invisible(muffled)
[09:31:12.169]                   }
[09:31:12.169]                   muffleCondition(cond)
[09:31:12.169]                 })
[09:31:12.169]             }))
[09:31:12.169]             future::FutureResult(value = ...future.value$value, 
[09:31:12.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.169]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.169]                     ...future.globalenv.names))
[09:31:12.169]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.169]         }, condition = base::local({
[09:31:12.169]             c <- base::c
[09:31:12.169]             inherits <- base::inherits
[09:31:12.169]             invokeRestart <- base::invokeRestart
[09:31:12.169]             length <- base::length
[09:31:12.169]             list <- base::list
[09:31:12.169]             seq.int <- base::seq.int
[09:31:12.169]             signalCondition <- base::signalCondition
[09:31:12.169]             sys.calls <- base::sys.calls
[09:31:12.169]             `[[` <- base::`[[`
[09:31:12.169]             `+` <- base::`+`
[09:31:12.169]             `<<-` <- base::`<<-`
[09:31:12.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.169]                   3L)]
[09:31:12.169]             }
[09:31:12.169]             function(cond) {
[09:31:12.169]                 is_error <- inherits(cond, "error")
[09:31:12.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.169]                   NULL)
[09:31:12.169]                 if (is_error) {
[09:31:12.169]                   sessionInformation <- function() {
[09:31:12.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.169]                       search = base::search(), system = base::Sys.info())
[09:31:12.169]                   }
[09:31:12.169]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.169]                     cond$call), session = sessionInformation(), 
[09:31:12.169]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.169]                   signalCondition(cond)
[09:31:12.169]                 }
[09:31:12.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.169]                 "immediateCondition"))) {
[09:31:12.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.169]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.169]                   if (TRUE && !signal) {
[09:31:12.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.169]                     {
[09:31:12.169]                       inherits <- base::inherits
[09:31:12.169]                       invokeRestart <- base::invokeRestart
[09:31:12.169]                       is.null <- base::is.null
[09:31:12.169]                       muffled <- FALSE
[09:31:12.169]                       if (inherits(cond, "message")) {
[09:31:12.169]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.169]                         if (muffled) 
[09:31:12.169]                           invokeRestart("muffleMessage")
[09:31:12.169]                       }
[09:31:12.169]                       else if (inherits(cond, "warning")) {
[09:31:12.169]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.169]                         if (muffled) 
[09:31:12.169]                           invokeRestart("muffleWarning")
[09:31:12.169]                       }
[09:31:12.169]                       else if (inherits(cond, "condition")) {
[09:31:12.169]                         if (!is.null(pattern)) {
[09:31:12.169]                           computeRestarts <- base::computeRestarts
[09:31:12.169]                           grepl <- base::grepl
[09:31:12.169]                           restarts <- computeRestarts(cond)
[09:31:12.169]                           for (restart in restarts) {
[09:31:12.169]                             name <- restart$name
[09:31:12.169]                             if (is.null(name)) 
[09:31:12.169]                               next
[09:31:12.169]                             if (!grepl(pattern, name)) 
[09:31:12.169]                               next
[09:31:12.169]                             invokeRestart(restart)
[09:31:12.169]                             muffled <- TRUE
[09:31:12.169]                             break
[09:31:12.169]                           }
[09:31:12.169]                         }
[09:31:12.169]                       }
[09:31:12.169]                       invisible(muffled)
[09:31:12.169]                     }
[09:31:12.169]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.169]                   }
[09:31:12.169]                 }
[09:31:12.169]                 else {
[09:31:12.169]                   if (TRUE) {
[09:31:12.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.169]                     {
[09:31:12.169]                       inherits <- base::inherits
[09:31:12.169]                       invokeRestart <- base::invokeRestart
[09:31:12.169]                       is.null <- base::is.null
[09:31:12.169]                       muffled <- FALSE
[09:31:12.169]                       if (inherits(cond, "message")) {
[09:31:12.169]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.169]                         if (muffled) 
[09:31:12.169]                           invokeRestart("muffleMessage")
[09:31:12.169]                       }
[09:31:12.169]                       else if (inherits(cond, "warning")) {
[09:31:12.169]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.169]                         if (muffled) 
[09:31:12.169]                           invokeRestart("muffleWarning")
[09:31:12.169]                       }
[09:31:12.169]                       else if (inherits(cond, "condition")) {
[09:31:12.169]                         if (!is.null(pattern)) {
[09:31:12.169]                           computeRestarts <- base::computeRestarts
[09:31:12.169]                           grepl <- base::grepl
[09:31:12.169]                           restarts <- computeRestarts(cond)
[09:31:12.169]                           for (restart in restarts) {
[09:31:12.169]                             name <- restart$name
[09:31:12.169]                             if (is.null(name)) 
[09:31:12.169]                               next
[09:31:12.169]                             if (!grepl(pattern, name)) 
[09:31:12.169]                               next
[09:31:12.169]                             invokeRestart(restart)
[09:31:12.169]                             muffled <- TRUE
[09:31:12.169]                             break
[09:31:12.169]                           }
[09:31:12.169]                         }
[09:31:12.169]                       }
[09:31:12.169]                       invisible(muffled)
[09:31:12.169]                     }
[09:31:12.169]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.169]                   }
[09:31:12.169]                 }
[09:31:12.169]             }
[09:31:12.169]         }))
[09:31:12.169]     }, error = function(ex) {
[09:31:12.169]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.169]                 ...future.rng), started = ...future.startTime, 
[09:31:12.169]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.169]             version = "1.8"), class = "FutureResult")
[09:31:12.169]     }, finally = {
[09:31:12.169]         if (!identical(...future.workdir, getwd())) 
[09:31:12.169]             setwd(...future.workdir)
[09:31:12.169]         {
[09:31:12.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.169]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.169]             }
[09:31:12.169]             base::options(...future.oldOptions)
[09:31:12.169]             if (.Platform$OS.type == "windows") {
[09:31:12.169]                 old_names <- names(...future.oldEnvVars)
[09:31:12.169]                 envs <- base::Sys.getenv()
[09:31:12.169]                 names <- names(envs)
[09:31:12.169]                 common <- intersect(names, old_names)
[09:31:12.169]                 added <- setdiff(names, old_names)
[09:31:12.169]                 removed <- setdiff(old_names, names)
[09:31:12.169]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.169]                   envs[common]]
[09:31:12.169]                 NAMES <- toupper(changed)
[09:31:12.169]                 args <- list()
[09:31:12.169]                 for (kk in seq_along(NAMES)) {
[09:31:12.169]                   name <- changed[[kk]]
[09:31:12.169]                   NAME <- NAMES[[kk]]
[09:31:12.169]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.169]                     next
[09:31:12.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.169]                 }
[09:31:12.169]                 NAMES <- toupper(added)
[09:31:12.169]                 for (kk in seq_along(NAMES)) {
[09:31:12.169]                   name <- added[[kk]]
[09:31:12.169]                   NAME <- NAMES[[kk]]
[09:31:12.169]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.169]                     next
[09:31:12.169]                   args[[name]] <- ""
[09:31:12.169]                 }
[09:31:12.169]                 NAMES <- toupper(removed)
[09:31:12.169]                 for (kk in seq_along(NAMES)) {
[09:31:12.169]                   name <- removed[[kk]]
[09:31:12.169]                   NAME <- NAMES[[kk]]
[09:31:12.169]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.169]                     next
[09:31:12.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.169]                 }
[09:31:12.169]                 if (length(args) > 0) 
[09:31:12.169]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.169]             }
[09:31:12.169]             else {
[09:31:12.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.169]             }
[09:31:12.169]             {
[09:31:12.169]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.169]                   0L) {
[09:31:12.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.169]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.169]                   base::options(opts)
[09:31:12.169]                 }
[09:31:12.169]                 {
[09:31:12.169]                   {
[09:31:12.169]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.169]                     NULL
[09:31:12.169]                   }
[09:31:12.169]                   options(future.plan = NULL)
[09:31:12.169]                   if (is.na(NA_character_)) 
[09:31:12.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.169]                     .init = FALSE)
[09:31:12.169]                 }
[09:31:12.169]             }
[09:31:12.169]         }
[09:31:12.169]     })
[09:31:12.169]     if (TRUE) {
[09:31:12.169]         base::sink(type = "output", split = FALSE)
[09:31:12.169]         if (TRUE) {
[09:31:12.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.169]         }
[09:31:12.169]         else {
[09:31:12.169]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.169]         }
[09:31:12.169]         base::close(...future.stdout)
[09:31:12.169]         ...future.stdout <- NULL
[09:31:12.169]     }
[09:31:12.169]     ...future.result$conditions <- ...future.conditions
[09:31:12.169]     ...future.result$finished <- base::Sys.time()
[09:31:12.169]     ...future.result
[09:31:12.169] }
[09:31:12.172] requestCore(): workers = 2
[09:31:12.183] MulticoreFuture started
[09:31:12.183] - Launch lazy future ... done
[09:31:12.184] run() for ‘MulticoreFuture’ ... done
[09:31:12.184] plan(): Setting new future strategy stack:
List of 6
 $ a:[09:31:12.184] List of future strategies:
[09:31:12.184] 1. sequential:
[09:31:12.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.184]    - tweaked: FALSE
[09:31:12.184]    - call: NULL
[09:31:12.186] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca7a1670> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3caddb2b0> 
 $  : NULL
 $  :[09:31:12.188] plan(): Setting new future strategy stack:
 NULL
 $  :[09:31:12.189] List of future strategies:
[09:31:12.189] 1. multicore:
[09:31:12.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.189]    - tweaked: FALSE
[09:31:12.189]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca7a1670> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3caddb2b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[09:31:12.194] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:12.195] resolve() on list ...
[09:31:12.196]  recursive: 0
[09:31:12.196]  length: 6
[09:31:12.196]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:12.196] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.196] - nx: 6
[09:31:12.196] - relay: TRUE
[09:31:12.197] - stdout: TRUE
[09:31:12.197] - signal: TRUE
[09:31:12.197] - resignal: FALSE
[09:31:12.197] - force: TRUE
[09:31:12.197] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.197] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.197]  - until=2
[09:31:12.198]  - relaying element #2
[09:31:12.198] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.198] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.198] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.198]  length: 5 (resolved future 1)
[09:31:12.198] Future #2
[09:31:12.199] result() for MulticoreFuture ...
[09:31:12.201] result() for MulticoreFuture ...
[09:31:12.201] result() for MulticoreFuture ... done
[09:31:12.201] result() for MulticoreFuture ... done
[09:31:12.201] result() for MulticoreFuture ...
[09:31:12.201] result() for MulticoreFuture ... done
[09:31:12.202] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:12.202] - nx: 6
[09:31:12.202] - relay: TRUE
[09:31:12.202] - stdout: TRUE
[09:31:12.202] - signal: TRUE
[09:31:12.202] - resignal: FALSE
[09:31:12.203] - force: TRUE
[09:31:12.203] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.203] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.203]  - until=2
[09:31:12.203]  - relaying element #2
[09:31:12.203] result() for MulticoreFuture ...
[09:31:12.204] result() for MulticoreFuture ... done
[09:31:12.204] result() for MulticoreFuture ...
[09:31:12.204] result() for MulticoreFuture ... done
[09:31:12.204] result() for MulticoreFuture ...
[09:31:12.205] result() for MulticoreFuture ... done
[09:31:12.205] result() for MulticoreFuture ...
[09:31:12.205] result() for MulticoreFuture ... done
[09:31:12.205] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.205] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.205] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:12.205]  length: 4 (resolved future 2)
[09:31:12.206] Future #3
[09:31:12.206] result() for MulticoreFuture ...
[09:31:12.206] result() for MulticoreFuture ...
[09:31:12.207] result() for MulticoreFuture ... done
[09:31:12.207] result() for MulticoreFuture ... done
[09:31:12.207] result() for MulticoreFuture ...
[09:31:12.207] result() for MulticoreFuture ... done
[09:31:12.207] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:12.207] - nx: 6
[09:31:12.207] - relay: TRUE
[09:31:12.207] - stdout: TRUE
[09:31:12.208] - signal: TRUE
[09:31:12.208] - resignal: FALSE
[09:31:12.208] - force: TRUE
[09:31:12.208] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.208] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.208]  - until=3
[09:31:12.208]  - relaying element #3
[09:31:12.208] result() for MulticoreFuture ...
[09:31:12.208] result() for MulticoreFuture ... done
[09:31:12.209] result() for MulticoreFuture ...
[09:31:12.209] result() for MulticoreFuture ... done
[09:31:12.209] result() for MulticoreFuture ...
[09:31:12.209] result() for MulticoreFuture ... done
[09:31:12.209] result() for MulticoreFuture ...
[09:31:12.209] result() for MulticoreFuture ... done
[09:31:12.209] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.209] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:12.210]  length: 3 (resolved future 3)
[09:31:12.210] signalConditionsASAP(NULL, pos=4) ...
[09:31:12.210] - nx: 6
[09:31:12.210] - relay: TRUE
[09:31:12.210] - stdout: TRUE
[09:31:12.210] - signal: TRUE
[09:31:12.210] - resignal: FALSE
[09:31:12.210] - force: TRUE
[09:31:12.210] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.210] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.210]  - until=5
[09:31:12.211]  - relaying element #5
[09:31:12.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.211] signalConditionsASAP(NULL, pos=4) ... done
[09:31:12.211]  length: 2 (resolved future 4)
[09:31:12.211] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.211] - nx: 6
[09:31:12.211] - relay: TRUE
[09:31:12.211] - stdout: TRUE
[09:31:12.211] - signal: TRUE
[09:31:12.212] - resignal: FALSE
[09:31:12.212] - force: TRUE
[09:31:12.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.212]  - until=6
[09:31:12.212]  - relaying element #6
[09:31:12.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.212] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.212]  length: 1 (resolved future 5)
[09:31:12.213] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.213] - nx: 6
[09:31:12.213] - relay: TRUE
[09:31:12.213] - stdout: TRUE
[09:31:12.213] - signal: TRUE
[09:31:12.213] - resignal: FALSE
[09:31:12.213] - force: TRUE
[09:31:12.213] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.213] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.213]  - until=6
[09:31:12.214] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.214] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.214] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.214]  length: 0 (resolved future 6)
[09:31:12.214] Relaying remaining futures
[09:31:12.214] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.214] - nx: 6
[09:31:12.214] - relay: TRUE
[09:31:12.214] - stdout: TRUE
[09:31:12.214] - signal: TRUE
[09:31:12.214] - resignal: FALSE
[09:31:12.215] - force: TRUE
[09:31:12.215] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.215] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:12.215] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.215] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.215] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.215] resolve() on list ... DONE
[09:31:12.215] result() for MulticoreFuture ...
[09:31:12.215] result() for MulticoreFuture ... done
[09:31:12.216] result() for MulticoreFuture ...
[09:31:12.216] result() for MulticoreFuture ... done
[09:31:12.216] result() for MulticoreFuture ...
[09:31:12.216] result() for MulticoreFuture ... done
[09:31:12.216] result() for MulticoreFuture ...
[09:31:12.216] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[09:31:12.218] getGlobalsAndPackages() ...
[09:31:12.218] Searching for globals...
[09:31:12.219] 
[09:31:12.219] Searching for globals ... DONE
[09:31:12.219] - globals: [0] <none>
[09:31:12.219] getGlobalsAndPackages() ... DONE
[09:31:12.219] run() for ‘Future’ ...
[09:31:12.220] - state: ‘created’
[09:31:12.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.225] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.225] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.226]   - Field: ‘label’
[09:31:12.226]   - Field: ‘local’
[09:31:12.226]   - Field: ‘owner’
[09:31:12.226]   - Field: ‘envir’
[09:31:12.226]   - Field: ‘workers’
[09:31:12.226]   - Field: ‘packages’
[09:31:12.226]   - Field: ‘gc’
[09:31:12.226]   - Field: ‘job’
[09:31:12.226]   - Field: ‘conditions’
[09:31:12.227]   - Field: ‘expr’
[09:31:12.227]   - Field: ‘uuid’
[09:31:12.227]   - Field: ‘seed’
[09:31:12.227]   - Field: ‘version’
[09:31:12.227]   - Field: ‘result’
[09:31:12.227]   - Field: ‘asynchronous’
[09:31:12.227]   - Field: ‘calls’
[09:31:12.227]   - Field: ‘globals’
[09:31:12.227]   - Field: ‘stdout’
[09:31:12.227]   - Field: ‘earlySignal’
[09:31:12.227]   - Field: ‘lazy’
[09:31:12.228]   - Field: ‘state’
[09:31:12.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.228] - Launch lazy future ...
[09:31:12.228] Packages needed by the future expression (n = 0): <none>
[09:31:12.228] Packages needed by future strategies (n = 0): <none>
[09:31:12.229] {
[09:31:12.229]     {
[09:31:12.229]         {
[09:31:12.229]             ...future.startTime <- base::Sys.time()
[09:31:12.229]             {
[09:31:12.229]                 {
[09:31:12.229]                   {
[09:31:12.229]                     {
[09:31:12.229]                       base::local({
[09:31:12.229]                         has_future <- base::requireNamespace("future", 
[09:31:12.229]                           quietly = TRUE)
[09:31:12.229]                         if (has_future) {
[09:31:12.229]                           ns <- base::getNamespace("future")
[09:31:12.229]                           version <- ns[[".package"]][["version"]]
[09:31:12.229]                           if (is.null(version)) 
[09:31:12.229]                             version <- utils::packageVersion("future")
[09:31:12.229]                         }
[09:31:12.229]                         else {
[09:31:12.229]                           version <- NULL
[09:31:12.229]                         }
[09:31:12.229]                         if (!has_future || version < "1.8.0") {
[09:31:12.229]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.229]                             "", base::R.version$version.string), 
[09:31:12.229]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.229]                               "release", "version")], collapse = " "), 
[09:31:12.229]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.229]                             info)
[09:31:12.229]                           info <- base::paste(info, collapse = "; ")
[09:31:12.229]                           if (!has_future) {
[09:31:12.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.229]                               info)
[09:31:12.229]                           }
[09:31:12.229]                           else {
[09:31:12.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.229]                               info, version)
[09:31:12.229]                           }
[09:31:12.229]                           base::stop(msg)
[09:31:12.229]                         }
[09:31:12.229]                       })
[09:31:12.229]                     }
[09:31:12.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.229]                     base::options(mc.cores = 1L)
[09:31:12.229]                   }
[09:31:12.229]                   ...future.strategy.old <- future::plan("list")
[09:31:12.229]                   options(future.plan = NULL)
[09:31:12.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.229]                 }
[09:31:12.229]                 ...future.workdir <- getwd()
[09:31:12.229]             }
[09:31:12.229]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.229]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.229]         }
[09:31:12.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.229]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.229]             base::names(...future.oldOptions))
[09:31:12.229]     }
[09:31:12.229]     if (FALSE) {
[09:31:12.229]     }
[09:31:12.229]     else {
[09:31:12.229]         if (TRUE) {
[09:31:12.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.229]                 open = "w")
[09:31:12.229]         }
[09:31:12.229]         else {
[09:31:12.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.229]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.229]         }
[09:31:12.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.229]             base::sink(type = "output", split = FALSE)
[09:31:12.229]             base::close(...future.stdout)
[09:31:12.229]         }, add = TRUE)
[09:31:12.229]     }
[09:31:12.229]     ...future.frame <- base::sys.nframe()
[09:31:12.229]     ...future.conditions <- base::list()
[09:31:12.229]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.229]     if (FALSE) {
[09:31:12.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.229]     }
[09:31:12.229]     ...future.result <- base::tryCatch({
[09:31:12.229]         base::withCallingHandlers({
[09:31:12.229]             ...future.value <- base::withVisible(base::local({
[09:31:12.229]                 withCallingHandlers({
[09:31:12.229]                   2
[09:31:12.229]                 }, immediateCondition = function(cond) {
[09:31:12.229]                   save_rds <- function (object, pathname, ...) 
[09:31:12.229]                   {
[09:31:12.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.229]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.229]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.229]                         fi_tmp[["mtime"]])
[09:31:12.229]                     }
[09:31:12.229]                     tryCatch({
[09:31:12.229]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.229]                     }, error = function(ex) {
[09:31:12.229]                       msg <- conditionMessage(ex)
[09:31:12.229]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.229]                         fi_tmp[["mtime"]], msg)
[09:31:12.229]                       ex$message <- msg
[09:31:12.229]                       stop(ex)
[09:31:12.229]                     })
[09:31:12.229]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.229]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.229]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.229]                       fi <- file.info(pathname)
[09:31:12.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.229]                         fi[["size"]], fi[["mtime"]])
[09:31:12.229]                       stop(msg)
[09:31:12.229]                     }
[09:31:12.229]                     invisible(pathname)
[09:31:12.229]                   }
[09:31:12.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.229]                     rootPath = tempdir()) 
[09:31:12.229]                   {
[09:31:12.229]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.229]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.229]                       tmpdir = path, fileext = ".rds")
[09:31:12.229]                     save_rds(obj, file)
[09:31:12.229]                   }
[09:31:12.229]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.229]                   {
[09:31:12.229]                     inherits <- base::inherits
[09:31:12.229]                     invokeRestart <- base::invokeRestart
[09:31:12.229]                     is.null <- base::is.null
[09:31:12.229]                     muffled <- FALSE
[09:31:12.229]                     if (inherits(cond, "message")) {
[09:31:12.229]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.229]                       if (muffled) 
[09:31:12.229]                         invokeRestart("muffleMessage")
[09:31:12.229]                     }
[09:31:12.229]                     else if (inherits(cond, "warning")) {
[09:31:12.229]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.229]                       if (muffled) 
[09:31:12.229]                         invokeRestart("muffleWarning")
[09:31:12.229]                     }
[09:31:12.229]                     else if (inherits(cond, "condition")) {
[09:31:12.229]                       if (!is.null(pattern)) {
[09:31:12.229]                         computeRestarts <- base::computeRestarts
[09:31:12.229]                         grepl <- base::grepl
[09:31:12.229]                         restarts <- computeRestarts(cond)
[09:31:12.229]                         for (restart in restarts) {
[09:31:12.229]                           name <- restart$name
[09:31:12.229]                           if (is.null(name)) 
[09:31:12.229]                             next
[09:31:12.229]                           if (!grepl(pattern, name)) 
[09:31:12.229]                             next
[09:31:12.229]                           invokeRestart(restart)
[09:31:12.229]                           muffled <- TRUE
[09:31:12.229]                           break
[09:31:12.229]                         }
[09:31:12.229]                       }
[09:31:12.229]                     }
[09:31:12.229]                     invisible(muffled)
[09:31:12.229]                   }
[09:31:12.229]                   muffleCondition(cond)
[09:31:12.229]                 })
[09:31:12.229]             }))
[09:31:12.229]             future::FutureResult(value = ...future.value$value, 
[09:31:12.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.229]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.229]                     ...future.globalenv.names))
[09:31:12.229]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.229]         }, condition = base::local({
[09:31:12.229]             c <- base::c
[09:31:12.229]             inherits <- base::inherits
[09:31:12.229]             invokeRestart <- base::invokeRestart
[09:31:12.229]             length <- base::length
[09:31:12.229]             list <- base::list
[09:31:12.229]             seq.int <- base::seq.int
[09:31:12.229]             signalCondition <- base::signalCondition
[09:31:12.229]             sys.calls <- base::sys.calls
[09:31:12.229]             `[[` <- base::`[[`
[09:31:12.229]             `+` <- base::`+`
[09:31:12.229]             `<<-` <- base::`<<-`
[09:31:12.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.229]                   3L)]
[09:31:12.229]             }
[09:31:12.229]             function(cond) {
[09:31:12.229]                 is_error <- inherits(cond, "error")
[09:31:12.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.229]                   NULL)
[09:31:12.229]                 if (is_error) {
[09:31:12.229]                   sessionInformation <- function() {
[09:31:12.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.229]                       search = base::search(), system = base::Sys.info())
[09:31:12.229]                   }
[09:31:12.229]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.229]                     cond$call), session = sessionInformation(), 
[09:31:12.229]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.229]                   signalCondition(cond)
[09:31:12.229]                 }
[09:31:12.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.229]                 "immediateCondition"))) {
[09:31:12.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.229]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.229]                   if (TRUE && !signal) {
[09:31:12.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.229]                     {
[09:31:12.229]                       inherits <- base::inherits
[09:31:12.229]                       invokeRestart <- base::invokeRestart
[09:31:12.229]                       is.null <- base::is.null
[09:31:12.229]                       muffled <- FALSE
[09:31:12.229]                       if (inherits(cond, "message")) {
[09:31:12.229]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.229]                         if (muffled) 
[09:31:12.229]                           invokeRestart("muffleMessage")
[09:31:12.229]                       }
[09:31:12.229]                       else if (inherits(cond, "warning")) {
[09:31:12.229]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.229]                         if (muffled) 
[09:31:12.229]                           invokeRestart("muffleWarning")
[09:31:12.229]                       }
[09:31:12.229]                       else if (inherits(cond, "condition")) {
[09:31:12.229]                         if (!is.null(pattern)) {
[09:31:12.229]                           computeRestarts <- base::computeRestarts
[09:31:12.229]                           grepl <- base::grepl
[09:31:12.229]                           restarts <- computeRestarts(cond)
[09:31:12.229]                           for (restart in restarts) {
[09:31:12.229]                             name <- restart$name
[09:31:12.229]                             if (is.null(name)) 
[09:31:12.229]                               next
[09:31:12.229]                             if (!grepl(pattern, name)) 
[09:31:12.229]                               next
[09:31:12.229]                             invokeRestart(restart)
[09:31:12.229]                             muffled <- TRUE
[09:31:12.229]                             break
[09:31:12.229]                           }
[09:31:12.229]                         }
[09:31:12.229]                       }
[09:31:12.229]                       invisible(muffled)
[09:31:12.229]                     }
[09:31:12.229]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.229]                   }
[09:31:12.229]                 }
[09:31:12.229]                 else {
[09:31:12.229]                   if (TRUE) {
[09:31:12.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.229]                     {
[09:31:12.229]                       inherits <- base::inherits
[09:31:12.229]                       invokeRestart <- base::invokeRestart
[09:31:12.229]                       is.null <- base::is.null
[09:31:12.229]                       muffled <- FALSE
[09:31:12.229]                       if (inherits(cond, "message")) {
[09:31:12.229]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.229]                         if (muffled) 
[09:31:12.229]                           invokeRestart("muffleMessage")
[09:31:12.229]                       }
[09:31:12.229]                       else if (inherits(cond, "warning")) {
[09:31:12.229]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.229]                         if (muffled) 
[09:31:12.229]                           invokeRestart("muffleWarning")
[09:31:12.229]                       }
[09:31:12.229]                       else if (inherits(cond, "condition")) {
[09:31:12.229]                         if (!is.null(pattern)) {
[09:31:12.229]                           computeRestarts <- base::computeRestarts
[09:31:12.229]                           grepl <- base::grepl
[09:31:12.229]                           restarts <- computeRestarts(cond)
[09:31:12.229]                           for (restart in restarts) {
[09:31:12.229]                             name <- restart$name
[09:31:12.229]                             if (is.null(name)) 
[09:31:12.229]                               next
[09:31:12.229]                             if (!grepl(pattern, name)) 
[09:31:12.229]                               next
[09:31:12.229]                             invokeRestart(restart)
[09:31:12.229]                             muffled <- TRUE
[09:31:12.229]                             break
[09:31:12.229]                           }
[09:31:12.229]                         }
[09:31:12.229]                       }
[09:31:12.229]                       invisible(muffled)
[09:31:12.229]                     }
[09:31:12.229]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.229]                   }
[09:31:12.229]                 }
[09:31:12.229]             }
[09:31:12.229]         }))
[09:31:12.229]     }, error = function(ex) {
[09:31:12.229]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.229]                 ...future.rng), started = ...future.startTime, 
[09:31:12.229]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.229]             version = "1.8"), class = "FutureResult")
[09:31:12.229]     }, finally = {
[09:31:12.229]         if (!identical(...future.workdir, getwd())) 
[09:31:12.229]             setwd(...future.workdir)
[09:31:12.229]         {
[09:31:12.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.229]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.229]             }
[09:31:12.229]             base::options(...future.oldOptions)
[09:31:12.229]             if (.Platform$OS.type == "windows") {
[09:31:12.229]                 old_names <- names(...future.oldEnvVars)
[09:31:12.229]                 envs <- base::Sys.getenv()
[09:31:12.229]                 names <- names(envs)
[09:31:12.229]                 common <- intersect(names, old_names)
[09:31:12.229]                 added <- setdiff(names, old_names)
[09:31:12.229]                 removed <- setdiff(old_names, names)
[09:31:12.229]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.229]                   envs[common]]
[09:31:12.229]                 NAMES <- toupper(changed)
[09:31:12.229]                 args <- list()
[09:31:12.229]                 for (kk in seq_along(NAMES)) {
[09:31:12.229]                   name <- changed[[kk]]
[09:31:12.229]                   NAME <- NAMES[[kk]]
[09:31:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.229]                     next
[09:31:12.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.229]                 }
[09:31:12.229]                 NAMES <- toupper(added)
[09:31:12.229]                 for (kk in seq_along(NAMES)) {
[09:31:12.229]                   name <- added[[kk]]
[09:31:12.229]                   NAME <- NAMES[[kk]]
[09:31:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.229]                     next
[09:31:12.229]                   args[[name]] <- ""
[09:31:12.229]                 }
[09:31:12.229]                 NAMES <- toupper(removed)
[09:31:12.229]                 for (kk in seq_along(NAMES)) {
[09:31:12.229]                   name <- removed[[kk]]
[09:31:12.229]                   NAME <- NAMES[[kk]]
[09:31:12.229]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.229]                     next
[09:31:12.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.229]                 }
[09:31:12.229]                 if (length(args) > 0) 
[09:31:12.229]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.229]             }
[09:31:12.229]             else {
[09:31:12.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.229]             }
[09:31:12.229]             {
[09:31:12.229]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.229]                   0L) {
[09:31:12.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.229]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.229]                   base::options(opts)
[09:31:12.229]                 }
[09:31:12.229]                 {
[09:31:12.229]                   {
[09:31:12.229]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.229]                     NULL
[09:31:12.229]                   }
[09:31:12.229]                   options(future.plan = NULL)
[09:31:12.229]                   if (is.na(NA_character_)) 
[09:31:12.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.229]                     .init = FALSE)
[09:31:12.229]                 }
[09:31:12.229]             }
[09:31:12.229]         }
[09:31:12.229]     })
[09:31:12.229]     if (TRUE) {
[09:31:12.229]         base::sink(type = "output", split = FALSE)
[09:31:12.229]         if (TRUE) {
[09:31:12.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.229]         }
[09:31:12.229]         else {
[09:31:12.229]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.229]         }
[09:31:12.229]         base::close(...future.stdout)
[09:31:12.229]         ...future.stdout <- NULL
[09:31:12.229]     }
[09:31:12.229]     ...future.result$conditions <- ...future.conditions
[09:31:12.229]     ...future.result$finished <- base::Sys.time()
[09:31:12.229]     ...future.result
[09:31:12.229] }
[09:31:12.231] requestCore(): workers = 2
[09:31:12.233] MulticoreFuture started
[09:31:12.233] - Launch lazy future ... done
[09:31:12.233] run() for ‘MulticoreFuture’ ... done
[09:31:12.234] getGlobalsAndPackages() ...
[09:31:12.234] plan(): Setting new future strategy stack:
[09:31:12.234] Searching for globals...
[09:31:12.234] List of future strategies:
[09:31:12.234] 1. sequential:
[09:31:12.234]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.234]    - tweaked: FALSE
[09:31:12.234]    - call: NULL
[09:31:12.235] 
[09:31:12.235] Searching for globals ... DONE
[09:31:12.235] plan(): nbrOfWorkers() = 1
[09:31:12.235] - globals: [0] <none>
[09:31:12.235] getGlobalsAndPackages() ... DONE
[09:31:12.236] run() for ‘Future’ ...
[09:31:12.236] - state: ‘created’
[09:31:12.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.237] plan(): Setting new future strategy stack:
[09:31:12.237] List of future strategies:
[09:31:12.237] 1. multicore:
[09:31:12.237]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.237]    - tweaked: FALSE
[09:31:12.237]    - call: plan(strategy)
[09:31:12.242] plan(): nbrOfWorkers() = 2
[09:31:12.242] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.243]   - Field: ‘label’
[09:31:12.243]   - Field: ‘local’
[09:31:12.243]   - Field: ‘owner’
[09:31:12.243]   - Field: ‘envir’
[09:31:12.243]   - Field: ‘workers’
[09:31:12.244]   - Field: ‘packages’
[09:31:12.244]   - Field: ‘gc’
[09:31:12.244]   - Field: ‘job’
[09:31:12.244]   - Field: ‘conditions’
[09:31:12.244]   - Field: ‘expr’
[09:31:12.244]   - Field: ‘uuid’
[09:31:12.244]   - Field: ‘seed’
[09:31:12.245]   - Field: ‘version’
[09:31:12.245]   - Field: ‘result’
[09:31:12.245]   - Field: ‘asynchronous’
[09:31:12.245]   - Field: ‘calls’
[09:31:12.245]   - Field: ‘globals’
[09:31:12.245]   - Field: ‘stdout’
[09:31:12.246]   - Field: ‘earlySignal’
[09:31:12.246]   - Field: ‘lazy’
[09:31:12.246]   - Field: ‘state’
[09:31:12.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.246] - Launch lazy future ...
[09:31:12.247] Packages needed by the future expression (n = 0): <none>
[09:31:12.247] Packages needed by future strategies (n = 0): <none>
[09:31:12.247] {
[09:31:12.247]     {
[09:31:12.247]         {
[09:31:12.247]             ...future.startTime <- base::Sys.time()
[09:31:12.247]             {
[09:31:12.247]                 {
[09:31:12.247]                   {
[09:31:12.247]                     {
[09:31:12.247]                       base::local({
[09:31:12.247]                         has_future <- base::requireNamespace("future", 
[09:31:12.247]                           quietly = TRUE)
[09:31:12.247]                         if (has_future) {
[09:31:12.247]                           ns <- base::getNamespace("future")
[09:31:12.247]                           version <- ns[[".package"]][["version"]]
[09:31:12.247]                           if (is.null(version)) 
[09:31:12.247]                             version <- utils::packageVersion("future")
[09:31:12.247]                         }
[09:31:12.247]                         else {
[09:31:12.247]                           version <- NULL
[09:31:12.247]                         }
[09:31:12.247]                         if (!has_future || version < "1.8.0") {
[09:31:12.247]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.247]                             "", base::R.version$version.string), 
[09:31:12.247]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.247]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.247]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.247]                               "release", "version")], collapse = " "), 
[09:31:12.247]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.247]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.247]                             info)
[09:31:12.247]                           info <- base::paste(info, collapse = "; ")
[09:31:12.247]                           if (!has_future) {
[09:31:12.247]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.247]                               info)
[09:31:12.247]                           }
[09:31:12.247]                           else {
[09:31:12.247]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.247]                               info, version)
[09:31:12.247]                           }
[09:31:12.247]                           base::stop(msg)
[09:31:12.247]                         }
[09:31:12.247]                       })
[09:31:12.247]                     }
[09:31:12.247]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.247]                     base::options(mc.cores = 1L)
[09:31:12.247]                   }
[09:31:12.247]                   ...future.strategy.old <- future::plan("list")
[09:31:12.247]                   options(future.plan = NULL)
[09:31:12.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.247]                 }
[09:31:12.247]                 ...future.workdir <- getwd()
[09:31:12.247]             }
[09:31:12.247]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.247]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.247]         }
[09:31:12.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.247]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.247]             base::names(...future.oldOptions))
[09:31:12.247]     }
[09:31:12.247]     if (FALSE) {
[09:31:12.247]     }
[09:31:12.247]     else {
[09:31:12.247]         if (TRUE) {
[09:31:12.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.247]                 open = "w")
[09:31:12.247]         }
[09:31:12.247]         else {
[09:31:12.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.247]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.247]         }
[09:31:12.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.247]             base::sink(type = "output", split = FALSE)
[09:31:12.247]             base::close(...future.stdout)
[09:31:12.247]         }, add = TRUE)
[09:31:12.247]     }
[09:31:12.247]     ...future.frame <- base::sys.nframe()
[09:31:12.247]     ...future.conditions <- base::list()
[09:31:12.247]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.247]     if (FALSE) {
[09:31:12.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.247]     }
[09:31:12.247]     ...future.result <- base::tryCatch({
[09:31:12.247]         base::withCallingHandlers({
[09:31:12.247]             ...future.value <- base::withVisible(base::local({
[09:31:12.247]                 withCallingHandlers({
[09:31:12.247]                   NULL
[09:31:12.247]                 }, immediateCondition = function(cond) {
[09:31:12.247]                   save_rds <- function (object, pathname, ...) 
[09:31:12.247]                   {
[09:31:12.247]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.247]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.247]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.247]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.247]                         fi_tmp[["mtime"]])
[09:31:12.247]                     }
[09:31:12.247]                     tryCatch({
[09:31:12.247]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.247]                     }, error = function(ex) {
[09:31:12.247]                       msg <- conditionMessage(ex)
[09:31:12.247]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.247]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.247]                         fi_tmp[["mtime"]], msg)
[09:31:12.247]                       ex$message <- msg
[09:31:12.247]                       stop(ex)
[09:31:12.247]                     })
[09:31:12.247]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.247]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.247]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.247]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.247]                       fi <- file.info(pathname)
[09:31:12.247]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.247]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.247]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.247]                         fi[["size"]], fi[["mtime"]])
[09:31:12.247]                       stop(msg)
[09:31:12.247]                     }
[09:31:12.247]                     invisible(pathname)
[09:31:12.247]                   }
[09:31:12.247]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.247]                     rootPath = tempdir()) 
[09:31:12.247]                   {
[09:31:12.247]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.247]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.247]                       tmpdir = path, fileext = ".rds")
[09:31:12.247]                     save_rds(obj, file)
[09:31:12.247]                   }
[09:31:12.247]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.247]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.247]                   {
[09:31:12.247]                     inherits <- base::inherits
[09:31:12.247]                     invokeRestart <- base::invokeRestart
[09:31:12.247]                     is.null <- base::is.null
[09:31:12.247]                     muffled <- FALSE
[09:31:12.247]                     if (inherits(cond, "message")) {
[09:31:12.247]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.247]                       if (muffled) 
[09:31:12.247]                         invokeRestart("muffleMessage")
[09:31:12.247]                     }
[09:31:12.247]                     else if (inherits(cond, "warning")) {
[09:31:12.247]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.247]                       if (muffled) 
[09:31:12.247]                         invokeRestart("muffleWarning")
[09:31:12.247]                     }
[09:31:12.247]                     else if (inherits(cond, "condition")) {
[09:31:12.247]                       if (!is.null(pattern)) {
[09:31:12.247]                         computeRestarts <- base::computeRestarts
[09:31:12.247]                         grepl <- base::grepl
[09:31:12.247]                         restarts <- computeRestarts(cond)
[09:31:12.247]                         for (restart in restarts) {
[09:31:12.247]                           name <- restart$name
[09:31:12.247]                           if (is.null(name)) 
[09:31:12.247]                             next
[09:31:12.247]                           if (!grepl(pattern, name)) 
[09:31:12.247]                             next
[09:31:12.247]                           invokeRestart(restart)
[09:31:12.247]                           muffled <- TRUE
[09:31:12.247]                           break
[09:31:12.247]                         }
[09:31:12.247]                       }
[09:31:12.247]                     }
[09:31:12.247]                     invisible(muffled)
[09:31:12.247]                   }
[09:31:12.247]                   muffleCondition(cond)
[09:31:12.247]                 })
[09:31:12.247]             }))
[09:31:12.247]             future::FutureResult(value = ...future.value$value, 
[09:31:12.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.247]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.247]                     ...future.globalenv.names))
[09:31:12.247]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.247]         }, condition = base::local({
[09:31:12.247]             c <- base::c
[09:31:12.247]             inherits <- base::inherits
[09:31:12.247]             invokeRestart <- base::invokeRestart
[09:31:12.247]             length <- base::length
[09:31:12.247]             list <- base::list
[09:31:12.247]             seq.int <- base::seq.int
[09:31:12.247]             signalCondition <- base::signalCondition
[09:31:12.247]             sys.calls <- base::sys.calls
[09:31:12.247]             `[[` <- base::`[[`
[09:31:12.247]             `+` <- base::`+`
[09:31:12.247]             `<<-` <- base::`<<-`
[09:31:12.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.247]                   3L)]
[09:31:12.247]             }
[09:31:12.247]             function(cond) {
[09:31:12.247]                 is_error <- inherits(cond, "error")
[09:31:12.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.247]                   NULL)
[09:31:12.247]                 if (is_error) {
[09:31:12.247]                   sessionInformation <- function() {
[09:31:12.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.247]                       search = base::search(), system = base::Sys.info())
[09:31:12.247]                   }
[09:31:12.247]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.247]                     cond$call), session = sessionInformation(), 
[09:31:12.247]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.247]                   signalCondition(cond)
[09:31:12.247]                 }
[09:31:12.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.247]                 "immediateCondition"))) {
[09:31:12.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.247]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.247]                   if (TRUE && !signal) {
[09:31:12.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.247]                     {
[09:31:12.247]                       inherits <- base::inherits
[09:31:12.247]                       invokeRestart <- base::invokeRestart
[09:31:12.247]                       is.null <- base::is.null
[09:31:12.247]                       muffled <- FALSE
[09:31:12.247]                       if (inherits(cond, "message")) {
[09:31:12.247]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.247]                         if (muffled) 
[09:31:12.247]                           invokeRestart("muffleMessage")
[09:31:12.247]                       }
[09:31:12.247]                       else if (inherits(cond, "warning")) {
[09:31:12.247]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.247]                         if (muffled) 
[09:31:12.247]                           invokeRestart("muffleWarning")
[09:31:12.247]                       }
[09:31:12.247]                       else if (inherits(cond, "condition")) {
[09:31:12.247]                         if (!is.null(pattern)) {
[09:31:12.247]                           computeRestarts <- base::computeRestarts
[09:31:12.247]                           grepl <- base::grepl
[09:31:12.247]                           restarts <- computeRestarts(cond)
[09:31:12.247]                           for (restart in restarts) {
[09:31:12.247]                             name <- restart$name
[09:31:12.247]                             if (is.null(name)) 
[09:31:12.247]                               next
[09:31:12.247]                             if (!grepl(pattern, name)) 
[09:31:12.247]                               next
[09:31:12.247]                             invokeRestart(restart)
[09:31:12.247]                             muffled <- TRUE
[09:31:12.247]                             break
[09:31:12.247]                           }
[09:31:12.247]                         }
[09:31:12.247]                       }
[09:31:12.247]                       invisible(muffled)
[09:31:12.247]                     }
[09:31:12.247]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.247]                   }
[09:31:12.247]                 }
[09:31:12.247]                 else {
[09:31:12.247]                   if (TRUE) {
[09:31:12.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.247]                     {
[09:31:12.247]                       inherits <- base::inherits
[09:31:12.247]                       invokeRestart <- base::invokeRestart
[09:31:12.247]                       is.null <- base::is.null
[09:31:12.247]                       muffled <- FALSE
[09:31:12.247]                       if (inherits(cond, "message")) {
[09:31:12.247]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.247]                         if (muffled) 
[09:31:12.247]                           invokeRestart("muffleMessage")
[09:31:12.247]                       }
[09:31:12.247]                       else if (inherits(cond, "warning")) {
[09:31:12.247]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.247]                         if (muffled) 
[09:31:12.247]                           invokeRestart("muffleWarning")
[09:31:12.247]                       }
[09:31:12.247]                       else if (inherits(cond, "condition")) {
[09:31:12.247]                         if (!is.null(pattern)) {
[09:31:12.247]                           computeRestarts <- base::computeRestarts
[09:31:12.247]                           grepl <- base::grepl
[09:31:12.247]                           restarts <- computeRestarts(cond)
[09:31:12.247]                           for (restart in restarts) {
[09:31:12.247]                             name <- restart$name
[09:31:12.247]                             if (is.null(name)) 
[09:31:12.247]                               next
[09:31:12.247]                             if (!grepl(pattern, name)) 
[09:31:12.247]                               next
[09:31:12.247]                             invokeRestart(restart)
[09:31:12.247]                             muffled <- TRUE
[09:31:12.247]                             break
[09:31:12.247]                           }
[09:31:12.247]                         }
[09:31:12.247]                       }
[09:31:12.247]                       invisible(muffled)
[09:31:12.247]                     }
[09:31:12.247]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.247]                   }
[09:31:12.247]                 }
[09:31:12.247]             }
[09:31:12.247]         }))
[09:31:12.247]     }, error = function(ex) {
[09:31:12.247]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.247]                 ...future.rng), started = ...future.startTime, 
[09:31:12.247]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.247]             version = "1.8"), class = "FutureResult")
[09:31:12.247]     }, finally = {
[09:31:12.247]         if (!identical(...future.workdir, getwd())) 
[09:31:12.247]             setwd(...future.workdir)
[09:31:12.247]         {
[09:31:12.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.247]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.247]             }
[09:31:12.247]             base::options(...future.oldOptions)
[09:31:12.247]             if (.Platform$OS.type == "windows") {
[09:31:12.247]                 old_names <- names(...future.oldEnvVars)
[09:31:12.247]                 envs <- base::Sys.getenv()
[09:31:12.247]                 names <- names(envs)
[09:31:12.247]                 common <- intersect(names, old_names)
[09:31:12.247]                 added <- setdiff(names, old_names)
[09:31:12.247]                 removed <- setdiff(old_names, names)
[09:31:12.247]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.247]                   envs[common]]
[09:31:12.247]                 NAMES <- toupper(changed)
[09:31:12.247]                 args <- list()
[09:31:12.247]                 for (kk in seq_along(NAMES)) {
[09:31:12.247]                   name <- changed[[kk]]
[09:31:12.247]                   NAME <- NAMES[[kk]]
[09:31:12.247]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.247]                     next
[09:31:12.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.247]                 }
[09:31:12.247]                 NAMES <- toupper(added)
[09:31:12.247]                 for (kk in seq_along(NAMES)) {
[09:31:12.247]                   name <- added[[kk]]
[09:31:12.247]                   NAME <- NAMES[[kk]]
[09:31:12.247]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.247]                     next
[09:31:12.247]                   args[[name]] <- ""
[09:31:12.247]                 }
[09:31:12.247]                 NAMES <- toupper(removed)
[09:31:12.247]                 for (kk in seq_along(NAMES)) {
[09:31:12.247]                   name <- removed[[kk]]
[09:31:12.247]                   NAME <- NAMES[[kk]]
[09:31:12.247]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.247]                     next
[09:31:12.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.247]                 }
[09:31:12.247]                 if (length(args) > 0) 
[09:31:12.247]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.247]             }
[09:31:12.247]             else {
[09:31:12.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.247]             }
[09:31:12.247]             {
[09:31:12.247]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.247]                   0L) {
[09:31:12.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.247]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.247]                   base::options(opts)
[09:31:12.247]                 }
[09:31:12.247]                 {
[09:31:12.247]                   {
[09:31:12.247]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.247]                     NULL
[09:31:12.247]                   }
[09:31:12.247]                   options(future.plan = NULL)
[09:31:12.247]                   if (is.na(NA_character_)) 
[09:31:12.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.247]                     .init = FALSE)
[09:31:12.247]                 }
[09:31:12.247]             }
[09:31:12.247]         }
[09:31:12.247]     })
[09:31:12.247]     if (TRUE) {
[09:31:12.247]         base::sink(type = "output", split = FALSE)
[09:31:12.247]         if (TRUE) {
[09:31:12.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.247]         }
[09:31:12.247]         else {
[09:31:12.247]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.247]         }
[09:31:12.247]         base::close(...future.stdout)
[09:31:12.247]         ...future.stdout <- NULL
[09:31:12.247]     }
[09:31:12.247]     ...future.result$conditions <- ...future.conditions
[09:31:12.247]     ...future.result$finished <- base::Sys.time()
[09:31:12.247]     ...future.result
[09:31:12.247] }
[09:31:12.251] requestCore(): workers = 2
[09:31:12.253] MulticoreFuture started
[09:31:12.254] - Launch lazy future ... done
[09:31:12.254] run() for ‘MulticoreFuture’ ... done
[09:31:12.254] plan(): Setting new future strategy stack:
List of 6
 $ a:[09:31:12.255] List of future strategies:
[09:31:12.255] 1. sequential:
[09:31:12.255]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.255]    - tweaked: FALSE
[09:31:12.255]    - call: NULL
[09:31:12.256] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb3f6610> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8e2a2f8> 
 $  : NULL
 $  :[09:31:12.258] plan(): Setting new future strategy stack:
 NULL
 $  :[09:31:12.258] List of future strategies:
[09:31:12.258] 1. multicore:
[09:31:12.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.258]    - tweaked: FALSE
[09:31:12.258]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb3f6610> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8e2a2f8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ :[09:31:12.263] plan(): nbrOfWorkers() = 2
 chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:12.266] resolve() on list ...
[09:31:12.267]  recursive: 0
[09:31:12.267]  length: 6
[09:31:12.267]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:12.267] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.267] - nx: 6
[09:31:12.267] - relay: TRUE
[09:31:12.267] - stdout: TRUE
[09:31:12.268] - signal: TRUE
[09:31:12.268] - resignal: FALSE
[09:31:12.268] - force: TRUE
[09:31:12.268] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.268] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.268]  - until=2
[09:31:12.269]  - relaying element #2
[09:31:12.269] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.269] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.269]  length: 5 (resolved future 1)
[09:31:12.269] Future #2
[09:31:12.270] result() for MulticoreFuture ...
[09:31:12.271] result() for MulticoreFuture ...
[09:31:12.271] result() for MulticoreFuture ... done
[09:31:12.271] result() for MulticoreFuture ... done
[09:31:12.271] result() for MulticoreFuture ...
[09:31:12.271] result() for MulticoreFuture ... done
[09:31:12.272] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:12.272] - nx: 6
[09:31:12.272] - relay: TRUE
[09:31:12.272] - stdout: TRUE
[09:31:12.272] - signal: TRUE
[09:31:12.272] - resignal: FALSE
[09:31:12.273] - force: TRUE
[09:31:12.273] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.273] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.273]  - until=2
[09:31:12.273]  - relaying element #2
[09:31:12.273] result() for MulticoreFuture ...
[09:31:12.274] result() for MulticoreFuture ... done
[09:31:12.274] result() for MulticoreFuture ...
[09:31:12.274] result() for MulticoreFuture ... done
[09:31:12.274] result() for MulticoreFuture ...
[09:31:12.274] result() for MulticoreFuture ... done
[09:31:12.275] result() for MulticoreFuture ...
[09:31:12.275] result() for MulticoreFuture ... done
[09:31:12.275] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.275] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.275] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:12.275]  length: 4 (resolved future 2)
[09:31:12.276] Future #3
[09:31:12.276] result() for MulticoreFuture ...
[09:31:12.276] result() for MulticoreFuture ...
[09:31:12.277] result() for MulticoreFuture ... done
[09:31:12.277] result() for MulticoreFuture ... done
[09:31:12.277] result() for MulticoreFuture ...
[09:31:12.277] result() for MulticoreFuture ... done
[09:31:12.277] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:12.277] - nx: 6
[09:31:12.277] - relay: TRUE
[09:31:12.277] - stdout: TRUE
[09:31:12.278] - signal: TRUE
[09:31:12.278] - resignal: FALSE
[09:31:12.278] - force: TRUE
[09:31:12.278] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.278] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.278]  - until=3
[09:31:12.278]  - relaying element #3
[09:31:12.278] result() for MulticoreFuture ...
[09:31:12.279] result() for MulticoreFuture ... done
[09:31:12.279] result() for MulticoreFuture ...
[09:31:12.279] result() for MulticoreFuture ... done
[09:31:12.279] result() for MulticoreFuture ...
[09:31:12.279] result() for MulticoreFuture ... done
[09:31:12.281] result() for MulticoreFuture ...
[09:31:12.282] result() for MulticoreFuture ... done
[09:31:12.282] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.282] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.282] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:12.282]  length: 3 (resolved future 3)
[09:31:12.283] signalConditionsASAP(NULL, pos=4) ...
[09:31:12.283] - nx: 6
[09:31:12.283] - relay: TRUE
[09:31:12.283] - stdout: TRUE
[09:31:12.283] - signal: TRUE
[09:31:12.283] - resignal: FALSE
[09:31:12.283] - force: TRUE
[09:31:12.283] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.284] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.284]  - until=5
[09:31:12.284]  - relaying element #5
[09:31:12.284] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.284] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.284] signalConditionsASAP(NULL, pos=4) ... done
[09:31:12.284]  length: 2 (resolved future 4)
[09:31:12.284] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.285] - nx: 6
[09:31:12.285] - relay: TRUE
[09:31:12.285] - stdout: TRUE
[09:31:12.285] - signal: TRUE
[09:31:12.285] - resignal: FALSE
[09:31:12.285] - force: TRUE
[09:31:12.285] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.285] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.285]  - until=6
[09:31:12.286]  - relaying element #6
[09:31:12.286] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.286] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.286] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.286]  length: 1 (resolved future 5)
[09:31:12.286] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.286] - nx: 6
[09:31:12.286] - relay: TRUE
[09:31:12.286] - stdout: TRUE
[09:31:12.287] - signal: TRUE
[09:31:12.287] - resignal: FALSE
[09:31:12.287] - force: TRUE
[09:31:12.287] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.287] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.287]  - until=6
[09:31:12.287] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.287] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.287] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.288]  length: 0 (resolved future 6)
[09:31:12.288] Relaying remaining futures
[09:31:12.288] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.288] - nx: 6
[09:31:12.288] - relay: TRUE
[09:31:12.288] - stdout: TRUE
[09:31:12.288] - signal: TRUE
[09:31:12.288] - resignal: FALSE
[09:31:12.288] - force: TRUE
[09:31:12.288] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.288] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:12.289] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.289] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.289] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.289] resolve() on list ... DONE
[09:31:12.289] result() for MulticoreFuture ...
[09:31:12.289] result() for MulticoreFuture ... done
[09:31:12.289] result() for MulticoreFuture ...
[09:31:12.289] result() for MulticoreFuture ... done
[09:31:12.290] result() for MulticoreFuture ...
[09:31:12.290] result() for MulticoreFuture ... done
[09:31:12.290] result() for MulticoreFuture ...
[09:31:12.290] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:12.293] getGlobalsAndPackages() ...
[09:31:12.294] Searching for globals...
[09:31:12.294] 
[09:31:12.294] Searching for globals ... DONE
[09:31:12.294] - globals: [0] <none>
[09:31:12.294] getGlobalsAndPackages() ... DONE
[09:31:12.294] run() for ‘Future’ ...
[09:31:12.295] - state: ‘created’
[09:31:12.295] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.298] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.299]   - Field: ‘label’
[09:31:12.299]   - Field: ‘local’
[09:31:12.299]   - Field: ‘owner’
[09:31:12.299]   - Field: ‘envir’
[09:31:12.299]   - Field: ‘workers’
[09:31:12.299]   - Field: ‘packages’
[09:31:12.299]   - Field: ‘gc’
[09:31:12.299]   - Field: ‘job’
[09:31:12.299]   - Field: ‘conditions’
[09:31:12.299]   - Field: ‘expr’
[09:31:12.299]   - Field: ‘uuid’
[09:31:12.300]   - Field: ‘seed’
[09:31:12.300]   - Field: ‘version’
[09:31:12.300]   - Field: ‘result’
[09:31:12.300]   - Field: ‘asynchronous’
[09:31:12.300]   - Field: ‘calls’
[09:31:12.300]   - Field: ‘globals’
[09:31:12.300]   - Field: ‘stdout’
[09:31:12.300]   - Field: ‘earlySignal’
[09:31:12.300]   - Field: ‘lazy’
[09:31:12.300]   - Field: ‘state’
[09:31:12.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.301] - Launch lazy future ...
[09:31:12.301] Packages needed by the future expression (n = 0): <none>
[09:31:12.301] Packages needed by future strategies (n = 0): <none>
[09:31:12.301] {
[09:31:12.301]     {
[09:31:12.301]         {
[09:31:12.301]             ...future.startTime <- base::Sys.time()
[09:31:12.301]             {
[09:31:12.301]                 {
[09:31:12.301]                   {
[09:31:12.301]                     {
[09:31:12.301]                       base::local({
[09:31:12.301]                         has_future <- base::requireNamespace("future", 
[09:31:12.301]                           quietly = TRUE)
[09:31:12.301]                         if (has_future) {
[09:31:12.301]                           ns <- base::getNamespace("future")
[09:31:12.301]                           version <- ns[[".package"]][["version"]]
[09:31:12.301]                           if (is.null(version)) 
[09:31:12.301]                             version <- utils::packageVersion("future")
[09:31:12.301]                         }
[09:31:12.301]                         else {
[09:31:12.301]                           version <- NULL
[09:31:12.301]                         }
[09:31:12.301]                         if (!has_future || version < "1.8.0") {
[09:31:12.301]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.301]                             "", base::R.version$version.string), 
[09:31:12.301]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.301]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.301]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.301]                               "release", "version")], collapse = " "), 
[09:31:12.301]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.301]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.301]                             info)
[09:31:12.301]                           info <- base::paste(info, collapse = "; ")
[09:31:12.301]                           if (!has_future) {
[09:31:12.301]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.301]                               info)
[09:31:12.301]                           }
[09:31:12.301]                           else {
[09:31:12.301]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.301]                               info, version)
[09:31:12.301]                           }
[09:31:12.301]                           base::stop(msg)
[09:31:12.301]                         }
[09:31:12.301]                       })
[09:31:12.301]                     }
[09:31:12.301]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.301]                     base::options(mc.cores = 1L)
[09:31:12.301]                   }
[09:31:12.301]                   ...future.strategy.old <- future::plan("list")
[09:31:12.301]                   options(future.plan = NULL)
[09:31:12.301]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.301]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.301]                 }
[09:31:12.301]                 ...future.workdir <- getwd()
[09:31:12.301]             }
[09:31:12.301]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.301]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.301]         }
[09:31:12.301]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.301]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.301]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.301]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.301]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.301]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.301]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.301]             base::names(...future.oldOptions))
[09:31:12.301]     }
[09:31:12.301]     if (FALSE) {
[09:31:12.301]     }
[09:31:12.301]     else {
[09:31:12.301]         if (TRUE) {
[09:31:12.301]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.301]                 open = "w")
[09:31:12.301]         }
[09:31:12.301]         else {
[09:31:12.301]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.301]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.301]         }
[09:31:12.301]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.301]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.301]             base::sink(type = "output", split = FALSE)
[09:31:12.301]             base::close(...future.stdout)
[09:31:12.301]         }, add = TRUE)
[09:31:12.301]     }
[09:31:12.301]     ...future.frame <- base::sys.nframe()
[09:31:12.301]     ...future.conditions <- base::list()
[09:31:12.301]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.301]     if (FALSE) {
[09:31:12.301]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.301]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.301]     }
[09:31:12.301]     ...future.result <- base::tryCatch({
[09:31:12.301]         base::withCallingHandlers({
[09:31:12.301]             ...future.value <- base::withVisible(base::local({
[09:31:12.301]                 withCallingHandlers({
[09:31:12.301]                   2
[09:31:12.301]                 }, immediateCondition = function(cond) {
[09:31:12.301]                   save_rds <- function (object, pathname, ...) 
[09:31:12.301]                   {
[09:31:12.301]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.301]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.301]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.301]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.301]                         fi_tmp[["mtime"]])
[09:31:12.301]                     }
[09:31:12.301]                     tryCatch({
[09:31:12.301]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.301]                     }, error = function(ex) {
[09:31:12.301]                       msg <- conditionMessage(ex)
[09:31:12.301]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.301]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.301]                         fi_tmp[["mtime"]], msg)
[09:31:12.301]                       ex$message <- msg
[09:31:12.301]                       stop(ex)
[09:31:12.301]                     })
[09:31:12.301]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.301]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.301]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.301]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.301]                       fi <- file.info(pathname)
[09:31:12.301]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.301]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.301]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.301]                         fi[["size"]], fi[["mtime"]])
[09:31:12.301]                       stop(msg)
[09:31:12.301]                     }
[09:31:12.301]                     invisible(pathname)
[09:31:12.301]                   }
[09:31:12.301]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.301]                     rootPath = tempdir()) 
[09:31:12.301]                   {
[09:31:12.301]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.301]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.301]                       tmpdir = path, fileext = ".rds")
[09:31:12.301]                     save_rds(obj, file)
[09:31:12.301]                   }
[09:31:12.301]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.301]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.301]                   {
[09:31:12.301]                     inherits <- base::inherits
[09:31:12.301]                     invokeRestart <- base::invokeRestart
[09:31:12.301]                     is.null <- base::is.null
[09:31:12.301]                     muffled <- FALSE
[09:31:12.301]                     if (inherits(cond, "message")) {
[09:31:12.301]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.301]                       if (muffled) 
[09:31:12.301]                         invokeRestart("muffleMessage")
[09:31:12.301]                     }
[09:31:12.301]                     else if (inherits(cond, "warning")) {
[09:31:12.301]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.301]                       if (muffled) 
[09:31:12.301]                         invokeRestart("muffleWarning")
[09:31:12.301]                     }
[09:31:12.301]                     else if (inherits(cond, "condition")) {
[09:31:12.301]                       if (!is.null(pattern)) {
[09:31:12.301]                         computeRestarts <- base::computeRestarts
[09:31:12.301]                         grepl <- base::grepl
[09:31:12.301]                         restarts <- computeRestarts(cond)
[09:31:12.301]                         for (restart in restarts) {
[09:31:12.301]                           name <- restart$name
[09:31:12.301]                           if (is.null(name)) 
[09:31:12.301]                             next
[09:31:12.301]                           if (!grepl(pattern, name)) 
[09:31:12.301]                             next
[09:31:12.301]                           invokeRestart(restart)
[09:31:12.301]                           muffled <- TRUE
[09:31:12.301]                           break
[09:31:12.301]                         }
[09:31:12.301]                       }
[09:31:12.301]                     }
[09:31:12.301]                     invisible(muffled)
[09:31:12.301]                   }
[09:31:12.301]                   muffleCondition(cond)
[09:31:12.301]                 })
[09:31:12.301]             }))
[09:31:12.301]             future::FutureResult(value = ...future.value$value, 
[09:31:12.301]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.301]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.301]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.301]                     ...future.globalenv.names))
[09:31:12.301]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.301]         }, condition = base::local({
[09:31:12.301]             c <- base::c
[09:31:12.301]             inherits <- base::inherits
[09:31:12.301]             invokeRestart <- base::invokeRestart
[09:31:12.301]             length <- base::length
[09:31:12.301]             list <- base::list
[09:31:12.301]             seq.int <- base::seq.int
[09:31:12.301]             signalCondition <- base::signalCondition
[09:31:12.301]             sys.calls <- base::sys.calls
[09:31:12.301]             `[[` <- base::`[[`
[09:31:12.301]             `+` <- base::`+`
[09:31:12.301]             `<<-` <- base::`<<-`
[09:31:12.301]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.301]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.301]                   3L)]
[09:31:12.301]             }
[09:31:12.301]             function(cond) {
[09:31:12.301]                 is_error <- inherits(cond, "error")
[09:31:12.301]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.301]                   NULL)
[09:31:12.301]                 if (is_error) {
[09:31:12.301]                   sessionInformation <- function() {
[09:31:12.301]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.301]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.301]                       search = base::search(), system = base::Sys.info())
[09:31:12.301]                   }
[09:31:12.301]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.301]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.301]                     cond$call), session = sessionInformation(), 
[09:31:12.301]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.301]                   signalCondition(cond)
[09:31:12.301]                 }
[09:31:12.301]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.301]                 "immediateCondition"))) {
[09:31:12.301]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.301]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.301]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.301]                   if (TRUE && !signal) {
[09:31:12.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.301]                     {
[09:31:12.301]                       inherits <- base::inherits
[09:31:12.301]                       invokeRestart <- base::invokeRestart
[09:31:12.301]                       is.null <- base::is.null
[09:31:12.301]                       muffled <- FALSE
[09:31:12.301]                       if (inherits(cond, "message")) {
[09:31:12.301]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.301]                         if (muffled) 
[09:31:12.301]                           invokeRestart("muffleMessage")
[09:31:12.301]                       }
[09:31:12.301]                       else if (inherits(cond, "warning")) {
[09:31:12.301]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.301]                         if (muffled) 
[09:31:12.301]                           invokeRestart("muffleWarning")
[09:31:12.301]                       }
[09:31:12.301]                       else if (inherits(cond, "condition")) {
[09:31:12.301]                         if (!is.null(pattern)) {
[09:31:12.301]                           computeRestarts <- base::computeRestarts
[09:31:12.301]                           grepl <- base::grepl
[09:31:12.301]                           restarts <- computeRestarts(cond)
[09:31:12.301]                           for (restart in restarts) {
[09:31:12.301]                             name <- restart$name
[09:31:12.301]                             if (is.null(name)) 
[09:31:12.301]                               next
[09:31:12.301]                             if (!grepl(pattern, name)) 
[09:31:12.301]                               next
[09:31:12.301]                             invokeRestart(restart)
[09:31:12.301]                             muffled <- TRUE
[09:31:12.301]                             break
[09:31:12.301]                           }
[09:31:12.301]                         }
[09:31:12.301]                       }
[09:31:12.301]                       invisible(muffled)
[09:31:12.301]                     }
[09:31:12.301]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.301]                   }
[09:31:12.301]                 }
[09:31:12.301]                 else {
[09:31:12.301]                   if (TRUE) {
[09:31:12.301]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.301]                     {
[09:31:12.301]                       inherits <- base::inherits
[09:31:12.301]                       invokeRestart <- base::invokeRestart
[09:31:12.301]                       is.null <- base::is.null
[09:31:12.301]                       muffled <- FALSE
[09:31:12.301]                       if (inherits(cond, "message")) {
[09:31:12.301]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.301]                         if (muffled) 
[09:31:12.301]                           invokeRestart("muffleMessage")
[09:31:12.301]                       }
[09:31:12.301]                       else if (inherits(cond, "warning")) {
[09:31:12.301]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.301]                         if (muffled) 
[09:31:12.301]                           invokeRestart("muffleWarning")
[09:31:12.301]                       }
[09:31:12.301]                       else if (inherits(cond, "condition")) {
[09:31:12.301]                         if (!is.null(pattern)) {
[09:31:12.301]                           computeRestarts <- base::computeRestarts
[09:31:12.301]                           grepl <- base::grepl
[09:31:12.301]                           restarts <- computeRestarts(cond)
[09:31:12.301]                           for (restart in restarts) {
[09:31:12.301]                             name <- restart$name
[09:31:12.301]                             if (is.null(name)) 
[09:31:12.301]                               next
[09:31:12.301]                             if (!grepl(pattern, name)) 
[09:31:12.301]                               next
[09:31:12.301]                             invokeRestart(restart)
[09:31:12.301]                             muffled <- TRUE
[09:31:12.301]                             break
[09:31:12.301]                           }
[09:31:12.301]                         }
[09:31:12.301]                       }
[09:31:12.301]                       invisible(muffled)
[09:31:12.301]                     }
[09:31:12.301]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.301]                   }
[09:31:12.301]                 }
[09:31:12.301]             }
[09:31:12.301]         }))
[09:31:12.301]     }, error = function(ex) {
[09:31:12.301]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.301]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.301]                 ...future.rng), started = ...future.startTime, 
[09:31:12.301]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.301]             version = "1.8"), class = "FutureResult")
[09:31:12.301]     }, finally = {
[09:31:12.301]         if (!identical(...future.workdir, getwd())) 
[09:31:12.301]             setwd(...future.workdir)
[09:31:12.301]         {
[09:31:12.301]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.301]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.301]             }
[09:31:12.301]             base::options(...future.oldOptions)
[09:31:12.301]             if (.Platform$OS.type == "windows") {
[09:31:12.301]                 old_names <- names(...future.oldEnvVars)
[09:31:12.301]                 envs <- base::Sys.getenv()
[09:31:12.301]                 names <- names(envs)
[09:31:12.301]                 common <- intersect(names, old_names)
[09:31:12.301]                 added <- setdiff(names, old_names)
[09:31:12.301]                 removed <- setdiff(old_names, names)
[09:31:12.301]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.301]                   envs[common]]
[09:31:12.301]                 NAMES <- toupper(changed)
[09:31:12.301]                 args <- list()
[09:31:12.301]                 for (kk in seq_along(NAMES)) {
[09:31:12.301]                   name <- changed[[kk]]
[09:31:12.301]                   NAME <- NAMES[[kk]]
[09:31:12.301]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.301]                     next
[09:31:12.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.301]                 }
[09:31:12.301]                 NAMES <- toupper(added)
[09:31:12.301]                 for (kk in seq_along(NAMES)) {
[09:31:12.301]                   name <- added[[kk]]
[09:31:12.301]                   NAME <- NAMES[[kk]]
[09:31:12.301]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.301]                     next
[09:31:12.301]                   args[[name]] <- ""
[09:31:12.301]                 }
[09:31:12.301]                 NAMES <- toupper(removed)
[09:31:12.301]                 for (kk in seq_along(NAMES)) {
[09:31:12.301]                   name <- removed[[kk]]
[09:31:12.301]                   NAME <- NAMES[[kk]]
[09:31:12.301]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.301]                     next
[09:31:12.301]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.301]                 }
[09:31:12.301]                 if (length(args) > 0) 
[09:31:12.301]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.301]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.301]             }
[09:31:12.301]             else {
[09:31:12.301]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.301]             }
[09:31:12.301]             {
[09:31:12.301]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.301]                   0L) {
[09:31:12.301]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.301]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.301]                   base::options(opts)
[09:31:12.301]                 }
[09:31:12.301]                 {
[09:31:12.301]                   {
[09:31:12.301]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.301]                     NULL
[09:31:12.301]                   }
[09:31:12.301]                   options(future.plan = NULL)
[09:31:12.301]                   if (is.na(NA_character_)) 
[09:31:12.301]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.301]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.301]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.301]                     .init = FALSE)
[09:31:12.301]                 }
[09:31:12.301]             }
[09:31:12.301]         }
[09:31:12.301]     })
[09:31:12.301]     if (TRUE) {
[09:31:12.301]         base::sink(type = "output", split = FALSE)
[09:31:12.301]         if (TRUE) {
[09:31:12.301]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.301]         }
[09:31:12.301]         else {
[09:31:12.301]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.301]         }
[09:31:12.301]         base::close(...future.stdout)
[09:31:12.301]         ...future.stdout <- NULL
[09:31:12.301]     }
[09:31:12.301]     ...future.result$conditions <- ...future.conditions
[09:31:12.301]     ...future.result$finished <- base::Sys.time()
[09:31:12.301]     ...future.result
[09:31:12.301] }
[09:31:12.304] requestCore(): workers = 2
[09:31:12.305] MulticoreFuture started
[09:31:12.306] - Launch lazy future ... done
[09:31:12.306] run() for ‘MulticoreFuture’ ... done
[09:31:12.306] getGlobalsAndPackages() ...
[09:31:12.306] plan(): Setting new future strategy stack:
[09:31:12.306] Searching for globals...
[09:31:12.307] List of future strategies:
[09:31:12.307] 1. sequential:
[09:31:12.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.307]    - tweaked: FALSE
[09:31:12.307]    - call: NULL
[09:31:12.307] 
[09:31:12.307] Searching for globals ... DONE
[09:31:12.307] plan(): nbrOfWorkers() = 1
[09:31:12.308] - globals: [0] <none>
[09:31:12.308] getGlobalsAndPackages() ... DONE
[09:31:12.308] run() for ‘Future’ ...
[09:31:12.308] - state: ‘created’
[09:31:12.309] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.309] plan(): Setting new future strategy stack:
[09:31:12.309] List of future strategies:
[09:31:12.309] 1. multicore:
[09:31:12.309]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.309]    - tweaked: FALSE
[09:31:12.309]    - call: plan(strategy)
[09:31:12.314] plan(): nbrOfWorkers() = 2
[09:31:12.314] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.314]   - Field: ‘label’
[09:31:12.315]   - Field: ‘local’
[09:31:12.315]   - Field: ‘owner’
[09:31:12.315]   - Field: ‘envir’
[09:31:12.315]   - Field: ‘workers’
[09:31:12.315]   - Field: ‘packages’
[09:31:12.315]   - Field: ‘gc’
[09:31:12.316]   - Field: ‘job’
[09:31:12.316]   - Field: ‘conditions’
[09:31:12.316]   - Field: ‘expr’
[09:31:12.316]   - Field: ‘uuid’
[09:31:12.316]   - Field: ‘seed’
[09:31:12.316]   - Field: ‘version’
[09:31:12.317]   - Field: ‘result’
[09:31:12.317]   - Field: ‘asynchronous’
[09:31:12.317]   - Field: ‘calls’
[09:31:12.317]   - Field: ‘globals’
[09:31:12.317]   - Field: ‘stdout’
[09:31:12.317]   - Field: ‘earlySignal’
[09:31:12.317]   - Field: ‘lazy’
[09:31:12.318]   - Field: ‘state’
[09:31:12.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.318] - Launch lazy future ...
[09:31:12.318] Packages needed by the future expression (n = 0): <none>
[09:31:12.319] Packages needed by future strategies (n = 0): <none>
[09:31:12.319] {
[09:31:12.319]     {
[09:31:12.319]         {
[09:31:12.319]             ...future.startTime <- base::Sys.time()
[09:31:12.319]             {
[09:31:12.319]                 {
[09:31:12.319]                   {
[09:31:12.319]                     {
[09:31:12.319]                       base::local({
[09:31:12.319]                         has_future <- base::requireNamespace("future", 
[09:31:12.319]                           quietly = TRUE)
[09:31:12.319]                         if (has_future) {
[09:31:12.319]                           ns <- base::getNamespace("future")
[09:31:12.319]                           version <- ns[[".package"]][["version"]]
[09:31:12.319]                           if (is.null(version)) 
[09:31:12.319]                             version <- utils::packageVersion("future")
[09:31:12.319]                         }
[09:31:12.319]                         else {
[09:31:12.319]                           version <- NULL
[09:31:12.319]                         }
[09:31:12.319]                         if (!has_future || version < "1.8.0") {
[09:31:12.319]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.319]                             "", base::R.version$version.string), 
[09:31:12.319]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.319]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.319]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.319]                               "release", "version")], collapse = " "), 
[09:31:12.319]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.319]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.319]                             info)
[09:31:12.319]                           info <- base::paste(info, collapse = "; ")
[09:31:12.319]                           if (!has_future) {
[09:31:12.319]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.319]                               info)
[09:31:12.319]                           }
[09:31:12.319]                           else {
[09:31:12.319]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.319]                               info, version)
[09:31:12.319]                           }
[09:31:12.319]                           base::stop(msg)
[09:31:12.319]                         }
[09:31:12.319]                       })
[09:31:12.319]                     }
[09:31:12.319]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.319]                     base::options(mc.cores = 1L)
[09:31:12.319]                   }
[09:31:12.319]                   ...future.strategy.old <- future::plan("list")
[09:31:12.319]                   options(future.plan = NULL)
[09:31:12.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.319]                 }
[09:31:12.319]                 ...future.workdir <- getwd()
[09:31:12.319]             }
[09:31:12.319]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.319]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.319]         }
[09:31:12.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.319]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.319]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.319]             base::names(...future.oldOptions))
[09:31:12.319]     }
[09:31:12.319]     if (FALSE) {
[09:31:12.319]     }
[09:31:12.319]     else {
[09:31:12.319]         if (TRUE) {
[09:31:12.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.319]                 open = "w")
[09:31:12.319]         }
[09:31:12.319]         else {
[09:31:12.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.319]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.319]         }
[09:31:12.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.319]             base::sink(type = "output", split = FALSE)
[09:31:12.319]             base::close(...future.stdout)
[09:31:12.319]         }, add = TRUE)
[09:31:12.319]     }
[09:31:12.319]     ...future.frame <- base::sys.nframe()
[09:31:12.319]     ...future.conditions <- base::list()
[09:31:12.319]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.319]     if (FALSE) {
[09:31:12.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.319]     }
[09:31:12.319]     ...future.result <- base::tryCatch({
[09:31:12.319]         base::withCallingHandlers({
[09:31:12.319]             ...future.value <- base::withVisible(base::local({
[09:31:12.319]                 withCallingHandlers({
[09:31:12.319]                   NULL
[09:31:12.319]                 }, immediateCondition = function(cond) {
[09:31:12.319]                   save_rds <- function (object, pathname, ...) 
[09:31:12.319]                   {
[09:31:12.319]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.319]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.319]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.319]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.319]                         fi_tmp[["mtime"]])
[09:31:12.319]                     }
[09:31:12.319]                     tryCatch({
[09:31:12.319]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.319]                     }, error = function(ex) {
[09:31:12.319]                       msg <- conditionMessage(ex)
[09:31:12.319]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.319]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.319]                         fi_tmp[["mtime"]], msg)
[09:31:12.319]                       ex$message <- msg
[09:31:12.319]                       stop(ex)
[09:31:12.319]                     })
[09:31:12.319]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.319]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.319]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.319]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.319]                       fi <- file.info(pathname)
[09:31:12.319]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.319]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.319]                         fi[["size"]], fi[["mtime"]])
[09:31:12.319]                       stop(msg)
[09:31:12.319]                     }
[09:31:12.319]                     invisible(pathname)
[09:31:12.319]                   }
[09:31:12.319]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.319]                     rootPath = tempdir()) 
[09:31:12.319]                   {
[09:31:12.319]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.319]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.319]                       tmpdir = path, fileext = ".rds")
[09:31:12.319]                     save_rds(obj, file)
[09:31:12.319]                   }
[09:31:12.319]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.319]                   {
[09:31:12.319]                     inherits <- base::inherits
[09:31:12.319]                     invokeRestart <- base::invokeRestart
[09:31:12.319]                     is.null <- base::is.null
[09:31:12.319]                     muffled <- FALSE
[09:31:12.319]                     if (inherits(cond, "message")) {
[09:31:12.319]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.319]                       if (muffled) 
[09:31:12.319]                         invokeRestart("muffleMessage")
[09:31:12.319]                     }
[09:31:12.319]                     else if (inherits(cond, "warning")) {
[09:31:12.319]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.319]                       if (muffled) 
[09:31:12.319]                         invokeRestart("muffleWarning")
[09:31:12.319]                     }
[09:31:12.319]                     else if (inherits(cond, "condition")) {
[09:31:12.319]                       if (!is.null(pattern)) {
[09:31:12.319]                         computeRestarts <- base::computeRestarts
[09:31:12.319]                         grepl <- base::grepl
[09:31:12.319]                         restarts <- computeRestarts(cond)
[09:31:12.319]                         for (restart in restarts) {
[09:31:12.319]                           name <- restart$name
[09:31:12.319]                           if (is.null(name)) 
[09:31:12.319]                             next
[09:31:12.319]                           if (!grepl(pattern, name)) 
[09:31:12.319]                             next
[09:31:12.319]                           invokeRestart(restart)
[09:31:12.319]                           muffled <- TRUE
[09:31:12.319]                           break
[09:31:12.319]                         }
[09:31:12.319]                       }
[09:31:12.319]                     }
[09:31:12.319]                     invisible(muffled)
[09:31:12.319]                   }
[09:31:12.319]                   muffleCondition(cond)
[09:31:12.319]                 })
[09:31:12.319]             }))
[09:31:12.319]             future::FutureResult(value = ...future.value$value, 
[09:31:12.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.319]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.319]                     ...future.globalenv.names))
[09:31:12.319]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.319]         }, condition = base::local({
[09:31:12.319]             c <- base::c
[09:31:12.319]             inherits <- base::inherits
[09:31:12.319]             invokeRestart <- base::invokeRestart
[09:31:12.319]             length <- base::length
[09:31:12.319]             list <- base::list
[09:31:12.319]             seq.int <- base::seq.int
[09:31:12.319]             signalCondition <- base::signalCondition
[09:31:12.319]             sys.calls <- base::sys.calls
[09:31:12.319]             `[[` <- base::`[[`
[09:31:12.319]             `+` <- base::`+`
[09:31:12.319]             `<<-` <- base::`<<-`
[09:31:12.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.319]                   3L)]
[09:31:12.319]             }
[09:31:12.319]             function(cond) {
[09:31:12.319]                 is_error <- inherits(cond, "error")
[09:31:12.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.319]                   NULL)
[09:31:12.319]                 if (is_error) {
[09:31:12.319]                   sessionInformation <- function() {
[09:31:12.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.319]                       search = base::search(), system = base::Sys.info())
[09:31:12.319]                   }
[09:31:12.319]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.319]                     cond$call), session = sessionInformation(), 
[09:31:12.319]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.319]                   signalCondition(cond)
[09:31:12.319]                 }
[09:31:12.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.319]                 "immediateCondition"))) {
[09:31:12.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.319]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.319]                   if (TRUE && !signal) {
[09:31:12.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.319]                     {
[09:31:12.319]                       inherits <- base::inherits
[09:31:12.319]                       invokeRestart <- base::invokeRestart
[09:31:12.319]                       is.null <- base::is.null
[09:31:12.319]                       muffled <- FALSE
[09:31:12.319]                       if (inherits(cond, "message")) {
[09:31:12.319]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.319]                         if (muffled) 
[09:31:12.319]                           invokeRestart("muffleMessage")
[09:31:12.319]                       }
[09:31:12.319]                       else if (inherits(cond, "warning")) {
[09:31:12.319]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.319]                         if (muffled) 
[09:31:12.319]                           invokeRestart("muffleWarning")
[09:31:12.319]                       }
[09:31:12.319]                       else if (inherits(cond, "condition")) {
[09:31:12.319]                         if (!is.null(pattern)) {
[09:31:12.319]                           computeRestarts <- base::computeRestarts
[09:31:12.319]                           grepl <- base::grepl
[09:31:12.319]                           restarts <- computeRestarts(cond)
[09:31:12.319]                           for (restart in restarts) {
[09:31:12.319]                             name <- restart$name
[09:31:12.319]                             if (is.null(name)) 
[09:31:12.319]                               next
[09:31:12.319]                             if (!grepl(pattern, name)) 
[09:31:12.319]                               next
[09:31:12.319]                             invokeRestart(restart)
[09:31:12.319]                             muffled <- TRUE
[09:31:12.319]                             break
[09:31:12.319]                           }
[09:31:12.319]                         }
[09:31:12.319]                       }
[09:31:12.319]                       invisible(muffled)
[09:31:12.319]                     }
[09:31:12.319]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.319]                   }
[09:31:12.319]                 }
[09:31:12.319]                 else {
[09:31:12.319]                   if (TRUE) {
[09:31:12.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.319]                     {
[09:31:12.319]                       inherits <- base::inherits
[09:31:12.319]                       invokeRestart <- base::invokeRestart
[09:31:12.319]                       is.null <- base::is.null
[09:31:12.319]                       muffled <- FALSE
[09:31:12.319]                       if (inherits(cond, "message")) {
[09:31:12.319]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.319]                         if (muffled) 
[09:31:12.319]                           invokeRestart("muffleMessage")
[09:31:12.319]                       }
[09:31:12.319]                       else if (inherits(cond, "warning")) {
[09:31:12.319]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.319]                         if (muffled) 
[09:31:12.319]                           invokeRestart("muffleWarning")
[09:31:12.319]                       }
[09:31:12.319]                       else if (inherits(cond, "condition")) {
[09:31:12.319]                         if (!is.null(pattern)) {
[09:31:12.319]                           computeRestarts <- base::computeRestarts
[09:31:12.319]                           grepl <- base::grepl
[09:31:12.319]                           restarts <- computeRestarts(cond)
[09:31:12.319]                           for (restart in restarts) {
[09:31:12.319]                             name <- restart$name
[09:31:12.319]                             if (is.null(name)) 
[09:31:12.319]                               next
[09:31:12.319]                             if (!grepl(pattern, name)) 
[09:31:12.319]                               next
[09:31:12.319]                             invokeRestart(restart)
[09:31:12.319]                             muffled <- TRUE
[09:31:12.319]                             break
[09:31:12.319]                           }
[09:31:12.319]                         }
[09:31:12.319]                       }
[09:31:12.319]                       invisible(muffled)
[09:31:12.319]                     }
[09:31:12.319]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.319]                   }
[09:31:12.319]                 }
[09:31:12.319]             }
[09:31:12.319]         }))
[09:31:12.319]     }, error = function(ex) {
[09:31:12.319]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.319]                 ...future.rng), started = ...future.startTime, 
[09:31:12.319]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.319]             version = "1.8"), class = "FutureResult")
[09:31:12.319]     }, finally = {
[09:31:12.319]         if (!identical(...future.workdir, getwd())) 
[09:31:12.319]             setwd(...future.workdir)
[09:31:12.319]         {
[09:31:12.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.319]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.319]             }
[09:31:12.319]             base::options(...future.oldOptions)
[09:31:12.319]             if (.Platform$OS.type == "windows") {
[09:31:12.319]                 old_names <- names(...future.oldEnvVars)
[09:31:12.319]                 envs <- base::Sys.getenv()
[09:31:12.319]                 names <- names(envs)
[09:31:12.319]                 common <- intersect(names, old_names)
[09:31:12.319]                 added <- setdiff(names, old_names)
[09:31:12.319]                 removed <- setdiff(old_names, names)
[09:31:12.319]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.319]                   envs[common]]
[09:31:12.319]                 NAMES <- toupper(changed)
[09:31:12.319]                 args <- list()
[09:31:12.319]                 for (kk in seq_along(NAMES)) {
[09:31:12.319]                   name <- changed[[kk]]
[09:31:12.319]                   NAME <- NAMES[[kk]]
[09:31:12.319]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.319]                     next
[09:31:12.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.319]                 }
[09:31:12.319]                 NAMES <- toupper(added)
[09:31:12.319]                 for (kk in seq_along(NAMES)) {
[09:31:12.319]                   name <- added[[kk]]
[09:31:12.319]                   NAME <- NAMES[[kk]]
[09:31:12.319]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.319]                     next
[09:31:12.319]                   args[[name]] <- ""
[09:31:12.319]                 }
[09:31:12.319]                 NAMES <- toupper(removed)
[09:31:12.319]                 for (kk in seq_along(NAMES)) {
[09:31:12.319]                   name <- removed[[kk]]
[09:31:12.319]                   NAME <- NAMES[[kk]]
[09:31:12.319]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.319]                     next
[09:31:12.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.319]                 }
[09:31:12.319]                 if (length(args) > 0) 
[09:31:12.319]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.319]             }
[09:31:12.319]             else {
[09:31:12.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.319]             }
[09:31:12.319]             {
[09:31:12.319]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.319]                   0L) {
[09:31:12.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.319]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.319]                   base::options(opts)
[09:31:12.319]                 }
[09:31:12.319]                 {
[09:31:12.319]                   {
[09:31:12.319]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.319]                     NULL
[09:31:12.319]                   }
[09:31:12.319]                   options(future.plan = NULL)
[09:31:12.319]                   if (is.na(NA_character_)) 
[09:31:12.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.319]                     .init = FALSE)
[09:31:12.319]                 }
[09:31:12.319]             }
[09:31:12.319]         }
[09:31:12.319]     })
[09:31:12.319]     if (TRUE) {
[09:31:12.319]         base::sink(type = "output", split = FALSE)
[09:31:12.319]         if (TRUE) {
[09:31:12.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.319]         }
[09:31:12.319]         else {
[09:31:12.319]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.319]         }
[09:31:12.319]         base::close(...future.stdout)
[09:31:12.319]         ...future.stdout <- NULL
[09:31:12.319]     }
[09:31:12.319]     ...future.result$conditions <- ...future.conditions
[09:31:12.319]     ...future.result$finished <- base::Sys.time()
[09:31:12.319]     ...future.result
[09:31:12.319] }
[09:31:12.323] requestCore(): workers = 2
[09:31:12.325] MulticoreFuture started
[09:31:12.325] - Launch lazy future ... done
[09:31:12.325] run() for ‘MulticoreFuture’ ... done
List of 6
[09:31:12.326] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[09:31:12.326] List of future strategies:
[09:31:12.326] 1. sequential:
[09:31:12.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.326]    - tweaked: FALSE
[09:31:12.326]    - call: NULL
[09:31:12.327] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca74df20> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cad690a8> 
 $  : NULL
 $  : NULL
 $  :[09:31:12.329] plan(): Setting new future strategy stack:
[09:31:12.329] List of future strategies:
[09:31:12.329] 1. multicore:
[09:31:12.329]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.329]    - tweaked: FALSE
[09:31:12.329]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca74df20> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cad690a8> 
 $  :[09:31:12.338] plan(): nbrOfWorkers() = 2
 NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:12.344] resolve() on list ...
[09:31:12.345]  recursive: 0
[09:31:12.345]  length: 6
[09:31:12.345]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:12.345] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.345] - nx: 6
[09:31:12.345] - relay: TRUE
[09:31:12.345] - stdout: TRUE
[09:31:12.346] - signal: TRUE
[09:31:12.346] - resignal: FALSE
[09:31:12.346] - force: TRUE
[09:31:12.346] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.346] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.346]  - until=2
[09:31:12.346]  - relaying element #2
[09:31:12.346] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.347] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.347] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.347]  length: 5 (resolved future 1)
[09:31:12.347] Future #2
[09:31:12.347] result() for MulticoreFuture ...
[09:31:12.348] result() for MulticoreFuture ...
[09:31:12.348] result() for MulticoreFuture ... done
[09:31:12.349] result() for MulticoreFuture ... done
[09:31:12.349] result() for MulticoreFuture ...
[09:31:12.349] result() for MulticoreFuture ... done
[09:31:12.349] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:12.349] - nx: 6
[09:31:12.349] - relay: TRUE
[09:31:12.349] - stdout: TRUE
[09:31:12.349] - signal: TRUE
[09:31:12.349] - resignal: FALSE
[09:31:12.350] - force: TRUE
[09:31:12.350] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.350] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.350]  - until=2
[09:31:12.350]  - relaying element #2
[09:31:12.350] result() for MulticoreFuture ...
[09:31:12.350] result() for MulticoreFuture ... done
[09:31:12.350] result() for MulticoreFuture ...
[09:31:12.351] result() for MulticoreFuture ... done
[09:31:12.351] result() for MulticoreFuture ...
[09:31:12.351] result() for MulticoreFuture ... done
[09:31:12.351] result() for MulticoreFuture ...
[09:31:12.351] result() for MulticoreFuture ... done
[09:31:12.351] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.351] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.352] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:12.352]  length: 4 (resolved future 2)
[09:31:12.352] Future #3
[09:31:12.352] result() for MulticoreFuture ...
[09:31:12.353] result() for MulticoreFuture ...
[09:31:12.353] result() for MulticoreFuture ... done
[09:31:12.353] result() for MulticoreFuture ... done
[09:31:12.353] result() for MulticoreFuture ...
[09:31:12.353] result() for MulticoreFuture ... done
[09:31:12.353] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:12.354] - nx: 6
[09:31:12.354] - relay: TRUE
[09:31:12.354] - stdout: TRUE
[09:31:12.354] - signal: TRUE
[09:31:12.354] - resignal: FALSE
[09:31:12.354] - force: TRUE
[09:31:12.354] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.354] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.354]  - until=3
[09:31:12.354]  - relaying element #3
[09:31:12.355] result() for MulticoreFuture ...
[09:31:12.355] result() for MulticoreFuture ... done
[09:31:12.355] result() for MulticoreFuture ...
[09:31:12.355] result() for MulticoreFuture ... done
[09:31:12.355] result() for MulticoreFuture ...
[09:31:12.355] result() for MulticoreFuture ... done
[09:31:12.355] result() for MulticoreFuture ...
[09:31:12.355] result() for MulticoreFuture ... done
[09:31:12.355] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.355] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.356] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:12.356]  length: 3 (resolved future 3)
[09:31:12.356] signalConditionsASAP(NULL, pos=4) ...
[09:31:12.356] - nx: 6
[09:31:12.356] - relay: TRUE
[09:31:12.356] - stdout: TRUE
[09:31:12.356] - signal: TRUE
[09:31:12.356] - resignal: FALSE
[09:31:12.356] - force: TRUE
[09:31:12.356] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.357] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.357]  - until=5
[09:31:12.357]  - relaying element #5
[09:31:12.357] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.357] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.357] signalConditionsASAP(NULL, pos=4) ... done
[09:31:12.357]  length: 2 (resolved future 4)
[09:31:12.357] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.357] - nx: 6
[09:31:12.357] - relay: TRUE
[09:31:12.358] - stdout: TRUE
[09:31:12.358] - signal: TRUE
[09:31:12.358] - resignal: FALSE
[09:31:12.358] - force: TRUE
[09:31:12.358] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.358] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.358]  - until=6
[09:31:12.358]  - relaying element #6
[09:31:12.358] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.358] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.358] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.359]  length: 1 (resolved future 5)
[09:31:12.359] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.359] - nx: 6
[09:31:12.359] - relay: TRUE
[09:31:12.359] - stdout: TRUE
[09:31:12.359] - signal: TRUE
[09:31:12.359] - resignal: FALSE
[09:31:12.359] - force: TRUE
[09:31:12.359] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.359] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.359]  - until=6
[09:31:12.360] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.360] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.360] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.360]  length: 0 (resolved future 6)
[09:31:12.360] Relaying remaining futures
[09:31:12.360] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.360] - nx: 6
[09:31:12.360] - relay: TRUE
[09:31:12.360] - stdout: TRUE
[09:31:12.360] - signal: TRUE
[09:31:12.361] - resignal: FALSE
[09:31:12.361] - force: TRUE
[09:31:12.361] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.361] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:12.361] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.361] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.361] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.361] resolve() on list ... DONE
[09:31:12.361] result() for MulticoreFuture ...
[09:31:12.362] result() for MulticoreFuture ... done
[09:31:12.362] result() for MulticoreFuture ...
[09:31:12.362] result() for MulticoreFuture ... done
[09:31:12.362] result() for MulticoreFuture ...
[09:31:12.362] result() for MulticoreFuture ... done
[09:31:12.362] result() for MulticoreFuture ...
[09:31:12.362] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:12.365] getGlobalsAndPackages() ...
[09:31:12.366] Searching for globals...
[09:31:12.366] 
[09:31:12.366] Searching for globals ... DONE
[09:31:12.366] - globals: [0] <none>
[09:31:12.366] getGlobalsAndPackages() ... DONE
[09:31:12.367] run() for ‘Future’ ...
[09:31:12.367] - state: ‘created’
[09:31:12.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.372] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.373]   - Field: ‘label’
[09:31:12.373]   - Field: ‘local’
[09:31:12.373]   - Field: ‘owner’
[09:31:12.373]   - Field: ‘envir’
[09:31:12.373]   - Field: ‘workers’
[09:31:12.373]   - Field: ‘packages’
[09:31:12.373]   - Field: ‘gc’
[09:31:12.373]   - Field: ‘job’
[09:31:12.373]   - Field: ‘conditions’
[09:31:12.374]   - Field: ‘expr’
[09:31:12.374]   - Field: ‘uuid’
[09:31:12.374]   - Field: ‘seed’
[09:31:12.374]   - Field: ‘version’
[09:31:12.374]   - Field: ‘result’
[09:31:12.374]   - Field: ‘asynchronous’
[09:31:12.374]   - Field: ‘calls’
[09:31:12.374]   - Field: ‘globals’
[09:31:12.374]   - Field: ‘stdout’
[09:31:12.374]   - Field: ‘earlySignal’
[09:31:12.374]   - Field: ‘lazy’
[09:31:12.375]   - Field: ‘state’
[09:31:12.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.375] - Launch lazy future ...
[09:31:12.375] Packages needed by the future expression (n = 0): <none>
[09:31:12.375] Packages needed by future strategies (n = 0): <none>
[09:31:12.376] {
[09:31:12.376]     {
[09:31:12.376]         {
[09:31:12.376]             ...future.startTime <- base::Sys.time()
[09:31:12.376]             {
[09:31:12.376]                 {
[09:31:12.376]                   {
[09:31:12.376]                     {
[09:31:12.376]                       base::local({
[09:31:12.376]                         has_future <- base::requireNamespace("future", 
[09:31:12.376]                           quietly = TRUE)
[09:31:12.376]                         if (has_future) {
[09:31:12.376]                           ns <- base::getNamespace("future")
[09:31:12.376]                           version <- ns[[".package"]][["version"]]
[09:31:12.376]                           if (is.null(version)) 
[09:31:12.376]                             version <- utils::packageVersion("future")
[09:31:12.376]                         }
[09:31:12.376]                         else {
[09:31:12.376]                           version <- NULL
[09:31:12.376]                         }
[09:31:12.376]                         if (!has_future || version < "1.8.0") {
[09:31:12.376]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.376]                             "", base::R.version$version.string), 
[09:31:12.376]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.376]                               "release", "version")], collapse = " "), 
[09:31:12.376]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.376]                             info)
[09:31:12.376]                           info <- base::paste(info, collapse = "; ")
[09:31:12.376]                           if (!has_future) {
[09:31:12.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.376]                               info)
[09:31:12.376]                           }
[09:31:12.376]                           else {
[09:31:12.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.376]                               info, version)
[09:31:12.376]                           }
[09:31:12.376]                           base::stop(msg)
[09:31:12.376]                         }
[09:31:12.376]                       })
[09:31:12.376]                     }
[09:31:12.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.376]                     base::options(mc.cores = 1L)
[09:31:12.376]                   }
[09:31:12.376]                   ...future.strategy.old <- future::plan("list")
[09:31:12.376]                   options(future.plan = NULL)
[09:31:12.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.376]                 }
[09:31:12.376]                 ...future.workdir <- getwd()
[09:31:12.376]             }
[09:31:12.376]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.376]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.376]         }
[09:31:12.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.376]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.376]             base::names(...future.oldOptions))
[09:31:12.376]     }
[09:31:12.376]     if (FALSE) {
[09:31:12.376]     }
[09:31:12.376]     else {
[09:31:12.376]         if (TRUE) {
[09:31:12.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.376]                 open = "w")
[09:31:12.376]         }
[09:31:12.376]         else {
[09:31:12.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.376]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.376]         }
[09:31:12.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.376]             base::sink(type = "output", split = FALSE)
[09:31:12.376]             base::close(...future.stdout)
[09:31:12.376]         }, add = TRUE)
[09:31:12.376]     }
[09:31:12.376]     ...future.frame <- base::sys.nframe()
[09:31:12.376]     ...future.conditions <- base::list()
[09:31:12.376]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.376]     if (FALSE) {
[09:31:12.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.376]     }
[09:31:12.376]     ...future.result <- base::tryCatch({
[09:31:12.376]         base::withCallingHandlers({
[09:31:12.376]             ...future.value <- base::withVisible(base::local({
[09:31:12.376]                 withCallingHandlers({
[09:31:12.376]                   2
[09:31:12.376]                 }, immediateCondition = function(cond) {
[09:31:12.376]                   save_rds <- function (object, pathname, ...) 
[09:31:12.376]                   {
[09:31:12.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.376]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.376]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.376]                         fi_tmp[["mtime"]])
[09:31:12.376]                     }
[09:31:12.376]                     tryCatch({
[09:31:12.376]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.376]                     }, error = function(ex) {
[09:31:12.376]                       msg <- conditionMessage(ex)
[09:31:12.376]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.376]                         fi_tmp[["mtime"]], msg)
[09:31:12.376]                       ex$message <- msg
[09:31:12.376]                       stop(ex)
[09:31:12.376]                     })
[09:31:12.376]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.376]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.376]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.376]                       fi <- file.info(pathname)
[09:31:12.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.376]                         fi[["size"]], fi[["mtime"]])
[09:31:12.376]                       stop(msg)
[09:31:12.376]                     }
[09:31:12.376]                     invisible(pathname)
[09:31:12.376]                   }
[09:31:12.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.376]                     rootPath = tempdir()) 
[09:31:12.376]                   {
[09:31:12.376]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.376]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.376]                       tmpdir = path, fileext = ".rds")
[09:31:12.376]                     save_rds(obj, file)
[09:31:12.376]                   }
[09:31:12.376]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.376]                   {
[09:31:12.376]                     inherits <- base::inherits
[09:31:12.376]                     invokeRestart <- base::invokeRestart
[09:31:12.376]                     is.null <- base::is.null
[09:31:12.376]                     muffled <- FALSE
[09:31:12.376]                     if (inherits(cond, "message")) {
[09:31:12.376]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.376]                       if (muffled) 
[09:31:12.376]                         invokeRestart("muffleMessage")
[09:31:12.376]                     }
[09:31:12.376]                     else if (inherits(cond, "warning")) {
[09:31:12.376]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.376]                       if (muffled) 
[09:31:12.376]                         invokeRestart("muffleWarning")
[09:31:12.376]                     }
[09:31:12.376]                     else if (inherits(cond, "condition")) {
[09:31:12.376]                       if (!is.null(pattern)) {
[09:31:12.376]                         computeRestarts <- base::computeRestarts
[09:31:12.376]                         grepl <- base::grepl
[09:31:12.376]                         restarts <- computeRestarts(cond)
[09:31:12.376]                         for (restart in restarts) {
[09:31:12.376]                           name <- restart$name
[09:31:12.376]                           if (is.null(name)) 
[09:31:12.376]                             next
[09:31:12.376]                           if (!grepl(pattern, name)) 
[09:31:12.376]                             next
[09:31:12.376]                           invokeRestart(restart)
[09:31:12.376]                           muffled <- TRUE
[09:31:12.376]                           break
[09:31:12.376]                         }
[09:31:12.376]                       }
[09:31:12.376]                     }
[09:31:12.376]                     invisible(muffled)
[09:31:12.376]                   }
[09:31:12.376]                   muffleCondition(cond)
[09:31:12.376]                 })
[09:31:12.376]             }))
[09:31:12.376]             future::FutureResult(value = ...future.value$value, 
[09:31:12.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.376]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.376]                     ...future.globalenv.names))
[09:31:12.376]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.376]         }, condition = base::local({
[09:31:12.376]             c <- base::c
[09:31:12.376]             inherits <- base::inherits
[09:31:12.376]             invokeRestart <- base::invokeRestart
[09:31:12.376]             length <- base::length
[09:31:12.376]             list <- base::list
[09:31:12.376]             seq.int <- base::seq.int
[09:31:12.376]             signalCondition <- base::signalCondition
[09:31:12.376]             sys.calls <- base::sys.calls
[09:31:12.376]             `[[` <- base::`[[`
[09:31:12.376]             `+` <- base::`+`
[09:31:12.376]             `<<-` <- base::`<<-`
[09:31:12.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.376]                   3L)]
[09:31:12.376]             }
[09:31:12.376]             function(cond) {
[09:31:12.376]                 is_error <- inherits(cond, "error")
[09:31:12.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.376]                   NULL)
[09:31:12.376]                 if (is_error) {
[09:31:12.376]                   sessionInformation <- function() {
[09:31:12.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.376]                       search = base::search(), system = base::Sys.info())
[09:31:12.376]                   }
[09:31:12.376]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.376]                     cond$call), session = sessionInformation(), 
[09:31:12.376]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.376]                   signalCondition(cond)
[09:31:12.376]                 }
[09:31:12.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.376]                 "immediateCondition"))) {
[09:31:12.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.376]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.376]                   if (TRUE && !signal) {
[09:31:12.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.376]                     {
[09:31:12.376]                       inherits <- base::inherits
[09:31:12.376]                       invokeRestart <- base::invokeRestart
[09:31:12.376]                       is.null <- base::is.null
[09:31:12.376]                       muffled <- FALSE
[09:31:12.376]                       if (inherits(cond, "message")) {
[09:31:12.376]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.376]                         if (muffled) 
[09:31:12.376]                           invokeRestart("muffleMessage")
[09:31:12.376]                       }
[09:31:12.376]                       else if (inherits(cond, "warning")) {
[09:31:12.376]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.376]                         if (muffled) 
[09:31:12.376]                           invokeRestart("muffleWarning")
[09:31:12.376]                       }
[09:31:12.376]                       else if (inherits(cond, "condition")) {
[09:31:12.376]                         if (!is.null(pattern)) {
[09:31:12.376]                           computeRestarts <- base::computeRestarts
[09:31:12.376]                           grepl <- base::grepl
[09:31:12.376]                           restarts <- computeRestarts(cond)
[09:31:12.376]                           for (restart in restarts) {
[09:31:12.376]                             name <- restart$name
[09:31:12.376]                             if (is.null(name)) 
[09:31:12.376]                               next
[09:31:12.376]                             if (!grepl(pattern, name)) 
[09:31:12.376]                               next
[09:31:12.376]                             invokeRestart(restart)
[09:31:12.376]                             muffled <- TRUE
[09:31:12.376]                             break
[09:31:12.376]                           }
[09:31:12.376]                         }
[09:31:12.376]                       }
[09:31:12.376]                       invisible(muffled)
[09:31:12.376]                     }
[09:31:12.376]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.376]                   }
[09:31:12.376]                 }
[09:31:12.376]                 else {
[09:31:12.376]                   if (TRUE) {
[09:31:12.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.376]                     {
[09:31:12.376]                       inherits <- base::inherits
[09:31:12.376]                       invokeRestart <- base::invokeRestart
[09:31:12.376]                       is.null <- base::is.null
[09:31:12.376]                       muffled <- FALSE
[09:31:12.376]                       if (inherits(cond, "message")) {
[09:31:12.376]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.376]                         if (muffled) 
[09:31:12.376]                           invokeRestart("muffleMessage")
[09:31:12.376]                       }
[09:31:12.376]                       else if (inherits(cond, "warning")) {
[09:31:12.376]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.376]                         if (muffled) 
[09:31:12.376]                           invokeRestart("muffleWarning")
[09:31:12.376]                       }
[09:31:12.376]                       else if (inherits(cond, "condition")) {
[09:31:12.376]                         if (!is.null(pattern)) {
[09:31:12.376]                           computeRestarts <- base::computeRestarts
[09:31:12.376]                           grepl <- base::grepl
[09:31:12.376]                           restarts <- computeRestarts(cond)
[09:31:12.376]                           for (restart in restarts) {
[09:31:12.376]                             name <- restart$name
[09:31:12.376]                             if (is.null(name)) 
[09:31:12.376]                               next
[09:31:12.376]                             if (!grepl(pattern, name)) 
[09:31:12.376]                               next
[09:31:12.376]                             invokeRestart(restart)
[09:31:12.376]                             muffled <- TRUE
[09:31:12.376]                             break
[09:31:12.376]                           }
[09:31:12.376]                         }
[09:31:12.376]                       }
[09:31:12.376]                       invisible(muffled)
[09:31:12.376]                     }
[09:31:12.376]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.376]                   }
[09:31:12.376]                 }
[09:31:12.376]             }
[09:31:12.376]         }))
[09:31:12.376]     }, error = function(ex) {
[09:31:12.376]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.376]                 ...future.rng), started = ...future.startTime, 
[09:31:12.376]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.376]             version = "1.8"), class = "FutureResult")
[09:31:12.376]     }, finally = {
[09:31:12.376]         if (!identical(...future.workdir, getwd())) 
[09:31:12.376]             setwd(...future.workdir)
[09:31:12.376]         {
[09:31:12.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.376]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.376]             }
[09:31:12.376]             base::options(...future.oldOptions)
[09:31:12.376]             if (.Platform$OS.type == "windows") {
[09:31:12.376]                 old_names <- names(...future.oldEnvVars)
[09:31:12.376]                 envs <- base::Sys.getenv()
[09:31:12.376]                 names <- names(envs)
[09:31:12.376]                 common <- intersect(names, old_names)
[09:31:12.376]                 added <- setdiff(names, old_names)
[09:31:12.376]                 removed <- setdiff(old_names, names)
[09:31:12.376]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.376]                   envs[common]]
[09:31:12.376]                 NAMES <- toupper(changed)
[09:31:12.376]                 args <- list()
[09:31:12.376]                 for (kk in seq_along(NAMES)) {
[09:31:12.376]                   name <- changed[[kk]]
[09:31:12.376]                   NAME <- NAMES[[kk]]
[09:31:12.376]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.376]                     next
[09:31:12.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.376]                 }
[09:31:12.376]                 NAMES <- toupper(added)
[09:31:12.376]                 for (kk in seq_along(NAMES)) {
[09:31:12.376]                   name <- added[[kk]]
[09:31:12.376]                   NAME <- NAMES[[kk]]
[09:31:12.376]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.376]                     next
[09:31:12.376]                   args[[name]] <- ""
[09:31:12.376]                 }
[09:31:12.376]                 NAMES <- toupper(removed)
[09:31:12.376]                 for (kk in seq_along(NAMES)) {
[09:31:12.376]                   name <- removed[[kk]]
[09:31:12.376]                   NAME <- NAMES[[kk]]
[09:31:12.376]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.376]                     next
[09:31:12.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.376]                 }
[09:31:12.376]                 if (length(args) > 0) 
[09:31:12.376]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.376]             }
[09:31:12.376]             else {
[09:31:12.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.376]             }
[09:31:12.376]             {
[09:31:12.376]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.376]                   0L) {
[09:31:12.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.376]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.376]                   base::options(opts)
[09:31:12.376]                 }
[09:31:12.376]                 {
[09:31:12.376]                   {
[09:31:12.376]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.376]                     NULL
[09:31:12.376]                   }
[09:31:12.376]                   options(future.plan = NULL)
[09:31:12.376]                   if (is.na(NA_character_)) 
[09:31:12.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.376]                     .init = FALSE)
[09:31:12.376]                 }
[09:31:12.376]             }
[09:31:12.376]         }
[09:31:12.376]     })
[09:31:12.376]     if (TRUE) {
[09:31:12.376]         base::sink(type = "output", split = FALSE)
[09:31:12.376]         if (TRUE) {
[09:31:12.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.376]         }
[09:31:12.376]         else {
[09:31:12.376]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.376]         }
[09:31:12.376]         base::close(...future.stdout)
[09:31:12.376]         ...future.stdout <- NULL
[09:31:12.376]     }
[09:31:12.376]     ...future.result$conditions <- ...future.conditions
[09:31:12.376]     ...future.result$finished <- base::Sys.time()
[09:31:12.376]     ...future.result
[09:31:12.376] }
[09:31:12.378] requestCore(): workers = 2
[09:31:12.379] MulticoreFuture started
[09:31:12.380] - Launch lazy future ... done
[09:31:12.380] run() for ‘MulticoreFuture’ ... done
[09:31:12.381] getGlobalsAndPackages() ...
[09:31:12.381] plan(): Setting new future strategy stack:
[09:31:12.381] Searching for globals...
[09:31:12.382] 
[09:31:12.381] List of future strategies:
[09:31:12.381] 1. sequential:
[09:31:12.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.381]    - tweaked: FALSE
[09:31:12.381]    - call: NULL
[09:31:12.382] Searching for globals ... DONE
[09:31:12.382] plan(): nbrOfWorkers() = 1
[09:31:12.382] - globals: [0] <none>
[09:31:12.382] getGlobalsAndPackages() ... DONE
[09:31:12.383] run() for ‘Future’ ...
[09:31:12.383] - state: ‘created’
[09:31:12.383] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.384] plan(): Setting new future strategy stack:
[09:31:12.384] List of future strategies:
[09:31:12.384] 1. multicore:
[09:31:12.384]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.384]    - tweaked: FALSE
[09:31:12.384]    - call: plan(strategy)
[09:31:12.388] plan(): nbrOfWorkers() = 2
[09:31:12.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.389]   - Field: ‘label’
[09:31:12.389]   - Field: ‘local’
[09:31:12.390]   - Field: ‘owner’
[09:31:12.390]   - Field: ‘envir’
[09:31:12.390]   - Field: ‘workers’
[09:31:12.390]   - Field: ‘packages’
[09:31:12.390]   - Field: ‘gc’
[09:31:12.390]   - Field: ‘job’
[09:31:12.391]   - Field: ‘conditions’
[09:31:12.391]   - Field: ‘expr’
[09:31:12.391]   - Field: ‘uuid’
[09:31:12.391]   - Field: ‘seed’
[09:31:12.391]   - Field: ‘version’
[09:31:12.391]   - Field: ‘result’
[09:31:12.392]   - Field: ‘asynchronous’
[09:31:12.392]   - Field: ‘calls’
[09:31:12.392]   - Field: ‘globals’
[09:31:12.392]   - Field: ‘stdout’
[09:31:12.392]   - Field: ‘earlySignal’
[09:31:12.392]   - Field: ‘lazy’
[09:31:12.392]   - Field: ‘state’
[09:31:12.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.393] - Launch lazy future ...
[09:31:12.393] Packages needed by the future expression (n = 0): <none>
[09:31:12.393] Packages needed by future strategies (n = 0): <none>
[09:31:12.394] {
[09:31:12.394]     {
[09:31:12.394]         {
[09:31:12.394]             ...future.startTime <- base::Sys.time()
[09:31:12.394]             {
[09:31:12.394]                 {
[09:31:12.394]                   {
[09:31:12.394]                     {
[09:31:12.394]                       base::local({
[09:31:12.394]                         has_future <- base::requireNamespace("future", 
[09:31:12.394]                           quietly = TRUE)
[09:31:12.394]                         if (has_future) {
[09:31:12.394]                           ns <- base::getNamespace("future")
[09:31:12.394]                           version <- ns[[".package"]][["version"]]
[09:31:12.394]                           if (is.null(version)) 
[09:31:12.394]                             version <- utils::packageVersion("future")
[09:31:12.394]                         }
[09:31:12.394]                         else {
[09:31:12.394]                           version <- NULL
[09:31:12.394]                         }
[09:31:12.394]                         if (!has_future || version < "1.8.0") {
[09:31:12.394]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.394]                             "", base::R.version$version.string), 
[09:31:12.394]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.394]                               "release", "version")], collapse = " "), 
[09:31:12.394]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.394]                             info)
[09:31:12.394]                           info <- base::paste(info, collapse = "; ")
[09:31:12.394]                           if (!has_future) {
[09:31:12.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.394]                               info)
[09:31:12.394]                           }
[09:31:12.394]                           else {
[09:31:12.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.394]                               info, version)
[09:31:12.394]                           }
[09:31:12.394]                           base::stop(msg)
[09:31:12.394]                         }
[09:31:12.394]                       })
[09:31:12.394]                     }
[09:31:12.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.394]                     base::options(mc.cores = 1L)
[09:31:12.394]                   }
[09:31:12.394]                   ...future.strategy.old <- future::plan("list")
[09:31:12.394]                   options(future.plan = NULL)
[09:31:12.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.394]                 }
[09:31:12.394]                 ...future.workdir <- getwd()
[09:31:12.394]             }
[09:31:12.394]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.394]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.394]         }
[09:31:12.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.394]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.394]             base::names(...future.oldOptions))
[09:31:12.394]     }
[09:31:12.394]     if (FALSE) {
[09:31:12.394]     }
[09:31:12.394]     else {
[09:31:12.394]         if (TRUE) {
[09:31:12.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.394]                 open = "w")
[09:31:12.394]         }
[09:31:12.394]         else {
[09:31:12.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.394]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.394]         }
[09:31:12.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.394]             base::sink(type = "output", split = FALSE)
[09:31:12.394]             base::close(...future.stdout)
[09:31:12.394]         }, add = TRUE)
[09:31:12.394]     }
[09:31:12.394]     ...future.frame <- base::sys.nframe()
[09:31:12.394]     ...future.conditions <- base::list()
[09:31:12.394]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.394]     if (FALSE) {
[09:31:12.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.394]     }
[09:31:12.394]     ...future.result <- base::tryCatch({
[09:31:12.394]         base::withCallingHandlers({
[09:31:12.394]             ...future.value <- base::withVisible(base::local({
[09:31:12.394]                 withCallingHandlers({
[09:31:12.394]                   NULL
[09:31:12.394]                 }, immediateCondition = function(cond) {
[09:31:12.394]                   save_rds <- function (object, pathname, ...) 
[09:31:12.394]                   {
[09:31:12.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.394]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.394]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.394]                         fi_tmp[["mtime"]])
[09:31:12.394]                     }
[09:31:12.394]                     tryCatch({
[09:31:12.394]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.394]                     }, error = function(ex) {
[09:31:12.394]                       msg <- conditionMessage(ex)
[09:31:12.394]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.394]                         fi_tmp[["mtime"]], msg)
[09:31:12.394]                       ex$message <- msg
[09:31:12.394]                       stop(ex)
[09:31:12.394]                     })
[09:31:12.394]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.394]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.394]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.394]                       fi <- file.info(pathname)
[09:31:12.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.394]                         fi[["size"]], fi[["mtime"]])
[09:31:12.394]                       stop(msg)
[09:31:12.394]                     }
[09:31:12.394]                     invisible(pathname)
[09:31:12.394]                   }
[09:31:12.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.394]                     rootPath = tempdir()) 
[09:31:12.394]                   {
[09:31:12.394]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.394]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.394]                       tmpdir = path, fileext = ".rds")
[09:31:12.394]                     save_rds(obj, file)
[09:31:12.394]                   }
[09:31:12.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.394]                   {
[09:31:12.394]                     inherits <- base::inherits
[09:31:12.394]                     invokeRestart <- base::invokeRestart
[09:31:12.394]                     is.null <- base::is.null
[09:31:12.394]                     muffled <- FALSE
[09:31:12.394]                     if (inherits(cond, "message")) {
[09:31:12.394]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.394]                       if (muffled) 
[09:31:12.394]                         invokeRestart("muffleMessage")
[09:31:12.394]                     }
[09:31:12.394]                     else if (inherits(cond, "warning")) {
[09:31:12.394]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.394]                       if (muffled) 
[09:31:12.394]                         invokeRestart("muffleWarning")
[09:31:12.394]                     }
[09:31:12.394]                     else if (inherits(cond, "condition")) {
[09:31:12.394]                       if (!is.null(pattern)) {
[09:31:12.394]                         computeRestarts <- base::computeRestarts
[09:31:12.394]                         grepl <- base::grepl
[09:31:12.394]                         restarts <- computeRestarts(cond)
[09:31:12.394]                         for (restart in restarts) {
[09:31:12.394]                           name <- restart$name
[09:31:12.394]                           if (is.null(name)) 
[09:31:12.394]                             next
[09:31:12.394]                           if (!grepl(pattern, name)) 
[09:31:12.394]                             next
[09:31:12.394]                           invokeRestart(restart)
[09:31:12.394]                           muffled <- TRUE
[09:31:12.394]                           break
[09:31:12.394]                         }
[09:31:12.394]                       }
[09:31:12.394]                     }
[09:31:12.394]                     invisible(muffled)
[09:31:12.394]                   }
[09:31:12.394]                   muffleCondition(cond)
[09:31:12.394]                 })
[09:31:12.394]             }))
[09:31:12.394]             future::FutureResult(value = ...future.value$value, 
[09:31:12.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.394]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.394]                     ...future.globalenv.names))
[09:31:12.394]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.394]         }, condition = base::local({
[09:31:12.394]             c <- base::c
[09:31:12.394]             inherits <- base::inherits
[09:31:12.394]             invokeRestart <- base::invokeRestart
[09:31:12.394]             length <- base::length
[09:31:12.394]             list <- base::list
[09:31:12.394]             seq.int <- base::seq.int
[09:31:12.394]             signalCondition <- base::signalCondition
[09:31:12.394]             sys.calls <- base::sys.calls
[09:31:12.394]             `[[` <- base::`[[`
[09:31:12.394]             `+` <- base::`+`
[09:31:12.394]             `<<-` <- base::`<<-`
[09:31:12.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.394]                   3L)]
[09:31:12.394]             }
[09:31:12.394]             function(cond) {
[09:31:12.394]                 is_error <- inherits(cond, "error")
[09:31:12.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.394]                   NULL)
[09:31:12.394]                 if (is_error) {
[09:31:12.394]                   sessionInformation <- function() {
[09:31:12.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.394]                       search = base::search(), system = base::Sys.info())
[09:31:12.394]                   }
[09:31:12.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.394]                     cond$call), session = sessionInformation(), 
[09:31:12.394]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.394]                   signalCondition(cond)
[09:31:12.394]                 }
[09:31:12.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.394]                 "immediateCondition"))) {
[09:31:12.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.394]                   if (TRUE && !signal) {
[09:31:12.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.394]                     {
[09:31:12.394]                       inherits <- base::inherits
[09:31:12.394]                       invokeRestart <- base::invokeRestart
[09:31:12.394]                       is.null <- base::is.null
[09:31:12.394]                       muffled <- FALSE
[09:31:12.394]                       if (inherits(cond, "message")) {
[09:31:12.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.394]                         if (muffled) 
[09:31:12.394]                           invokeRestart("muffleMessage")
[09:31:12.394]                       }
[09:31:12.394]                       else if (inherits(cond, "warning")) {
[09:31:12.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.394]                         if (muffled) 
[09:31:12.394]                           invokeRestart("muffleWarning")
[09:31:12.394]                       }
[09:31:12.394]                       else if (inherits(cond, "condition")) {
[09:31:12.394]                         if (!is.null(pattern)) {
[09:31:12.394]                           computeRestarts <- base::computeRestarts
[09:31:12.394]                           grepl <- base::grepl
[09:31:12.394]                           restarts <- computeRestarts(cond)
[09:31:12.394]                           for (restart in restarts) {
[09:31:12.394]                             name <- restart$name
[09:31:12.394]                             if (is.null(name)) 
[09:31:12.394]                               next
[09:31:12.394]                             if (!grepl(pattern, name)) 
[09:31:12.394]                               next
[09:31:12.394]                             invokeRestart(restart)
[09:31:12.394]                             muffled <- TRUE
[09:31:12.394]                             break
[09:31:12.394]                           }
[09:31:12.394]                         }
[09:31:12.394]                       }
[09:31:12.394]                       invisible(muffled)
[09:31:12.394]                     }
[09:31:12.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.394]                   }
[09:31:12.394]                 }
[09:31:12.394]                 else {
[09:31:12.394]                   if (TRUE) {
[09:31:12.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.394]                     {
[09:31:12.394]                       inherits <- base::inherits
[09:31:12.394]                       invokeRestart <- base::invokeRestart
[09:31:12.394]                       is.null <- base::is.null
[09:31:12.394]                       muffled <- FALSE
[09:31:12.394]                       if (inherits(cond, "message")) {
[09:31:12.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.394]                         if (muffled) 
[09:31:12.394]                           invokeRestart("muffleMessage")
[09:31:12.394]                       }
[09:31:12.394]                       else if (inherits(cond, "warning")) {
[09:31:12.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.394]                         if (muffled) 
[09:31:12.394]                           invokeRestart("muffleWarning")
[09:31:12.394]                       }
[09:31:12.394]                       else if (inherits(cond, "condition")) {
[09:31:12.394]                         if (!is.null(pattern)) {
[09:31:12.394]                           computeRestarts <- base::computeRestarts
[09:31:12.394]                           grepl <- base::grepl
[09:31:12.394]                           restarts <- computeRestarts(cond)
[09:31:12.394]                           for (restart in restarts) {
[09:31:12.394]                             name <- restart$name
[09:31:12.394]                             if (is.null(name)) 
[09:31:12.394]                               next
[09:31:12.394]                             if (!grepl(pattern, name)) 
[09:31:12.394]                               next
[09:31:12.394]                             invokeRestart(restart)
[09:31:12.394]                             muffled <- TRUE
[09:31:12.394]                             break
[09:31:12.394]                           }
[09:31:12.394]                         }
[09:31:12.394]                       }
[09:31:12.394]                       invisible(muffled)
[09:31:12.394]                     }
[09:31:12.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.394]                   }
[09:31:12.394]                 }
[09:31:12.394]             }
[09:31:12.394]         }))
[09:31:12.394]     }, error = function(ex) {
[09:31:12.394]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.394]                 ...future.rng), started = ...future.startTime, 
[09:31:12.394]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.394]             version = "1.8"), class = "FutureResult")
[09:31:12.394]     }, finally = {
[09:31:12.394]         if (!identical(...future.workdir, getwd())) 
[09:31:12.394]             setwd(...future.workdir)
[09:31:12.394]         {
[09:31:12.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.394]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.394]             }
[09:31:12.394]             base::options(...future.oldOptions)
[09:31:12.394]             if (.Platform$OS.type == "windows") {
[09:31:12.394]                 old_names <- names(...future.oldEnvVars)
[09:31:12.394]                 envs <- base::Sys.getenv()
[09:31:12.394]                 names <- names(envs)
[09:31:12.394]                 common <- intersect(names, old_names)
[09:31:12.394]                 added <- setdiff(names, old_names)
[09:31:12.394]                 removed <- setdiff(old_names, names)
[09:31:12.394]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.394]                   envs[common]]
[09:31:12.394]                 NAMES <- toupper(changed)
[09:31:12.394]                 args <- list()
[09:31:12.394]                 for (kk in seq_along(NAMES)) {
[09:31:12.394]                   name <- changed[[kk]]
[09:31:12.394]                   NAME <- NAMES[[kk]]
[09:31:12.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.394]                     next
[09:31:12.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.394]                 }
[09:31:12.394]                 NAMES <- toupper(added)
[09:31:12.394]                 for (kk in seq_along(NAMES)) {
[09:31:12.394]                   name <- added[[kk]]
[09:31:12.394]                   NAME <- NAMES[[kk]]
[09:31:12.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.394]                     next
[09:31:12.394]                   args[[name]] <- ""
[09:31:12.394]                 }
[09:31:12.394]                 NAMES <- toupper(removed)
[09:31:12.394]                 for (kk in seq_along(NAMES)) {
[09:31:12.394]                   name <- removed[[kk]]
[09:31:12.394]                   NAME <- NAMES[[kk]]
[09:31:12.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.394]                     next
[09:31:12.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.394]                 }
[09:31:12.394]                 if (length(args) > 0) 
[09:31:12.394]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.394]             }
[09:31:12.394]             else {
[09:31:12.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.394]             }
[09:31:12.394]             {
[09:31:12.394]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.394]                   0L) {
[09:31:12.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.394]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.394]                   base::options(opts)
[09:31:12.394]                 }
[09:31:12.394]                 {
[09:31:12.394]                   {
[09:31:12.394]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.394]                     NULL
[09:31:12.394]                   }
[09:31:12.394]                   options(future.plan = NULL)
[09:31:12.394]                   if (is.na(NA_character_)) 
[09:31:12.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.394]                     .init = FALSE)
[09:31:12.394]                 }
[09:31:12.394]             }
[09:31:12.394]         }
[09:31:12.394]     })
[09:31:12.394]     if (TRUE) {
[09:31:12.394]         base::sink(type = "output", split = FALSE)
[09:31:12.394]         if (TRUE) {
[09:31:12.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.394]         }
[09:31:12.394]         else {
[09:31:12.394]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.394]         }
[09:31:12.394]         base::close(...future.stdout)
[09:31:12.394]         ...future.stdout <- NULL
[09:31:12.394]     }
[09:31:12.394]     ...future.result$conditions <- ...future.conditions
[09:31:12.394]     ...future.result$finished <- base::Sys.time()
[09:31:12.394]     ...future.result
[09:31:12.394] }
[09:31:12.397] requestCore(): workers = 2
[09:31:12.399] MulticoreFuture started
[09:31:12.400] - Launch lazy future ... done
[09:31:12.400] run() for ‘MulticoreFuture’ ... done
List of 6
[09:31:12.401] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[09:31:12.401] List of future strategies:
[09:31:12.401] 1. sequential:
[09:31:12.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.401]    - tweaked: FALSE
[09:31:12.401]    - call: NULL
[09:31:12.402] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb4029c8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8a21088> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[09:31:12.404] plan(): Setting new future strategy stack:
 $ a: num 1
[09:31:12.404] List of future strategies:
[09:31:12.404] 1. multicore:
[09:31:12.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.404]    - tweaked: FALSE
[09:31:12.404]    - call: plan(strategy)
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb4029c8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8a21088> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:12.410] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:12.413] resolve() on list ...
[09:31:12.413]  recursive: 0
[09:31:12.413]  length: 6
[09:31:12.413]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:12.413] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.414] - nx: 6
[09:31:12.414] - relay: TRUE
[09:31:12.414] - stdout: TRUE
[09:31:12.414] - signal: TRUE
[09:31:12.414] - resignal: FALSE
[09:31:12.414] - force: TRUE
[09:31:12.414] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.414] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.415]  - until=2
[09:31:12.415]  - relaying element #2
[09:31:12.415] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.415] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.415] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.415]  length: 5 (resolved future 1)
[09:31:12.416] Future #2
[09:31:12.416] result() for MulticoreFuture ...
[09:31:12.417] result() for MulticoreFuture ...
[09:31:12.417] result() for MulticoreFuture ... done
[09:31:12.417] result() for MulticoreFuture ... done
[09:31:12.417] result() for MulticoreFuture ...
[09:31:12.417] result() for MulticoreFuture ... done
[09:31:12.417] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:12.418] - nx: 6
[09:31:12.418] - relay: TRUE
[09:31:12.418] - stdout: TRUE
[09:31:12.418] - signal: TRUE
[09:31:12.418] - resignal: FALSE
[09:31:12.418] - force: TRUE
[09:31:12.418] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.418] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.419]  - until=2
[09:31:12.419]  - relaying element #2
[09:31:12.419] result() for MulticoreFuture ...
[09:31:12.419] result() for MulticoreFuture ... done
[09:31:12.419] result() for MulticoreFuture ...
[09:31:12.419] result() for MulticoreFuture ... done
[09:31:12.419] result() for MulticoreFuture ...
[09:31:12.419] result() for MulticoreFuture ... done
[09:31:12.420] result() for MulticoreFuture ...
[09:31:12.420] result() for MulticoreFuture ... done
[09:31:12.420] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.420] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.420] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:12.420]  length: 4 (resolved future 2)
[09:31:12.421] Future #3
[09:31:12.421] result() for MulticoreFuture ...
[09:31:12.421] result() for MulticoreFuture ...
[09:31:12.422] result() for MulticoreFuture ... done
[09:31:12.422] result() for MulticoreFuture ... done
[09:31:12.422] result() for MulticoreFuture ...
[09:31:12.422] result() for MulticoreFuture ... done
[09:31:12.422] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:12.423] - nx: 6
[09:31:12.423] - relay: TRUE
[09:31:12.423] - stdout: TRUE
[09:31:12.426] - signal: TRUE
[09:31:12.426] - resignal: FALSE
[09:31:12.426] - force: TRUE
[09:31:12.426] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.426] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.427]  - until=3
[09:31:12.427]  - relaying element #3
[09:31:12.427] result() for MulticoreFuture ...
[09:31:12.427] result() for MulticoreFuture ... done
[09:31:12.427] result() for MulticoreFuture ...
[09:31:12.427] result() for MulticoreFuture ... done
[09:31:12.428] result() for MulticoreFuture ...
[09:31:12.428] result() for MulticoreFuture ... done
[09:31:12.428] result() for MulticoreFuture ...
[09:31:12.428] result() for MulticoreFuture ... done
[09:31:12.428] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.428] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.428] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:12.429]  length: 3 (resolved future 3)
[09:31:12.429] signalConditionsASAP(NULL, pos=4) ...
[09:31:12.429] - nx: 6
[09:31:12.429] - relay: TRUE
[09:31:12.429] - stdout: TRUE
[09:31:12.429] - signal: TRUE
[09:31:12.429] - resignal: FALSE
[09:31:12.429] - force: TRUE
[09:31:12.429] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.430] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.430]  - until=5
[09:31:12.430]  - relaying element #5
[09:31:12.430] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.430] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.430] signalConditionsASAP(NULL, pos=4) ... done
[09:31:12.430]  length: 2 (resolved future 4)
[09:31:12.430] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.430] - nx: 6
[09:31:12.431] - relay: TRUE
[09:31:12.431] - stdout: TRUE
[09:31:12.431] - signal: TRUE
[09:31:12.431] - resignal: FALSE
[09:31:12.431] - force: TRUE
[09:31:12.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.431] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.431]  - until=6
[09:31:12.431]  - relaying element #6
[09:31:12.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.432] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.432] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.432]  length: 1 (resolved future 5)
[09:31:12.432] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.432] - nx: 6
[09:31:12.432] - relay: TRUE
[09:31:12.432] - stdout: TRUE
[09:31:12.432] - signal: TRUE
[09:31:12.432] - resignal: FALSE
[09:31:12.432] - force: TRUE
[09:31:12.433] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.433] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.433]  - until=6
[09:31:12.433] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.433] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.433] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.433]  length: 0 (resolved future 6)
[09:31:12.433] Relaying remaining futures
[09:31:12.433] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.434] - nx: 6
[09:31:12.434] - relay: TRUE
[09:31:12.434] - stdout: TRUE
[09:31:12.434] - signal: TRUE
[09:31:12.434] - resignal: FALSE
[09:31:12.434] - force: TRUE
[09:31:12.434] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.434] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:12.434] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.434] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.435] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.435] resolve() on list ... DONE
[09:31:12.435] result() for MulticoreFuture ...
[09:31:12.435] result() for MulticoreFuture ... done
[09:31:12.435] result() for MulticoreFuture ...
[09:31:12.435] result() for MulticoreFuture ... done
[09:31:12.435] result() for MulticoreFuture ...
[09:31:12.435] result() for MulticoreFuture ... done
[09:31:12.435] result() for MulticoreFuture ...
[09:31:12.435] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:12.439] getGlobalsAndPackages() ...
[09:31:12.439] Searching for globals...
[09:31:12.439] 
[09:31:12.440] Searching for globals ... DONE
[09:31:12.440] - globals: [0] <none>
[09:31:12.440] getGlobalsAndPackages() ... DONE
[09:31:12.440] run() for ‘Future’ ...
[09:31:12.440] - state: ‘created’
[09:31:12.440] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.444] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.444]   - Field: ‘label’
[09:31:12.444]   - Field: ‘local’
[09:31:12.444]   - Field: ‘owner’
[09:31:12.444]   - Field: ‘envir’
[09:31:12.445]   - Field: ‘workers’
[09:31:12.445]   - Field: ‘packages’
[09:31:12.445]   - Field: ‘gc’
[09:31:12.445]   - Field: ‘job’
[09:31:12.445]   - Field: ‘conditions’
[09:31:12.445]   - Field: ‘expr’
[09:31:12.445]   - Field: ‘uuid’
[09:31:12.445]   - Field: ‘seed’
[09:31:12.445]   - Field: ‘version’
[09:31:12.445]   - Field: ‘result’
[09:31:12.445]   - Field: ‘asynchronous’
[09:31:12.446]   - Field: ‘calls’
[09:31:12.446]   - Field: ‘globals’
[09:31:12.446]   - Field: ‘stdout’
[09:31:12.446]   - Field: ‘earlySignal’
[09:31:12.446]   - Field: ‘lazy’
[09:31:12.446]   - Field: ‘state’
[09:31:12.446] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.446] - Launch lazy future ...
[09:31:12.446] Packages needed by the future expression (n = 0): <none>
[09:31:12.447] Packages needed by future strategies (n = 0): <none>
[09:31:12.447] {
[09:31:12.447]     {
[09:31:12.447]         {
[09:31:12.447]             ...future.startTime <- base::Sys.time()
[09:31:12.447]             {
[09:31:12.447]                 {
[09:31:12.447]                   {
[09:31:12.447]                     {
[09:31:12.447]                       base::local({
[09:31:12.447]                         has_future <- base::requireNamespace("future", 
[09:31:12.447]                           quietly = TRUE)
[09:31:12.447]                         if (has_future) {
[09:31:12.447]                           ns <- base::getNamespace("future")
[09:31:12.447]                           version <- ns[[".package"]][["version"]]
[09:31:12.447]                           if (is.null(version)) 
[09:31:12.447]                             version <- utils::packageVersion("future")
[09:31:12.447]                         }
[09:31:12.447]                         else {
[09:31:12.447]                           version <- NULL
[09:31:12.447]                         }
[09:31:12.447]                         if (!has_future || version < "1.8.0") {
[09:31:12.447]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.447]                             "", base::R.version$version.string), 
[09:31:12.447]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.447]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.447]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.447]                               "release", "version")], collapse = " "), 
[09:31:12.447]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.447]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.447]                             info)
[09:31:12.447]                           info <- base::paste(info, collapse = "; ")
[09:31:12.447]                           if (!has_future) {
[09:31:12.447]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.447]                               info)
[09:31:12.447]                           }
[09:31:12.447]                           else {
[09:31:12.447]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.447]                               info, version)
[09:31:12.447]                           }
[09:31:12.447]                           base::stop(msg)
[09:31:12.447]                         }
[09:31:12.447]                       })
[09:31:12.447]                     }
[09:31:12.447]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.447]                     base::options(mc.cores = 1L)
[09:31:12.447]                   }
[09:31:12.447]                   ...future.strategy.old <- future::plan("list")
[09:31:12.447]                   options(future.plan = NULL)
[09:31:12.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.447]                 }
[09:31:12.447]                 ...future.workdir <- getwd()
[09:31:12.447]             }
[09:31:12.447]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.447]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.447]         }
[09:31:12.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.447]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.447]             base::names(...future.oldOptions))
[09:31:12.447]     }
[09:31:12.447]     if (FALSE) {
[09:31:12.447]     }
[09:31:12.447]     else {
[09:31:12.447]         if (TRUE) {
[09:31:12.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.447]                 open = "w")
[09:31:12.447]         }
[09:31:12.447]         else {
[09:31:12.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.447]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.447]         }
[09:31:12.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.447]             base::sink(type = "output", split = FALSE)
[09:31:12.447]             base::close(...future.stdout)
[09:31:12.447]         }, add = TRUE)
[09:31:12.447]     }
[09:31:12.447]     ...future.frame <- base::sys.nframe()
[09:31:12.447]     ...future.conditions <- base::list()
[09:31:12.447]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.447]     if (FALSE) {
[09:31:12.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.447]     }
[09:31:12.447]     ...future.result <- base::tryCatch({
[09:31:12.447]         base::withCallingHandlers({
[09:31:12.447]             ...future.value <- base::withVisible(base::local({
[09:31:12.447]                 withCallingHandlers({
[09:31:12.447]                   2
[09:31:12.447]                 }, immediateCondition = function(cond) {
[09:31:12.447]                   save_rds <- function (object, pathname, ...) 
[09:31:12.447]                   {
[09:31:12.447]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.447]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.447]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.447]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.447]                         fi_tmp[["mtime"]])
[09:31:12.447]                     }
[09:31:12.447]                     tryCatch({
[09:31:12.447]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.447]                     }, error = function(ex) {
[09:31:12.447]                       msg <- conditionMessage(ex)
[09:31:12.447]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.447]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.447]                         fi_tmp[["mtime"]], msg)
[09:31:12.447]                       ex$message <- msg
[09:31:12.447]                       stop(ex)
[09:31:12.447]                     })
[09:31:12.447]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.447]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.447]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.447]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.447]                       fi <- file.info(pathname)
[09:31:12.447]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.447]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.447]                         fi[["size"]], fi[["mtime"]])
[09:31:12.447]                       stop(msg)
[09:31:12.447]                     }
[09:31:12.447]                     invisible(pathname)
[09:31:12.447]                   }
[09:31:12.447]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.447]                     rootPath = tempdir()) 
[09:31:12.447]                   {
[09:31:12.447]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.447]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.447]                       tmpdir = path, fileext = ".rds")
[09:31:12.447]                     save_rds(obj, file)
[09:31:12.447]                   }
[09:31:12.447]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.447]                   {
[09:31:12.447]                     inherits <- base::inherits
[09:31:12.447]                     invokeRestart <- base::invokeRestart
[09:31:12.447]                     is.null <- base::is.null
[09:31:12.447]                     muffled <- FALSE
[09:31:12.447]                     if (inherits(cond, "message")) {
[09:31:12.447]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.447]                       if (muffled) 
[09:31:12.447]                         invokeRestart("muffleMessage")
[09:31:12.447]                     }
[09:31:12.447]                     else if (inherits(cond, "warning")) {
[09:31:12.447]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.447]                       if (muffled) 
[09:31:12.447]                         invokeRestart("muffleWarning")
[09:31:12.447]                     }
[09:31:12.447]                     else if (inherits(cond, "condition")) {
[09:31:12.447]                       if (!is.null(pattern)) {
[09:31:12.447]                         computeRestarts <- base::computeRestarts
[09:31:12.447]                         grepl <- base::grepl
[09:31:12.447]                         restarts <- computeRestarts(cond)
[09:31:12.447]                         for (restart in restarts) {
[09:31:12.447]                           name <- restart$name
[09:31:12.447]                           if (is.null(name)) 
[09:31:12.447]                             next
[09:31:12.447]                           if (!grepl(pattern, name)) 
[09:31:12.447]                             next
[09:31:12.447]                           invokeRestart(restart)
[09:31:12.447]                           muffled <- TRUE
[09:31:12.447]                           break
[09:31:12.447]                         }
[09:31:12.447]                       }
[09:31:12.447]                     }
[09:31:12.447]                     invisible(muffled)
[09:31:12.447]                   }
[09:31:12.447]                   muffleCondition(cond)
[09:31:12.447]                 })
[09:31:12.447]             }))
[09:31:12.447]             future::FutureResult(value = ...future.value$value, 
[09:31:12.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.447]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.447]                     ...future.globalenv.names))
[09:31:12.447]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.447]         }, condition = base::local({
[09:31:12.447]             c <- base::c
[09:31:12.447]             inherits <- base::inherits
[09:31:12.447]             invokeRestart <- base::invokeRestart
[09:31:12.447]             length <- base::length
[09:31:12.447]             list <- base::list
[09:31:12.447]             seq.int <- base::seq.int
[09:31:12.447]             signalCondition <- base::signalCondition
[09:31:12.447]             sys.calls <- base::sys.calls
[09:31:12.447]             `[[` <- base::`[[`
[09:31:12.447]             `+` <- base::`+`
[09:31:12.447]             `<<-` <- base::`<<-`
[09:31:12.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.447]                   3L)]
[09:31:12.447]             }
[09:31:12.447]             function(cond) {
[09:31:12.447]                 is_error <- inherits(cond, "error")
[09:31:12.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.447]                   NULL)
[09:31:12.447]                 if (is_error) {
[09:31:12.447]                   sessionInformation <- function() {
[09:31:12.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.447]                       search = base::search(), system = base::Sys.info())
[09:31:12.447]                   }
[09:31:12.447]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.447]                     cond$call), session = sessionInformation(), 
[09:31:12.447]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.447]                   signalCondition(cond)
[09:31:12.447]                 }
[09:31:12.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.447]                 "immediateCondition"))) {
[09:31:12.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.447]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.447]                   if (TRUE && !signal) {
[09:31:12.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.447]                     {
[09:31:12.447]                       inherits <- base::inherits
[09:31:12.447]                       invokeRestart <- base::invokeRestart
[09:31:12.447]                       is.null <- base::is.null
[09:31:12.447]                       muffled <- FALSE
[09:31:12.447]                       if (inherits(cond, "message")) {
[09:31:12.447]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.447]                         if (muffled) 
[09:31:12.447]                           invokeRestart("muffleMessage")
[09:31:12.447]                       }
[09:31:12.447]                       else if (inherits(cond, "warning")) {
[09:31:12.447]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.447]                         if (muffled) 
[09:31:12.447]                           invokeRestart("muffleWarning")
[09:31:12.447]                       }
[09:31:12.447]                       else if (inherits(cond, "condition")) {
[09:31:12.447]                         if (!is.null(pattern)) {
[09:31:12.447]                           computeRestarts <- base::computeRestarts
[09:31:12.447]                           grepl <- base::grepl
[09:31:12.447]                           restarts <- computeRestarts(cond)
[09:31:12.447]                           for (restart in restarts) {
[09:31:12.447]                             name <- restart$name
[09:31:12.447]                             if (is.null(name)) 
[09:31:12.447]                               next
[09:31:12.447]                             if (!grepl(pattern, name)) 
[09:31:12.447]                               next
[09:31:12.447]                             invokeRestart(restart)
[09:31:12.447]                             muffled <- TRUE
[09:31:12.447]                             break
[09:31:12.447]                           }
[09:31:12.447]                         }
[09:31:12.447]                       }
[09:31:12.447]                       invisible(muffled)
[09:31:12.447]                     }
[09:31:12.447]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.447]                   }
[09:31:12.447]                 }
[09:31:12.447]                 else {
[09:31:12.447]                   if (TRUE) {
[09:31:12.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.447]                     {
[09:31:12.447]                       inherits <- base::inherits
[09:31:12.447]                       invokeRestart <- base::invokeRestart
[09:31:12.447]                       is.null <- base::is.null
[09:31:12.447]                       muffled <- FALSE
[09:31:12.447]                       if (inherits(cond, "message")) {
[09:31:12.447]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.447]                         if (muffled) 
[09:31:12.447]                           invokeRestart("muffleMessage")
[09:31:12.447]                       }
[09:31:12.447]                       else if (inherits(cond, "warning")) {
[09:31:12.447]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.447]                         if (muffled) 
[09:31:12.447]                           invokeRestart("muffleWarning")
[09:31:12.447]                       }
[09:31:12.447]                       else if (inherits(cond, "condition")) {
[09:31:12.447]                         if (!is.null(pattern)) {
[09:31:12.447]                           computeRestarts <- base::computeRestarts
[09:31:12.447]                           grepl <- base::grepl
[09:31:12.447]                           restarts <- computeRestarts(cond)
[09:31:12.447]                           for (restart in restarts) {
[09:31:12.447]                             name <- restart$name
[09:31:12.447]                             if (is.null(name)) 
[09:31:12.447]                               next
[09:31:12.447]                             if (!grepl(pattern, name)) 
[09:31:12.447]                               next
[09:31:12.447]                             invokeRestart(restart)
[09:31:12.447]                             muffled <- TRUE
[09:31:12.447]                             break
[09:31:12.447]                           }
[09:31:12.447]                         }
[09:31:12.447]                       }
[09:31:12.447]                       invisible(muffled)
[09:31:12.447]                     }
[09:31:12.447]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.447]                   }
[09:31:12.447]                 }
[09:31:12.447]             }
[09:31:12.447]         }))
[09:31:12.447]     }, error = function(ex) {
[09:31:12.447]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.447]                 ...future.rng), started = ...future.startTime, 
[09:31:12.447]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.447]             version = "1.8"), class = "FutureResult")
[09:31:12.447]     }, finally = {
[09:31:12.447]         if (!identical(...future.workdir, getwd())) 
[09:31:12.447]             setwd(...future.workdir)
[09:31:12.447]         {
[09:31:12.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.447]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.447]             }
[09:31:12.447]             base::options(...future.oldOptions)
[09:31:12.447]             if (.Platform$OS.type == "windows") {
[09:31:12.447]                 old_names <- names(...future.oldEnvVars)
[09:31:12.447]                 envs <- base::Sys.getenv()
[09:31:12.447]                 names <- names(envs)
[09:31:12.447]                 common <- intersect(names, old_names)
[09:31:12.447]                 added <- setdiff(names, old_names)
[09:31:12.447]                 removed <- setdiff(old_names, names)
[09:31:12.447]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.447]                   envs[common]]
[09:31:12.447]                 NAMES <- toupper(changed)
[09:31:12.447]                 args <- list()
[09:31:12.447]                 for (kk in seq_along(NAMES)) {
[09:31:12.447]                   name <- changed[[kk]]
[09:31:12.447]                   NAME <- NAMES[[kk]]
[09:31:12.447]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.447]                     next
[09:31:12.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.447]                 }
[09:31:12.447]                 NAMES <- toupper(added)
[09:31:12.447]                 for (kk in seq_along(NAMES)) {
[09:31:12.447]                   name <- added[[kk]]
[09:31:12.447]                   NAME <- NAMES[[kk]]
[09:31:12.447]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.447]                     next
[09:31:12.447]                   args[[name]] <- ""
[09:31:12.447]                 }
[09:31:12.447]                 NAMES <- toupper(removed)
[09:31:12.447]                 for (kk in seq_along(NAMES)) {
[09:31:12.447]                   name <- removed[[kk]]
[09:31:12.447]                   NAME <- NAMES[[kk]]
[09:31:12.447]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.447]                     next
[09:31:12.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.447]                 }
[09:31:12.447]                 if (length(args) > 0) 
[09:31:12.447]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.447]             }
[09:31:12.447]             else {
[09:31:12.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.447]             }
[09:31:12.447]             {
[09:31:12.447]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.447]                   0L) {
[09:31:12.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.447]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.447]                   base::options(opts)
[09:31:12.447]                 }
[09:31:12.447]                 {
[09:31:12.447]                   {
[09:31:12.447]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.447]                     NULL
[09:31:12.447]                   }
[09:31:12.447]                   options(future.plan = NULL)
[09:31:12.447]                   if (is.na(NA_character_)) 
[09:31:12.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.447]                     .init = FALSE)
[09:31:12.447]                 }
[09:31:12.447]             }
[09:31:12.447]         }
[09:31:12.447]     })
[09:31:12.447]     if (TRUE) {
[09:31:12.447]         base::sink(type = "output", split = FALSE)
[09:31:12.447]         if (TRUE) {
[09:31:12.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.447]         }
[09:31:12.447]         else {
[09:31:12.447]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.447]         }
[09:31:12.447]         base::close(...future.stdout)
[09:31:12.447]         ...future.stdout <- NULL
[09:31:12.447]     }
[09:31:12.447]     ...future.result$conditions <- ...future.conditions
[09:31:12.447]     ...future.result$finished <- base::Sys.time()
[09:31:12.447]     ...future.result
[09:31:12.447] }
[09:31:12.449] requestCore(): workers = 2
[09:31:12.451] MulticoreFuture started
[09:31:12.451] - Launch lazy future ... done
[09:31:12.451] run() for ‘MulticoreFuture’ ... done
[09:31:12.452] getGlobalsAndPackages() ...
[09:31:12.452] Searching for globals...
[09:31:12.452] plan(): Setting new future strategy stack:
[09:31:12.453] 
[09:31:12.452] List of future strategies:
[09:31:12.452] 1. sequential:
[09:31:12.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.452]    - tweaked: FALSE
[09:31:12.452]    - call: NULL
[09:31:12.453] Searching for globals ... DONE
[09:31:12.453] - globals: [0] <none>
[09:31:12.453] plan(): nbrOfWorkers() = 1
[09:31:12.453] getGlobalsAndPackages() ... DONE
[09:31:12.454] run() for ‘Future’ ...
[09:31:12.454] - state: ‘created’
[09:31:12.454] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:12.455] plan(): Setting new future strategy stack:
[09:31:12.455] List of future strategies:
[09:31:12.455] 1. multicore:
[09:31:12.455]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.455]    - tweaked: FALSE
[09:31:12.455]    - call: plan(strategy)
[09:31:12.459] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:12.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:12.459]   - Field: ‘label’
[09:31:12.460]   - Field: ‘local’
[09:31:12.460] plan(): nbrOfWorkers() = 2
[09:31:12.460]   - Field: ‘owner’
[09:31:12.460]   - Field: ‘envir’
[09:31:12.460]   - Field: ‘workers’
[09:31:12.460]   - Field: ‘packages’
[09:31:12.460]   - Field: ‘gc’
[09:31:12.460]   - Field: ‘job’
[09:31:12.461]   - Field: ‘conditions’
[09:31:12.461]   - Field: ‘expr’
[09:31:12.461]   - Field: ‘uuid’
[09:31:12.461]   - Field: ‘seed’
[09:31:12.461]   - Field: ‘version’
[09:31:12.461]   - Field: ‘result’
[09:31:12.461]   - Field: ‘asynchronous’
[09:31:12.462]   - Field: ‘calls’
[09:31:12.462]   - Field: ‘globals’
[09:31:12.462]   - Field: ‘stdout’
[09:31:12.462]   - Field: ‘earlySignal’
[09:31:12.462]   - Field: ‘lazy’
[09:31:12.462]   - Field: ‘state’
[09:31:12.462] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:12.463] - Launch lazy future ...
[09:31:12.463] Packages needed by the future expression (n = 0): <none>
[09:31:12.463] Packages needed by future strategies (n = 0): <none>
[09:31:12.464] {
[09:31:12.464]     {
[09:31:12.464]         {
[09:31:12.464]             ...future.startTime <- base::Sys.time()
[09:31:12.464]             {
[09:31:12.464]                 {
[09:31:12.464]                   {
[09:31:12.464]                     {
[09:31:12.464]                       base::local({
[09:31:12.464]                         has_future <- base::requireNamespace("future", 
[09:31:12.464]                           quietly = TRUE)
[09:31:12.464]                         if (has_future) {
[09:31:12.464]                           ns <- base::getNamespace("future")
[09:31:12.464]                           version <- ns[[".package"]][["version"]]
[09:31:12.464]                           if (is.null(version)) 
[09:31:12.464]                             version <- utils::packageVersion("future")
[09:31:12.464]                         }
[09:31:12.464]                         else {
[09:31:12.464]                           version <- NULL
[09:31:12.464]                         }
[09:31:12.464]                         if (!has_future || version < "1.8.0") {
[09:31:12.464]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:12.464]                             "", base::R.version$version.string), 
[09:31:12.464]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:12.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:12.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:12.464]                               "release", "version")], collapse = " "), 
[09:31:12.464]                             hostname = base::Sys.info()[["nodename"]])
[09:31:12.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:12.464]                             info)
[09:31:12.464]                           info <- base::paste(info, collapse = "; ")
[09:31:12.464]                           if (!has_future) {
[09:31:12.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:12.464]                               info)
[09:31:12.464]                           }
[09:31:12.464]                           else {
[09:31:12.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:12.464]                               info, version)
[09:31:12.464]                           }
[09:31:12.464]                           base::stop(msg)
[09:31:12.464]                         }
[09:31:12.464]                       })
[09:31:12.464]                     }
[09:31:12.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:12.464]                     base::options(mc.cores = 1L)
[09:31:12.464]                   }
[09:31:12.464]                   ...future.strategy.old <- future::plan("list")
[09:31:12.464]                   options(future.plan = NULL)
[09:31:12.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:12.464]                 }
[09:31:12.464]                 ...future.workdir <- getwd()
[09:31:12.464]             }
[09:31:12.464]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:12.464]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:12.464]         }
[09:31:12.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:12.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:12.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:12.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:12.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:12.464]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:12.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:12.464]             base::names(...future.oldOptions))
[09:31:12.464]     }
[09:31:12.464]     if (FALSE) {
[09:31:12.464]     }
[09:31:12.464]     else {
[09:31:12.464]         if (TRUE) {
[09:31:12.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:12.464]                 open = "w")
[09:31:12.464]         }
[09:31:12.464]         else {
[09:31:12.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:12.464]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:12.464]         }
[09:31:12.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:12.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:12.464]             base::sink(type = "output", split = FALSE)
[09:31:12.464]             base::close(...future.stdout)
[09:31:12.464]         }, add = TRUE)
[09:31:12.464]     }
[09:31:12.464]     ...future.frame <- base::sys.nframe()
[09:31:12.464]     ...future.conditions <- base::list()
[09:31:12.464]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:12.464]     if (FALSE) {
[09:31:12.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:12.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:12.464]     }
[09:31:12.464]     ...future.result <- base::tryCatch({
[09:31:12.464]         base::withCallingHandlers({
[09:31:12.464]             ...future.value <- base::withVisible(base::local({
[09:31:12.464]                 withCallingHandlers({
[09:31:12.464]                   NULL
[09:31:12.464]                 }, immediateCondition = function(cond) {
[09:31:12.464]                   save_rds <- function (object, pathname, ...) 
[09:31:12.464]                   {
[09:31:12.464]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:12.464]                     if (file_test("-f", pathname_tmp)) {
[09:31:12.464]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.464]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:12.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.464]                         fi_tmp[["mtime"]])
[09:31:12.464]                     }
[09:31:12.464]                     tryCatch({
[09:31:12.464]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:12.464]                     }, error = function(ex) {
[09:31:12.464]                       msg <- conditionMessage(ex)
[09:31:12.464]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.464]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:12.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.464]                         fi_tmp[["mtime"]], msg)
[09:31:12.464]                       ex$message <- msg
[09:31:12.464]                       stop(ex)
[09:31:12.464]                     })
[09:31:12.464]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:12.464]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:12.464]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:12.464]                       fi_tmp <- file.info(pathname_tmp)
[09:31:12.464]                       fi <- file.info(pathname)
[09:31:12.464]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:12.464]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:12.464]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:12.464]                         fi[["size"]], fi[["mtime"]])
[09:31:12.464]                       stop(msg)
[09:31:12.464]                     }
[09:31:12.464]                     invisible(pathname)
[09:31:12.464]                   }
[09:31:12.464]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:12.464]                     rootPath = tempdir()) 
[09:31:12.464]                   {
[09:31:12.464]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:12.464]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:12.464]                       tmpdir = path, fileext = ".rds")
[09:31:12.464]                     save_rds(obj, file)
[09:31:12.464]                   }
[09:31:12.464]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:12.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.464]                   {
[09:31:12.464]                     inherits <- base::inherits
[09:31:12.464]                     invokeRestart <- base::invokeRestart
[09:31:12.464]                     is.null <- base::is.null
[09:31:12.464]                     muffled <- FALSE
[09:31:12.464]                     if (inherits(cond, "message")) {
[09:31:12.464]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:12.464]                       if (muffled) 
[09:31:12.464]                         invokeRestart("muffleMessage")
[09:31:12.464]                     }
[09:31:12.464]                     else if (inherits(cond, "warning")) {
[09:31:12.464]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:12.464]                       if (muffled) 
[09:31:12.464]                         invokeRestart("muffleWarning")
[09:31:12.464]                     }
[09:31:12.464]                     else if (inherits(cond, "condition")) {
[09:31:12.464]                       if (!is.null(pattern)) {
[09:31:12.464]                         computeRestarts <- base::computeRestarts
[09:31:12.464]                         grepl <- base::grepl
[09:31:12.464]                         restarts <- computeRestarts(cond)
[09:31:12.464]                         for (restart in restarts) {
[09:31:12.464]                           name <- restart$name
[09:31:12.464]                           if (is.null(name)) 
[09:31:12.464]                             next
[09:31:12.464]                           if (!grepl(pattern, name)) 
[09:31:12.464]                             next
[09:31:12.464]                           invokeRestart(restart)
[09:31:12.464]                           muffled <- TRUE
[09:31:12.464]                           break
[09:31:12.464]                         }
[09:31:12.464]                       }
[09:31:12.464]                     }
[09:31:12.464]                     invisible(muffled)
[09:31:12.464]                   }
[09:31:12.464]                   muffleCondition(cond)
[09:31:12.464]                 })
[09:31:12.464]             }))
[09:31:12.464]             future::FutureResult(value = ...future.value$value, 
[09:31:12.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.464]                   ...future.rng), globalenv = if (FALSE) 
[09:31:12.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:12.464]                     ...future.globalenv.names))
[09:31:12.464]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:12.464]         }, condition = base::local({
[09:31:12.464]             c <- base::c
[09:31:12.464]             inherits <- base::inherits
[09:31:12.464]             invokeRestart <- base::invokeRestart
[09:31:12.464]             length <- base::length
[09:31:12.464]             list <- base::list
[09:31:12.464]             seq.int <- base::seq.int
[09:31:12.464]             signalCondition <- base::signalCondition
[09:31:12.464]             sys.calls <- base::sys.calls
[09:31:12.464]             `[[` <- base::`[[`
[09:31:12.464]             `+` <- base::`+`
[09:31:12.464]             `<<-` <- base::`<<-`
[09:31:12.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:12.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:12.464]                   3L)]
[09:31:12.464]             }
[09:31:12.464]             function(cond) {
[09:31:12.464]                 is_error <- inherits(cond, "error")
[09:31:12.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:12.464]                   NULL)
[09:31:12.464]                 if (is_error) {
[09:31:12.464]                   sessionInformation <- function() {
[09:31:12.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:12.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:12.464]                       search = base::search(), system = base::Sys.info())
[09:31:12.464]                   }
[09:31:12.464]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:12.464]                     cond$call), session = sessionInformation(), 
[09:31:12.464]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:12.464]                   signalCondition(cond)
[09:31:12.464]                 }
[09:31:12.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:12.464]                 "immediateCondition"))) {
[09:31:12.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:12.464]                   ...future.conditions[[length(...future.conditions) + 
[09:31:12.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:12.464]                   if (TRUE && !signal) {
[09:31:12.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.464]                     {
[09:31:12.464]                       inherits <- base::inherits
[09:31:12.464]                       invokeRestart <- base::invokeRestart
[09:31:12.464]                       is.null <- base::is.null
[09:31:12.464]                       muffled <- FALSE
[09:31:12.464]                       if (inherits(cond, "message")) {
[09:31:12.464]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.464]                         if (muffled) 
[09:31:12.464]                           invokeRestart("muffleMessage")
[09:31:12.464]                       }
[09:31:12.464]                       else if (inherits(cond, "warning")) {
[09:31:12.464]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.464]                         if (muffled) 
[09:31:12.464]                           invokeRestart("muffleWarning")
[09:31:12.464]                       }
[09:31:12.464]                       else if (inherits(cond, "condition")) {
[09:31:12.464]                         if (!is.null(pattern)) {
[09:31:12.464]                           computeRestarts <- base::computeRestarts
[09:31:12.464]                           grepl <- base::grepl
[09:31:12.464]                           restarts <- computeRestarts(cond)
[09:31:12.464]                           for (restart in restarts) {
[09:31:12.464]                             name <- restart$name
[09:31:12.464]                             if (is.null(name)) 
[09:31:12.464]                               next
[09:31:12.464]                             if (!grepl(pattern, name)) 
[09:31:12.464]                               next
[09:31:12.464]                             invokeRestart(restart)
[09:31:12.464]                             muffled <- TRUE
[09:31:12.464]                             break
[09:31:12.464]                           }
[09:31:12.464]                         }
[09:31:12.464]                       }
[09:31:12.464]                       invisible(muffled)
[09:31:12.464]                     }
[09:31:12.464]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.464]                   }
[09:31:12.464]                 }
[09:31:12.464]                 else {
[09:31:12.464]                   if (TRUE) {
[09:31:12.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:12.464]                     {
[09:31:12.464]                       inherits <- base::inherits
[09:31:12.464]                       invokeRestart <- base::invokeRestart
[09:31:12.464]                       is.null <- base::is.null
[09:31:12.464]                       muffled <- FALSE
[09:31:12.464]                       if (inherits(cond, "message")) {
[09:31:12.464]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:12.464]                         if (muffled) 
[09:31:12.464]                           invokeRestart("muffleMessage")
[09:31:12.464]                       }
[09:31:12.464]                       else if (inherits(cond, "warning")) {
[09:31:12.464]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:12.464]                         if (muffled) 
[09:31:12.464]                           invokeRestart("muffleWarning")
[09:31:12.464]                       }
[09:31:12.464]                       else if (inherits(cond, "condition")) {
[09:31:12.464]                         if (!is.null(pattern)) {
[09:31:12.464]                           computeRestarts <- base::computeRestarts
[09:31:12.464]                           grepl <- base::grepl
[09:31:12.464]                           restarts <- computeRestarts(cond)
[09:31:12.464]                           for (restart in restarts) {
[09:31:12.464]                             name <- restart$name
[09:31:12.464]                             if (is.null(name)) 
[09:31:12.464]                               next
[09:31:12.464]                             if (!grepl(pattern, name)) 
[09:31:12.464]                               next
[09:31:12.464]                             invokeRestart(restart)
[09:31:12.464]                             muffled <- TRUE
[09:31:12.464]                             break
[09:31:12.464]                           }
[09:31:12.464]                         }
[09:31:12.464]                       }
[09:31:12.464]                       invisible(muffled)
[09:31:12.464]                     }
[09:31:12.464]                     muffleCondition(cond, pattern = "^muffle")
[09:31:12.464]                   }
[09:31:12.464]                 }
[09:31:12.464]             }
[09:31:12.464]         }))
[09:31:12.464]     }, error = function(ex) {
[09:31:12.464]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:12.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:12.464]                 ...future.rng), started = ...future.startTime, 
[09:31:12.464]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:12.464]             version = "1.8"), class = "FutureResult")
[09:31:12.464]     }, finally = {
[09:31:12.464]         if (!identical(...future.workdir, getwd())) 
[09:31:12.464]             setwd(...future.workdir)
[09:31:12.464]         {
[09:31:12.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:12.464]                 ...future.oldOptions$nwarnings <- NULL
[09:31:12.464]             }
[09:31:12.464]             base::options(...future.oldOptions)
[09:31:12.464]             if (.Platform$OS.type == "windows") {
[09:31:12.464]                 old_names <- names(...future.oldEnvVars)
[09:31:12.464]                 envs <- base::Sys.getenv()
[09:31:12.464]                 names <- names(envs)
[09:31:12.464]                 common <- intersect(names, old_names)
[09:31:12.464]                 added <- setdiff(names, old_names)
[09:31:12.464]                 removed <- setdiff(old_names, names)
[09:31:12.464]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:12.464]                   envs[common]]
[09:31:12.464]                 NAMES <- toupper(changed)
[09:31:12.464]                 args <- list()
[09:31:12.464]                 for (kk in seq_along(NAMES)) {
[09:31:12.464]                   name <- changed[[kk]]
[09:31:12.464]                   NAME <- NAMES[[kk]]
[09:31:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.464]                     next
[09:31:12.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.464]                 }
[09:31:12.464]                 NAMES <- toupper(added)
[09:31:12.464]                 for (kk in seq_along(NAMES)) {
[09:31:12.464]                   name <- added[[kk]]
[09:31:12.464]                   NAME <- NAMES[[kk]]
[09:31:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.464]                     next
[09:31:12.464]                   args[[name]] <- ""
[09:31:12.464]                 }
[09:31:12.464]                 NAMES <- toupper(removed)
[09:31:12.464]                 for (kk in seq_along(NAMES)) {
[09:31:12.464]                   name <- removed[[kk]]
[09:31:12.464]                   NAME <- NAMES[[kk]]
[09:31:12.464]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:12.464]                     next
[09:31:12.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:12.464]                 }
[09:31:12.464]                 if (length(args) > 0) 
[09:31:12.464]                   base::do.call(base::Sys.setenv, args = args)
[09:31:12.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:12.464]             }
[09:31:12.464]             else {
[09:31:12.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:12.464]             }
[09:31:12.464]             {
[09:31:12.464]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:12.464]                   0L) {
[09:31:12.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:12.464]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:12.464]                   base::options(opts)
[09:31:12.464]                 }
[09:31:12.464]                 {
[09:31:12.464]                   {
[09:31:12.464]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:12.464]                     NULL
[09:31:12.464]                   }
[09:31:12.464]                   options(future.plan = NULL)
[09:31:12.464]                   if (is.na(NA_character_)) 
[09:31:12.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:12.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:12.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:12.464]                     .init = FALSE)
[09:31:12.464]                 }
[09:31:12.464]             }
[09:31:12.464]         }
[09:31:12.464]     })
[09:31:12.464]     if (TRUE) {
[09:31:12.464]         base::sink(type = "output", split = FALSE)
[09:31:12.464]         if (TRUE) {
[09:31:12.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:12.464]         }
[09:31:12.464]         else {
[09:31:12.464]             ...future.result["stdout"] <- base::list(NULL)
[09:31:12.464]         }
[09:31:12.464]         base::close(...future.stdout)
[09:31:12.464]         ...future.stdout <- NULL
[09:31:12.464]     }
[09:31:12.464]     ...future.result$conditions <- ...future.conditions
[09:31:12.464]     ...future.result$finished <- base::Sys.time()
[09:31:12.464]     ...future.result
[09:31:12.464] }
[09:31:12.467] requestCore(): workers = 2
[09:31:12.474] MulticoreFuture started
[09:31:12.475] - Launch lazy future ... done
[09:31:12.475] plan(): Setting new future strategy stack:
[09:31:12.475] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[09:31:12.476] List of future strategies:
[09:31:12.476] 1. sequential:
[09:31:12.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:12.476]    - tweaked: FALSE
[09:31:12.476]    - call: NULL
[09:31:12.477] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca8c7f38> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cae7be30> 
 $  : NULL
 $  :[09:31:12.480] plan(): Setting new future strategy stack:
 NULL
 $  :[09:31:12.480] List of future strategies:
[09:31:12.480] 1. multicore:
[09:31:12.480]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:12.480]    - tweaked: FALSE
[09:31:12.480]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3ca8c7f38> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cae7be30> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ :[09:31:12.485] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:12.490] resolve() on list ...
[09:31:12.490]  recursive: 0
[09:31:12.491]  length: 6
[09:31:12.491]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:12.491] signalConditionsASAP(numeric, pos=1) ...
[09:31:12.491] - nx: 6
[09:31:12.491] - relay: TRUE
[09:31:12.491] - stdout: TRUE
[09:31:12.491] - signal: TRUE
[09:31:12.491] - resignal: FALSE
[09:31:12.492] - force: TRUE
[09:31:12.492] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.492] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.492]  - until=2
[09:31:12.492]  - relaying element #2
[09:31:12.492] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.492] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.493] signalConditionsASAP(NULL, pos=1) ... done
[09:31:12.493]  length: 5 (resolved future 1)
[09:31:12.493] Future #2
[09:31:12.493] result() for MulticoreFuture ...
[09:31:12.494] result() for MulticoreFuture ...
[09:31:12.494] result() for MulticoreFuture ... done
[09:31:12.494] result() for MulticoreFuture ... done
[09:31:12.494] result() for MulticoreFuture ...
[09:31:12.494] result() for MulticoreFuture ... done
[09:31:12.495] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:12.495] - nx: 6
[09:31:12.495] - relay: TRUE
[09:31:12.495] - stdout: TRUE
[09:31:12.495] - signal: TRUE
[09:31:12.495] - resignal: FALSE
[09:31:12.495] - force: TRUE
[09:31:12.495] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.496] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:12.496]  - until=2
[09:31:12.496]  - relaying element #2
[09:31:12.496] result() for MulticoreFuture ...
[09:31:12.496] result() for MulticoreFuture ... done
[09:31:12.496] result() for MulticoreFuture ...
[09:31:12.496] result() for MulticoreFuture ... done
[09:31:12.496] result() for MulticoreFuture ...
[09:31:12.497] result() for MulticoreFuture ... done
[09:31:12.497] result() for MulticoreFuture ...
[09:31:12.497] result() for MulticoreFuture ... done
[09:31:12.497] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.497] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.497] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:12.497]  length: 4 (resolved future 2)
[09:31:12.498] Future #3
[09:31:12.498] result() for MulticoreFuture ...
[09:31:12.498] result() for MulticoreFuture ...
[09:31:12.498] result() for MulticoreFuture ... done
[09:31:12.499] result() for MulticoreFuture ... done
[09:31:12.499] result() for MulticoreFuture ...
[09:31:12.499] result() for MulticoreFuture ... done
[09:31:12.499] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:12.499] - nx: 6
[09:31:12.499] - relay: TRUE
[09:31:12.499] - stdout: TRUE
[09:31:12.499] - signal: TRUE
[09:31:12.499] - resignal: FALSE
[09:31:12.500] - force: TRUE
[09:31:12.500] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.500] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:12.500]  - until=3
[09:31:12.500]  - relaying element #3
[09:31:12.500] result() for MulticoreFuture ...
[09:31:12.500] result() for MulticoreFuture ... done
[09:31:12.500] result() for MulticoreFuture ...
[09:31:12.500] result() for MulticoreFuture ... done
[09:31:12.501] result() for MulticoreFuture ...
[09:31:12.501] result() for MulticoreFuture ... done
[09:31:12.501] result() for MulticoreFuture ...
[09:31:12.501] result() for MulticoreFuture ... done
[09:31:12.501] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.501] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.501] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:12.501]  length: 3 (resolved future 3)
[09:31:12.501] signalConditionsASAP(NULL, pos=4) ...
[09:31:12.502] - nx: 6
[09:31:12.502] - relay: TRUE
[09:31:12.502] - stdout: TRUE
[09:31:12.502] - signal: TRUE
[09:31:12.502] - resignal: FALSE
[09:31:12.502] - force: TRUE
[09:31:12.502] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.502]  - until=5
[09:31:12.502]  - relaying element #5
[09:31:12.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.503] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.503] signalConditionsASAP(NULL, pos=4) ... done
[09:31:12.503]  length: 2 (resolved future 4)
[09:31:12.503] signalConditionsASAP(NULL, pos=5) ...
[09:31:12.503] - nx: 6
[09:31:12.503] - relay: TRUE
[09:31:12.503] - stdout: TRUE
[09:31:12.503] - signal: TRUE
[09:31:12.503] - resignal: FALSE
[09:31:12.503] - force: TRUE
[09:31:12.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:12.504] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.504]  - until=6
[09:31:12.504]  - relaying element #6
[09:31:12.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.504] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.504] signalConditionsASAP(NULL, pos=5) ... done
[09:31:12.504]  length: 1 (resolved future 5)
[09:31:12.504] signalConditionsASAP(numeric, pos=6) ...
[09:31:12.504] - nx: 6
[09:31:12.504] - relay: TRUE
[09:31:12.505] - stdout: TRUE
[09:31:12.505] - signal: TRUE
[09:31:12.505] - resignal: FALSE
[09:31:12.505] - force: TRUE
[09:31:12.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:12.505] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.505]  - until=6
[09:31:12.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.505] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.505] signalConditionsASAP(numeric, pos=6) ... done
[09:31:12.506]  length: 0 (resolved future 6)
[09:31:12.506] Relaying remaining futures
[09:31:12.506] signalConditionsASAP(NULL, pos=0) ...
[09:31:12.506] - nx: 6
[09:31:12.506] - relay: TRUE
[09:31:12.506] - stdout: TRUE
[09:31:12.506] - signal: TRUE
[09:31:12.506] - resignal: FALSE
[09:31:12.506] - force: TRUE
[09:31:12.506] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.506] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:12.507] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:12.507] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:12.507] signalConditionsASAP(NULL, pos=0) ... done
[09:31:12.507] resolve() on list ... DONE
[09:31:12.507] result() for MulticoreFuture ...
[09:31:12.507] result() for MulticoreFuture ... done
[09:31:12.507] result() for MulticoreFuture ...
[09:31:12.507] result() for MulticoreFuture ... done
[09:31:12.507] result() for MulticoreFuture ...
[09:31:12.508] result() for MulticoreFuture ... done
[09:31:12.508] result() for MulticoreFuture ...
[09:31:12.508] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[09:31:12.513] plan(): Setting new future strategy stack:
[09:31:12.514] List of future strategies:
[09:31:12.514] 1. multisession:
[09:31:12.514]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:12.514]    - tweaked: FALSE
[09:31:12.514]    - call: plan(strategy)
[09:31:12.514] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:12.514] multisession:
[09:31:12.514] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:12.514] - tweaked: FALSE
[09:31:12.514] - call: plan(strategy)
[09:31:12.521] getGlobalsAndPackages() ...
[09:31:12.521] Not searching for globals
[09:31:12.521] - globals: [0] <none>
[09:31:12.521] getGlobalsAndPackages() ... DONE
[09:31:12.522] [local output] makeClusterPSOCK() ...
[09:31:12.561] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:12.563] [local output] Base port: 11689
[09:31:12.563] [local output] Getting setup options for 2 cluster nodes ...
[09:31:12.563] [local output]  - Node 1 of 2 ...
[09:31:12.563] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:12.564] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4733be3e579.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4733be3e579.pid")'’
[09:31:12.750] - Possible to infer worker's PID: TRUE
[09:31:12.750] [local output] Rscript port: 11689

[09:31:12.750] [local output]  - Node 2 of 2 ...
[09:31:12.751] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:12.751] [local output] Rscript port: 11689

[09:31:12.752] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:12.752] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:12.752] [local output] Setting up PSOCK nodes in parallel
[09:31:12.752] List of 36
[09:31:12.752]  $ worker          : chr "localhost"
[09:31:12.752]   ..- attr(*, "localhost")= logi TRUE
[09:31:12.752]  $ master          : chr "localhost"
[09:31:12.752]  $ port            : int 11689
[09:31:12.752]  $ connectTimeout  : num 120
[09:31:12.752]  $ timeout         : num 2592000
[09:31:12.752]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:12.752]  $ homogeneous     : logi TRUE
[09:31:12.752]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:12.752]  $ rscript_envs    : NULL
[09:31:12.752]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:12.752]  $ rscript_startup : NULL
[09:31:12.752]  $ rscript_sh      : chr "sh"
[09:31:12.752]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:12.752]  $ methods         : logi TRUE
[09:31:12.752]  $ socketOptions   : chr "no-delay"
[09:31:12.752]  $ useXDR          : logi FALSE
[09:31:12.752]  $ outfile         : chr "/dev/null"
[09:31:12.752]  $ renice          : int NA
[09:31:12.752]  $ rshcmd          : NULL
[09:31:12.752]  $ user            : chr(0) 
[09:31:12.752]  $ revtunnel       : logi FALSE
[09:31:12.752]  $ rshlogfile      : NULL
[09:31:12.752]  $ rshopts         : chr(0) 
[09:31:12.752]  $ rank            : int 1
[09:31:12.752]  $ manual          : logi FALSE
[09:31:12.752]  $ dryrun          : logi FALSE
[09:31:12.752]  $ quiet           : logi FALSE
[09:31:12.752]  $ setup_strategy  : chr "parallel"
[09:31:12.752]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:12.752]  $ pidfile         : chr "/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4733be3e579.pid"
[09:31:12.752]  $ rshcmd_label    : NULL
[09:31:12.752]  $ rsh_call        : NULL
[09:31:12.752]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:12.752]  $ localMachine    : logi TRUE
[09:31:12.752]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:12.752]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:12.752]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:12.752]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:12.752]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:12.752]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:12.752]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:12.752]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:12.752]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:12.752]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:12.752]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:12.752]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:12.752]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:12.752]  $ arguments       :List of 28
[09:31:12.752]   ..$ worker          : chr "localhost"
[09:31:12.752]   ..$ master          : NULL
[09:31:12.752]   ..$ port            : int 11689
[09:31:12.752]   ..$ connectTimeout  : num 120
[09:31:12.752]   ..$ timeout         : num 2592000
[09:31:12.752]   ..$ rscript         : NULL
[09:31:12.752]   ..$ homogeneous     : NULL
[09:31:12.752]   ..$ rscript_args    : NULL
[09:31:12.752]   ..$ rscript_envs    : NULL
[09:31:12.752]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:12.752]   ..$ rscript_startup : NULL
[09:31:12.752]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:12.752]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:12.752]   ..$ methods         : logi TRUE
[09:31:12.752]   ..$ socketOptions   : chr "no-delay"
[09:31:12.752]   ..$ useXDR          : logi FALSE
[09:31:12.752]   ..$ outfile         : chr "/dev/null"
[09:31:12.752]   ..$ renice          : int NA
[09:31:12.752]   ..$ rshcmd          : NULL
[09:31:12.752]   ..$ user            : NULL
[09:31:12.752]   ..$ revtunnel       : logi NA
[09:31:12.752]   ..$ rshlogfile      : NULL
[09:31:12.752]   ..$ rshopts         : NULL
[09:31:12.752]   ..$ rank            : int 1
[09:31:12.752]   ..$ manual          : logi FALSE
[09:31:12.752]   ..$ dryrun          : logi FALSE
[09:31:12.752]   ..$ quiet           : logi FALSE
[09:31:12.752]   ..$ setup_strategy  : chr "parallel"
[09:31:12.752]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:12.769] [local output] System call to launch all workers:
[09:31:12.769] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4733be3e579.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11689 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:12.769] [local output] Starting PSOCK main server
[09:31:12.775] [local output] Workers launched
[09:31:12.775] [local output] Waiting for workers to connect back
[09:31:12.775]  - [local output] 0 workers out of 2 ready
[09:31:12.991]  - [local output] 0 workers out of 2 ready
[09:31:12.992]  - [local output] 1 workers out of 2 ready
[09:31:13.018]  - [local output] 1 workers out of 2 ready
[09:31:13.018]  - [local output] 2 workers out of 2 ready
[09:31:13.018] [local output] Launching of workers completed
[09:31:13.018] [local output] Collecting session information from workers
[09:31:13.019] [local output]  - Worker #1 of 2
[09:31:13.020] [local output]  - Worker #2 of 2
[09:31:13.020] [local output] makeClusterPSOCK() ... done
[09:31:13.031] Packages needed by the future expression (n = 0): <none>
[09:31:13.031] Packages needed by future strategies (n = 0): <none>
[09:31:13.032] {
[09:31:13.032]     {
[09:31:13.032]         {
[09:31:13.032]             ...future.startTime <- base::Sys.time()
[09:31:13.032]             {
[09:31:13.032]                 {
[09:31:13.032]                   {
[09:31:13.032]                     {
[09:31:13.032]                       base::local({
[09:31:13.032]                         has_future <- base::requireNamespace("future", 
[09:31:13.032]                           quietly = TRUE)
[09:31:13.032]                         if (has_future) {
[09:31:13.032]                           ns <- base::getNamespace("future")
[09:31:13.032]                           version <- ns[[".package"]][["version"]]
[09:31:13.032]                           if (is.null(version)) 
[09:31:13.032]                             version <- utils::packageVersion("future")
[09:31:13.032]                         }
[09:31:13.032]                         else {
[09:31:13.032]                           version <- NULL
[09:31:13.032]                         }
[09:31:13.032]                         if (!has_future || version < "1.8.0") {
[09:31:13.032]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.032]                             "", base::R.version$version.string), 
[09:31:13.032]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.032]                               "release", "version")], collapse = " "), 
[09:31:13.032]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.032]                             info)
[09:31:13.032]                           info <- base::paste(info, collapse = "; ")
[09:31:13.032]                           if (!has_future) {
[09:31:13.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.032]                               info)
[09:31:13.032]                           }
[09:31:13.032]                           else {
[09:31:13.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.032]                               info, version)
[09:31:13.032]                           }
[09:31:13.032]                           base::stop(msg)
[09:31:13.032]                         }
[09:31:13.032]                       })
[09:31:13.032]                     }
[09:31:13.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.032]                     base::options(mc.cores = 1L)
[09:31:13.032]                   }
[09:31:13.032]                   ...future.strategy.old <- future::plan("list")
[09:31:13.032]                   options(future.plan = NULL)
[09:31:13.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.032]                 }
[09:31:13.032]                 ...future.workdir <- getwd()
[09:31:13.032]             }
[09:31:13.032]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.032]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.032]         }
[09:31:13.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.032]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.032]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.032]             base::names(...future.oldOptions))
[09:31:13.032]     }
[09:31:13.032]     if (FALSE) {
[09:31:13.032]     }
[09:31:13.032]     else {
[09:31:13.032]         if (TRUE) {
[09:31:13.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.032]                 open = "w")
[09:31:13.032]         }
[09:31:13.032]         else {
[09:31:13.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.032]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.032]         }
[09:31:13.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.032]             base::sink(type = "output", split = FALSE)
[09:31:13.032]             base::close(...future.stdout)
[09:31:13.032]         }, add = TRUE)
[09:31:13.032]     }
[09:31:13.032]     ...future.frame <- base::sys.nframe()
[09:31:13.032]     ...future.conditions <- base::list()
[09:31:13.032]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.032]     if (FALSE) {
[09:31:13.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.032]     }
[09:31:13.032]     ...future.result <- base::tryCatch({
[09:31:13.032]         base::withCallingHandlers({
[09:31:13.032]             ...future.value <- base::withVisible(base::local({
[09:31:13.032]                 ...future.makeSendCondition <- base::local({
[09:31:13.032]                   sendCondition <- NULL
[09:31:13.032]                   function(frame = 1L) {
[09:31:13.032]                     if (is.function(sendCondition)) 
[09:31:13.032]                       return(sendCondition)
[09:31:13.032]                     ns <- getNamespace("parallel")
[09:31:13.032]                     if (exists("sendData", mode = "function", 
[09:31:13.032]                       envir = ns)) {
[09:31:13.032]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.032]                         envir = ns)
[09:31:13.032]                       envir <- sys.frame(frame)
[09:31:13.032]                       master <- NULL
[09:31:13.032]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.032]                         !identical(envir, emptyenv())) {
[09:31:13.032]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.032]                           inherits = FALSE)) {
[09:31:13.032]                           master <- get("master", mode = "list", 
[09:31:13.032]                             envir = envir, inherits = FALSE)
[09:31:13.032]                           if (inherits(master, c("SOCKnode", 
[09:31:13.032]                             "SOCK0node"))) {
[09:31:13.032]                             sendCondition <<- function(cond) {
[09:31:13.032]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.032]                                 success = TRUE)
[09:31:13.032]                               parallel_sendData(master, data)
[09:31:13.032]                             }
[09:31:13.032]                             return(sendCondition)
[09:31:13.032]                           }
[09:31:13.032]                         }
[09:31:13.032]                         frame <- frame + 1L
[09:31:13.032]                         envir <- sys.frame(frame)
[09:31:13.032]                       }
[09:31:13.032]                     }
[09:31:13.032]                     sendCondition <<- function(cond) NULL
[09:31:13.032]                   }
[09:31:13.032]                 })
[09:31:13.032]                 withCallingHandlers({
[09:31:13.032]                   NA
[09:31:13.032]                 }, immediateCondition = function(cond) {
[09:31:13.032]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.032]                   sendCondition(cond)
[09:31:13.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.032]                   {
[09:31:13.032]                     inherits <- base::inherits
[09:31:13.032]                     invokeRestart <- base::invokeRestart
[09:31:13.032]                     is.null <- base::is.null
[09:31:13.032]                     muffled <- FALSE
[09:31:13.032]                     if (inherits(cond, "message")) {
[09:31:13.032]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.032]                       if (muffled) 
[09:31:13.032]                         invokeRestart("muffleMessage")
[09:31:13.032]                     }
[09:31:13.032]                     else if (inherits(cond, "warning")) {
[09:31:13.032]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.032]                       if (muffled) 
[09:31:13.032]                         invokeRestart("muffleWarning")
[09:31:13.032]                     }
[09:31:13.032]                     else if (inherits(cond, "condition")) {
[09:31:13.032]                       if (!is.null(pattern)) {
[09:31:13.032]                         computeRestarts <- base::computeRestarts
[09:31:13.032]                         grepl <- base::grepl
[09:31:13.032]                         restarts <- computeRestarts(cond)
[09:31:13.032]                         for (restart in restarts) {
[09:31:13.032]                           name <- restart$name
[09:31:13.032]                           if (is.null(name)) 
[09:31:13.032]                             next
[09:31:13.032]                           if (!grepl(pattern, name)) 
[09:31:13.032]                             next
[09:31:13.032]                           invokeRestart(restart)
[09:31:13.032]                           muffled <- TRUE
[09:31:13.032]                           break
[09:31:13.032]                         }
[09:31:13.032]                       }
[09:31:13.032]                     }
[09:31:13.032]                     invisible(muffled)
[09:31:13.032]                   }
[09:31:13.032]                   muffleCondition(cond)
[09:31:13.032]                 })
[09:31:13.032]             }))
[09:31:13.032]             future::FutureResult(value = ...future.value$value, 
[09:31:13.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.032]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.032]                     ...future.globalenv.names))
[09:31:13.032]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.032]         }, condition = base::local({
[09:31:13.032]             c <- base::c
[09:31:13.032]             inherits <- base::inherits
[09:31:13.032]             invokeRestart <- base::invokeRestart
[09:31:13.032]             length <- base::length
[09:31:13.032]             list <- base::list
[09:31:13.032]             seq.int <- base::seq.int
[09:31:13.032]             signalCondition <- base::signalCondition
[09:31:13.032]             sys.calls <- base::sys.calls
[09:31:13.032]             `[[` <- base::`[[`
[09:31:13.032]             `+` <- base::`+`
[09:31:13.032]             `<<-` <- base::`<<-`
[09:31:13.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.032]                   3L)]
[09:31:13.032]             }
[09:31:13.032]             function(cond) {
[09:31:13.032]                 is_error <- inherits(cond, "error")
[09:31:13.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.032]                   NULL)
[09:31:13.032]                 if (is_error) {
[09:31:13.032]                   sessionInformation <- function() {
[09:31:13.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.032]                       search = base::search(), system = base::Sys.info())
[09:31:13.032]                   }
[09:31:13.032]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.032]                     cond$call), session = sessionInformation(), 
[09:31:13.032]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.032]                   signalCondition(cond)
[09:31:13.032]                 }
[09:31:13.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.032]                 "immediateCondition"))) {
[09:31:13.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.032]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.032]                   if (TRUE && !signal) {
[09:31:13.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.032]                     {
[09:31:13.032]                       inherits <- base::inherits
[09:31:13.032]                       invokeRestart <- base::invokeRestart
[09:31:13.032]                       is.null <- base::is.null
[09:31:13.032]                       muffled <- FALSE
[09:31:13.032]                       if (inherits(cond, "message")) {
[09:31:13.032]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.032]                         if (muffled) 
[09:31:13.032]                           invokeRestart("muffleMessage")
[09:31:13.032]                       }
[09:31:13.032]                       else if (inherits(cond, "warning")) {
[09:31:13.032]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.032]                         if (muffled) 
[09:31:13.032]                           invokeRestart("muffleWarning")
[09:31:13.032]                       }
[09:31:13.032]                       else if (inherits(cond, "condition")) {
[09:31:13.032]                         if (!is.null(pattern)) {
[09:31:13.032]                           computeRestarts <- base::computeRestarts
[09:31:13.032]                           grepl <- base::grepl
[09:31:13.032]                           restarts <- computeRestarts(cond)
[09:31:13.032]                           for (restart in restarts) {
[09:31:13.032]                             name <- restart$name
[09:31:13.032]                             if (is.null(name)) 
[09:31:13.032]                               next
[09:31:13.032]                             if (!grepl(pattern, name)) 
[09:31:13.032]                               next
[09:31:13.032]                             invokeRestart(restart)
[09:31:13.032]                             muffled <- TRUE
[09:31:13.032]                             break
[09:31:13.032]                           }
[09:31:13.032]                         }
[09:31:13.032]                       }
[09:31:13.032]                       invisible(muffled)
[09:31:13.032]                     }
[09:31:13.032]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.032]                   }
[09:31:13.032]                 }
[09:31:13.032]                 else {
[09:31:13.032]                   if (TRUE) {
[09:31:13.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.032]                     {
[09:31:13.032]                       inherits <- base::inherits
[09:31:13.032]                       invokeRestart <- base::invokeRestart
[09:31:13.032]                       is.null <- base::is.null
[09:31:13.032]                       muffled <- FALSE
[09:31:13.032]                       if (inherits(cond, "message")) {
[09:31:13.032]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.032]                         if (muffled) 
[09:31:13.032]                           invokeRestart("muffleMessage")
[09:31:13.032]                       }
[09:31:13.032]                       else if (inherits(cond, "warning")) {
[09:31:13.032]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.032]                         if (muffled) 
[09:31:13.032]                           invokeRestart("muffleWarning")
[09:31:13.032]                       }
[09:31:13.032]                       else if (inherits(cond, "condition")) {
[09:31:13.032]                         if (!is.null(pattern)) {
[09:31:13.032]                           computeRestarts <- base::computeRestarts
[09:31:13.032]                           grepl <- base::grepl
[09:31:13.032]                           restarts <- computeRestarts(cond)
[09:31:13.032]                           for (restart in restarts) {
[09:31:13.032]                             name <- restart$name
[09:31:13.032]                             if (is.null(name)) 
[09:31:13.032]                               next
[09:31:13.032]                             if (!grepl(pattern, name)) 
[09:31:13.032]                               next
[09:31:13.032]                             invokeRestart(restart)
[09:31:13.032]                             muffled <- TRUE
[09:31:13.032]                             break
[09:31:13.032]                           }
[09:31:13.032]                         }
[09:31:13.032]                       }
[09:31:13.032]                       invisible(muffled)
[09:31:13.032]                     }
[09:31:13.032]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.032]                   }
[09:31:13.032]                 }
[09:31:13.032]             }
[09:31:13.032]         }))
[09:31:13.032]     }, error = function(ex) {
[09:31:13.032]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.032]                 ...future.rng), started = ...future.startTime, 
[09:31:13.032]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.032]             version = "1.8"), class = "FutureResult")
[09:31:13.032]     }, finally = {
[09:31:13.032]         if (!identical(...future.workdir, getwd())) 
[09:31:13.032]             setwd(...future.workdir)
[09:31:13.032]         {
[09:31:13.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.032]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.032]             }
[09:31:13.032]             base::options(...future.oldOptions)
[09:31:13.032]             if (.Platform$OS.type == "windows") {
[09:31:13.032]                 old_names <- names(...future.oldEnvVars)
[09:31:13.032]                 envs <- base::Sys.getenv()
[09:31:13.032]                 names <- names(envs)
[09:31:13.032]                 common <- intersect(names, old_names)
[09:31:13.032]                 added <- setdiff(names, old_names)
[09:31:13.032]                 removed <- setdiff(old_names, names)
[09:31:13.032]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.032]                   envs[common]]
[09:31:13.032]                 NAMES <- toupper(changed)
[09:31:13.032]                 args <- list()
[09:31:13.032]                 for (kk in seq_along(NAMES)) {
[09:31:13.032]                   name <- changed[[kk]]
[09:31:13.032]                   NAME <- NAMES[[kk]]
[09:31:13.032]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.032]                     next
[09:31:13.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.032]                 }
[09:31:13.032]                 NAMES <- toupper(added)
[09:31:13.032]                 for (kk in seq_along(NAMES)) {
[09:31:13.032]                   name <- added[[kk]]
[09:31:13.032]                   NAME <- NAMES[[kk]]
[09:31:13.032]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.032]                     next
[09:31:13.032]                   args[[name]] <- ""
[09:31:13.032]                 }
[09:31:13.032]                 NAMES <- toupper(removed)
[09:31:13.032]                 for (kk in seq_along(NAMES)) {
[09:31:13.032]                   name <- removed[[kk]]
[09:31:13.032]                   NAME <- NAMES[[kk]]
[09:31:13.032]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.032]                     next
[09:31:13.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.032]                 }
[09:31:13.032]                 if (length(args) > 0) 
[09:31:13.032]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.032]             }
[09:31:13.032]             else {
[09:31:13.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.032]             }
[09:31:13.032]             {
[09:31:13.032]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.032]                   0L) {
[09:31:13.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.032]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.032]                   base::options(opts)
[09:31:13.032]                 }
[09:31:13.032]                 {
[09:31:13.032]                   {
[09:31:13.032]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.032]                     NULL
[09:31:13.032]                   }
[09:31:13.032]                   options(future.plan = NULL)
[09:31:13.032]                   if (is.na(NA_character_)) 
[09:31:13.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.032]                     .init = FALSE)
[09:31:13.032]                 }
[09:31:13.032]             }
[09:31:13.032]         }
[09:31:13.032]     })
[09:31:13.032]     if (TRUE) {
[09:31:13.032]         base::sink(type = "output", split = FALSE)
[09:31:13.032]         if (TRUE) {
[09:31:13.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.032]         }
[09:31:13.032]         else {
[09:31:13.032]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.032]         }
[09:31:13.032]         base::close(...future.stdout)
[09:31:13.032]         ...future.stdout <- NULL
[09:31:13.032]     }
[09:31:13.032]     ...future.result$conditions <- ...future.conditions
[09:31:13.032]     ...future.result$finished <- base::Sys.time()
[09:31:13.032]     ...future.result
[09:31:13.032] }
[09:31:13.083] MultisessionFuture started
[09:31:13.084] result() for ClusterFuture ...
[09:31:13.084] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.085] - Validating connection of MultisessionFuture
[09:31:13.116] - received message: FutureResult
[09:31:13.116] - Received FutureResult
[09:31:13.116] - Erased future from FutureRegistry
[09:31:13.116] result() for ClusterFuture ...
[09:31:13.116] - result already collected: FutureResult
[09:31:13.116] result() for ClusterFuture ... done
[09:31:13.116] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.117] result() for ClusterFuture ... done
[09:31:13.117] result() for ClusterFuture ...
[09:31:13.117] - result already collected: FutureResult
[09:31:13.117] result() for ClusterFuture ... done
[09:31:13.117] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:13.121] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:13.121] getGlobalsAndPackages() ...
[09:31:13.121] Searching for globals...
[09:31:13.122] 
[09:31:13.122] Searching for globals ... DONE
[09:31:13.122] - globals: [0] <none>
[09:31:13.122] getGlobalsAndPackages() ... DONE
[09:31:13.122] run() for ‘Future’ ...
[09:31:13.123] - state: ‘created’
[09:31:13.123] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.137]   - Field: ‘node’
[09:31:13.137]   - Field: ‘label’
[09:31:13.137]   - Field: ‘local’
[09:31:13.138]   - Field: ‘owner’
[09:31:13.138]   - Field: ‘envir’
[09:31:13.138]   - Field: ‘workers’
[09:31:13.138]   - Field: ‘packages’
[09:31:13.138]   - Field: ‘gc’
[09:31:13.138]   - Field: ‘conditions’
[09:31:13.138]   - Field: ‘persistent’
[09:31:13.138]   - Field: ‘expr’
[09:31:13.138]   - Field: ‘uuid’
[09:31:13.138]   - Field: ‘seed’
[09:31:13.139]   - Field: ‘version’
[09:31:13.139]   - Field: ‘result’
[09:31:13.139]   - Field: ‘asynchronous’
[09:31:13.139]   - Field: ‘calls’
[09:31:13.139]   - Field: ‘globals’
[09:31:13.139]   - Field: ‘stdout’
[09:31:13.139]   - Field: ‘earlySignal’
[09:31:13.139]   - Field: ‘lazy’
[09:31:13.139]   - Field: ‘state’
[09:31:13.140] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.140] - Launch lazy future ...
[09:31:13.140] Packages needed by the future expression (n = 0): <none>
[09:31:13.140] Packages needed by future strategies (n = 0): <none>
[09:31:13.141] {
[09:31:13.141]     {
[09:31:13.141]         {
[09:31:13.141]             ...future.startTime <- base::Sys.time()
[09:31:13.141]             {
[09:31:13.141]                 {
[09:31:13.141]                   {
[09:31:13.141]                     {
[09:31:13.141]                       base::local({
[09:31:13.141]                         has_future <- base::requireNamespace("future", 
[09:31:13.141]                           quietly = TRUE)
[09:31:13.141]                         if (has_future) {
[09:31:13.141]                           ns <- base::getNamespace("future")
[09:31:13.141]                           version <- ns[[".package"]][["version"]]
[09:31:13.141]                           if (is.null(version)) 
[09:31:13.141]                             version <- utils::packageVersion("future")
[09:31:13.141]                         }
[09:31:13.141]                         else {
[09:31:13.141]                           version <- NULL
[09:31:13.141]                         }
[09:31:13.141]                         if (!has_future || version < "1.8.0") {
[09:31:13.141]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.141]                             "", base::R.version$version.string), 
[09:31:13.141]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.141]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.141]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.141]                               "release", "version")], collapse = " "), 
[09:31:13.141]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.141]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.141]                             info)
[09:31:13.141]                           info <- base::paste(info, collapse = "; ")
[09:31:13.141]                           if (!has_future) {
[09:31:13.141]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.141]                               info)
[09:31:13.141]                           }
[09:31:13.141]                           else {
[09:31:13.141]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.141]                               info, version)
[09:31:13.141]                           }
[09:31:13.141]                           base::stop(msg)
[09:31:13.141]                         }
[09:31:13.141]                       })
[09:31:13.141]                     }
[09:31:13.141]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.141]                     base::options(mc.cores = 1L)
[09:31:13.141]                   }
[09:31:13.141]                   ...future.strategy.old <- future::plan("list")
[09:31:13.141]                   options(future.plan = NULL)
[09:31:13.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.141]                 }
[09:31:13.141]                 ...future.workdir <- getwd()
[09:31:13.141]             }
[09:31:13.141]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.141]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.141]         }
[09:31:13.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.141]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.141]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.141]             base::names(...future.oldOptions))
[09:31:13.141]     }
[09:31:13.141]     if (FALSE) {
[09:31:13.141]     }
[09:31:13.141]     else {
[09:31:13.141]         if (TRUE) {
[09:31:13.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.141]                 open = "w")
[09:31:13.141]         }
[09:31:13.141]         else {
[09:31:13.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.141]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.141]         }
[09:31:13.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.141]             base::sink(type = "output", split = FALSE)
[09:31:13.141]             base::close(...future.stdout)
[09:31:13.141]         }, add = TRUE)
[09:31:13.141]     }
[09:31:13.141]     ...future.frame <- base::sys.nframe()
[09:31:13.141]     ...future.conditions <- base::list()
[09:31:13.141]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.141]     if (FALSE) {
[09:31:13.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.141]     }
[09:31:13.141]     ...future.result <- base::tryCatch({
[09:31:13.141]         base::withCallingHandlers({
[09:31:13.141]             ...future.value <- base::withVisible(base::local({
[09:31:13.141]                 ...future.makeSendCondition <- base::local({
[09:31:13.141]                   sendCondition <- NULL
[09:31:13.141]                   function(frame = 1L) {
[09:31:13.141]                     if (is.function(sendCondition)) 
[09:31:13.141]                       return(sendCondition)
[09:31:13.141]                     ns <- getNamespace("parallel")
[09:31:13.141]                     if (exists("sendData", mode = "function", 
[09:31:13.141]                       envir = ns)) {
[09:31:13.141]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.141]                         envir = ns)
[09:31:13.141]                       envir <- sys.frame(frame)
[09:31:13.141]                       master <- NULL
[09:31:13.141]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.141]                         !identical(envir, emptyenv())) {
[09:31:13.141]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.141]                           inherits = FALSE)) {
[09:31:13.141]                           master <- get("master", mode = "list", 
[09:31:13.141]                             envir = envir, inherits = FALSE)
[09:31:13.141]                           if (inherits(master, c("SOCKnode", 
[09:31:13.141]                             "SOCK0node"))) {
[09:31:13.141]                             sendCondition <<- function(cond) {
[09:31:13.141]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.141]                                 success = TRUE)
[09:31:13.141]                               parallel_sendData(master, data)
[09:31:13.141]                             }
[09:31:13.141]                             return(sendCondition)
[09:31:13.141]                           }
[09:31:13.141]                         }
[09:31:13.141]                         frame <- frame + 1L
[09:31:13.141]                         envir <- sys.frame(frame)
[09:31:13.141]                       }
[09:31:13.141]                     }
[09:31:13.141]                     sendCondition <<- function(cond) NULL
[09:31:13.141]                   }
[09:31:13.141]                 })
[09:31:13.141]                 withCallingHandlers({
[09:31:13.141]                   2
[09:31:13.141]                 }, immediateCondition = function(cond) {
[09:31:13.141]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.141]                   sendCondition(cond)
[09:31:13.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.141]                   {
[09:31:13.141]                     inherits <- base::inherits
[09:31:13.141]                     invokeRestart <- base::invokeRestart
[09:31:13.141]                     is.null <- base::is.null
[09:31:13.141]                     muffled <- FALSE
[09:31:13.141]                     if (inherits(cond, "message")) {
[09:31:13.141]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.141]                       if (muffled) 
[09:31:13.141]                         invokeRestart("muffleMessage")
[09:31:13.141]                     }
[09:31:13.141]                     else if (inherits(cond, "warning")) {
[09:31:13.141]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.141]                       if (muffled) 
[09:31:13.141]                         invokeRestart("muffleWarning")
[09:31:13.141]                     }
[09:31:13.141]                     else if (inherits(cond, "condition")) {
[09:31:13.141]                       if (!is.null(pattern)) {
[09:31:13.141]                         computeRestarts <- base::computeRestarts
[09:31:13.141]                         grepl <- base::grepl
[09:31:13.141]                         restarts <- computeRestarts(cond)
[09:31:13.141]                         for (restart in restarts) {
[09:31:13.141]                           name <- restart$name
[09:31:13.141]                           if (is.null(name)) 
[09:31:13.141]                             next
[09:31:13.141]                           if (!grepl(pattern, name)) 
[09:31:13.141]                             next
[09:31:13.141]                           invokeRestart(restart)
[09:31:13.141]                           muffled <- TRUE
[09:31:13.141]                           break
[09:31:13.141]                         }
[09:31:13.141]                       }
[09:31:13.141]                     }
[09:31:13.141]                     invisible(muffled)
[09:31:13.141]                   }
[09:31:13.141]                   muffleCondition(cond)
[09:31:13.141]                 })
[09:31:13.141]             }))
[09:31:13.141]             future::FutureResult(value = ...future.value$value, 
[09:31:13.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.141]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.141]                     ...future.globalenv.names))
[09:31:13.141]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.141]         }, condition = base::local({
[09:31:13.141]             c <- base::c
[09:31:13.141]             inherits <- base::inherits
[09:31:13.141]             invokeRestart <- base::invokeRestart
[09:31:13.141]             length <- base::length
[09:31:13.141]             list <- base::list
[09:31:13.141]             seq.int <- base::seq.int
[09:31:13.141]             signalCondition <- base::signalCondition
[09:31:13.141]             sys.calls <- base::sys.calls
[09:31:13.141]             `[[` <- base::`[[`
[09:31:13.141]             `+` <- base::`+`
[09:31:13.141]             `<<-` <- base::`<<-`
[09:31:13.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.141]                   3L)]
[09:31:13.141]             }
[09:31:13.141]             function(cond) {
[09:31:13.141]                 is_error <- inherits(cond, "error")
[09:31:13.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.141]                   NULL)
[09:31:13.141]                 if (is_error) {
[09:31:13.141]                   sessionInformation <- function() {
[09:31:13.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.141]                       search = base::search(), system = base::Sys.info())
[09:31:13.141]                   }
[09:31:13.141]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.141]                     cond$call), session = sessionInformation(), 
[09:31:13.141]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.141]                   signalCondition(cond)
[09:31:13.141]                 }
[09:31:13.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.141]                 "immediateCondition"))) {
[09:31:13.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.141]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.141]                   if (TRUE && !signal) {
[09:31:13.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.141]                     {
[09:31:13.141]                       inherits <- base::inherits
[09:31:13.141]                       invokeRestart <- base::invokeRestart
[09:31:13.141]                       is.null <- base::is.null
[09:31:13.141]                       muffled <- FALSE
[09:31:13.141]                       if (inherits(cond, "message")) {
[09:31:13.141]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.141]                         if (muffled) 
[09:31:13.141]                           invokeRestart("muffleMessage")
[09:31:13.141]                       }
[09:31:13.141]                       else if (inherits(cond, "warning")) {
[09:31:13.141]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.141]                         if (muffled) 
[09:31:13.141]                           invokeRestart("muffleWarning")
[09:31:13.141]                       }
[09:31:13.141]                       else if (inherits(cond, "condition")) {
[09:31:13.141]                         if (!is.null(pattern)) {
[09:31:13.141]                           computeRestarts <- base::computeRestarts
[09:31:13.141]                           grepl <- base::grepl
[09:31:13.141]                           restarts <- computeRestarts(cond)
[09:31:13.141]                           for (restart in restarts) {
[09:31:13.141]                             name <- restart$name
[09:31:13.141]                             if (is.null(name)) 
[09:31:13.141]                               next
[09:31:13.141]                             if (!grepl(pattern, name)) 
[09:31:13.141]                               next
[09:31:13.141]                             invokeRestart(restart)
[09:31:13.141]                             muffled <- TRUE
[09:31:13.141]                             break
[09:31:13.141]                           }
[09:31:13.141]                         }
[09:31:13.141]                       }
[09:31:13.141]                       invisible(muffled)
[09:31:13.141]                     }
[09:31:13.141]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.141]                   }
[09:31:13.141]                 }
[09:31:13.141]                 else {
[09:31:13.141]                   if (TRUE) {
[09:31:13.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.141]                     {
[09:31:13.141]                       inherits <- base::inherits
[09:31:13.141]                       invokeRestart <- base::invokeRestart
[09:31:13.141]                       is.null <- base::is.null
[09:31:13.141]                       muffled <- FALSE
[09:31:13.141]                       if (inherits(cond, "message")) {
[09:31:13.141]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.141]                         if (muffled) 
[09:31:13.141]                           invokeRestart("muffleMessage")
[09:31:13.141]                       }
[09:31:13.141]                       else if (inherits(cond, "warning")) {
[09:31:13.141]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.141]                         if (muffled) 
[09:31:13.141]                           invokeRestart("muffleWarning")
[09:31:13.141]                       }
[09:31:13.141]                       else if (inherits(cond, "condition")) {
[09:31:13.141]                         if (!is.null(pattern)) {
[09:31:13.141]                           computeRestarts <- base::computeRestarts
[09:31:13.141]                           grepl <- base::grepl
[09:31:13.141]                           restarts <- computeRestarts(cond)
[09:31:13.141]                           for (restart in restarts) {
[09:31:13.141]                             name <- restart$name
[09:31:13.141]                             if (is.null(name)) 
[09:31:13.141]                               next
[09:31:13.141]                             if (!grepl(pattern, name)) 
[09:31:13.141]                               next
[09:31:13.141]                             invokeRestart(restart)
[09:31:13.141]                             muffled <- TRUE
[09:31:13.141]                             break
[09:31:13.141]                           }
[09:31:13.141]                         }
[09:31:13.141]                       }
[09:31:13.141]                       invisible(muffled)
[09:31:13.141]                     }
[09:31:13.141]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.141]                   }
[09:31:13.141]                 }
[09:31:13.141]             }
[09:31:13.141]         }))
[09:31:13.141]     }, error = function(ex) {
[09:31:13.141]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.141]                 ...future.rng), started = ...future.startTime, 
[09:31:13.141]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.141]             version = "1.8"), class = "FutureResult")
[09:31:13.141]     }, finally = {
[09:31:13.141]         if (!identical(...future.workdir, getwd())) 
[09:31:13.141]             setwd(...future.workdir)
[09:31:13.141]         {
[09:31:13.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.141]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.141]             }
[09:31:13.141]             base::options(...future.oldOptions)
[09:31:13.141]             if (.Platform$OS.type == "windows") {
[09:31:13.141]                 old_names <- names(...future.oldEnvVars)
[09:31:13.141]                 envs <- base::Sys.getenv()
[09:31:13.141]                 names <- names(envs)
[09:31:13.141]                 common <- intersect(names, old_names)
[09:31:13.141]                 added <- setdiff(names, old_names)
[09:31:13.141]                 removed <- setdiff(old_names, names)
[09:31:13.141]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.141]                   envs[common]]
[09:31:13.141]                 NAMES <- toupper(changed)
[09:31:13.141]                 args <- list()
[09:31:13.141]                 for (kk in seq_along(NAMES)) {
[09:31:13.141]                   name <- changed[[kk]]
[09:31:13.141]                   NAME <- NAMES[[kk]]
[09:31:13.141]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.141]                     next
[09:31:13.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.141]                 }
[09:31:13.141]                 NAMES <- toupper(added)
[09:31:13.141]                 for (kk in seq_along(NAMES)) {
[09:31:13.141]                   name <- added[[kk]]
[09:31:13.141]                   NAME <- NAMES[[kk]]
[09:31:13.141]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.141]                     next
[09:31:13.141]                   args[[name]] <- ""
[09:31:13.141]                 }
[09:31:13.141]                 NAMES <- toupper(removed)
[09:31:13.141]                 for (kk in seq_along(NAMES)) {
[09:31:13.141]                   name <- removed[[kk]]
[09:31:13.141]                   NAME <- NAMES[[kk]]
[09:31:13.141]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.141]                     next
[09:31:13.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.141]                 }
[09:31:13.141]                 if (length(args) > 0) 
[09:31:13.141]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.141]             }
[09:31:13.141]             else {
[09:31:13.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.141]             }
[09:31:13.141]             {
[09:31:13.141]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.141]                   0L) {
[09:31:13.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.141]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.141]                   base::options(opts)
[09:31:13.141]                 }
[09:31:13.141]                 {
[09:31:13.141]                   {
[09:31:13.141]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.141]                     NULL
[09:31:13.141]                   }
[09:31:13.141]                   options(future.plan = NULL)
[09:31:13.141]                   if (is.na(NA_character_)) 
[09:31:13.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.141]                     .init = FALSE)
[09:31:13.141]                 }
[09:31:13.141]             }
[09:31:13.141]         }
[09:31:13.141]     })
[09:31:13.141]     if (TRUE) {
[09:31:13.141]         base::sink(type = "output", split = FALSE)
[09:31:13.141]         if (TRUE) {
[09:31:13.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.141]         }
[09:31:13.141]         else {
[09:31:13.141]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.141]         }
[09:31:13.141]         base::close(...future.stdout)
[09:31:13.141]         ...future.stdout <- NULL
[09:31:13.141]     }
[09:31:13.141]     ...future.result$conditions <- ...future.conditions
[09:31:13.141]     ...future.result$finished <- base::Sys.time()
[09:31:13.141]     ...future.result
[09:31:13.141] }
[09:31:13.144] MultisessionFuture started
[09:31:13.144] - Launch lazy future ... done
[09:31:13.144] run() for ‘MultisessionFuture’ ... done
[09:31:13.145] getGlobalsAndPackages() ...
[09:31:13.145] Searching for globals...
[09:31:13.145] 
[09:31:13.146] Searching for globals ... DONE
[09:31:13.146] - globals: [0] <none>
[09:31:13.146] getGlobalsAndPackages() ... DONE
[09:31:13.146] run() for ‘Future’ ...
[09:31:13.146] - state: ‘created’
[09:31:13.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.161] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.161]   - Field: ‘node’
[09:31:13.161]   - Field: ‘label’
[09:31:13.161]   - Field: ‘local’
[09:31:13.161]   - Field: ‘owner’
[09:31:13.161]   - Field: ‘envir’
[09:31:13.161]   - Field: ‘workers’
[09:31:13.162]   - Field: ‘packages’
[09:31:13.162]   - Field: ‘gc’
[09:31:13.162]   - Field: ‘conditions’
[09:31:13.162]   - Field: ‘persistent’
[09:31:13.162]   - Field: ‘expr’
[09:31:13.162]   - Field: ‘uuid’
[09:31:13.162]   - Field: ‘seed’
[09:31:13.162]   - Field: ‘version’
[09:31:13.162]   - Field: ‘result’
[09:31:13.163]   - Field: ‘asynchronous’
[09:31:13.163]   - Field: ‘calls’
[09:31:13.163]   - Field: ‘globals’
[09:31:13.163]   - Field: ‘stdout’
[09:31:13.163]   - Field: ‘earlySignal’
[09:31:13.163]   - Field: ‘lazy’
[09:31:13.163]   - Field: ‘state’
[09:31:13.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.163] - Launch lazy future ...
[09:31:13.164] Packages needed by the future expression (n = 0): <none>
[09:31:13.164] Packages needed by future strategies (n = 0): <none>
[09:31:13.164] {
[09:31:13.164]     {
[09:31:13.164]         {
[09:31:13.164]             ...future.startTime <- base::Sys.time()
[09:31:13.164]             {
[09:31:13.164]                 {
[09:31:13.164]                   {
[09:31:13.164]                     {
[09:31:13.164]                       base::local({
[09:31:13.164]                         has_future <- base::requireNamespace("future", 
[09:31:13.164]                           quietly = TRUE)
[09:31:13.164]                         if (has_future) {
[09:31:13.164]                           ns <- base::getNamespace("future")
[09:31:13.164]                           version <- ns[[".package"]][["version"]]
[09:31:13.164]                           if (is.null(version)) 
[09:31:13.164]                             version <- utils::packageVersion("future")
[09:31:13.164]                         }
[09:31:13.164]                         else {
[09:31:13.164]                           version <- NULL
[09:31:13.164]                         }
[09:31:13.164]                         if (!has_future || version < "1.8.0") {
[09:31:13.164]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.164]                             "", base::R.version$version.string), 
[09:31:13.164]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.164]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.164]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.164]                               "release", "version")], collapse = " "), 
[09:31:13.164]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.164]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.164]                             info)
[09:31:13.164]                           info <- base::paste(info, collapse = "; ")
[09:31:13.164]                           if (!has_future) {
[09:31:13.164]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.164]                               info)
[09:31:13.164]                           }
[09:31:13.164]                           else {
[09:31:13.164]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.164]                               info, version)
[09:31:13.164]                           }
[09:31:13.164]                           base::stop(msg)
[09:31:13.164]                         }
[09:31:13.164]                       })
[09:31:13.164]                     }
[09:31:13.164]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.164]                     base::options(mc.cores = 1L)
[09:31:13.164]                   }
[09:31:13.164]                   ...future.strategy.old <- future::plan("list")
[09:31:13.164]                   options(future.plan = NULL)
[09:31:13.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.164]                 }
[09:31:13.164]                 ...future.workdir <- getwd()
[09:31:13.164]             }
[09:31:13.164]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.164]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.164]         }
[09:31:13.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.164]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.164]             base::names(...future.oldOptions))
[09:31:13.164]     }
[09:31:13.164]     if (FALSE) {
[09:31:13.164]     }
[09:31:13.164]     else {
[09:31:13.164]         if (TRUE) {
[09:31:13.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.164]                 open = "w")
[09:31:13.164]         }
[09:31:13.164]         else {
[09:31:13.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.164]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.164]         }
[09:31:13.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.164]             base::sink(type = "output", split = FALSE)
[09:31:13.164]             base::close(...future.stdout)
[09:31:13.164]         }, add = TRUE)
[09:31:13.164]     }
[09:31:13.164]     ...future.frame <- base::sys.nframe()
[09:31:13.164]     ...future.conditions <- base::list()
[09:31:13.164]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.164]     if (FALSE) {
[09:31:13.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.164]     }
[09:31:13.164]     ...future.result <- base::tryCatch({
[09:31:13.164]         base::withCallingHandlers({
[09:31:13.164]             ...future.value <- base::withVisible(base::local({
[09:31:13.164]                 ...future.makeSendCondition <- base::local({
[09:31:13.164]                   sendCondition <- NULL
[09:31:13.164]                   function(frame = 1L) {
[09:31:13.164]                     if (is.function(sendCondition)) 
[09:31:13.164]                       return(sendCondition)
[09:31:13.164]                     ns <- getNamespace("parallel")
[09:31:13.164]                     if (exists("sendData", mode = "function", 
[09:31:13.164]                       envir = ns)) {
[09:31:13.164]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.164]                         envir = ns)
[09:31:13.164]                       envir <- sys.frame(frame)
[09:31:13.164]                       master <- NULL
[09:31:13.164]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.164]                         !identical(envir, emptyenv())) {
[09:31:13.164]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.164]                           inherits = FALSE)) {
[09:31:13.164]                           master <- get("master", mode = "list", 
[09:31:13.164]                             envir = envir, inherits = FALSE)
[09:31:13.164]                           if (inherits(master, c("SOCKnode", 
[09:31:13.164]                             "SOCK0node"))) {
[09:31:13.164]                             sendCondition <<- function(cond) {
[09:31:13.164]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.164]                                 success = TRUE)
[09:31:13.164]                               parallel_sendData(master, data)
[09:31:13.164]                             }
[09:31:13.164]                             return(sendCondition)
[09:31:13.164]                           }
[09:31:13.164]                         }
[09:31:13.164]                         frame <- frame + 1L
[09:31:13.164]                         envir <- sys.frame(frame)
[09:31:13.164]                       }
[09:31:13.164]                     }
[09:31:13.164]                     sendCondition <<- function(cond) NULL
[09:31:13.164]                   }
[09:31:13.164]                 })
[09:31:13.164]                 withCallingHandlers({
[09:31:13.164]                   NULL
[09:31:13.164]                 }, immediateCondition = function(cond) {
[09:31:13.164]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.164]                   sendCondition(cond)
[09:31:13.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.164]                   {
[09:31:13.164]                     inherits <- base::inherits
[09:31:13.164]                     invokeRestart <- base::invokeRestart
[09:31:13.164]                     is.null <- base::is.null
[09:31:13.164]                     muffled <- FALSE
[09:31:13.164]                     if (inherits(cond, "message")) {
[09:31:13.164]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.164]                       if (muffled) 
[09:31:13.164]                         invokeRestart("muffleMessage")
[09:31:13.164]                     }
[09:31:13.164]                     else if (inherits(cond, "warning")) {
[09:31:13.164]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.164]                       if (muffled) 
[09:31:13.164]                         invokeRestart("muffleWarning")
[09:31:13.164]                     }
[09:31:13.164]                     else if (inherits(cond, "condition")) {
[09:31:13.164]                       if (!is.null(pattern)) {
[09:31:13.164]                         computeRestarts <- base::computeRestarts
[09:31:13.164]                         grepl <- base::grepl
[09:31:13.164]                         restarts <- computeRestarts(cond)
[09:31:13.164]                         for (restart in restarts) {
[09:31:13.164]                           name <- restart$name
[09:31:13.164]                           if (is.null(name)) 
[09:31:13.164]                             next
[09:31:13.164]                           if (!grepl(pattern, name)) 
[09:31:13.164]                             next
[09:31:13.164]                           invokeRestart(restart)
[09:31:13.164]                           muffled <- TRUE
[09:31:13.164]                           break
[09:31:13.164]                         }
[09:31:13.164]                       }
[09:31:13.164]                     }
[09:31:13.164]                     invisible(muffled)
[09:31:13.164]                   }
[09:31:13.164]                   muffleCondition(cond)
[09:31:13.164]                 })
[09:31:13.164]             }))
[09:31:13.164]             future::FutureResult(value = ...future.value$value, 
[09:31:13.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.164]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.164]                     ...future.globalenv.names))
[09:31:13.164]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.164]         }, condition = base::local({
[09:31:13.164]             c <- base::c
[09:31:13.164]             inherits <- base::inherits
[09:31:13.164]             invokeRestart <- base::invokeRestart
[09:31:13.164]             length <- base::length
[09:31:13.164]             list <- base::list
[09:31:13.164]             seq.int <- base::seq.int
[09:31:13.164]             signalCondition <- base::signalCondition
[09:31:13.164]             sys.calls <- base::sys.calls
[09:31:13.164]             `[[` <- base::`[[`
[09:31:13.164]             `+` <- base::`+`
[09:31:13.164]             `<<-` <- base::`<<-`
[09:31:13.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.164]                   3L)]
[09:31:13.164]             }
[09:31:13.164]             function(cond) {
[09:31:13.164]                 is_error <- inherits(cond, "error")
[09:31:13.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.164]                   NULL)
[09:31:13.164]                 if (is_error) {
[09:31:13.164]                   sessionInformation <- function() {
[09:31:13.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.164]                       search = base::search(), system = base::Sys.info())
[09:31:13.164]                   }
[09:31:13.164]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.164]                     cond$call), session = sessionInformation(), 
[09:31:13.164]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.164]                   signalCondition(cond)
[09:31:13.164]                 }
[09:31:13.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.164]                 "immediateCondition"))) {
[09:31:13.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.164]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.164]                   if (TRUE && !signal) {
[09:31:13.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.164]                     {
[09:31:13.164]                       inherits <- base::inherits
[09:31:13.164]                       invokeRestart <- base::invokeRestart
[09:31:13.164]                       is.null <- base::is.null
[09:31:13.164]                       muffled <- FALSE
[09:31:13.164]                       if (inherits(cond, "message")) {
[09:31:13.164]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.164]                         if (muffled) 
[09:31:13.164]                           invokeRestart("muffleMessage")
[09:31:13.164]                       }
[09:31:13.164]                       else if (inherits(cond, "warning")) {
[09:31:13.164]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.164]                         if (muffled) 
[09:31:13.164]                           invokeRestart("muffleWarning")
[09:31:13.164]                       }
[09:31:13.164]                       else if (inherits(cond, "condition")) {
[09:31:13.164]                         if (!is.null(pattern)) {
[09:31:13.164]                           computeRestarts <- base::computeRestarts
[09:31:13.164]                           grepl <- base::grepl
[09:31:13.164]                           restarts <- computeRestarts(cond)
[09:31:13.164]                           for (restart in restarts) {
[09:31:13.164]                             name <- restart$name
[09:31:13.164]                             if (is.null(name)) 
[09:31:13.164]                               next
[09:31:13.164]                             if (!grepl(pattern, name)) 
[09:31:13.164]                               next
[09:31:13.164]                             invokeRestart(restart)
[09:31:13.164]                             muffled <- TRUE
[09:31:13.164]                             break
[09:31:13.164]                           }
[09:31:13.164]                         }
[09:31:13.164]                       }
[09:31:13.164]                       invisible(muffled)
[09:31:13.164]                     }
[09:31:13.164]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.164]                   }
[09:31:13.164]                 }
[09:31:13.164]                 else {
[09:31:13.164]                   if (TRUE) {
[09:31:13.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.164]                     {
[09:31:13.164]                       inherits <- base::inherits
[09:31:13.164]                       invokeRestart <- base::invokeRestart
[09:31:13.164]                       is.null <- base::is.null
[09:31:13.164]                       muffled <- FALSE
[09:31:13.164]                       if (inherits(cond, "message")) {
[09:31:13.164]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.164]                         if (muffled) 
[09:31:13.164]                           invokeRestart("muffleMessage")
[09:31:13.164]                       }
[09:31:13.164]                       else if (inherits(cond, "warning")) {
[09:31:13.164]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.164]                         if (muffled) 
[09:31:13.164]                           invokeRestart("muffleWarning")
[09:31:13.164]                       }
[09:31:13.164]                       else if (inherits(cond, "condition")) {
[09:31:13.164]                         if (!is.null(pattern)) {
[09:31:13.164]                           computeRestarts <- base::computeRestarts
[09:31:13.164]                           grepl <- base::grepl
[09:31:13.164]                           restarts <- computeRestarts(cond)
[09:31:13.164]                           for (restart in restarts) {
[09:31:13.164]                             name <- restart$name
[09:31:13.164]                             if (is.null(name)) 
[09:31:13.164]                               next
[09:31:13.164]                             if (!grepl(pattern, name)) 
[09:31:13.164]                               next
[09:31:13.164]                             invokeRestart(restart)
[09:31:13.164]                             muffled <- TRUE
[09:31:13.164]                             break
[09:31:13.164]                           }
[09:31:13.164]                         }
[09:31:13.164]                       }
[09:31:13.164]                       invisible(muffled)
[09:31:13.164]                     }
[09:31:13.164]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.164]                   }
[09:31:13.164]                 }
[09:31:13.164]             }
[09:31:13.164]         }))
[09:31:13.164]     }, error = function(ex) {
[09:31:13.164]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.164]                 ...future.rng), started = ...future.startTime, 
[09:31:13.164]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.164]             version = "1.8"), class = "FutureResult")
[09:31:13.164]     }, finally = {
[09:31:13.164]         if (!identical(...future.workdir, getwd())) 
[09:31:13.164]             setwd(...future.workdir)
[09:31:13.164]         {
[09:31:13.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.164]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.164]             }
[09:31:13.164]             base::options(...future.oldOptions)
[09:31:13.164]             if (.Platform$OS.type == "windows") {
[09:31:13.164]                 old_names <- names(...future.oldEnvVars)
[09:31:13.164]                 envs <- base::Sys.getenv()
[09:31:13.164]                 names <- names(envs)
[09:31:13.164]                 common <- intersect(names, old_names)
[09:31:13.164]                 added <- setdiff(names, old_names)
[09:31:13.164]                 removed <- setdiff(old_names, names)
[09:31:13.164]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.164]                   envs[common]]
[09:31:13.164]                 NAMES <- toupper(changed)
[09:31:13.164]                 args <- list()
[09:31:13.164]                 for (kk in seq_along(NAMES)) {
[09:31:13.164]                   name <- changed[[kk]]
[09:31:13.164]                   NAME <- NAMES[[kk]]
[09:31:13.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.164]                     next
[09:31:13.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.164]                 }
[09:31:13.164]                 NAMES <- toupper(added)
[09:31:13.164]                 for (kk in seq_along(NAMES)) {
[09:31:13.164]                   name <- added[[kk]]
[09:31:13.164]                   NAME <- NAMES[[kk]]
[09:31:13.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.164]                     next
[09:31:13.164]                   args[[name]] <- ""
[09:31:13.164]                 }
[09:31:13.164]                 NAMES <- toupper(removed)
[09:31:13.164]                 for (kk in seq_along(NAMES)) {
[09:31:13.164]                   name <- removed[[kk]]
[09:31:13.164]                   NAME <- NAMES[[kk]]
[09:31:13.164]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.164]                     next
[09:31:13.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.164]                 }
[09:31:13.164]                 if (length(args) > 0) 
[09:31:13.164]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.164]             }
[09:31:13.164]             else {
[09:31:13.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.164]             }
[09:31:13.164]             {
[09:31:13.164]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.164]                   0L) {
[09:31:13.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.164]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.164]                   base::options(opts)
[09:31:13.164]                 }
[09:31:13.164]                 {
[09:31:13.164]                   {
[09:31:13.164]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.164]                     NULL
[09:31:13.164]                   }
[09:31:13.164]                   options(future.plan = NULL)
[09:31:13.164]                   if (is.na(NA_character_)) 
[09:31:13.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.164]                     .init = FALSE)
[09:31:13.164]                 }
[09:31:13.164]             }
[09:31:13.164]         }
[09:31:13.164]     })
[09:31:13.164]     if (TRUE) {
[09:31:13.164]         base::sink(type = "output", split = FALSE)
[09:31:13.164]         if (TRUE) {
[09:31:13.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.164]         }
[09:31:13.164]         else {
[09:31:13.164]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.164]         }
[09:31:13.164]         base::close(...future.stdout)
[09:31:13.164]         ...future.stdout <- NULL
[09:31:13.164]     }
[09:31:13.164]     ...future.result$conditions <- ...future.conditions
[09:31:13.164]     ...future.result$finished <- base::Sys.time()
[09:31:13.164]     ...future.result
[09:31:13.164] }
[09:31:13.216] MultisessionFuture started
[09:31:13.216] - Launch lazy future ... done
[09:31:13.216] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cbed6690> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc335dd0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cbed6690> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc335dd0> 
 $  : NULL
 $  : NULL
 $  : num 6
[09:31:13.222] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.222] - Validating connection of MultisessionFuture
[09:31:13.222] - received message: FutureResult
[09:31:13.222] - Received FutureResult
[09:31:13.222] - Erased future from FutureRegistry
[09:31:13.223] result() for ClusterFuture ...
[09:31:13.223] - result already collected: FutureResult
[09:31:13.223] result() for ClusterFuture ... done
[09:31:13.223] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:13.234] resolve() on list ...
[09:31:13.235]  recursive: 0
[09:31:13.235]  length: 6
[09:31:13.235]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:13.235] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.235] - nx: 6
[09:31:13.235] - relay: TRUE
[09:31:13.235] - stdout: TRUE
[09:31:13.235] - signal: TRUE
[09:31:13.235] - resignal: FALSE
[09:31:13.236] - force: TRUE
[09:31:13.236] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.236] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.236]  - until=2
[09:31:13.236]  - relaying element #2
[09:31:13.236] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.236] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.236] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.236]  length: 5 (resolved future 1)
[09:31:13.237] Future #2
[09:31:13.237] result() for ClusterFuture ...
[09:31:13.237] - result already collected: FutureResult
[09:31:13.237] result() for ClusterFuture ... done
[09:31:13.237] result() for ClusterFuture ...
[09:31:13.237] - result already collected: FutureResult
[09:31:13.237] result() for ClusterFuture ... done
[09:31:13.237] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:13.238] - nx: 6
[09:31:13.238] - relay: TRUE
[09:31:13.238] - stdout: TRUE
[09:31:13.238] - signal: TRUE
[09:31:13.238] - resignal: FALSE
[09:31:13.238] - force: TRUE
[09:31:13.238] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.238] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.238]  - until=2
[09:31:13.238]  - relaying element #2
[09:31:13.239] result() for ClusterFuture ...
[09:31:13.239] - result already collected: FutureResult
[09:31:13.239] result() for ClusterFuture ... done
[09:31:13.239] result() for ClusterFuture ...
[09:31:13.239] - result already collected: FutureResult
[09:31:13.239] result() for ClusterFuture ... done
[09:31:13.239] result() for ClusterFuture ...
[09:31:13.239] - result already collected: FutureResult
[09:31:13.239] result() for ClusterFuture ... done
[09:31:13.240] result() for ClusterFuture ...
[09:31:13.240] - result already collected: FutureResult
[09:31:13.240] result() for ClusterFuture ... done
[09:31:13.240] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.240] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.240] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:13.240]  length: 4 (resolved future 2)
[09:31:13.248] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.248] - Validating connection of MultisessionFuture
[09:31:13.248] - received message: FutureResult
[09:31:13.249] - Received FutureResult
[09:31:13.249] - Erased future from FutureRegistry
[09:31:13.249] result() for ClusterFuture ...
[09:31:13.249] - result already collected: FutureResult
[09:31:13.249] result() for ClusterFuture ... done
[09:31:13.249] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.249] Future #3
[09:31:13.249] result() for ClusterFuture ...
[09:31:13.249] - result already collected: FutureResult
[09:31:13.250] result() for ClusterFuture ... done
[09:31:13.250] result() for ClusterFuture ...
[09:31:13.250] - result already collected: FutureResult
[09:31:13.250] result() for ClusterFuture ... done
[09:31:13.250] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:13.250] - nx: 6
[09:31:13.250] - relay: TRUE
[09:31:13.250] - stdout: TRUE
[09:31:13.250] - signal: TRUE
[09:31:13.250] - resignal: FALSE
[09:31:13.251] - force: TRUE
[09:31:13.251] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.251] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.251]  - until=3
[09:31:13.251]  - relaying element #3
[09:31:13.251] result() for ClusterFuture ...
[09:31:13.251] - result already collected: FutureResult
[09:31:13.251] result() for ClusterFuture ... done
[09:31:13.251] result() for ClusterFuture ...
[09:31:13.252] - result already collected: FutureResult
[09:31:13.252] result() for ClusterFuture ... done
[09:31:13.252] result() for ClusterFuture ...
[09:31:13.252] - result already collected: FutureResult
[09:31:13.252] result() for ClusterFuture ... done
[09:31:13.252] result() for ClusterFuture ...
[09:31:13.252] - result already collected: FutureResult
[09:31:13.252] result() for ClusterFuture ... done
[09:31:13.252] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.253] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.253] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:13.253]  length: 3 (resolved future 3)
[09:31:13.253] signalConditionsASAP(NULL, pos=4) ...
[09:31:13.253] - nx: 6
[09:31:13.253] - relay: TRUE
[09:31:13.253] - stdout: TRUE
[09:31:13.253] - signal: TRUE
[09:31:13.253] - resignal: FALSE
[09:31:13.254] - force: TRUE
[09:31:13.254] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.254] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.254]  - until=5
[09:31:13.254]  - relaying element #5
[09:31:13.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.254] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.254] signalConditionsASAP(NULL, pos=4) ... done
[09:31:13.254]  length: 2 (resolved future 4)
[09:31:13.255] signalConditionsASAP(NULL, pos=5) ...
[09:31:13.255] - nx: 6
[09:31:13.255] - relay: TRUE
[09:31:13.255] - stdout: TRUE
[09:31:13.255] - signal: TRUE
[09:31:13.255] - resignal: FALSE
[09:31:13.255] - force: TRUE
[09:31:13.255] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.255]  - until=6
[09:31:13.256]  - relaying element #6
[09:31:13.256] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.256] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.256] signalConditionsASAP(NULL, pos=5) ... done
[09:31:13.256]  length: 1 (resolved future 5)
[09:31:13.256] signalConditionsASAP(numeric, pos=6) ...
[09:31:13.256] - nx: 6
[09:31:13.256] - relay: TRUE
[09:31:13.256] - stdout: TRUE
[09:31:13.257] - signal: TRUE
[09:31:13.257] - resignal: FALSE
[09:31:13.257] - force: TRUE
[09:31:13.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.257] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.257]  - until=6
[09:31:13.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.257] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.257] signalConditionsASAP(numeric, pos=6) ... done
[09:31:13.258]  length: 0 (resolved future 6)
[09:31:13.258] Relaying remaining futures
[09:31:13.258] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.258] - nx: 6
[09:31:13.258] - relay: TRUE
[09:31:13.258] - stdout: TRUE
[09:31:13.258] - signal: TRUE
[09:31:13.258] - resignal: FALSE
[09:31:13.258] - force: TRUE
[09:31:13.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.259] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:13.259] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.259] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.259] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.259] resolve() on list ... DONE
[09:31:13.259] result() for ClusterFuture ...
[09:31:13.261] - result already collected: FutureResult
[09:31:13.261] result() for ClusterFuture ... done
[09:31:13.262] result() for ClusterFuture ...
[09:31:13.262] - result already collected: FutureResult
[09:31:13.262] result() for ClusterFuture ... done
[09:31:13.262] result() for ClusterFuture ...
[09:31:13.262] - result already collected: FutureResult
[09:31:13.262] result() for ClusterFuture ... done
[09:31:13.262] result() for ClusterFuture ...
[09:31:13.262] - result already collected: FutureResult
[09:31:13.262] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[09:31:13.264] getGlobalsAndPackages() ...
[09:31:13.264] Searching for globals...
[09:31:13.265] 
[09:31:13.265] Searching for globals ... DONE
[09:31:13.265] - globals: [0] <none>
[09:31:13.265] getGlobalsAndPackages() ... DONE
[09:31:13.265] run() for ‘Future’ ...
[09:31:13.265] - state: ‘created’
[09:31:13.265] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.279] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.279]   - Field: ‘node’
[09:31:13.279]   - Field: ‘label’
[09:31:13.279]   - Field: ‘local’
[09:31:13.280]   - Field: ‘owner’
[09:31:13.280]   - Field: ‘envir’
[09:31:13.280]   - Field: ‘workers’
[09:31:13.280]   - Field: ‘packages’
[09:31:13.280]   - Field: ‘gc’
[09:31:13.280]   - Field: ‘conditions’
[09:31:13.280]   - Field: ‘persistent’
[09:31:13.280]   - Field: ‘expr’
[09:31:13.280]   - Field: ‘uuid’
[09:31:13.280]   - Field: ‘seed’
[09:31:13.280]   - Field: ‘version’
[09:31:13.281]   - Field: ‘result’
[09:31:13.281]   - Field: ‘asynchronous’
[09:31:13.281]   - Field: ‘calls’
[09:31:13.281]   - Field: ‘globals’
[09:31:13.281]   - Field: ‘stdout’
[09:31:13.281]   - Field: ‘earlySignal’
[09:31:13.281]   - Field: ‘lazy’
[09:31:13.281]   - Field: ‘state’
[09:31:13.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.281] - Launch lazy future ...
[09:31:13.282] Packages needed by the future expression (n = 0): <none>
[09:31:13.282] Packages needed by future strategies (n = 0): <none>
[09:31:13.282] {
[09:31:13.282]     {
[09:31:13.282]         {
[09:31:13.282]             ...future.startTime <- base::Sys.time()
[09:31:13.282]             {
[09:31:13.282]                 {
[09:31:13.282]                   {
[09:31:13.282]                     {
[09:31:13.282]                       base::local({
[09:31:13.282]                         has_future <- base::requireNamespace("future", 
[09:31:13.282]                           quietly = TRUE)
[09:31:13.282]                         if (has_future) {
[09:31:13.282]                           ns <- base::getNamespace("future")
[09:31:13.282]                           version <- ns[[".package"]][["version"]]
[09:31:13.282]                           if (is.null(version)) 
[09:31:13.282]                             version <- utils::packageVersion("future")
[09:31:13.282]                         }
[09:31:13.282]                         else {
[09:31:13.282]                           version <- NULL
[09:31:13.282]                         }
[09:31:13.282]                         if (!has_future || version < "1.8.0") {
[09:31:13.282]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.282]                             "", base::R.version$version.string), 
[09:31:13.282]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.282]                               "release", "version")], collapse = " "), 
[09:31:13.282]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.282]                             info)
[09:31:13.282]                           info <- base::paste(info, collapse = "; ")
[09:31:13.282]                           if (!has_future) {
[09:31:13.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.282]                               info)
[09:31:13.282]                           }
[09:31:13.282]                           else {
[09:31:13.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.282]                               info, version)
[09:31:13.282]                           }
[09:31:13.282]                           base::stop(msg)
[09:31:13.282]                         }
[09:31:13.282]                       })
[09:31:13.282]                     }
[09:31:13.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.282]                     base::options(mc.cores = 1L)
[09:31:13.282]                   }
[09:31:13.282]                   ...future.strategy.old <- future::plan("list")
[09:31:13.282]                   options(future.plan = NULL)
[09:31:13.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.282]                 }
[09:31:13.282]                 ...future.workdir <- getwd()
[09:31:13.282]             }
[09:31:13.282]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.282]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.282]         }
[09:31:13.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.282]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.282]             base::names(...future.oldOptions))
[09:31:13.282]     }
[09:31:13.282]     if (FALSE) {
[09:31:13.282]     }
[09:31:13.282]     else {
[09:31:13.282]         if (TRUE) {
[09:31:13.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.282]                 open = "w")
[09:31:13.282]         }
[09:31:13.282]         else {
[09:31:13.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.282]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.282]         }
[09:31:13.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.282]             base::sink(type = "output", split = FALSE)
[09:31:13.282]             base::close(...future.stdout)
[09:31:13.282]         }, add = TRUE)
[09:31:13.282]     }
[09:31:13.282]     ...future.frame <- base::sys.nframe()
[09:31:13.282]     ...future.conditions <- base::list()
[09:31:13.282]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.282]     if (FALSE) {
[09:31:13.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.282]     }
[09:31:13.282]     ...future.result <- base::tryCatch({
[09:31:13.282]         base::withCallingHandlers({
[09:31:13.282]             ...future.value <- base::withVisible(base::local({
[09:31:13.282]                 ...future.makeSendCondition <- base::local({
[09:31:13.282]                   sendCondition <- NULL
[09:31:13.282]                   function(frame = 1L) {
[09:31:13.282]                     if (is.function(sendCondition)) 
[09:31:13.282]                       return(sendCondition)
[09:31:13.282]                     ns <- getNamespace("parallel")
[09:31:13.282]                     if (exists("sendData", mode = "function", 
[09:31:13.282]                       envir = ns)) {
[09:31:13.282]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.282]                         envir = ns)
[09:31:13.282]                       envir <- sys.frame(frame)
[09:31:13.282]                       master <- NULL
[09:31:13.282]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.282]                         !identical(envir, emptyenv())) {
[09:31:13.282]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.282]                           inherits = FALSE)) {
[09:31:13.282]                           master <- get("master", mode = "list", 
[09:31:13.282]                             envir = envir, inherits = FALSE)
[09:31:13.282]                           if (inherits(master, c("SOCKnode", 
[09:31:13.282]                             "SOCK0node"))) {
[09:31:13.282]                             sendCondition <<- function(cond) {
[09:31:13.282]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.282]                                 success = TRUE)
[09:31:13.282]                               parallel_sendData(master, data)
[09:31:13.282]                             }
[09:31:13.282]                             return(sendCondition)
[09:31:13.282]                           }
[09:31:13.282]                         }
[09:31:13.282]                         frame <- frame + 1L
[09:31:13.282]                         envir <- sys.frame(frame)
[09:31:13.282]                       }
[09:31:13.282]                     }
[09:31:13.282]                     sendCondition <<- function(cond) NULL
[09:31:13.282]                   }
[09:31:13.282]                 })
[09:31:13.282]                 withCallingHandlers({
[09:31:13.282]                   2
[09:31:13.282]                 }, immediateCondition = function(cond) {
[09:31:13.282]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.282]                   sendCondition(cond)
[09:31:13.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.282]                   {
[09:31:13.282]                     inherits <- base::inherits
[09:31:13.282]                     invokeRestart <- base::invokeRestart
[09:31:13.282]                     is.null <- base::is.null
[09:31:13.282]                     muffled <- FALSE
[09:31:13.282]                     if (inherits(cond, "message")) {
[09:31:13.282]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.282]                       if (muffled) 
[09:31:13.282]                         invokeRestart("muffleMessage")
[09:31:13.282]                     }
[09:31:13.282]                     else if (inherits(cond, "warning")) {
[09:31:13.282]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.282]                       if (muffled) 
[09:31:13.282]                         invokeRestart("muffleWarning")
[09:31:13.282]                     }
[09:31:13.282]                     else if (inherits(cond, "condition")) {
[09:31:13.282]                       if (!is.null(pattern)) {
[09:31:13.282]                         computeRestarts <- base::computeRestarts
[09:31:13.282]                         grepl <- base::grepl
[09:31:13.282]                         restarts <- computeRestarts(cond)
[09:31:13.282]                         for (restart in restarts) {
[09:31:13.282]                           name <- restart$name
[09:31:13.282]                           if (is.null(name)) 
[09:31:13.282]                             next
[09:31:13.282]                           if (!grepl(pattern, name)) 
[09:31:13.282]                             next
[09:31:13.282]                           invokeRestart(restart)
[09:31:13.282]                           muffled <- TRUE
[09:31:13.282]                           break
[09:31:13.282]                         }
[09:31:13.282]                       }
[09:31:13.282]                     }
[09:31:13.282]                     invisible(muffled)
[09:31:13.282]                   }
[09:31:13.282]                   muffleCondition(cond)
[09:31:13.282]                 })
[09:31:13.282]             }))
[09:31:13.282]             future::FutureResult(value = ...future.value$value, 
[09:31:13.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.282]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.282]                     ...future.globalenv.names))
[09:31:13.282]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.282]         }, condition = base::local({
[09:31:13.282]             c <- base::c
[09:31:13.282]             inherits <- base::inherits
[09:31:13.282]             invokeRestart <- base::invokeRestart
[09:31:13.282]             length <- base::length
[09:31:13.282]             list <- base::list
[09:31:13.282]             seq.int <- base::seq.int
[09:31:13.282]             signalCondition <- base::signalCondition
[09:31:13.282]             sys.calls <- base::sys.calls
[09:31:13.282]             `[[` <- base::`[[`
[09:31:13.282]             `+` <- base::`+`
[09:31:13.282]             `<<-` <- base::`<<-`
[09:31:13.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.282]                   3L)]
[09:31:13.282]             }
[09:31:13.282]             function(cond) {
[09:31:13.282]                 is_error <- inherits(cond, "error")
[09:31:13.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.282]                   NULL)
[09:31:13.282]                 if (is_error) {
[09:31:13.282]                   sessionInformation <- function() {
[09:31:13.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.282]                       search = base::search(), system = base::Sys.info())
[09:31:13.282]                   }
[09:31:13.282]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.282]                     cond$call), session = sessionInformation(), 
[09:31:13.282]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.282]                   signalCondition(cond)
[09:31:13.282]                 }
[09:31:13.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.282]                 "immediateCondition"))) {
[09:31:13.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.282]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.282]                   if (TRUE && !signal) {
[09:31:13.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.282]                     {
[09:31:13.282]                       inherits <- base::inherits
[09:31:13.282]                       invokeRestart <- base::invokeRestart
[09:31:13.282]                       is.null <- base::is.null
[09:31:13.282]                       muffled <- FALSE
[09:31:13.282]                       if (inherits(cond, "message")) {
[09:31:13.282]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.282]                         if (muffled) 
[09:31:13.282]                           invokeRestart("muffleMessage")
[09:31:13.282]                       }
[09:31:13.282]                       else if (inherits(cond, "warning")) {
[09:31:13.282]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.282]                         if (muffled) 
[09:31:13.282]                           invokeRestart("muffleWarning")
[09:31:13.282]                       }
[09:31:13.282]                       else if (inherits(cond, "condition")) {
[09:31:13.282]                         if (!is.null(pattern)) {
[09:31:13.282]                           computeRestarts <- base::computeRestarts
[09:31:13.282]                           grepl <- base::grepl
[09:31:13.282]                           restarts <- computeRestarts(cond)
[09:31:13.282]                           for (restart in restarts) {
[09:31:13.282]                             name <- restart$name
[09:31:13.282]                             if (is.null(name)) 
[09:31:13.282]                               next
[09:31:13.282]                             if (!grepl(pattern, name)) 
[09:31:13.282]                               next
[09:31:13.282]                             invokeRestart(restart)
[09:31:13.282]                             muffled <- TRUE
[09:31:13.282]                             break
[09:31:13.282]                           }
[09:31:13.282]                         }
[09:31:13.282]                       }
[09:31:13.282]                       invisible(muffled)
[09:31:13.282]                     }
[09:31:13.282]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.282]                   }
[09:31:13.282]                 }
[09:31:13.282]                 else {
[09:31:13.282]                   if (TRUE) {
[09:31:13.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.282]                     {
[09:31:13.282]                       inherits <- base::inherits
[09:31:13.282]                       invokeRestart <- base::invokeRestart
[09:31:13.282]                       is.null <- base::is.null
[09:31:13.282]                       muffled <- FALSE
[09:31:13.282]                       if (inherits(cond, "message")) {
[09:31:13.282]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.282]                         if (muffled) 
[09:31:13.282]                           invokeRestart("muffleMessage")
[09:31:13.282]                       }
[09:31:13.282]                       else if (inherits(cond, "warning")) {
[09:31:13.282]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.282]                         if (muffled) 
[09:31:13.282]                           invokeRestart("muffleWarning")
[09:31:13.282]                       }
[09:31:13.282]                       else if (inherits(cond, "condition")) {
[09:31:13.282]                         if (!is.null(pattern)) {
[09:31:13.282]                           computeRestarts <- base::computeRestarts
[09:31:13.282]                           grepl <- base::grepl
[09:31:13.282]                           restarts <- computeRestarts(cond)
[09:31:13.282]                           for (restart in restarts) {
[09:31:13.282]                             name <- restart$name
[09:31:13.282]                             if (is.null(name)) 
[09:31:13.282]                               next
[09:31:13.282]                             if (!grepl(pattern, name)) 
[09:31:13.282]                               next
[09:31:13.282]                             invokeRestart(restart)
[09:31:13.282]                             muffled <- TRUE
[09:31:13.282]                             break
[09:31:13.282]                           }
[09:31:13.282]                         }
[09:31:13.282]                       }
[09:31:13.282]                       invisible(muffled)
[09:31:13.282]                     }
[09:31:13.282]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.282]                   }
[09:31:13.282]                 }
[09:31:13.282]             }
[09:31:13.282]         }))
[09:31:13.282]     }, error = function(ex) {
[09:31:13.282]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.282]                 ...future.rng), started = ...future.startTime, 
[09:31:13.282]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.282]             version = "1.8"), class = "FutureResult")
[09:31:13.282]     }, finally = {
[09:31:13.282]         if (!identical(...future.workdir, getwd())) 
[09:31:13.282]             setwd(...future.workdir)
[09:31:13.282]         {
[09:31:13.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.282]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.282]             }
[09:31:13.282]             base::options(...future.oldOptions)
[09:31:13.282]             if (.Platform$OS.type == "windows") {
[09:31:13.282]                 old_names <- names(...future.oldEnvVars)
[09:31:13.282]                 envs <- base::Sys.getenv()
[09:31:13.282]                 names <- names(envs)
[09:31:13.282]                 common <- intersect(names, old_names)
[09:31:13.282]                 added <- setdiff(names, old_names)
[09:31:13.282]                 removed <- setdiff(old_names, names)
[09:31:13.282]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.282]                   envs[common]]
[09:31:13.282]                 NAMES <- toupper(changed)
[09:31:13.282]                 args <- list()
[09:31:13.282]                 for (kk in seq_along(NAMES)) {
[09:31:13.282]                   name <- changed[[kk]]
[09:31:13.282]                   NAME <- NAMES[[kk]]
[09:31:13.282]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.282]                     next
[09:31:13.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.282]                 }
[09:31:13.282]                 NAMES <- toupper(added)
[09:31:13.282]                 for (kk in seq_along(NAMES)) {
[09:31:13.282]                   name <- added[[kk]]
[09:31:13.282]                   NAME <- NAMES[[kk]]
[09:31:13.282]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.282]                     next
[09:31:13.282]                   args[[name]] <- ""
[09:31:13.282]                 }
[09:31:13.282]                 NAMES <- toupper(removed)
[09:31:13.282]                 for (kk in seq_along(NAMES)) {
[09:31:13.282]                   name <- removed[[kk]]
[09:31:13.282]                   NAME <- NAMES[[kk]]
[09:31:13.282]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.282]                     next
[09:31:13.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.282]                 }
[09:31:13.282]                 if (length(args) > 0) 
[09:31:13.282]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.282]             }
[09:31:13.282]             else {
[09:31:13.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.282]             }
[09:31:13.282]             {
[09:31:13.282]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.282]                   0L) {
[09:31:13.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.282]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.282]                   base::options(opts)
[09:31:13.282]                 }
[09:31:13.282]                 {
[09:31:13.282]                   {
[09:31:13.282]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.282]                     NULL
[09:31:13.282]                   }
[09:31:13.282]                   options(future.plan = NULL)
[09:31:13.282]                   if (is.na(NA_character_)) 
[09:31:13.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.282]                     .init = FALSE)
[09:31:13.282]                 }
[09:31:13.282]             }
[09:31:13.282]         }
[09:31:13.282]     })
[09:31:13.282]     if (TRUE) {
[09:31:13.282]         base::sink(type = "output", split = FALSE)
[09:31:13.282]         if (TRUE) {
[09:31:13.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.282]         }
[09:31:13.282]         else {
[09:31:13.282]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.282]         }
[09:31:13.282]         base::close(...future.stdout)
[09:31:13.282]         ...future.stdout <- NULL
[09:31:13.282]     }
[09:31:13.282]     ...future.result$conditions <- ...future.conditions
[09:31:13.282]     ...future.result$finished <- base::Sys.time()
[09:31:13.282]     ...future.result
[09:31:13.282] }
[09:31:13.285] MultisessionFuture started
[09:31:13.285] - Launch lazy future ... done
[09:31:13.285] run() for ‘MultisessionFuture’ ... done
[09:31:13.285] getGlobalsAndPackages() ...
[09:31:13.286] Searching for globals...
[09:31:13.286] 
[09:31:13.286] Searching for globals ... DONE
[09:31:13.286] - globals: [0] <none>
[09:31:13.286] getGlobalsAndPackages() ... DONE
[09:31:13.287] run() for ‘Future’ ...
[09:31:13.287] - state: ‘created’
[09:31:13.287] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.301] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.302]   - Field: ‘node’
[09:31:13.302]   - Field: ‘label’
[09:31:13.302]   - Field: ‘local’
[09:31:13.302]   - Field: ‘owner’
[09:31:13.302]   - Field: ‘envir’
[09:31:13.302]   - Field: ‘workers’
[09:31:13.302]   - Field: ‘packages’
[09:31:13.302]   - Field: ‘gc’
[09:31:13.302]   - Field: ‘conditions’
[09:31:13.302]   - Field: ‘persistent’
[09:31:13.302]   - Field: ‘expr’
[09:31:13.303]   - Field: ‘uuid’
[09:31:13.303]   - Field: ‘seed’
[09:31:13.303]   - Field: ‘version’
[09:31:13.303]   - Field: ‘result’
[09:31:13.303]   - Field: ‘asynchronous’
[09:31:13.303]   - Field: ‘calls’
[09:31:13.303]   - Field: ‘globals’
[09:31:13.303]   - Field: ‘stdout’
[09:31:13.303]   - Field: ‘earlySignal’
[09:31:13.303]   - Field: ‘lazy’
[09:31:13.303]   - Field: ‘state’
[09:31:13.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.304] - Launch lazy future ...
[09:31:13.304] Packages needed by the future expression (n = 0): <none>
[09:31:13.304] Packages needed by future strategies (n = 0): <none>
[09:31:13.304] {
[09:31:13.304]     {
[09:31:13.304]         {
[09:31:13.304]             ...future.startTime <- base::Sys.time()
[09:31:13.304]             {
[09:31:13.304]                 {
[09:31:13.304]                   {
[09:31:13.304]                     {
[09:31:13.304]                       base::local({
[09:31:13.304]                         has_future <- base::requireNamespace("future", 
[09:31:13.304]                           quietly = TRUE)
[09:31:13.304]                         if (has_future) {
[09:31:13.304]                           ns <- base::getNamespace("future")
[09:31:13.304]                           version <- ns[[".package"]][["version"]]
[09:31:13.304]                           if (is.null(version)) 
[09:31:13.304]                             version <- utils::packageVersion("future")
[09:31:13.304]                         }
[09:31:13.304]                         else {
[09:31:13.304]                           version <- NULL
[09:31:13.304]                         }
[09:31:13.304]                         if (!has_future || version < "1.8.0") {
[09:31:13.304]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.304]                             "", base::R.version$version.string), 
[09:31:13.304]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.304]                               "release", "version")], collapse = " "), 
[09:31:13.304]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.304]                             info)
[09:31:13.304]                           info <- base::paste(info, collapse = "; ")
[09:31:13.304]                           if (!has_future) {
[09:31:13.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.304]                               info)
[09:31:13.304]                           }
[09:31:13.304]                           else {
[09:31:13.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.304]                               info, version)
[09:31:13.304]                           }
[09:31:13.304]                           base::stop(msg)
[09:31:13.304]                         }
[09:31:13.304]                       })
[09:31:13.304]                     }
[09:31:13.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.304]                     base::options(mc.cores = 1L)
[09:31:13.304]                   }
[09:31:13.304]                   ...future.strategy.old <- future::plan("list")
[09:31:13.304]                   options(future.plan = NULL)
[09:31:13.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.304]                 }
[09:31:13.304]                 ...future.workdir <- getwd()
[09:31:13.304]             }
[09:31:13.304]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.304]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.304]         }
[09:31:13.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.304]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.304]             base::names(...future.oldOptions))
[09:31:13.304]     }
[09:31:13.304]     if (FALSE) {
[09:31:13.304]     }
[09:31:13.304]     else {
[09:31:13.304]         if (TRUE) {
[09:31:13.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.304]                 open = "w")
[09:31:13.304]         }
[09:31:13.304]         else {
[09:31:13.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.304]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.304]         }
[09:31:13.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.304]             base::sink(type = "output", split = FALSE)
[09:31:13.304]             base::close(...future.stdout)
[09:31:13.304]         }, add = TRUE)
[09:31:13.304]     }
[09:31:13.304]     ...future.frame <- base::sys.nframe()
[09:31:13.304]     ...future.conditions <- base::list()
[09:31:13.304]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.304]     if (FALSE) {
[09:31:13.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.304]     }
[09:31:13.304]     ...future.result <- base::tryCatch({
[09:31:13.304]         base::withCallingHandlers({
[09:31:13.304]             ...future.value <- base::withVisible(base::local({
[09:31:13.304]                 ...future.makeSendCondition <- base::local({
[09:31:13.304]                   sendCondition <- NULL
[09:31:13.304]                   function(frame = 1L) {
[09:31:13.304]                     if (is.function(sendCondition)) 
[09:31:13.304]                       return(sendCondition)
[09:31:13.304]                     ns <- getNamespace("parallel")
[09:31:13.304]                     if (exists("sendData", mode = "function", 
[09:31:13.304]                       envir = ns)) {
[09:31:13.304]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.304]                         envir = ns)
[09:31:13.304]                       envir <- sys.frame(frame)
[09:31:13.304]                       master <- NULL
[09:31:13.304]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.304]                         !identical(envir, emptyenv())) {
[09:31:13.304]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.304]                           inherits = FALSE)) {
[09:31:13.304]                           master <- get("master", mode = "list", 
[09:31:13.304]                             envir = envir, inherits = FALSE)
[09:31:13.304]                           if (inherits(master, c("SOCKnode", 
[09:31:13.304]                             "SOCK0node"))) {
[09:31:13.304]                             sendCondition <<- function(cond) {
[09:31:13.304]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.304]                                 success = TRUE)
[09:31:13.304]                               parallel_sendData(master, data)
[09:31:13.304]                             }
[09:31:13.304]                             return(sendCondition)
[09:31:13.304]                           }
[09:31:13.304]                         }
[09:31:13.304]                         frame <- frame + 1L
[09:31:13.304]                         envir <- sys.frame(frame)
[09:31:13.304]                       }
[09:31:13.304]                     }
[09:31:13.304]                     sendCondition <<- function(cond) NULL
[09:31:13.304]                   }
[09:31:13.304]                 })
[09:31:13.304]                 withCallingHandlers({
[09:31:13.304]                   NULL
[09:31:13.304]                 }, immediateCondition = function(cond) {
[09:31:13.304]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.304]                   sendCondition(cond)
[09:31:13.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.304]                   {
[09:31:13.304]                     inherits <- base::inherits
[09:31:13.304]                     invokeRestart <- base::invokeRestart
[09:31:13.304]                     is.null <- base::is.null
[09:31:13.304]                     muffled <- FALSE
[09:31:13.304]                     if (inherits(cond, "message")) {
[09:31:13.304]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.304]                       if (muffled) 
[09:31:13.304]                         invokeRestart("muffleMessage")
[09:31:13.304]                     }
[09:31:13.304]                     else if (inherits(cond, "warning")) {
[09:31:13.304]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.304]                       if (muffled) 
[09:31:13.304]                         invokeRestart("muffleWarning")
[09:31:13.304]                     }
[09:31:13.304]                     else if (inherits(cond, "condition")) {
[09:31:13.304]                       if (!is.null(pattern)) {
[09:31:13.304]                         computeRestarts <- base::computeRestarts
[09:31:13.304]                         grepl <- base::grepl
[09:31:13.304]                         restarts <- computeRestarts(cond)
[09:31:13.304]                         for (restart in restarts) {
[09:31:13.304]                           name <- restart$name
[09:31:13.304]                           if (is.null(name)) 
[09:31:13.304]                             next
[09:31:13.304]                           if (!grepl(pattern, name)) 
[09:31:13.304]                             next
[09:31:13.304]                           invokeRestart(restart)
[09:31:13.304]                           muffled <- TRUE
[09:31:13.304]                           break
[09:31:13.304]                         }
[09:31:13.304]                       }
[09:31:13.304]                     }
[09:31:13.304]                     invisible(muffled)
[09:31:13.304]                   }
[09:31:13.304]                   muffleCondition(cond)
[09:31:13.304]                 })
[09:31:13.304]             }))
[09:31:13.304]             future::FutureResult(value = ...future.value$value, 
[09:31:13.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.304]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.304]                     ...future.globalenv.names))
[09:31:13.304]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.304]         }, condition = base::local({
[09:31:13.304]             c <- base::c
[09:31:13.304]             inherits <- base::inherits
[09:31:13.304]             invokeRestart <- base::invokeRestart
[09:31:13.304]             length <- base::length
[09:31:13.304]             list <- base::list
[09:31:13.304]             seq.int <- base::seq.int
[09:31:13.304]             signalCondition <- base::signalCondition
[09:31:13.304]             sys.calls <- base::sys.calls
[09:31:13.304]             `[[` <- base::`[[`
[09:31:13.304]             `+` <- base::`+`
[09:31:13.304]             `<<-` <- base::`<<-`
[09:31:13.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.304]                   3L)]
[09:31:13.304]             }
[09:31:13.304]             function(cond) {
[09:31:13.304]                 is_error <- inherits(cond, "error")
[09:31:13.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.304]                   NULL)
[09:31:13.304]                 if (is_error) {
[09:31:13.304]                   sessionInformation <- function() {
[09:31:13.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.304]                       search = base::search(), system = base::Sys.info())
[09:31:13.304]                   }
[09:31:13.304]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.304]                     cond$call), session = sessionInformation(), 
[09:31:13.304]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.304]                   signalCondition(cond)
[09:31:13.304]                 }
[09:31:13.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.304]                 "immediateCondition"))) {
[09:31:13.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.304]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.304]                   if (TRUE && !signal) {
[09:31:13.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.304]                     {
[09:31:13.304]                       inherits <- base::inherits
[09:31:13.304]                       invokeRestart <- base::invokeRestart
[09:31:13.304]                       is.null <- base::is.null
[09:31:13.304]                       muffled <- FALSE
[09:31:13.304]                       if (inherits(cond, "message")) {
[09:31:13.304]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.304]                         if (muffled) 
[09:31:13.304]                           invokeRestart("muffleMessage")
[09:31:13.304]                       }
[09:31:13.304]                       else if (inherits(cond, "warning")) {
[09:31:13.304]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.304]                         if (muffled) 
[09:31:13.304]                           invokeRestart("muffleWarning")
[09:31:13.304]                       }
[09:31:13.304]                       else if (inherits(cond, "condition")) {
[09:31:13.304]                         if (!is.null(pattern)) {
[09:31:13.304]                           computeRestarts <- base::computeRestarts
[09:31:13.304]                           grepl <- base::grepl
[09:31:13.304]                           restarts <- computeRestarts(cond)
[09:31:13.304]                           for (restart in restarts) {
[09:31:13.304]                             name <- restart$name
[09:31:13.304]                             if (is.null(name)) 
[09:31:13.304]                               next
[09:31:13.304]                             if (!grepl(pattern, name)) 
[09:31:13.304]                               next
[09:31:13.304]                             invokeRestart(restart)
[09:31:13.304]                             muffled <- TRUE
[09:31:13.304]                             break
[09:31:13.304]                           }
[09:31:13.304]                         }
[09:31:13.304]                       }
[09:31:13.304]                       invisible(muffled)
[09:31:13.304]                     }
[09:31:13.304]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.304]                   }
[09:31:13.304]                 }
[09:31:13.304]                 else {
[09:31:13.304]                   if (TRUE) {
[09:31:13.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.304]                     {
[09:31:13.304]                       inherits <- base::inherits
[09:31:13.304]                       invokeRestart <- base::invokeRestart
[09:31:13.304]                       is.null <- base::is.null
[09:31:13.304]                       muffled <- FALSE
[09:31:13.304]                       if (inherits(cond, "message")) {
[09:31:13.304]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.304]                         if (muffled) 
[09:31:13.304]                           invokeRestart("muffleMessage")
[09:31:13.304]                       }
[09:31:13.304]                       else if (inherits(cond, "warning")) {
[09:31:13.304]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.304]                         if (muffled) 
[09:31:13.304]                           invokeRestart("muffleWarning")
[09:31:13.304]                       }
[09:31:13.304]                       else if (inherits(cond, "condition")) {
[09:31:13.304]                         if (!is.null(pattern)) {
[09:31:13.304]                           computeRestarts <- base::computeRestarts
[09:31:13.304]                           grepl <- base::grepl
[09:31:13.304]                           restarts <- computeRestarts(cond)
[09:31:13.304]                           for (restart in restarts) {
[09:31:13.304]                             name <- restart$name
[09:31:13.304]                             if (is.null(name)) 
[09:31:13.304]                               next
[09:31:13.304]                             if (!grepl(pattern, name)) 
[09:31:13.304]                               next
[09:31:13.304]                             invokeRestart(restart)
[09:31:13.304]                             muffled <- TRUE
[09:31:13.304]                             break
[09:31:13.304]                           }
[09:31:13.304]                         }
[09:31:13.304]                       }
[09:31:13.304]                       invisible(muffled)
[09:31:13.304]                     }
[09:31:13.304]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.304]                   }
[09:31:13.304]                 }
[09:31:13.304]             }
[09:31:13.304]         }))
[09:31:13.304]     }, error = function(ex) {
[09:31:13.304]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.304]                 ...future.rng), started = ...future.startTime, 
[09:31:13.304]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.304]             version = "1.8"), class = "FutureResult")
[09:31:13.304]     }, finally = {
[09:31:13.304]         if (!identical(...future.workdir, getwd())) 
[09:31:13.304]             setwd(...future.workdir)
[09:31:13.304]         {
[09:31:13.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.304]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.304]             }
[09:31:13.304]             base::options(...future.oldOptions)
[09:31:13.304]             if (.Platform$OS.type == "windows") {
[09:31:13.304]                 old_names <- names(...future.oldEnvVars)
[09:31:13.304]                 envs <- base::Sys.getenv()
[09:31:13.304]                 names <- names(envs)
[09:31:13.304]                 common <- intersect(names, old_names)
[09:31:13.304]                 added <- setdiff(names, old_names)
[09:31:13.304]                 removed <- setdiff(old_names, names)
[09:31:13.304]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.304]                   envs[common]]
[09:31:13.304]                 NAMES <- toupper(changed)
[09:31:13.304]                 args <- list()
[09:31:13.304]                 for (kk in seq_along(NAMES)) {
[09:31:13.304]                   name <- changed[[kk]]
[09:31:13.304]                   NAME <- NAMES[[kk]]
[09:31:13.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.304]                     next
[09:31:13.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.304]                 }
[09:31:13.304]                 NAMES <- toupper(added)
[09:31:13.304]                 for (kk in seq_along(NAMES)) {
[09:31:13.304]                   name <- added[[kk]]
[09:31:13.304]                   NAME <- NAMES[[kk]]
[09:31:13.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.304]                     next
[09:31:13.304]                   args[[name]] <- ""
[09:31:13.304]                 }
[09:31:13.304]                 NAMES <- toupper(removed)
[09:31:13.304]                 for (kk in seq_along(NAMES)) {
[09:31:13.304]                   name <- removed[[kk]]
[09:31:13.304]                   NAME <- NAMES[[kk]]
[09:31:13.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.304]                     next
[09:31:13.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.304]                 }
[09:31:13.304]                 if (length(args) > 0) 
[09:31:13.304]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.304]             }
[09:31:13.304]             else {
[09:31:13.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.304]             }
[09:31:13.304]             {
[09:31:13.304]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.304]                   0L) {
[09:31:13.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.304]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.304]                   base::options(opts)
[09:31:13.304]                 }
[09:31:13.304]                 {
[09:31:13.304]                   {
[09:31:13.304]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.304]                     NULL
[09:31:13.304]                   }
[09:31:13.304]                   options(future.plan = NULL)
[09:31:13.304]                   if (is.na(NA_character_)) 
[09:31:13.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.304]                     .init = FALSE)
[09:31:13.304]                 }
[09:31:13.304]             }
[09:31:13.304]         }
[09:31:13.304]     })
[09:31:13.304]     if (TRUE) {
[09:31:13.304]         base::sink(type = "output", split = FALSE)
[09:31:13.304]         if (TRUE) {
[09:31:13.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.304]         }
[09:31:13.304]         else {
[09:31:13.304]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.304]         }
[09:31:13.304]         base::close(...future.stdout)
[09:31:13.304]         ...future.stdout <- NULL
[09:31:13.304]     }
[09:31:13.304]     ...future.result$conditions <- ...future.conditions
[09:31:13.304]     ...future.result$finished <- base::Sys.time()
[09:31:13.304]     ...future.result
[09:31:13.304] }
[09:31:13.307] MultisessionFuture started
[09:31:13.307] - Launch lazy future ... done
[09:31:13.307] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb437030> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cabb43e8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb437030> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cabb43e8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[09:31:13.312] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.313] - Validating connection of MultisessionFuture
[09:31:13.313] - received message: FutureResult
[09:31:13.313] - Received FutureResult
[09:31:13.313] - Erased future from FutureRegistry
[09:31:13.313] result() for ClusterFuture ...
[09:31:13.313] - result already collected: FutureResult
[09:31:13.313] result() for ClusterFuture ... done
[09:31:13.313] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.314] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.314] - Validating connection of MultisessionFuture
[09:31:13.314] - received message: FutureResult
[09:31:13.314] - Received FutureResult
[09:31:13.314] - Erased future from FutureRegistry
[09:31:13.314] result() for ClusterFuture ...
[09:31:13.314] - result already collected: FutureResult
[09:31:13.314] result() for ClusterFuture ... done
[09:31:13.315] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:13.316] resolve() on list ...
[09:31:13.316]  recursive: 0
[09:31:13.316]  length: 6
[09:31:13.316]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:13.316] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.317] - nx: 6
[09:31:13.317] - relay: TRUE
[09:31:13.317] - stdout: TRUE
[09:31:13.317] - signal: TRUE
[09:31:13.317] - resignal: FALSE
[09:31:13.317] - force: TRUE
[09:31:13.317] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.317] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.317]  - until=2
[09:31:13.317]  - relaying element #2
[09:31:13.317] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.317] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.318] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.318]  length: 5 (resolved future 1)
[09:31:13.318] Future #2
[09:31:13.318] result() for ClusterFuture ...
[09:31:13.318] - result already collected: FutureResult
[09:31:13.318] result() for ClusterFuture ... done
[09:31:13.318] result() for ClusterFuture ...
[09:31:13.318] - result already collected: FutureResult
[09:31:13.318] result() for ClusterFuture ... done
[09:31:13.318] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:13.318] - nx: 6
[09:31:13.319] - relay: TRUE
[09:31:13.319] - stdout: TRUE
[09:31:13.319] - signal: TRUE
[09:31:13.319] - resignal: FALSE
[09:31:13.319] - force: TRUE
[09:31:13.319] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.319] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.319]  - until=2
[09:31:13.319]  - relaying element #2
[09:31:13.319] result() for ClusterFuture ...
[09:31:13.319] - result already collected: FutureResult
[09:31:13.319] result() for ClusterFuture ... done
[09:31:13.320] result() for ClusterFuture ...
[09:31:13.320] - result already collected: FutureResult
[09:31:13.320] result() for ClusterFuture ... done
[09:31:13.320] result() for ClusterFuture ...
[09:31:13.320] - result already collected: FutureResult
[09:31:13.320] result() for ClusterFuture ... done
[09:31:13.320] result() for ClusterFuture ...
[09:31:13.320] - result already collected: FutureResult
[09:31:13.320] result() for ClusterFuture ... done
[09:31:13.320] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.320] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.321] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:13.321]  length: 4 (resolved future 2)
[09:31:13.321] Future #3
[09:31:13.321] result() for ClusterFuture ...
[09:31:13.321] - result already collected: FutureResult
[09:31:13.321] result() for ClusterFuture ... done
[09:31:13.321] result() for ClusterFuture ...
[09:31:13.321] - result already collected: FutureResult
[09:31:13.321] result() for ClusterFuture ... done
[09:31:13.321] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:13.321] - nx: 6
[09:31:13.322] - relay: TRUE
[09:31:13.322] - stdout: TRUE
[09:31:13.322] - signal: TRUE
[09:31:13.322] - resignal: FALSE
[09:31:13.322] - force: TRUE
[09:31:13.322] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.322] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.322]  - until=3
[09:31:13.322]  - relaying element #3
[09:31:13.322] result() for ClusterFuture ...
[09:31:13.322] - result already collected: FutureResult
[09:31:13.322] result() for ClusterFuture ... done
[09:31:13.323] result() for ClusterFuture ...
[09:31:13.323] - result already collected: FutureResult
[09:31:13.323] result() for ClusterFuture ... done
[09:31:13.323] result() for ClusterFuture ...
[09:31:13.323] - result already collected: FutureResult
[09:31:13.323] result() for ClusterFuture ... done
[09:31:13.323] result() for ClusterFuture ...
[09:31:13.323] - result already collected: FutureResult
[09:31:13.323] result() for ClusterFuture ... done
[09:31:13.323] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.323] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.323] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:13.324]  length: 3 (resolved future 3)
[09:31:13.324] signalConditionsASAP(NULL, pos=4) ...
[09:31:13.324] - nx: 6
[09:31:13.324] - relay: TRUE
[09:31:13.324] - stdout: TRUE
[09:31:13.324] - signal: TRUE
[09:31:13.324] - resignal: FALSE
[09:31:13.324] - force: TRUE
[09:31:13.324] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.324] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.324]  - until=5
[09:31:13.324]  - relaying element #5
[09:31:13.325] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.325] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.325] signalConditionsASAP(NULL, pos=4) ... done
[09:31:13.325]  length: 2 (resolved future 4)
[09:31:13.325] signalConditionsASAP(NULL, pos=5) ...
[09:31:13.325] - nx: 6
[09:31:13.325] - relay: TRUE
[09:31:13.325] - stdout: TRUE
[09:31:13.325] - signal: TRUE
[09:31:13.325] - resignal: FALSE
[09:31:13.325] - force: TRUE
[09:31:13.325] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.326] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.326]  - until=6
[09:31:13.326]  - relaying element #6
[09:31:13.326] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.326] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.326] signalConditionsASAP(NULL, pos=5) ... done
[09:31:13.326]  length: 1 (resolved future 5)
[09:31:13.326] signalConditionsASAP(numeric, pos=6) ...
[09:31:13.326] - nx: 6
[09:31:13.326] - relay: TRUE
[09:31:13.326] - stdout: TRUE
[09:31:13.326] - signal: TRUE
[09:31:13.327] - resignal: FALSE
[09:31:13.327] - force: TRUE
[09:31:13.327] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.327] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.327]  - until=6
[09:31:13.327] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.327] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.327] signalConditionsASAP(numeric, pos=6) ... done
[09:31:13.327]  length: 0 (resolved future 6)
[09:31:13.327] Relaying remaining futures
[09:31:13.327] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.327] - nx: 6
[09:31:13.328] - relay: TRUE
[09:31:13.328] - stdout: TRUE
[09:31:13.328] - signal: TRUE
[09:31:13.328] - resignal: FALSE
[09:31:13.328] - force: TRUE
[09:31:13.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:13.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.328] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.328] resolve() on list ... DONE
[09:31:13.329] result() for ClusterFuture ...
[09:31:13.329] - result already collected: FutureResult
[09:31:13.329] result() for ClusterFuture ... done
[09:31:13.329] result() for ClusterFuture ...
[09:31:13.329] - result already collected: FutureResult
[09:31:13.329] result() for ClusterFuture ... done
[09:31:13.329] result() for ClusterFuture ...
[09:31:13.329] - result already collected: FutureResult
[09:31:13.329] result() for ClusterFuture ... done
[09:31:13.329] result() for ClusterFuture ...
[09:31:13.329] - result already collected: FutureResult
[09:31:13.329] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:13.332] getGlobalsAndPackages() ...
[09:31:13.333] Searching for globals...
[09:31:13.333] 
[09:31:13.333] Searching for globals ... DONE
[09:31:13.333] - globals: [0] <none>
[09:31:13.333] getGlobalsAndPackages() ... DONE
[09:31:13.333] run() for ‘Future’ ...
[09:31:13.333] - state: ‘created’
[09:31:13.334] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.347] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.347]   - Field: ‘node’
[09:31:13.347]   - Field: ‘label’
[09:31:13.347]   - Field: ‘local’
[09:31:13.347]   - Field: ‘owner’
[09:31:13.348]   - Field: ‘envir’
[09:31:13.348]   - Field: ‘workers’
[09:31:13.348]   - Field: ‘packages’
[09:31:13.348]   - Field: ‘gc’
[09:31:13.348]   - Field: ‘conditions’
[09:31:13.348]   - Field: ‘persistent’
[09:31:13.348]   - Field: ‘expr’
[09:31:13.348]   - Field: ‘uuid’
[09:31:13.348]   - Field: ‘seed’
[09:31:13.348]   - Field: ‘version’
[09:31:13.348]   - Field: ‘result’
[09:31:13.349]   - Field: ‘asynchronous’
[09:31:13.349]   - Field: ‘calls’
[09:31:13.349]   - Field: ‘globals’
[09:31:13.349]   - Field: ‘stdout’
[09:31:13.349]   - Field: ‘earlySignal’
[09:31:13.349]   - Field: ‘lazy’
[09:31:13.349]   - Field: ‘state’
[09:31:13.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.349] - Launch lazy future ...
[09:31:13.349] Packages needed by the future expression (n = 0): <none>
[09:31:13.350] Packages needed by future strategies (n = 0): <none>
[09:31:13.350] {
[09:31:13.350]     {
[09:31:13.350]         {
[09:31:13.350]             ...future.startTime <- base::Sys.time()
[09:31:13.350]             {
[09:31:13.350]                 {
[09:31:13.350]                   {
[09:31:13.350]                     {
[09:31:13.350]                       base::local({
[09:31:13.350]                         has_future <- base::requireNamespace("future", 
[09:31:13.350]                           quietly = TRUE)
[09:31:13.350]                         if (has_future) {
[09:31:13.350]                           ns <- base::getNamespace("future")
[09:31:13.350]                           version <- ns[[".package"]][["version"]]
[09:31:13.350]                           if (is.null(version)) 
[09:31:13.350]                             version <- utils::packageVersion("future")
[09:31:13.350]                         }
[09:31:13.350]                         else {
[09:31:13.350]                           version <- NULL
[09:31:13.350]                         }
[09:31:13.350]                         if (!has_future || version < "1.8.0") {
[09:31:13.350]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.350]                             "", base::R.version$version.string), 
[09:31:13.350]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.350]                               "release", "version")], collapse = " "), 
[09:31:13.350]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.350]                             info)
[09:31:13.350]                           info <- base::paste(info, collapse = "; ")
[09:31:13.350]                           if (!has_future) {
[09:31:13.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.350]                               info)
[09:31:13.350]                           }
[09:31:13.350]                           else {
[09:31:13.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.350]                               info, version)
[09:31:13.350]                           }
[09:31:13.350]                           base::stop(msg)
[09:31:13.350]                         }
[09:31:13.350]                       })
[09:31:13.350]                     }
[09:31:13.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.350]                     base::options(mc.cores = 1L)
[09:31:13.350]                   }
[09:31:13.350]                   ...future.strategy.old <- future::plan("list")
[09:31:13.350]                   options(future.plan = NULL)
[09:31:13.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.350]                 }
[09:31:13.350]                 ...future.workdir <- getwd()
[09:31:13.350]             }
[09:31:13.350]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.350]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.350]         }
[09:31:13.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.350]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.350]             base::names(...future.oldOptions))
[09:31:13.350]     }
[09:31:13.350]     if (FALSE) {
[09:31:13.350]     }
[09:31:13.350]     else {
[09:31:13.350]         if (TRUE) {
[09:31:13.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.350]                 open = "w")
[09:31:13.350]         }
[09:31:13.350]         else {
[09:31:13.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.350]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.350]         }
[09:31:13.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.350]             base::sink(type = "output", split = FALSE)
[09:31:13.350]             base::close(...future.stdout)
[09:31:13.350]         }, add = TRUE)
[09:31:13.350]     }
[09:31:13.350]     ...future.frame <- base::sys.nframe()
[09:31:13.350]     ...future.conditions <- base::list()
[09:31:13.350]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.350]     if (FALSE) {
[09:31:13.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.350]     }
[09:31:13.350]     ...future.result <- base::tryCatch({
[09:31:13.350]         base::withCallingHandlers({
[09:31:13.350]             ...future.value <- base::withVisible(base::local({
[09:31:13.350]                 ...future.makeSendCondition <- base::local({
[09:31:13.350]                   sendCondition <- NULL
[09:31:13.350]                   function(frame = 1L) {
[09:31:13.350]                     if (is.function(sendCondition)) 
[09:31:13.350]                       return(sendCondition)
[09:31:13.350]                     ns <- getNamespace("parallel")
[09:31:13.350]                     if (exists("sendData", mode = "function", 
[09:31:13.350]                       envir = ns)) {
[09:31:13.350]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.350]                         envir = ns)
[09:31:13.350]                       envir <- sys.frame(frame)
[09:31:13.350]                       master <- NULL
[09:31:13.350]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.350]                         !identical(envir, emptyenv())) {
[09:31:13.350]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.350]                           inherits = FALSE)) {
[09:31:13.350]                           master <- get("master", mode = "list", 
[09:31:13.350]                             envir = envir, inherits = FALSE)
[09:31:13.350]                           if (inherits(master, c("SOCKnode", 
[09:31:13.350]                             "SOCK0node"))) {
[09:31:13.350]                             sendCondition <<- function(cond) {
[09:31:13.350]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.350]                                 success = TRUE)
[09:31:13.350]                               parallel_sendData(master, data)
[09:31:13.350]                             }
[09:31:13.350]                             return(sendCondition)
[09:31:13.350]                           }
[09:31:13.350]                         }
[09:31:13.350]                         frame <- frame + 1L
[09:31:13.350]                         envir <- sys.frame(frame)
[09:31:13.350]                       }
[09:31:13.350]                     }
[09:31:13.350]                     sendCondition <<- function(cond) NULL
[09:31:13.350]                   }
[09:31:13.350]                 })
[09:31:13.350]                 withCallingHandlers({
[09:31:13.350]                   2
[09:31:13.350]                 }, immediateCondition = function(cond) {
[09:31:13.350]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.350]                   sendCondition(cond)
[09:31:13.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.350]                   {
[09:31:13.350]                     inherits <- base::inherits
[09:31:13.350]                     invokeRestart <- base::invokeRestart
[09:31:13.350]                     is.null <- base::is.null
[09:31:13.350]                     muffled <- FALSE
[09:31:13.350]                     if (inherits(cond, "message")) {
[09:31:13.350]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.350]                       if (muffled) 
[09:31:13.350]                         invokeRestart("muffleMessage")
[09:31:13.350]                     }
[09:31:13.350]                     else if (inherits(cond, "warning")) {
[09:31:13.350]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.350]                       if (muffled) 
[09:31:13.350]                         invokeRestart("muffleWarning")
[09:31:13.350]                     }
[09:31:13.350]                     else if (inherits(cond, "condition")) {
[09:31:13.350]                       if (!is.null(pattern)) {
[09:31:13.350]                         computeRestarts <- base::computeRestarts
[09:31:13.350]                         grepl <- base::grepl
[09:31:13.350]                         restarts <- computeRestarts(cond)
[09:31:13.350]                         for (restart in restarts) {
[09:31:13.350]                           name <- restart$name
[09:31:13.350]                           if (is.null(name)) 
[09:31:13.350]                             next
[09:31:13.350]                           if (!grepl(pattern, name)) 
[09:31:13.350]                             next
[09:31:13.350]                           invokeRestart(restart)
[09:31:13.350]                           muffled <- TRUE
[09:31:13.350]                           break
[09:31:13.350]                         }
[09:31:13.350]                       }
[09:31:13.350]                     }
[09:31:13.350]                     invisible(muffled)
[09:31:13.350]                   }
[09:31:13.350]                   muffleCondition(cond)
[09:31:13.350]                 })
[09:31:13.350]             }))
[09:31:13.350]             future::FutureResult(value = ...future.value$value, 
[09:31:13.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.350]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.350]                     ...future.globalenv.names))
[09:31:13.350]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.350]         }, condition = base::local({
[09:31:13.350]             c <- base::c
[09:31:13.350]             inherits <- base::inherits
[09:31:13.350]             invokeRestart <- base::invokeRestart
[09:31:13.350]             length <- base::length
[09:31:13.350]             list <- base::list
[09:31:13.350]             seq.int <- base::seq.int
[09:31:13.350]             signalCondition <- base::signalCondition
[09:31:13.350]             sys.calls <- base::sys.calls
[09:31:13.350]             `[[` <- base::`[[`
[09:31:13.350]             `+` <- base::`+`
[09:31:13.350]             `<<-` <- base::`<<-`
[09:31:13.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.350]                   3L)]
[09:31:13.350]             }
[09:31:13.350]             function(cond) {
[09:31:13.350]                 is_error <- inherits(cond, "error")
[09:31:13.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.350]                   NULL)
[09:31:13.350]                 if (is_error) {
[09:31:13.350]                   sessionInformation <- function() {
[09:31:13.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.350]                       search = base::search(), system = base::Sys.info())
[09:31:13.350]                   }
[09:31:13.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.350]                     cond$call), session = sessionInformation(), 
[09:31:13.350]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.350]                   signalCondition(cond)
[09:31:13.350]                 }
[09:31:13.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.350]                 "immediateCondition"))) {
[09:31:13.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.350]                   if (TRUE && !signal) {
[09:31:13.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.350]                     {
[09:31:13.350]                       inherits <- base::inherits
[09:31:13.350]                       invokeRestart <- base::invokeRestart
[09:31:13.350]                       is.null <- base::is.null
[09:31:13.350]                       muffled <- FALSE
[09:31:13.350]                       if (inherits(cond, "message")) {
[09:31:13.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.350]                         if (muffled) 
[09:31:13.350]                           invokeRestart("muffleMessage")
[09:31:13.350]                       }
[09:31:13.350]                       else if (inherits(cond, "warning")) {
[09:31:13.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.350]                         if (muffled) 
[09:31:13.350]                           invokeRestart("muffleWarning")
[09:31:13.350]                       }
[09:31:13.350]                       else if (inherits(cond, "condition")) {
[09:31:13.350]                         if (!is.null(pattern)) {
[09:31:13.350]                           computeRestarts <- base::computeRestarts
[09:31:13.350]                           grepl <- base::grepl
[09:31:13.350]                           restarts <- computeRestarts(cond)
[09:31:13.350]                           for (restart in restarts) {
[09:31:13.350]                             name <- restart$name
[09:31:13.350]                             if (is.null(name)) 
[09:31:13.350]                               next
[09:31:13.350]                             if (!grepl(pattern, name)) 
[09:31:13.350]                               next
[09:31:13.350]                             invokeRestart(restart)
[09:31:13.350]                             muffled <- TRUE
[09:31:13.350]                             break
[09:31:13.350]                           }
[09:31:13.350]                         }
[09:31:13.350]                       }
[09:31:13.350]                       invisible(muffled)
[09:31:13.350]                     }
[09:31:13.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.350]                   }
[09:31:13.350]                 }
[09:31:13.350]                 else {
[09:31:13.350]                   if (TRUE) {
[09:31:13.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.350]                     {
[09:31:13.350]                       inherits <- base::inherits
[09:31:13.350]                       invokeRestart <- base::invokeRestart
[09:31:13.350]                       is.null <- base::is.null
[09:31:13.350]                       muffled <- FALSE
[09:31:13.350]                       if (inherits(cond, "message")) {
[09:31:13.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.350]                         if (muffled) 
[09:31:13.350]                           invokeRestart("muffleMessage")
[09:31:13.350]                       }
[09:31:13.350]                       else if (inherits(cond, "warning")) {
[09:31:13.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.350]                         if (muffled) 
[09:31:13.350]                           invokeRestart("muffleWarning")
[09:31:13.350]                       }
[09:31:13.350]                       else if (inherits(cond, "condition")) {
[09:31:13.350]                         if (!is.null(pattern)) {
[09:31:13.350]                           computeRestarts <- base::computeRestarts
[09:31:13.350]                           grepl <- base::grepl
[09:31:13.350]                           restarts <- computeRestarts(cond)
[09:31:13.350]                           for (restart in restarts) {
[09:31:13.350]                             name <- restart$name
[09:31:13.350]                             if (is.null(name)) 
[09:31:13.350]                               next
[09:31:13.350]                             if (!grepl(pattern, name)) 
[09:31:13.350]                               next
[09:31:13.350]                             invokeRestart(restart)
[09:31:13.350]                             muffled <- TRUE
[09:31:13.350]                             break
[09:31:13.350]                           }
[09:31:13.350]                         }
[09:31:13.350]                       }
[09:31:13.350]                       invisible(muffled)
[09:31:13.350]                     }
[09:31:13.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.350]                   }
[09:31:13.350]                 }
[09:31:13.350]             }
[09:31:13.350]         }))
[09:31:13.350]     }, error = function(ex) {
[09:31:13.350]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.350]                 ...future.rng), started = ...future.startTime, 
[09:31:13.350]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.350]             version = "1.8"), class = "FutureResult")
[09:31:13.350]     }, finally = {
[09:31:13.350]         if (!identical(...future.workdir, getwd())) 
[09:31:13.350]             setwd(...future.workdir)
[09:31:13.350]         {
[09:31:13.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.350]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.350]             }
[09:31:13.350]             base::options(...future.oldOptions)
[09:31:13.350]             if (.Platform$OS.type == "windows") {
[09:31:13.350]                 old_names <- names(...future.oldEnvVars)
[09:31:13.350]                 envs <- base::Sys.getenv()
[09:31:13.350]                 names <- names(envs)
[09:31:13.350]                 common <- intersect(names, old_names)
[09:31:13.350]                 added <- setdiff(names, old_names)
[09:31:13.350]                 removed <- setdiff(old_names, names)
[09:31:13.350]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.350]                   envs[common]]
[09:31:13.350]                 NAMES <- toupper(changed)
[09:31:13.350]                 args <- list()
[09:31:13.350]                 for (kk in seq_along(NAMES)) {
[09:31:13.350]                   name <- changed[[kk]]
[09:31:13.350]                   NAME <- NAMES[[kk]]
[09:31:13.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.350]                     next
[09:31:13.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.350]                 }
[09:31:13.350]                 NAMES <- toupper(added)
[09:31:13.350]                 for (kk in seq_along(NAMES)) {
[09:31:13.350]                   name <- added[[kk]]
[09:31:13.350]                   NAME <- NAMES[[kk]]
[09:31:13.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.350]                     next
[09:31:13.350]                   args[[name]] <- ""
[09:31:13.350]                 }
[09:31:13.350]                 NAMES <- toupper(removed)
[09:31:13.350]                 for (kk in seq_along(NAMES)) {
[09:31:13.350]                   name <- removed[[kk]]
[09:31:13.350]                   NAME <- NAMES[[kk]]
[09:31:13.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.350]                     next
[09:31:13.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.350]                 }
[09:31:13.350]                 if (length(args) > 0) 
[09:31:13.350]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.350]             }
[09:31:13.350]             else {
[09:31:13.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.350]             }
[09:31:13.350]             {
[09:31:13.350]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.350]                   0L) {
[09:31:13.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.350]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.350]                   base::options(opts)
[09:31:13.350]                 }
[09:31:13.350]                 {
[09:31:13.350]                   {
[09:31:13.350]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.350]                     NULL
[09:31:13.350]                   }
[09:31:13.350]                   options(future.plan = NULL)
[09:31:13.350]                   if (is.na(NA_character_)) 
[09:31:13.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.350]                     .init = FALSE)
[09:31:13.350]                 }
[09:31:13.350]             }
[09:31:13.350]         }
[09:31:13.350]     })
[09:31:13.350]     if (TRUE) {
[09:31:13.350]         base::sink(type = "output", split = FALSE)
[09:31:13.350]         if (TRUE) {
[09:31:13.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.350]         }
[09:31:13.350]         else {
[09:31:13.350]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.350]         }
[09:31:13.350]         base::close(...future.stdout)
[09:31:13.350]         ...future.stdout <- NULL
[09:31:13.350]     }
[09:31:13.350]     ...future.result$conditions <- ...future.conditions
[09:31:13.350]     ...future.result$finished <- base::Sys.time()
[09:31:13.350]     ...future.result
[09:31:13.350] }
[09:31:13.353] MultisessionFuture started
[09:31:13.353] - Launch lazy future ... done
[09:31:13.353] run() for ‘MultisessionFuture’ ... done
[09:31:13.353] getGlobalsAndPackages() ...
[09:31:13.353] Searching for globals...
[09:31:13.354] 
[09:31:13.354] Searching for globals ... DONE
[09:31:13.354] - globals: [0] <none>
[09:31:13.354] getGlobalsAndPackages() ... DONE
[09:31:13.354] run() for ‘Future’ ...
[09:31:13.354] - state: ‘created’
[09:31:13.354] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.367] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.368]   - Field: ‘node’
[09:31:13.368]   - Field: ‘label’
[09:31:13.368]   - Field: ‘local’
[09:31:13.368]   - Field: ‘owner’
[09:31:13.368]   - Field: ‘envir’
[09:31:13.368]   - Field: ‘workers’
[09:31:13.368]   - Field: ‘packages’
[09:31:13.368]   - Field: ‘gc’
[09:31:13.368]   - Field: ‘conditions’
[09:31:13.368]   - Field: ‘persistent’
[09:31:13.369]   - Field: ‘expr’
[09:31:13.369]   - Field: ‘uuid’
[09:31:13.369]   - Field: ‘seed’
[09:31:13.369]   - Field: ‘version’
[09:31:13.369]   - Field: ‘result’
[09:31:13.369]   - Field: ‘asynchronous’
[09:31:13.369]   - Field: ‘calls’
[09:31:13.369]   - Field: ‘globals’
[09:31:13.369]   - Field: ‘stdout’
[09:31:13.369]   - Field: ‘earlySignal’
[09:31:13.369]   - Field: ‘lazy’
[09:31:13.369]   - Field: ‘state’
[09:31:13.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.370] - Launch lazy future ...
[09:31:13.370] Packages needed by the future expression (n = 0): <none>
[09:31:13.370] Packages needed by future strategies (n = 0): <none>
[09:31:13.370] {
[09:31:13.370]     {
[09:31:13.370]         {
[09:31:13.370]             ...future.startTime <- base::Sys.time()
[09:31:13.370]             {
[09:31:13.370]                 {
[09:31:13.370]                   {
[09:31:13.370]                     {
[09:31:13.370]                       base::local({
[09:31:13.370]                         has_future <- base::requireNamespace("future", 
[09:31:13.370]                           quietly = TRUE)
[09:31:13.370]                         if (has_future) {
[09:31:13.370]                           ns <- base::getNamespace("future")
[09:31:13.370]                           version <- ns[[".package"]][["version"]]
[09:31:13.370]                           if (is.null(version)) 
[09:31:13.370]                             version <- utils::packageVersion("future")
[09:31:13.370]                         }
[09:31:13.370]                         else {
[09:31:13.370]                           version <- NULL
[09:31:13.370]                         }
[09:31:13.370]                         if (!has_future || version < "1.8.0") {
[09:31:13.370]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.370]                             "", base::R.version$version.string), 
[09:31:13.370]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.370]                               "release", "version")], collapse = " "), 
[09:31:13.370]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.370]                             info)
[09:31:13.370]                           info <- base::paste(info, collapse = "; ")
[09:31:13.370]                           if (!has_future) {
[09:31:13.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.370]                               info)
[09:31:13.370]                           }
[09:31:13.370]                           else {
[09:31:13.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.370]                               info, version)
[09:31:13.370]                           }
[09:31:13.370]                           base::stop(msg)
[09:31:13.370]                         }
[09:31:13.370]                       })
[09:31:13.370]                     }
[09:31:13.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.370]                     base::options(mc.cores = 1L)
[09:31:13.370]                   }
[09:31:13.370]                   ...future.strategy.old <- future::plan("list")
[09:31:13.370]                   options(future.plan = NULL)
[09:31:13.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.370]                 }
[09:31:13.370]                 ...future.workdir <- getwd()
[09:31:13.370]             }
[09:31:13.370]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.370]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.370]         }
[09:31:13.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.370]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.370]             base::names(...future.oldOptions))
[09:31:13.370]     }
[09:31:13.370]     if (FALSE) {
[09:31:13.370]     }
[09:31:13.370]     else {
[09:31:13.370]         if (TRUE) {
[09:31:13.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.370]                 open = "w")
[09:31:13.370]         }
[09:31:13.370]         else {
[09:31:13.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.370]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.370]         }
[09:31:13.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.370]             base::sink(type = "output", split = FALSE)
[09:31:13.370]             base::close(...future.stdout)
[09:31:13.370]         }, add = TRUE)
[09:31:13.370]     }
[09:31:13.370]     ...future.frame <- base::sys.nframe()
[09:31:13.370]     ...future.conditions <- base::list()
[09:31:13.370]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.370]     if (FALSE) {
[09:31:13.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.370]     }
[09:31:13.370]     ...future.result <- base::tryCatch({
[09:31:13.370]         base::withCallingHandlers({
[09:31:13.370]             ...future.value <- base::withVisible(base::local({
[09:31:13.370]                 ...future.makeSendCondition <- base::local({
[09:31:13.370]                   sendCondition <- NULL
[09:31:13.370]                   function(frame = 1L) {
[09:31:13.370]                     if (is.function(sendCondition)) 
[09:31:13.370]                       return(sendCondition)
[09:31:13.370]                     ns <- getNamespace("parallel")
[09:31:13.370]                     if (exists("sendData", mode = "function", 
[09:31:13.370]                       envir = ns)) {
[09:31:13.370]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.370]                         envir = ns)
[09:31:13.370]                       envir <- sys.frame(frame)
[09:31:13.370]                       master <- NULL
[09:31:13.370]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.370]                         !identical(envir, emptyenv())) {
[09:31:13.370]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.370]                           inherits = FALSE)) {
[09:31:13.370]                           master <- get("master", mode = "list", 
[09:31:13.370]                             envir = envir, inherits = FALSE)
[09:31:13.370]                           if (inherits(master, c("SOCKnode", 
[09:31:13.370]                             "SOCK0node"))) {
[09:31:13.370]                             sendCondition <<- function(cond) {
[09:31:13.370]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.370]                                 success = TRUE)
[09:31:13.370]                               parallel_sendData(master, data)
[09:31:13.370]                             }
[09:31:13.370]                             return(sendCondition)
[09:31:13.370]                           }
[09:31:13.370]                         }
[09:31:13.370]                         frame <- frame + 1L
[09:31:13.370]                         envir <- sys.frame(frame)
[09:31:13.370]                       }
[09:31:13.370]                     }
[09:31:13.370]                     sendCondition <<- function(cond) NULL
[09:31:13.370]                   }
[09:31:13.370]                 })
[09:31:13.370]                 withCallingHandlers({
[09:31:13.370]                   NULL
[09:31:13.370]                 }, immediateCondition = function(cond) {
[09:31:13.370]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.370]                   sendCondition(cond)
[09:31:13.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.370]                   {
[09:31:13.370]                     inherits <- base::inherits
[09:31:13.370]                     invokeRestart <- base::invokeRestart
[09:31:13.370]                     is.null <- base::is.null
[09:31:13.370]                     muffled <- FALSE
[09:31:13.370]                     if (inherits(cond, "message")) {
[09:31:13.370]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.370]                       if (muffled) 
[09:31:13.370]                         invokeRestart("muffleMessage")
[09:31:13.370]                     }
[09:31:13.370]                     else if (inherits(cond, "warning")) {
[09:31:13.370]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.370]                       if (muffled) 
[09:31:13.370]                         invokeRestart("muffleWarning")
[09:31:13.370]                     }
[09:31:13.370]                     else if (inherits(cond, "condition")) {
[09:31:13.370]                       if (!is.null(pattern)) {
[09:31:13.370]                         computeRestarts <- base::computeRestarts
[09:31:13.370]                         grepl <- base::grepl
[09:31:13.370]                         restarts <- computeRestarts(cond)
[09:31:13.370]                         for (restart in restarts) {
[09:31:13.370]                           name <- restart$name
[09:31:13.370]                           if (is.null(name)) 
[09:31:13.370]                             next
[09:31:13.370]                           if (!grepl(pattern, name)) 
[09:31:13.370]                             next
[09:31:13.370]                           invokeRestart(restart)
[09:31:13.370]                           muffled <- TRUE
[09:31:13.370]                           break
[09:31:13.370]                         }
[09:31:13.370]                       }
[09:31:13.370]                     }
[09:31:13.370]                     invisible(muffled)
[09:31:13.370]                   }
[09:31:13.370]                   muffleCondition(cond)
[09:31:13.370]                 })
[09:31:13.370]             }))
[09:31:13.370]             future::FutureResult(value = ...future.value$value, 
[09:31:13.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.370]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.370]                     ...future.globalenv.names))
[09:31:13.370]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.370]         }, condition = base::local({
[09:31:13.370]             c <- base::c
[09:31:13.370]             inherits <- base::inherits
[09:31:13.370]             invokeRestart <- base::invokeRestart
[09:31:13.370]             length <- base::length
[09:31:13.370]             list <- base::list
[09:31:13.370]             seq.int <- base::seq.int
[09:31:13.370]             signalCondition <- base::signalCondition
[09:31:13.370]             sys.calls <- base::sys.calls
[09:31:13.370]             `[[` <- base::`[[`
[09:31:13.370]             `+` <- base::`+`
[09:31:13.370]             `<<-` <- base::`<<-`
[09:31:13.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.370]                   3L)]
[09:31:13.370]             }
[09:31:13.370]             function(cond) {
[09:31:13.370]                 is_error <- inherits(cond, "error")
[09:31:13.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.370]                   NULL)
[09:31:13.370]                 if (is_error) {
[09:31:13.370]                   sessionInformation <- function() {
[09:31:13.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.370]                       search = base::search(), system = base::Sys.info())
[09:31:13.370]                   }
[09:31:13.370]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.370]                     cond$call), session = sessionInformation(), 
[09:31:13.370]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.370]                   signalCondition(cond)
[09:31:13.370]                 }
[09:31:13.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.370]                 "immediateCondition"))) {
[09:31:13.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.370]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.370]                   if (TRUE && !signal) {
[09:31:13.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.370]                     {
[09:31:13.370]                       inherits <- base::inherits
[09:31:13.370]                       invokeRestart <- base::invokeRestart
[09:31:13.370]                       is.null <- base::is.null
[09:31:13.370]                       muffled <- FALSE
[09:31:13.370]                       if (inherits(cond, "message")) {
[09:31:13.370]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.370]                         if (muffled) 
[09:31:13.370]                           invokeRestart("muffleMessage")
[09:31:13.370]                       }
[09:31:13.370]                       else if (inherits(cond, "warning")) {
[09:31:13.370]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.370]                         if (muffled) 
[09:31:13.370]                           invokeRestart("muffleWarning")
[09:31:13.370]                       }
[09:31:13.370]                       else if (inherits(cond, "condition")) {
[09:31:13.370]                         if (!is.null(pattern)) {
[09:31:13.370]                           computeRestarts <- base::computeRestarts
[09:31:13.370]                           grepl <- base::grepl
[09:31:13.370]                           restarts <- computeRestarts(cond)
[09:31:13.370]                           for (restart in restarts) {
[09:31:13.370]                             name <- restart$name
[09:31:13.370]                             if (is.null(name)) 
[09:31:13.370]                               next
[09:31:13.370]                             if (!grepl(pattern, name)) 
[09:31:13.370]                               next
[09:31:13.370]                             invokeRestart(restart)
[09:31:13.370]                             muffled <- TRUE
[09:31:13.370]                             break
[09:31:13.370]                           }
[09:31:13.370]                         }
[09:31:13.370]                       }
[09:31:13.370]                       invisible(muffled)
[09:31:13.370]                     }
[09:31:13.370]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.370]                   }
[09:31:13.370]                 }
[09:31:13.370]                 else {
[09:31:13.370]                   if (TRUE) {
[09:31:13.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.370]                     {
[09:31:13.370]                       inherits <- base::inherits
[09:31:13.370]                       invokeRestart <- base::invokeRestart
[09:31:13.370]                       is.null <- base::is.null
[09:31:13.370]                       muffled <- FALSE
[09:31:13.370]                       if (inherits(cond, "message")) {
[09:31:13.370]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.370]                         if (muffled) 
[09:31:13.370]                           invokeRestart("muffleMessage")
[09:31:13.370]                       }
[09:31:13.370]                       else if (inherits(cond, "warning")) {
[09:31:13.370]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.370]                         if (muffled) 
[09:31:13.370]                           invokeRestart("muffleWarning")
[09:31:13.370]                       }
[09:31:13.370]                       else if (inherits(cond, "condition")) {
[09:31:13.370]                         if (!is.null(pattern)) {
[09:31:13.370]                           computeRestarts <- base::computeRestarts
[09:31:13.370]                           grepl <- base::grepl
[09:31:13.370]                           restarts <- computeRestarts(cond)
[09:31:13.370]                           for (restart in restarts) {
[09:31:13.370]                             name <- restart$name
[09:31:13.370]                             if (is.null(name)) 
[09:31:13.370]                               next
[09:31:13.370]                             if (!grepl(pattern, name)) 
[09:31:13.370]                               next
[09:31:13.370]                             invokeRestart(restart)
[09:31:13.370]                             muffled <- TRUE
[09:31:13.370]                             break
[09:31:13.370]                           }
[09:31:13.370]                         }
[09:31:13.370]                       }
[09:31:13.370]                       invisible(muffled)
[09:31:13.370]                     }
[09:31:13.370]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.370]                   }
[09:31:13.370]                 }
[09:31:13.370]             }
[09:31:13.370]         }))
[09:31:13.370]     }, error = function(ex) {
[09:31:13.370]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.370]                 ...future.rng), started = ...future.startTime, 
[09:31:13.370]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.370]             version = "1.8"), class = "FutureResult")
[09:31:13.370]     }, finally = {
[09:31:13.370]         if (!identical(...future.workdir, getwd())) 
[09:31:13.370]             setwd(...future.workdir)
[09:31:13.370]         {
[09:31:13.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.370]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.370]             }
[09:31:13.370]             base::options(...future.oldOptions)
[09:31:13.370]             if (.Platform$OS.type == "windows") {
[09:31:13.370]                 old_names <- names(...future.oldEnvVars)
[09:31:13.370]                 envs <- base::Sys.getenv()
[09:31:13.370]                 names <- names(envs)
[09:31:13.370]                 common <- intersect(names, old_names)
[09:31:13.370]                 added <- setdiff(names, old_names)
[09:31:13.370]                 removed <- setdiff(old_names, names)
[09:31:13.370]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.370]                   envs[common]]
[09:31:13.370]                 NAMES <- toupper(changed)
[09:31:13.370]                 args <- list()
[09:31:13.370]                 for (kk in seq_along(NAMES)) {
[09:31:13.370]                   name <- changed[[kk]]
[09:31:13.370]                   NAME <- NAMES[[kk]]
[09:31:13.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.370]                     next
[09:31:13.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.370]                 }
[09:31:13.370]                 NAMES <- toupper(added)
[09:31:13.370]                 for (kk in seq_along(NAMES)) {
[09:31:13.370]                   name <- added[[kk]]
[09:31:13.370]                   NAME <- NAMES[[kk]]
[09:31:13.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.370]                     next
[09:31:13.370]                   args[[name]] <- ""
[09:31:13.370]                 }
[09:31:13.370]                 NAMES <- toupper(removed)
[09:31:13.370]                 for (kk in seq_along(NAMES)) {
[09:31:13.370]                   name <- removed[[kk]]
[09:31:13.370]                   NAME <- NAMES[[kk]]
[09:31:13.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.370]                     next
[09:31:13.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.370]                 }
[09:31:13.370]                 if (length(args) > 0) 
[09:31:13.370]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.370]             }
[09:31:13.370]             else {
[09:31:13.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.370]             }
[09:31:13.370]             {
[09:31:13.370]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.370]                   0L) {
[09:31:13.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.370]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.370]                   base::options(opts)
[09:31:13.370]                 }
[09:31:13.370]                 {
[09:31:13.370]                   {
[09:31:13.370]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.370]                     NULL
[09:31:13.370]                   }
[09:31:13.370]                   options(future.plan = NULL)
[09:31:13.370]                   if (is.na(NA_character_)) 
[09:31:13.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.370]                     .init = FALSE)
[09:31:13.370]                 }
[09:31:13.370]             }
[09:31:13.370]         }
[09:31:13.370]     })
[09:31:13.370]     if (TRUE) {
[09:31:13.370]         base::sink(type = "output", split = FALSE)
[09:31:13.370]         if (TRUE) {
[09:31:13.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.370]         }
[09:31:13.370]         else {
[09:31:13.370]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.370]         }
[09:31:13.370]         base::close(...future.stdout)
[09:31:13.370]         ...future.stdout <- NULL
[09:31:13.370]     }
[09:31:13.370]     ...future.result$conditions <- ...future.conditions
[09:31:13.370]     ...future.result$finished <- base::Sys.time()
[09:31:13.370]     ...future.result
[09:31:13.370] }
[09:31:13.373] MultisessionFuture started
[09:31:13.373] - Launch lazy future ... done
[09:31:13.373] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc5d8428> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc9e4ec0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc5d8428> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cc9e4ec0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[09:31:13.379] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.379] - Validating connection of MultisessionFuture
[09:31:13.379] - received message: FutureResult
[09:31:13.379] - Received FutureResult
[09:31:13.379] - Erased future from FutureRegistry
[09:31:13.379] result() for ClusterFuture ...
[09:31:13.379] - result already collected: FutureResult
[09:31:13.379] result() for ClusterFuture ... done
[09:31:13.379] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.380] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.380] - Validating connection of MultisessionFuture
[09:31:13.380] - received message: FutureResult
[09:31:13.380] - Received FutureResult
[09:31:13.380] - Erased future from FutureRegistry
[09:31:13.381] result() for ClusterFuture ...
[09:31:13.381] - result already collected: FutureResult
[09:31:13.381] result() for ClusterFuture ... done
[09:31:13.381] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:13.384] resolve() on list ...
[09:31:13.384]  recursive: 0
[09:31:13.384]  length: 6
[09:31:13.384]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:13.385] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.385] - nx: 6
[09:31:13.385] - relay: TRUE
[09:31:13.385] - stdout: TRUE
[09:31:13.385] - signal: TRUE
[09:31:13.385] - resignal: FALSE
[09:31:13.385] - force: TRUE
[09:31:13.385] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.385] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.385]  - until=2
[09:31:13.385]  - relaying element #2
[09:31:13.385] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.386] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.386] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.386]  length: 5 (resolved future 1)
[09:31:13.386] Future #2
[09:31:13.386] result() for ClusterFuture ...
[09:31:13.386] - result already collected: FutureResult
[09:31:13.386] result() for ClusterFuture ... done
[09:31:13.386] result() for ClusterFuture ...
[09:31:13.386] - result already collected: FutureResult
[09:31:13.386] result() for ClusterFuture ... done
[09:31:13.386] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:13.386] - nx: 6
[09:31:13.387] - relay: TRUE
[09:31:13.387] - stdout: TRUE
[09:31:13.387] - signal: TRUE
[09:31:13.387] - resignal: FALSE
[09:31:13.387] - force: TRUE
[09:31:13.387] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.387] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.387]  - until=2
[09:31:13.387]  - relaying element #2
[09:31:13.387] result() for ClusterFuture ...
[09:31:13.387] - result already collected: FutureResult
[09:31:13.387] result() for ClusterFuture ... done
[09:31:13.388] result() for ClusterFuture ...
[09:31:13.388] - result already collected: FutureResult
[09:31:13.388] result() for ClusterFuture ... done
[09:31:13.388] result() for ClusterFuture ...
[09:31:13.388] - result already collected: FutureResult
[09:31:13.388] result() for ClusterFuture ... done
[09:31:13.388] result() for ClusterFuture ...
[09:31:13.388] - result already collected: FutureResult
[09:31:13.388] result() for ClusterFuture ... done
[09:31:13.388] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.388] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.388] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:13.389]  length: 4 (resolved future 2)
[09:31:13.389] Future #3
[09:31:13.389] result() for ClusterFuture ...
[09:31:13.389] - result already collected: FutureResult
[09:31:13.389] result() for ClusterFuture ... done
[09:31:13.389] result() for ClusterFuture ...
[09:31:13.389] - result already collected: FutureResult
[09:31:13.389] result() for ClusterFuture ... done
[09:31:13.389] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:13.389] - nx: 6
[09:31:13.389] - relay: TRUE
[09:31:13.390] - stdout: TRUE
[09:31:13.390] - signal: TRUE
[09:31:13.390] - resignal: FALSE
[09:31:13.390] - force: TRUE
[09:31:13.390] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.390] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.390]  - until=3
[09:31:13.390]  - relaying element #3
[09:31:13.390] result() for ClusterFuture ...
[09:31:13.390] - result already collected: FutureResult
[09:31:13.390] result() for ClusterFuture ... done
[09:31:13.390] result() for ClusterFuture ...
[09:31:13.390] - result already collected: FutureResult
[09:31:13.391] result() for ClusterFuture ... done
[09:31:13.391] result() for ClusterFuture ...
[09:31:13.391] - result already collected: FutureResult
[09:31:13.391] result() for ClusterFuture ... done
[09:31:13.391] result() for ClusterFuture ...
[09:31:13.391] - result already collected: FutureResult
[09:31:13.391] result() for ClusterFuture ... done
[09:31:13.391] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.391] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.391] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:13.391]  length: 3 (resolved future 3)
[09:31:13.392] signalConditionsASAP(NULL, pos=4) ...
[09:31:13.392] - nx: 6
[09:31:13.392] - relay: TRUE
[09:31:13.392] - stdout: TRUE
[09:31:13.392] - signal: TRUE
[09:31:13.392] - resignal: FALSE
[09:31:13.392] - force: TRUE
[09:31:13.392] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.392] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.392]  - until=5
[09:31:13.392]  - relaying element #5
[09:31:13.392] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.393] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.393] signalConditionsASAP(NULL, pos=4) ... done
[09:31:13.393]  length: 2 (resolved future 4)
[09:31:13.393] signalConditionsASAP(NULL, pos=5) ...
[09:31:13.393] - nx: 6
[09:31:13.393] - relay: TRUE
[09:31:13.393] - stdout: TRUE
[09:31:13.393] - signal: TRUE
[09:31:13.393] - resignal: FALSE
[09:31:13.393] - force: TRUE
[09:31:13.393] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.393] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.393]  - until=6
[09:31:13.394]  - relaying element #6
[09:31:13.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.394] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.394] signalConditionsASAP(NULL, pos=5) ... done
[09:31:13.394]  length: 1 (resolved future 5)
[09:31:13.394] signalConditionsASAP(numeric, pos=6) ...
[09:31:13.394] - nx: 6
[09:31:13.394] - relay: TRUE
[09:31:13.394] - stdout: TRUE
[09:31:13.394] - signal: TRUE
[09:31:13.394] - resignal: FALSE
[09:31:13.394] - force: TRUE
[09:31:13.394] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.395] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.395]  - until=6
[09:31:13.395] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.395] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.395] signalConditionsASAP(numeric, pos=6) ... done
[09:31:13.395]  length: 0 (resolved future 6)
[09:31:13.395] Relaying remaining futures
[09:31:13.395] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.395] - nx: 6
[09:31:13.395] - relay: TRUE
[09:31:13.395] - stdout: TRUE
[09:31:13.395] - signal: TRUE
[09:31:13.396] - resignal: FALSE
[09:31:13.396] - force: TRUE
[09:31:13.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.396] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:13.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.396] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.396] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.396] resolve() on list ... DONE
[09:31:13.396] result() for ClusterFuture ...
[09:31:13.396] - result already collected: FutureResult
[09:31:13.396] result() for ClusterFuture ... done
[09:31:13.397] result() for ClusterFuture ...
[09:31:13.397] - result already collected: FutureResult
[09:31:13.397] result() for ClusterFuture ... done
[09:31:13.397] result() for ClusterFuture ...
[09:31:13.397] - result already collected: FutureResult
[09:31:13.397] result() for ClusterFuture ... done
[09:31:13.397] result() for ClusterFuture ...
[09:31:13.397] - result already collected: FutureResult
[09:31:13.397] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:13.400] getGlobalsAndPackages() ...
[09:31:13.400] Searching for globals...
[09:31:13.401] 
[09:31:13.401] Searching for globals ... DONE
[09:31:13.401] - globals: [0] <none>
[09:31:13.401] getGlobalsAndPackages() ... DONE
[09:31:13.401] run() for ‘Future’ ...
[09:31:13.401] - state: ‘created’
[09:31:13.401] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.416]   - Field: ‘node’
[09:31:13.416]   - Field: ‘label’
[09:31:13.417]   - Field: ‘local’
[09:31:13.417]   - Field: ‘owner’
[09:31:13.417]   - Field: ‘envir’
[09:31:13.417]   - Field: ‘workers’
[09:31:13.417]   - Field: ‘packages’
[09:31:13.417]   - Field: ‘gc’
[09:31:13.417]   - Field: ‘conditions’
[09:31:13.417]   - Field: ‘persistent’
[09:31:13.417]   - Field: ‘expr’
[09:31:13.417]   - Field: ‘uuid’
[09:31:13.417]   - Field: ‘seed’
[09:31:13.418]   - Field: ‘version’
[09:31:13.418]   - Field: ‘result’
[09:31:13.418]   - Field: ‘asynchronous’
[09:31:13.418]   - Field: ‘calls’
[09:31:13.418]   - Field: ‘globals’
[09:31:13.418]   - Field: ‘stdout’
[09:31:13.418]   - Field: ‘earlySignal’
[09:31:13.418]   - Field: ‘lazy’
[09:31:13.418]   - Field: ‘state’
[09:31:13.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.418] - Launch lazy future ...
[09:31:13.419] Packages needed by the future expression (n = 0): <none>
[09:31:13.419] Packages needed by future strategies (n = 0): <none>
[09:31:13.419] {
[09:31:13.419]     {
[09:31:13.419]         {
[09:31:13.419]             ...future.startTime <- base::Sys.time()
[09:31:13.419]             {
[09:31:13.419]                 {
[09:31:13.419]                   {
[09:31:13.419]                     {
[09:31:13.419]                       base::local({
[09:31:13.419]                         has_future <- base::requireNamespace("future", 
[09:31:13.419]                           quietly = TRUE)
[09:31:13.419]                         if (has_future) {
[09:31:13.419]                           ns <- base::getNamespace("future")
[09:31:13.419]                           version <- ns[[".package"]][["version"]]
[09:31:13.419]                           if (is.null(version)) 
[09:31:13.419]                             version <- utils::packageVersion("future")
[09:31:13.419]                         }
[09:31:13.419]                         else {
[09:31:13.419]                           version <- NULL
[09:31:13.419]                         }
[09:31:13.419]                         if (!has_future || version < "1.8.0") {
[09:31:13.419]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.419]                             "", base::R.version$version.string), 
[09:31:13.419]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.419]                               "release", "version")], collapse = " "), 
[09:31:13.419]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.419]                             info)
[09:31:13.419]                           info <- base::paste(info, collapse = "; ")
[09:31:13.419]                           if (!has_future) {
[09:31:13.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.419]                               info)
[09:31:13.419]                           }
[09:31:13.419]                           else {
[09:31:13.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.419]                               info, version)
[09:31:13.419]                           }
[09:31:13.419]                           base::stop(msg)
[09:31:13.419]                         }
[09:31:13.419]                       })
[09:31:13.419]                     }
[09:31:13.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.419]                     base::options(mc.cores = 1L)
[09:31:13.419]                   }
[09:31:13.419]                   ...future.strategy.old <- future::plan("list")
[09:31:13.419]                   options(future.plan = NULL)
[09:31:13.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.419]                 }
[09:31:13.419]                 ...future.workdir <- getwd()
[09:31:13.419]             }
[09:31:13.419]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.419]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.419]         }
[09:31:13.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.419]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.419]             base::names(...future.oldOptions))
[09:31:13.419]     }
[09:31:13.419]     if (FALSE) {
[09:31:13.419]     }
[09:31:13.419]     else {
[09:31:13.419]         if (TRUE) {
[09:31:13.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.419]                 open = "w")
[09:31:13.419]         }
[09:31:13.419]         else {
[09:31:13.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.419]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.419]         }
[09:31:13.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.419]             base::sink(type = "output", split = FALSE)
[09:31:13.419]             base::close(...future.stdout)
[09:31:13.419]         }, add = TRUE)
[09:31:13.419]     }
[09:31:13.419]     ...future.frame <- base::sys.nframe()
[09:31:13.419]     ...future.conditions <- base::list()
[09:31:13.419]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.419]     if (FALSE) {
[09:31:13.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.419]     }
[09:31:13.419]     ...future.result <- base::tryCatch({
[09:31:13.419]         base::withCallingHandlers({
[09:31:13.419]             ...future.value <- base::withVisible(base::local({
[09:31:13.419]                 ...future.makeSendCondition <- base::local({
[09:31:13.419]                   sendCondition <- NULL
[09:31:13.419]                   function(frame = 1L) {
[09:31:13.419]                     if (is.function(sendCondition)) 
[09:31:13.419]                       return(sendCondition)
[09:31:13.419]                     ns <- getNamespace("parallel")
[09:31:13.419]                     if (exists("sendData", mode = "function", 
[09:31:13.419]                       envir = ns)) {
[09:31:13.419]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.419]                         envir = ns)
[09:31:13.419]                       envir <- sys.frame(frame)
[09:31:13.419]                       master <- NULL
[09:31:13.419]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.419]                         !identical(envir, emptyenv())) {
[09:31:13.419]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.419]                           inherits = FALSE)) {
[09:31:13.419]                           master <- get("master", mode = "list", 
[09:31:13.419]                             envir = envir, inherits = FALSE)
[09:31:13.419]                           if (inherits(master, c("SOCKnode", 
[09:31:13.419]                             "SOCK0node"))) {
[09:31:13.419]                             sendCondition <<- function(cond) {
[09:31:13.419]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.419]                                 success = TRUE)
[09:31:13.419]                               parallel_sendData(master, data)
[09:31:13.419]                             }
[09:31:13.419]                             return(sendCondition)
[09:31:13.419]                           }
[09:31:13.419]                         }
[09:31:13.419]                         frame <- frame + 1L
[09:31:13.419]                         envir <- sys.frame(frame)
[09:31:13.419]                       }
[09:31:13.419]                     }
[09:31:13.419]                     sendCondition <<- function(cond) NULL
[09:31:13.419]                   }
[09:31:13.419]                 })
[09:31:13.419]                 withCallingHandlers({
[09:31:13.419]                   2
[09:31:13.419]                 }, immediateCondition = function(cond) {
[09:31:13.419]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.419]                   sendCondition(cond)
[09:31:13.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.419]                   {
[09:31:13.419]                     inherits <- base::inherits
[09:31:13.419]                     invokeRestart <- base::invokeRestart
[09:31:13.419]                     is.null <- base::is.null
[09:31:13.419]                     muffled <- FALSE
[09:31:13.419]                     if (inherits(cond, "message")) {
[09:31:13.419]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.419]                       if (muffled) 
[09:31:13.419]                         invokeRestart("muffleMessage")
[09:31:13.419]                     }
[09:31:13.419]                     else if (inherits(cond, "warning")) {
[09:31:13.419]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.419]                       if (muffled) 
[09:31:13.419]                         invokeRestart("muffleWarning")
[09:31:13.419]                     }
[09:31:13.419]                     else if (inherits(cond, "condition")) {
[09:31:13.419]                       if (!is.null(pattern)) {
[09:31:13.419]                         computeRestarts <- base::computeRestarts
[09:31:13.419]                         grepl <- base::grepl
[09:31:13.419]                         restarts <- computeRestarts(cond)
[09:31:13.419]                         for (restart in restarts) {
[09:31:13.419]                           name <- restart$name
[09:31:13.419]                           if (is.null(name)) 
[09:31:13.419]                             next
[09:31:13.419]                           if (!grepl(pattern, name)) 
[09:31:13.419]                             next
[09:31:13.419]                           invokeRestart(restart)
[09:31:13.419]                           muffled <- TRUE
[09:31:13.419]                           break
[09:31:13.419]                         }
[09:31:13.419]                       }
[09:31:13.419]                     }
[09:31:13.419]                     invisible(muffled)
[09:31:13.419]                   }
[09:31:13.419]                   muffleCondition(cond)
[09:31:13.419]                 })
[09:31:13.419]             }))
[09:31:13.419]             future::FutureResult(value = ...future.value$value, 
[09:31:13.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.419]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.419]                     ...future.globalenv.names))
[09:31:13.419]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.419]         }, condition = base::local({
[09:31:13.419]             c <- base::c
[09:31:13.419]             inherits <- base::inherits
[09:31:13.419]             invokeRestart <- base::invokeRestart
[09:31:13.419]             length <- base::length
[09:31:13.419]             list <- base::list
[09:31:13.419]             seq.int <- base::seq.int
[09:31:13.419]             signalCondition <- base::signalCondition
[09:31:13.419]             sys.calls <- base::sys.calls
[09:31:13.419]             `[[` <- base::`[[`
[09:31:13.419]             `+` <- base::`+`
[09:31:13.419]             `<<-` <- base::`<<-`
[09:31:13.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.419]                   3L)]
[09:31:13.419]             }
[09:31:13.419]             function(cond) {
[09:31:13.419]                 is_error <- inherits(cond, "error")
[09:31:13.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.419]                   NULL)
[09:31:13.419]                 if (is_error) {
[09:31:13.419]                   sessionInformation <- function() {
[09:31:13.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.419]                       search = base::search(), system = base::Sys.info())
[09:31:13.419]                   }
[09:31:13.419]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.419]                     cond$call), session = sessionInformation(), 
[09:31:13.419]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.419]                   signalCondition(cond)
[09:31:13.419]                 }
[09:31:13.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.419]                 "immediateCondition"))) {
[09:31:13.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.419]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.419]                   if (TRUE && !signal) {
[09:31:13.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.419]                     {
[09:31:13.419]                       inherits <- base::inherits
[09:31:13.419]                       invokeRestart <- base::invokeRestart
[09:31:13.419]                       is.null <- base::is.null
[09:31:13.419]                       muffled <- FALSE
[09:31:13.419]                       if (inherits(cond, "message")) {
[09:31:13.419]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.419]                         if (muffled) 
[09:31:13.419]                           invokeRestart("muffleMessage")
[09:31:13.419]                       }
[09:31:13.419]                       else if (inherits(cond, "warning")) {
[09:31:13.419]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.419]                         if (muffled) 
[09:31:13.419]                           invokeRestart("muffleWarning")
[09:31:13.419]                       }
[09:31:13.419]                       else if (inherits(cond, "condition")) {
[09:31:13.419]                         if (!is.null(pattern)) {
[09:31:13.419]                           computeRestarts <- base::computeRestarts
[09:31:13.419]                           grepl <- base::grepl
[09:31:13.419]                           restarts <- computeRestarts(cond)
[09:31:13.419]                           for (restart in restarts) {
[09:31:13.419]                             name <- restart$name
[09:31:13.419]                             if (is.null(name)) 
[09:31:13.419]                               next
[09:31:13.419]                             if (!grepl(pattern, name)) 
[09:31:13.419]                               next
[09:31:13.419]                             invokeRestart(restart)
[09:31:13.419]                             muffled <- TRUE
[09:31:13.419]                             break
[09:31:13.419]                           }
[09:31:13.419]                         }
[09:31:13.419]                       }
[09:31:13.419]                       invisible(muffled)
[09:31:13.419]                     }
[09:31:13.419]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.419]                   }
[09:31:13.419]                 }
[09:31:13.419]                 else {
[09:31:13.419]                   if (TRUE) {
[09:31:13.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.419]                     {
[09:31:13.419]                       inherits <- base::inherits
[09:31:13.419]                       invokeRestart <- base::invokeRestart
[09:31:13.419]                       is.null <- base::is.null
[09:31:13.419]                       muffled <- FALSE
[09:31:13.419]                       if (inherits(cond, "message")) {
[09:31:13.419]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.419]                         if (muffled) 
[09:31:13.419]                           invokeRestart("muffleMessage")
[09:31:13.419]                       }
[09:31:13.419]                       else if (inherits(cond, "warning")) {
[09:31:13.419]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.419]                         if (muffled) 
[09:31:13.419]                           invokeRestart("muffleWarning")
[09:31:13.419]                       }
[09:31:13.419]                       else if (inherits(cond, "condition")) {
[09:31:13.419]                         if (!is.null(pattern)) {
[09:31:13.419]                           computeRestarts <- base::computeRestarts
[09:31:13.419]                           grepl <- base::grepl
[09:31:13.419]                           restarts <- computeRestarts(cond)
[09:31:13.419]                           for (restart in restarts) {
[09:31:13.419]                             name <- restart$name
[09:31:13.419]                             if (is.null(name)) 
[09:31:13.419]                               next
[09:31:13.419]                             if (!grepl(pattern, name)) 
[09:31:13.419]                               next
[09:31:13.419]                             invokeRestart(restart)
[09:31:13.419]                             muffled <- TRUE
[09:31:13.419]                             break
[09:31:13.419]                           }
[09:31:13.419]                         }
[09:31:13.419]                       }
[09:31:13.419]                       invisible(muffled)
[09:31:13.419]                     }
[09:31:13.419]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.419]                   }
[09:31:13.419]                 }
[09:31:13.419]             }
[09:31:13.419]         }))
[09:31:13.419]     }, error = function(ex) {
[09:31:13.419]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.419]                 ...future.rng), started = ...future.startTime, 
[09:31:13.419]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.419]             version = "1.8"), class = "FutureResult")
[09:31:13.419]     }, finally = {
[09:31:13.419]         if (!identical(...future.workdir, getwd())) 
[09:31:13.419]             setwd(...future.workdir)
[09:31:13.419]         {
[09:31:13.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.419]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.419]             }
[09:31:13.419]             base::options(...future.oldOptions)
[09:31:13.419]             if (.Platform$OS.type == "windows") {
[09:31:13.419]                 old_names <- names(...future.oldEnvVars)
[09:31:13.419]                 envs <- base::Sys.getenv()
[09:31:13.419]                 names <- names(envs)
[09:31:13.419]                 common <- intersect(names, old_names)
[09:31:13.419]                 added <- setdiff(names, old_names)
[09:31:13.419]                 removed <- setdiff(old_names, names)
[09:31:13.419]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.419]                   envs[common]]
[09:31:13.419]                 NAMES <- toupper(changed)
[09:31:13.419]                 args <- list()
[09:31:13.419]                 for (kk in seq_along(NAMES)) {
[09:31:13.419]                   name <- changed[[kk]]
[09:31:13.419]                   NAME <- NAMES[[kk]]
[09:31:13.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.419]                     next
[09:31:13.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.419]                 }
[09:31:13.419]                 NAMES <- toupper(added)
[09:31:13.419]                 for (kk in seq_along(NAMES)) {
[09:31:13.419]                   name <- added[[kk]]
[09:31:13.419]                   NAME <- NAMES[[kk]]
[09:31:13.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.419]                     next
[09:31:13.419]                   args[[name]] <- ""
[09:31:13.419]                 }
[09:31:13.419]                 NAMES <- toupper(removed)
[09:31:13.419]                 for (kk in seq_along(NAMES)) {
[09:31:13.419]                   name <- removed[[kk]]
[09:31:13.419]                   NAME <- NAMES[[kk]]
[09:31:13.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.419]                     next
[09:31:13.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.419]                 }
[09:31:13.419]                 if (length(args) > 0) 
[09:31:13.419]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.419]             }
[09:31:13.419]             else {
[09:31:13.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.419]             }
[09:31:13.419]             {
[09:31:13.419]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.419]                   0L) {
[09:31:13.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.419]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.419]                   base::options(opts)
[09:31:13.419]                 }
[09:31:13.419]                 {
[09:31:13.419]                   {
[09:31:13.419]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.419]                     NULL
[09:31:13.419]                   }
[09:31:13.419]                   options(future.plan = NULL)
[09:31:13.419]                   if (is.na(NA_character_)) 
[09:31:13.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.419]                     .init = FALSE)
[09:31:13.419]                 }
[09:31:13.419]             }
[09:31:13.419]         }
[09:31:13.419]     })
[09:31:13.419]     if (TRUE) {
[09:31:13.419]         base::sink(type = "output", split = FALSE)
[09:31:13.419]         if (TRUE) {
[09:31:13.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.419]         }
[09:31:13.419]         else {
[09:31:13.419]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.419]         }
[09:31:13.419]         base::close(...future.stdout)
[09:31:13.419]         ...future.stdout <- NULL
[09:31:13.419]     }
[09:31:13.419]     ...future.result$conditions <- ...future.conditions
[09:31:13.419]     ...future.result$finished <- base::Sys.time()
[09:31:13.419]     ...future.result
[09:31:13.419] }
[09:31:13.422] MultisessionFuture started
[09:31:13.422] - Launch lazy future ... done
[09:31:13.422] run() for ‘MultisessionFuture’ ... done
[09:31:13.422] getGlobalsAndPackages() ...
[09:31:13.422] Searching for globals...
[09:31:13.423] 
[09:31:13.423] Searching for globals ... DONE
[09:31:13.423] - globals: [0] <none>
[09:31:13.423] getGlobalsAndPackages() ... DONE
[09:31:13.423] run() for ‘Future’ ...
[09:31:13.423] - state: ‘created’
[09:31:13.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.437]   - Field: ‘node’
[09:31:13.437]   - Field: ‘label’
[09:31:13.437]   - Field: ‘local’
[09:31:13.437]   - Field: ‘owner’
[09:31:13.437]   - Field: ‘envir’
[09:31:13.437]   - Field: ‘workers’
[09:31:13.437]   - Field: ‘packages’
[09:31:13.437]   - Field: ‘gc’
[09:31:13.437]   - Field: ‘conditions’
[09:31:13.438]   - Field: ‘persistent’
[09:31:13.438]   - Field: ‘expr’
[09:31:13.438]   - Field: ‘uuid’
[09:31:13.438]   - Field: ‘seed’
[09:31:13.438]   - Field: ‘version’
[09:31:13.438]   - Field: ‘result’
[09:31:13.438]   - Field: ‘asynchronous’
[09:31:13.438]   - Field: ‘calls’
[09:31:13.438]   - Field: ‘globals’
[09:31:13.438]   - Field: ‘stdout’
[09:31:13.438]   - Field: ‘earlySignal’
[09:31:13.438]   - Field: ‘lazy’
[09:31:13.439]   - Field: ‘state’
[09:31:13.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.439] - Launch lazy future ...
[09:31:13.439] Packages needed by the future expression (n = 0): <none>
[09:31:13.439] Packages needed by future strategies (n = 0): <none>
[09:31:13.439] {
[09:31:13.439]     {
[09:31:13.439]         {
[09:31:13.439]             ...future.startTime <- base::Sys.time()
[09:31:13.439]             {
[09:31:13.439]                 {
[09:31:13.439]                   {
[09:31:13.439]                     {
[09:31:13.439]                       base::local({
[09:31:13.439]                         has_future <- base::requireNamespace("future", 
[09:31:13.439]                           quietly = TRUE)
[09:31:13.439]                         if (has_future) {
[09:31:13.439]                           ns <- base::getNamespace("future")
[09:31:13.439]                           version <- ns[[".package"]][["version"]]
[09:31:13.439]                           if (is.null(version)) 
[09:31:13.439]                             version <- utils::packageVersion("future")
[09:31:13.439]                         }
[09:31:13.439]                         else {
[09:31:13.439]                           version <- NULL
[09:31:13.439]                         }
[09:31:13.439]                         if (!has_future || version < "1.8.0") {
[09:31:13.439]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.439]                             "", base::R.version$version.string), 
[09:31:13.439]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.439]                               "release", "version")], collapse = " "), 
[09:31:13.439]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.439]                             info)
[09:31:13.439]                           info <- base::paste(info, collapse = "; ")
[09:31:13.439]                           if (!has_future) {
[09:31:13.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.439]                               info)
[09:31:13.439]                           }
[09:31:13.439]                           else {
[09:31:13.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.439]                               info, version)
[09:31:13.439]                           }
[09:31:13.439]                           base::stop(msg)
[09:31:13.439]                         }
[09:31:13.439]                       })
[09:31:13.439]                     }
[09:31:13.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.439]                     base::options(mc.cores = 1L)
[09:31:13.439]                   }
[09:31:13.439]                   ...future.strategy.old <- future::plan("list")
[09:31:13.439]                   options(future.plan = NULL)
[09:31:13.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.439]                 }
[09:31:13.439]                 ...future.workdir <- getwd()
[09:31:13.439]             }
[09:31:13.439]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.439]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.439]         }
[09:31:13.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.439]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.439]             base::names(...future.oldOptions))
[09:31:13.439]     }
[09:31:13.439]     if (FALSE) {
[09:31:13.439]     }
[09:31:13.439]     else {
[09:31:13.439]         if (TRUE) {
[09:31:13.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.439]                 open = "w")
[09:31:13.439]         }
[09:31:13.439]         else {
[09:31:13.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.439]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.439]         }
[09:31:13.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.439]             base::sink(type = "output", split = FALSE)
[09:31:13.439]             base::close(...future.stdout)
[09:31:13.439]         }, add = TRUE)
[09:31:13.439]     }
[09:31:13.439]     ...future.frame <- base::sys.nframe()
[09:31:13.439]     ...future.conditions <- base::list()
[09:31:13.439]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.439]     if (FALSE) {
[09:31:13.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.439]     }
[09:31:13.439]     ...future.result <- base::tryCatch({
[09:31:13.439]         base::withCallingHandlers({
[09:31:13.439]             ...future.value <- base::withVisible(base::local({
[09:31:13.439]                 ...future.makeSendCondition <- base::local({
[09:31:13.439]                   sendCondition <- NULL
[09:31:13.439]                   function(frame = 1L) {
[09:31:13.439]                     if (is.function(sendCondition)) 
[09:31:13.439]                       return(sendCondition)
[09:31:13.439]                     ns <- getNamespace("parallel")
[09:31:13.439]                     if (exists("sendData", mode = "function", 
[09:31:13.439]                       envir = ns)) {
[09:31:13.439]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.439]                         envir = ns)
[09:31:13.439]                       envir <- sys.frame(frame)
[09:31:13.439]                       master <- NULL
[09:31:13.439]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.439]                         !identical(envir, emptyenv())) {
[09:31:13.439]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.439]                           inherits = FALSE)) {
[09:31:13.439]                           master <- get("master", mode = "list", 
[09:31:13.439]                             envir = envir, inherits = FALSE)
[09:31:13.439]                           if (inherits(master, c("SOCKnode", 
[09:31:13.439]                             "SOCK0node"))) {
[09:31:13.439]                             sendCondition <<- function(cond) {
[09:31:13.439]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.439]                                 success = TRUE)
[09:31:13.439]                               parallel_sendData(master, data)
[09:31:13.439]                             }
[09:31:13.439]                             return(sendCondition)
[09:31:13.439]                           }
[09:31:13.439]                         }
[09:31:13.439]                         frame <- frame + 1L
[09:31:13.439]                         envir <- sys.frame(frame)
[09:31:13.439]                       }
[09:31:13.439]                     }
[09:31:13.439]                     sendCondition <<- function(cond) NULL
[09:31:13.439]                   }
[09:31:13.439]                 })
[09:31:13.439]                 withCallingHandlers({
[09:31:13.439]                   NULL
[09:31:13.439]                 }, immediateCondition = function(cond) {
[09:31:13.439]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.439]                   sendCondition(cond)
[09:31:13.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.439]                   {
[09:31:13.439]                     inherits <- base::inherits
[09:31:13.439]                     invokeRestart <- base::invokeRestart
[09:31:13.439]                     is.null <- base::is.null
[09:31:13.439]                     muffled <- FALSE
[09:31:13.439]                     if (inherits(cond, "message")) {
[09:31:13.439]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.439]                       if (muffled) 
[09:31:13.439]                         invokeRestart("muffleMessage")
[09:31:13.439]                     }
[09:31:13.439]                     else if (inherits(cond, "warning")) {
[09:31:13.439]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.439]                       if (muffled) 
[09:31:13.439]                         invokeRestart("muffleWarning")
[09:31:13.439]                     }
[09:31:13.439]                     else if (inherits(cond, "condition")) {
[09:31:13.439]                       if (!is.null(pattern)) {
[09:31:13.439]                         computeRestarts <- base::computeRestarts
[09:31:13.439]                         grepl <- base::grepl
[09:31:13.439]                         restarts <- computeRestarts(cond)
[09:31:13.439]                         for (restart in restarts) {
[09:31:13.439]                           name <- restart$name
[09:31:13.439]                           if (is.null(name)) 
[09:31:13.439]                             next
[09:31:13.439]                           if (!grepl(pattern, name)) 
[09:31:13.439]                             next
[09:31:13.439]                           invokeRestart(restart)
[09:31:13.439]                           muffled <- TRUE
[09:31:13.439]                           break
[09:31:13.439]                         }
[09:31:13.439]                       }
[09:31:13.439]                     }
[09:31:13.439]                     invisible(muffled)
[09:31:13.439]                   }
[09:31:13.439]                   muffleCondition(cond)
[09:31:13.439]                 })
[09:31:13.439]             }))
[09:31:13.439]             future::FutureResult(value = ...future.value$value, 
[09:31:13.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.439]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.439]                     ...future.globalenv.names))
[09:31:13.439]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.439]         }, condition = base::local({
[09:31:13.439]             c <- base::c
[09:31:13.439]             inherits <- base::inherits
[09:31:13.439]             invokeRestart <- base::invokeRestart
[09:31:13.439]             length <- base::length
[09:31:13.439]             list <- base::list
[09:31:13.439]             seq.int <- base::seq.int
[09:31:13.439]             signalCondition <- base::signalCondition
[09:31:13.439]             sys.calls <- base::sys.calls
[09:31:13.439]             `[[` <- base::`[[`
[09:31:13.439]             `+` <- base::`+`
[09:31:13.439]             `<<-` <- base::`<<-`
[09:31:13.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.439]                   3L)]
[09:31:13.439]             }
[09:31:13.439]             function(cond) {
[09:31:13.439]                 is_error <- inherits(cond, "error")
[09:31:13.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.439]                   NULL)
[09:31:13.439]                 if (is_error) {
[09:31:13.439]                   sessionInformation <- function() {
[09:31:13.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.439]                       search = base::search(), system = base::Sys.info())
[09:31:13.439]                   }
[09:31:13.439]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.439]                     cond$call), session = sessionInformation(), 
[09:31:13.439]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.439]                   signalCondition(cond)
[09:31:13.439]                 }
[09:31:13.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.439]                 "immediateCondition"))) {
[09:31:13.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.439]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.439]                   if (TRUE && !signal) {
[09:31:13.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.439]                     {
[09:31:13.439]                       inherits <- base::inherits
[09:31:13.439]                       invokeRestart <- base::invokeRestart
[09:31:13.439]                       is.null <- base::is.null
[09:31:13.439]                       muffled <- FALSE
[09:31:13.439]                       if (inherits(cond, "message")) {
[09:31:13.439]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.439]                         if (muffled) 
[09:31:13.439]                           invokeRestart("muffleMessage")
[09:31:13.439]                       }
[09:31:13.439]                       else if (inherits(cond, "warning")) {
[09:31:13.439]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.439]                         if (muffled) 
[09:31:13.439]                           invokeRestart("muffleWarning")
[09:31:13.439]                       }
[09:31:13.439]                       else if (inherits(cond, "condition")) {
[09:31:13.439]                         if (!is.null(pattern)) {
[09:31:13.439]                           computeRestarts <- base::computeRestarts
[09:31:13.439]                           grepl <- base::grepl
[09:31:13.439]                           restarts <- computeRestarts(cond)
[09:31:13.439]                           for (restart in restarts) {
[09:31:13.439]                             name <- restart$name
[09:31:13.439]                             if (is.null(name)) 
[09:31:13.439]                               next
[09:31:13.439]                             if (!grepl(pattern, name)) 
[09:31:13.439]                               next
[09:31:13.439]                             invokeRestart(restart)
[09:31:13.439]                             muffled <- TRUE
[09:31:13.439]                             break
[09:31:13.439]                           }
[09:31:13.439]                         }
[09:31:13.439]                       }
[09:31:13.439]                       invisible(muffled)
[09:31:13.439]                     }
[09:31:13.439]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.439]                   }
[09:31:13.439]                 }
[09:31:13.439]                 else {
[09:31:13.439]                   if (TRUE) {
[09:31:13.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.439]                     {
[09:31:13.439]                       inherits <- base::inherits
[09:31:13.439]                       invokeRestart <- base::invokeRestart
[09:31:13.439]                       is.null <- base::is.null
[09:31:13.439]                       muffled <- FALSE
[09:31:13.439]                       if (inherits(cond, "message")) {
[09:31:13.439]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.439]                         if (muffled) 
[09:31:13.439]                           invokeRestart("muffleMessage")
[09:31:13.439]                       }
[09:31:13.439]                       else if (inherits(cond, "warning")) {
[09:31:13.439]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.439]                         if (muffled) 
[09:31:13.439]                           invokeRestart("muffleWarning")
[09:31:13.439]                       }
[09:31:13.439]                       else if (inherits(cond, "condition")) {
[09:31:13.439]                         if (!is.null(pattern)) {
[09:31:13.439]                           computeRestarts <- base::computeRestarts
[09:31:13.439]                           grepl <- base::grepl
[09:31:13.439]                           restarts <- computeRestarts(cond)
[09:31:13.439]                           for (restart in restarts) {
[09:31:13.439]                             name <- restart$name
[09:31:13.439]                             if (is.null(name)) 
[09:31:13.439]                               next
[09:31:13.439]                             if (!grepl(pattern, name)) 
[09:31:13.439]                               next
[09:31:13.439]                             invokeRestart(restart)
[09:31:13.439]                             muffled <- TRUE
[09:31:13.439]                             break
[09:31:13.439]                           }
[09:31:13.439]                         }
[09:31:13.439]                       }
[09:31:13.439]                       invisible(muffled)
[09:31:13.439]                     }
[09:31:13.439]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.439]                   }
[09:31:13.439]                 }
[09:31:13.439]             }
[09:31:13.439]         }))
[09:31:13.439]     }, error = function(ex) {
[09:31:13.439]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.439]                 ...future.rng), started = ...future.startTime, 
[09:31:13.439]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.439]             version = "1.8"), class = "FutureResult")
[09:31:13.439]     }, finally = {
[09:31:13.439]         if (!identical(...future.workdir, getwd())) 
[09:31:13.439]             setwd(...future.workdir)
[09:31:13.439]         {
[09:31:13.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.439]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.439]             }
[09:31:13.439]             base::options(...future.oldOptions)
[09:31:13.439]             if (.Platform$OS.type == "windows") {
[09:31:13.439]                 old_names <- names(...future.oldEnvVars)
[09:31:13.439]                 envs <- base::Sys.getenv()
[09:31:13.439]                 names <- names(envs)
[09:31:13.439]                 common <- intersect(names, old_names)
[09:31:13.439]                 added <- setdiff(names, old_names)
[09:31:13.439]                 removed <- setdiff(old_names, names)
[09:31:13.439]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.439]                   envs[common]]
[09:31:13.439]                 NAMES <- toupper(changed)
[09:31:13.439]                 args <- list()
[09:31:13.439]                 for (kk in seq_along(NAMES)) {
[09:31:13.439]                   name <- changed[[kk]]
[09:31:13.439]                   NAME <- NAMES[[kk]]
[09:31:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.439]                     next
[09:31:13.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.439]                 }
[09:31:13.439]                 NAMES <- toupper(added)
[09:31:13.439]                 for (kk in seq_along(NAMES)) {
[09:31:13.439]                   name <- added[[kk]]
[09:31:13.439]                   NAME <- NAMES[[kk]]
[09:31:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.439]                     next
[09:31:13.439]                   args[[name]] <- ""
[09:31:13.439]                 }
[09:31:13.439]                 NAMES <- toupper(removed)
[09:31:13.439]                 for (kk in seq_along(NAMES)) {
[09:31:13.439]                   name <- removed[[kk]]
[09:31:13.439]                   NAME <- NAMES[[kk]]
[09:31:13.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.439]                     next
[09:31:13.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.439]                 }
[09:31:13.439]                 if (length(args) > 0) 
[09:31:13.439]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.439]             }
[09:31:13.439]             else {
[09:31:13.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.439]             }
[09:31:13.439]             {
[09:31:13.439]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.439]                   0L) {
[09:31:13.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.439]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.439]                   base::options(opts)
[09:31:13.439]                 }
[09:31:13.439]                 {
[09:31:13.439]                   {
[09:31:13.439]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.439]                     NULL
[09:31:13.439]                   }
[09:31:13.439]                   options(future.plan = NULL)
[09:31:13.439]                   if (is.na(NA_character_)) 
[09:31:13.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.439]                     .init = FALSE)
[09:31:13.439]                 }
[09:31:13.439]             }
[09:31:13.439]         }
[09:31:13.439]     })
[09:31:13.439]     if (TRUE) {
[09:31:13.439]         base::sink(type = "output", split = FALSE)
[09:31:13.439]         if (TRUE) {
[09:31:13.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.439]         }
[09:31:13.439]         else {
[09:31:13.439]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.439]         }
[09:31:13.439]         base::close(...future.stdout)
[09:31:13.439]         ...future.stdout <- NULL
[09:31:13.439]     }
[09:31:13.439]     ...future.result$conditions <- ...future.conditions
[09:31:13.439]     ...future.result$finished <- base::Sys.time()
[09:31:13.439]     ...future.result
[09:31:13.439] }
[09:31:13.442] MultisessionFuture started
[09:31:13.442] - Launch lazy future ... done
[09:31:13.443] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8cd5950> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb64ef10> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3c8cd5950> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb64ef10> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:13.448] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.448] - Validating connection of MultisessionFuture
[09:31:13.448] - received message: FutureResult
[09:31:13.448] - Received FutureResult
[09:31:13.448] - Erased future from FutureRegistry
[09:31:13.448] result() for ClusterFuture ...
[09:31:13.449] - result already collected: FutureResult
[09:31:13.449] result() for ClusterFuture ... done
[09:31:13.449] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.449] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.449] - Validating connection of MultisessionFuture
[09:31:13.449] - received message: FutureResult
[09:31:13.449] - Received FutureResult
[09:31:13.450] - Erased future from FutureRegistry
[09:31:13.450] result() for ClusterFuture ...
[09:31:13.450] - result already collected: FutureResult
[09:31:13.450] result() for ClusterFuture ... done
[09:31:13.450] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:13.452] resolve() on list ...
[09:31:13.452]  recursive: 0
[09:31:13.452]  length: 6
[09:31:13.452]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:13.452] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.452] - nx: 6
[09:31:13.452] - relay: TRUE
[09:31:13.452] - stdout: TRUE
[09:31:13.452] - signal: TRUE
[09:31:13.452] - resignal: FALSE
[09:31:13.453] - force: TRUE
[09:31:13.453] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.453] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.453]  - until=2
[09:31:13.453]  - relaying element #2
[09:31:13.453] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.453] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.453] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.453]  length: 5 (resolved future 1)
[09:31:13.453] Future #2
[09:31:13.453] result() for ClusterFuture ...
[09:31:13.454] - result already collected: FutureResult
[09:31:13.454] result() for ClusterFuture ... done
[09:31:13.454] result() for ClusterFuture ...
[09:31:13.454] - result already collected: FutureResult
[09:31:13.454] result() for ClusterFuture ... done
[09:31:13.454] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:13.454] - nx: 6
[09:31:13.454] - relay: TRUE
[09:31:13.454] - stdout: TRUE
[09:31:13.454] - signal: TRUE
[09:31:13.454] - resignal: FALSE
[09:31:13.454] - force: TRUE
[09:31:13.455] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.455] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.455]  - until=2
[09:31:13.455]  - relaying element #2
[09:31:13.455] result() for ClusterFuture ...
[09:31:13.455] - result already collected: FutureResult
[09:31:13.455] result() for ClusterFuture ... done
[09:31:13.455] result() for ClusterFuture ...
[09:31:13.455] - result already collected: FutureResult
[09:31:13.455] result() for ClusterFuture ... done
[09:31:13.455] result() for ClusterFuture ...
[09:31:13.456] - result already collected: FutureResult
[09:31:13.456] result() for ClusterFuture ... done
[09:31:13.456] result() for ClusterFuture ...
[09:31:13.456] - result already collected: FutureResult
[09:31:13.456] result() for ClusterFuture ... done
[09:31:13.456] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.456] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.456] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:13.456]  length: 4 (resolved future 2)
[09:31:13.456] Future #3
[09:31:13.456] result() for ClusterFuture ...
[09:31:13.457] - result already collected: FutureResult
[09:31:13.457] result() for ClusterFuture ... done
[09:31:13.457] result() for ClusterFuture ...
[09:31:13.457] - result already collected: FutureResult
[09:31:13.457] result() for ClusterFuture ... done
[09:31:13.457] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:13.457] - nx: 6
[09:31:13.457] - relay: TRUE
[09:31:13.457] - stdout: TRUE
[09:31:13.457] - signal: TRUE
[09:31:13.457] - resignal: FALSE
[09:31:13.457] - force: TRUE
[09:31:13.458] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.458] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.458]  - until=3
[09:31:13.458]  - relaying element #3
[09:31:13.458] result() for ClusterFuture ...
[09:31:13.458] - result already collected: FutureResult
[09:31:13.458] result() for ClusterFuture ... done
[09:31:13.458] result() for ClusterFuture ...
[09:31:13.458] - result already collected: FutureResult
[09:31:13.458] result() for ClusterFuture ... done
[09:31:13.458] result() for ClusterFuture ...
[09:31:13.458] - result already collected: FutureResult
[09:31:13.459] result() for ClusterFuture ... done
[09:31:13.459] result() for ClusterFuture ...
[09:31:13.459] - result already collected: FutureResult
[09:31:13.459] result() for ClusterFuture ... done
[09:31:13.459] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.459] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.459] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:13.459]  length: 3 (resolved future 3)
[09:31:13.459] signalConditionsASAP(NULL, pos=4) ...
[09:31:13.459] - nx: 6
[09:31:13.459] - relay: TRUE
[09:31:13.459] - stdout: TRUE
[09:31:13.460] - signal: TRUE
[09:31:13.460] - resignal: FALSE
[09:31:13.460] - force: TRUE
[09:31:13.460] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.460] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.460]  - until=5
[09:31:13.460]  - relaying element #5
[09:31:13.460] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.460] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.460] signalConditionsASAP(NULL, pos=4) ... done
[09:31:13.460]  length: 2 (resolved future 4)
[09:31:13.460] signalConditionsASAP(NULL, pos=5) ...
[09:31:13.461] - nx: 6
[09:31:13.461] - relay: TRUE
[09:31:13.461] - stdout: TRUE
[09:31:13.461] - signal: TRUE
[09:31:13.461] - resignal: FALSE
[09:31:13.461] - force: TRUE
[09:31:13.461] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.461] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.461]  - until=6
[09:31:13.461]  - relaying element #6
[09:31:13.461] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.461] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.462] signalConditionsASAP(NULL, pos=5) ... done
[09:31:13.462]  length: 1 (resolved future 5)
[09:31:13.462] signalConditionsASAP(numeric, pos=6) ...
[09:31:13.462] - nx: 6
[09:31:13.462] - relay: TRUE
[09:31:13.462] - stdout: TRUE
[09:31:13.462] - signal: TRUE
[09:31:13.462] - resignal: FALSE
[09:31:13.462] - force: TRUE
[09:31:13.462] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.462] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.462]  - until=6
[09:31:13.463] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.463] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.463] signalConditionsASAP(numeric, pos=6) ... done
[09:31:13.463]  length: 0 (resolved future 6)
[09:31:13.463] Relaying remaining futures
[09:31:13.463] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.463] - nx: 6
[09:31:13.463] - relay: TRUE
[09:31:13.463] - stdout: TRUE
[09:31:13.463] - signal: TRUE
[09:31:13.463] - resignal: FALSE
[09:31:13.463] - force: TRUE
[09:31:13.463] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.464] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:13.464] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.464] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.464] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.464] resolve() on list ... DONE
[09:31:13.464] result() for ClusterFuture ...
[09:31:13.464] - result already collected: FutureResult
[09:31:13.464] result() for ClusterFuture ... done
[09:31:13.464] result() for ClusterFuture ...
[09:31:13.464] - result already collected: FutureResult
[09:31:13.464] result() for ClusterFuture ... done
[09:31:13.465] result() for ClusterFuture ...
[09:31:13.465] - result already collected: FutureResult
[09:31:13.465] result() for ClusterFuture ... done
[09:31:13.465] result() for ClusterFuture ...
[09:31:13.465] - result already collected: FutureResult
[09:31:13.465] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:13.468] getGlobalsAndPackages() ...
[09:31:13.468] Searching for globals...
[09:31:13.469] 
[09:31:13.469] Searching for globals ... DONE
[09:31:13.469] - globals: [0] <none>
[09:31:13.469] getGlobalsAndPackages() ... DONE
[09:31:13.469] run() for ‘Future’ ...
[09:31:13.469] - state: ‘created’
[09:31:13.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.482] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.483]   - Field: ‘node’
[09:31:13.483]   - Field: ‘label’
[09:31:13.483]   - Field: ‘local’
[09:31:13.483]   - Field: ‘owner’
[09:31:13.483]   - Field: ‘envir’
[09:31:13.483]   - Field: ‘workers’
[09:31:13.483]   - Field: ‘packages’
[09:31:13.483]   - Field: ‘gc’
[09:31:13.483]   - Field: ‘conditions’
[09:31:13.483]   - Field: ‘persistent’
[09:31:13.484]   - Field: ‘expr’
[09:31:13.484]   - Field: ‘uuid’
[09:31:13.484]   - Field: ‘seed’
[09:31:13.484]   - Field: ‘version’
[09:31:13.484]   - Field: ‘result’
[09:31:13.486]   - Field: ‘asynchronous’
[09:31:13.486]   - Field: ‘calls’
[09:31:13.486]   - Field: ‘globals’
[09:31:13.486]   - Field: ‘stdout’
[09:31:13.486]   - Field: ‘earlySignal’
[09:31:13.486]   - Field: ‘lazy’
[09:31:13.486]   - Field: ‘state’
[09:31:13.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.486] - Launch lazy future ...
[09:31:13.487] Packages needed by the future expression (n = 0): <none>
[09:31:13.487] Packages needed by future strategies (n = 0): <none>
[09:31:13.487] {
[09:31:13.487]     {
[09:31:13.487]         {
[09:31:13.487]             ...future.startTime <- base::Sys.time()
[09:31:13.487]             {
[09:31:13.487]                 {
[09:31:13.487]                   {
[09:31:13.487]                     {
[09:31:13.487]                       base::local({
[09:31:13.487]                         has_future <- base::requireNamespace("future", 
[09:31:13.487]                           quietly = TRUE)
[09:31:13.487]                         if (has_future) {
[09:31:13.487]                           ns <- base::getNamespace("future")
[09:31:13.487]                           version <- ns[[".package"]][["version"]]
[09:31:13.487]                           if (is.null(version)) 
[09:31:13.487]                             version <- utils::packageVersion("future")
[09:31:13.487]                         }
[09:31:13.487]                         else {
[09:31:13.487]                           version <- NULL
[09:31:13.487]                         }
[09:31:13.487]                         if (!has_future || version < "1.8.0") {
[09:31:13.487]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.487]                             "", base::R.version$version.string), 
[09:31:13.487]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.487]                               "release", "version")], collapse = " "), 
[09:31:13.487]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.487]                             info)
[09:31:13.487]                           info <- base::paste(info, collapse = "; ")
[09:31:13.487]                           if (!has_future) {
[09:31:13.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.487]                               info)
[09:31:13.487]                           }
[09:31:13.487]                           else {
[09:31:13.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.487]                               info, version)
[09:31:13.487]                           }
[09:31:13.487]                           base::stop(msg)
[09:31:13.487]                         }
[09:31:13.487]                       })
[09:31:13.487]                     }
[09:31:13.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.487]                     base::options(mc.cores = 1L)
[09:31:13.487]                   }
[09:31:13.487]                   ...future.strategy.old <- future::plan("list")
[09:31:13.487]                   options(future.plan = NULL)
[09:31:13.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.487]                 }
[09:31:13.487]                 ...future.workdir <- getwd()
[09:31:13.487]             }
[09:31:13.487]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.487]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.487]         }
[09:31:13.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.487]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.487]             base::names(...future.oldOptions))
[09:31:13.487]     }
[09:31:13.487]     if (FALSE) {
[09:31:13.487]     }
[09:31:13.487]     else {
[09:31:13.487]         if (TRUE) {
[09:31:13.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.487]                 open = "w")
[09:31:13.487]         }
[09:31:13.487]         else {
[09:31:13.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.487]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.487]         }
[09:31:13.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.487]             base::sink(type = "output", split = FALSE)
[09:31:13.487]             base::close(...future.stdout)
[09:31:13.487]         }, add = TRUE)
[09:31:13.487]     }
[09:31:13.487]     ...future.frame <- base::sys.nframe()
[09:31:13.487]     ...future.conditions <- base::list()
[09:31:13.487]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.487]     if (FALSE) {
[09:31:13.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.487]     }
[09:31:13.487]     ...future.result <- base::tryCatch({
[09:31:13.487]         base::withCallingHandlers({
[09:31:13.487]             ...future.value <- base::withVisible(base::local({
[09:31:13.487]                 ...future.makeSendCondition <- base::local({
[09:31:13.487]                   sendCondition <- NULL
[09:31:13.487]                   function(frame = 1L) {
[09:31:13.487]                     if (is.function(sendCondition)) 
[09:31:13.487]                       return(sendCondition)
[09:31:13.487]                     ns <- getNamespace("parallel")
[09:31:13.487]                     if (exists("sendData", mode = "function", 
[09:31:13.487]                       envir = ns)) {
[09:31:13.487]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.487]                         envir = ns)
[09:31:13.487]                       envir <- sys.frame(frame)
[09:31:13.487]                       master <- NULL
[09:31:13.487]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.487]                         !identical(envir, emptyenv())) {
[09:31:13.487]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.487]                           inherits = FALSE)) {
[09:31:13.487]                           master <- get("master", mode = "list", 
[09:31:13.487]                             envir = envir, inherits = FALSE)
[09:31:13.487]                           if (inherits(master, c("SOCKnode", 
[09:31:13.487]                             "SOCK0node"))) {
[09:31:13.487]                             sendCondition <<- function(cond) {
[09:31:13.487]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.487]                                 success = TRUE)
[09:31:13.487]                               parallel_sendData(master, data)
[09:31:13.487]                             }
[09:31:13.487]                             return(sendCondition)
[09:31:13.487]                           }
[09:31:13.487]                         }
[09:31:13.487]                         frame <- frame + 1L
[09:31:13.487]                         envir <- sys.frame(frame)
[09:31:13.487]                       }
[09:31:13.487]                     }
[09:31:13.487]                     sendCondition <<- function(cond) NULL
[09:31:13.487]                   }
[09:31:13.487]                 })
[09:31:13.487]                 withCallingHandlers({
[09:31:13.487]                   2
[09:31:13.487]                 }, immediateCondition = function(cond) {
[09:31:13.487]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.487]                   sendCondition(cond)
[09:31:13.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.487]                   {
[09:31:13.487]                     inherits <- base::inherits
[09:31:13.487]                     invokeRestart <- base::invokeRestart
[09:31:13.487]                     is.null <- base::is.null
[09:31:13.487]                     muffled <- FALSE
[09:31:13.487]                     if (inherits(cond, "message")) {
[09:31:13.487]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.487]                       if (muffled) 
[09:31:13.487]                         invokeRestart("muffleMessage")
[09:31:13.487]                     }
[09:31:13.487]                     else if (inherits(cond, "warning")) {
[09:31:13.487]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.487]                       if (muffled) 
[09:31:13.487]                         invokeRestart("muffleWarning")
[09:31:13.487]                     }
[09:31:13.487]                     else if (inherits(cond, "condition")) {
[09:31:13.487]                       if (!is.null(pattern)) {
[09:31:13.487]                         computeRestarts <- base::computeRestarts
[09:31:13.487]                         grepl <- base::grepl
[09:31:13.487]                         restarts <- computeRestarts(cond)
[09:31:13.487]                         for (restart in restarts) {
[09:31:13.487]                           name <- restart$name
[09:31:13.487]                           if (is.null(name)) 
[09:31:13.487]                             next
[09:31:13.487]                           if (!grepl(pattern, name)) 
[09:31:13.487]                             next
[09:31:13.487]                           invokeRestart(restart)
[09:31:13.487]                           muffled <- TRUE
[09:31:13.487]                           break
[09:31:13.487]                         }
[09:31:13.487]                       }
[09:31:13.487]                     }
[09:31:13.487]                     invisible(muffled)
[09:31:13.487]                   }
[09:31:13.487]                   muffleCondition(cond)
[09:31:13.487]                 })
[09:31:13.487]             }))
[09:31:13.487]             future::FutureResult(value = ...future.value$value, 
[09:31:13.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.487]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.487]                     ...future.globalenv.names))
[09:31:13.487]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.487]         }, condition = base::local({
[09:31:13.487]             c <- base::c
[09:31:13.487]             inherits <- base::inherits
[09:31:13.487]             invokeRestart <- base::invokeRestart
[09:31:13.487]             length <- base::length
[09:31:13.487]             list <- base::list
[09:31:13.487]             seq.int <- base::seq.int
[09:31:13.487]             signalCondition <- base::signalCondition
[09:31:13.487]             sys.calls <- base::sys.calls
[09:31:13.487]             `[[` <- base::`[[`
[09:31:13.487]             `+` <- base::`+`
[09:31:13.487]             `<<-` <- base::`<<-`
[09:31:13.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.487]                   3L)]
[09:31:13.487]             }
[09:31:13.487]             function(cond) {
[09:31:13.487]                 is_error <- inherits(cond, "error")
[09:31:13.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.487]                   NULL)
[09:31:13.487]                 if (is_error) {
[09:31:13.487]                   sessionInformation <- function() {
[09:31:13.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.487]                       search = base::search(), system = base::Sys.info())
[09:31:13.487]                   }
[09:31:13.487]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.487]                     cond$call), session = sessionInformation(), 
[09:31:13.487]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.487]                   signalCondition(cond)
[09:31:13.487]                 }
[09:31:13.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.487]                 "immediateCondition"))) {
[09:31:13.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.487]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.487]                   if (TRUE && !signal) {
[09:31:13.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.487]                     {
[09:31:13.487]                       inherits <- base::inherits
[09:31:13.487]                       invokeRestart <- base::invokeRestart
[09:31:13.487]                       is.null <- base::is.null
[09:31:13.487]                       muffled <- FALSE
[09:31:13.487]                       if (inherits(cond, "message")) {
[09:31:13.487]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.487]                         if (muffled) 
[09:31:13.487]                           invokeRestart("muffleMessage")
[09:31:13.487]                       }
[09:31:13.487]                       else if (inherits(cond, "warning")) {
[09:31:13.487]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.487]                         if (muffled) 
[09:31:13.487]                           invokeRestart("muffleWarning")
[09:31:13.487]                       }
[09:31:13.487]                       else if (inherits(cond, "condition")) {
[09:31:13.487]                         if (!is.null(pattern)) {
[09:31:13.487]                           computeRestarts <- base::computeRestarts
[09:31:13.487]                           grepl <- base::grepl
[09:31:13.487]                           restarts <- computeRestarts(cond)
[09:31:13.487]                           for (restart in restarts) {
[09:31:13.487]                             name <- restart$name
[09:31:13.487]                             if (is.null(name)) 
[09:31:13.487]                               next
[09:31:13.487]                             if (!grepl(pattern, name)) 
[09:31:13.487]                               next
[09:31:13.487]                             invokeRestart(restart)
[09:31:13.487]                             muffled <- TRUE
[09:31:13.487]                             break
[09:31:13.487]                           }
[09:31:13.487]                         }
[09:31:13.487]                       }
[09:31:13.487]                       invisible(muffled)
[09:31:13.487]                     }
[09:31:13.487]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.487]                   }
[09:31:13.487]                 }
[09:31:13.487]                 else {
[09:31:13.487]                   if (TRUE) {
[09:31:13.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.487]                     {
[09:31:13.487]                       inherits <- base::inherits
[09:31:13.487]                       invokeRestart <- base::invokeRestart
[09:31:13.487]                       is.null <- base::is.null
[09:31:13.487]                       muffled <- FALSE
[09:31:13.487]                       if (inherits(cond, "message")) {
[09:31:13.487]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.487]                         if (muffled) 
[09:31:13.487]                           invokeRestart("muffleMessage")
[09:31:13.487]                       }
[09:31:13.487]                       else if (inherits(cond, "warning")) {
[09:31:13.487]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.487]                         if (muffled) 
[09:31:13.487]                           invokeRestart("muffleWarning")
[09:31:13.487]                       }
[09:31:13.487]                       else if (inherits(cond, "condition")) {
[09:31:13.487]                         if (!is.null(pattern)) {
[09:31:13.487]                           computeRestarts <- base::computeRestarts
[09:31:13.487]                           grepl <- base::grepl
[09:31:13.487]                           restarts <- computeRestarts(cond)
[09:31:13.487]                           for (restart in restarts) {
[09:31:13.487]                             name <- restart$name
[09:31:13.487]                             if (is.null(name)) 
[09:31:13.487]                               next
[09:31:13.487]                             if (!grepl(pattern, name)) 
[09:31:13.487]                               next
[09:31:13.487]                             invokeRestart(restart)
[09:31:13.487]                             muffled <- TRUE
[09:31:13.487]                             break
[09:31:13.487]                           }
[09:31:13.487]                         }
[09:31:13.487]                       }
[09:31:13.487]                       invisible(muffled)
[09:31:13.487]                     }
[09:31:13.487]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.487]                   }
[09:31:13.487]                 }
[09:31:13.487]             }
[09:31:13.487]         }))
[09:31:13.487]     }, error = function(ex) {
[09:31:13.487]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.487]                 ...future.rng), started = ...future.startTime, 
[09:31:13.487]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.487]             version = "1.8"), class = "FutureResult")
[09:31:13.487]     }, finally = {
[09:31:13.487]         if (!identical(...future.workdir, getwd())) 
[09:31:13.487]             setwd(...future.workdir)
[09:31:13.487]         {
[09:31:13.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.487]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.487]             }
[09:31:13.487]             base::options(...future.oldOptions)
[09:31:13.487]             if (.Platform$OS.type == "windows") {
[09:31:13.487]                 old_names <- names(...future.oldEnvVars)
[09:31:13.487]                 envs <- base::Sys.getenv()
[09:31:13.487]                 names <- names(envs)
[09:31:13.487]                 common <- intersect(names, old_names)
[09:31:13.487]                 added <- setdiff(names, old_names)
[09:31:13.487]                 removed <- setdiff(old_names, names)
[09:31:13.487]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.487]                   envs[common]]
[09:31:13.487]                 NAMES <- toupper(changed)
[09:31:13.487]                 args <- list()
[09:31:13.487]                 for (kk in seq_along(NAMES)) {
[09:31:13.487]                   name <- changed[[kk]]
[09:31:13.487]                   NAME <- NAMES[[kk]]
[09:31:13.487]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.487]                     next
[09:31:13.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.487]                 }
[09:31:13.487]                 NAMES <- toupper(added)
[09:31:13.487]                 for (kk in seq_along(NAMES)) {
[09:31:13.487]                   name <- added[[kk]]
[09:31:13.487]                   NAME <- NAMES[[kk]]
[09:31:13.487]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.487]                     next
[09:31:13.487]                   args[[name]] <- ""
[09:31:13.487]                 }
[09:31:13.487]                 NAMES <- toupper(removed)
[09:31:13.487]                 for (kk in seq_along(NAMES)) {
[09:31:13.487]                   name <- removed[[kk]]
[09:31:13.487]                   NAME <- NAMES[[kk]]
[09:31:13.487]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.487]                     next
[09:31:13.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.487]                 }
[09:31:13.487]                 if (length(args) > 0) 
[09:31:13.487]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.487]             }
[09:31:13.487]             else {
[09:31:13.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.487]             }
[09:31:13.487]             {
[09:31:13.487]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.487]                   0L) {
[09:31:13.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.487]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.487]                   base::options(opts)
[09:31:13.487]                 }
[09:31:13.487]                 {
[09:31:13.487]                   {
[09:31:13.487]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.487]                     NULL
[09:31:13.487]                   }
[09:31:13.487]                   options(future.plan = NULL)
[09:31:13.487]                   if (is.na(NA_character_)) 
[09:31:13.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.487]                     .init = FALSE)
[09:31:13.487]                 }
[09:31:13.487]             }
[09:31:13.487]         }
[09:31:13.487]     })
[09:31:13.487]     if (TRUE) {
[09:31:13.487]         base::sink(type = "output", split = FALSE)
[09:31:13.487]         if (TRUE) {
[09:31:13.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.487]         }
[09:31:13.487]         else {
[09:31:13.487]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.487]         }
[09:31:13.487]         base::close(...future.stdout)
[09:31:13.487]         ...future.stdout <- NULL
[09:31:13.487]     }
[09:31:13.487]     ...future.result$conditions <- ...future.conditions
[09:31:13.487]     ...future.result$finished <- base::Sys.time()
[09:31:13.487]     ...future.result
[09:31:13.487] }
[09:31:13.490] MultisessionFuture started
[09:31:13.490] - Launch lazy future ... done
[09:31:13.490] run() for ‘MultisessionFuture’ ... done
[09:31:13.490] getGlobalsAndPackages() ...
[09:31:13.490] Searching for globals...
[09:31:13.490] 
[09:31:13.491] Searching for globals ... DONE
[09:31:13.491] - globals: [0] <none>
[09:31:13.491] getGlobalsAndPackages() ... DONE
[09:31:13.491] run() for ‘Future’ ...
[09:31:13.491] - state: ‘created’
[09:31:13.491] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:13.505]   - Field: ‘node’
[09:31:13.505]   - Field: ‘label’
[09:31:13.505]   - Field: ‘local’
[09:31:13.506]   - Field: ‘owner’
[09:31:13.506]   - Field: ‘envir’
[09:31:13.506]   - Field: ‘workers’
[09:31:13.506]   - Field: ‘packages’
[09:31:13.506]   - Field: ‘gc’
[09:31:13.506]   - Field: ‘conditions’
[09:31:13.506]   - Field: ‘persistent’
[09:31:13.506]   - Field: ‘expr’
[09:31:13.506]   - Field: ‘uuid’
[09:31:13.506]   - Field: ‘seed’
[09:31:13.506]   - Field: ‘version’
[09:31:13.506]   - Field: ‘result’
[09:31:13.507]   - Field: ‘asynchronous’
[09:31:13.507]   - Field: ‘calls’
[09:31:13.507]   - Field: ‘globals’
[09:31:13.507]   - Field: ‘stdout’
[09:31:13.507]   - Field: ‘earlySignal’
[09:31:13.507]   - Field: ‘lazy’
[09:31:13.507]   - Field: ‘state’
[09:31:13.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:13.507] - Launch lazy future ...
[09:31:13.507] Packages needed by the future expression (n = 0): <none>
[09:31:13.508] Packages needed by future strategies (n = 0): <none>
[09:31:13.508] {
[09:31:13.508]     {
[09:31:13.508]         {
[09:31:13.508]             ...future.startTime <- base::Sys.time()
[09:31:13.508]             {
[09:31:13.508]                 {
[09:31:13.508]                   {
[09:31:13.508]                     {
[09:31:13.508]                       base::local({
[09:31:13.508]                         has_future <- base::requireNamespace("future", 
[09:31:13.508]                           quietly = TRUE)
[09:31:13.508]                         if (has_future) {
[09:31:13.508]                           ns <- base::getNamespace("future")
[09:31:13.508]                           version <- ns[[".package"]][["version"]]
[09:31:13.508]                           if (is.null(version)) 
[09:31:13.508]                             version <- utils::packageVersion("future")
[09:31:13.508]                         }
[09:31:13.508]                         else {
[09:31:13.508]                           version <- NULL
[09:31:13.508]                         }
[09:31:13.508]                         if (!has_future || version < "1.8.0") {
[09:31:13.508]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.508]                             "", base::R.version$version.string), 
[09:31:13.508]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.508]                               "release", "version")], collapse = " "), 
[09:31:13.508]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.508]                             info)
[09:31:13.508]                           info <- base::paste(info, collapse = "; ")
[09:31:13.508]                           if (!has_future) {
[09:31:13.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.508]                               info)
[09:31:13.508]                           }
[09:31:13.508]                           else {
[09:31:13.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.508]                               info, version)
[09:31:13.508]                           }
[09:31:13.508]                           base::stop(msg)
[09:31:13.508]                         }
[09:31:13.508]                       })
[09:31:13.508]                     }
[09:31:13.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.508]                     base::options(mc.cores = 1L)
[09:31:13.508]                   }
[09:31:13.508]                   ...future.strategy.old <- future::plan("list")
[09:31:13.508]                   options(future.plan = NULL)
[09:31:13.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.508]                 }
[09:31:13.508]                 ...future.workdir <- getwd()
[09:31:13.508]             }
[09:31:13.508]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.508]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.508]         }
[09:31:13.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.508]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.508]             base::names(...future.oldOptions))
[09:31:13.508]     }
[09:31:13.508]     if (FALSE) {
[09:31:13.508]     }
[09:31:13.508]     else {
[09:31:13.508]         if (TRUE) {
[09:31:13.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.508]                 open = "w")
[09:31:13.508]         }
[09:31:13.508]         else {
[09:31:13.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.508]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.508]         }
[09:31:13.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.508]             base::sink(type = "output", split = FALSE)
[09:31:13.508]             base::close(...future.stdout)
[09:31:13.508]         }, add = TRUE)
[09:31:13.508]     }
[09:31:13.508]     ...future.frame <- base::sys.nframe()
[09:31:13.508]     ...future.conditions <- base::list()
[09:31:13.508]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.508]     if (FALSE) {
[09:31:13.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.508]     }
[09:31:13.508]     ...future.result <- base::tryCatch({
[09:31:13.508]         base::withCallingHandlers({
[09:31:13.508]             ...future.value <- base::withVisible(base::local({
[09:31:13.508]                 ...future.makeSendCondition <- base::local({
[09:31:13.508]                   sendCondition <- NULL
[09:31:13.508]                   function(frame = 1L) {
[09:31:13.508]                     if (is.function(sendCondition)) 
[09:31:13.508]                       return(sendCondition)
[09:31:13.508]                     ns <- getNamespace("parallel")
[09:31:13.508]                     if (exists("sendData", mode = "function", 
[09:31:13.508]                       envir = ns)) {
[09:31:13.508]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:13.508]                         envir = ns)
[09:31:13.508]                       envir <- sys.frame(frame)
[09:31:13.508]                       master <- NULL
[09:31:13.508]                       while (!identical(envir, .GlobalEnv) && 
[09:31:13.508]                         !identical(envir, emptyenv())) {
[09:31:13.508]                         if (exists("master", mode = "list", envir = envir, 
[09:31:13.508]                           inherits = FALSE)) {
[09:31:13.508]                           master <- get("master", mode = "list", 
[09:31:13.508]                             envir = envir, inherits = FALSE)
[09:31:13.508]                           if (inherits(master, c("SOCKnode", 
[09:31:13.508]                             "SOCK0node"))) {
[09:31:13.508]                             sendCondition <<- function(cond) {
[09:31:13.508]                               data <- list(type = "VALUE", value = cond, 
[09:31:13.508]                                 success = TRUE)
[09:31:13.508]                               parallel_sendData(master, data)
[09:31:13.508]                             }
[09:31:13.508]                             return(sendCondition)
[09:31:13.508]                           }
[09:31:13.508]                         }
[09:31:13.508]                         frame <- frame + 1L
[09:31:13.508]                         envir <- sys.frame(frame)
[09:31:13.508]                       }
[09:31:13.508]                     }
[09:31:13.508]                     sendCondition <<- function(cond) NULL
[09:31:13.508]                   }
[09:31:13.508]                 })
[09:31:13.508]                 withCallingHandlers({
[09:31:13.508]                   NULL
[09:31:13.508]                 }, immediateCondition = function(cond) {
[09:31:13.508]                   sendCondition <- ...future.makeSendCondition()
[09:31:13.508]                   sendCondition(cond)
[09:31:13.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.508]                   {
[09:31:13.508]                     inherits <- base::inherits
[09:31:13.508]                     invokeRestart <- base::invokeRestart
[09:31:13.508]                     is.null <- base::is.null
[09:31:13.508]                     muffled <- FALSE
[09:31:13.508]                     if (inherits(cond, "message")) {
[09:31:13.508]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.508]                       if (muffled) 
[09:31:13.508]                         invokeRestart("muffleMessage")
[09:31:13.508]                     }
[09:31:13.508]                     else if (inherits(cond, "warning")) {
[09:31:13.508]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.508]                       if (muffled) 
[09:31:13.508]                         invokeRestart("muffleWarning")
[09:31:13.508]                     }
[09:31:13.508]                     else if (inherits(cond, "condition")) {
[09:31:13.508]                       if (!is.null(pattern)) {
[09:31:13.508]                         computeRestarts <- base::computeRestarts
[09:31:13.508]                         grepl <- base::grepl
[09:31:13.508]                         restarts <- computeRestarts(cond)
[09:31:13.508]                         for (restart in restarts) {
[09:31:13.508]                           name <- restart$name
[09:31:13.508]                           if (is.null(name)) 
[09:31:13.508]                             next
[09:31:13.508]                           if (!grepl(pattern, name)) 
[09:31:13.508]                             next
[09:31:13.508]                           invokeRestart(restart)
[09:31:13.508]                           muffled <- TRUE
[09:31:13.508]                           break
[09:31:13.508]                         }
[09:31:13.508]                       }
[09:31:13.508]                     }
[09:31:13.508]                     invisible(muffled)
[09:31:13.508]                   }
[09:31:13.508]                   muffleCondition(cond)
[09:31:13.508]                 })
[09:31:13.508]             }))
[09:31:13.508]             future::FutureResult(value = ...future.value$value, 
[09:31:13.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.508]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.508]                     ...future.globalenv.names))
[09:31:13.508]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.508]         }, condition = base::local({
[09:31:13.508]             c <- base::c
[09:31:13.508]             inherits <- base::inherits
[09:31:13.508]             invokeRestart <- base::invokeRestart
[09:31:13.508]             length <- base::length
[09:31:13.508]             list <- base::list
[09:31:13.508]             seq.int <- base::seq.int
[09:31:13.508]             signalCondition <- base::signalCondition
[09:31:13.508]             sys.calls <- base::sys.calls
[09:31:13.508]             `[[` <- base::`[[`
[09:31:13.508]             `+` <- base::`+`
[09:31:13.508]             `<<-` <- base::`<<-`
[09:31:13.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.508]                   3L)]
[09:31:13.508]             }
[09:31:13.508]             function(cond) {
[09:31:13.508]                 is_error <- inherits(cond, "error")
[09:31:13.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.508]                   NULL)
[09:31:13.508]                 if (is_error) {
[09:31:13.508]                   sessionInformation <- function() {
[09:31:13.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.508]                       search = base::search(), system = base::Sys.info())
[09:31:13.508]                   }
[09:31:13.508]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.508]                     cond$call), session = sessionInformation(), 
[09:31:13.508]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.508]                   signalCondition(cond)
[09:31:13.508]                 }
[09:31:13.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.508]                 "immediateCondition"))) {
[09:31:13.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.508]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.508]                   if (TRUE && !signal) {
[09:31:13.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.508]                     {
[09:31:13.508]                       inherits <- base::inherits
[09:31:13.508]                       invokeRestart <- base::invokeRestart
[09:31:13.508]                       is.null <- base::is.null
[09:31:13.508]                       muffled <- FALSE
[09:31:13.508]                       if (inherits(cond, "message")) {
[09:31:13.508]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.508]                         if (muffled) 
[09:31:13.508]                           invokeRestart("muffleMessage")
[09:31:13.508]                       }
[09:31:13.508]                       else if (inherits(cond, "warning")) {
[09:31:13.508]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.508]                         if (muffled) 
[09:31:13.508]                           invokeRestart("muffleWarning")
[09:31:13.508]                       }
[09:31:13.508]                       else if (inherits(cond, "condition")) {
[09:31:13.508]                         if (!is.null(pattern)) {
[09:31:13.508]                           computeRestarts <- base::computeRestarts
[09:31:13.508]                           grepl <- base::grepl
[09:31:13.508]                           restarts <- computeRestarts(cond)
[09:31:13.508]                           for (restart in restarts) {
[09:31:13.508]                             name <- restart$name
[09:31:13.508]                             if (is.null(name)) 
[09:31:13.508]                               next
[09:31:13.508]                             if (!grepl(pattern, name)) 
[09:31:13.508]                               next
[09:31:13.508]                             invokeRestart(restart)
[09:31:13.508]                             muffled <- TRUE
[09:31:13.508]                             break
[09:31:13.508]                           }
[09:31:13.508]                         }
[09:31:13.508]                       }
[09:31:13.508]                       invisible(muffled)
[09:31:13.508]                     }
[09:31:13.508]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.508]                   }
[09:31:13.508]                 }
[09:31:13.508]                 else {
[09:31:13.508]                   if (TRUE) {
[09:31:13.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.508]                     {
[09:31:13.508]                       inherits <- base::inherits
[09:31:13.508]                       invokeRestart <- base::invokeRestart
[09:31:13.508]                       is.null <- base::is.null
[09:31:13.508]                       muffled <- FALSE
[09:31:13.508]                       if (inherits(cond, "message")) {
[09:31:13.508]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.508]                         if (muffled) 
[09:31:13.508]                           invokeRestart("muffleMessage")
[09:31:13.508]                       }
[09:31:13.508]                       else if (inherits(cond, "warning")) {
[09:31:13.508]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.508]                         if (muffled) 
[09:31:13.508]                           invokeRestart("muffleWarning")
[09:31:13.508]                       }
[09:31:13.508]                       else if (inherits(cond, "condition")) {
[09:31:13.508]                         if (!is.null(pattern)) {
[09:31:13.508]                           computeRestarts <- base::computeRestarts
[09:31:13.508]                           grepl <- base::grepl
[09:31:13.508]                           restarts <- computeRestarts(cond)
[09:31:13.508]                           for (restart in restarts) {
[09:31:13.508]                             name <- restart$name
[09:31:13.508]                             if (is.null(name)) 
[09:31:13.508]                               next
[09:31:13.508]                             if (!grepl(pattern, name)) 
[09:31:13.508]                               next
[09:31:13.508]                             invokeRestart(restart)
[09:31:13.508]                             muffled <- TRUE
[09:31:13.508]                             break
[09:31:13.508]                           }
[09:31:13.508]                         }
[09:31:13.508]                       }
[09:31:13.508]                       invisible(muffled)
[09:31:13.508]                     }
[09:31:13.508]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.508]                   }
[09:31:13.508]                 }
[09:31:13.508]             }
[09:31:13.508]         }))
[09:31:13.508]     }, error = function(ex) {
[09:31:13.508]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.508]                 ...future.rng), started = ...future.startTime, 
[09:31:13.508]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.508]             version = "1.8"), class = "FutureResult")
[09:31:13.508]     }, finally = {
[09:31:13.508]         if (!identical(...future.workdir, getwd())) 
[09:31:13.508]             setwd(...future.workdir)
[09:31:13.508]         {
[09:31:13.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.508]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.508]             }
[09:31:13.508]             base::options(...future.oldOptions)
[09:31:13.508]             if (.Platform$OS.type == "windows") {
[09:31:13.508]                 old_names <- names(...future.oldEnvVars)
[09:31:13.508]                 envs <- base::Sys.getenv()
[09:31:13.508]                 names <- names(envs)
[09:31:13.508]                 common <- intersect(names, old_names)
[09:31:13.508]                 added <- setdiff(names, old_names)
[09:31:13.508]                 removed <- setdiff(old_names, names)
[09:31:13.508]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.508]                   envs[common]]
[09:31:13.508]                 NAMES <- toupper(changed)
[09:31:13.508]                 args <- list()
[09:31:13.508]                 for (kk in seq_along(NAMES)) {
[09:31:13.508]                   name <- changed[[kk]]
[09:31:13.508]                   NAME <- NAMES[[kk]]
[09:31:13.508]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.508]                     next
[09:31:13.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.508]                 }
[09:31:13.508]                 NAMES <- toupper(added)
[09:31:13.508]                 for (kk in seq_along(NAMES)) {
[09:31:13.508]                   name <- added[[kk]]
[09:31:13.508]                   NAME <- NAMES[[kk]]
[09:31:13.508]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.508]                     next
[09:31:13.508]                   args[[name]] <- ""
[09:31:13.508]                 }
[09:31:13.508]                 NAMES <- toupper(removed)
[09:31:13.508]                 for (kk in seq_along(NAMES)) {
[09:31:13.508]                   name <- removed[[kk]]
[09:31:13.508]                   NAME <- NAMES[[kk]]
[09:31:13.508]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.508]                     next
[09:31:13.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.508]                 }
[09:31:13.508]                 if (length(args) > 0) 
[09:31:13.508]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.508]             }
[09:31:13.508]             else {
[09:31:13.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.508]             }
[09:31:13.508]             {
[09:31:13.508]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.508]                   0L) {
[09:31:13.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.508]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.508]                   base::options(opts)
[09:31:13.508]                 }
[09:31:13.508]                 {
[09:31:13.508]                   {
[09:31:13.508]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.508]                     NULL
[09:31:13.508]                   }
[09:31:13.508]                   options(future.plan = NULL)
[09:31:13.508]                   if (is.na(NA_character_)) 
[09:31:13.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.508]                     .init = FALSE)
[09:31:13.508]                 }
[09:31:13.508]             }
[09:31:13.508]         }
[09:31:13.508]     })
[09:31:13.508]     if (TRUE) {
[09:31:13.508]         base::sink(type = "output", split = FALSE)
[09:31:13.508]         if (TRUE) {
[09:31:13.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.508]         }
[09:31:13.508]         else {
[09:31:13.508]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.508]         }
[09:31:13.508]         base::close(...future.stdout)
[09:31:13.508]         ...future.stdout <- NULL
[09:31:13.508]     }
[09:31:13.508]     ...future.result$conditions <- ...future.conditions
[09:31:13.508]     ...future.result$finished <- base::Sys.time()
[09:31:13.508]     ...future.result
[09:31:13.508] }
[09:31:13.511] MultisessionFuture started
[09:31:13.511] - Launch lazy future ... done
[09:31:13.511] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cce1a780> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb4c3f40> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cce1a780> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a3cb4c3f40> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:13.516] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.516] - Validating connection of MultisessionFuture
[09:31:13.517] - received message: FutureResult
[09:31:13.517] - Received FutureResult
[09:31:13.517] - Erased future from FutureRegistry
[09:31:13.517] result() for ClusterFuture ...
[09:31:13.517] - result already collected: FutureResult
[09:31:13.517] result() for ClusterFuture ... done
[09:31:13.517] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:13.518] receiveMessageFromWorker() for ClusterFuture ...
[09:31:13.518] - Validating connection of MultisessionFuture
[09:31:13.518] - received message: FutureResult
[09:31:13.518] - Received FutureResult
[09:31:13.518] - Erased future from FutureRegistry
[09:31:13.518] result() for ClusterFuture ...
[09:31:13.518] - result already collected: FutureResult
[09:31:13.518] result() for ClusterFuture ... done
[09:31:13.518] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[09:31:13.520] resolve() on list ...
[09:31:13.520]  recursive: 0
[09:31:13.521]  length: 6
[09:31:13.521]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[09:31:13.521] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.521] - nx: 6
[09:31:13.521] - relay: TRUE
[09:31:13.521] - stdout: TRUE
[09:31:13.521] - signal: TRUE
[09:31:13.521] - resignal: FALSE
[09:31:13.521] - force: TRUE
[09:31:13.521] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.521] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.521]  - until=2
[09:31:13.522]  - relaying element #2
[09:31:13.522] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.522] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.522] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.522]  length: 5 (resolved future 1)
[09:31:13.522] Future #2
[09:31:13.522] result() for ClusterFuture ...
[09:31:13.522] - result already collected: FutureResult
[09:31:13.522] result() for ClusterFuture ... done
[09:31:13.522] result() for ClusterFuture ...
[09:31:13.522] - result already collected: FutureResult
[09:31:13.523] result() for ClusterFuture ... done
[09:31:13.523] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:13.523] - nx: 6
[09:31:13.523] - relay: TRUE
[09:31:13.523] - stdout: TRUE
[09:31:13.523] - signal: TRUE
[09:31:13.523] - resignal: FALSE
[09:31:13.523] - force: TRUE
[09:31:13.523] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.523] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:13.523]  - until=2
[09:31:13.523]  - relaying element #2
[09:31:13.524] result() for ClusterFuture ...
[09:31:13.524] - result already collected: FutureResult
[09:31:13.524] result() for ClusterFuture ... done
[09:31:13.524] result() for ClusterFuture ...
[09:31:13.524] - result already collected: FutureResult
[09:31:13.524] result() for ClusterFuture ... done
[09:31:13.524] result() for ClusterFuture ...
[09:31:13.524] - result already collected: FutureResult
[09:31:13.524] result() for ClusterFuture ... done
[09:31:13.524] result() for ClusterFuture ...
[09:31:13.525] - result already collected: FutureResult
[09:31:13.525] result() for ClusterFuture ... done
[09:31:13.525] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.525] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.525] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:13.525]  length: 4 (resolved future 2)
[09:31:13.525] Future #3
[09:31:13.525] result() for ClusterFuture ...
[09:31:13.525] - result already collected: FutureResult
[09:31:13.525] result() for ClusterFuture ... done
[09:31:13.525] result() for ClusterFuture ...
[09:31:13.526] - result already collected: FutureResult
[09:31:13.526] result() for ClusterFuture ... done
[09:31:13.526] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:13.526] - nx: 6
[09:31:13.526] - relay: TRUE
[09:31:13.526] - stdout: TRUE
[09:31:13.526] - signal: TRUE
[09:31:13.526] - resignal: FALSE
[09:31:13.526] - force: TRUE
[09:31:13.526] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.526] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:13.526]  - until=3
[09:31:13.526]  - relaying element #3
[09:31:13.527] result() for ClusterFuture ...
[09:31:13.527] - result already collected: FutureResult
[09:31:13.527] result() for ClusterFuture ... done
[09:31:13.527] result() for ClusterFuture ...
[09:31:13.527] - result already collected: FutureResult
[09:31:13.527] result() for ClusterFuture ... done
[09:31:13.527] result() for ClusterFuture ...
[09:31:13.527] - result already collected: FutureResult
[09:31:13.527] result() for ClusterFuture ... done
[09:31:13.527] result() for ClusterFuture ...
[09:31:13.527] - result already collected: FutureResult
[09:31:13.527] result() for ClusterFuture ... done
[09:31:13.528] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.528] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.528] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:13.528]  length: 3 (resolved future 3)
[09:31:13.528] signalConditionsASAP(NULL, pos=4) ...
[09:31:13.528] - nx: 6
[09:31:13.528] - relay: TRUE
[09:31:13.528] - stdout: TRUE
[09:31:13.528] - signal: TRUE
[09:31:13.528] - resignal: FALSE
[09:31:13.528] - force: TRUE
[09:31:13.529] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.529] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.529]  - until=5
[09:31:13.529]  - relaying element #5
[09:31:13.529] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.529] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.529] signalConditionsASAP(NULL, pos=4) ... done
[09:31:13.529]  length: 2 (resolved future 4)
[09:31:13.529] signalConditionsASAP(NULL, pos=5) ...
[09:31:13.529] - nx: 6
[09:31:13.529] - relay: TRUE
[09:31:13.529] - stdout: TRUE
[09:31:13.530] - signal: TRUE
[09:31:13.530] - resignal: FALSE
[09:31:13.530] - force: TRUE
[09:31:13.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:13.530] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.530]  - until=6
[09:31:13.530]  - relaying element #6
[09:31:13.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.530] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.530] signalConditionsASAP(NULL, pos=5) ... done
[09:31:13.530]  length: 1 (resolved future 5)
[09:31:13.530] signalConditionsASAP(numeric, pos=6) ...
[09:31:13.531] - nx: 6
[09:31:13.531] - relay: TRUE
[09:31:13.531] - stdout: TRUE
[09:31:13.531] - signal: TRUE
[09:31:13.531] - resignal: FALSE
[09:31:13.531] - force: TRUE
[09:31:13.531] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:13.531] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.531]  - until=6
[09:31:13.531] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.531] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.531] signalConditionsASAP(numeric, pos=6) ... done
[09:31:13.532]  length: 0 (resolved future 6)
[09:31:13.532] Relaying remaining futures
[09:31:13.532] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.532] - nx: 6
[09:31:13.532] - relay: TRUE
[09:31:13.532] - stdout: TRUE
[09:31:13.532] - signal: TRUE
[09:31:13.532] - resignal: FALSE
[09:31:13.532] - force: TRUE
[09:31:13.532] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.532] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[09:31:13.533] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:13.533] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:13.533] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.533] resolve() on list ... DONE
[09:31:13.533] result() for ClusterFuture ...
[09:31:13.533] - result already collected: FutureResult
[09:31:13.533] result() for ClusterFuture ... done
[09:31:13.533] result() for ClusterFuture ...
[09:31:13.533] - result already collected: FutureResult
[09:31:13.533] result() for ClusterFuture ... done
[09:31:13.533] result() for ClusterFuture ...
[09:31:13.534] - result already collected: FutureResult
[09:31:13.534] result() for ClusterFuture ... done
[09:31:13.534] result() for ClusterFuture ...
[09:31:13.534] - result already collected: FutureResult
[09:31:13.534] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[09:31:13.538] plan(): Setting new future strategy stack:
[09:31:13.538] List of future strategies:
[09:31:13.538] 1. multicore:
[09:31:13.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.538]    - tweaked: FALSE
[09:31:13.538]    - call: plan(strategy)
[09:31:13.542] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:13.543] getGlobalsAndPackages() ...
[09:31:13.543] Searching for globals...
[09:31:13.543] 
[09:31:13.543] Searching for globals ... DONE
[09:31:13.544] - globals: [0] <none>
[09:31:13.544] getGlobalsAndPackages() ... DONE
[09:31:13.544] run() for ‘Future’ ...
[09:31:13.544] - state: ‘created’
[09:31:13.544] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.549]   - Field: ‘label’
[09:31:13.549]   - Field: ‘local’
[09:31:13.549]   - Field: ‘owner’
[09:31:13.549]   - Field: ‘envir’
[09:31:13.549]   - Field: ‘workers’
[09:31:13.550]   - Field: ‘packages’
[09:31:13.550]   - Field: ‘gc’
[09:31:13.550]   - Field: ‘job’
[09:31:13.550]   - Field: ‘conditions’
[09:31:13.550]   - Field: ‘expr’
[09:31:13.550]   - Field: ‘uuid’
[09:31:13.550]   - Field: ‘seed’
[09:31:13.550]   - Field: ‘version’
[09:31:13.550]   - Field: ‘result’
[09:31:13.550]   - Field: ‘asynchronous’
[09:31:13.550]   - Field: ‘calls’
[09:31:13.551]   - Field: ‘globals’
[09:31:13.551]   - Field: ‘stdout’
[09:31:13.551]   - Field: ‘earlySignal’
[09:31:13.551]   - Field: ‘lazy’
[09:31:13.551]   - Field: ‘state’
[09:31:13.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.551] - Launch lazy future ...
[09:31:13.551] Packages needed by the future expression (n = 0): <none>
[09:31:13.551] Packages needed by future strategies (n = 0): <none>
[09:31:13.552] {
[09:31:13.552]     {
[09:31:13.552]         {
[09:31:13.552]             ...future.startTime <- base::Sys.time()
[09:31:13.552]             {
[09:31:13.552]                 {
[09:31:13.552]                   {
[09:31:13.552]                     {
[09:31:13.552]                       base::local({
[09:31:13.552]                         has_future <- base::requireNamespace("future", 
[09:31:13.552]                           quietly = TRUE)
[09:31:13.552]                         if (has_future) {
[09:31:13.552]                           ns <- base::getNamespace("future")
[09:31:13.552]                           version <- ns[[".package"]][["version"]]
[09:31:13.552]                           if (is.null(version)) 
[09:31:13.552]                             version <- utils::packageVersion("future")
[09:31:13.552]                         }
[09:31:13.552]                         else {
[09:31:13.552]                           version <- NULL
[09:31:13.552]                         }
[09:31:13.552]                         if (!has_future || version < "1.8.0") {
[09:31:13.552]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.552]                             "", base::R.version$version.string), 
[09:31:13.552]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.552]                               "release", "version")], collapse = " "), 
[09:31:13.552]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.552]                             info)
[09:31:13.552]                           info <- base::paste(info, collapse = "; ")
[09:31:13.552]                           if (!has_future) {
[09:31:13.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.552]                               info)
[09:31:13.552]                           }
[09:31:13.552]                           else {
[09:31:13.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.552]                               info, version)
[09:31:13.552]                           }
[09:31:13.552]                           base::stop(msg)
[09:31:13.552]                         }
[09:31:13.552]                       })
[09:31:13.552]                     }
[09:31:13.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.552]                     base::options(mc.cores = 1L)
[09:31:13.552]                   }
[09:31:13.552]                   ...future.strategy.old <- future::plan("list")
[09:31:13.552]                   options(future.plan = NULL)
[09:31:13.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.552]                 }
[09:31:13.552]                 ...future.workdir <- getwd()
[09:31:13.552]             }
[09:31:13.552]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.552]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.552]         }
[09:31:13.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.552]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.552]             base::names(...future.oldOptions))
[09:31:13.552]     }
[09:31:13.552]     if (FALSE) {
[09:31:13.552]     }
[09:31:13.552]     else {
[09:31:13.552]         if (TRUE) {
[09:31:13.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.552]                 open = "w")
[09:31:13.552]         }
[09:31:13.552]         else {
[09:31:13.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.552]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.552]         }
[09:31:13.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.552]             base::sink(type = "output", split = FALSE)
[09:31:13.552]             base::close(...future.stdout)
[09:31:13.552]         }, add = TRUE)
[09:31:13.552]     }
[09:31:13.552]     ...future.frame <- base::sys.nframe()
[09:31:13.552]     ...future.conditions <- base::list()
[09:31:13.552]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.552]     if (FALSE) {
[09:31:13.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.552]     }
[09:31:13.552]     ...future.result <- base::tryCatch({
[09:31:13.552]         base::withCallingHandlers({
[09:31:13.552]             ...future.value <- base::withVisible(base::local({
[09:31:13.552]                 withCallingHandlers({
[09:31:13.552]                   2
[09:31:13.552]                 }, immediateCondition = function(cond) {
[09:31:13.552]                   save_rds <- function (object, pathname, ...) 
[09:31:13.552]                   {
[09:31:13.552]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.552]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.552]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.552]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.552]                         fi_tmp[["mtime"]])
[09:31:13.552]                     }
[09:31:13.552]                     tryCatch({
[09:31:13.552]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.552]                     }, error = function(ex) {
[09:31:13.552]                       msg <- conditionMessage(ex)
[09:31:13.552]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.552]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.552]                         fi_tmp[["mtime"]], msg)
[09:31:13.552]                       ex$message <- msg
[09:31:13.552]                       stop(ex)
[09:31:13.552]                     })
[09:31:13.552]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.552]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.552]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.552]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.552]                       fi <- file.info(pathname)
[09:31:13.552]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.552]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.552]                         fi[["size"]], fi[["mtime"]])
[09:31:13.552]                       stop(msg)
[09:31:13.552]                     }
[09:31:13.552]                     invisible(pathname)
[09:31:13.552]                   }
[09:31:13.552]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.552]                     rootPath = tempdir()) 
[09:31:13.552]                   {
[09:31:13.552]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.552]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.552]                       tmpdir = path, fileext = ".rds")
[09:31:13.552]                     save_rds(obj, file)
[09:31:13.552]                   }
[09:31:13.552]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.552]                   {
[09:31:13.552]                     inherits <- base::inherits
[09:31:13.552]                     invokeRestart <- base::invokeRestart
[09:31:13.552]                     is.null <- base::is.null
[09:31:13.552]                     muffled <- FALSE
[09:31:13.552]                     if (inherits(cond, "message")) {
[09:31:13.552]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.552]                       if (muffled) 
[09:31:13.552]                         invokeRestart("muffleMessage")
[09:31:13.552]                     }
[09:31:13.552]                     else if (inherits(cond, "warning")) {
[09:31:13.552]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.552]                       if (muffled) 
[09:31:13.552]                         invokeRestart("muffleWarning")
[09:31:13.552]                     }
[09:31:13.552]                     else if (inherits(cond, "condition")) {
[09:31:13.552]                       if (!is.null(pattern)) {
[09:31:13.552]                         computeRestarts <- base::computeRestarts
[09:31:13.552]                         grepl <- base::grepl
[09:31:13.552]                         restarts <- computeRestarts(cond)
[09:31:13.552]                         for (restart in restarts) {
[09:31:13.552]                           name <- restart$name
[09:31:13.552]                           if (is.null(name)) 
[09:31:13.552]                             next
[09:31:13.552]                           if (!grepl(pattern, name)) 
[09:31:13.552]                             next
[09:31:13.552]                           invokeRestart(restart)
[09:31:13.552]                           muffled <- TRUE
[09:31:13.552]                           break
[09:31:13.552]                         }
[09:31:13.552]                       }
[09:31:13.552]                     }
[09:31:13.552]                     invisible(muffled)
[09:31:13.552]                   }
[09:31:13.552]                   muffleCondition(cond)
[09:31:13.552]                 })
[09:31:13.552]             }))
[09:31:13.552]             future::FutureResult(value = ...future.value$value, 
[09:31:13.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.552]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.552]                     ...future.globalenv.names))
[09:31:13.552]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.552]         }, condition = base::local({
[09:31:13.552]             c <- base::c
[09:31:13.552]             inherits <- base::inherits
[09:31:13.552]             invokeRestart <- base::invokeRestart
[09:31:13.552]             length <- base::length
[09:31:13.552]             list <- base::list
[09:31:13.552]             seq.int <- base::seq.int
[09:31:13.552]             signalCondition <- base::signalCondition
[09:31:13.552]             sys.calls <- base::sys.calls
[09:31:13.552]             `[[` <- base::`[[`
[09:31:13.552]             `+` <- base::`+`
[09:31:13.552]             `<<-` <- base::`<<-`
[09:31:13.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.552]                   3L)]
[09:31:13.552]             }
[09:31:13.552]             function(cond) {
[09:31:13.552]                 is_error <- inherits(cond, "error")
[09:31:13.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.552]                   NULL)
[09:31:13.552]                 if (is_error) {
[09:31:13.552]                   sessionInformation <- function() {
[09:31:13.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.552]                       search = base::search(), system = base::Sys.info())
[09:31:13.552]                   }
[09:31:13.552]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.552]                     cond$call), session = sessionInformation(), 
[09:31:13.552]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.552]                   signalCondition(cond)
[09:31:13.552]                 }
[09:31:13.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.552]                 "immediateCondition"))) {
[09:31:13.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.552]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.552]                   if (TRUE && !signal) {
[09:31:13.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.552]                     {
[09:31:13.552]                       inherits <- base::inherits
[09:31:13.552]                       invokeRestart <- base::invokeRestart
[09:31:13.552]                       is.null <- base::is.null
[09:31:13.552]                       muffled <- FALSE
[09:31:13.552]                       if (inherits(cond, "message")) {
[09:31:13.552]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.552]                         if (muffled) 
[09:31:13.552]                           invokeRestart("muffleMessage")
[09:31:13.552]                       }
[09:31:13.552]                       else if (inherits(cond, "warning")) {
[09:31:13.552]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.552]                         if (muffled) 
[09:31:13.552]                           invokeRestart("muffleWarning")
[09:31:13.552]                       }
[09:31:13.552]                       else if (inherits(cond, "condition")) {
[09:31:13.552]                         if (!is.null(pattern)) {
[09:31:13.552]                           computeRestarts <- base::computeRestarts
[09:31:13.552]                           grepl <- base::grepl
[09:31:13.552]                           restarts <- computeRestarts(cond)
[09:31:13.552]                           for (restart in restarts) {
[09:31:13.552]                             name <- restart$name
[09:31:13.552]                             if (is.null(name)) 
[09:31:13.552]                               next
[09:31:13.552]                             if (!grepl(pattern, name)) 
[09:31:13.552]                               next
[09:31:13.552]                             invokeRestart(restart)
[09:31:13.552]                             muffled <- TRUE
[09:31:13.552]                             break
[09:31:13.552]                           }
[09:31:13.552]                         }
[09:31:13.552]                       }
[09:31:13.552]                       invisible(muffled)
[09:31:13.552]                     }
[09:31:13.552]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.552]                   }
[09:31:13.552]                 }
[09:31:13.552]                 else {
[09:31:13.552]                   if (TRUE) {
[09:31:13.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.552]                     {
[09:31:13.552]                       inherits <- base::inherits
[09:31:13.552]                       invokeRestart <- base::invokeRestart
[09:31:13.552]                       is.null <- base::is.null
[09:31:13.552]                       muffled <- FALSE
[09:31:13.552]                       if (inherits(cond, "message")) {
[09:31:13.552]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.552]                         if (muffled) 
[09:31:13.552]                           invokeRestart("muffleMessage")
[09:31:13.552]                       }
[09:31:13.552]                       else if (inherits(cond, "warning")) {
[09:31:13.552]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.552]                         if (muffled) 
[09:31:13.552]                           invokeRestart("muffleWarning")
[09:31:13.552]                       }
[09:31:13.552]                       else if (inherits(cond, "condition")) {
[09:31:13.552]                         if (!is.null(pattern)) {
[09:31:13.552]                           computeRestarts <- base::computeRestarts
[09:31:13.552]                           grepl <- base::grepl
[09:31:13.552]                           restarts <- computeRestarts(cond)
[09:31:13.552]                           for (restart in restarts) {
[09:31:13.552]                             name <- restart$name
[09:31:13.552]                             if (is.null(name)) 
[09:31:13.552]                               next
[09:31:13.552]                             if (!grepl(pattern, name)) 
[09:31:13.552]                               next
[09:31:13.552]                             invokeRestart(restart)
[09:31:13.552]                             muffled <- TRUE
[09:31:13.552]                             break
[09:31:13.552]                           }
[09:31:13.552]                         }
[09:31:13.552]                       }
[09:31:13.552]                       invisible(muffled)
[09:31:13.552]                     }
[09:31:13.552]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.552]                   }
[09:31:13.552]                 }
[09:31:13.552]             }
[09:31:13.552]         }))
[09:31:13.552]     }, error = function(ex) {
[09:31:13.552]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.552]                 ...future.rng), started = ...future.startTime, 
[09:31:13.552]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.552]             version = "1.8"), class = "FutureResult")
[09:31:13.552]     }, finally = {
[09:31:13.552]         if (!identical(...future.workdir, getwd())) 
[09:31:13.552]             setwd(...future.workdir)
[09:31:13.552]         {
[09:31:13.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.552]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.552]             }
[09:31:13.552]             base::options(...future.oldOptions)
[09:31:13.552]             if (.Platform$OS.type == "windows") {
[09:31:13.552]                 old_names <- names(...future.oldEnvVars)
[09:31:13.552]                 envs <- base::Sys.getenv()
[09:31:13.552]                 names <- names(envs)
[09:31:13.552]                 common <- intersect(names, old_names)
[09:31:13.552]                 added <- setdiff(names, old_names)
[09:31:13.552]                 removed <- setdiff(old_names, names)
[09:31:13.552]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.552]                   envs[common]]
[09:31:13.552]                 NAMES <- toupper(changed)
[09:31:13.552]                 args <- list()
[09:31:13.552]                 for (kk in seq_along(NAMES)) {
[09:31:13.552]                   name <- changed[[kk]]
[09:31:13.552]                   NAME <- NAMES[[kk]]
[09:31:13.552]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.552]                     next
[09:31:13.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.552]                 }
[09:31:13.552]                 NAMES <- toupper(added)
[09:31:13.552]                 for (kk in seq_along(NAMES)) {
[09:31:13.552]                   name <- added[[kk]]
[09:31:13.552]                   NAME <- NAMES[[kk]]
[09:31:13.552]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.552]                     next
[09:31:13.552]                   args[[name]] <- ""
[09:31:13.552]                 }
[09:31:13.552]                 NAMES <- toupper(removed)
[09:31:13.552]                 for (kk in seq_along(NAMES)) {
[09:31:13.552]                   name <- removed[[kk]]
[09:31:13.552]                   NAME <- NAMES[[kk]]
[09:31:13.552]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.552]                     next
[09:31:13.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.552]                 }
[09:31:13.552]                 if (length(args) > 0) 
[09:31:13.552]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.552]             }
[09:31:13.552]             else {
[09:31:13.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.552]             }
[09:31:13.552]             {
[09:31:13.552]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.552]                   0L) {
[09:31:13.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.552]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.552]                   base::options(opts)
[09:31:13.552]                 }
[09:31:13.552]                 {
[09:31:13.552]                   {
[09:31:13.552]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.552]                     NULL
[09:31:13.552]                   }
[09:31:13.552]                   options(future.plan = NULL)
[09:31:13.552]                   if (is.na(NA_character_)) 
[09:31:13.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.552]                     .init = FALSE)
[09:31:13.552]                 }
[09:31:13.552]             }
[09:31:13.552]         }
[09:31:13.552]     })
[09:31:13.552]     if (TRUE) {
[09:31:13.552]         base::sink(type = "output", split = FALSE)
[09:31:13.552]         if (TRUE) {
[09:31:13.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.552]         }
[09:31:13.552]         else {
[09:31:13.552]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.552]         }
[09:31:13.552]         base::close(...future.stdout)
[09:31:13.552]         ...future.stdout <- NULL
[09:31:13.552]     }
[09:31:13.552]     ...future.result$conditions <- ...future.conditions
[09:31:13.552]     ...future.result$finished <- base::Sys.time()
[09:31:13.552]     ...future.result
[09:31:13.552] }
[09:31:13.554] requestCore(): workers = 2
[09:31:13.556] MulticoreFuture started
[09:31:13.557] - Launch lazy future ... done
[09:31:13.557] run() for ‘MulticoreFuture’ ... done
[09:31:13.557] getGlobalsAndPackages() ...
[09:31:13.557] Searching for globals...
[09:31:13.557] plan(): Setting new future strategy stack:
[09:31:13.558] 
[09:31:13.558] Searching for globals ... DONE
[09:31:13.558] List of future strategies:
[09:31:13.558] 1. sequential:
[09:31:13.558]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.558]    - tweaked: FALSE
[09:31:13.558]    - call: NULL
[09:31:13.558] - globals: [0] <none>
[09:31:13.559] plan(): nbrOfWorkers() = 1
[09:31:13.559] getGlobalsAndPackages() ... DONE
[09:31:13.559] run() for ‘Future’ ...
[09:31:13.559] - state: ‘created’
[09:31:13.559] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.560] plan(): Setting new future strategy stack:
[09:31:13.560] List of future strategies:
[09:31:13.560] 1. multicore:
[09:31:13.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.560]    - tweaked: FALSE
[09:31:13.560]    - call: plan(strategy)
[09:31:13.565] plan(): nbrOfWorkers() = 2
[09:31:13.565] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.565]   - Field: ‘label’
[09:31:13.565]   - Field: ‘local’
[09:31:13.566]   - Field: ‘owner’
[09:31:13.566]   - Field: ‘envir’
[09:31:13.566]   - Field: ‘workers’
[09:31:13.566]   - Field: ‘packages’
[09:31:13.566]   - Field: ‘gc’
[09:31:13.566]   - Field: ‘job’
[09:31:13.567]   - Field: ‘conditions’
[09:31:13.567]   - Field: ‘expr’
[09:31:13.567]   - Field: ‘uuid’
[09:31:13.567]   - Field: ‘seed’
[09:31:13.567]   - Field: ‘version’
[09:31:13.567]   - Field: ‘result’
[09:31:13.567]   - Field: ‘asynchronous’
[09:31:13.568]   - Field: ‘calls’
[09:31:13.568]   - Field: ‘globals’
[09:31:13.568]   - Field: ‘stdout’
[09:31:13.568]   - Field: ‘earlySignal’
[09:31:13.568]   - Field: ‘lazy’
[09:31:13.569]   - Field: ‘state’
[09:31:13.569] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.569] - Launch lazy future ...
[09:31:13.569] Packages needed by the future expression (n = 0): <none>
[09:31:13.570] Packages needed by future strategies (n = 0): <none>
[09:31:13.571] {
[09:31:13.571]     {
[09:31:13.571]         {
[09:31:13.571]             ...future.startTime <- base::Sys.time()
[09:31:13.571]             {
[09:31:13.571]                 {
[09:31:13.571]                   {
[09:31:13.571]                     {
[09:31:13.571]                       base::local({
[09:31:13.571]                         has_future <- base::requireNamespace("future", 
[09:31:13.571]                           quietly = TRUE)
[09:31:13.571]                         if (has_future) {
[09:31:13.571]                           ns <- base::getNamespace("future")
[09:31:13.571]                           version <- ns[[".package"]][["version"]]
[09:31:13.571]                           if (is.null(version)) 
[09:31:13.571]                             version <- utils::packageVersion("future")
[09:31:13.571]                         }
[09:31:13.571]                         else {
[09:31:13.571]                           version <- NULL
[09:31:13.571]                         }
[09:31:13.571]                         if (!has_future || version < "1.8.0") {
[09:31:13.571]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.571]                             "", base::R.version$version.string), 
[09:31:13.571]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.571]                               "release", "version")], collapse = " "), 
[09:31:13.571]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.571]                             info)
[09:31:13.571]                           info <- base::paste(info, collapse = "; ")
[09:31:13.571]                           if (!has_future) {
[09:31:13.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.571]                               info)
[09:31:13.571]                           }
[09:31:13.571]                           else {
[09:31:13.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.571]                               info, version)
[09:31:13.571]                           }
[09:31:13.571]                           base::stop(msg)
[09:31:13.571]                         }
[09:31:13.571]                       })
[09:31:13.571]                     }
[09:31:13.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.571]                     base::options(mc.cores = 1L)
[09:31:13.571]                   }
[09:31:13.571]                   ...future.strategy.old <- future::plan("list")
[09:31:13.571]                   options(future.plan = NULL)
[09:31:13.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.571]                 }
[09:31:13.571]                 ...future.workdir <- getwd()
[09:31:13.571]             }
[09:31:13.571]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.571]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.571]         }
[09:31:13.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.571]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.571]             base::names(...future.oldOptions))
[09:31:13.571]     }
[09:31:13.571]     if (FALSE) {
[09:31:13.571]     }
[09:31:13.571]     else {
[09:31:13.571]         if (TRUE) {
[09:31:13.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.571]                 open = "w")
[09:31:13.571]         }
[09:31:13.571]         else {
[09:31:13.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.571]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.571]         }
[09:31:13.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.571]             base::sink(type = "output", split = FALSE)
[09:31:13.571]             base::close(...future.stdout)
[09:31:13.571]         }, add = TRUE)
[09:31:13.571]     }
[09:31:13.571]     ...future.frame <- base::sys.nframe()
[09:31:13.571]     ...future.conditions <- base::list()
[09:31:13.571]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.571]     if (FALSE) {
[09:31:13.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.571]     }
[09:31:13.571]     ...future.result <- base::tryCatch({
[09:31:13.571]         base::withCallingHandlers({
[09:31:13.571]             ...future.value <- base::withVisible(base::local({
[09:31:13.571]                 withCallingHandlers({
[09:31:13.571]                   NULL
[09:31:13.571]                 }, immediateCondition = function(cond) {
[09:31:13.571]                   save_rds <- function (object, pathname, ...) 
[09:31:13.571]                   {
[09:31:13.571]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.571]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.571]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.571]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.571]                         fi_tmp[["mtime"]])
[09:31:13.571]                     }
[09:31:13.571]                     tryCatch({
[09:31:13.571]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.571]                     }, error = function(ex) {
[09:31:13.571]                       msg <- conditionMessage(ex)
[09:31:13.571]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.571]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.571]                         fi_tmp[["mtime"]], msg)
[09:31:13.571]                       ex$message <- msg
[09:31:13.571]                       stop(ex)
[09:31:13.571]                     })
[09:31:13.571]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.571]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.571]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.571]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.571]                       fi <- file.info(pathname)
[09:31:13.571]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.571]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.571]                         fi[["size"]], fi[["mtime"]])
[09:31:13.571]                       stop(msg)
[09:31:13.571]                     }
[09:31:13.571]                     invisible(pathname)
[09:31:13.571]                   }
[09:31:13.571]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.571]                     rootPath = tempdir()) 
[09:31:13.571]                   {
[09:31:13.571]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.571]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.571]                       tmpdir = path, fileext = ".rds")
[09:31:13.571]                     save_rds(obj, file)
[09:31:13.571]                   }
[09:31:13.571]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.571]                   {
[09:31:13.571]                     inherits <- base::inherits
[09:31:13.571]                     invokeRestart <- base::invokeRestart
[09:31:13.571]                     is.null <- base::is.null
[09:31:13.571]                     muffled <- FALSE
[09:31:13.571]                     if (inherits(cond, "message")) {
[09:31:13.571]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.571]                       if (muffled) 
[09:31:13.571]                         invokeRestart("muffleMessage")
[09:31:13.571]                     }
[09:31:13.571]                     else if (inherits(cond, "warning")) {
[09:31:13.571]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.571]                       if (muffled) 
[09:31:13.571]                         invokeRestart("muffleWarning")
[09:31:13.571]                     }
[09:31:13.571]                     else if (inherits(cond, "condition")) {
[09:31:13.571]                       if (!is.null(pattern)) {
[09:31:13.571]                         computeRestarts <- base::computeRestarts
[09:31:13.571]                         grepl <- base::grepl
[09:31:13.571]                         restarts <- computeRestarts(cond)
[09:31:13.571]                         for (restart in restarts) {
[09:31:13.571]                           name <- restart$name
[09:31:13.571]                           if (is.null(name)) 
[09:31:13.571]                             next
[09:31:13.571]                           if (!grepl(pattern, name)) 
[09:31:13.571]                             next
[09:31:13.571]                           invokeRestart(restart)
[09:31:13.571]                           muffled <- TRUE
[09:31:13.571]                           break
[09:31:13.571]                         }
[09:31:13.571]                       }
[09:31:13.571]                     }
[09:31:13.571]                     invisible(muffled)
[09:31:13.571]                   }
[09:31:13.571]                   muffleCondition(cond)
[09:31:13.571]                 })
[09:31:13.571]             }))
[09:31:13.571]             future::FutureResult(value = ...future.value$value, 
[09:31:13.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.571]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.571]                     ...future.globalenv.names))
[09:31:13.571]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.571]         }, condition = base::local({
[09:31:13.571]             c <- base::c
[09:31:13.571]             inherits <- base::inherits
[09:31:13.571]             invokeRestart <- base::invokeRestart
[09:31:13.571]             length <- base::length
[09:31:13.571]             list <- base::list
[09:31:13.571]             seq.int <- base::seq.int
[09:31:13.571]             signalCondition <- base::signalCondition
[09:31:13.571]             sys.calls <- base::sys.calls
[09:31:13.571]             `[[` <- base::`[[`
[09:31:13.571]             `+` <- base::`+`
[09:31:13.571]             `<<-` <- base::`<<-`
[09:31:13.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.571]                   3L)]
[09:31:13.571]             }
[09:31:13.571]             function(cond) {
[09:31:13.571]                 is_error <- inherits(cond, "error")
[09:31:13.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.571]                   NULL)
[09:31:13.571]                 if (is_error) {
[09:31:13.571]                   sessionInformation <- function() {
[09:31:13.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.571]                       search = base::search(), system = base::Sys.info())
[09:31:13.571]                   }
[09:31:13.571]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.571]                     cond$call), session = sessionInformation(), 
[09:31:13.571]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.571]                   signalCondition(cond)
[09:31:13.571]                 }
[09:31:13.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.571]                 "immediateCondition"))) {
[09:31:13.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.571]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.571]                   if (TRUE && !signal) {
[09:31:13.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.571]                     {
[09:31:13.571]                       inherits <- base::inherits
[09:31:13.571]                       invokeRestart <- base::invokeRestart
[09:31:13.571]                       is.null <- base::is.null
[09:31:13.571]                       muffled <- FALSE
[09:31:13.571]                       if (inherits(cond, "message")) {
[09:31:13.571]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.571]                         if (muffled) 
[09:31:13.571]                           invokeRestart("muffleMessage")
[09:31:13.571]                       }
[09:31:13.571]                       else if (inherits(cond, "warning")) {
[09:31:13.571]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.571]                         if (muffled) 
[09:31:13.571]                           invokeRestart("muffleWarning")
[09:31:13.571]                       }
[09:31:13.571]                       else if (inherits(cond, "condition")) {
[09:31:13.571]                         if (!is.null(pattern)) {
[09:31:13.571]                           computeRestarts <- base::computeRestarts
[09:31:13.571]                           grepl <- base::grepl
[09:31:13.571]                           restarts <- computeRestarts(cond)
[09:31:13.571]                           for (restart in restarts) {
[09:31:13.571]                             name <- restart$name
[09:31:13.571]                             if (is.null(name)) 
[09:31:13.571]                               next
[09:31:13.571]                             if (!grepl(pattern, name)) 
[09:31:13.571]                               next
[09:31:13.571]                             invokeRestart(restart)
[09:31:13.571]                             muffled <- TRUE
[09:31:13.571]                             break
[09:31:13.571]                           }
[09:31:13.571]                         }
[09:31:13.571]                       }
[09:31:13.571]                       invisible(muffled)
[09:31:13.571]                     }
[09:31:13.571]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.571]                   }
[09:31:13.571]                 }
[09:31:13.571]                 else {
[09:31:13.571]                   if (TRUE) {
[09:31:13.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.571]                     {
[09:31:13.571]                       inherits <- base::inherits
[09:31:13.571]                       invokeRestart <- base::invokeRestart
[09:31:13.571]                       is.null <- base::is.null
[09:31:13.571]                       muffled <- FALSE
[09:31:13.571]                       if (inherits(cond, "message")) {
[09:31:13.571]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.571]                         if (muffled) 
[09:31:13.571]                           invokeRestart("muffleMessage")
[09:31:13.571]                       }
[09:31:13.571]                       else if (inherits(cond, "warning")) {
[09:31:13.571]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.571]                         if (muffled) 
[09:31:13.571]                           invokeRestart("muffleWarning")
[09:31:13.571]                       }
[09:31:13.571]                       else if (inherits(cond, "condition")) {
[09:31:13.571]                         if (!is.null(pattern)) {
[09:31:13.571]                           computeRestarts <- base::computeRestarts
[09:31:13.571]                           grepl <- base::grepl
[09:31:13.571]                           restarts <- computeRestarts(cond)
[09:31:13.571]                           for (restart in restarts) {
[09:31:13.571]                             name <- restart$name
[09:31:13.571]                             if (is.null(name)) 
[09:31:13.571]                               next
[09:31:13.571]                             if (!grepl(pattern, name)) 
[09:31:13.571]                               next
[09:31:13.571]                             invokeRestart(restart)
[09:31:13.571]                             muffled <- TRUE
[09:31:13.571]                             break
[09:31:13.571]                           }
[09:31:13.571]                         }
[09:31:13.571]                       }
[09:31:13.571]                       invisible(muffled)
[09:31:13.571]                     }
[09:31:13.571]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.571]                   }
[09:31:13.571]                 }
[09:31:13.571]             }
[09:31:13.571]         }))
[09:31:13.571]     }, error = function(ex) {
[09:31:13.571]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.571]                 ...future.rng), started = ...future.startTime, 
[09:31:13.571]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.571]             version = "1.8"), class = "FutureResult")
[09:31:13.571]     }, finally = {
[09:31:13.571]         if (!identical(...future.workdir, getwd())) 
[09:31:13.571]             setwd(...future.workdir)
[09:31:13.571]         {
[09:31:13.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.571]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.571]             }
[09:31:13.571]             base::options(...future.oldOptions)
[09:31:13.571]             if (.Platform$OS.type == "windows") {
[09:31:13.571]                 old_names <- names(...future.oldEnvVars)
[09:31:13.571]                 envs <- base::Sys.getenv()
[09:31:13.571]                 names <- names(envs)
[09:31:13.571]                 common <- intersect(names, old_names)
[09:31:13.571]                 added <- setdiff(names, old_names)
[09:31:13.571]                 removed <- setdiff(old_names, names)
[09:31:13.571]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.571]                   envs[common]]
[09:31:13.571]                 NAMES <- toupper(changed)
[09:31:13.571]                 args <- list()
[09:31:13.571]                 for (kk in seq_along(NAMES)) {
[09:31:13.571]                   name <- changed[[kk]]
[09:31:13.571]                   NAME <- NAMES[[kk]]
[09:31:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.571]                     next
[09:31:13.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.571]                 }
[09:31:13.571]                 NAMES <- toupper(added)
[09:31:13.571]                 for (kk in seq_along(NAMES)) {
[09:31:13.571]                   name <- added[[kk]]
[09:31:13.571]                   NAME <- NAMES[[kk]]
[09:31:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.571]                     next
[09:31:13.571]                   args[[name]] <- ""
[09:31:13.571]                 }
[09:31:13.571]                 NAMES <- toupper(removed)
[09:31:13.571]                 for (kk in seq_along(NAMES)) {
[09:31:13.571]                   name <- removed[[kk]]
[09:31:13.571]                   NAME <- NAMES[[kk]]
[09:31:13.571]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.571]                     next
[09:31:13.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.571]                 }
[09:31:13.571]                 if (length(args) > 0) 
[09:31:13.571]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.571]             }
[09:31:13.571]             else {
[09:31:13.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.571]             }
[09:31:13.571]             {
[09:31:13.571]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.571]                   0L) {
[09:31:13.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.571]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.571]                   base::options(opts)
[09:31:13.571]                 }
[09:31:13.571]                 {
[09:31:13.571]                   {
[09:31:13.571]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.571]                     NULL
[09:31:13.571]                   }
[09:31:13.571]                   options(future.plan = NULL)
[09:31:13.571]                   if (is.na(NA_character_)) 
[09:31:13.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.571]                     .init = FALSE)
[09:31:13.571]                 }
[09:31:13.571]             }
[09:31:13.571]         }
[09:31:13.571]     })
[09:31:13.571]     if (TRUE) {
[09:31:13.571]         base::sink(type = "output", split = FALSE)
[09:31:13.571]         if (TRUE) {
[09:31:13.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.571]         }
[09:31:13.571]         else {
[09:31:13.571]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.571]         }
[09:31:13.571]         base::close(...future.stdout)
[09:31:13.571]         ...future.stdout <- NULL
[09:31:13.571]     }
[09:31:13.571]     ...future.result$conditions <- ...future.conditions
[09:31:13.571]     ...future.result$finished <- base::Sys.time()
[09:31:13.571]     ...future.result
[09:31:13.571] }
[09:31:13.574] requestCore(): workers = 2
[09:31:13.577] MulticoreFuture started
[09:31:13.577] - Launch lazy future ... done
[09:31:13.577] run() for ‘MulticoreFuture’ ... done
[09:31:13.578] plan(): Setting new future strategy stack:
[09:31:13.578] getGlobalsAndPackages() ...
[09:31:13.578] Searching for globals...
[09:31:13.578] List of future strategies:
[09:31:13.578] 1. sequential:
[09:31:13.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.578]    - tweaked: FALSE
[09:31:13.578]    - call: NULL
[09:31:13.579] plan(): nbrOfWorkers() = 1
[09:31:13.580] - globals found: [1] ‘{’
[09:31:13.580] Searching for globals ... DONE
[09:31:13.580] Resolving globals: FALSE
[09:31:13.581] 
[09:31:13.581] 
[09:31:13.581] getGlobalsAndPackages() ... DONE
[09:31:13.581] plan(): Setting new future strategy stack:
[09:31:13.581] run() for ‘Future’ ...
[09:31:13.581] List of future strategies:
[09:31:13.581] 1. multicore:
[09:31:13.581]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.581]    - tweaked: FALSE
[09:31:13.581]    - call: plan(strategy)
[09:31:13.581] - state: ‘created’
[09:31:13.582] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.586] plan(): nbrOfWorkers() = 2
[09:31:13.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.586]   - Field: ‘label’
[09:31:13.587]   - Field: ‘local’
[09:31:13.587]   - Field: ‘owner’
[09:31:13.587]   - Field: ‘envir’
[09:31:13.587]   - Field: ‘workers’
[09:31:13.587]   - Field: ‘packages’
[09:31:13.587]   - Field: ‘gc’
[09:31:13.587]   - Field: ‘job’
[09:31:13.588]   - Field: ‘conditions’
[09:31:13.588]   - Field: ‘expr’
[09:31:13.588]   - Field: ‘uuid’
[09:31:13.588]   - Field: ‘seed’
[09:31:13.588]   - Field: ‘version’
[09:31:13.588]   - Field: ‘result’
[09:31:13.588]   - Field: ‘asynchronous’
[09:31:13.588]   - Field: ‘calls’
[09:31:13.589]   - Field: ‘globals’
[09:31:13.589]   - Field: ‘stdout’
[09:31:13.589]   - Field: ‘earlySignal’
[09:31:13.589]   - Field: ‘lazy’
[09:31:13.589]   - Field: ‘state’
[09:31:13.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.589] - Launch lazy future ...
[09:31:13.590] Packages needed by the future expression (n = 0): <none>
[09:31:13.590] Packages needed by future strategies (n = 0): <none>
[09:31:13.591] {
[09:31:13.591]     {
[09:31:13.591]         {
[09:31:13.591]             ...future.startTime <- base::Sys.time()
[09:31:13.591]             {
[09:31:13.591]                 {
[09:31:13.591]                   {
[09:31:13.591]                     {
[09:31:13.591]                       base::local({
[09:31:13.591]                         has_future <- base::requireNamespace("future", 
[09:31:13.591]                           quietly = TRUE)
[09:31:13.591]                         if (has_future) {
[09:31:13.591]                           ns <- base::getNamespace("future")
[09:31:13.591]                           version <- ns[[".package"]][["version"]]
[09:31:13.591]                           if (is.null(version)) 
[09:31:13.591]                             version <- utils::packageVersion("future")
[09:31:13.591]                         }
[09:31:13.591]                         else {
[09:31:13.591]                           version <- NULL
[09:31:13.591]                         }
[09:31:13.591]                         if (!has_future || version < "1.8.0") {
[09:31:13.591]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.591]                             "", base::R.version$version.string), 
[09:31:13.591]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.591]                               "release", "version")], collapse = " "), 
[09:31:13.591]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.591]                             info)
[09:31:13.591]                           info <- base::paste(info, collapse = "; ")
[09:31:13.591]                           if (!has_future) {
[09:31:13.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.591]                               info)
[09:31:13.591]                           }
[09:31:13.591]                           else {
[09:31:13.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.591]                               info, version)
[09:31:13.591]                           }
[09:31:13.591]                           base::stop(msg)
[09:31:13.591]                         }
[09:31:13.591]                       })
[09:31:13.591]                     }
[09:31:13.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.591]                     base::options(mc.cores = 1L)
[09:31:13.591]                   }
[09:31:13.591]                   ...future.strategy.old <- future::plan("list")
[09:31:13.591]                   options(future.plan = NULL)
[09:31:13.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.591]                 }
[09:31:13.591]                 ...future.workdir <- getwd()
[09:31:13.591]             }
[09:31:13.591]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.591]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.591]         }
[09:31:13.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.591]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.591]             base::names(...future.oldOptions))
[09:31:13.591]     }
[09:31:13.591]     if (FALSE) {
[09:31:13.591]     }
[09:31:13.591]     else {
[09:31:13.591]         if (TRUE) {
[09:31:13.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.591]                 open = "w")
[09:31:13.591]         }
[09:31:13.591]         else {
[09:31:13.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.591]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.591]         }
[09:31:13.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.591]             base::sink(type = "output", split = FALSE)
[09:31:13.591]             base::close(...future.stdout)
[09:31:13.591]         }, add = TRUE)
[09:31:13.591]     }
[09:31:13.591]     ...future.frame <- base::sys.nframe()
[09:31:13.591]     ...future.conditions <- base::list()
[09:31:13.591]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.591]     if (FALSE) {
[09:31:13.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.591]     }
[09:31:13.591]     ...future.result <- base::tryCatch({
[09:31:13.591]         base::withCallingHandlers({
[09:31:13.591]             ...future.value <- base::withVisible(base::local({
[09:31:13.591]                 withCallingHandlers({
[09:31:13.591]                   {
[09:31:13.591]                     4
[09:31:13.591]                   }
[09:31:13.591]                 }, immediateCondition = function(cond) {
[09:31:13.591]                   save_rds <- function (object, pathname, ...) 
[09:31:13.591]                   {
[09:31:13.591]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.591]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.591]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.591]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.591]                         fi_tmp[["mtime"]])
[09:31:13.591]                     }
[09:31:13.591]                     tryCatch({
[09:31:13.591]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.591]                     }, error = function(ex) {
[09:31:13.591]                       msg <- conditionMessage(ex)
[09:31:13.591]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.591]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.591]                         fi_tmp[["mtime"]], msg)
[09:31:13.591]                       ex$message <- msg
[09:31:13.591]                       stop(ex)
[09:31:13.591]                     })
[09:31:13.591]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.591]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.591]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.591]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.591]                       fi <- file.info(pathname)
[09:31:13.591]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.591]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.591]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.591]                         fi[["size"]], fi[["mtime"]])
[09:31:13.591]                       stop(msg)
[09:31:13.591]                     }
[09:31:13.591]                     invisible(pathname)
[09:31:13.591]                   }
[09:31:13.591]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.591]                     rootPath = tempdir()) 
[09:31:13.591]                   {
[09:31:13.591]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.591]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.591]                       tmpdir = path, fileext = ".rds")
[09:31:13.591]                     save_rds(obj, file)
[09:31:13.591]                   }
[09:31:13.591]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.591]                   {
[09:31:13.591]                     inherits <- base::inherits
[09:31:13.591]                     invokeRestart <- base::invokeRestart
[09:31:13.591]                     is.null <- base::is.null
[09:31:13.591]                     muffled <- FALSE
[09:31:13.591]                     if (inherits(cond, "message")) {
[09:31:13.591]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.591]                       if (muffled) 
[09:31:13.591]                         invokeRestart("muffleMessage")
[09:31:13.591]                     }
[09:31:13.591]                     else if (inherits(cond, "warning")) {
[09:31:13.591]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.591]                       if (muffled) 
[09:31:13.591]                         invokeRestart("muffleWarning")
[09:31:13.591]                     }
[09:31:13.591]                     else if (inherits(cond, "condition")) {
[09:31:13.591]                       if (!is.null(pattern)) {
[09:31:13.591]                         computeRestarts <- base::computeRestarts
[09:31:13.591]                         grepl <- base::grepl
[09:31:13.591]                         restarts <- computeRestarts(cond)
[09:31:13.591]                         for (restart in restarts) {
[09:31:13.591]                           name <- restart$name
[09:31:13.591]                           if (is.null(name)) 
[09:31:13.591]                             next
[09:31:13.591]                           if (!grepl(pattern, name)) 
[09:31:13.591]                             next
[09:31:13.591]                           invokeRestart(restart)
[09:31:13.591]                           muffled <- TRUE
[09:31:13.591]                           break
[09:31:13.591]                         }
[09:31:13.591]                       }
[09:31:13.591]                     }
[09:31:13.591]                     invisible(muffled)
[09:31:13.591]                   }
[09:31:13.591]                   muffleCondition(cond)
[09:31:13.591]                 })
[09:31:13.591]             }))
[09:31:13.591]             future::FutureResult(value = ...future.value$value, 
[09:31:13.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.591]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.591]                     ...future.globalenv.names))
[09:31:13.591]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.591]         }, condition = base::local({
[09:31:13.591]             c <- base::c
[09:31:13.591]             inherits <- base::inherits
[09:31:13.591]             invokeRestart <- base::invokeRestart
[09:31:13.591]             length <- base::length
[09:31:13.591]             list <- base::list
[09:31:13.591]             seq.int <- base::seq.int
[09:31:13.591]             signalCondition <- base::signalCondition
[09:31:13.591]             sys.calls <- base::sys.calls
[09:31:13.591]             `[[` <- base::`[[`
[09:31:13.591]             `+` <- base::`+`
[09:31:13.591]             `<<-` <- base::`<<-`
[09:31:13.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.591]                   3L)]
[09:31:13.591]             }
[09:31:13.591]             function(cond) {
[09:31:13.591]                 is_error <- inherits(cond, "error")
[09:31:13.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.591]                   NULL)
[09:31:13.591]                 if (is_error) {
[09:31:13.591]                   sessionInformation <- function() {
[09:31:13.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.591]                       search = base::search(), system = base::Sys.info())
[09:31:13.591]                   }
[09:31:13.591]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.591]                     cond$call), session = sessionInformation(), 
[09:31:13.591]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.591]                   signalCondition(cond)
[09:31:13.591]                 }
[09:31:13.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.591]                 "immediateCondition"))) {
[09:31:13.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.591]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.591]                   if (TRUE && !signal) {
[09:31:13.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.591]                     {
[09:31:13.591]                       inherits <- base::inherits
[09:31:13.591]                       invokeRestart <- base::invokeRestart
[09:31:13.591]                       is.null <- base::is.null
[09:31:13.591]                       muffled <- FALSE
[09:31:13.591]                       if (inherits(cond, "message")) {
[09:31:13.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.591]                         if (muffled) 
[09:31:13.591]                           invokeRestart("muffleMessage")
[09:31:13.591]                       }
[09:31:13.591]                       else if (inherits(cond, "warning")) {
[09:31:13.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.591]                         if (muffled) 
[09:31:13.591]                           invokeRestart("muffleWarning")
[09:31:13.591]                       }
[09:31:13.591]                       else if (inherits(cond, "condition")) {
[09:31:13.591]                         if (!is.null(pattern)) {
[09:31:13.591]                           computeRestarts <- base::computeRestarts
[09:31:13.591]                           grepl <- base::grepl
[09:31:13.591]                           restarts <- computeRestarts(cond)
[09:31:13.591]                           for (restart in restarts) {
[09:31:13.591]                             name <- restart$name
[09:31:13.591]                             if (is.null(name)) 
[09:31:13.591]                               next
[09:31:13.591]                             if (!grepl(pattern, name)) 
[09:31:13.591]                               next
[09:31:13.591]                             invokeRestart(restart)
[09:31:13.591]                             muffled <- TRUE
[09:31:13.591]                             break
[09:31:13.591]                           }
[09:31:13.591]                         }
[09:31:13.591]                       }
[09:31:13.591]                       invisible(muffled)
[09:31:13.591]                     }
[09:31:13.591]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.591]                   }
[09:31:13.591]                 }
[09:31:13.591]                 else {
[09:31:13.591]                   if (TRUE) {
[09:31:13.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.591]                     {
[09:31:13.591]                       inherits <- base::inherits
[09:31:13.591]                       invokeRestart <- base::invokeRestart
[09:31:13.591]                       is.null <- base::is.null
[09:31:13.591]                       muffled <- FALSE
[09:31:13.591]                       if (inherits(cond, "message")) {
[09:31:13.591]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.591]                         if (muffled) 
[09:31:13.591]                           invokeRestart("muffleMessage")
[09:31:13.591]                       }
[09:31:13.591]                       else if (inherits(cond, "warning")) {
[09:31:13.591]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.591]                         if (muffled) 
[09:31:13.591]                           invokeRestart("muffleWarning")
[09:31:13.591]                       }
[09:31:13.591]                       else if (inherits(cond, "condition")) {
[09:31:13.591]                         if (!is.null(pattern)) {
[09:31:13.591]                           computeRestarts <- base::computeRestarts
[09:31:13.591]                           grepl <- base::grepl
[09:31:13.591]                           restarts <- computeRestarts(cond)
[09:31:13.591]                           for (restart in restarts) {
[09:31:13.591]                             name <- restart$name
[09:31:13.591]                             if (is.null(name)) 
[09:31:13.591]                               next
[09:31:13.591]                             if (!grepl(pattern, name)) 
[09:31:13.591]                               next
[09:31:13.591]                             invokeRestart(restart)
[09:31:13.591]                             muffled <- TRUE
[09:31:13.591]                             break
[09:31:13.591]                           }
[09:31:13.591]                         }
[09:31:13.591]                       }
[09:31:13.591]                       invisible(muffled)
[09:31:13.591]                     }
[09:31:13.591]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.591]                   }
[09:31:13.591]                 }
[09:31:13.591]             }
[09:31:13.591]         }))
[09:31:13.591]     }, error = function(ex) {
[09:31:13.591]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.591]                 ...future.rng), started = ...future.startTime, 
[09:31:13.591]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.591]             version = "1.8"), class = "FutureResult")
[09:31:13.591]     }, finally = {
[09:31:13.591]         if (!identical(...future.workdir, getwd())) 
[09:31:13.591]             setwd(...future.workdir)
[09:31:13.591]         {
[09:31:13.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.591]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.591]             }
[09:31:13.591]             base::options(...future.oldOptions)
[09:31:13.591]             if (.Platform$OS.type == "windows") {
[09:31:13.591]                 old_names <- names(...future.oldEnvVars)
[09:31:13.591]                 envs <- base::Sys.getenv()
[09:31:13.591]                 names <- names(envs)
[09:31:13.591]                 common <- intersect(names, old_names)
[09:31:13.591]                 added <- setdiff(names, old_names)
[09:31:13.591]                 removed <- setdiff(old_names, names)
[09:31:13.591]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.591]                   envs[common]]
[09:31:13.591]                 NAMES <- toupper(changed)
[09:31:13.591]                 args <- list()
[09:31:13.591]                 for (kk in seq_along(NAMES)) {
[09:31:13.591]                   name <- changed[[kk]]
[09:31:13.591]                   NAME <- NAMES[[kk]]
[09:31:13.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.591]                     next
[09:31:13.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.591]                 }
[09:31:13.591]                 NAMES <- toupper(added)
[09:31:13.591]                 for (kk in seq_along(NAMES)) {
[09:31:13.591]                   name <- added[[kk]]
[09:31:13.591]                   NAME <- NAMES[[kk]]
[09:31:13.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.591]                     next
[09:31:13.591]                   args[[name]] <- ""
[09:31:13.591]                 }
[09:31:13.591]                 NAMES <- toupper(removed)
[09:31:13.591]                 for (kk in seq_along(NAMES)) {
[09:31:13.591]                   name <- removed[[kk]]
[09:31:13.591]                   NAME <- NAMES[[kk]]
[09:31:13.591]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.591]                     next
[09:31:13.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.591]                 }
[09:31:13.591]                 if (length(args) > 0) 
[09:31:13.591]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.591]             }
[09:31:13.591]             else {
[09:31:13.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.591]             }
[09:31:13.591]             {
[09:31:13.591]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.591]                   0L) {
[09:31:13.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.591]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.591]                   base::options(opts)
[09:31:13.591]                 }
[09:31:13.591]                 {
[09:31:13.591]                   {
[09:31:13.591]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.591]                     NULL
[09:31:13.591]                   }
[09:31:13.591]                   options(future.plan = NULL)
[09:31:13.591]                   if (is.na(NA_character_)) 
[09:31:13.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.591]                     .init = FALSE)
[09:31:13.591]                 }
[09:31:13.591]             }
[09:31:13.591]         }
[09:31:13.591]     })
[09:31:13.591]     if (TRUE) {
[09:31:13.591]         base::sink(type = "output", split = FALSE)
[09:31:13.591]         if (TRUE) {
[09:31:13.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.591]         }
[09:31:13.591]         else {
[09:31:13.591]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.591]         }
[09:31:13.591]         base::close(...future.stdout)
[09:31:13.591]         ...future.stdout <- NULL
[09:31:13.591]     }
[09:31:13.591]     ...future.result$conditions <- ...future.conditions
[09:31:13.591]     ...future.result$finished <- base::Sys.time()
[09:31:13.591]     ...future.result
[09:31:13.591] }
[09:31:13.594] requestCore(): workers = 2
[09:31:13.594] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:13.605] result() for MulticoreFuture ...
[09:31:13.606] result() for MulticoreFuture ...
[09:31:13.606] result() for MulticoreFuture ... done
[09:31:13.606] result() for MulticoreFuture ... done
[09:31:13.606] result() for MulticoreFuture ...
[09:31:13.606] result() for MulticoreFuture ... done
[09:31:13.609] MulticoreFuture started
[09:31:13.610] - Launch lazy future ... done
[09:31:13.610] run() for ‘MulticoreFuture’ ... done
[09:31:13.610] plan(): Setting new future strategy stack:
<environment: 0x55a3cc2ea290> 
[09:31:13.610] List of future strategies:
[09:31:13.610] 1. sequential:
[09:31:13.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.610]    - tweaked: FALSE
[09:31:13.610]    - call: NULL
[09:31:13.611] plan(): nbrOfWorkers() = 1
<environment: 0x55a3ccd91bb8> 
[09:31:13.613] plan(): Setting new future strategy stack:
[09:31:13.613] List of future strategies:
[09:31:13.613] 1. multicore:
[09:31:13.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.613]    - tweaked: FALSE
[09:31:13.613]    - call: plan(strategy)
[09:31:13.618] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:13.620] resolve() on environment ...
[09:31:13.620]  recursive: 0
[09:31:13.621]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:13.621] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.621] - nx: 4
[09:31:13.622] - relay: TRUE
[09:31:13.622] - stdout: TRUE
[09:31:13.622] - signal: TRUE
[09:31:13.622] - resignal: FALSE
[09:31:13.622] - force: TRUE
[09:31:13.622] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.622] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.622]  - until=2
[09:31:13.623]  - relaying element #2
[09:31:13.623] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.623] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.623] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.623]  length: 3 (resolved future 1)
[09:31:13.623] Future #2
[09:31:13.623] result() for MulticoreFuture ...
[09:31:13.624] result() for MulticoreFuture ... done
[09:31:13.624] result() for MulticoreFuture ...
[09:31:13.624] result() for MulticoreFuture ... done
[09:31:13.624] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:13.624] - nx: 4
[09:31:13.624] - relay: TRUE
[09:31:13.624] - stdout: TRUE
[09:31:13.624] - signal: TRUE
[09:31:13.625] - resignal: FALSE
[09:31:13.625] - force: TRUE
[09:31:13.625] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.625] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.625]  - until=2
[09:31:13.631]  - relaying element #2
[09:31:13.632] result() for MulticoreFuture ...
[09:31:13.632] result() for MulticoreFuture ... done
[09:31:13.632] result() for MulticoreFuture ...
[09:31:13.632] result() for MulticoreFuture ... done
[09:31:13.632] result() for MulticoreFuture ...
[09:31:13.632] result() for MulticoreFuture ... done
[09:31:13.633] result() for MulticoreFuture ...
[09:31:13.633] result() for MulticoreFuture ... done
[09:31:13.633] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.633] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.633] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:13.633]  length: 2 (resolved future 2)
[09:31:13.634] Future #3
[09:31:13.634] result() for MulticoreFuture ...
[09:31:13.634] result() for MulticoreFuture ...
[09:31:13.635] result() for MulticoreFuture ... done
[09:31:13.635] result() for MulticoreFuture ... done
[09:31:13.635] result() for MulticoreFuture ...
[09:31:13.635] result() for MulticoreFuture ... done
[09:31:13.635] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:13.635] - nx: 4
[09:31:13.635] - relay: TRUE
[09:31:13.636] - stdout: TRUE
[09:31:13.636] - signal: TRUE
[09:31:13.636] - resignal: FALSE
[09:31:13.636] - force: TRUE
[09:31:13.636] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.636] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.636]  - until=3
[09:31:13.636]  - relaying element #3
[09:31:13.637] result() for MulticoreFuture ...
[09:31:13.637] result() for MulticoreFuture ... done
[09:31:13.637] result() for MulticoreFuture ...
[09:31:13.637] result() for MulticoreFuture ... done
[09:31:13.637] result() for MulticoreFuture ...
[09:31:13.637] result() for MulticoreFuture ... done
[09:31:13.637] result() for MulticoreFuture ...
[09:31:13.638] result() for MulticoreFuture ... done
[09:31:13.638] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.638] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.638] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:13.638]  length: 1 (resolved future 3)
[09:31:13.638] Future #4
[09:31:13.638] result() for MulticoreFuture ...
[09:31:13.639] result() for MulticoreFuture ...
[09:31:13.639] result() for MulticoreFuture ... done
[09:31:13.639] result() for MulticoreFuture ... done
[09:31:13.639] result() for MulticoreFuture ...
[09:31:13.640] result() for MulticoreFuture ... done
[09:31:13.640] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:13.640] - nx: 4
[09:31:13.640] - relay: TRUE
[09:31:13.640] - stdout: TRUE
[09:31:13.640] - signal: TRUE
[09:31:13.640] - resignal: FALSE
[09:31:13.640] - force: TRUE
[09:31:13.641] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.641] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.641]  - until=4
[09:31:13.641]  - relaying element #4
[09:31:13.641] result() for MulticoreFuture ...
[09:31:13.641] result() for MulticoreFuture ... done
[09:31:13.641] result() for MulticoreFuture ...
[09:31:13.641] result() for MulticoreFuture ... done
[09:31:13.642] result() for MulticoreFuture ...
[09:31:13.642] result() for MulticoreFuture ... done
[09:31:13.642] result() for MulticoreFuture ...
[09:31:13.642] result() for MulticoreFuture ... done
[09:31:13.642] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.642] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.642] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:13.642]  length: 0 (resolved future 4)
[09:31:13.642] Relaying remaining futures
[09:31:13.643] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.643] - nx: 4
[09:31:13.643] - relay: TRUE
[09:31:13.643] - stdout: TRUE
[09:31:13.643] - signal: TRUE
[09:31:13.643] - resignal: FALSE
[09:31:13.643] - force: TRUE
[09:31:13.643] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.643] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:13.643] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.644] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.644] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.644] resolve() on environment ... DONE
[09:31:13.644] result() for MulticoreFuture ...
[09:31:13.644] result() for MulticoreFuture ... done
[09:31:13.644] result() for MulticoreFuture ...
[09:31:13.644] result() for MulticoreFuture ... done
[09:31:13.644] result() for MulticoreFuture ...
[09:31:13.644] result() for MulticoreFuture ... done
[09:31:13.645] result() for MulticoreFuture ...
[09:31:13.645] result() for MulticoreFuture ... done
[09:31:13.645] result() for MulticoreFuture ...
[09:31:13.645] result() for MulticoreFuture ... done
[09:31:13.645] result() for MulticoreFuture ...
[09:31:13.645] result() for MulticoreFuture ... done
<environment: 0x55a3cce45b40> 
Dimensions: c(1, 6)
[09:31:13.645] getGlobalsAndPackages() ...
[09:31:13.646] Searching for globals...
[09:31:13.646] 
[09:31:13.646] Searching for globals ... DONE
[09:31:13.646] - globals: [0] <none>
[09:31:13.646] getGlobalsAndPackages() ... DONE
[09:31:13.647] run() for ‘Future’ ...
[09:31:13.647] - state: ‘created’
[09:31:13.647] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.651]   - Field: ‘label’
[09:31:13.651]   - Field: ‘local’
[09:31:13.651]   - Field: ‘owner’
[09:31:13.651]   - Field: ‘envir’
[09:31:13.651]   - Field: ‘workers’
[09:31:13.652]   - Field: ‘packages’
[09:31:13.652]   - Field: ‘gc’
[09:31:13.652]   - Field: ‘job’
[09:31:13.652]   - Field: ‘conditions’
[09:31:13.652]   - Field: ‘expr’
[09:31:13.652]   - Field: ‘uuid’
[09:31:13.652]   - Field: ‘seed’
[09:31:13.652]   - Field: ‘version’
[09:31:13.652]   - Field: ‘result’
[09:31:13.653]   - Field: ‘asynchronous’
[09:31:13.653]   - Field: ‘calls’
[09:31:13.653]   - Field: ‘globals’
[09:31:13.653]   - Field: ‘stdout’
[09:31:13.653]   - Field: ‘earlySignal’
[09:31:13.653]   - Field: ‘lazy’
[09:31:13.653]   - Field: ‘state’
[09:31:13.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.653] - Launch lazy future ...
[09:31:13.654] Packages needed by the future expression (n = 0): <none>
[09:31:13.654] Packages needed by future strategies (n = 0): <none>
[09:31:13.654] {
[09:31:13.654]     {
[09:31:13.654]         {
[09:31:13.654]             ...future.startTime <- base::Sys.time()
[09:31:13.654]             {
[09:31:13.654]                 {
[09:31:13.654]                   {
[09:31:13.654]                     {
[09:31:13.654]                       base::local({
[09:31:13.654]                         has_future <- base::requireNamespace("future", 
[09:31:13.654]                           quietly = TRUE)
[09:31:13.654]                         if (has_future) {
[09:31:13.654]                           ns <- base::getNamespace("future")
[09:31:13.654]                           version <- ns[[".package"]][["version"]]
[09:31:13.654]                           if (is.null(version)) 
[09:31:13.654]                             version <- utils::packageVersion("future")
[09:31:13.654]                         }
[09:31:13.654]                         else {
[09:31:13.654]                           version <- NULL
[09:31:13.654]                         }
[09:31:13.654]                         if (!has_future || version < "1.8.0") {
[09:31:13.654]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.654]                             "", base::R.version$version.string), 
[09:31:13.654]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.654]                               "release", "version")], collapse = " "), 
[09:31:13.654]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.654]                             info)
[09:31:13.654]                           info <- base::paste(info, collapse = "; ")
[09:31:13.654]                           if (!has_future) {
[09:31:13.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.654]                               info)
[09:31:13.654]                           }
[09:31:13.654]                           else {
[09:31:13.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.654]                               info, version)
[09:31:13.654]                           }
[09:31:13.654]                           base::stop(msg)
[09:31:13.654]                         }
[09:31:13.654]                       })
[09:31:13.654]                     }
[09:31:13.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.654]                     base::options(mc.cores = 1L)
[09:31:13.654]                   }
[09:31:13.654]                   ...future.strategy.old <- future::plan("list")
[09:31:13.654]                   options(future.plan = NULL)
[09:31:13.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.654]                 }
[09:31:13.654]                 ...future.workdir <- getwd()
[09:31:13.654]             }
[09:31:13.654]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.654]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.654]         }
[09:31:13.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.654]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.654]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.654]             base::names(...future.oldOptions))
[09:31:13.654]     }
[09:31:13.654]     if (FALSE) {
[09:31:13.654]     }
[09:31:13.654]     else {
[09:31:13.654]         if (TRUE) {
[09:31:13.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.654]                 open = "w")
[09:31:13.654]         }
[09:31:13.654]         else {
[09:31:13.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.654]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.654]         }
[09:31:13.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.654]             base::sink(type = "output", split = FALSE)
[09:31:13.654]             base::close(...future.stdout)
[09:31:13.654]         }, add = TRUE)
[09:31:13.654]     }
[09:31:13.654]     ...future.frame <- base::sys.nframe()
[09:31:13.654]     ...future.conditions <- base::list()
[09:31:13.654]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.654]     if (FALSE) {
[09:31:13.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.654]     }
[09:31:13.654]     ...future.result <- base::tryCatch({
[09:31:13.654]         base::withCallingHandlers({
[09:31:13.654]             ...future.value <- base::withVisible(base::local({
[09:31:13.654]                 withCallingHandlers({
[09:31:13.654]                   2
[09:31:13.654]                 }, immediateCondition = function(cond) {
[09:31:13.654]                   save_rds <- function (object, pathname, ...) 
[09:31:13.654]                   {
[09:31:13.654]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.654]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.654]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.654]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.654]                         fi_tmp[["mtime"]])
[09:31:13.654]                     }
[09:31:13.654]                     tryCatch({
[09:31:13.654]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.654]                     }, error = function(ex) {
[09:31:13.654]                       msg <- conditionMessage(ex)
[09:31:13.654]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.654]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.654]                         fi_tmp[["mtime"]], msg)
[09:31:13.654]                       ex$message <- msg
[09:31:13.654]                       stop(ex)
[09:31:13.654]                     })
[09:31:13.654]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.654]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.654]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.654]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.654]                       fi <- file.info(pathname)
[09:31:13.654]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.654]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.654]                         fi[["size"]], fi[["mtime"]])
[09:31:13.654]                       stop(msg)
[09:31:13.654]                     }
[09:31:13.654]                     invisible(pathname)
[09:31:13.654]                   }
[09:31:13.654]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.654]                     rootPath = tempdir()) 
[09:31:13.654]                   {
[09:31:13.654]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.654]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.654]                       tmpdir = path, fileext = ".rds")
[09:31:13.654]                     save_rds(obj, file)
[09:31:13.654]                   }
[09:31:13.654]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.654]                   {
[09:31:13.654]                     inherits <- base::inherits
[09:31:13.654]                     invokeRestart <- base::invokeRestart
[09:31:13.654]                     is.null <- base::is.null
[09:31:13.654]                     muffled <- FALSE
[09:31:13.654]                     if (inherits(cond, "message")) {
[09:31:13.654]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.654]                       if (muffled) 
[09:31:13.654]                         invokeRestart("muffleMessage")
[09:31:13.654]                     }
[09:31:13.654]                     else if (inherits(cond, "warning")) {
[09:31:13.654]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.654]                       if (muffled) 
[09:31:13.654]                         invokeRestart("muffleWarning")
[09:31:13.654]                     }
[09:31:13.654]                     else if (inherits(cond, "condition")) {
[09:31:13.654]                       if (!is.null(pattern)) {
[09:31:13.654]                         computeRestarts <- base::computeRestarts
[09:31:13.654]                         grepl <- base::grepl
[09:31:13.654]                         restarts <- computeRestarts(cond)
[09:31:13.654]                         for (restart in restarts) {
[09:31:13.654]                           name <- restart$name
[09:31:13.654]                           if (is.null(name)) 
[09:31:13.654]                             next
[09:31:13.654]                           if (!grepl(pattern, name)) 
[09:31:13.654]                             next
[09:31:13.654]                           invokeRestart(restart)
[09:31:13.654]                           muffled <- TRUE
[09:31:13.654]                           break
[09:31:13.654]                         }
[09:31:13.654]                       }
[09:31:13.654]                     }
[09:31:13.654]                     invisible(muffled)
[09:31:13.654]                   }
[09:31:13.654]                   muffleCondition(cond)
[09:31:13.654]                 })
[09:31:13.654]             }))
[09:31:13.654]             future::FutureResult(value = ...future.value$value, 
[09:31:13.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.654]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.654]                     ...future.globalenv.names))
[09:31:13.654]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.654]         }, condition = base::local({
[09:31:13.654]             c <- base::c
[09:31:13.654]             inherits <- base::inherits
[09:31:13.654]             invokeRestart <- base::invokeRestart
[09:31:13.654]             length <- base::length
[09:31:13.654]             list <- base::list
[09:31:13.654]             seq.int <- base::seq.int
[09:31:13.654]             signalCondition <- base::signalCondition
[09:31:13.654]             sys.calls <- base::sys.calls
[09:31:13.654]             `[[` <- base::`[[`
[09:31:13.654]             `+` <- base::`+`
[09:31:13.654]             `<<-` <- base::`<<-`
[09:31:13.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.654]                   3L)]
[09:31:13.654]             }
[09:31:13.654]             function(cond) {
[09:31:13.654]                 is_error <- inherits(cond, "error")
[09:31:13.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.654]                   NULL)
[09:31:13.654]                 if (is_error) {
[09:31:13.654]                   sessionInformation <- function() {
[09:31:13.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.654]                       search = base::search(), system = base::Sys.info())
[09:31:13.654]                   }
[09:31:13.654]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.654]                     cond$call), session = sessionInformation(), 
[09:31:13.654]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.654]                   signalCondition(cond)
[09:31:13.654]                 }
[09:31:13.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.654]                 "immediateCondition"))) {
[09:31:13.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.654]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.654]                   if (TRUE && !signal) {
[09:31:13.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.654]                     {
[09:31:13.654]                       inherits <- base::inherits
[09:31:13.654]                       invokeRestart <- base::invokeRestart
[09:31:13.654]                       is.null <- base::is.null
[09:31:13.654]                       muffled <- FALSE
[09:31:13.654]                       if (inherits(cond, "message")) {
[09:31:13.654]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.654]                         if (muffled) 
[09:31:13.654]                           invokeRestart("muffleMessage")
[09:31:13.654]                       }
[09:31:13.654]                       else if (inherits(cond, "warning")) {
[09:31:13.654]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.654]                         if (muffled) 
[09:31:13.654]                           invokeRestart("muffleWarning")
[09:31:13.654]                       }
[09:31:13.654]                       else if (inherits(cond, "condition")) {
[09:31:13.654]                         if (!is.null(pattern)) {
[09:31:13.654]                           computeRestarts <- base::computeRestarts
[09:31:13.654]                           grepl <- base::grepl
[09:31:13.654]                           restarts <- computeRestarts(cond)
[09:31:13.654]                           for (restart in restarts) {
[09:31:13.654]                             name <- restart$name
[09:31:13.654]                             if (is.null(name)) 
[09:31:13.654]                               next
[09:31:13.654]                             if (!grepl(pattern, name)) 
[09:31:13.654]                               next
[09:31:13.654]                             invokeRestart(restart)
[09:31:13.654]                             muffled <- TRUE
[09:31:13.654]                             break
[09:31:13.654]                           }
[09:31:13.654]                         }
[09:31:13.654]                       }
[09:31:13.654]                       invisible(muffled)
[09:31:13.654]                     }
[09:31:13.654]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.654]                   }
[09:31:13.654]                 }
[09:31:13.654]                 else {
[09:31:13.654]                   if (TRUE) {
[09:31:13.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.654]                     {
[09:31:13.654]                       inherits <- base::inherits
[09:31:13.654]                       invokeRestart <- base::invokeRestart
[09:31:13.654]                       is.null <- base::is.null
[09:31:13.654]                       muffled <- FALSE
[09:31:13.654]                       if (inherits(cond, "message")) {
[09:31:13.654]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.654]                         if (muffled) 
[09:31:13.654]                           invokeRestart("muffleMessage")
[09:31:13.654]                       }
[09:31:13.654]                       else if (inherits(cond, "warning")) {
[09:31:13.654]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.654]                         if (muffled) 
[09:31:13.654]                           invokeRestart("muffleWarning")
[09:31:13.654]                       }
[09:31:13.654]                       else if (inherits(cond, "condition")) {
[09:31:13.654]                         if (!is.null(pattern)) {
[09:31:13.654]                           computeRestarts <- base::computeRestarts
[09:31:13.654]                           grepl <- base::grepl
[09:31:13.654]                           restarts <- computeRestarts(cond)
[09:31:13.654]                           for (restart in restarts) {
[09:31:13.654]                             name <- restart$name
[09:31:13.654]                             if (is.null(name)) 
[09:31:13.654]                               next
[09:31:13.654]                             if (!grepl(pattern, name)) 
[09:31:13.654]                               next
[09:31:13.654]                             invokeRestart(restart)
[09:31:13.654]                             muffled <- TRUE
[09:31:13.654]                             break
[09:31:13.654]                           }
[09:31:13.654]                         }
[09:31:13.654]                       }
[09:31:13.654]                       invisible(muffled)
[09:31:13.654]                     }
[09:31:13.654]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.654]                   }
[09:31:13.654]                 }
[09:31:13.654]             }
[09:31:13.654]         }))
[09:31:13.654]     }, error = function(ex) {
[09:31:13.654]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.654]                 ...future.rng), started = ...future.startTime, 
[09:31:13.654]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.654]             version = "1.8"), class = "FutureResult")
[09:31:13.654]     }, finally = {
[09:31:13.654]         if (!identical(...future.workdir, getwd())) 
[09:31:13.654]             setwd(...future.workdir)
[09:31:13.654]         {
[09:31:13.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.654]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.654]             }
[09:31:13.654]             base::options(...future.oldOptions)
[09:31:13.654]             if (.Platform$OS.type == "windows") {
[09:31:13.654]                 old_names <- names(...future.oldEnvVars)
[09:31:13.654]                 envs <- base::Sys.getenv()
[09:31:13.654]                 names <- names(envs)
[09:31:13.654]                 common <- intersect(names, old_names)
[09:31:13.654]                 added <- setdiff(names, old_names)
[09:31:13.654]                 removed <- setdiff(old_names, names)
[09:31:13.654]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.654]                   envs[common]]
[09:31:13.654]                 NAMES <- toupper(changed)
[09:31:13.654]                 args <- list()
[09:31:13.654]                 for (kk in seq_along(NAMES)) {
[09:31:13.654]                   name <- changed[[kk]]
[09:31:13.654]                   NAME <- NAMES[[kk]]
[09:31:13.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.654]                     next
[09:31:13.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.654]                 }
[09:31:13.654]                 NAMES <- toupper(added)
[09:31:13.654]                 for (kk in seq_along(NAMES)) {
[09:31:13.654]                   name <- added[[kk]]
[09:31:13.654]                   NAME <- NAMES[[kk]]
[09:31:13.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.654]                     next
[09:31:13.654]                   args[[name]] <- ""
[09:31:13.654]                 }
[09:31:13.654]                 NAMES <- toupper(removed)
[09:31:13.654]                 for (kk in seq_along(NAMES)) {
[09:31:13.654]                   name <- removed[[kk]]
[09:31:13.654]                   NAME <- NAMES[[kk]]
[09:31:13.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.654]                     next
[09:31:13.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.654]                 }
[09:31:13.654]                 if (length(args) > 0) 
[09:31:13.654]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.654]             }
[09:31:13.654]             else {
[09:31:13.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.654]             }
[09:31:13.654]             {
[09:31:13.654]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.654]                   0L) {
[09:31:13.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.654]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.654]                   base::options(opts)
[09:31:13.654]                 }
[09:31:13.654]                 {
[09:31:13.654]                   {
[09:31:13.654]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.654]                     NULL
[09:31:13.654]                   }
[09:31:13.654]                   options(future.plan = NULL)
[09:31:13.654]                   if (is.na(NA_character_)) 
[09:31:13.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.654]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.654]                     .init = FALSE)
[09:31:13.654]                 }
[09:31:13.654]             }
[09:31:13.654]         }
[09:31:13.654]     })
[09:31:13.654]     if (TRUE) {
[09:31:13.654]         base::sink(type = "output", split = FALSE)
[09:31:13.654]         if (TRUE) {
[09:31:13.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.654]         }
[09:31:13.654]         else {
[09:31:13.654]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.654]         }
[09:31:13.654]         base::close(...future.stdout)
[09:31:13.654]         ...future.stdout <- NULL
[09:31:13.654]     }
[09:31:13.654]     ...future.result$conditions <- ...future.conditions
[09:31:13.654]     ...future.result$finished <- base::Sys.time()
[09:31:13.654]     ...future.result
[09:31:13.654] }
[09:31:13.657] requestCore(): workers = 2
[09:31:13.659] MulticoreFuture started
[09:31:13.659] - Launch lazy future ... done
[09:31:13.659] run() for ‘MulticoreFuture’ ... done
[09:31:13.659] getGlobalsAndPackages() ...
[09:31:13.660] Searching for globals...
[09:31:13.660] plan(): Setting new future strategy stack:
[09:31:13.660] 
[09:31:13.661] Searching for globals ... DONE
[09:31:13.661] - globals: [0] <none>
[09:31:13.660] List of future strategies:
[09:31:13.660] 1. sequential:
[09:31:13.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.660]    - tweaked: FALSE
[09:31:13.660]    - call: NULL
[09:31:13.661] getGlobalsAndPackages() ... DONE
[09:31:13.661] plan(): nbrOfWorkers() = 1
[09:31:13.661] run() for ‘Future’ ...
[09:31:13.662] - state: ‘created’
[09:31:13.662] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.663] plan(): Setting new future strategy stack:
[09:31:13.663] List of future strategies:
[09:31:13.663] 1. multicore:
[09:31:13.663]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.663]    - tweaked: FALSE
[09:31:13.663]    - call: plan(strategy)
[09:31:13.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.667]   - Field: ‘label’
[09:31:13.667] plan(): nbrOfWorkers() = 2
[09:31:13.667]   - Field: ‘local’
[09:31:13.668]   - Field: ‘owner’
[09:31:13.668]   - Field: ‘envir’
[09:31:13.668]   - Field: ‘workers’
[09:31:13.668]   - Field: ‘packages’
[09:31:13.668]   - Field: ‘gc’
[09:31:13.668]   - Field: ‘job’
[09:31:13.669]   - Field: ‘conditions’
[09:31:13.669]   - Field: ‘expr’
[09:31:13.669]   - Field: ‘uuid’
[09:31:13.669]   - Field: ‘seed’
[09:31:13.669]   - Field: ‘version’
[09:31:13.669]   - Field: ‘result’
[09:31:13.670]   - Field: ‘asynchronous’
[09:31:13.670]   - Field: ‘calls’
[09:31:13.670]   - Field: ‘globals’
[09:31:13.670]   - Field: ‘stdout’
[09:31:13.670]   - Field: ‘earlySignal’
[09:31:13.670]   - Field: ‘lazy’
[09:31:13.671]   - Field: ‘state’
[09:31:13.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.671] - Launch lazy future ...
[09:31:13.671] Packages needed by the future expression (n = 0): <none>
[09:31:13.672] Packages needed by future strategies (n = 0): <none>
[09:31:13.673] {
[09:31:13.673]     {
[09:31:13.673]         {
[09:31:13.673]             ...future.startTime <- base::Sys.time()
[09:31:13.673]             {
[09:31:13.673]                 {
[09:31:13.673]                   {
[09:31:13.673]                     {
[09:31:13.673]                       base::local({
[09:31:13.673]                         has_future <- base::requireNamespace("future", 
[09:31:13.673]                           quietly = TRUE)
[09:31:13.673]                         if (has_future) {
[09:31:13.673]                           ns <- base::getNamespace("future")
[09:31:13.673]                           version <- ns[[".package"]][["version"]]
[09:31:13.673]                           if (is.null(version)) 
[09:31:13.673]                             version <- utils::packageVersion("future")
[09:31:13.673]                         }
[09:31:13.673]                         else {
[09:31:13.673]                           version <- NULL
[09:31:13.673]                         }
[09:31:13.673]                         if (!has_future || version < "1.8.0") {
[09:31:13.673]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.673]                             "", base::R.version$version.string), 
[09:31:13.673]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.673]                               "release", "version")], collapse = " "), 
[09:31:13.673]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.673]                             info)
[09:31:13.673]                           info <- base::paste(info, collapse = "; ")
[09:31:13.673]                           if (!has_future) {
[09:31:13.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.673]                               info)
[09:31:13.673]                           }
[09:31:13.673]                           else {
[09:31:13.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.673]                               info, version)
[09:31:13.673]                           }
[09:31:13.673]                           base::stop(msg)
[09:31:13.673]                         }
[09:31:13.673]                       })
[09:31:13.673]                     }
[09:31:13.673]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.673]                     base::options(mc.cores = 1L)
[09:31:13.673]                   }
[09:31:13.673]                   ...future.strategy.old <- future::plan("list")
[09:31:13.673]                   options(future.plan = NULL)
[09:31:13.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.673]                 }
[09:31:13.673]                 ...future.workdir <- getwd()
[09:31:13.673]             }
[09:31:13.673]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.673]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.673]         }
[09:31:13.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.673]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.673]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.673]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.673]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.673]             base::names(...future.oldOptions))
[09:31:13.673]     }
[09:31:13.673]     if (FALSE) {
[09:31:13.673]     }
[09:31:13.673]     else {
[09:31:13.673]         if (TRUE) {
[09:31:13.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.673]                 open = "w")
[09:31:13.673]         }
[09:31:13.673]         else {
[09:31:13.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.673]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.673]         }
[09:31:13.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.673]             base::sink(type = "output", split = FALSE)
[09:31:13.673]             base::close(...future.stdout)
[09:31:13.673]         }, add = TRUE)
[09:31:13.673]     }
[09:31:13.673]     ...future.frame <- base::sys.nframe()
[09:31:13.673]     ...future.conditions <- base::list()
[09:31:13.673]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.673]     if (FALSE) {
[09:31:13.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.673]     }
[09:31:13.673]     ...future.result <- base::tryCatch({
[09:31:13.673]         base::withCallingHandlers({
[09:31:13.673]             ...future.value <- base::withVisible(base::local({
[09:31:13.673]                 withCallingHandlers({
[09:31:13.673]                   NULL
[09:31:13.673]                 }, immediateCondition = function(cond) {
[09:31:13.673]                   save_rds <- function (object, pathname, ...) 
[09:31:13.673]                   {
[09:31:13.673]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.673]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.673]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.673]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.673]                         fi_tmp[["mtime"]])
[09:31:13.673]                     }
[09:31:13.673]                     tryCatch({
[09:31:13.673]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.673]                     }, error = function(ex) {
[09:31:13.673]                       msg <- conditionMessage(ex)
[09:31:13.673]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.673]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.673]                         fi_tmp[["mtime"]], msg)
[09:31:13.673]                       ex$message <- msg
[09:31:13.673]                       stop(ex)
[09:31:13.673]                     })
[09:31:13.673]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.673]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.673]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.673]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.673]                       fi <- file.info(pathname)
[09:31:13.673]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.673]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.673]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.673]                         fi[["size"]], fi[["mtime"]])
[09:31:13.673]                       stop(msg)
[09:31:13.673]                     }
[09:31:13.673]                     invisible(pathname)
[09:31:13.673]                   }
[09:31:13.673]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.673]                     rootPath = tempdir()) 
[09:31:13.673]                   {
[09:31:13.673]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.673]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.673]                       tmpdir = path, fileext = ".rds")
[09:31:13.673]                     save_rds(obj, file)
[09:31:13.673]                   }
[09:31:13.673]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.673]                   {
[09:31:13.673]                     inherits <- base::inherits
[09:31:13.673]                     invokeRestart <- base::invokeRestart
[09:31:13.673]                     is.null <- base::is.null
[09:31:13.673]                     muffled <- FALSE
[09:31:13.673]                     if (inherits(cond, "message")) {
[09:31:13.673]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.673]                       if (muffled) 
[09:31:13.673]                         invokeRestart("muffleMessage")
[09:31:13.673]                     }
[09:31:13.673]                     else if (inherits(cond, "warning")) {
[09:31:13.673]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.673]                       if (muffled) 
[09:31:13.673]                         invokeRestart("muffleWarning")
[09:31:13.673]                     }
[09:31:13.673]                     else if (inherits(cond, "condition")) {
[09:31:13.673]                       if (!is.null(pattern)) {
[09:31:13.673]                         computeRestarts <- base::computeRestarts
[09:31:13.673]                         grepl <- base::grepl
[09:31:13.673]                         restarts <- computeRestarts(cond)
[09:31:13.673]                         for (restart in restarts) {
[09:31:13.673]                           name <- restart$name
[09:31:13.673]                           if (is.null(name)) 
[09:31:13.673]                             next
[09:31:13.673]                           if (!grepl(pattern, name)) 
[09:31:13.673]                             next
[09:31:13.673]                           invokeRestart(restart)
[09:31:13.673]                           muffled <- TRUE
[09:31:13.673]                           break
[09:31:13.673]                         }
[09:31:13.673]                       }
[09:31:13.673]                     }
[09:31:13.673]                     invisible(muffled)
[09:31:13.673]                   }
[09:31:13.673]                   muffleCondition(cond)
[09:31:13.673]                 })
[09:31:13.673]             }))
[09:31:13.673]             future::FutureResult(value = ...future.value$value, 
[09:31:13.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.673]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.673]                     ...future.globalenv.names))
[09:31:13.673]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.673]         }, condition = base::local({
[09:31:13.673]             c <- base::c
[09:31:13.673]             inherits <- base::inherits
[09:31:13.673]             invokeRestart <- base::invokeRestart
[09:31:13.673]             length <- base::length
[09:31:13.673]             list <- base::list
[09:31:13.673]             seq.int <- base::seq.int
[09:31:13.673]             signalCondition <- base::signalCondition
[09:31:13.673]             sys.calls <- base::sys.calls
[09:31:13.673]             `[[` <- base::`[[`
[09:31:13.673]             `+` <- base::`+`
[09:31:13.673]             `<<-` <- base::`<<-`
[09:31:13.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.673]                   3L)]
[09:31:13.673]             }
[09:31:13.673]             function(cond) {
[09:31:13.673]                 is_error <- inherits(cond, "error")
[09:31:13.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.673]                   NULL)
[09:31:13.673]                 if (is_error) {
[09:31:13.673]                   sessionInformation <- function() {
[09:31:13.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.673]                       search = base::search(), system = base::Sys.info())
[09:31:13.673]                   }
[09:31:13.673]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.673]                     cond$call), session = sessionInformation(), 
[09:31:13.673]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.673]                   signalCondition(cond)
[09:31:13.673]                 }
[09:31:13.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.673]                 "immediateCondition"))) {
[09:31:13.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.673]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.673]                   if (TRUE && !signal) {
[09:31:13.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.673]                     {
[09:31:13.673]                       inherits <- base::inherits
[09:31:13.673]                       invokeRestart <- base::invokeRestart
[09:31:13.673]                       is.null <- base::is.null
[09:31:13.673]                       muffled <- FALSE
[09:31:13.673]                       if (inherits(cond, "message")) {
[09:31:13.673]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.673]                         if (muffled) 
[09:31:13.673]                           invokeRestart("muffleMessage")
[09:31:13.673]                       }
[09:31:13.673]                       else if (inherits(cond, "warning")) {
[09:31:13.673]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.673]                         if (muffled) 
[09:31:13.673]                           invokeRestart("muffleWarning")
[09:31:13.673]                       }
[09:31:13.673]                       else if (inherits(cond, "condition")) {
[09:31:13.673]                         if (!is.null(pattern)) {
[09:31:13.673]                           computeRestarts <- base::computeRestarts
[09:31:13.673]                           grepl <- base::grepl
[09:31:13.673]                           restarts <- computeRestarts(cond)
[09:31:13.673]                           for (restart in restarts) {
[09:31:13.673]                             name <- restart$name
[09:31:13.673]                             if (is.null(name)) 
[09:31:13.673]                               next
[09:31:13.673]                             if (!grepl(pattern, name)) 
[09:31:13.673]                               next
[09:31:13.673]                             invokeRestart(restart)
[09:31:13.673]                             muffled <- TRUE
[09:31:13.673]                             break
[09:31:13.673]                           }
[09:31:13.673]                         }
[09:31:13.673]                       }
[09:31:13.673]                       invisible(muffled)
[09:31:13.673]                     }
[09:31:13.673]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.673]                   }
[09:31:13.673]                 }
[09:31:13.673]                 else {
[09:31:13.673]                   if (TRUE) {
[09:31:13.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.673]                     {
[09:31:13.673]                       inherits <- base::inherits
[09:31:13.673]                       invokeRestart <- base::invokeRestart
[09:31:13.673]                       is.null <- base::is.null
[09:31:13.673]                       muffled <- FALSE
[09:31:13.673]                       if (inherits(cond, "message")) {
[09:31:13.673]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.673]                         if (muffled) 
[09:31:13.673]                           invokeRestart("muffleMessage")
[09:31:13.673]                       }
[09:31:13.673]                       else if (inherits(cond, "warning")) {
[09:31:13.673]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.673]                         if (muffled) 
[09:31:13.673]                           invokeRestart("muffleWarning")
[09:31:13.673]                       }
[09:31:13.673]                       else if (inherits(cond, "condition")) {
[09:31:13.673]                         if (!is.null(pattern)) {
[09:31:13.673]                           computeRestarts <- base::computeRestarts
[09:31:13.673]                           grepl <- base::grepl
[09:31:13.673]                           restarts <- computeRestarts(cond)
[09:31:13.673]                           for (restart in restarts) {
[09:31:13.673]                             name <- restart$name
[09:31:13.673]                             if (is.null(name)) 
[09:31:13.673]                               next
[09:31:13.673]                             if (!grepl(pattern, name)) 
[09:31:13.673]                               next
[09:31:13.673]                             invokeRestart(restart)
[09:31:13.673]                             muffled <- TRUE
[09:31:13.673]                             break
[09:31:13.673]                           }
[09:31:13.673]                         }
[09:31:13.673]                       }
[09:31:13.673]                       invisible(muffled)
[09:31:13.673]                     }
[09:31:13.673]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.673]                   }
[09:31:13.673]                 }
[09:31:13.673]             }
[09:31:13.673]         }))
[09:31:13.673]     }, error = function(ex) {
[09:31:13.673]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.673]                 ...future.rng), started = ...future.startTime, 
[09:31:13.673]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.673]             version = "1.8"), class = "FutureResult")
[09:31:13.673]     }, finally = {
[09:31:13.673]         if (!identical(...future.workdir, getwd())) 
[09:31:13.673]             setwd(...future.workdir)
[09:31:13.673]         {
[09:31:13.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.673]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.673]             }
[09:31:13.673]             base::options(...future.oldOptions)
[09:31:13.673]             if (.Platform$OS.type == "windows") {
[09:31:13.673]                 old_names <- names(...future.oldEnvVars)
[09:31:13.673]                 envs <- base::Sys.getenv()
[09:31:13.673]                 names <- names(envs)
[09:31:13.673]                 common <- intersect(names, old_names)
[09:31:13.673]                 added <- setdiff(names, old_names)
[09:31:13.673]                 removed <- setdiff(old_names, names)
[09:31:13.673]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.673]                   envs[common]]
[09:31:13.673]                 NAMES <- toupper(changed)
[09:31:13.673]                 args <- list()
[09:31:13.673]                 for (kk in seq_along(NAMES)) {
[09:31:13.673]                   name <- changed[[kk]]
[09:31:13.673]                   NAME <- NAMES[[kk]]
[09:31:13.673]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.673]                     next
[09:31:13.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.673]                 }
[09:31:13.673]                 NAMES <- toupper(added)
[09:31:13.673]                 for (kk in seq_along(NAMES)) {
[09:31:13.673]                   name <- added[[kk]]
[09:31:13.673]                   NAME <- NAMES[[kk]]
[09:31:13.673]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.673]                     next
[09:31:13.673]                   args[[name]] <- ""
[09:31:13.673]                 }
[09:31:13.673]                 NAMES <- toupper(removed)
[09:31:13.673]                 for (kk in seq_along(NAMES)) {
[09:31:13.673]                   name <- removed[[kk]]
[09:31:13.673]                   NAME <- NAMES[[kk]]
[09:31:13.673]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.673]                     next
[09:31:13.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.673]                 }
[09:31:13.673]                 if (length(args) > 0) 
[09:31:13.673]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.673]             }
[09:31:13.673]             else {
[09:31:13.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.673]             }
[09:31:13.673]             {
[09:31:13.673]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.673]                   0L) {
[09:31:13.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.673]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.673]                   base::options(opts)
[09:31:13.673]                 }
[09:31:13.673]                 {
[09:31:13.673]                   {
[09:31:13.673]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.673]                     NULL
[09:31:13.673]                   }
[09:31:13.673]                   options(future.plan = NULL)
[09:31:13.673]                   if (is.na(NA_character_)) 
[09:31:13.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.673]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.673]                     .init = FALSE)
[09:31:13.673]                 }
[09:31:13.673]             }
[09:31:13.673]         }
[09:31:13.673]     })
[09:31:13.673]     if (TRUE) {
[09:31:13.673]         base::sink(type = "output", split = FALSE)
[09:31:13.673]         if (TRUE) {
[09:31:13.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.673]         }
[09:31:13.673]         else {
[09:31:13.673]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.673]         }
[09:31:13.673]         base::close(...future.stdout)
[09:31:13.673]         ...future.stdout <- NULL
[09:31:13.673]     }
[09:31:13.673]     ...future.result$conditions <- ...future.conditions
[09:31:13.673]     ...future.result$finished <- base::Sys.time()
[09:31:13.673]     ...future.result
[09:31:13.673] }
[09:31:13.676] requestCore(): workers = 2
[09:31:13.678] MulticoreFuture started
[09:31:13.679] - Launch lazy future ... done
[09:31:13.679] run() for ‘MulticoreFuture’ ... done
[09:31:13.679] plan(): Setting new future strategy stack:
[09:31:13.680] getGlobalsAndPackages() ...
[09:31:13.680] Searching for globals...
[09:31:13.680] List of future strategies:
[09:31:13.680] 1. sequential:
[09:31:13.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.680]    - tweaked: FALSE
[09:31:13.680]    - call: NULL
[09:31:13.681] plan(): nbrOfWorkers() = 1
[09:31:13.682] - globals found: [1] ‘{’
[09:31:13.682] Searching for globals ... DONE
[09:31:13.682] Resolving globals: FALSE
[09:31:13.683] plan(): Setting new future strategy stack:
[09:31:13.683] 
[09:31:13.683] 
[09:31:13.683] getGlobalsAndPackages() ... DONE
[09:31:13.683] List of future strategies:
[09:31:13.683] 1. multicore:
[09:31:13.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.683]    - tweaked: FALSE
[09:31:13.683]    - call: plan(strategy)
[09:31:13.684] run() for ‘Future’ ...
[09:31:13.684] - state: ‘created’
[09:31:13.684] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.688] plan(): nbrOfWorkers() = 2
[09:31:13.689] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.689]   - Field: ‘label’
[09:31:13.689]   - Field: ‘local’
[09:31:13.689]   - Field: ‘owner’
[09:31:13.690]   - Field: ‘envir’
[09:31:13.690]   - Field: ‘workers’
[09:31:13.690]   - Field: ‘packages’
[09:31:13.690]   - Field: ‘gc’
[09:31:13.690]   - Field: ‘job’
[09:31:13.690]   - Field: ‘conditions’
[09:31:13.690]   - Field: ‘expr’
[09:31:13.691]   - Field: ‘uuid’
[09:31:13.691]   - Field: ‘seed’
[09:31:13.691]   - Field: ‘version’
[09:31:13.691]   - Field: ‘result’
[09:31:13.691]   - Field: ‘asynchronous’
[09:31:13.691]   - Field: ‘calls’
[09:31:13.692]   - Field: ‘globals’
[09:31:13.692]   - Field: ‘stdout’
[09:31:13.692]   - Field: ‘earlySignal’
[09:31:13.692]   - Field: ‘lazy’
[09:31:13.692]   - Field: ‘state’
[09:31:13.692] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.692] - Launch lazy future ...
[09:31:13.693] Packages needed by the future expression (n = 0): <none>
[09:31:13.693] Packages needed by future strategies (n = 0): <none>
[09:31:13.694] {
[09:31:13.694]     {
[09:31:13.694]         {
[09:31:13.694]             ...future.startTime <- base::Sys.time()
[09:31:13.694]             {
[09:31:13.694]                 {
[09:31:13.694]                   {
[09:31:13.694]                     {
[09:31:13.694]                       base::local({
[09:31:13.694]                         has_future <- base::requireNamespace("future", 
[09:31:13.694]                           quietly = TRUE)
[09:31:13.694]                         if (has_future) {
[09:31:13.694]                           ns <- base::getNamespace("future")
[09:31:13.694]                           version <- ns[[".package"]][["version"]]
[09:31:13.694]                           if (is.null(version)) 
[09:31:13.694]                             version <- utils::packageVersion("future")
[09:31:13.694]                         }
[09:31:13.694]                         else {
[09:31:13.694]                           version <- NULL
[09:31:13.694]                         }
[09:31:13.694]                         if (!has_future || version < "1.8.0") {
[09:31:13.694]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.694]                             "", base::R.version$version.string), 
[09:31:13.694]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.694]                               "release", "version")], collapse = " "), 
[09:31:13.694]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.694]                             info)
[09:31:13.694]                           info <- base::paste(info, collapse = "; ")
[09:31:13.694]                           if (!has_future) {
[09:31:13.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.694]                               info)
[09:31:13.694]                           }
[09:31:13.694]                           else {
[09:31:13.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.694]                               info, version)
[09:31:13.694]                           }
[09:31:13.694]                           base::stop(msg)
[09:31:13.694]                         }
[09:31:13.694]                       })
[09:31:13.694]                     }
[09:31:13.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.694]                     base::options(mc.cores = 1L)
[09:31:13.694]                   }
[09:31:13.694]                   ...future.strategy.old <- future::plan("list")
[09:31:13.694]                   options(future.plan = NULL)
[09:31:13.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.694]                 }
[09:31:13.694]                 ...future.workdir <- getwd()
[09:31:13.694]             }
[09:31:13.694]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.694]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.694]         }
[09:31:13.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.694]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.694]             base::names(...future.oldOptions))
[09:31:13.694]     }
[09:31:13.694]     if (FALSE) {
[09:31:13.694]     }
[09:31:13.694]     else {
[09:31:13.694]         if (TRUE) {
[09:31:13.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.694]                 open = "w")
[09:31:13.694]         }
[09:31:13.694]         else {
[09:31:13.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.694]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.694]         }
[09:31:13.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.694]             base::sink(type = "output", split = FALSE)
[09:31:13.694]             base::close(...future.stdout)
[09:31:13.694]         }, add = TRUE)
[09:31:13.694]     }
[09:31:13.694]     ...future.frame <- base::sys.nframe()
[09:31:13.694]     ...future.conditions <- base::list()
[09:31:13.694]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.694]     if (FALSE) {
[09:31:13.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.694]     }
[09:31:13.694]     ...future.result <- base::tryCatch({
[09:31:13.694]         base::withCallingHandlers({
[09:31:13.694]             ...future.value <- base::withVisible(base::local({
[09:31:13.694]                 withCallingHandlers({
[09:31:13.694]                   {
[09:31:13.694]                     4
[09:31:13.694]                   }
[09:31:13.694]                 }, immediateCondition = function(cond) {
[09:31:13.694]                   save_rds <- function (object, pathname, ...) 
[09:31:13.694]                   {
[09:31:13.694]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.694]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.694]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.694]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.694]                         fi_tmp[["mtime"]])
[09:31:13.694]                     }
[09:31:13.694]                     tryCatch({
[09:31:13.694]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.694]                     }, error = function(ex) {
[09:31:13.694]                       msg <- conditionMessage(ex)
[09:31:13.694]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.694]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.694]                         fi_tmp[["mtime"]], msg)
[09:31:13.694]                       ex$message <- msg
[09:31:13.694]                       stop(ex)
[09:31:13.694]                     })
[09:31:13.694]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.694]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.694]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.694]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.694]                       fi <- file.info(pathname)
[09:31:13.694]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.694]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.694]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.694]                         fi[["size"]], fi[["mtime"]])
[09:31:13.694]                       stop(msg)
[09:31:13.694]                     }
[09:31:13.694]                     invisible(pathname)
[09:31:13.694]                   }
[09:31:13.694]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.694]                     rootPath = tempdir()) 
[09:31:13.694]                   {
[09:31:13.694]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.694]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.694]                       tmpdir = path, fileext = ".rds")
[09:31:13.694]                     save_rds(obj, file)
[09:31:13.694]                   }
[09:31:13.694]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.694]                   {
[09:31:13.694]                     inherits <- base::inherits
[09:31:13.694]                     invokeRestart <- base::invokeRestart
[09:31:13.694]                     is.null <- base::is.null
[09:31:13.694]                     muffled <- FALSE
[09:31:13.694]                     if (inherits(cond, "message")) {
[09:31:13.694]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.694]                       if (muffled) 
[09:31:13.694]                         invokeRestart("muffleMessage")
[09:31:13.694]                     }
[09:31:13.694]                     else if (inherits(cond, "warning")) {
[09:31:13.694]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.694]                       if (muffled) 
[09:31:13.694]                         invokeRestart("muffleWarning")
[09:31:13.694]                     }
[09:31:13.694]                     else if (inherits(cond, "condition")) {
[09:31:13.694]                       if (!is.null(pattern)) {
[09:31:13.694]                         computeRestarts <- base::computeRestarts
[09:31:13.694]                         grepl <- base::grepl
[09:31:13.694]                         restarts <- computeRestarts(cond)
[09:31:13.694]                         for (restart in restarts) {
[09:31:13.694]                           name <- restart$name
[09:31:13.694]                           if (is.null(name)) 
[09:31:13.694]                             next
[09:31:13.694]                           if (!grepl(pattern, name)) 
[09:31:13.694]                             next
[09:31:13.694]                           invokeRestart(restart)
[09:31:13.694]                           muffled <- TRUE
[09:31:13.694]                           break
[09:31:13.694]                         }
[09:31:13.694]                       }
[09:31:13.694]                     }
[09:31:13.694]                     invisible(muffled)
[09:31:13.694]                   }
[09:31:13.694]                   muffleCondition(cond)
[09:31:13.694]                 })
[09:31:13.694]             }))
[09:31:13.694]             future::FutureResult(value = ...future.value$value, 
[09:31:13.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.694]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.694]                     ...future.globalenv.names))
[09:31:13.694]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.694]         }, condition = base::local({
[09:31:13.694]             c <- base::c
[09:31:13.694]             inherits <- base::inherits
[09:31:13.694]             invokeRestart <- base::invokeRestart
[09:31:13.694]             length <- base::length
[09:31:13.694]             list <- base::list
[09:31:13.694]             seq.int <- base::seq.int
[09:31:13.694]             signalCondition <- base::signalCondition
[09:31:13.694]             sys.calls <- base::sys.calls
[09:31:13.694]             `[[` <- base::`[[`
[09:31:13.694]             `+` <- base::`+`
[09:31:13.694]             `<<-` <- base::`<<-`
[09:31:13.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.694]                   3L)]
[09:31:13.694]             }
[09:31:13.694]             function(cond) {
[09:31:13.694]                 is_error <- inherits(cond, "error")
[09:31:13.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.694]                   NULL)
[09:31:13.694]                 if (is_error) {
[09:31:13.694]                   sessionInformation <- function() {
[09:31:13.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.694]                       search = base::search(), system = base::Sys.info())
[09:31:13.694]                   }
[09:31:13.694]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.694]                     cond$call), session = sessionInformation(), 
[09:31:13.694]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.694]                   signalCondition(cond)
[09:31:13.694]                 }
[09:31:13.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.694]                 "immediateCondition"))) {
[09:31:13.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.694]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.694]                   if (TRUE && !signal) {
[09:31:13.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.694]                     {
[09:31:13.694]                       inherits <- base::inherits
[09:31:13.694]                       invokeRestart <- base::invokeRestart
[09:31:13.694]                       is.null <- base::is.null
[09:31:13.694]                       muffled <- FALSE
[09:31:13.694]                       if (inherits(cond, "message")) {
[09:31:13.694]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.694]                         if (muffled) 
[09:31:13.694]                           invokeRestart("muffleMessage")
[09:31:13.694]                       }
[09:31:13.694]                       else if (inherits(cond, "warning")) {
[09:31:13.694]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.694]                         if (muffled) 
[09:31:13.694]                           invokeRestart("muffleWarning")
[09:31:13.694]                       }
[09:31:13.694]                       else if (inherits(cond, "condition")) {
[09:31:13.694]                         if (!is.null(pattern)) {
[09:31:13.694]                           computeRestarts <- base::computeRestarts
[09:31:13.694]                           grepl <- base::grepl
[09:31:13.694]                           restarts <- computeRestarts(cond)
[09:31:13.694]                           for (restart in restarts) {
[09:31:13.694]                             name <- restart$name
[09:31:13.694]                             if (is.null(name)) 
[09:31:13.694]                               next
[09:31:13.694]                             if (!grepl(pattern, name)) 
[09:31:13.694]                               next
[09:31:13.694]                             invokeRestart(restart)
[09:31:13.694]                             muffled <- TRUE
[09:31:13.694]                             break
[09:31:13.694]                           }
[09:31:13.694]                         }
[09:31:13.694]                       }
[09:31:13.694]                       invisible(muffled)
[09:31:13.694]                     }
[09:31:13.694]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.694]                   }
[09:31:13.694]                 }
[09:31:13.694]                 else {
[09:31:13.694]                   if (TRUE) {
[09:31:13.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.694]                     {
[09:31:13.694]                       inherits <- base::inherits
[09:31:13.694]                       invokeRestart <- base::invokeRestart
[09:31:13.694]                       is.null <- base::is.null
[09:31:13.694]                       muffled <- FALSE
[09:31:13.694]                       if (inherits(cond, "message")) {
[09:31:13.694]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.694]                         if (muffled) 
[09:31:13.694]                           invokeRestart("muffleMessage")
[09:31:13.694]                       }
[09:31:13.694]                       else if (inherits(cond, "warning")) {
[09:31:13.694]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.694]                         if (muffled) 
[09:31:13.694]                           invokeRestart("muffleWarning")
[09:31:13.694]                       }
[09:31:13.694]                       else if (inherits(cond, "condition")) {
[09:31:13.694]                         if (!is.null(pattern)) {
[09:31:13.694]                           computeRestarts <- base::computeRestarts
[09:31:13.694]                           grepl <- base::grepl
[09:31:13.694]                           restarts <- computeRestarts(cond)
[09:31:13.694]                           for (restart in restarts) {
[09:31:13.694]                             name <- restart$name
[09:31:13.694]                             if (is.null(name)) 
[09:31:13.694]                               next
[09:31:13.694]                             if (!grepl(pattern, name)) 
[09:31:13.694]                               next
[09:31:13.694]                             invokeRestart(restart)
[09:31:13.694]                             muffled <- TRUE
[09:31:13.694]                             break
[09:31:13.694]                           }
[09:31:13.694]                         }
[09:31:13.694]                       }
[09:31:13.694]                       invisible(muffled)
[09:31:13.694]                     }
[09:31:13.694]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.694]                   }
[09:31:13.694]                 }
[09:31:13.694]             }
[09:31:13.694]         }))
[09:31:13.694]     }, error = function(ex) {
[09:31:13.694]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.694]                 ...future.rng), started = ...future.startTime, 
[09:31:13.694]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.694]             version = "1.8"), class = "FutureResult")
[09:31:13.694]     }, finally = {
[09:31:13.694]         if (!identical(...future.workdir, getwd())) 
[09:31:13.694]             setwd(...future.workdir)
[09:31:13.694]         {
[09:31:13.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.694]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.694]             }
[09:31:13.694]             base::options(...future.oldOptions)
[09:31:13.694]             if (.Platform$OS.type == "windows") {
[09:31:13.694]                 old_names <- names(...future.oldEnvVars)
[09:31:13.694]                 envs <- base::Sys.getenv()
[09:31:13.694]                 names <- names(envs)
[09:31:13.694]                 common <- intersect(names, old_names)
[09:31:13.694]                 added <- setdiff(names, old_names)
[09:31:13.694]                 removed <- setdiff(old_names, names)
[09:31:13.694]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.694]                   envs[common]]
[09:31:13.694]                 NAMES <- toupper(changed)
[09:31:13.694]                 args <- list()
[09:31:13.694]                 for (kk in seq_along(NAMES)) {
[09:31:13.694]                   name <- changed[[kk]]
[09:31:13.694]                   NAME <- NAMES[[kk]]
[09:31:13.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.694]                     next
[09:31:13.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.694]                 }
[09:31:13.694]                 NAMES <- toupper(added)
[09:31:13.694]                 for (kk in seq_along(NAMES)) {
[09:31:13.694]                   name <- added[[kk]]
[09:31:13.694]                   NAME <- NAMES[[kk]]
[09:31:13.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.694]                     next
[09:31:13.694]                   args[[name]] <- ""
[09:31:13.694]                 }
[09:31:13.694]                 NAMES <- toupper(removed)
[09:31:13.694]                 for (kk in seq_along(NAMES)) {
[09:31:13.694]                   name <- removed[[kk]]
[09:31:13.694]                   NAME <- NAMES[[kk]]
[09:31:13.694]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.694]                     next
[09:31:13.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.694]                 }
[09:31:13.694]                 if (length(args) > 0) 
[09:31:13.694]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.694]             }
[09:31:13.694]             else {
[09:31:13.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.694]             }
[09:31:13.694]             {
[09:31:13.694]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.694]                   0L) {
[09:31:13.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.694]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.694]                   base::options(opts)
[09:31:13.694]                 }
[09:31:13.694]                 {
[09:31:13.694]                   {
[09:31:13.694]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.694]                     NULL
[09:31:13.694]                   }
[09:31:13.694]                   options(future.plan = NULL)
[09:31:13.694]                   if (is.na(NA_character_)) 
[09:31:13.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.694]                     .init = FALSE)
[09:31:13.694]                 }
[09:31:13.694]             }
[09:31:13.694]         }
[09:31:13.694]     })
[09:31:13.694]     if (TRUE) {
[09:31:13.694]         base::sink(type = "output", split = FALSE)
[09:31:13.694]         if (TRUE) {
[09:31:13.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.694]         }
[09:31:13.694]         else {
[09:31:13.694]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.694]         }
[09:31:13.694]         base::close(...future.stdout)
[09:31:13.694]         ...future.stdout <- NULL
[09:31:13.694]     }
[09:31:13.694]     ...future.result$conditions <- ...future.conditions
[09:31:13.694]     ...future.result$finished <- base::Sys.time()
[09:31:13.694]     ...future.result
[09:31:13.694] }
[09:31:13.697] requestCore(): workers = 2
[09:31:13.698] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:13.720] result() for MulticoreFuture ...
[09:31:13.721] result() for MulticoreFuture ...
[09:31:13.721] result() for MulticoreFuture ... done
[09:31:13.721] result() for MulticoreFuture ... done
[09:31:13.721] result() for MulticoreFuture ...
[09:31:13.722] result() for MulticoreFuture ... done
[09:31:13.724] MulticoreFuture started
[09:31:13.724] - Launch lazy future ... done
[09:31:13.725] run() for ‘MulticoreFuture’ ... done
[09:31:13.725] plan(): Setting new future strategy stack:
<environment: 0x55a3caca75e8> 
[09:31:13.726] List of future strategies:
[09:31:13.726] 1. sequential:
[09:31:13.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.726]    - tweaked: FALSE
[09:31:13.726]    - call: NULL
[09:31:13.727] plan(): nbrOfWorkers() = 1
<environment: 0x55a3cc3c20f8> 
[09:31:13.729] plan(): Setting new future strategy stack:
[09:31:13.730] List of future strategies:
[09:31:13.730] 1. multicore:
[09:31:13.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.730]    - tweaked: FALSE
[09:31:13.730]    - call: plan(strategy)
[09:31:13.734] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:13.737] resolve() on environment ...
[09:31:13.737]  recursive: 0
[09:31:13.738]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:13.738] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.738] - nx: 4
[09:31:13.738] - relay: TRUE
[09:31:13.738] - stdout: TRUE
[09:31:13.738] - signal: TRUE
[09:31:13.738] - resignal: FALSE
[09:31:13.739] - force: TRUE
[09:31:13.739] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.739] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.739]  - until=2
[09:31:13.739]  - relaying element #2
[09:31:13.739] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.739] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.739] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.740]  length: 3 (resolved future 1)
[09:31:13.740] Future #2
[09:31:13.740] result() for MulticoreFuture ...
[09:31:13.740] result() for MulticoreFuture ... done
[09:31:13.740] result() for MulticoreFuture ...
[09:31:13.740] result() for MulticoreFuture ... done
[09:31:13.741] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:13.741] - nx: 4
[09:31:13.741] - relay: TRUE
[09:31:13.741] - stdout: TRUE
[09:31:13.741] - signal: TRUE
[09:31:13.741] - resignal: FALSE
[09:31:13.741] - force: TRUE
[09:31:13.741] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.742] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.742]  - until=2
[09:31:13.742]  - relaying element #2
[09:31:13.742] result() for MulticoreFuture ...
[09:31:13.742] result() for MulticoreFuture ... done
[09:31:13.742] result() for MulticoreFuture ...
[09:31:13.742] result() for MulticoreFuture ... done
[09:31:13.742] result() for MulticoreFuture ...
[09:31:13.743] result() for MulticoreFuture ... done
[09:31:13.743] result() for MulticoreFuture ...
[09:31:13.743] result() for MulticoreFuture ... done
[09:31:13.743] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.743] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.743] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:13.743]  length: 2 (resolved future 2)
[09:31:13.744] Future #3
[09:31:13.744] result() for MulticoreFuture ...
[09:31:13.745] result() for MulticoreFuture ...
[09:31:13.745] result() for MulticoreFuture ... done
[09:31:13.745] result() for MulticoreFuture ... done
[09:31:13.745] result() for MulticoreFuture ...
[09:31:13.745] result() for MulticoreFuture ... done
[09:31:13.745] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:13.745] - nx: 4
[09:31:13.746] - relay: TRUE
[09:31:13.746] - stdout: TRUE
[09:31:13.746] - signal: TRUE
[09:31:13.746] - resignal: FALSE
[09:31:13.746] - force: TRUE
[09:31:13.746] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.746] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.746]  - until=3
[09:31:13.746]  - relaying element #3
[09:31:13.747] result() for MulticoreFuture ...
[09:31:13.747] result() for MulticoreFuture ... done
[09:31:13.747] result() for MulticoreFuture ...
[09:31:13.747] result() for MulticoreFuture ... done
[09:31:13.747] result() for MulticoreFuture ...
[09:31:13.747] result() for MulticoreFuture ... done
[09:31:13.747] result() for MulticoreFuture ...
[09:31:13.748] result() for MulticoreFuture ... done
[09:31:13.748] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.748] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.748] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:13.748]  length: 1 (resolved future 3)
[09:31:13.748] Future #4
[09:31:13.749] result() for MulticoreFuture ...
[09:31:13.749] result() for MulticoreFuture ...
[09:31:13.749] result() for MulticoreFuture ... done
[09:31:13.750] result() for MulticoreFuture ... done
[09:31:13.750] result() for MulticoreFuture ...
[09:31:13.750] result() for MulticoreFuture ... done
[09:31:13.750] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:13.750] - nx: 4
[09:31:13.750] - relay: TRUE
[09:31:13.751] - stdout: TRUE
[09:31:13.751] - signal: TRUE
[09:31:13.751] - resignal: FALSE
[09:31:13.751] - force: TRUE
[09:31:13.751] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.751] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.752]  - until=4
[09:31:13.752]  - relaying element #4
[09:31:13.752] result() for MulticoreFuture ...
[09:31:13.752] result() for MulticoreFuture ... done
[09:31:13.752] result() for MulticoreFuture ...
[09:31:13.752] result() for MulticoreFuture ... done
[09:31:13.753] result() for MulticoreFuture ...
[09:31:13.753] result() for MulticoreFuture ... done
[09:31:13.753] result() for MulticoreFuture ...
[09:31:13.753] result() for MulticoreFuture ... done
[09:31:13.753] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.753] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.753] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:13.753]  length: 0 (resolved future 4)
[09:31:13.753] Relaying remaining futures
[09:31:13.753] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.754] - nx: 4
[09:31:13.754] - relay: TRUE
[09:31:13.754] - stdout: TRUE
[09:31:13.754] - signal: TRUE
[09:31:13.754] - resignal: FALSE
[09:31:13.754] - force: TRUE
[09:31:13.754] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.754] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:13.754] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.754] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.755] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.755] resolve() on environment ... DONE
[09:31:13.755] result() for MulticoreFuture ...
[09:31:13.755] result() for MulticoreFuture ... done
[09:31:13.755] result() for MulticoreFuture ...
[09:31:13.755] result() for MulticoreFuture ... done
[09:31:13.755] result() for MulticoreFuture ...
[09:31:13.755] result() for MulticoreFuture ... done
[09:31:13.755] result() for MulticoreFuture ...
[09:31:13.756] result() for MulticoreFuture ... done
[09:31:13.756] result() for MulticoreFuture ...
[09:31:13.756] result() for MulticoreFuture ... done
[09:31:13.756] result() for MulticoreFuture ...
[09:31:13.756] result() for MulticoreFuture ... done
<environment: 0x55a3cc480f58> 
Dimensions: c(2, 3)
[09:31:13.756] getGlobalsAndPackages() ...
[09:31:13.757] Searching for globals...
[09:31:13.757] 
[09:31:13.757] Searching for globals ... DONE
[09:31:13.757] - globals: [0] <none>
[09:31:13.757] getGlobalsAndPackages() ... DONE
[09:31:13.758] run() for ‘Future’ ...
[09:31:13.758] - state: ‘created’
[09:31:13.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.762]   - Field: ‘label’
[09:31:13.762]   - Field: ‘local’
[09:31:13.762]   - Field: ‘owner’
[09:31:13.762]   - Field: ‘envir’
[09:31:13.763]   - Field: ‘workers’
[09:31:13.763]   - Field: ‘packages’
[09:31:13.763]   - Field: ‘gc’
[09:31:13.763]   - Field: ‘job’
[09:31:13.763]   - Field: ‘conditions’
[09:31:13.763]   - Field: ‘expr’
[09:31:13.763]   - Field: ‘uuid’
[09:31:13.763]   - Field: ‘seed’
[09:31:13.763]   - Field: ‘version’
[09:31:13.764]   - Field: ‘result’
[09:31:13.764]   - Field: ‘asynchronous’
[09:31:13.764]   - Field: ‘calls’
[09:31:13.764]   - Field: ‘globals’
[09:31:13.764]   - Field: ‘stdout’
[09:31:13.764]   - Field: ‘earlySignal’
[09:31:13.764]   - Field: ‘lazy’
[09:31:13.764]   - Field: ‘state’
[09:31:13.764] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.765] - Launch lazy future ...
[09:31:13.765] Packages needed by the future expression (n = 0): <none>
[09:31:13.765] Packages needed by future strategies (n = 0): <none>
[09:31:13.765] {
[09:31:13.765]     {
[09:31:13.765]         {
[09:31:13.765]             ...future.startTime <- base::Sys.time()
[09:31:13.765]             {
[09:31:13.765]                 {
[09:31:13.765]                   {
[09:31:13.765]                     {
[09:31:13.765]                       base::local({
[09:31:13.765]                         has_future <- base::requireNamespace("future", 
[09:31:13.765]                           quietly = TRUE)
[09:31:13.765]                         if (has_future) {
[09:31:13.765]                           ns <- base::getNamespace("future")
[09:31:13.765]                           version <- ns[[".package"]][["version"]]
[09:31:13.765]                           if (is.null(version)) 
[09:31:13.765]                             version <- utils::packageVersion("future")
[09:31:13.765]                         }
[09:31:13.765]                         else {
[09:31:13.765]                           version <- NULL
[09:31:13.765]                         }
[09:31:13.765]                         if (!has_future || version < "1.8.0") {
[09:31:13.765]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.765]                             "", base::R.version$version.string), 
[09:31:13.765]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.765]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.765]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.765]                               "release", "version")], collapse = " "), 
[09:31:13.765]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.765]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.765]                             info)
[09:31:13.765]                           info <- base::paste(info, collapse = "; ")
[09:31:13.765]                           if (!has_future) {
[09:31:13.765]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.765]                               info)
[09:31:13.765]                           }
[09:31:13.765]                           else {
[09:31:13.765]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.765]                               info, version)
[09:31:13.765]                           }
[09:31:13.765]                           base::stop(msg)
[09:31:13.765]                         }
[09:31:13.765]                       })
[09:31:13.765]                     }
[09:31:13.765]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.765]                     base::options(mc.cores = 1L)
[09:31:13.765]                   }
[09:31:13.765]                   ...future.strategy.old <- future::plan("list")
[09:31:13.765]                   options(future.plan = NULL)
[09:31:13.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.765]                 }
[09:31:13.765]                 ...future.workdir <- getwd()
[09:31:13.765]             }
[09:31:13.765]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.765]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.765]         }
[09:31:13.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.765]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.765]             base::names(...future.oldOptions))
[09:31:13.765]     }
[09:31:13.765]     if (FALSE) {
[09:31:13.765]     }
[09:31:13.765]     else {
[09:31:13.765]         if (TRUE) {
[09:31:13.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.765]                 open = "w")
[09:31:13.765]         }
[09:31:13.765]         else {
[09:31:13.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.765]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.765]         }
[09:31:13.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.765]             base::sink(type = "output", split = FALSE)
[09:31:13.765]             base::close(...future.stdout)
[09:31:13.765]         }, add = TRUE)
[09:31:13.765]     }
[09:31:13.765]     ...future.frame <- base::sys.nframe()
[09:31:13.765]     ...future.conditions <- base::list()
[09:31:13.765]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.765]     if (FALSE) {
[09:31:13.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.765]     }
[09:31:13.765]     ...future.result <- base::tryCatch({
[09:31:13.765]         base::withCallingHandlers({
[09:31:13.765]             ...future.value <- base::withVisible(base::local({
[09:31:13.765]                 withCallingHandlers({
[09:31:13.765]                   2
[09:31:13.765]                 }, immediateCondition = function(cond) {
[09:31:13.765]                   save_rds <- function (object, pathname, ...) 
[09:31:13.765]                   {
[09:31:13.765]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.765]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.765]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.765]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.765]                         fi_tmp[["mtime"]])
[09:31:13.765]                     }
[09:31:13.765]                     tryCatch({
[09:31:13.765]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.765]                     }, error = function(ex) {
[09:31:13.765]                       msg <- conditionMessage(ex)
[09:31:13.765]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.765]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.765]                         fi_tmp[["mtime"]], msg)
[09:31:13.765]                       ex$message <- msg
[09:31:13.765]                       stop(ex)
[09:31:13.765]                     })
[09:31:13.765]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.765]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.765]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.765]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.765]                       fi <- file.info(pathname)
[09:31:13.765]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.765]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.765]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.765]                         fi[["size"]], fi[["mtime"]])
[09:31:13.765]                       stop(msg)
[09:31:13.765]                     }
[09:31:13.765]                     invisible(pathname)
[09:31:13.765]                   }
[09:31:13.765]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.765]                     rootPath = tempdir()) 
[09:31:13.765]                   {
[09:31:13.765]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.765]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.765]                       tmpdir = path, fileext = ".rds")
[09:31:13.765]                     save_rds(obj, file)
[09:31:13.765]                   }
[09:31:13.765]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.765]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.765]                   {
[09:31:13.765]                     inherits <- base::inherits
[09:31:13.765]                     invokeRestart <- base::invokeRestart
[09:31:13.765]                     is.null <- base::is.null
[09:31:13.765]                     muffled <- FALSE
[09:31:13.765]                     if (inherits(cond, "message")) {
[09:31:13.765]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.765]                       if (muffled) 
[09:31:13.765]                         invokeRestart("muffleMessage")
[09:31:13.765]                     }
[09:31:13.765]                     else if (inherits(cond, "warning")) {
[09:31:13.765]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.765]                       if (muffled) 
[09:31:13.765]                         invokeRestart("muffleWarning")
[09:31:13.765]                     }
[09:31:13.765]                     else if (inherits(cond, "condition")) {
[09:31:13.765]                       if (!is.null(pattern)) {
[09:31:13.765]                         computeRestarts <- base::computeRestarts
[09:31:13.765]                         grepl <- base::grepl
[09:31:13.765]                         restarts <- computeRestarts(cond)
[09:31:13.765]                         for (restart in restarts) {
[09:31:13.765]                           name <- restart$name
[09:31:13.765]                           if (is.null(name)) 
[09:31:13.765]                             next
[09:31:13.765]                           if (!grepl(pattern, name)) 
[09:31:13.765]                             next
[09:31:13.765]                           invokeRestart(restart)
[09:31:13.765]                           muffled <- TRUE
[09:31:13.765]                           break
[09:31:13.765]                         }
[09:31:13.765]                       }
[09:31:13.765]                     }
[09:31:13.765]                     invisible(muffled)
[09:31:13.765]                   }
[09:31:13.765]                   muffleCondition(cond)
[09:31:13.765]                 })
[09:31:13.765]             }))
[09:31:13.765]             future::FutureResult(value = ...future.value$value, 
[09:31:13.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.765]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.765]                     ...future.globalenv.names))
[09:31:13.765]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.765]         }, condition = base::local({
[09:31:13.765]             c <- base::c
[09:31:13.765]             inherits <- base::inherits
[09:31:13.765]             invokeRestart <- base::invokeRestart
[09:31:13.765]             length <- base::length
[09:31:13.765]             list <- base::list
[09:31:13.765]             seq.int <- base::seq.int
[09:31:13.765]             signalCondition <- base::signalCondition
[09:31:13.765]             sys.calls <- base::sys.calls
[09:31:13.765]             `[[` <- base::`[[`
[09:31:13.765]             `+` <- base::`+`
[09:31:13.765]             `<<-` <- base::`<<-`
[09:31:13.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.765]                   3L)]
[09:31:13.765]             }
[09:31:13.765]             function(cond) {
[09:31:13.765]                 is_error <- inherits(cond, "error")
[09:31:13.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.765]                   NULL)
[09:31:13.765]                 if (is_error) {
[09:31:13.765]                   sessionInformation <- function() {
[09:31:13.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.765]                       search = base::search(), system = base::Sys.info())
[09:31:13.765]                   }
[09:31:13.765]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.765]                     cond$call), session = sessionInformation(), 
[09:31:13.765]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.765]                   signalCondition(cond)
[09:31:13.765]                 }
[09:31:13.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.765]                 "immediateCondition"))) {
[09:31:13.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.765]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.765]                   if (TRUE && !signal) {
[09:31:13.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.765]                     {
[09:31:13.765]                       inherits <- base::inherits
[09:31:13.765]                       invokeRestart <- base::invokeRestart
[09:31:13.765]                       is.null <- base::is.null
[09:31:13.765]                       muffled <- FALSE
[09:31:13.765]                       if (inherits(cond, "message")) {
[09:31:13.765]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.765]                         if (muffled) 
[09:31:13.765]                           invokeRestart("muffleMessage")
[09:31:13.765]                       }
[09:31:13.765]                       else if (inherits(cond, "warning")) {
[09:31:13.765]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.765]                         if (muffled) 
[09:31:13.765]                           invokeRestart("muffleWarning")
[09:31:13.765]                       }
[09:31:13.765]                       else if (inherits(cond, "condition")) {
[09:31:13.765]                         if (!is.null(pattern)) {
[09:31:13.765]                           computeRestarts <- base::computeRestarts
[09:31:13.765]                           grepl <- base::grepl
[09:31:13.765]                           restarts <- computeRestarts(cond)
[09:31:13.765]                           for (restart in restarts) {
[09:31:13.765]                             name <- restart$name
[09:31:13.765]                             if (is.null(name)) 
[09:31:13.765]                               next
[09:31:13.765]                             if (!grepl(pattern, name)) 
[09:31:13.765]                               next
[09:31:13.765]                             invokeRestart(restart)
[09:31:13.765]                             muffled <- TRUE
[09:31:13.765]                             break
[09:31:13.765]                           }
[09:31:13.765]                         }
[09:31:13.765]                       }
[09:31:13.765]                       invisible(muffled)
[09:31:13.765]                     }
[09:31:13.765]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.765]                   }
[09:31:13.765]                 }
[09:31:13.765]                 else {
[09:31:13.765]                   if (TRUE) {
[09:31:13.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.765]                     {
[09:31:13.765]                       inherits <- base::inherits
[09:31:13.765]                       invokeRestart <- base::invokeRestart
[09:31:13.765]                       is.null <- base::is.null
[09:31:13.765]                       muffled <- FALSE
[09:31:13.765]                       if (inherits(cond, "message")) {
[09:31:13.765]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.765]                         if (muffled) 
[09:31:13.765]                           invokeRestart("muffleMessage")
[09:31:13.765]                       }
[09:31:13.765]                       else if (inherits(cond, "warning")) {
[09:31:13.765]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.765]                         if (muffled) 
[09:31:13.765]                           invokeRestart("muffleWarning")
[09:31:13.765]                       }
[09:31:13.765]                       else if (inherits(cond, "condition")) {
[09:31:13.765]                         if (!is.null(pattern)) {
[09:31:13.765]                           computeRestarts <- base::computeRestarts
[09:31:13.765]                           grepl <- base::grepl
[09:31:13.765]                           restarts <- computeRestarts(cond)
[09:31:13.765]                           for (restart in restarts) {
[09:31:13.765]                             name <- restart$name
[09:31:13.765]                             if (is.null(name)) 
[09:31:13.765]                               next
[09:31:13.765]                             if (!grepl(pattern, name)) 
[09:31:13.765]                               next
[09:31:13.765]                             invokeRestart(restart)
[09:31:13.765]                             muffled <- TRUE
[09:31:13.765]                             break
[09:31:13.765]                           }
[09:31:13.765]                         }
[09:31:13.765]                       }
[09:31:13.765]                       invisible(muffled)
[09:31:13.765]                     }
[09:31:13.765]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.765]                   }
[09:31:13.765]                 }
[09:31:13.765]             }
[09:31:13.765]         }))
[09:31:13.765]     }, error = function(ex) {
[09:31:13.765]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.765]                 ...future.rng), started = ...future.startTime, 
[09:31:13.765]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.765]             version = "1.8"), class = "FutureResult")
[09:31:13.765]     }, finally = {
[09:31:13.765]         if (!identical(...future.workdir, getwd())) 
[09:31:13.765]             setwd(...future.workdir)
[09:31:13.765]         {
[09:31:13.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.765]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.765]             }
[09:31:13.765]             base::options(...future.oldOptions)
[09:31:13.765]             if (.Platform$OS.type == "windows") {
[09:31:13.765]                 old_names <- names(...future.oldEnvVars)
[09:31:13.765]                 envs <- base::Sys.getenv()
[09:31:13.765]                 names <- names(envs)
[09:31:13.765]                 common <- intersect(names, old_names)
[09:31:13.765]                 added <- setdiff(names, old_names)
[09:31:13.765]                 removed <- setdiff(old_names, names)
[09:31:13.765]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.765]                   envs[common]]
[09:31:13.765]                 NAMES <- toupper(changed)
[09:31:13.765]                 args <- list()
[09:31:13.765]                 for (kk in seq_along(NAMES)) {
[09:31:13.765]                   name <- changed[[kk]]
[09:31:13.765]                   NAME <- NAMES[[kk]]
[09:31:13.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.765]                     next
[09:31:13.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.765]                 }
[09:31:13.765]                 NAMES <- toupper(added)
[09:31:13.765]                 for (kk in seq_along(NAMES)) {
[09:31:13.765]                   name <- added[[kk]]
[09:31:13.765]                   NAME <- NAMES[[kk]]
[09:31:13.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.765]                     next
[09:31:13.765]                   args[[name]] <- ""
[09:31:13.765]                 }
[09:31:13.765]                 NAMES <- toupper(removed)
[09:31:13.765]                 for (kk in seq_along(NAMES)) {
[09:31:13.765]                   name <- removed[[kk]]
[09:31:13.765]                   NAME <- NAMES[[kk]]
[09:31:13.765]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.765]                     next
[09:31:13.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.765]                 }
[09:31:13.765]                 if (length(args) > 0) 
[09:31:13.765]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.765]             }
[09:31:13.765]             else {
[09:31:13.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.765]             }
[09:31:13.765]             {
[09:31:13.765]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.765]                   0L) {
[09:31:13.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.765]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.765]                   base::options(opts)
[09:31:13.765]                 }
[09:31:13.765]                 {
[09:31:13.765]                   {
[09:31:13.765]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.765]                     NULL
[09:31:13.765]                   }
[09:31:13.765]                   options(future.plan = NULL)
[09:31:13.765]                   if (is.na(NA_character_)) 
[09:31:13.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.765]                     .init = FALSE)
[09:31:13.765]                 }
[09:31:13.765]             }
[09:31:13.765]         }
[09:31:13.765]     })
[09:31:13.765]     if (TRUE) {
[09:31:13.765]         base::sink(type = "output", split = FALSE)
[09:31:13.765]         if (TRUE) {
[09:31:13.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.765]         }
[09:31:13.765]         else {
[09:31:13.765]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.765]         }
[09:31:13.765]         base::close(...future.stdout)
[09:31:13.765]         ...future.stdout <- NULL
[09:31:13.765]     }
[09:31:13.765]     ...future.result$conditions <- ...future.conditions
[09:31:13.765]     ...future.result$finished <- base::Sys.time()
[09:31:13.765]     ...future.result
[09:31:13.765] }
[09:31:13.768] requestCore(): workers = 2
[09:31:13.770] MulticoreFuture started
[09:31:13.770] - Launch lazy future ... done
[09:31:13.770] run() for ‘MulticoreFuture’ ... done
[09:31:13.771] getGlobalsAndPackages() ...
[09:31:13.771] Searching for globals...
[09:31:13.771] plan(): Setting new future strategy stack:
[09:31:13.772] 
[09:31:13.772] Searching for globals ... DONE
[09:31:13.771] List of future strategies:
[09:31:13.771] 1. sequential:
[09:31:13.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.771]    - tweaked: FALSE
[09:31:13.771]    - call: NULL
[09:31:13.772] - globals: [0] <none>
[09:31:13.772] getGlobalsAndPackages() ... DONE
[09:31:13.772] plan(): nbrOfWorkers() = 1
[09:31:13.773] run() for ‘Future’ ...
[09:31:13.773] - state: ‘created’
[09:31:13.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.774] plan(): Setting new future strategy stack:
[09:31:13.774] List of future strategies:
[09:31:13.774] 1. multicore:
[09:31:13.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.774]    - tweaked: FALSE
[09:31:13.774]    - call: plan(strategy)
[09:31:13.778] plan(): nbrOfWorkers() = 2
[09:31:13.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.784] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.784]   - Field: ‘label’
[09:31:13.784]   - Field: ‘local’
[09:31:13.784]   - Field: ‘owner’
[09:31:13.785]   - Field: ‘envir’
[09:31:13.785]   - Field: ‘workers’
[09:31:13.785]   - Field: ‘packages’
[09:31:13.785]   - Field: ‘gc’
[09:31:13.785]   - Field: ‘job’
[09:31:13.785]   - Field: ‘conditions’
[09:31:13.785]   - Field: ‘expr’
[09:31:13.786]   - Field: ‘uuid’
[09:31:13.786]   - Field: ‘seed’
[09:31:13.786]   - Field: ‘version’
[09:31:13.786]   - Field: ‘result’
[09:31:13.786]   - Field: ‘asynchronous’
[09:31:13.786]   - Field: ‘calls’
[09:31:13.786]   - Field: ‘globals’
[09:31:13.786]   - Field: ‘stdout’
[09:31:13.787]   - Field: ‘earlySignal’
[09:31:13.787]   - Field: ‘lazy’
[09:31:13.787]   - Field: ‘state’
[09:31:13.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.787] - Launch lazy future ...
[09:31:13.788] Packages needed by the future expression (n = 0): <none>
[09:31:13.788] Packages needed by future strategies (n = 0): <none>
[09:31:13.788] {
[09:31:13.788]     {
[09:31:13.788]         {
[09:31:13.788]             ...future.startTime <- base::Sys.time()
[09:31:13.788]             {
[09:31:13.788]                 {
[09:31:13.788]                   {
[09:31:13.788]                     {
[09:31:13.788]                       base::local({
[09:31:13.788]                         has_future <- base::requireNamespace("future", 
[09:31:13.788]                           quietly = TRUE)
[09:31:13.788]                         if (has_future) {
[09:31:13.788]                           ns <- base::getNamespace("future")
[09:31:13.788]                           version <- ns[[".package"]][["version"]]
[09:31:13.788]                           if (is.null(version)) 
[09:31:13.788]                             version <- utils::packageVersion("future")
[09:31:13.788]                         }
[09:31:13.788]                         else {
[09:31:13.788]                           version <- NULL
[09:31:13.788]                         }
[09:31:13.788]                         if (!has_future || version < "1.8.0") {
[09:31:13.788]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.788]                             "", base::R.version$version.string), 
[09:31:13.788]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.788]                               "release", "version")], collapse = " "), 
[09:31:13.788]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.788]                             info)
[09:31:13.788]                           info <- base::paste(info, collapse = "; ")
[09:31:13.788]                           if (!has_future) {
[09:31:13.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.788]                               info)
[09:31:13.788]                           }
[09:31:13.788]                           else {
[09:31:13.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.788]                               info, version)
[09:31:13.788]                           }
[09:31:13.788]                           base::stop(msg)
[09:31:13.788]                         }
[09:31:13.788]                       })
[09:31:13.788]                     }
[09:31:13.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.788]                     base::options(mc.cores = 1L)
[09:31:13.788]                   }
[09:31:13.788]                   ...future.strategy.old <- future::plan("list")
[09:31:13.788]                   options(future.plan = NULL)
[09:31:13.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.788]                 }
[09:31:13.788]                 ...future.workdir <- getwd()
[09:31:13.788]             }
[09:31:13.788]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.788]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.788]         }
[09:31:13.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.788]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.788]             base::names(...future.oldOptions))
[09:31:13.788]     }
[09:31:13.788]     if (FALSE) {
[09:31:13.788]     }
[09:31:13.788]     else {
[09:31:13.788]         if (TRUE) {
[09:31:13.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.788]                 open = "w")
[09:31:13.788]         }
[09:31:13.788]         else {
[09:31:13.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.788]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.788]         }
[09:31:13.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.788]             base::sink(type = "output", split = FALSE)
[09:31:13.788]             base::close(...future.stdout)
[09:31:13.788]         }, add = TRUE)
[09:31:13.788]     }
[09:31:13.788]     ...future.frame <- base::sys.nframe()
[09:31:13.788]     ...future.conditions <- base::list()
[09:31:13.788]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.788]     if (FALSE) {
[09:31:13.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.788]     }
[09:31:13.788]     ...future.result <- base::tryCatch({
[09:31:13.788]         base::withCallingHandlers({
[09:31:13.788]             ...future.value <- base::withVisible(base::local({
[09:31:13.788]                 withCallingHandlers({
[09:31:13.788]                   NULL
[09:31:13.788]                 }, immediateCondition = function(cond) {
[09:31:13.788]                   save_rds <- function (object, pathname, ...) 
[09:31:13.788]                   {
[09:31:13.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.788]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.788]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.788]                         fi_tmp[["mtime"]])
[09:31:13.788]                     }
[09:31:13.788]                     tryCatch({
[09:31:13.788]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.788]                     }, error = function(ex) {
[09:31:13.788]                       msg <- conditionMessage(ex)
[09:31:13.788]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.788]                         fi_tmp[["mtime"]], msg)
[09:31:13.788]                       ex$message <- msg
[09:31:13.788]                       stop(ex)
[09:31:13.788]                     })
[09:31:13.788]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.788]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.788]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.788]                       fi <- file.info(pathname)
[09:31:13.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.788]                         fi[["size"]], fi[["mtime"]])
[09:31:13.788]                       stop(msg)
[09:31:13.788]                     }
[09:31:13.788]                     invisible(pathname)
[09:31:13.788]                   }
[09:31:13.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.788]                     rootPath = tempdir()) 
[09:31:13.788]                   {
[09:31:13.788]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.788]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.788]                       tmpdir = path, fileext = ".rds")
[09:31:13.788]                     save_rds(obj, file)
[09:31:13.788]                   }
[09:31:13.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.788]                   {
[09:31:13.788]                     inherits <- base::inherits
[09:31:13.788]                     invokeRestart <- base::invokeRestart
[09:31:13.788]                     is.null <- base::is.null
[09:31:13.788]                     muffled <- FALSE
[09:31:13.788]                     if (inherits(cond, "message")) {
[09:31:13.788]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.788]                       if (muffled) 
[09:31:13.788]                         invokeRestart("muffleMessage")
[09:31:13.788]                     }
[09:31:13.788]                     else if (inherits(cond, "warning")) {
[09:31:13.788]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.788]                       if (muffled) 
[09:31:13.788]                         invokeRestart("muffleWarning")
[09:31:13.788]                     }
[09:31:13.788]                     else if (inherits(cond, "condition")) {
[09:31:13.788]                       if (!is.null(pattern)) {
[09:31:13.788]                         computeRestarts <- base::computeRestarts
[09:31:13.788]                         grepl <- base::grepl
[09:31:13.788]                         restarts <- computeRestarts(cond)
[09:31:13.788]                         for (restart in restarts) {
[09:31:13.788]                           name <- restart$name
[09:31:13.788]                           if (is.null(name)) 
[09:31:13.788]                             next
[09:31:13.788]                           if (!grepl(pattern, name)) 
[09:31:13.788]                             next
[09:31:13.788]                           invokeRestart(restart)
[09:31:13.788]                           muffled <- TRUE
[09:31:13.788]                           break
[09:31:13.788]                         }
[09:31:13.788]                       }
[09:31:13.788]                     }
[09:31:13.788]                     invisible(muffled)
[09:31:13.788]                   }
[09:31:13.788]                   muffleCondition(cond)
[09:31:13.788]                 })
[09:31:13.788]             }))
[09:31:13.788]             future::FutureResult(value = ...future.value$value, 
[09:31:13.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.788]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.788]                     ...future.globalenv.names))
[09:31:13.788]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.788]         }, condition = base::local({
[09:31:13.788]             c <- base::c
[09:31:13.788]             inherits <- base::inherits
[09:31:13.788]             invokeRestart <- base::invokeRestart
[09:31:13.788]             length <- base::length
[09:31:13.788]             list <- base::list
[09:31:13.788]             seq.int <- base::seq.int
[09:31:13.788]             signalCondition <- base::signalCondition
[09:31:13.788]             sys.calls <- base::sys.calls
[09:31:13.788]             `[[` <- base::`[[`
[09:31:13.788]             `+` <- base::`+`
[09:31:13.788]             `<<-` <- base::`<<-`
[09:31:13.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.788]                   3L)]
[09:31:13.788]             }
[09:31:13.788]             function(cond) {
[09:31:13.788]                 is_error <- inherits(cond, "error")
[09:31:13.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.788]                   NULL)
[09:31:13.788]                 if (is_error) {
[09:31:13.788]                   sessionInformation <- function() {
[09:31:13.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.788]                       search = base::search(), system = base::Sys.info())
[09:31:13.788]                   }
[09:31:13.788]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.788]                     cond$call), session = sessionInformation(), 
[09:31:13.788]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.788]                   signalCondition(cond)
[09:31:13.788]                 }
[09:31:13.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.788]                 "immediateCondition"))) {
[09:31:13.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.788]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.788]                   if (TRUE && !signal) {
[09:31:13.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.788]                     {
[09:31:13.788]                       inherits <- base::inherits
[09:31:13.788]                       invokeRestart <- base::invokeRestart
[09:31:13.788]                       is.null <- base::is.null
[09:31:13.788]                       muffled <- FALSE
[09:31:13.788]                       if (inherits(cond, "message")) {
[09:31:13.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.788]                         if (muffled) 
[09:31:13.788]                           invokeRestart("muffleMessage")
[09:31:13.788]                       }
[09:31:13.788]                       else if (inherits(cond, "warning")) {
[09:31:13.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.788]                         if (muffled) 
[09:31:13.788]                           invokeRestart("muffleWarning")
[09:31:13.788]                       }
[09:31:13.788]                       else if (inherits(cond, "condition")) {
[09:31:13.788]                         if (!is.null(pattern)) {
[09:31:13.788]                           computeRestarts <- base::computeRestarts
[09:31:13.788]                           grepl <- base::grepl
[09:31:13.788]                           restarts <- computeRestarts(cond)
[09:31:13.788]                           for (restart in restarts) {
[09:31:13.788]                             name <- restart$name
[09:31:13.788]                             if (is.null(name)) 
[09:31:13.788]                               next
[09:31:13.788]                             if (!grepl(pattern, name)) 
[09:31:13.788]                               next
[09:31:13.788]                             invokeRestart(restart)
[09:31:13.788]                             muffled <- TRUE
[09:31:13.788]                             break
[09:31:13.788]                           }
[09:31:13.788]                         }
[09:31:13.788]                       }
[09:31:13.788]                       invisible(muffled)
[09:31:13.788]                     }
[09:31:13.788]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.788]                   }
[09:31:13.788]                 }
[09:31:13.788]                 else {
[09:31:13.788]                   if (TRUE) {
[09:31:13.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.788]                     {
[09:31:13.788]                       inherits <- base::inherits
[09:31:13.788]                       invokeRestart <- base::invokeRestart
[09:31:13.788]                       is.null <- base::is.null
[09:31:13.788]                       muffled <- FALSE
[09:31:13.788]                       if (inherits(cond, "message")) {
[09:31:13.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.788]                         if (muffled) 
[09:31:13.788]                           invokeRestart("muffleMessage")
[09:31:13.788]                       }
[09:31:13.788]                       else if (inherits(cond, "warning")) {
[09:31:13.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.788]                         if (muffled) 
[09:31:13.788]                           invokeRestart("muffleWarning")
[09:31:13.788]                       }
[09:31:13.788]                       else if (inherits(cond, "condition")) {
[09:31:13.788]                         if (!is.null(pattern)) {
[09:31:13.788]                           computeRestarts <- base::computeRestarts
[09:31:13.788]                           grepl <- base::grepl
[09:31:13.788]                           restarts <- computeRestarts(cond)
[09:31:13.788]                           for (restart in restarts) {
[09:31:13.788]                             name <- restart$name
[09:31:13.788]                             if (is.null(name)) 
[09:31:13.788]                               next
[09:31:13.788]                             if (!grepl(pattern, name)) 
[09:31:13.788]                               next
[09:31:13.788]                             invokeRestart(restart)
[09:31:13.788]                             muffled <- TRUE
[09:31:13.788]                             break
[09:31:13.788]                           }
[09:31:13.788]                         }
[09:31:13.788]                       }
[09:31:13.788]                       invisible(muffled)
[09:31:13.788]                     }
[09:31:13.788]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.788]                   }
[09:31:13.788]                 }
[09:31:13.788]             }
[09:31:13.788]         }))
[09:31:13.788]     }, error = function(ex) {
[09:31:13.788]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.788]                 ...future.rng), started = ...future.startTime, 
[09:31:13.788]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.788]             version = "1.8"), class = "FutureResult")
[09:31:13.788]     }, finally = {
[09:31:13.788]         if (!identical(...future.workdir, getwd())) 
[09:31:13.788]             setwd(...future.workdir)
[09:31:13.788]         {
[09:31:13.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.788]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.788]             }
[09:31:13.788]             base::options(...future.oldOptions)
[09:31:13.788]             if (.Platform$OS.type == "windows") {
[09:31:13.788]                 old_names <- names(...future.oldEnvVars)
[09:31:13.788]                 envs <- base::Sys.getenv()
[09:31:13.788]                 names <- names(envs)
[09:31:13.788]                 common <- intersect(names, old_names)
[09:31:13.788]                 added <- setdiff(names, old_names)
[09:31:13.788]                 removed <- setdiff(old_names, names)
[09:31:13.788]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.788]                   envs[common]]
[09:31:13.788]                 NAMES <- toupper(changed)
[09:31:13.788]                 args <- list()
[09:31:13.788]                 for (kk in seq_along(NAMES)) {
[09:31:13.788]                   name <- changed[[kk]]
[09:31:13.788]                   NAME <- NAMES[[kk]]
[09:31:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.788]                     next
[09:31:13.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.788]                 }
[09:31:13.788]                 NAMES <- toupper(added)
[09:31:13.788]                 for (kk in seq_along(NAMES)) {
[09:31:13.788]                   name <- added[[kk]]
[09:31:13.788]                   NAME <- NAMES[[kk]]
[09:31:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.788]                     next
[09:31:13.788]                   args[[name]] <- ""
[09:31:13.788]                 }
[09:31:13.788]                 NAMES <- toupper(removed)
[09:31:13.788]                 for (kk in seq_along(NAMES)) {
[09:31:13.788]                   name <- removed[[kk]]
[09:31:13.788]                   NAME <- NAMES[[kk]]
[09:31:13.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.788]                     next
[09:31:13.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.788]                 }
[09:31:13.788]                 if (length(args) > 0) 
[09:31:13.788]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.788]             }
[09:31:13.788]             else {
[09:31:13.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.788]             }
[09:31:13.788]             {
[09:31:13.788]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.788]                   0L) {
[09:31:13.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.788]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.788]                   base::options(opts)
[09:31:13.788]                 }
[09:31:13.788]                 {
[09:31:13.788]                   {
[09:31:13.788]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.788]                     NULL
[09:31:13.788]                   }
[09:31:13.788]                   options(future.plan = NULL)
[09:31:13.788]                   if (is.na(NA_character_)) 
[09:31:13.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.788]                     .init = FALSE)
[09:31:13.788]                 }
[09:31:13.788]             }
[09:31:13.788]         }
[09:31:13.788]     })
[09:31:13.788]     if (TRUE) {
[09:31:13.788]         base::sink(type = "output", split = FALSE)
[09:31:13.788]         if (TRUE) {
[09:31:13.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.788]         }
[09:31:13.788]         else {
[09:31:13.788]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.788]         }
[09:31:13.788]         base::close(...future.stdout)
[09:31:13.788]         ...future.stdout <- NULL
[09:31:13.788]     }
[09:31:13.788]     ...future.result$conditions <- ...future.conditions
[09:31:13.788]     ...future.result$finished <- base::Sys.time()
[09:31:13.788]     ...future.result
[09:31:13.788] }
[09:31:13.791] requestCore(): workers = 2
[09:31:13.793] MulticoreFuture started
[09:31:13.794] - Launch lazy future ... done
[09:31:13.794] run() for ‘MulticoreFuture’ ... done
[09:31:13.794] plan(): Setting new future strategy stack:
[09:31:13.795] getGlobalsAndPackages() ...
[09:31:13.795] Searching for globals...
[09:31:13.795] List of future strategies:
[09:31:13.795] 1. sequential:
[09:31:13.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.795]    - tweaked: FALSE
[09:31:13.795]    - call: NULL
[09:31:13.796] plan(): nbrOfWorkers() = 1
[09:31:13.796] - globals found: [1] ‘{’
[09:31:13.797] Searching for globals ... DONE
[09:31:13.797] Resolving globals: FALSE
[09:31:13.797] 
[09:31:13.797] 
[09:31:13.798] getGlobalsAndPackages() ... DONE
[09:31:13.798] plan(): Setting new future strategy stack:
[09:31:13.798] run() for ‘Future’ ...
[09:31:13.798] - state: ‘created’
[09:31:13.798] List of future strategies:
[09:31:13.798] 1. multicore:
[09:31:13.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.798]    - tweaked: FALSE
[09:31:13.798]    - call: plan(strategy)
[09:31:13.798] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.803] plan(): nbrOfWorkers() = 2
[09:31:13.803] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.803]   - Field: ‘label’
[09:31:13.804]   - Field: ‘local’
[09:31:13.804]   - Field: ‘owner’
[09:31:13.804]   - Field: ‘envir’
[09:31:13.804]   - Field: ‘workers’
[09:31:13.804]   - Field: ‘packages’
[09:31:13.804]   - Field: ‘gc’
[09:31:13.804]   - Field: ‘job’
[09:31:13.805]   - Field: ‘conditions’
[09:31:13.805]   - Field: ‘expr’
[09:31:13.805]   - Field: ‘uuid’
[09:31:13.805]   - Field: ‘seed’
[09:31:13.805]   - Field: ‘version’
[09:31:13.805]   - Field: ‘result’
[09:31:13.805]   - Field: ‘asynchronous’
[09:31:13.806]   - Field: ‘calls’
[09:31:13.806]   - Field: ‘globals’
[09:31:13.806]   - Field: ‘stdout’
[09:31:13.806]   - Field: ‘earlySignal’
[09:31:13.806]   - Field: ‘lazy’
[09:31:13.806]   - Field: ‘state’
[09:31:13.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.806] - Launch lazy future ...
[09:31:13.807] Packages needed by the future expression (n = 0): <none>
[09:31:13.807] Packages needed by future strategies (n = 0): <none>
[09:31:13.808] {
[09:31:13.808]     {
[09:31:13.808]         {
[09:31:13.808]             ...future.startTime <- base::Sys.time()
[09:31:13.808]             {
[09:31:13.808]                 {
[09:31:13.808]                   {
[09:31:13.808]                     {
[09:31:13.808]                       base::local({
[09:31:13.808]                         has_future <- base::requireNamespace("future", 
[09:31:13.808]                           quietly = TRUE)
[09:31:13.808]                         if (has_future) {
[09:31:13.808]                           ns <- base::getNamespace("future")
[09:31:13.808]                           version <- ns[[".package"]][["version"]]
[09:31:13.808]                           if (is.null(version)) 
[09:31:13.808]                             version <- utils::packageVersion("future")
[09:31:13.808]                         }
[09:31:13.808]                         else {
[09:31:13.808]                           version <- NULL
[09:31:13.808]                         }
[09:31:13.808]                         if (!has_future || version < "1.8.0") {
[09:31:13.808]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.808]                             "", base::R.version$version.string), 
[09:31:13.808]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.808]                               "release", "version")], collapse = " "), 
[09:31:13.808]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.808]                             info)
[09:31:13.808]                           info <- base::paste(info, collapse = "; ")
[09:31:13.808]                           if (!has_future) {
[09:31:13.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.808]                               info)
[09:31:13.808]                           }
[09:31:13.808]                           else {
[09:31:13.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.808]                               info, version)
[09:31:13.808]                           }
[09:31:13.808]                           base::stop(msg)
[09:31:13.808]                         }
[09:31:13.808]                       })
[09:31:13.808]                     }
[09:31:13.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.808]                     base::options(mc.cores = 1L)
[09:31:13.808]                   }
[09:31:13.808]                   ...future.strategy.old <- future::plan("list")
[09:31:13.808]                   options(future.plan = NULL)
[09:31:13.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.808]                 }
[09:31:13.808]                 ...future.workdir <- getwd()
[09:31:13.808]             }
[09:31:13.808]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.808]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.808]         }
[09:31:13.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.808]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.808]             base::names(...future.oldOptions))
[09:31:13.808]     }
[09:31:13.808]     if (FALSE) {
[09:31:13.808]     }
[09:31:13.808]     else {
[09:31:13.808]         if (TRUE) {
[09:31:13.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.808]                 open = "w")
[09:31:13.808]         }
[09:31:13.808]         else {
[09:31:13.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.808]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.808]         }
[09:31:13.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.808]             base::sink(type = "output", split = FALSE)
[09:31:13.808]             base::close(...future.stdout)
[09:31:13.808]         }, add = TRUE)
[09:31:13.808]     }
[09:31:13.808]     ...future.frame <- base::sys.nframe()
[09:31:13.808]     ...future.conditions <- base::list()
[09:31:13.808]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.808]     if (FALSE) {
[09:31:13.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.808]     }
[09:31:13.808]     ...future.result <- base::tryCatch({
[09:31:13.808]         base::withCallingHandlers({
[09:31:13.808]             ...future.value <- base::withVisible(base::local({
[09:31:13.808]                 withCallingHandlers({
[09:31:13.808]                   {
[09:31:13.808]                     4
[09:31:13.808]                   }
[09:31:13.808]                 }, immediateCondition = function(cond) {
[09:31:13.808]                   save_rds <- function (object, pathname, ...) 
[09:31:13.808]                   {
[09:31:13.808]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.808]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.808]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.808]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.808]                         fi_tmp[["mtime"]])
[09:31:13.808]                     }
[09:31:13.808]                     tryCatch({
[09:31:13.808]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.808]                     }, error = function(ex) {
[09:31:13.808]                       msg <- conditionMessage(ex)
[09:31:13.808]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.808]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.808]                         fi_tmp[["mtime"]], msg)
[09:31:13.808]                       ex$message <- msg
[09:31:13.808]                       stop(ex)
[09:31:13.808]                     })
[09:31:13.808]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.808]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.808]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.808]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.808]                       fi <- file.info(pathname)
[09:31:13.808]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.808]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.808]                         fi[["size"]], fi[["mtime"]])
[09:31:13.808]                       stop(msg)
[09:31:13.808]                     }
[09:31:13.808]                     invisible(pathname)
[09:31:13.808]                   }
[09:31:13.808]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.808]                     rootPath = tempdir()) 
[09:31:13.808]                   {
[09:31:13.808]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.808]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.808]                       tmpdir = path, fileext = ".rds")
[09:31:13.808]                     save_rds(obj, file)
[09:31:13.808]                   }
[09:31:13.808]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.808]                   {
[09:31:13.808]                     inherits <- base::inherits
[09:31:13.808]                     invokeRestart <- base::invokeRestart
[09:31:13.808]                     is.null <- base::is.null
[09:31:13.808]                     muffled <- FALSE
[09:31:13.808]                     if (inherits(cond, "message")) {
[09:31:13.808]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.808]                       if (muffled) 
[09:31:13.808]                         invokeRestart("muffleMessage")
[09:31:13.808]                     }
[09:31:13.808]                     else if (inherits(cond, "warning")) {
[09:31:13.808]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.808]                       if (muffled) 
[09:31:13.808]                         invokeRestart("muffleWarning")
[09:31:13.808]                     }
[09:31:13.808]                     else if (inherits(cond, "condition")) {
[09:31:13.808]                       if (!is.null(pattern)) {
[09:31:13.808]                         computeRestarts <- base::computeRestarts
[09:31:13.808]                         grepl <- base::grepl
[09:31:13.808]                         restarts <- computeRestarts(cond)
[09:31:13.808]                         for (restart in restarts) {
[09:31:13.808]                           name <- restart$name
[09:31:13.808]                           if (is.null(name)) 
[09:31:13.808]                             next
[09:31:13.808]                           if (!grepl(pattern, name)) 
[09:31:13.808]                             next
[09:31:13.808]                           invokeRestart(restart)
[09:31:13.808]                           muffled <- TRUE
[09:31:13.808]                           break
[09:31:13.808]                         }
[09:31:13.808]                       }
[09:31:13.808]                     }
[09:31:13.808]                     invisible(muffled)
[09:31:13.808]                   }
[09:31:13.808]                   muffleCondition(cond)
[09:31:13.808]                 })
[09:31:13.808]             }))
[09:31:13.808]             future::FutureResult(value = ...future.value$value, 
[09:31:13.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.808]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.808]                     ...future.globalenv.names))
[09:31:13.808]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.808]         }, condition = base::local({
[09:31:13.808]             c <- base::c
[09:31:13.808]             inherits <- base::inherits
[09:31:13.808]             invokeRestart <- base::invokeRestart
[09:31:13.808]             length <- base::length
[09:31:13.808]             list <- base::list
[09:31:13.808]             seq.int <- base::seq.int
[09:31:13.808]             signalCondition <- base::signalCondition
[09:31:13.808]             sys.calls <- base::sys.calls
[09:31:13.808]             `[[` <- base::`[[`
[09:31:13.808]             `+` <- base::`+`
[09:31:13.808]             `<<-` <- base::`<<-`
[09:31:13.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.808]                   3L)]
[09:31:13.808]             }
[09:31:13.808]             function(cond) {
[09:31:13.808]                 is_error <- inherits(cond, "error")
[09:31:13.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.808]                   NULL)
[09:31:13.808]                 if (is_error) {
[09:31:13.808]                   sessionInformation <- function() {
[09:31:13.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.808]                       search = base::search(), system = base::Sys.info())
[09:31:13.808]                   }
[09:31:13.808]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.808]                     cond$call), session = sessionInformation(), 
[09:31:13.808]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.808]                   signalCondition(cond)
[09:31:13.808]                 }
[09:31:13.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.808]                 "immediateCondition"))) {
[09:31:13.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.808]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.808]                   if (TRUE && !signal) {
[09:31:13.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.808]                     {
[09:31:13.808]                       inherits <- base::inherits
[09:31:13.808]                       invokeRestart <- base::invokeRestart
[09:31:13.808]                       is.null <- base::is.null
[09:31:13.808]                       muffled <- FALSE
[09:31:13.808]                       if (inherits(cond, "message")) {
[09:31:13.808]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.808]                         if (muffled) 
[09:31:13.808]                           invokeRestart("muffleMessage")
[09:31:13.808]                       }
[09:31:13.808]                       else if (inherits(cond, "warning")) {
[09:31:13.808]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.808]                         if (muffled) 
[09:31:13.808]                           invokeRestart("muffleWarning")
[09:31:13.808]                       }
[09:31:13.808]                       else if (inherits(cond, "condition")) {
[09:31:13.808]                         if (!is.null(pattern)) {
[09:31:13.808]                           computeRestarts <- base::computeRestarts
[09:31:13.808]                           grepl <- base::grepl
[09:31:13.808]                           restarts <- computeRestarts(cond)
[09:31:13.808]                           for (restart in restarts) {
[09:31:13.808]                             name <- restart$name
[09:31:13.808]                             if (is.null(name)) 
[09:31:13.808]                               next
[09:31:13.808]                             if (!grepl(pattern, name)) 
[09:31:13.808]                               next
[09:31:13.808]                             invokeRestart(restart)
[09:31:13.808]                             muffled <- TRUE
[09:31:13.808]                             break
[09:31:13.808]                           }
[09:31:13.808]                         }
[09:31:13.808]                       }
[09:31:13.808]                       invisible(muffled)
[09:31:13.808]                     }
[09:31:13.808]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.808]                   }
[09:31:13.808]                 }
[09:31:13.808]                 else {
[09:31:13.808]                   if (TRUE) {
[09:31:13.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.808]                     {
[09:31:13.808]                       inherits <- base::inherits
[09:31:13.808]                       invokeRestart <- base::invokeRestart
[09:31:13.808]                       is.null <- base::is.null
[09:31:13.808]                       muffled <- FALSE
[09:31:13.808]                       if (inherits(cond, "message")) {
[09:31:13.808]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.808]                         if (muffled) 
[09:31:13.808]                           invokeRestart("muffleMessage")
[09:31:13.808]                       }
[09:31:13.808]                       else if (inherits(cond, "warning")) {
[09:31:13.808]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.808]                         if (muffled) 
[09:31:13.808]                           invokeRestart("muffleWarning")
[09:31:13.808]                       }
[09:31:13.808]                       else if (inherits(cond, "condition")) {
[09:31:13.808]                         if (!is.null(pattern)) {
[09:31:13.808]                           computeRestarts <- base::computeRestarts
[09:31:13.808]                           grepl <- base::grepl
[09:31:13.808]                           restarts <- computeRestarts(cond)
[09:31:13.808]                           for (restart in restarts) {
[09:31:13.808]                             name <- restart$name
[09:31:13.808]                             if (is.null(name)) 
[09:31:13.808]                               next
[09:31:13.808]                             if (!grepl(pattern, name)) 
[09:31:13.808]                               next
[09:31:13.808]                             invokeRestart(restart)
[09:31:13.808]                             muffled <- TRUE
[09:31:13.808]                             break
[09:31:13.808]                           }
[09:31:13.808]                         }
[09:31:13.808]                       }
[09:31:13.808]                       invisible(muffled)
[09:31:13.808]                     }
[09:31:13.808]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.808]                   }
[09:31:13.808]                 }
[09:31:13.808]             }
[09:31:13.808]         }))
[09:31:13.808]     }, error = function(ex) {
[09:31:13.808]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.808]                 ...future.rng), started = ...future.startTime, 
[09:31:13.808]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.808]             version = "1.8"), class = "FutureResult")
[09:31:13.808]     }, finally = {
[09:31:13.808]         if (!identical(...future.workdir, getwd())) 
[09:31:13.808]             setwd(...future.workdir)
[09:31:13.808]         {
[09:31:13.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.808]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.808]             }
[09:31:13.808]             base::options(...future.oldOptions)
[09:31:13.808]             if (.Platform$OS.type == "windows") {
[09:31:13.808]                 old_names <- names(...future.oldEnvVars)
[09:31:13.808]                 envs <- base::Sys.getenv()
[09:31:13.808]                 names <- names(envs)
[09:31:13.808]                 common <- intersect(names, old_names)
[09:31:13.808]                 added <- setdiff(names, old_names)
[09:31:13.808]                 removed <- setdiff(old_names, names)
[09:31:13.808]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.808]                   envs[common]]
[09:31:13.808]                 NAMES <- toupper(changed)
[09:31:13.808]                 args <- list()
[09:31:13.808]                 for (kk in seq_along(NAMES)) {
[09:31:13.808]                   name <- changed[[kk]]
[09:31:13.808]                   NAME <- NAMES[[kk]]
[09:31:13.808]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.808]                     next
[09:31:13.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.808]                 }
[09:31:13.808]                 NAMES <- toupper(added)
[09:31:13.808]                 for (kk in seq_along(NAMES)) {
[09:31:13.808]                   name <- added[[kk]]
[09:31:13.808]                   NAME <- NAMES[[kk]]
[09:31:13.808]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.808]                     next
[09:31:13.808]                   args[[name]] <- ""
[09:31:13.808]                 }
[09:31:13.808]                 NAMES <- toupper(removed)
[09:31:13.808]                 for (kk in seq_along(NAMES)) {
[09:31:13.808]                   name <- removed[[kk]]
[09:31:13.808]                   NAME <- NAMES[[kk]]
[09:31:13.808]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.808]                     next
[09:31:13.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.808]                 }
[09:31:13.808]                 if (length(args) > 0) 
[09:31:13.808]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.808]             }
[09:31:13.808]             else {
[09:31:13.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.808]             }
[09:31:13.808]             {
[09:31:13.808]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.808]                   0L) {
[09:31:13.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.808]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.808]                   base::options(opts)
[09:31:13.808]                 }
[09:31:13.808]                 {
[09:31:13.808]                   {
[09:31:13.808]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.808]                     NULL
[09:31:13.808]                   }
[09:31:13.808]                   options(future.plan = NULL)
[09:31:13.808]                   if (is.na(NA_character_)) 
[09:31:13.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.808]                     .init = FALSE)
[09:31:13.808]                 }
[09:31:13.808]             }
[09:31:13.808]         }
[09:31:13.808]     })
[09:31:13.808]     if (TRUE) {
[09:31:13.808]         base::sink(type = "output", split = FALSE)
[09:31:13.808]         if (TRUE) {
[09:31:13.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.808]         }
[09:31:13.808]         else {
[09:31:13.808]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.808]         }
[09:31:13.808]         base::close(...future.stdout)
[09:31:13.808]         ...future.stdout <- NULL
[09:31:13.808]     }
[09:31:13.808]     ...future.result$conditions <- ...future.conditions
[09:31:13.808]     ...future.result$finished <- base::Sys.time()
[09:31:13.808]     ...future.result
[09:31:13.808] }
[09:31:13.811] requestCore(): workers = 2
[09:31:13.812] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:13.822] result() for MulticoreFuture ...
[09:31:13.823] result() for MulticoreFuture ...
[09:31:13.823] result() for MulticoreFuture ... done
[09:31:13.824] result() for MulticoreFuture ... done
[09:31:13.824] result() for MulticoreFuture ...
[09:31:13.824] result() for MulticoreFuture ... done
[09:31:13.826] MulticoreFuture started
[09:31:13.827] - Launch lazy future ... done
[09:31:13.827] run() for ‘MulticoreFuture’ ... done
[09:31:13.828] plan(): Setting new future strategy stack:
<environment: 0x55a3ccbe72b0> 
[09:31:13.828] List of future strategies:
[09:31:13.828] 1. sequential:
[09:31:13.828]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.828]    - tweaked: FALSE
[09:31:13.828]    - call: NULL
[09:31:13.829] plan(): nbrOfWorkers() = 1
<environment: 0x55a3caafd228> 
[09:31:13.832] plan(): Setting new future strategy stack:
[09:31:13.832] List of future strategies:
[09:31:13.832] 1. multicore:
[09:31:13.832]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.832]    - tweaked: FALSE
[09:31:13.832]    - call: plan(strategy)
[09:31:13.837] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:13.839] resolve() on environment ...
[09:31:13.840]  recursive: 0
[09:31:13.840]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:13.841] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.841] - nx: 4
[09:31:13.841] - relay: TRUE
[09:31:13.841] - stdout: TRUE
[09:31:13.841] - signal: TRUE
[09:31:13.841] - resignal: FALSE
[09:31:13.841] - force: TRUE
[09:31:13.842] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.842] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.842]  - until=2
[09:31:13.842]  - relaying element #2
[09:31:13.842] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.842] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.842] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.843]  length: 3 (resolved future 1)
[09:31:13.843] Future #2
[09:31:13.843] result() for MulticoreFuture ...
[09:31:13.843] result() for MulticoreFuture ... done
[09:31:13.843] result() for MulticoreFuture ...
[09:31:13.843] result() for MulticoreFuture ... done
[09:31:13.843] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:13.844] - nx: 4
[09:31:13.844] - relay: TRUE
[09:31:13.844] - stdout: TRUE
[09:31:13.844] - signal: TRUE
[09:31:13.844] - resignal: FALSE
[09:31:13.844] - force: TRUE
[09:31:13.844] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.845] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.845]  - until=2
[09:31:13.845]  - relaying element #2
[09:31:13.845] result() for MulticoreFuture ...
[09:31:13.845] result() for MulticoreFuture ... done
[09:31:13.845] result() for MulticoreFuture ...
[09:31:13.845] result() for MulticoreFuture ... done
[09:31:13.846] result() for MulticoreFuture ...
[09:31:13.846] result() for MulticoreFuture ... done
[09:31:13.846] result() for MulticoreFuture ...
[09:31:13.846] result() for MulticoreFuture ... done
[09:31:13.846] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.846] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.846] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:13.847]  length: 2 (resolved future 2)
[09:31:13.847] Future #3
[09:31:13.847] result() for MulticoreFuture ...
[09:31:13.848] result() for MulticoreFuture ...
[09:31:13.848] result() for MulticoreFuture ... done
[09:31:13.848] result() for MulticoreFuture ... done
[09:31:13.848] result() for MulticoreFuture ...
[09:31:13.849] result() for MulticoreFuture ... done
[09:31:13.849] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:13.849] - nx: 4
[09:31:13.849] - relay: TRUE
[09:31:13.849] - stdout: TRUE
[09:31:13.849] - signal: TRUE
[09:31:13.850] - resignal: FALSE
[09:31:13.850] - force: TRUE
[09:31:13.850] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.850] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.850]  - until=3
[09:31:13.850]  - relaying element #3
[09:31:13.851] result() for MulticoreFuture ...
[09:31:13.851] result() for MulticoreFuture ... done
[09:31:13.851] result() for MulticoreFuture ...
[09:31:13.851] result() for MulticoreFuture ... done
[09:31:13.851] result() for MulticoreFuture ...
[09:31:13.852] result() for MulticoreFuture ... done
[09:31:13.852] result() for MulticoreFuture ...
[09:31:13.852] result() for MulticoreFuture ... done
[09:31:13.852] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.852] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.852] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:13.853]  length: 1 (resolved future 3)
[09:31:13.853] Future #4
[09:31:13.853] result() for MulticoreFuture ...
[09:31:13.854] result() for MulticoreFuture ...
[09:31:13.854] result() for MulticoreFuture ... done
[09:31:13.854] result() for MulticoreFuture ... done
[09:31:13.855] result() for MulticoreFuture ...
[09:31:13.855] result() for MulticoreFuture ... done
[09:31:13.855] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:13.855] - nx: 4
[09:31:13.855] - relay: TRUE
[09:31:13.855] - stdout: TRUE
[09:31:13.856] - signal: TRUE
[09:31:13.856] - resignal: FALSE
[09:31:13.856] - force: TRUE
[09:31:13.856] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.856] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.857]  - until=4
[09:31:13.857]  - relaying element #4
[09:31:13.857] result() for MulticoreFuture ...
[09:31:13.857] result() for MulticoreFuture ... done
[09:31:13.857] result() for MulticoreFuture ...
[09:31:13.857] result() for MulticoreFuture ... done
[09:31:13.857] result() for MulticoreFuture ...
[09:31:13.858] result() for MulticoreFuture ... done
[09:31:13.858] result() for MulticoreFuture ...
[09:31:13.858] result() for MulticoreFuture ... done
[09:31:13.858] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.858] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.858] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:13.858]  length: 0 (resolved future 4)
[09:31:13.858] Relaying remaining futures
[09:31:13.858] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.859] - nx: 4
[09:31:13.859] - relay: TRUE
[09:31:13.859] - stdout: TRUE
[09:31:13.859] - signal: TRUE
[09:31:13.859] - resignal: FALSE
[09:31:13.859] - force: TRUE
[09:31:13.859] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.859] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:13.859] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.860] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.860] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.860] resolve() on environment ... DONE
[09:31:13.860] result() for MulticoreFuture ...
[09:31:13.860] result() for MulticoreFuture ... done
[09:31:13.860] result() for MulticoreFuture ...
[09:31:13.860] result() for MulticoreFuture ... done
[09:31:13.860] result() for MulticoreFuture ...
[09:31:13.861] result() for MulticoreFuture ... done
[09:31:13.861] result() for MulticoreFuture ...
[09:31:13.861] result() for MulticoreFuture ... done
[09:31:13.861] result() for MulticoreFuture ...
[09:31:13.861] result() for MulticoreFuture ... done
[09:31:13.861] result() for MulticoreFuture ...
[09:31:13.861] result() for MulticoreFuture ... done
<environment: 0x55a3ca849098> 
Dimensions: c(2, 3, 1)
[09:31:13.862] getGlobalsAndPackages() ...
[09:31:13.862] Searching for globals...
[09:31:13.862] 
[09:31:13.862] Searching for globals ... DONE
[09:31:13.862] - globals: [0] <none>
[09:31:13.863] getGlobalsAndPackages() ... DONE
[09:31:13.863] run() for ‘Future’ ...
[09:31:13.863] - state: ‘created’
[09:31:13.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.868]   - Field: ‘label’
[09:31:13.868]   - Field: ‘local’
[09:31:13.868]   - Field: ‘owner’
[09:31:13.868]   - Field: ‘envir’
[09:31:13.868]   - Field: ‘workers’
[09:31:13.868]   - Field: ‘packages’
[09:31:13.869]   - Field: ‘gc’
[09:31:13.869]   - Field: ‘job’
[09:31:13.869]   - Field: ‘conditions’
[09:31:13.869]   - Field: ‘expr’
[09:31:13.869]   - Field: ‘uuid’
[09:31:13.869]   - Field: ‘seed’
[09:31:13.869]   - Field: ‘version’
[09:31:13.869]   - Field: ‘result’
[09:31:13.870]   - Field: ‘asynchronous’
[09:31:13.870]   - Field: ‘calls’
[09:31:13.870]   - Field: ‘globals’
[09:31:13.870]   - Field: ‘stdout’
[09:31:13.870]   - Field: ‘earlySignal’
[09:31:13.870]   - Field: ‘lazy’
[09:31:13.870]   - Field: ‘state’
[09:31:13.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.870] - Launch lazy future ...
[09:31:13.871] Packages needed by the future expression (n = 0): <none>
[09:31:13.871] Packages needed by future strategies (n = 0): <none>
[09:31:13.871] {
[09:31:13.871]     {
[09:31:13.871]         {
[09:31:13.871]             ...future.startTime <- base::Sys.time()
[09:31:13.871]             {
[09:31:13.871]                 {
[09:31:13.871]                   {
[09:31:13.871]                     {
[09:31:13.871]                       base::local({
[09:31:13.871]                         has_future <- base::requireNamespace("future", 
[09:31:13.871]                           quietly = TRUE)
[09:31:13.871]                         if (has_future) {
[09:31:13.871]                           ns <- base::getNamespace("future")
[09:31:13.871]                           version <- ns[[".package"]][["version"]]
[09:31:13.871]                           if (is.null(version)) 
[09:31:13.871]                             version <- utils::packageVersion("future")
[09:31:13.871]                         }
[09:31:13.871]                         else {
[09:31:13.871]                           version <- NULL
[09:31:13.871]                         }
[09:31:13.871]                         if (!has_future || version < "1.8.0") {
[09:31:13.871]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.871]                             "", base::R.version$version.string), 
[09:31:13.871]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.871]                               "release", "version")], collapse = " "), 
[09:31:13.871]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.871]                             info)
[09:31:13.871]                           info <- base::paste(info, collapse = "; ")
[09:31:13.871]                           if (!has_future) {
[09:31:13.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.871]                               info)
[09:31:13.871]                           }
[09:31:13.871]                           else {
[09:31:13.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.871]                               info, version)
[09:31:13.871]                           }
[09:31:13.871]                           base::stop(msg)
[09:31:13.871]                         }
[09:31:13.871]                       })
[09:31:13.871]                     }
[09:31:13.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.871]                     base::options(mc.cores = 1L)
[09:31:13.871]                   }
[09:31:13.871]                   ...future.strategy.old <- future::plan("list")
[09:31:13.871]                   options(future.plan = NULL)
[09:31:13.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.871]                 }
[09:31:13.871]                 ...future.workdir <- getwd()
[09:31:13.871]             }
[09:31:13.871]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.871]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.871]         }
[09:31:13.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.871]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.871]             base::names(...future.oldOptions))
[09:31:13.871]     }
[09:31:13.871]     if (FALSE) {
[09:31:13.871]     }
[09:31:13.871]     else {
[09:31:13.871]         if (TRUE) {
[09:31:13.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.871]                 open = "w")
[09:31:13.871]         }
[09:31:13.871]         else {
[09:31:13.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.871]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.871]         }
[09:31:13.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.871]             base::sink(type = "output", split = FALSE)
[09:31:13.871]             base::close(...future.stdout)
[09:31:13.871]         }, add = TRUE)
[09:31:13.871]     }
[09:31:13.871]     ...future.frame <- base::sys.nframe()
[09:31:13.871]     ...future.conditions <- base::list()
[09:31:13.871]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.871]     if (FALSE) {
[09:31:13.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.871]     }
[09:31:13.871]     ...future.result <- base::tryCatch({
[09:31:13.871]         base::withCallingHandlers({
[09:31:13.871]             ...future.value <- base::withVisible(base::local({
[09:31:13.871]                 withCallingHandlers({
[09:31:13.871]                   2
[09:31:13.871]                 }, immediateCondition = function(cond) {
[09:31:13.871]                   save_rds <- function (object, pathname, ...) 
[09:31:13.871]                   {
[09:31:13.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.871]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.871]                         fi_tmp[["mtime"]])
[09:31:13.871]                     }
[09:31:13.871]                     tryCatch({
[09:31:13.871]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.871]                     }, error = function(ex) {
[09:31:13.871]                       msg <- conditionMessage(ex)
[09:31:13.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.871]                         fi_tmp[["mtime"]], msg)
[09:31:13.871]                       ex$message <- msg
[09:31:13.871]                       stop(ex)
[09:31:13.871]                     })
[09:31:13.871]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.871]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.871]                       fi <- file.info(pathname)
[09:31:13.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.871]                         fi[["size"]], fi[["mtime"]])
[09:31:13.871]                       stop(msg)
[09:31:13.871]                     }
[09:31:13.871]                     invisible(pathname)
[09:31:13.871]                   }
[09:31:13.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.871]                     rootPath = tempdir()) 
[09:31:13.871]                   {
[09:31:13.871]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.871]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.871]                       tmpdir = path, fileext = ".rds")
[09:31:13.871]                     save_rds(obj, file)
[09:31:13.871]                   }
[09:31:13.871]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.871]                   {
[09:31:13.871]                     inherits <- base::inherits
[09:31:13.871]                     invokeRestart <- base::invokeRestart
[09:31:13.871]                     is.null <- base::is.null
[09:31:13.871]                     muffled <- FALSE
[09:31:13.871]                     if (inherits(cond, "message")) {
[09:31:13.871]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.871]                       if (muffled) 
[09:31:13.871]                         invokeRestart("muffleMessage")
[09:31:13.871]                     }
[09:31:13.871]                     else if (inherits(cond, "warning")) {
[09:31:13.871]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.871]                       if (muffled) 
[09:31:13.871]                         invokeRestart("muffleWarning")
[09:31:13.871]                     }
[09:31:13.871]                     else if (inherits(cond, "condition")) {
[09:31:13.871]                       if (!is.null(pattern)) {
[09:31:13.871]                         computeRestarts <- base::computeRestarts
[09:31:13.871]                         grepl <- base::grepl
[09:31:13.871]                         restarts <- computeRestarts(cond)
[09:31:13.871]                         for (restart in restarts) {
[09:31:13.871]                           name <- restart$name
[09:31:13.871]                           if (is.null(name)) 
[09:31:13.871]                             next
[09:31:13.871]                           if (!grepl(pattern, name)) 
[09:31:13.871]                             next
[09:31:13.871]                           invokeRestart(restart)
[09:31:13.871]                           muffled <- TRUE
[09:31:13.871]                           break
[09:31:13.871]                         }
[09:31:13.871]                       }
[09:31:13.871]                     }
[09:31:13.871]                     invisible(muffled)
[09:31:13.871]                   }
[09:31:13.871]                   muffleCondition(cond)
[09:31:13.871]                 })
[09:31:13.871]             }))
[09:31:13.871]             future::FutureResult(value = ...future.value$value, 
[09:31:13.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.871]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.871]                     ...future.globalenv.names))
[09:31:13.871]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.871]         }, condition = base::local({
[09:31:13.871]             c <- base::c
[09:31:13.871]             inherits <- base::inherits
[09:31:13.871]             invokeRestart <- base::invokeRestart
[09:31:13.871]             length <- base::length
[09:31:13.871]             list <- base::list
[09:31:13.871]             seq.int <- base::seq.int
[09:31:13.871]             signalCondition <- base::signalCondition
[09:31:13.871]             sys.calls <- base::sys.calls
[09:31:13.871]             `[[` <- base::`[[`
[09:31:13.871]             `+` <- base::`+`
[09:31:13.871]             `<<-` <- base::`<<-`
[09:31:13.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.871]                   3L)]
[09:31:13.871]             }
[09:31:13.871]             function(cond) {
[09:31:13.871]                 is_error <- inherits(cond, "error")
[09:31:13.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.871]                   NULL)
[09:31:13.871]                 if (is_error) {
[09:31:13.871]                   sessionInformation <- function() {
[09:31:13.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.871]                       search = base::search(), system = base::Sys.info())
[09:31:13.871]                   }
[09:31:13.871]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.871]                     cond$call), session = sessionInformation(), 
[09:31:13.871]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.871]                   signalCondition(cond)
[09:31:13.871]                 }
[09:31:13.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.871]                 "immediateCondition"))) {
[09:31:13.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.871]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.871]                   if (TRUE && !signal) {
[09:31:13.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.871]                     {
[09:31:13.871]                       inherits <- base::inherits
[09:31:13.871]                       invokeRestart <- base::invokeRestart
[09:31:13.871]                       is.null <- base::is.null
[09:31:13.871]                       muffled <- FALSE
[09:31:13.871]                       if (inherits(cond, "message")) {
[09:31:13.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.871]                         if (muffled) 
[09:31:13.871]                           invokeRestart("muffleMessage")
[09:31:13.871]                       }
[09:31:13.871]                       else if (inherits(cond, "warning")) {
[09:31:13.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.871]                         if (muffled) 
[09:31:13.871]                           invokeRestart("muffleWarning")
[09:31:13.871]                       }
[09:31:13.871]                       else if (inherits(cond, "condition")) {
[09:31:13.871]                         if (!is.null(pattern)) {
[09:31:13.871]                           computeRestarts <- base::computeRestarts
[09:31:13.871]                           grepl <- base::grepl
[09:31:13.871]                           restarts <- computeRestarts(cond)
[09:31:13.871]                           for (restart in restarts) {
[09:31:13.871]                             name <- restart$name
[09:31:13.871]                             if (is.null(name)) 
[09:31:13.871]                               next
[09:31:13.871]                             if (!grepl(pattern, name)) 
[09:31:13.871]                               next
[09:31:13.871]                             invokeRestart(restart)
[09:31:13.871]                             muffled <- TRUE
[09:31:13.871]                             break
[09:31:13.871]                           }
[09:31:13.871]                         }
[09:31:13.871]                       }
[09:31:13.871]                       invisible(muffled)
[09:31:13.871]                     }
[09:31:13.871]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.871]                   }
[09:31:13.871]                 }
[09:31:13.871]                 else {
[09:31:13.871]                   if (TRUE) {
[09:31:13.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.871]                     {
[09:31:13.871]                       inherits <- base::inherits
[09:31:13.871]                       invokeRestart <- base::invokeRestart
[09:31:13.871]                       is.null <- base::is.null
[09:31:13.871]                       muffled <- FALSE
[09:31:13.871]                       if (inherits(cond, "message")) {
[09:31:13.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.871]                         if (muffled) 
[09:31:13.871]                           invokeRestart("muffleMessage")
[09:31:13.871]                       }
[09:31:13.871]                       else if (inherits(cond, "warning")) {
[09:31:13.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.871]                         if (muffled) 
[09:31:13.871]                           invokeRestart("muffleWarning")
[09:31:13.871]                       }
[09:31:13.871]                       else if (inherits(cond, "condition")) {
[09:31:13.871]                         if (!is.null(pattern)) {
[09:31:13.871]                           computeRestarts <- base::computeRestarts
[09:31:13.871]                           grepl <- base::grepl
[09:31:13.871]                           restarts <- computeRestarts(cond)
[09:31:13.871]                           for (restart in restarts) {
[09:31:13.871]                             name <- restart$name
[09:31:13.871]                             if (is.null(name)) 
[09:31:13.871]                               next
[09:31:13.871]                             if (!grepl(pattern, name)) 
[09:31:13.871]                               next
[09:31:13.871]                             invokeRestart(restart)
[09:31:13.871]                             muffled <- TRUE
[09:31:13.871]                             break
[09:31:13.871]                           }
[09:31:13.871]                         }
[09:31:13.871]                       }
[09:31:13.871]                       invisible(muffled)
[09:31:13.871]                     }
[09:31:13.871]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.871]                   }
[09:31:13.871]                 }
[09:31:13.871]             }
[09:31:13.871]         }))
[09:31:13.871]     }, error = function(ex) {
[09:31:13.871]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.871]                 ...future.rng), started = ...future.startTime, 
[09:31:13.871]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.871]             version = "1.8"), class = "FutureResult")
[09:31:13.871]     }, finally = {
[09:31:13.871]         if (!identical(...future.workdir, getwd())) 
[09:31:13.871]             setwd(...future.workdir)
[09:31:13.871]         {
[09:31:13.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.871]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.871]             }
[09:31:13.871]             base::options(...future.oldOptions)
[09:31:13.871]             if (.Platform$OS.type == "windows") {
[09:31:13.871]                 old_names <- names(...future.oldEnvVars)
[09:31:13.871]                 envs <- base::Sys.getenv()
[09:31:13.871]                 names <- names(envs)
[09:31:13.871]                 common <- intersect(names, old_names)
[09:31:13.871]                 added <- setdiff(names, old_names)
[09:31:13.871]                 removed <- setdiff(old_names, names)
[09:31:13.871]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.871]                   envs[common]]
[09:31:13.871]                 NAMES <- toupper(changed)
[09:31:13.871]                 args <- list()
[09:31:13.871]                 for (kk in seq_along(NAMES)) {
[09:31:13.871]                   name <- changed[[kk]]
[09:31:13.871]                   NAME <- NAMES[[kk]]
[09:31:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.871]                     next
[09:31:13.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.871]                 }
[09:31:13.871]                 NAMES <- toupper(added)
[09:31:13.871]                 for (kk in seq_along(NAMES)) {
[09:31:13.871]                   name <- added[[kk]]
[09:31:13.871]                   NAME <- NAMES[[kk]]
[09:31:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.871]                     next
[09:31:13.871]                   args[[name]] <- ""
[09:31:13.871]                 }
[09:31:13.871]                 NAMES <- toupper(removed)
[09:31:13.871]                 for (kk in seq_along(NAMES)) {
[09:31:13.871]                   name <- removed[[kk]]
[09:31:13.871]                   NAME <- NAMES[[kk]]
[09:31:13.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.871]                     next
[09:31:13.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.871]                 }
[09:31:13.871]                 if (length(args) > 0) 
[09:31:13.871]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.871]             }
[09:31:13.871]             else {
[09:31:13.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.871]             }
[09:31:13.871]             {
[09:31:13.871]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.871]                   0L) {
[09:31:13.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.871]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.871]                   base::options(opts)
[09:31:13.871]                 }
[09:31:13.871]                 {
[09:31:13.871]                   {
[09:31:13.871]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.871]                     NULL
[09:31:13.871]                   }
[09:31:13.871]                   options(future.plan = NULL)
[09:31:13.871]                   if (is.na(NA_character_)) 
[09:31:13.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.871]                     .init = FALSE)
[09:31:13.871]                 }
[09:31:13.871]             }
[09:31:13.871]         }
[09:31:13.871]     })
[09:31:13.871]     if (TRUE) {
[09:31:13.871]         base::sink(type = "output", split = FALSE)
[09:31:13.871]         if (TRUE) {
[09:31:13.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.871]         }
[09:31:13.871]         else {
[09:31:13.871]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.871]         }
[09:31:13.871]         base::close(...future.stdout)
[09:31:13.871]         ...future.stdout <- NULL
[09:31:13.871]     }
[09:31:13.871]     ...future.result$conditions <- ...future.conditions
[09:31:13.871]     ...future.result$finished <- base::Sys.time()
[09:31:13.871]     ...future.result
[09:31:13.871] }
[09:31:13.874] requestCore(): workers = 2
[09:31:13.876] MulticoreFuture started
[09:31:13.876] - Launch lazy future ... done
[09:31:13.877] run() for ‘MulticoreFuture’ ... done
[09:31:13.877] getGlobalsAndPackages() ...
[09:31:13.877] Searching for globals...
[09:31:13.877] plan(): Setting new future strategy stack:
[09:31:13.878] 
[09:31:13.878] Searching for globals ... DONE
[09:31:13.878] - globals: [0] <none>
[09:31:13.877] List of future strategies:
[09:31:13.877] 1. sequential:
[09:31:13.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.877]    - tweaked: FALSE
[09:31:13.877]    - call: NULL
[09:31:13.878] getGlobalsAndPackages() ... DONE
[09:31:13.878] plan(): nbrOfWorkers() = 1
[09:31:13.879] run() for ‘Future’ ...
[09:31:13.879] - state: ‘created’
[09:31:13.879] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.880] plan(): Setting new future strategy stack:
[09:31:13.880] List of future strategies:
[09:31:13.880] 1. multicore:
[09:31:13.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.880]    - tweaked: FALSE
[09:31:13.880]    - call: plan(strategy)
[09:31:13.884] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.884]   - Field: ‘label’
[09:31:13.885]   - Field: ‘local’
[09:31:13.885] plan(): nbrOfWorkers() = 2
[09:31:13.885]   - Field: ‘owner’
[09:31:13.885]   - Field: ‘envir’
[09:31:13.885]   - Field: ‘workers’
[09:31:13.885]   - Field: ‘packages’
[09:31:13.885]   - Field: ‘gc’
[09:31:13.885]   - Field: ‘job’
[09:31:13.886]   - Field: ‘conditions’
[09:31:13.886]   - Field: ‘expr’
[09:31:13.886]   - Field: ‘uuid’
[09:31:13.886]   - Field: ‘seed’
[09:31:13.886]   - Field: ‘version’
[09:31:13.886]   - Field: ‘result’
[09:31:13.886]   - Field: ‘asynchronous’
[09:31:13.886]   - Field: ‘calls’
[09:31:13.887]   - Field: ‘globals’
[09:31:13.887]   - Field: ‘stdout’
[09:31:13.887]   - Field: ‘earlySignal’
[09:31:13.887]   - Field: ‘lazy’
[09:31:13.887]   - Field: ‘state’
[09:31:13.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.887] - Launch lazy future ...
[09:31:13.888] Packages needed by the future expression (n = 0): <none>
[09:31:13.888] Packages needed by future strategies (n = 0): <none>
[09:31:13.889] {
[09:31:13.889]     {
[09:31:13.889]         {
[09:31:13.889]             ...future.startTime <- base::Sys.time()
[09:31:13.889]             {
[09:31:13.889]                 {
[09:31:13.889]                   {
[09:31:13.889]                     {
[09:31:13.889]                       base::local({
[09:31:13.889]                         has_future <- base::requireNamespace("future", 
[09:31:13.889]                           quietly = TRUE)
[09:31:13.889]                         if (has_future) {
[09:31:13.889]                           ns <- base::getNamespace("future")
[09:31:13.889]                           version <- ns[[".package"]][["version"]]
[09:31:13.889]                           if (is.null(version)) 
[09:31:13.889]                             version <- utils::packageVersion("future")
[09:31:13.889]                         }
[09:31:13.889]                         else {
[09:31:13.889]                           version <- NULL
[09:31:13.889]                         }
[09:31:13.889]                         if (!has_future || version < "1.8.0") {
[09:31:13.889]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.889]                             "", base::R.version$version.string), 
[09:31:13.889]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.889]                               "release", "version")], collapse = " "), 
[09:31:13.889]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.889]                             info)
[09:31:13.889]                           info <- base::paste(info, collapse = "; ")
[09:31:13.889]                           if (!has_future) {
[09:31:13.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.889]                               info)
[09:31:13.889]                           }
[09:31:13.889]                           else {
[09:31:13.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.889]                               info, version)
[09:31:13.889]                           }
[09:31:13.889]                           base::stop(msg)
[09:31:13.889]                         }
[09:31:13.889]                       })
[09:31:13.889]                     }
[09:31:13.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.889]                     base::options(mc.cores = 1L)
[09:31:13.889]                   }
[09:31:13.889]                   ...future.strategy.old <- future::plan("list")
[09:31:13.889]                   options(future.plan = NULL)
[09:31:13.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.889]                 }
[09:31:13.889]                 ...future.workdir <- getwd()
[09:31:13.889]             }
[09:31:13.889]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.889]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.889]         }
[09:31:13.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.889]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.889]             base::names(...future.oldOptions))
[09:31:13.889]     }
[09:31:13.889]     if (FALSE) {
[09:31:13.889]     }
[09:31:13.889]     else {
[09:31:13.889]         if (TRUE) {
[09:31:13.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.889]                 open = "w")
[09:31:13.889]         }
[09:31:13.889]         else {
[09:31:13.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.889]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.889]         }
[09:31:13.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.889]             base::sink(type = "output", split = FALSE)
[09:31:13.889]             base::close(...future.stdout)
[09:31:13.889]         }, add = TRUE)
[09:31:13.889]     }
[09:31:13.889]     ...future.frame <- base::sys.nframe()
[09:31:13.889]     ...future.conditions <- base::list()
[09:31:13.889]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.889]     if (FALSE) {
[09:31:13.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.889]     }
[09:31:13.889]     ...future.result <- base::tryCatch({
[09:31:13.889]         base::withCallingHandlers({
[09:31:13.889]             ...future.value <- base::withVisible(base::local({
[09:31:13.889]                 withCallingHandlers({
[09:31:13.889]                   NULL
[09:31:13.889]                 }, immediateCondition = function(cond) {
[09:31:13.889]                   save_rds <- function (object, pathname, ...) 
[09:31:13.889]                   {
[09:31:13.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.889]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.889]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.889]                         fi_tmp[["mtime"]])
[09:31:13.889]                     }
[09:31:13.889]                     tryCatch({
[09:31:13.889]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.889]                     }, error = function(ex) {
[09:31:13.889]                       msg <- conditionMessage(ex)
[09:31:13.889]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.889]                         fi_tmp[["mtime"]], msg)
[09:31:13.889]                       ex$message <- msg
[09:31:13.889]                       stop(ex)
[09:31:13.889]                     })
[09:31:13.889]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.889]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.889]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.889]                       fi <- file.info(pathname)
[09:31:13.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.889]                         fi[["size"]], fi[["mtime"]])
[09:31:13.889]                       stop(msg)
[09:31:13.889]                     }
[09:31:13.889]                     invisible(pathname)
[09:31:13.889]                   }
[09:31:13.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.889]                     rootPath = tempdir()) 
[09:31:13.889]                   {
[09:31:13.889]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.889]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.889]                       tmpdir = path, fileext = ".rds")
[09:31:13.889]                     save_rds(obj, file)
[09:31:13.889]                   }
[09:31:13.889]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.889]                   {
[09:31:13.889]                     inherits <- base::inherits
[09:31:13.889]                     invokeRestart <- base::invokeRestart
[09:31:13.889]                     is.null <- base::is.null
[09:31:13.889]                     muffled <- FALSE
[09:31:13.889]                     if (inherits(cond, "message")) {
[09:31:13.889]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.889]                       if (muffled) 
[09:31:13.889]                         invokeRestart("muffleMessage")
[09:31:13.889]                     }
[09:31:13.889]                     else if (inherits(cond, "warning")) {
[09:31:13.889]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.889]                       if (muffled) 
[09:31:13.889]                         invokeRestart("muffleWarning")
[09:31:13.889]                     }
[09:31:13.889]                     else if (inherits(cond, "condition")) {
[09:31:13.889]                       if (!is.null(pattern)) {
[09:31:13.889]                         computeRestarts <- base::computeRestarts
[09:31:13.889]                         grepl <- base::grepl
[09:31:13.889]                         restarts <- computeRestarts(cond)
[09:31:13.889]                         for (restart in restarts) {
[09:31:13.889]                           name <- restart$name
[09:31:13.889]                           if (is.null(name)) 
[09:31:13.889]                             next
[09:31:13.889]                           if (!grepl(pattern, name)) 
[09:31:13.889]                             next
[09:31:13.889]                           invokeRestart(restart)
[09:31:13.889]                           muffled <- TRUE
[09:31:13.889]                           break
[09:31:13.889]                         }
[09:31:13.889]                       }
[09:31:13.889]                     }
[09:31:13.889]                     invisible(muffled)
[09:31:13.889]                   }
[09:31:13.889]                   muffleCondition(cond)
[09:31:13.889]                 })
[09:31:13.889]             }))
[09:31:13.889]             future::FutureResult(value = ...future.value$value, 
[09:31:13.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.889]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.889]                     ...future.globalenv.names))
[09:31:13.889]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.889]         }, condition = base::local({
[09:31:13.889]             c <- base::c
[09:31:13.889]             inherits <- base::inherits
[09:31:13.889]             invokeRestart <- base::invokeRestart
[09:31:13.889]             length <- base::length
[09:31:13.889]             list <- base::list
[09:31:13.889]             seq.int <- base::seq.int
[09:31:13.889]             signalCondition <- base::signalCondition
[09:31:13.889]             sys.calls <- base::sys.calls
[09:31:13.889]             `[[` <- base::`[[`
[09:31:13.889]             `+` <- base::`+`
[09:31:13.889]             `<<-` <- base::`<<-`
[09:31:13.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.889]                   3L)]
[09:31:13.889]             }
[09:31:13.889]             function(cond) {
[09:31:13.889]                 is_error <- inherits(cond, "error")
[09:31:13.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.889]                   NULL)
[09:31:13.889]                 if (is_error) {
[09:31:13.889]                   sessionInformation <- function() {
[09:31:13.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.889]                       search = base::search(), system = base::Sys.info())
[09:31:13.889]                   }
[09:31:13.889]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.889]                     cond$call), session = sessionInformation(), 
[09:31:13.889]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.889]                   signalCondition(cond)
[09:31:13.889]                 }
[09:31:13.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.889]                 "immediateCondition"))) {
[09:31:13.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.889]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.889]                   if (TRUE && !signal) {
[09:31:13.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.889]                     {
[09:31:13.889]                       inherits <- base::inherits
[09:31:13.889]                       invokeRestart <- base::invokeRestart
[09:31:13.889]                       is.null <- base::is.null
[09:31:13.889]                       muffled <- FALSE
[09:31:13.889]                       if (inherits(cond, "message")) {
[09:31:13.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.889]                         if (muffled) 
[09:31:13.889]                           invokeRestart("muffleMessage")
[09:31:13.889]                       }
[09:31:13.889]                       else if (inherits(cond, "warning")) {
[09:31:13.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.889]                         if (muffled) 
[09:31:13.889]                           invokeRestart("muffleWarning")
[09:31:13.889]                       }
[09:31:13.889]                       else if (inherits(cond, "condition")) {
[09:31:13.889]                         if (!is.null(pattern)) {
[09:31:13.889]                           computeRestarts <- base::computeRestarts
[09:31:13.889]                           grepl <- base::grepl
[09:31:13.889]                           restarts <- computeRestarts(cond)
[09:31:13.889]                           for (restart in restarts) {
[09:31:13.889]                             name <- restart$name
[09:31:13.889]                             if (is.null(name)) 
[09:31:13.889]                               next
[09:31:13.889]                             if (!grepl(pattern, name)) 
[09:31:13.889]                               next
[09:31:13.889]                             invokeRestart(restart)
[09:31:13.889]                             muffled <- TRUE
[09:31:13.889]                             break
[09:31:13.889]                           }
[09:31:13.889]                         }
[09:31:13.889]                       }
[09:31:13.889]                       invisible(muffled)
[09:31:13.889]                     }
[09:31:13.889]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.889]                   }
[09:31:13.889]                 }
[09:31:13.889]                 else {
[09:31:13.889]                   if (TRUE) {
[09:31:13.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.889]                     {
[09:31:13.889]                       inherits <- base::inherits
[09:31:13.889]                       invokeRestart <- base::invokeRestart
[09:31:13.889]                       is.null <- base::is.null
[09:31:13.889]                       muffled <- FALSE
[09:31:13.889]                       if (inherits(cond, "message")) {
[09:31:13.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.889]                         if (muffled) 
[09:31:13.889]                           invokeRestart("muffleMessage")
[09:31:13.889]                       }
[09:31:13.889]                       else if (inherits(cond, "warning")) {
[09:31:13.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.889]                         if (muffled) 
[09:31:13.889]                           invokeRestart("muffleWarning")
[09:31:13.889]                       }
[09:31:13.889]                       else if (inherits(cond, "condition")) {
[09:31:13.889]                         if (!is.null(pattern)) {
[09:31:13.889]                           computeRestarts <- base::computeRestarts
[09:31:13.889]                           grepl <- base::grepl
[09:31:13.889]                           restarts <- computeRestarts(cond)
[09:31:13.889]                           for (restart in restarts) {
[09:31:13.889]                             name <- restart$name
[09:31:13.889]                             if (is.null(name)) 
[09:31:13.889]                               next
[09:31:13.889]                             if (!grepl(pattern, name)) 
[09:31:13.889]                               next
[09:31:13.889]                             invokeRestart(restart)
[09:31:13.889]                             muffled <- TRUE
[09:31:13.889]                             break
[09:31:13.889]                           }
[09:31:13.889]                         }
[09:31:13.889]                       }
[09:31:13.889]                       invisible(muffled)
[09:31:13.889]                     }
[09:31:13.889]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.889]                   }
[09:31:13.889]                 }
[09:31:13.889]             }
[09:31:13.889]         }))
[09:31:13.889]     }, error = function(ex) {
[09:31:13.889]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.889]                 ...future.rng), started = ...future.startTime, 
[09:31:13.889]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.889]             version = "1.8"), class = "FutureResult")
[09:31:13.889]     }, finally = {
[09:31:13.889]         if (!identical(...future.workdir, getwd())) 
[09:31:13.889]             setwd(...future.workdir)
[09:31:13.889]         {
[09:31:13.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.889]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.889]             }
[09:31:13.889]             base::options(...future.oldOptions)
[09:31:13.889]             if (.Platform$OS.type == "windows") {
[09:31:13.889]                 old_names <- names(...future.oldEnvVars)
[09:31:13.889]                 envs <- base::Sys.getenv()
[09:31:13.889]                 names <- names(envs)
[09:31:13.889]                 common <- intersect(names, old_names)
[09:31:13.889]                 added <- setdiff(names, old_names)
[09:31:13.889]                 removed <- setdiff(old_names, names)
[09:31:13.889]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.889]                   envs[common]]
[09:31:13.889]                 NAMES <- toupper(changed)
[09:31:13.889]                 args <- list()
[09:31:13.889]                 for (kk in seq_along(NAMES)) {
[09:31:13.889]                   name <- changed[[kk]]
[09:31:13.889]                   NAME <- NAMES[[kk]]
[09:31:13.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.889]                     next
[09:31:13.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.889]                 }
[09:31:13.889]                 NAMES <- toupper(added)
[09:31:13.889]                 for (kk in seq_along(NAMES)) {
[09:31:13.889]                   name <- added[[kk]]
[09:31:13.889]                   NAME <- NAMES[[kk]]
[09:31:13.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.889]                     next
[09:31:13.889]                   args[[name]] <- ""
[09:31:13.889]                 }
[09:31:13.889]                 NAMES <- toupper(removed)
[09:31:13.889]                 for (kk in seq_along(NAMES)) {
[09:31:13.889]                   name <- removed[[kk]]
[09:31:13.889]                   NAME <- NAMES[[kk]]
[09:31:13.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.889]                     next
[09:31:13.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.889]                 }
[09:31:13.889]                 if (length(args) > 0) 
[09:31:13.889]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.889]             }
[09:31:13.889]             else {
[09:31:13.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.889]             }
[09:31:13.889]             {
[09:31:13.889]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.889]                   0L) {
[09:31:13.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.889]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.889]                   base::options(opts)
[09:31:13.889]                 }
[09:31:13.889]                 {
[09:31:13.889]                   {
[09:31:13.889]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.889]                     NULL
[09:31:13.889]                   }
[09:31:13.889]                   options(future.plan = NULL)
[09:31:13.889]                   if (is.na(NA_character_)) 
[09:31:13.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.889]                     .init = FALSE)
[09:31:13.889]                 }
[09:31:13.889]             }
[09:31:13.889]         }
[09:31:13.889]     })
[09:31:13.889]     if (TRUE) {
[09:31:13.889]         base::sink(type = "output", split = FALSE)
[09:31:13.889]         if (TRUE) {
[09:31:13.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.889]         }
[09:31:13.889]         else {
[09:31:13.889]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.889]         }
[09:31:13.889]         base::close(...future.stdout)
[09:31:13.889]         ...future.stdout <- NULL
[09:31:13.889]     }
[09:31:13.889]     ...future.result$conditions <- ...future.conditions
[09:31:13.889]     ...future.result$finished <- base::Sys.time()
[09:31:13.889]     ...future.result
[09:31:13.889] }
[09:31:13.892] requestCore(): workers = 2
[09:31:13.894] MulticoreFuture started
[09:31:13.894] - Launch lazy future ... done
[09:31:13.895] run() for ‘MulticoreFuture’ ... done
[09:31:13.895] plan(): Setting new future strategy stack:
[09:31:13.895] getGlobalsAndPackages() ...
[09:31:13.896] Searching for globals...
[09:31:13.896] List of future strategies:
[09:31:13.896] 1. sequential:
[09:31:13.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.896]    - tweaked: FALSE
[09:31:13.896]    - call: NULL
[09:31:13.897] plan(): nbrOfWorkers() = 1
[09:31:13.897] - globals found: [1] ‘{’
[09:31:13.897] Searching for globals ... DONE
[09:31:13.897] Resolving globals: FALSE
[09:31:13.898] 
[09:31:13.898] 
[09:31:13.898] getGlobalsAndPackages() ... DONE
[09:31:13.898] plan(): Setting new future strategy stack:
[09:31:13.899] run() for ‘Future’ ...
[09:31:13.899] - state: ‘created’
[09:31:13.899] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.899] List of future strategies:
[09:31:13.899] 1. multicore:
[09:31:13.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.899]    - tweaked: FALSE
[09:31:13.899]    - call: plan(strategy)
[09:31:13.903] plan(): nbrOfWorkers() = 2
[09:31:13.904] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.904]   - Field: ‘label’
[09:31:13.904]   - Field: ‘local’
[09:31:13.904]   - Field: ‘owner’
[09:31:13.904]   - Field: ‘envir’
[09:31:13.905]   - Field: ‘workers’
[09:31:13.905]   - Field: ‘packages’
[09:31:13.905]   - Field: ‘gc’
[09:31:13.905]   - Field: ‘job’
[09:31:13.905]   - Field: ‘conditions’
[09:31:13.905]   - Field: ‘expr’
[09:31:13.905]   - Field: ‘uuid’
[09:31:13.905]   - Field: ‘seed’
[09:31:13.906]   - Field: ‘version’
[09:31:13.906]   - Field: ‘result’
[09:31:13.906]   - Field: ‘asynchronous’
[09:31:13.906]   - Field: ‘calls’
[09:31:13.906]   - Field: ‘globals’
[09:31:13.906]   - Field: ‘stdout’
[09:31:13.906]   - Field: ‘earlySignal’
[09:31:13.906]   - Field: ‘lazy’
[09:31:13.907]   - Field: ‘state’
[09:31:13.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.907] - Launch lazy future ...
[09:31:13.907] Packages needed by the future expression (n = 0): <none>
[09:31:13.907] Packages needed by future strategies (n = 0): <none>
[09:31:13.908] {
[09:31:13.908]     {
[09:31:13.908]         {
[09:31:13.908]             ...future.startTime <- base::Sys.time()
[09:31:13.908]             {
[09:31:13.908]                 {
[09:31:13.908]                   {
[09:31:13.908]                     {
[09:31:13.908]                       base::local({
[09:31:13.908]                         has_future <- base::requireNamespace("future", 
[09:31:13.908]                           quietly = TRUE)
[09:31:13.908]                         if (has_future) {
[09:31:13.908]                           ns <- base::getNamespace("future")
[09:31:13.908]                           version <- ns[[".package"]][["version"]]
[09:31:13.908]                           if (is.null(version)) 
[09:31:13.908]                             version <- utils::packageVersion("future")
[09:31:13.908]                         }
[09:31:13.908]                         else {
[09:31:13.908]                           version <- NULL
[09:31:13.908]                         }
[09:31:13.908]                         if (!has_future || version < "1.8.0") {
[09:31:13.908]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.908]                             "", base::R.version$version.string), 
[09:31:13.908]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.908]                               "release", "version")], collapse = " "), 
[09:31:13.908]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.908]                             info)
[09:31:13.908]                           info <- base::paste(info, collapse = "; ")
[09:31:13.908]                           if (!has_future) {
[09:31:13.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.908]                               info)
[09:31:13.908]                           }
[09:31:13.908]                           else {
[09:31:13.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.908]                               info, version)
[09:31:13.908]                           }
[09:31:13.908]                           base::stop(msg)
[09:31:13.908]                         }
[09:31:13.908]                       })
[09:31:13.908]                     }
[09:31:13.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.908]                     base::options(mc.cores = 1L)
[09:31:13.908]                   }
[09:31:13.908]                   ...future.strategy.old <- future::plan("list")
[09:31:13.908]                   options(future.plan = NULL)
[09:31:13.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.908]                 }
[09:31:13.908]                 ...future.workdir <- getwd()
[09:31:13.908]             }
[09:31:13.908]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.908]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.908]         }
[09:31:13.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.908]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.908]             base::names(...future.oldOptions))
[09:31:13.908]     }
[09:31:13.908]     if (FALSE) {
[09:31:13.908]     }
[09:31:13.908]     else {
[09:31:13.908]         if (TRUE) {
[09:31:13.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.908]                 open = "w")
[09:31:13.908]         }
[09:31:13.908]         else {
[09:31:13.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.908]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.908]         }
[09:31:13.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.908]             base::sink(type = "output", split = FALSE)
[09:31:13.908]             base::close(...future.stdout)
[09:31:13.908]         }, add = TRUE)
[09:31:13.908]     }
[09:31:13.908]     ...future.frame <- base::sys.nframe()
[09:31:13.908]     ...future.conditions <- base::list()
[09:31:13.908]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.908]     if (FALSE) {
[09:31:13.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.908]     }
[09:31:13.908]     ...future.result <- base::tryCatch({
[09:31:13.908]         base::withCallingHandlers({
[09:31:13.908]             ...future.value <- base::withVisible(base::local({
[09:31:13.908]                 withCallingHandlers({
[09:31:13.908]                   {
[09:31:13.908]                     4
[09:31:13.908]                   }
[09:31:13.908]                 }, immediateCondition = function(cond) {
[09:31:13.908]                   save_rds <- function (object, pathname, ...) 
[09:31:13.908]                   {
[09:31:13.908]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.908]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.908]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.908]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.908]                         fi_tmp[["mtime"]])
[09:31:13.908]                     }
[09:31:13.908]                     tryCatch({
[09:31:13.908]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.908]                     }, error = function(ex) {
[09:31:13.908]                       msg <- conditionMessage(ex)
[09:31:13.908]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.908]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.908]                         fi_tmp[["mtime"]], msg)
[09:31:13.908]                       ex$message <- msg
[09:31:13.908]                       stop(ex)
[09:31:13.908]                     })
[09:31:13.908]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.908]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.908]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.908]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.908]                       fi <- file.info(pathname)
[09:31:13.908]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.908]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.908]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.908]                         fi[["size"]], fi[["mtime"]])
[09:31:13.908]                       stop(msg)
[09:31:13.908]                     }
[09:31:13.908]                     invisible(pathname)
[09:31:13.908]                   }
[09:31:13.908]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.908]                     rootPath = tempdir()) 
[09:31:13.908]                   {
[09:31:13.908]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.908]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.908]                       tmpdir = path, fileext = ".rds")
[09:31:13.908]                     save_rds(obj, file)
[09:31:13.908]                   }
[09:31:13.908]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.908]                   {
[09:31:13.908]                     inherits <- base::inherits
[09:31:13.908]                     invokeRestart <- base::invokeRestart
[09:31:13.908]                     is.null <- base::is.null
[09:31:13.908]                     muffled <- FALSE
[09:31:13.908]                     if (inherits(cond, "message")) {
[09:31:13.908]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.908]                       if (muffled) 
[09:31:13.908]                         invokeRestart("muffleMessage")
[09:31:13.908]                     }
[09:31:13.908]                     else if (inherits(cond, "warning")) {
[09:31:13.908]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.908]                       if (muffled) 
[09:31:13.908]                         invokeRestart("muffleWarning")
[09:31:13.908]                     }
[09:31:13.908]                     else if (inherits(cond, "condition")) {
[09:31:13.908]                       if (!is.null(pattern)) {
[09:31:13.908]                         computeRestarts <- base::computeRestarts
[09:31:13.908]                         grepl <- base::grepl
[09:31:13.908]                         restarts <- computeRestarts(cond)
[09:31:13.908]                         for (restart in restarts) {
[09:31:13.908]                           name <- restart$name
[09:31:13.908]                           if (is.null(name)) 
[09:31:13.908]                             next
[09:31:13.908]                           if (!grepl(pattern, name)) 
[09:31:13.908]                             next
[09:31:13.908]                           invokeRestart(restart)
[09:31:13.908]                           muffled <- TRUE
[09:31:13.908]                           break
[09:31:13.908]                         }
[09:31:13.908]                       }
[09:31:13.908]                     }
[09:31:13.908]                     invisible(muffled)
[09:31:13.908]                   }
[09:31:13.908]                   muffleCondition(cond)
[09:31:13.908]                 })
[09:31:13.908]             }))
[09:31:13.908]             future::FutureResult(value = ...future.value$value, 
[09:31:13.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.908]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.908]                     ...future.globalenv.names))
[09:31:13.908]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.908]         }, condition = base::local({
[09:31:13.908]             c <- base::c
[09:31:13.908]             inherits <- base::inherits
[09:31:13.908]             invokeRestart <- base::invokeRestart
[09:31:13.908]             length <- base::length
[09:31:13.908]             list <- base::list
[09:31:13.908]             seq.int <- base::seq.int
[09:31:13.908]             signalCondition <- base::signalCondition
[09:31:13.908]             sys.calls <- base::sys.calls
[09:31:13.908]             `[[` <- base::`[[`
[09:31:13.908]             `+` <- base::`+`
[09:31:13.908]             `<<-` <- base::`<<-`
[09:31:13.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.908]                   3L)]
[09:31:13.908]             }
[09:31:13.908]             function(cond) {
[09:31:13.908]                 is_error <- inherits(cond, "error")
[09:31:13.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.908]                   NULL)
[09:31:13.908]                 if (is_error) {
[09:31:13.908]                   sessionInformation <- function() {
[09:31:13.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.908]                       search = base::search(), system = base::Sys.info())
[09:31:13.908]                   }
[09:31:13.908]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.908]                     cond$call), session = sessionInformation(), 
[09:31:13.908]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.908]                   signalCondition(cond)
[09:31:13.908]                 }
[09:31:13.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.908]                 "immediateCondition"))) {
[09:31:13.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.908]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.908]                   if (TRUE && !signal) {
[09:31:13.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.908]                     {
[09:31:13.908]                       inherits <- base::inherits
[09:31:13.908]                       invokeRestart <- base::invokeRestart
[09:31:13.908]                       is.null <- base::is.null
[09:31:13.908]                       muffled <- FALSE
[09:31:13.908]                       if (inherits(cond, "message")) {
[09:31:13.908]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.908]                         if (muffled) 
[09:31:13.908]                           invokeRestart("muffleMessage")
[09:31:13.908]                       }
[09:31:13.908]                       else if (inherits(cond, "warning")) {
[09:31:13.908]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.908]                         if (muffled) 
[09:31:13.908]                           invokeRestart("muffleWarning")
[09:31:13.908]                       }
[09:31:13.908]                       else if (inherits(cond, "condition")) {
[09:31:13.908]                         if (!is.null(pattern)) {
[09:31:13.908]                           computeRestarts <- base::computeRestarts
[09:31:13.908]                           grepl <- base::grepl
[09:31:13.908]                           restarts <- computeRestarts(cond)
[09:31:13.908]                           for (restart in restarts) {
[09:31:13.908]                             name <- restart$name
[09:31:13.908]                             if (is.null(name)) 
[09:31:13.908]                               next
[09:31:13.908]                             if (!grepl(pattern, name)) 
[09:31:13.908]                               next
[09:31:13.908]                             invokeRestart(restart)
[09:31:13.908]                             muffled <- TRUE
[09:31:13.908]                             break
[09:31:13.908]                           }
[09:31:13.908]                         }
[09:31:13.908]                       }
[09:31:13.908]                       invisible(muffled)
[09:31:13.908]                     }
[09:31:13.908]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.908]                   }
[09:31:13.908]                 }
[09:31:13.908]                 else {
[09:31:13.908]                   if (TRUE) {
[09:31:13.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.908]                     {
[09:31:13.908]                       inherits <- base::inherits
[09:31:13.908]                       invokeRestart <- base::invokeRestart
[09:31:13.908]                       is.null <- base::is.null
[09:31:13.908]                       muffled <- FALSE
[09:31:13.908]                       if (inherits(cond, "message")) {
[09:31:13.908]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.908]                         if (muffled) 
[09:31:13.908]                           invokeRestart("muffleMessage")
[09:31:13.908]                       }
[09:31:13.908]                       else if (inherits(cond, "warning")) {
[09:31:13.908]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.908]                         if (muffled) 
[09:31:13.908]                           invokeRestart("muffleWarning")
[09:31:13.908]                       }
[09:31:13.908]                       else if (inherits(cond, "condition")) {
[09:31:13.908]                         if (!is.null(pattern)) {
[09:31:13.908]                           computeRestarts <- base::computeRestarts
[09:31:13.908]                           grepl <- base::grepl
[09:31:13.908]                           restarts <- computeRestarts(cond)
[09:31:13.908]                           for (restart in restarts) {
[09:31:13.908]                             name <- restart$name
[09:31:13.908]                             if (is.null(name)) 
[09:31:13.908]                               next
[09:31:13.908]                             if (!grepl(pattern, name)) 
[09:31:13.908]                               next
[09:31:13.908]                             invokeRestart(restart)
[09:31:13.908]                             muffled <- TRUE
[09:31:13.908]                             break
[09:31:13.908]                           }
[09:31:13.908]                         }
[09:31:13.908]                       }
[09:31:13.908]                       invisible(muffled)
[09:31:13.908]                     }
[09:31:13.908]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.908]                   }
[09:31:13.908]                 }
[09:31:13.908]             }
[09:31:13.908]         }))
[09:31:13.908]     }, error = function(ex) {
[09:31:13.908]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.908]                 ...future.rng), started = ...future.startTime, 
[09:31:13.908]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.908]             version = "1.8"), class = "FutureResult")
[09:31:13.908]     }, finally = {
[09:31:13.908]         if (!identical(...future.workdir, getwd())) 
[09:31:13.908]             setwd(...future.workdir)
[09:31:13.908]         {
[09:31:13.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.908]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.908]             }
[09:31:13.908]             base::options(...future.oldOptions)
[09:31:13.908]             if (.Platform$OS.type == "windows") {
[09:31:13.908]                 old_names <- names(...future.oldEnvVars)
[09:31:13.908]                 envs <- base::Sys.getenv()
[09:31:13.908]                 names <- names(envs)
[09:31:13.908]                 common <- intersect(names, old_names)
[09:31:13.908]                 added <- setdiff(names, old_names)
[09:31:13.908]                 removed <- setdiff(old_names, names)
[09:31:13.908]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.908]                   envs[common]]
[09:31:13.908]                 NAMES <- toupper(changed)
[09:31:13.908]                 args <- list()
[09:31:13.908]                 for (kk in seq_along(NAMES)) {
[09:31:13.908]                   name <- changed[[kk]]
[09:31:13.908]                   NAME <- NAMES[[kk]]
[09:31:13.908]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.908]                     next
[09:31:13.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.908]                 }
[09:31:13.908]                 NAMES <- toupper(added)
[09:31:13.908]                 for (kk in seq_along(NAMES)) {
[09:31:13.908]                   name <- added[[kk]]
[09:31:13.908]                   NAME <- NAMES[[kk]]
[09:31:13.908]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.908]                     next
[09:31:13.908]                   args[[name]] <- ""
[09:31:13.908]                 }
[09:31:13.908]                 NAMES <- toupper(removed)
[09:31:13.908]                 for (kk in seq_along(NAMES)) {
[09:31:13.908]                   name <- removed[[kk]]
[09:31:13.908]                   NAME <- NAMES[[kk]]
[09:31:13.908]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.908]                     next
[09:31:13.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.908]                 }
[09:31:13.908]                 if (length(args) > 0) 
[09:31:13.908]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.908]             }
[09:31:13.908]             else {
[09:31:13.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.908]             }
[09:31:13.908]             {
[09:31:13.908]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.908]                   0L) {
[09:31:13.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.908]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.908]                   base::options(opts)
[09:31:13.908]                 }
[09:31:13.908]                 {
[09:31:13.908]                   {
[09:31:13.908]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.908]                     NULL
[09:31:13.908]                   }
[09:31:13.908]                   options(future.plan = NULL)
[09:31:13.908]                   if (is.na(NA_character_)) 
[09:31:13.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.908]                     .init = FALSE)
[09:31:13.908]                 }
[09:31:13.908]             }
[09:31:13.908]         }
[09:31:13.908]     })
[09:31:13.908]     if (TRUE) {
[09:31:13.908]         base::sink(type = "output", split = FALSE)
[09:31:13.908]         if (TRUE) {
[09:31:13.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.908]         }
[09:31:13.908]         else {
[09:31:13.908]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.908]         }
[09:31:13.908]         base::close(...future.stdout)
[09:31:13.908]         ...future.stdout <- NULL
[09:31:13.908]     }
[09:31:13.908]     ...future.result$conditions <- ...future.conditions
[09:31:13.908]     ...future.result$finished <- base::Sys.time()
[09:31:13.908]     ...future.result
[09:31:13.908] }
[09:31:13.911] requestCore(): workers = 2
[09:31:13.912] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:13.922] result() for MulticoreFuture ...
[09:31:13.923] result() for MulticoreFuture ...
[09:31:13.923] result() for MulticoreFuture ... done
[09:31:13.924] result() for MulticoreFuture ... done
[09:31:13.924] result() for MulticoreFuture ...
[09:31:13.924] result() for MulticoreFuture ... done
[09:31:13.927] MulticoreFuture started
[09:31:13.927] - Launch lazy future ... done
[09:31:13.927] run() for ‘MulticoreFuture’ ... done
[09:31:13.928] plan(): Setting new future strategy stack:
<environment: 0x55a3cb80fa60> 
[09:31:13.928] List of future strategies:
[09:31:13.928] 1. sequential:
[09:31:13.928]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.928]    - tweaked: FALSE
[09:31:13.928]    - call: NULL
[09:31:13.929] plan(): nbrOfWorkers() = 1
<environment: 0x55a3cc854bf8> 
[09:31:13.931] plan(): Setting new future strategy stack:
[09:31:13.931] List of future strategies:
[09:31:13.931] 1. multicore:
[09:31:13.931]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.931]    - tweaked: FALSE
[09:31:13.931]    - call: plan(strategy)
[09:31:13.936] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:13.938] resolve() on environment ...
[09:31:13.938]  recursive: 0
[09:31:13.939]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:13.939] signalConditionsASAP(numeric, pos=1) ...
[09:31:13.940] - nx: 4
[09:31:13.940] - relay: TRUE
[09:31:13.940] - stdout: TRUE
[09:31:13.940] - signal: TRUE
[09:31:13.940] - resignal: FALSE
[09:31:13.940] - force: TRUE
[09:31:13.940] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.940] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.941]  - until=2
[09:31:13.941]  - relaying element #2
[09:31:13.941] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.941] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.941] signalConditionsASAP(NULL, pos=1) ... done
[09:31:13.941]  length: 3 (resolved future 1)
[09:31:13.941] Future #2
[09:31:13.942] result() for MulticoreFuture ...
[09:31:13.942] result() for MulticoreFuture ... done
[09:31:13.942] result() for MulticoreFuture ...
[09:31:13.942] result() for MulticoreFuture ... done
[09:31:13.942] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:13.942] - nx: 4
[09:31:13.942] - relay: TRUE
[09:31:13.943] - stdout: TRUE
[09:31:13.943] - signal: TRUE
[09:31:13.943] - resignal: FALSE
[09:31:13.943] - force: TRUE
[09:31:13.943] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:13.943] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:13.943]  - until=2
[09:31:13.943]  - relaying element #2
[09:31:13.943] result() for MulticoreFuture ...
[09:31:13.944] result() for MulticoreFuture ... done
[09:31:13.944] result() for MulticoreFuture ...
[09:31:13.944] result() for MulticoreFuture ... done
[09:31:13.944] result() for MulticoreFuture ...
[09:31:13.944] result() for MulticoreFuture ... done
[09:31:13.944] result() for MulticoreFuture ...
[09:31:13.944] result() for MulticoreFuture ... done
[09:31:13.945] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.945] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.945] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:13.945]  length: 2 (resolved future 2)
[09:31:13.945] Future #3
[09:31:13.945] result() for MulticoreFuture ...
[09:31:13.946] result() for MulticoreFuture ...
[09:31:13.946] result() for MulticoreFuture ... done
[09:31:13.947] result() for MulticoreFuture ... done
[09:31:13.947] result() for MulticoreFuture ...
[09:31:13.947] result() for MulticoreFuture ... done
[09:31:13.947] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:13.947] - nx: 4
[09:31:13.948] - relay: TRUE
[09:31:13.948] - stdout: TRUE
[09:31:13.948] - signal: TRUE
[09:31:13.948] - resignal: FALSE
[09:31:13.948] - force: TRUE
[09:31:13.948] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:13.948] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:13.949]  - until=3
[09:31:13.949]  - relaying element #3
[09:31:13.949] result() for MulticoreFuture ...
[09:31:13.949] result() for MulticoreFuture ... done
[09:31:13.949] result() for MulticoreFuture ...
[09:31:13.950] result() for MulticoreFuture ... done
[09:31:13.950] result() for MulticoreFuture ...
[09:31:13.950] result() for MulticoreFuture ... done
[09:31:13.950] result() for MulticoreFuture ...
[09:31:13.950] result() for MulticoreFuture ... done
[09:31:13.950] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.950] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.950] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:13.951]  length: 1 (resolved future 3)
[09:31:13.951] Future #4
[09:31:13.951] result() for MulticoreFuture ...
[09:31:13.952] result() for MulticoreFuture ...
[09:31:13.952] result() for MulticoreFuture ... done
[09:31:13.952] result() for MulticoreFuture ... done
[09:31:13.952] result() for MulticoreFuture ...
[09:31:13.952] result() for MulticoreFuture ... done
[09:31:13.952] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:13.952] - nx: 4
[09:31:13.953] - relay: TRUE
[09:31:13.953] - stdout: TRUE
[09:31:13.953] - signal: TRUE
[09:31:13.953] - resignal: FALSE
[09:31:13.953] - force: TRUE
[09:31:13.953] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:13.953] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:13.953]  - until=4
[09:31:13.953]  - relaying element #4
[09:31:13.954] result() for MulticoreFuture ...
[09:31:13.954] result() for MulticoreFuture ... done
[09:31:13.954] result() for MulticoreFuture ...
[09:31:13.954] result() for MulticoreFuture ... done
[09:31:13.954] result() for MulticoreFuture ...
[09:31:13.954] result() for MulticoreFuture ... done
[09:31:13.954] result() for MulticoreFuture ...
[09:31:13.954] result() for MulticoreFuture ... done
[09:31:13.954] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.955] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.955] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:13.955]  length: 0 (resolved future 4)
[09:31:13.955] Relaying remaining futures
[09:31:13.955] signalConditionsASAP(NULL, pos=0) ...
[09:31:13.955] - nx: 4
[09:31:13.955] - relay: TRUE
[09:31:13.955] - stdout: TRUE
[09:31:13.955] - signal: TRUE
[09:31:13.955] - resignal: FALSE
[09:31:13.955] - force: TRUE
[09:31:13.956] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.956] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:13.956] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:13.956] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:13.956] signalConditionsASAP(NULL, pos=0) ... done
[09:31:13.956] resolve() on environment ... DONE
[09:31:13.956] result() for MulticoreFuture ...
[09:31:13.956] result() for MulticoreFuture ... done
[09:31:13.957] result() for MulticoreFuture ...
[09:31:13.957] result() for MulticoreFuture ... done
[09:31:13.957] result() for MulticoreFuture ...
[09:31:13.957] result() for MulticoreFuture ... done
[09:31:13.957] result() for MulticoreFuture ...
[09:31:13.957] result() for MulticoreFuture ... done
[09:31:13.957] result() for MulticoreFuture ...
[09:31:13.957] result() for MulticoreFuture ... done
[09:31:13.957] result() for MulticoreFuture ...
[09:31:13.957] result() for MulticoreFuture ... done
<environment: 0x55a3cc920c50> 
Dimensions: c(2, 1, 3, 1)
[09:31:13.958] getGlobalsAndPackages() ...
[09:31:13.958] Searching for globals...
[09:31:13.962] 
[09:31:13.962] Searching for globals ... DONE
[09:31:13.963] - globals: [0] <none>
[09:31:13.963] getGlobalsAndPackages() ... DONE
[09:31:13.963] run() for ‘Future’ ...
[09:31:13.963] - state: ‘created’
[09:31:13.963] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.967] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.968]   - Field: ‘label’
[09:31:13.968]   - Field: ‘local’
[09:31:13.968]   - Field: ‘owner’
[09:31:13.968]   - Field: ‘envir’
[09:31:13.968]   - Field: ‘workers’
[09:31:13.969]   - Field: ‘packages’
[09:31:13.969]   - Field: ‘gc’
[09:31:13.969]   - Field: ‘job’
[09:31:13.969]   - Field: ‘conditions’
[09:31:13.969]   - Field: ‘expr’
[09:31:13.969]   - Field: ‘uuid’
[09:31:13.969]   - Field: ‘seed’
[09:31:13.969]   - Field: ‘version’
[09:31:13.969]   - Field: ‘result’
[09:31:13.970]   - Field: ‘asynchronous’
[09:31:13.970]   - Field: ‘calls’
[09:31:13.970]   - Field: ‘globals’
[09:31:13.970]   - Field: ‘stdout’
[09:31:13.970]   - Field: ‘earlySignal’
[09:31:13.970]   - Field: ‘lazy’
[09:31:13.970]   - Field: ‘state’
[09:31:13.970] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.970] - Launch lazy future ...
[09:31:13.971] Packages needed by the future expression (n = 0): <none>
[09:31:13.971] Packages needed by future strategies (n = 0): <none>
[09:31:13.971] {
[09:31:13.971]     {
[09:31:13.971]         {
[09:31:13.971]             ...future.startTime <- base::Sys.time()
[09:31:13.971]             {
[09:31:13.971]                 {
[09:31:13.971]                   {
[09:31:13.971]                     {
[09:31:13.971]                       base::local({
[09:31:13.971]                         has_future <- base::requireNamespace("future", 
[09:31:13.971]                           quietly = TRUE)
[09:31:13.971]                         if (has_future) {
[09:31:13.971]                           ns <- base::getNamespace("future")
[09:31:13.971]                           version <- ns[[".package"]][["version"]]
[09:31:13.971]                           if (is.null(version)) 
[09:31:13.971]                             version <- utils::packageVersion("future")
[09:31:13.971]                         }
[09:31:13.971]                         else {
[09:31:13.971]                           version <- NULL
[09:31:13.971]                         }
[09:31:13.971]                         if (!has_future || version < "1.8.0") {
[09:31:13.971]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.971]                             "", base::R.version$version.string), 
[09:31:13.971]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.971]                               "release", "version")], collapse = " "), 
[09:31:13.971]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.971]                             info)
[09:31:13.971]                           info <- base::paste(info, collapse = "; ")
[09:31:13.971]                           if (!has_future) {
[09:31:13.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.971]                               info)
[09:31:13.971]                           }
[09:31:13.971]                           else {
[09:31:13.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.971]                               info, version)
[09:31:13.971]                           }
[09:31:13.971]                           base::stop(msg)
[09:31:13.971]                         }
[09:31:13.971]                       })
[09:31:13.971]                     }
[09:31:13.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.971]                     base::options(mc.cores = 1L)
[09:31:13.971]                   }
[09:31:13.971]                   ...future.strategy.old <- future::plan("list")
[09:31:13.971]                   options(future.plan = NULL)
[09:31:13.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.971]                 }
[09:31:13.971]                 ...future.workdir <- getwd()
[09:31:13.971]             }
[09:31:13.971]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.971]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.971]         }
[09:31:13.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.971]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.971]             base::names(...future.oldOptions))
[09:31:13.971]     }
[09:31:13.971]     if (FALSE) {
[09:31:13.971]     }
[09:31:13.971]     else {
[09:31:13.971]         if (TRUE) {
[09:31:13.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.971]                 open = "w")
[09:31:13.971]         }
[09:31:13.971]         else {
[09:31:13.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.971]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.971]         }
[09:31:13.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.971]             base::sink(type = "output", split = FALSE)
[09:31:13.971]             base::close(...future.stdout)
[09:31:13.971]         }, add = TRUE)
[09:31:13.971]     }
[09:31:13.971]     ...future.frame <- base::sys.nframe()
[09:31:13.971]     ...future.conditions <- base::list()
[09:31:13.971]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.971]     if (FALSE) {
[09:31:13.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.971]     }
[09:31:13.971]     ...future.result <- base::tryCatch({
[09:31:13.971]         base::withCallingHandlers({
[09:31:13.971]             ...future.value <- base::withVisible(base::local({
[09:31:13.971]                 withCallingHandlers({
[09:31:13.971]                   2
[09:31:13.971]                 }, immediateCondition = function(cond) {
[09:31:13.971]                   save_rds <- function (object, pathname, ...) 
[09:31:13.971]                   {
[09:31:13.971]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.971]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.971]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.971]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.971]                         fi_tmp[["mtime"]])
[09:31:13.971]                     }
[09:31:13.971]                     tryCatch({
[09:31:13.971]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.971]                     }, error = function(ex) {
[09:31:13.971]                       msg <- conditionMessage(ex)
[09:31:13.971]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.971]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.971]                         fi_tmp[["mtime"]], msg)
[09:31:13.971]                       ex$message <- msg
[09:31:13.971]                       stop(ex)
[09:31:13.971]                     })
[09:31:13.971]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.971]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.971]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.971]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.971]                       fi <- file.info(pathname)
[09:31:13.971]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.971]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.971]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.971]                         fi[["size"]], fi[["mtime"]])
[09:31:13.971]                       stop(msg)
[09:31:13.971]                     }
[09:31:13.971]                     invisible(pathname)
[09:31:13.971]                   }
[09:31:13.971]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.971]                     rootPath = tempdir()) 
[09:31:13.971]                   {
[09:31:13.971]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.971]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.971]                       tmpdir = path, fileext = ".rds")
[09:31:13.971]                     save_rds(obj, file)
[09:31:13.971]                   }
[09:31:13.971]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.971]                   {
[09:31:13.971]                     inherits <- base::inherits
[09:31:13.971]                     invokeRestart <- base::invokeRestart
[09:31:13.971]                     is.null <- base::is.null
[09:31:13.971]                     muffled <- FALSE
[09:31:13.971]                     if (inherits(cond, "message")) {
[09:31:13.971]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.971]                       if (muffled) 
[09:31:13.971]                         invokeRestart("muffleMessage")
[09:31:13.971]                     }
[09:31:13.971]                     else if (inherits(cond, "warning")) {
[09:31:13.971]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.971]                       if (muffled) 
[09:31:13.971]                         invokeRestart("muffleWarning")
[09:31:13.971]                     }
[09:31:13.971]                     else if (inherits(cond, "condition")) {
[09:31:13.971]                       if (!is.null(pattern)) {
[09:31:13.971]                         computeRestarts <- base::computeRestarts
[09:31:13.971]                         grepl <- base::grepl
[09:31:13.971]                         restarts <- computeRestarts(cond)
[09:31:13.971]                         for (restart in restarts) {
[09:31:13.971]                           name <- restart$name
[09:31:13.971]                           if (is.null(name)) 
[09:31:13.971]                             next
[09:31:13.971]                           if (!grepl(pattern, name)) 
[09:31:13.971]                             next
[09:31:13.971]                           invokeRestart(restart)
[09:31:13.971]                           muffled <- TRUE
[09:31:13.971]                           break
[09:31:13.971]                         }
[09:31:13.971]                       }
[09:31:13.971]                     }
[09:31:13.971]                     invisible(muffled)
[09:31:13.971]                   }
[09:31:13.971]                   muffleCondition(cond)
[09:31:13.971]                 })
[09:31:13.971]             }))
[09:31:13.971]             future::FutureResult(value = ...future.value$value, 
[09:31:13.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.971]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.971]                     ...future.globalenv.names))
[09:31:13.971]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.971]         }, condition = base::local({
[09:31:13.971]             c <- base::c
[09:31:13.971]             inherits <- base::inherits
[09:31:13.971]             invokeRestart <- base::invokeRestart
[09:31:13.971]             length <- base::length
[09:31:13.971]             list <- base::list
[09:31:13.971]             seq.int <- base::seq.int
[09:31:13.971]             signalCondition <- base::signalCondition
[09:31:13.971]             sys.calls <- base::sys.calls
[09:31:13.971]             `[[` <- base::`[[`
[09:31:13.971]             `+` <- base::`+`
[09:31:13.971]             `<<-` <- base::`<<-`
[09:31:13.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.971]                   3L)]
[09:31:13.971]             }
[09:31:13.971]             function(cond) {
[09:31:13.971]                 is_error <- inherits(cond, "error")
[09:31:13.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.971]                   NULL)
[09:31:13.971]                 if (is_error) {
[09:31:13.971]                   sessionInformation <- function() {
[09:31:13.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.971]                       search = base::search(), system = base::Sys.info())
[09:31:13.971]                   }
[09:31:13.971]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.971]                     cond$call), session = sessionInformation(), 
[09:31:13.971]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.971]                   signalCondition(cond)
[09:31:13.971]                 }
[09:31:13.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.971]                 "immediateCondition"))) {
[09:31:13.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.971]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.971]                   if (TRUE && !signal) {
[09:31:13.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.971]                     {
[09:31:13.971]                       inherits <- base::inherits
[09:31:13.971]                       invokeRestart <- base::invokeRestart
[09:31:13.971]                       is.null <- base::is.null
[09:31:13.971]                       muffled <- FALSE
[09:31:13.971]                       if (inherits(cond, "message")) {
[09:31:13.971]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.971]                         if (muffled) 
[09:31:13.971]                           invokeRestart("muffleMessage")
[09:31:13.971]                       }
[09:31:13.971]                       else if (inherits(cond, "warning")) {
[09:31:13.971]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.971]                         if (muffled) 
[09:31:13.971]                           invokeRestart("muffleWarning")
[09:31:13.971]                       }
[09:31:13.971]                       else if (inherits(cond, "condition")) {
[09:31:13.971]                         if (!is.null(pattern)) {
[09:31:13.971]                           computeRestarts <- base::computeRestarts
[09:31:13.971]                           grepl <- base::grepl
[09:31:13.971]                           restarts <- computeRestarts(cond)
[09:31:13.971]                           for (restart in restarts) {
[09:31:13.971]                             name <- restart$name
[09:31:13.971]                             if (is.null(name)) 
[09:31:13.971]                               next
[09:31:13.971]                             if (!grepl(pattern, name)) 
[09:31:13.971]                               next
[09:31:13.971]                             invokeRestart(restart)
[09:31:13.971]                             muffled <- TRUE
[09:31:13.971]                             break
[09:31:13.971]                           }
[09:31:13.971]                         }
[09:31:13.971]                       }
[09:31:13.971]                       invisible(muffled)
[09:31:13.971]                     }
[09:31:13.971]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.971]                   }
[09:31:13.971]                 }
[09:31:13.971]                 else {
[09:31:13.971]                   if (TRUE) {
[09:31:13.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.971]                     {
[09:31:13.971]                       inherits <- base::inherits
[09:31:13.971]                       invokeRestart <- base::invokeRestart
[09:31:13.971]                       is.null <- base::is.null
[09:31:13.971]                       muffled <- FALSE
[09:31:13.971]                       if (inherits(cond, "message")) {
[09:31:13.971]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.971]                         if (muffled) 
[09:31:13.971]                           invokeRestart("muffleMessage")
[09:31:13.971]                       }
[09:31:13.971]                       else if (inherits(cond, "warning")) {
[09:31:13.971]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.971]                         if (muffled) 
[09:31:13.971]                           invokeRestart("muffleWarning")
[09:31:13.971]                       }
[09:31:13.971]                       else if (inherits(cond, "condition")) {
[09:31:13.971]                         if (!is.null(pattern)) {
[09:31:13.971]                           computeRestarts <- base::computeRestarts
[09:31:13.971]                           grepl <- base::grepl
[09:31:13.971]                           restarts <- computeRestarts(cond)
[09:31:13.971]                           for (restart in restarts) {
[09:31:13.971]                             name <- restart$name
[09:31:13.971]                             if (is.null(name)) 
[09:31:13.971]                               next
[09:31:13.971]                             if (!grepl(pattern, name)) 
[09:31:13.971]                               next
[09:31:13.971]                             invokeRestart(restart)
[09:31:13.971]                             muffled <- TRUE
[09:31:13.971]                             break
[09:31:13.971]                           }
[09:31:13.971]                         }
[09:31:13.971]                       }
[09:31:13.971]                       invisible(muffled)
[09:31:13.971]                     }
[09:31:13.971]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.971]                   }
[09:31:13.971]                 }
[09:31:13.971]             }
[09:31:13.971]         }))
[09:31:13.971]     }, error = function(ex) {
[09:31:13.971]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.971]                 ...future.rng), started = ...future.startTime, 
[09:31:13.971]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.971]             version = "1.8"), class = "FutureResult")
[09:31:13.971]     }, finally = {
[09:31:13.971]         if (!identical(...future.workdir, getwd())) 
[09:31:13.971]             setwd(...future.workdir)
[09:31:13.971]         {
[09:31:13.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.971]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.971]             }
[09:31:13.971]             base::options(...future.oldOptions)
[09:31:13.971]             if (.Platform$OS.type == "windows") {
[09:31:13.971]                 old_names <- names(...future.oldEnvVars)
[09:31:13.971]                 envs <- base::Sys.getenv()
[09:31:13.971]                 names <- names(envs)
[09:31:13.971]                 common <- intersect(names, old_names)
[09:31:13.971]                 added <- setdiff(names, old_names)
[09:31:13.971]                 removed <- setdiff(old_names, names)
[09:31:13.971]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.971]                   envs[common]]
[09:31:13.971]                 NAMES <- toupper(changed)
[09:31:13.971]                 args <- list()
[09:31:13.971]                 for (kk in seq_along(NAMES)) {
[09:31:13.971]                   name <- changed[[kk]]
[09:31:13.971]                   NAME <- NAMES[[kk]]
[09:31:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.971]                     next
[09:31:13.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.971]                 }
[09:31:13.971]                 NAMES <- toupper(added)
[09:31:13.971]                 for (kk in seq_along(NAMES)) {
[09:31:13.971]                   name <- added[[kk]]
[09:31:13.971]                   NAME <- NAMES[[kk]]
[09:31:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.971]                     next
[09:31:13.971]                   args[[name]] <- ""
[09:31:13.971]                 }
[09:31:13.971]                 NAMES <- toupper(removed)
[09:31:13.971]                 for (kk in seq_along(NAMES)) {
[09:31:13.971]                   name <- removed[[kk]]
[09:31:13.971]                   NAME <- NAMES[[kk]]
[09:31:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.971]                     next
[09:31:13.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.971]                 }
[09:31:13.971]                 if (length(args) > 0) 
[09:31:13.971]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.971]             }
[09:31:13.971]             else {
[09:31:13.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.971]             }
[09:31:13.971]             {
[09:31:13.971]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.971]                   0L) {
[09:31:13.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.971]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.971]                   base::options(opts)
[09:31:13.971]                 }
[09:31:13.971]                 {
[09:31:13.971]                   {
[09:31:13.971]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.971]                     NULL
[09:31:13.971]                   }
[09:31:13.971]                   options(future.plan = NULL)
[09:31:13.971]                   if (is.na(NA_character_)) 
[09:31:13.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.971]                     .init = FALSE)
[09:31:13.971]                 }
[09:31:13.971]             }
[09:31:13.971]         }
[09:31:13.971]     })
[09:31:13.971]     if (TRUE) {
[09:31:13.971]         base::sink(type = "output", split = FALSE)
[09:31:13.971]         if (TRUE) {
[09:31:13.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.971]         }
[09:31:13.971]         else {
[09:31:13.971]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.971]         }
[09:31:13.971]         base::close(...future.stdout)
[09:31:13.971]         ...future.stdout <- NULL
[09:31:13.971]     }
[09:31:13.971]     ...future.result$conditions <- ...future.conditions
[09:31:13.971]     ...future.result$finished <- base::Sys.time()
[09:31:13.971]     ...future.result
[09:31:13.971] }
[09:31:13.974] requestCore(): workers = 2
[09:31:13.976] MulticoreFuture started
[09:31:13.976] - Launch lazy future ... done
[09:31:13.976] run() for ‘MulticoreFuture’ ... done
[09:31:13.976] getGlobalsAndPackages() ...
[09:31:13.977] Searching for globals...
[09:31:13.977] plan(): Setting new future strategy stack:
[09:31:13.978] 
[09:31:13.978] Searching for globals ... DONE
[09:31:13.977] List of future strategies:
[09:31:13.977] 1. sequential:
[09:31:13.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.977]    - tweaked: FALSE
[09:31:13.977]    - call: NULL
[09:31:13.978] - globals: [0] <none>
[09:31:13.978] plan(): nbrOfWorkers() = 1
[09:31:13.978] getGlobalsAndPackages() ... DONE
[09:31:13.979] run() for ‘Future’ ...
[09:31:13.979] - state: ‘created’
[09:31:13.979] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.980] plan(): Setting new future strategy stack:
[09:31:13.980] List of future strategies:
[09:31:13.980] 1. multicore:
[09:31:13.980]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.980]    - tweaked: FALSE
[09:31:13.980]    - call: plan(strategy)
[09:31:13.984] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:13.984] plan(): nbrOfWorkers() = 2
[09:31:13.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:13.984]   - Field: ‘label’
[09:31:13.984]   - Field: ‘local’
[09:31:13.985]   - Field: ‘owner’
[09:31:13.985]   - Field: ‘envir’
[09:31:13.985]   - Field: ‘workers’
[09:31:13.985]   - Field: ‘packages’
[09:31:13.985]   - Field: ‘gc’
[09:31:13.985]   - Field: ‘job’
[09:31:13.985]   - Field: ‘conditions’
[09:31:13.986]   - Field: ‘expr’
[09:31:13.986]   - Field: ‘uuid’
[09:31:13.986]   - Field: ‘seed’
[09:31:13.986]   - Field: ‘version’
[09:31:13.986]   - Field: ‘result’
[09:31:13.986]   - Field: ‘asynchronous’
[09:31:13.986]   - Field: ‘calls’
[09:31:13.986]   - Field: ‘globals’
[09:31:13.987]   - Field: ‘stdout’
[09:31:13.987]   - Field: ‘earlySignal’
[09:31:13.987]   - Field: ‘lazy’
[09:31:13.987]   - Field: ‘state’
[09:31:13.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:13.987] - Launch lazy future ...
[09:31:13.988] Packages needed by the future expression (n = 0): <none>
[09:31:13.988] Packages needed by future strategies (n = 0): <none>
[09:31:13.989] {
[09:31:13.989]     {
[09:31:13.989]         {
[09:31:13.989]             ...future.startTime <- base::Sys.time()
[09:31:13.989]             {
[09:31:13.989]                 {
[09:31:13.989]                   {
[09:31:13.989]                     {
[09:31:13.989]                       base::local({
[09:31:13.989]                         has_future <- base::requireNamespace("future", 
[09:31:13.989]                           quietly = TRUE)
[09:31:13.989]                         if (has_future) {
[09:31:13.989]                           ns <- base::getNamespace("future")
[09:31:13.989]                           version <- ns[[".package"]][["version"]]
[09:31:13.989]                           if (is.null(version)) 
[09:31:13.989]                             version <- utils::packageVersion("future")
[09:31:13.989]                         }
[09:31:13.989]                         else {
[09:31:13.989]                           version <- NULL
[09:31:13.989]                         }
[09:31:13.989]                         if (!has_future || version < "1.8.0") {
[09:31:13.989]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:13.989]                             "", base::R.version$version.string), 
[09:31:13.989]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:13.989]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:13.989]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:13.989]                               "release", "version")], collapse = " "), 
[09:31:13.989]                             hostname = base::Sys.info()[["nodename"]])
[09:31:13.989]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:13.989]                             info)
[09:31:13.989]                           info <- base::paste(info, collapse = "; ")
[09:31:13.989]                           if (!has_future) {
[09:31:13.989]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:13.989]                               info)
[09:31:13.989]                           }
[09:31:13.989]                           else {
[09:31:13.989]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:13.989]                               info, version)
[09:31:13.989]                           }
[09:31:13.989]                           base::stop(msg)
[09:31:13.989]                         }
[09:31:13.989]                       })
[09:31:13.989]                     }
[09:31:13.989]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:13.989]                     base::options(mc.cores = 1L)
[09:31:13.989]                   }
[09:31:13.989]                   ...future.strategy.old <- future::plan("list")
[09:31:13.989]                   options(future.plan = NULL)
[09:31:13.989]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.989]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:13.989]                 }
[09:31:13.989]                 ...future.workdir <- getwd()
[09:31:13.989]             }
[09:31:13.989]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:13.989]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:13.989]         }
[09:31:13.989]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:13.989]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:13.989]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:13.989]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:13.989]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:13.989]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:13.989]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:13.989]             base::names(...future.oldOptions))
[09:31:13.989]     }
[09:31:13.989]     if (FALSE) {
[09:31:13.989]     }
[09:31:13.989]     else {
[09:31:13.989]         if (TRUE) {
[09:31:13.989]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:13.989]                 open = "w")
[09:31:13.989]         }
[09:31:13.989]         else {
[09:31:13.989]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:13.989]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:13.989]         }
[09:31:13.989]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:13.989]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:13.989]             base::sink(type = "output", split = FALSE)
[09:31:13.989]             base::close(...future.stdout)
[09:31:13.989]         }, add = TRUE)
[09:31:13.989]     }
[09:31:13.989]     ...future.frame <- base::sys.nframe()
[09:31:13.989]     ...future.conditions <- base::list()
[09:31:13.989]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:13.989]     if (FALSE) {
[09:31:13.989]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:13.989]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:13.989]     }
[09:31:13.989]     ...future.result <- base::tryCatch({
[09:31:13.989]         base::withCallingHandlers({
[09:31:13.989]             ...future.value <- base::withVisible(base::local({
[09:31:13.989]                 withCallingHandlers({
[09:31:13.989]                   NULL
[09:31:13.989]                 }, immediateCondition = function(cond) {
[09:31:13.989]                   save_rds <- function (object, pathname, ...) 
[09:31:13.989]                   {
[09:31:13.989]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:13.989]                     if (file_test("-f", pathname_tmp)) {
[09:31:13.989]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.989]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:13.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.989]                         fi_tmp[["mtime"]])
[09:31:13.989]                     }
[09:31:13.989]                     tryCatch({
[09:31:13.989]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:13.989]                     }, error = function(ex) {
[09:31:13.989]                       msg <- conditionMessage(ex)
[09:31:13.989]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.989]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:13.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.989]                         fi_tmp[["mtime"]], msg)
[09:31:13.989]                       ex$message <- msg
[09:31:13.989]                       stop(ex)
[09:31:13.989]                     })
[09:31:13.989]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:13.989]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:13.989]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:13.989]                       fi_tmp <- file.info(pathname_tmp)
[09:31:13.989]                       fi <- file.info(pathname)
[09:31:13.989]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:13.989]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:13.989]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:13.989]                         fi[["size"]], fi[["mtime"]])
[09:31:13.989]                       stop(msg)
[09:31:13.989]                     }
[09:31:13.989]                     invisible(pathname)
[09:31:13.989]                   }
[09:31:13.989]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:13.989]                     rootPath = tempdir()) 
[09:31:13.989]                   {
[09:31:13.989]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:13.989]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:13.989]                       tmpdir = path, fileext = ".rds")
[09:31:13.989]                     save_rds(obj, file)
[09:31:13.989]                   }
[09:31:13.989]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:13.989]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.989]                   {
[09:31:13.989]                     inherits <- base::inherits
[09:31:13.989]                     invokeRestart <- base::invokeRestart
[09:31:13.989]                     is.null <- base::is.null
[09:31:13.989]                     muffled <- FALSE
[09:31:13.989]                     if (inherits(cond, "message")) {
[09:31:13.989]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:13.989]                       if (muffled) 
[09:31:13.989]                         invokeRestart("muffleMessage")
[09:31:13.989]                     }
[09:31:13.989]                     else if (inherits(cond, "warning")) {
[09:31:13.989]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:13.989]                       if (muffled) 
[09:31:13.989]                         invokeRestart("muffleWarning")
[09:31:13.989]                     }
[09:31:13.989]                     else if (inherits(cond, "condition")) {
[09:31:13.989]                       if (!is.null(pattern)) {
[09:31:13.989]                         computeRestarts <- base::computeRestarts
[09:31:13.989]                         grepl <- base::grepl
[09:31:13.989]                         restarts <- computeRestarts(cond)
[09:31:13.989]                         for (restart in restarts) {
[09:31:13.989]                           name <- restart$name
[09:31:13.989]                           if (is.null(name)) 
[09:31:13.989]                             next
[09:31:13.989]                           if (!grepl(pattern, name)) 
[09:31:13.989]                             next
[09:31:13.989]                           invokeRestart(restart)
[09:31:13.989]                           muffled <- TRUE
[09:31:13.989]                           break
[09:31:13.989]                         }
[09:31:13.989]                       }
[09:31:13.989]                     }
[09:31:13.989]                     invisible(muffled)
[09:31:13.989]                   }
[09:31:13.989]                   muffleCondition(cond)
[09:31:13.989]                 })
[09:31:13.989]             }))
[09:31:13.989]             future::FutureResult(value = ...future.value$value, 
[09:31:13.989]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.989]                   ...future.rng), globalenv = if (FALSE) 
[09:31:13.989]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:13.989]                     ...future.globalenv.names))
[09:31:13.989]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:13.989]         }, condition = base::local({
[09:31:13.989]             c <- base::c
[09:31:13.989]             inherits <- base::inherits
[09:31:13.989]             invokeRestart <- base::invokeRestart
[09:31:13.989]             length <- base::length
[09:31:13.989]             list <- base::list
[09:31:13.989]             seq.int <- base::seq.int
[09:31:13.989]             signalCondition <- base::signalCondition
[09:31:13.989]             sys.calls <- base::sys.calls
[09:31:13.989]             `[[` <- base::`[[`
[09:31:13.989]             `+` <- base::`+`
[09:31:13.989]             `<<-` <- base::`<<-`
[09:31:13.989]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:13.989]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:13.989]                   3L)]
[09:31:13.989]             }
[09:31:13.989]             function(cond) {
[09:31:13.989]                 is_error <- inherits(cond, "error")
[09:31:13.989]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:13.989]                   NULL)
[09:31:13.989]                 if (is_error) {
[09:31:13.989]                   sessionInformation <- function() {
[09:31:13.989]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:13.989]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:13.989]                       search = base::search(), system = base::Sys.info())
[09:31:13.989]                   }
[09:31:13.989]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.989]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:13.989]                     cond$call), session = sessionInformation(), 
[09:31:13.989]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:13.989]                   signalCondition(cond)
[09:31:13.989]                 }
[09:31:13.989]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:13.989]                 "immediateCondition"))) {
[09:31:13.989]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:13.989]                   ...future.conditions[[length(...future.conditions) + 
[09:31:13.989]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:13.989]                   if (TRUE && !signal) {
[09:31:13.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.989]                     {
[09:31:13.989]                       inherits <- base::inherits
[09:31:13.989]                       invokeRestart <- base::invokeRestart
[09:31:13.989]                       is.null <- base::is.null
[09:31:13.989]                       muffled <- FALSE
[09:31:13.989]                       if (inherits(cond, "message")) {
[09:31:13.989]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.989]                         if (muffled) 
[09:31:13.989]                           invokeRestart("muffleMessage")
[09:31:13.989]                       }
[09:31:13.989]                       else if (inherits(cond, "warning")) {
[09:31:13.989]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.989]                         if (muffled) 
[09:31:13.989]                           invokeRestart("muffleWarning")
[09:31:13.989]                       }
[09:31:13.989]                       else if (inherits(cond, "condition")) {
[09:31:13.989]                         if (!is.null(pattern)) {
[09:31:13.989]                           computeRestarts <- base::computeRestarts
[09:31:13.989]                           grepl <- base::grepl
[09:31:13.989]                           restarts <- computeRestarts(cond)
[09:31:13.989]                           for (restart in restarts) {
[09:31:13.989]                             name <- restart$name
[09:31:13.989]                             if (is.null(name)) 
[09:31:13.989]                               next
[09:31:13.989]                             if (!grepl(pattern, name)) 
[09:31:13.989]                               next
[09:31:13.989]                             invokeRestart(restart)
[09:31:13.989]                             muffled <- TRUE
[09:31:13.989]                             break
[09:31:13.989]                           }
[09:31:13.989]                         }
[09:31:13.989]                       }
[09:31:13.989]                       invisible(muffled)
[09:31:13.989]                     }
[09:31:13.989]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.989]                   }
[09:31:13.989]                 }
[09:31:13.989]                 else {
[09:31:13.989]                   if (TRUE) {
[09:31:13.989]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:13.989]                     {
[09:31:13.989]                       inherits <- base::inherits
[09:31:13.989]                       invokeRestart <- base::invokeRestart
[09:31:13.989]                       is.null <- base::is.null
[09:31:13.989]                       muffled <- FALSE
[09:31:13.989]                       if (inherits(cond, "message")) {
[09:31:13.989]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:13.989]                         if (muffled) 
[09:31:13.989]                           invokeRestart("muffleMessage")
[09:31:13.989]                       }
[09:31:13.989]                       else if (inherits(cond, "warning")) {
[09:31:13.989]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:13.989]                         if (muffled) 
[09:31:13.989]                           invokeRestart("muffleWarning")
[09:31:13.989]                       }
[09:31:13.989]                       else if (inherits(cond, "condition")) {
[09:31:13.989]                         if (!is.null(pattern)) {
[09:31:13.989]                           computeRestarts <- base::computeRestarts
[09:31:13.989]                           grepl <- base::grepl
[09:31:13.989]                           restarts <- computeRestarts(cond)
[09:31:13.989]                           for (restart in restarts) {
[09:31:13.989]                             name <- restart$name
[09:31:13.989]                             if (is.null(name)) 
[09:31:13.989]                               next
[09:31:13.989]                             if (!grepl(pattern, name)) 
[09:31:13.989]                               next
[09:31:13.989]                             invokeRestart(restart)
[09:31:13.989]                             muffled <- TRUE
[09:31:13.989]                             break
[09:31:13.989]                           }
[09:31:13.989]                         }
[09:31:13.989]                       }
[09:31:13.989]                       invisible(muffled)
[09:31:13.989]                     }
[09:31:13.989]                     muffleCondition(cond, pattern = "^muffle")
[09:31:13.989]                   }
[09:31:13.989]                 }
[09:31:13.989]             }
[09:31:13.989]         }))
[09:31:13.989]     }, error = function(ex) {
[09:31:13.989]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:13.989]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:13.989]                 ...future.rng), started = ...future.startTime, 
[09:31:13.989]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:13.989]             version = "1.8"), class = "FutureResult")
[09:31:13.989]     }, finally = {
[09:31:13.989]         if (!identical(...future.workdir, getwd())) 
[09:31:13.989]             setwd(...future.workdir)
[09:31:13.989]         {
[09:31:13.989]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:13.989]                 ...future.oldOptions$nwarnings <- NULL
[09:31:13.989]             }
[09:31:13.989]             base::options(...future.oldOptions)
[09:31:13.989]             if (.Platform$OS.type == "windows") {
[09:31:13.989]                 old_names <- names(...future.oldEnvVars)
[09:31:13.989]                 envs <- base::Sys.getenv()
[09:31:13.989]                 names <- names(envs)
[09:31:13.989]                 common <- intersect(names, old_names)
[09:31:13.989]                 added <- setdiff(names, old_names)
[09:31:13.989]                 removed <- setdiff(old_names, names)
[09:31:13.989]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:13.989]                   envs[common]]
[09:31:13.989]                 NAMES <- toupper(changed)
[09:31:13.989]                 args <- list()
[09:31:13.989]                 for (kk in seq_along(NAMES)) {
[09:31:13.989]                   name <- changed[[kk]]
[09:31:13.989]                   NAME <- NAMES[[kk]]
[09:31:13.989]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.989]                     next
[09:31:13.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.989]                 }
[09:31:13.989]                 NAMES <- toupper(added)
[09:31:13.989]                 for (kk in seq_along(NAMES)) {
[09:31:13.989]                   name <- added[[kk]]
[09:31:13.989]                   NAME <- NAMES[[kk]]
[09:31:13.989]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.989]                     next
[09:31:13.989]                   args[[name]] <- ""
[09:31:13.989]                 }
[09:31:13.989]                 NAMES <- toupper(removed)
[09:31:13.989]                 for (kk in seq_along(NAMES)) {
[09:31:13.989]                   name <- removed[[kk]]
[09:31:13.989]                   NAME <- NAMES[[kk]]
[09:31:13.989]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:13.989]                     next
[09:31:13.989]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:13.989]                 }
[09:31:13.989]                 if (length(args) > 0) 
[09:31:13.989]                   base::do.call(base::Sys.setenv, args = args)
[09:31:13.989]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:13.989]             }
[09:31:13.989]             else {
[09:31:13.989]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:13.989]             }
[09:31:13.989]             {
[09:31:13.989]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:13.989]                   0L) {
[09:31:13.989]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:13.989]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:13.989]                   base::options(opts)
[09:31:13.989]                 }
[09:31:13.989]                 {
[09:31:13.989]                   {
[09:31:13.989]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:13.989]                     NULL
[09:31:13.989]                   }
[09:31:13.989]                   options(future.plan = NULL)
[09:31:13.989]                   if (is.na(NA_character_)) 
[09:31:13.989]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:13.989]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:13.989]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:13.989]                     .init = FALSE)
[09:31:13.989]                 }
[09:31:13.989]             }
[09:31:13.989]         }
[09:31:13.989]     })
[09:31:13.989]     if (TRUE) {
[09:31:13.989]         base::sink(type = "output", split = FALSE)
[09:31:13.989]         if (TRUE) {
[09:31:13.989]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:13.989]         }
[09:31:13.989]         else {
[09:31:13.989]             ...future.result["stdout"] <- base::list(NULL)
[09:31:13.989]         }
[09:31:13.989]         base::close(...future.stdout)
[09:31:13.989]         ...future.stdout <- NULL
[09:31:13.989]     }
[09:31:13.989]     ...future.result$conditions <- ...future.conditions
[09:31:13.989]     ...future.result$finished <- base::Sys.time()
[09:31:13.989]     ...future.result
[09:31:13.989] }
[09:31:13.992] requestCore(): workers = 2
[09:31:13.994] MulticoreFuture started
[09:31:13.995] - Launch lazy future ... done
[09:31:13.995] run() for ‘MulticoreFuture’ ... done
[09:31:13.996] plan(): Setting new future strategy stack:
[09:31:13.996] getGlobalsAndPackages() ...
[09:31:13.996] Searching for globals...
[09:31:13.996] List of future strategies:
[09:31:13.996] 1. sequential:
[09:31:13.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:13.996]    - tweaked: FALSE
[09:31:13.996]    - call: NULL
[09:31:13.997] plan(): nbrOfWorkers() = 1
[09:31:13.997] - globals found: [1] ‘{’
[09:31:13.998] Searching for globals ... DONE
[09:31:13.998] Resolving globals: FALSE
[09:31:13.998] 
[09:31:13.999] 
[09:31:13.999] getGlobalsAndPackages() ... DONE
[09:31:13.999] plan(): Setting new future strategy stack:
[09:31:13.999] run() for ‘Future’ ...
[09:31:13.999] - state: ‘created’
[09:31:14.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:13.999] List of future strategies:
[09:31:13.999] 1. multicore:
[09:31:13.999]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:13.999]    - tweaked: FALSE
[09:31:13.999]    - call: plan(strategy)
[09:31:14.004] plan(): nbrOfWorkers() = 2
[09:31:14.004] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:14.005]   - Field: ‘label’
[09:31:14.005]   - Field: ‘local’
[09:31:14.005]   - Field: ‘owner’
[09:31:14.005]   - Field: ‘envir’
[09:31:14.005]   - Field: ‘workers’
[09:31:14.005]   - Field: ‘packages’
[09:31:14.006]   - Field: ‘gc’
[09:31:14.006]   - Field: ‘job’
[09:31:14.006]   - Field: ‘conditions’
[09:31:14.006]   - Field: ‘expr’
[09:31:14.006]   - Field: ‘uuid’
[09:31:14.006]   - Field: ‘seed’
[09:31:14.006]   - Field: ‘version’
[09:31:14.007]   - Field: ‘result’
[09:31:14.007]   - Field: ‘asynchronous’
[09:31:14.007]   - Field: ‘calls’
[09:31:14.007]   - Field: ‘globals’
[09:31:14.007]   - Field: ‘stdout’
[09:31:14.007]   - Field: ‘earlySignal’
[09:31:14.007]   - Field: ‘lazy’
[09:31:14.008]   - Field: ‘state’
[09:31:14.008] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:14.008] - Launch lazy future ...
[09:31:14.008] Packages needed by the future expression (n = 0): <none>
[09:31:14.009] Packages needed by future strategies (n = 0): <none>
[09:31:14.009] {
[09:31:14.009]     {
[09:31:14.009]         {
[09:31:14.009]             ...future.startTime <- base::Sys.time()
[09:31:14.009]             {
[09:31:14.009]                 {
[09:31:14.009]                   {
[09:31:14.009]                     {
[09:31:14.009]                       base::local({
[09:31:14.009]                         has_future <- base::requireNamespace("future", 
[09:31:14.009]                           quietly = TRUE)
[09:31:14.009]                         if (has_future) {
[09:31:14.009]                           ns <- base::getNamespace("future")
[09:31:14.009]                           version <- ns[[".package"]][["version"]]
[09:31:14.009]                           if (is.null(version)) 
[09:31:14.009]                             version <- utils::packageVersion("future")
[09:31:14.009]                         }
[09:31:14.009]                         else {
[09:31:14.009]                           version <- NULL
[09:31:14.009]                         }
[09:31:14.009]                         if (!has_future || version < "1.8.0") {
[09:31:14.009]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.009]                             "", base::R.version$version.string), 
[09:31:14.009]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.009]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.009]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.009]                               "release", "version")], collapse = " "), 
[09:31:14.009]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.009]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.009]                             info)
[09:31:14.009]                           info <- base::paste(info, collapse = "; ")
[09:31:14.009]                           if (!has_future) {
[09:31:14.009]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.009]                               info)
[09:31:14.009]                           }
[09:31:14.009]                           else {
[09:31:14.009]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.009]                               info, version)
[09:31:14.009]                           }
[09:31:14.009]                           base::stop(msg)
[09:31:14.009]                         }
[09:31:14.009]                       })
[09:31:14.009]                     }
[09:31:14.009]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.009]                     base::options(mc.cores = 1L)
[09:31:14.009]                   }
[09:31:14.009]                   ...future.strategy.old <- future::plan("list")
[09:31:14.009]                   options(future.plan = NULL)
[09:31:14.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.009]                 }
[09:31:14.009]                 ...future.workdir <- getwd()
[09:31:14.009]             }
[09:31:14.009]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.009]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.009]         }
[09:31:14.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.009]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.009]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.009]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.009]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.009]             base::names(...future.oldOptions))
[09:31:14.009]     }
[09:31:14.009]     if (FALSE) {
[09:31:14.009]     }
[09:31:14.009]     else {
[09:31:14.009]         if (TRUE) {
[09:31:14.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.009]                 open = "w")
[09:31:14.009]         }
[09:31:14.009]         else {
[09:31:14.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.009]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.009]         }
[09:31:14.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.009]             base::sink(type = "output", split = FALSE)
[09:31:14.009]             base::close(...future.stdout)
[09:31:14.009]         }, add = TRUE)
[09:31:14.009]     }
[09:31:14.009]     ...future.frame <- base::sys.nframe()
[09:31:14.009]     ...future.conditions <- base::list()
[09:31:14.009]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.009]     if (FALSE) {
[09:31:14.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.009]     }
[09:31:14.009]     ...future.result <- base::tryCatch({
[09:31:14.009]         base::withCallingHandlers({
[09:31:14.009]             ...future.value <- base::withVisible(base::local({
[09:31:14.009]                 withCallingHandlers({
[09:31:14.009]                   {
[09:31:14.009]                     4
[09:31:14.009]                   }
[09:31:14.009]                 }, immediateCondition = function(cond) {
[09:31:14.009]                   save_rds <- function (object, pathname, ...) 
[09:31:14.009]                   {
[09:31:14.009]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:14.009]                     if (file_test("-f", pathname_tmp)) {
[09:31:14.009]                       fi_tmp <- file.info(pathname_tmp)
[09:31:14.009]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:14.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:14.009]                         fi_tmp[["mtime"]])
[09:31:14.009]                     }
[09:31:14.009]                     tryCatch({
[09:31:14.009]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:14.009]                     }, error = function(ex) {
[09:31:14.009]                       msg <- conditionMessage(ex)
[09:31:14.009]                       fi_tmp <- file.info(pathname_tmp)
[09:31:14.009]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:14.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:14.009]                         fi_tmp[["mtime"]], msg)
[09:31:14.009]                       ex$message <- msg
[09:31:14.009]                       stop(ex)
[09:31:14.009]                     })
[09:31:14.009]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:14.009]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:14.009]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:14.009]                       fi_tmp <- file.info(pathname_tmp)
[09:31:14.009]                       fi <- file.info(pathname)
[09:31:14.009]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:14.009]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:14.009]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:14.009]                         fi[["size"]], fi[["mtime"]])
[09:31:14.009]                       stop(msg)
[09:31:14.009]                     }
[09:31:14.009]                     invisible(pathname)
[09:31:14.009]                   }
[09:31:14.009]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:14.009]                     rootPath = tempdir()) 
[09:31:14.009]                   {
[09:31:14.009]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:14.009]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:14.009]                       tmpdir = path, fileext = ".rds")
[09:31:14.009]                     save_rds(obj, file)
[09:31:14.009]                   }
[09:31:14.009]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:14.009]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.009]                   {
[09:31:14.009]                     inherits <- base::inherits
[09:31:14.009]                     invokeRestart <- base::invokeRestart
[09:31:14.009]                     is.null <- base::is.null
[09:31:14.009]                     muffled <- FALSE
[09:31:14.009]                     if (inherits(cond, "message")) {
[09:31:14.009]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.009]                       if (muffled) 
[09:31:14.009]                         invokeRestart("muffleMessage")
[09:31:14.009]                     }
[09:31:14.009]                     else if (inherits(cond, "warning")) {
[09:31:14.009]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.009]                       if (muffled) 
[09:31:14.009]                         invokeRestart("muffleWarning")
[09:31:14.009]                     }
[09:31:14.009]                     else if (inherits(cond, "condition")) {
[09:31:14.009]                       if (!is.null(pattern)) {
[09:31:14.009]                         computeRestarts <- base::computeRestarts
[09:31:14.009]                         grepl <- base::grepl
[09:31:14.009]                         restarts <- computeRestarts(cond)
[09:31:14.009]                         for (restart in restarts) {
[09:31:14.009]                           name <- restart$name
[09:31:14.009]                           if (is.null(name)) 
[09:31:14.009]                             next
[09:31:14.009]                           if (!grepl(pattern, name)) 
[09:31:14.009]                             next
[09:31:14.009]                           invokeRestart(restart)
[09:31:14.009]                           muffled <- TRUE
[09:31:14.009]                           break
[09:31:14.009]                         }
[09:31:14.009]                       }
[09:31:14.009]                     }
[09:31:14.009]                     invisible(muffled)
[09:31:14.009]                   }
[09:31:14.009]                   muffleCondition(cond)
[09:31:14.009]                 })
[09:31:14.009]             }))
[09:31:14.009]             future::FutureResult(value = ...future.value$value, 
[09:31:14.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.009]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.009]                     ...future.globalenv.names))
[09:31:14.009]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.009]         }, condition = base::local({
[09:31:14.009]             c <- base::c
[09:31:14.009]             inherits <- base::inherits
[09:31:14.009]             invokeRestart <- base::invokeRestart
[09:31:14.009]             length <- base::length
[09:31:14.009]             list <- base::list
[09:31:14.009]             seq.int <- base::seq.int
[09:31:14.009]             signalCondition <- base::signalCondition
[09:31:14.009]             sys.calls <- base::sys.calls
[09:31:14.009]             `[[` <- base::`[[`
[09:31:14.009]             `+` <- base::`+`
[09:31:14.009]             `<<-` <- base::`<<-`
[09:31:14.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.009]                   3L)]
[09:31:14.009]             }
[09:31:14.009]             function(cond) {
[09:31:14.009]                 is_error <- inherits(cond, "error")
[09:31:14.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.009]                   NULL)
[09:31:14.009]                 if (is_error) {
[09:31:14.009]                   sessionInformation <- function() {
[09:31:14.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.009]                       search = base::search(), system = base::Sys.info())
[09:31:14.009]                   }
[09:31:14.009]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.009]                     cond$call), session = sessionInformation(), 
[09:31:14.009]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.009]                   signalCondition(cond)
[09:31:14.009]                 }
[09:31:14.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.009]                 "immediateCondition"))) {
[09:31:14.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.009]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.009]                   if (TRUE && !signal) {
[09:31:14.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.009]                     {
[09:31:14.009]                       inherits <- base::inherits
[09:31:14.009]                       invokeRestart <- base::invokeRestart
[09:31:14.009]                       is.null <- base::is.null
[09:31:14.009]                       muffled <- FALSE
[09:31:14.009]                       if (inherits(cond, "message")) {
[09:31:14.009]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.009]                         if (muffled) 
[09:31:14.009]                           invokeRestart("muffleMessage")
[09:31:14.009]                       }
[09:31:14.009]                       else if (inherits(cond, "warning")) {
[09:31:14.009]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.009]                         if (muffled) 
[09:31:14.009]                           invokeRestart("muffleWarning")
[09:31:14.009]                       }
[09:31:14.009]                       else if (inherits(cond, "condition")) {
[09:31:14.009]                         if (!is.null(pattern)) {
[09:31:14.009]                           computeRestarts <- base::computeRestarts
[09:31:14.009]                           grepl <- base::grepl
[09:31:14.009]                           restarts <- computeRestarts(cond)
[09:31:14.009]                           for (restart in restarts) {
[09:31:14.009]                             name <- restart$name
[09:31:14.009]                             if (is.null(name)) 
[09:31:14.009]                               next
[09:31:14.009]                             if (!grepl(pattern, name)) 
[09:31:14.009]                               next
[09:31:14.009]                             invokeRestart(restart)
[09:31:14.009]                             muffled <- TRUE
[09:31:14.009]                             break
[09:31:14.009]                           }
[09:31:14.009]                         }
[09:31:14.009]                       }
[09:31:14.009]                       invisible(muffled)
[09:31:14.009]                     }
[09:31:14.009]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.009]                   }
[09:31:14.009]                 }
[09:31:14.009]                 else {
[09:31:14.009]                   if (TRUE) {
[09:31:14.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.009]                     {
[09:31:14.009]                       inherits <- base::inherits
[09:31:14.009]                       invokeRestart <- base::invokeRestart
[09:31:14.009]                       is.null <- base::is.null
[09:31:14.009]                       muffled <- FALSE
[09:31:14.009]                       if (inherits(cond, "message")) {
[09:31:14.009]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.009]                         if (muffled) 
[09:31:14.009]                           invokeRestart("muffleMessage")
[09:31:14.009]                       }
[09:31:14.009]                       else if (inherits(cond, "warning")) {
[09:31:14.009]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.009]                         if (muffled) 
[09:31:14.009]                           invokeRestart("muffleWarning")
[09:31:14.009]                       }
[09:31:14.009]                       else if (inherits(cond, "condition")) {
[09:31:14.009]                         if (!is.null(pattern)) {
[09:31:14.009]                           computeRestarts <- base::computeRestarts
[09:31:14.009]                           grepl <- base::grepl
[09:31:14.009]                           restarts <- computeRestarts(cond)
[09:31:14.009]                           for (restart in restarts) {
[09:31:14.009]                             name <- restart$name
[09:31:14.009]                             if (is.null(name)) 
[09:31:14.009]                               next
[09:31:14.009]                             if (!grepl(pattern, name)) 
[09:31:14.009]                               next
[09:31:14.009]                             invokeRestart(restart)
[09:31:14.009]                             muffled <- TRUE
[09:31:14.009]                             break
[09:31:14.009]                           }
[09:31:14.009]                         }
[09:31:14.009]                       }
[09:31:14.009]                       invisible(muffled)
[09:31:14.009]                     }
[09:31:14.009]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.009]                   }
[09:31:14.009]                 }
[09:31:14.009]             }
[09:31:14.009]         }))
[09:31:14.009]     }, error = function(ex) {
[09:31:14.009]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.009]                 ...future.rng), started = ...future.startTime, 
[09:31:14.009]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.009]             version = "1.8"), class = "FutureResult")
[09:31:14.009]     }, finally = {
[09:31:14.009]         if (!identical(...future.workdir, getwd())) 
[09:31:14.009]             setwd(...future.workdir)
[09:31:14.009]         {
[09:31:14.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.009]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.009]             }
[09:31:14.009]             base::options(...future.oldOptions)
[09:31:14.009]             if (.Platform$OS.type == "windows") {
[09:31:14.009]                 old_names <- names(...future.oldEnvVars)
[09:31:14.009]                 envs <- base::Sys.getenv()
[09:31:14.009]                 names <- names(envs)
[09:31:14.009]                 common <- intersect(names, old_names)
[09:31:14.009]                 added <- setdiff(names, old_names)
[09:31:14.009]                 removed <- setdiff(old_names, names)
[09:31:14.009]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.009]                   envs[common]]
[09:31:14.009]                 NAMES <- toupper(changed)
[09:31:14.009]                 args <- list()
[09:31:14.009]                 for (kk in seq_along(NAMES)) {
[09:31:14.009]                   name <- changed[[kk]]
[09:31:14.009]                   NAME <- NAMES[[kk]]
[09:31:14.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.009]                     next
[09:31:14.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.009]                 }
[09:31:14.009]                 NAMES <- toupper(added)
[09:31:14.009]                 for (kk in seq_along(NAMES)) {
[09:31:14.009]                   name <- added[[kk]]
[09:31:14.009]                   NAME <- NAMES[[kk]]
[09:31:14.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.009]                     next
[09:31:14.009]                   args[[name]] <- ""
[09:31:14.009]                 }
[09:31:14.009]                 NAMES <- toupper(removed)
[09:31:14.009]                 for (kk in seq_along(NAMES)) {
[09:31:14.009]                   name <- removed[[kk]]
[09:31:14.009]                   NAME <- NAMES[[kk]]
[09:31:14.009]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.009]                     next
[09:31:14.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.009]                 }
[09:31:14.009]                 if (length(args) > 0) 
[09:31:14.009]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.009]             }
[09:31:14.009]             else {
[09:31:14.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.009]             }
[09:31:14.009]             {
[09:31:14.009]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.009]                   0L) {
[09:31:14.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.009]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.009]                   base::options(opts)
[09:31:14.009]                 }
[09:31:14.009]                 {
[09:31:14.009]                   {
[09:31:14.009]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.009]                     NULL
[09:31:14.009]                   }
[09:31:14.009]                   options(future.plan = NULL)
[09:31:14.009]                   if (is.na(NA_character_)) 
[09:31:14.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.009]                     .init = FALSE)
[09:31:14.009]                 }
[09:31:14.009]             }
[09:31:14.009]         }
[09:31:14.009]     })
[09:31:14.009]     if (TRUE) {
[09:31:14.009]         base::sink(type = "output", split = FALSE)
[09:31:14.009]         if (TRUE) {
[09:31:14.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.009]         }
[09:31:14.009]         else {
[09:31:14.009]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.009]         }
[09:31:14.009]         base::close(...future.stdout)
[09:31:14.009]         ...future.stdout <- NULL
[09:31:14.009]     }
[09:31:14.009]     ...future.result$conditions <- ...future.conditions
[09:31:14.009]     ...future.result$finished <- base::Sys.time()
[09:31:14.009]     ...future.result
[09:31:14.009] }
[09:31:14.013] requestCore(): workers = 2
[09:31:14.013] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:14.024] result() for MulticoreFuture ...
[09:31:14.025] result() for MulticoreFuture ...
[09:31:14.025] result() for MulticoreFuture ... done
[09:31:14.025] result() for MulticoreFuture ... done
[09:31:14.025] result() for MulticoreFuture ...
[09:31:14.025] result() for MulticoreFuture ... done
[09:31:14.028] MulticoreFuture started
[09:31:14.028] - Launch lazy future ... done
[09:31:14.029] run() for ‘MulticoreFuture’ ... done
[09:31:14.029] plan(): Setting new future strategy stack:
<environment: 0x55a3ccf5cb78> 
[09:31:14.030] List of future strategies:
[09:31:14.030] 1. sequential:
[09:31:14.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:14.030]    - tweaked: FALSE
[09:31:14.030]    - call: NULL
[09:31:14.031] plan(): nbrOfWorkers() = 1
<environment: 0x55a3c97a0cf0> 
[09:31:14.034] plan(): Setting new future strategy stack:
[09:31:14.034] List of future strategies:
[09:31:14.034] 1. multicore:
[09:31:14.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:14.034]    - tweaked: FALSE
[09:31:14.034]    - call: plan(strategy)
[09:31:14.040] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.042] resolve() on environment ...
[09:31:14.042]  recursive: 0
[09:31:14.043]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.044] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.044] - nx: 4
[09:31:14.044] - relay: TRUE
[09:31:14.044] - stdout: TRUE
[09:31:14.044] - signal: TRUE
[09:31:14.044] - resignal: FALSE
[09:31:14.044] - force: TRUE
[09:31:14.045] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.045] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.045]  - until=2
[09:31:14.045]  - relaying element #2
[09:31:14.045] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.045] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.046] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.046]  length: 3 (resolved future 1)
[09:31:14.046] Future #2
[09:31:14.046] result() for MulticoreFuture ...
[09:31:14.046] result() for MulticoreFuture ... done
[09:31:14.046] result() for MulticoreFuture ...
[09:31:14.047] result() for MulticoreFuture ... done
[09:31:14.047] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:14.047] - nx: 4
[09:31:14.047] - relay: TRUE
[09:31:14.047] - stdout: TRUE
[09:31:14.047] - signal: TRUE
[09:31:14.047] - resignal: FALSE
[09:31:14.047] - force: TRUE
[09:31:14.048] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.048] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.048]  - until=2
[09:31:14.048]  - relaying element #2
[09:31:14.048] result() for MulticoreFuture ...
[09:31:14.048] result() for MulticoreFuture ... done
[09:31:14.048] result() for MulticoreFuture ...
[09:31:14.049] result() for MulticoreFuture ... done
[09:31:14.049] result() for MulticoreFuture ...
[09:31:14.049] result() for MulticoreFuture ... done
[09:31:14.049] result() for MulticoreFuture ...
[09:31:14.049] result() for MulticoreFuture ... done
[09:31:14.049] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.049] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.050] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:14.050]  length: 2 (resolved future 2)
[09:31:14.050] Future #3
[09:31:14.050] result() for MulticoreFuture ...
[09:31:14.051] result() for MulticoreFuture ...
[09:31:14.051] result() for MulticoreFuture ... done
[09:31:14.051] result() for MulticoreFuture ... done
[09:31:14.051] result() for MulticoreFuture ...
[09:31:14.052] result() for MulticoreFuture ... done
[09:31:14.052] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:14.052] - nx: 4
[09:31:14.052] - relay: TRUE
[09:31:14.052] - stdout: TRUE
[09:31:14.052] - signal: TRUE
[09:31:14.052] - resignal: FALSE
[09:31:14.053] - force: TRUE
[09:31:14.053] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.053] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.053]  - until=3
[09:31:14.053]  - relaying element #3
[09:31:14.053] result() for MulticoreFuture ...
[09:31:14.053] result() for MulticoreFuture ... done
[09:31:14.054] result() for MulticoreFuture ...
[09:31:14.054] result() for MulticoreFuture ... done
[09:31:14.054] result() for MulticoreFuture ...
[09:31:14.054] result() for MulticoreFuture ... done
[09:31:14.055] result() for MulticoreFuture ...
[09:31:14.055] result() for MulticoreFuture ... done
[09:31:14.055] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.055] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.055] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:14.055]  length: 1 (resolved future 3)
[09:31:14.055] Future #4
[09:31:14.056] result() for MulticoreFuture ...
[09:31:14.056] result() for MulticoreFuture ...
[09:31:14.057] result() for MulticoreFuture ... done
[09:31:14.057] result() for MulticoreFuture ... done
[09:31:14.057] result() for MulticoreFuture ...
[09:31:14.057] result() for MulticoreFuture ... done
[09:31:14.057] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:14.057] - nx: 4
[09:31:14.058] - relay: TRUE
[09:31:14.058] - stdout: TRUE
[09:31:14.058] - signal: TRUE
[09:31:14.058] - resignal: FALSE
[09:31:14.058] - force: TRUE
[09:31:14.058] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.058] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.059]  - until=4
[09:31:14.059]  - relaying element #4
[09:31:14.059] result() for MulticoreFuture ...
[09:31:14.059] result() for MulticoreFuture ... done
[09:31:14.059] result() for MulticoreFuture ...
[09:31:14.059] result() for MulticoreFuture ... done
[09:31:14.060] result() for MulticoreFuture ...
[09:31:14.060] result() for MulticoreFuture ... done
[09:31:14.060] result() for MulticoreFuture ...
[09:31:14.060] result() for MulticoreFuture ... done
[09:31:14.060] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.060] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.060] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:14.060]  length: 0 (resolved future 4)
[09:31:14.061] Relaying remaining futures
[09:31:14.061] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.061] - nx: 4
[09:31:14.061] - relay: TRUE
[09:31:14.061] - stdout: TRUE
[09:31:14.061] - signal: TRUE
[09:31:14.061] - resignal: FALSE
[09:31:14.061] - force: TRUE
[09:31:14.061] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.061] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.062] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.062] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.062] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.062] resolve() on environment ... DONE
[09:31:14.062] result() for MulticoreFuture ...
[09:31:14.062] result() for MulticoreFuture ... done
[09:31:14.062] result() for MulticoreFuture ...
[09:31:14.062] result() for MulticoreFuture ... done
[09:31:14.062] result() for MulticoreFuture ...
[09:31:14.063] result() for MulticoreFuture ... done
[09:31:14.063] result() for MulticoreFuture ...
[09:31:14.063] result() for MulticoreFuture ... done
[09:31:14.063] result() for MulticoreFuture ...
[09:31:14.063] result() for MulticoreFuture ... done
[09:31:14.063] result() for MulticoreFuture ...
[09:31:14.063] result() for MulticoreFuture ... done
<environment: 0x55a3c9295ba8> 
Type of future: multisession
[09:31:14.064] plan(): Setting new future strategy stack:
[09:31:14.064] List of future strategies:
[09:31:14.064] 1. multisession:
[09:31:14.064]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:14.064]    - tweaked: FALSE
[09:31:14.064]    - call: plan(strategy)
[09:31:14.064] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:14.064] multisession:
[09:31:14.064] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:14.064] - tweaked: FALSE
[09:31:14.064] - call: plan(strategy)
[09:31:14.068] getGlobalsAndPackages() ...
[09:31:14.068] Not searching for globals
[09:31:14.069] - globals: [0] <none>
[09:31:14.069] getGlobalsAndPackages() ... DONE
[09:31:14.069] [local output] makeClusterPSOCK() ...
[09:31:14.073] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:14.073] [local output] Base port: 11719
[09:31:14.073] [local output] Getting setup options for 2 cluster nodes ...
[09:31:14.073] [local output]  - Node 1 of 2 ...
[09:31:14.074] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:14.074] [local output] Rscript port: 11719

[09:31:14.075] [local output]  - Node 2 of 2 ...
[09:31:14.075] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:14.076] [local output] Rscript port: 11719

[09:31:14.076] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:14.076] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:14.077] [local output] Setting up PSOCK nodes in parallel
[09:31:14.077] List of 36
[09:31:14.077]  $ worker          : chr "localhost"
[09:31:14.077]   ..- attr(*, "localhost")= logi TRUE
[09:31:14.077]  $ master          : chr "localhost"
[09:31:14.077]  $ port            : int 11719
[09:31:14.077]  $ connectTimeout  : num 120
[09:31:14.077]  $ timeout         : num 2592000
[09:31:14.077]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:14.077]  $ homogeneous     : logi TRUE
[09:31:14.077]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:14.077]  $ rscript_envs    : NULL
[09:31:14.077]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:14.077]  $ rscript_startup : NULL
[09:31:14.077]  $ rscript_sh      : chr "sh"
[09:31:14.077]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:14.077]  $ methods         : logi TRUE
[09:31:14.077]  $ socketOptions   : chr "no-delay"
[09:31:14.077]  $ useXDR          : logi FALSE
[09:31:14.077]  $ outfile         : chr "/dev/null"
[09:31:14.077]  $ renice          : int NA
[09:31:14.077]  $ rshcmd          : NULL
[09:31:14.077]  $ user            : chr(0) 
[09:31:14.077]  $ revtunnel       : logi FALSE
[09:31:14.077]  $ rshlogfile      : NULL
[09:31:14.077]  $ rshopts         : chr(0) 
[09:31:14.077]  $ rank            : int 1
[09:31:14.077]  $ manual          : logi FALSE
[09:31:14.077]  $ dryrun          : logi FALSE
[09:31:14.077]  $ quiet           : logi FALSE
[09:31:14.077]  $ setup_strategy  : chr "parallel"
[09:31:14.077]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:14.077]  $ pidfile         : chr "/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4737d4bf7cc.pid"
[09:31:14.077]  $ rshcmd_label    : NULL
[09:31:14.077]  $ rsh_call        : NULL
[09:31:14.077]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:14.077]  $ localMachine    : logi TRUE
[09:31:14.077]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:14.077]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:14.077]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:14.077]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:14.077]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:14.077]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:14.077]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:14.077]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:14.077]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:14.077]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:14.077]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:14.077]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:14.077]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:14.077]  $ arguments       :List of 28
[09:31:14.077]   ..$ worker          : chr "localhost"
[09:31:14.077]   ..$ master          : NULL
[09:31:14.077]   ..$ port            : int 11719
[09:31:14.077]   ..$ connectTimeout  : num 120
[09:31:14.077]   ..$ timeout         : num 2592000
[09:31:14.077]   ..$ rscript         : NULL
[09:31:14.077]   ..$ homogeneous     : NULL
[09:31:14.077]   ..$ rscript_args    : NULL
[09:31:14.077]   ..$ rscript_envs    : NULL
[09:31:14.077]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:14.077]   ..$ rscript_startup : NULL
[09:31:14.077]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:14.077]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:14.077]   ..$ methods         : logi TRUE
[09:31:14.077]   ..$ socketOptions   : chr "no-delay"
[09:31:14.077]   ..$ useXDR          : logi FALSE
[09:31:14.077]   ..$ outfile         : chr "/dev/null"
[09:31:14.077]   ..$ renice          : int NA
[09:31:14.077]   ..$ rshcmd          : NULL
[09:31:14.077]   ..$ user            : NULL
[09:31:14.077]   ..$ revtunnel       : logi NA
[09:31:14.077]   ..$ rshlogfile      : NULL
[09:31:14.077]   ..$ rshopts         : NULL
[09:31:14.077]   ..$ rank            : int 1
[09:31:14.077]   ..$ manual          : logi FALSE
[09:31:14.077]   ..$ dryrun          : logi FALSE
[09:31:14.077]   ..$ quiet           : logi FALSE
[09:31:14.077]   ..$ setup_strategy  : chr "parallel"
[09:31:14.077]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:14.096] [local output] System call to launch all workers:
[09:31:14.096] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a4737d4bf7cc.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11719 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:14.096] [local output] Starting PSOCK main server
[09:31:14.097] [local output] Workers launched
[09:31:14.097] [local output] Waiting for workers to connect back
[09:31:14.097]  - [local output] 0 workers out of 2 ready
[09:31:14.297]  - [local output] 0 workers out of 2 ready
[09:31:14.298]  - [local output] 1 workers out of 2 ready
[09:31:14.353]  - [local output] 1 workers out of 2 ready
[09:31:14.354]  - [local output] 2 workers out of 2 ready
[09:31:14.354] [local output] Launching of workers completed
[09:31:14.354] [local output] Collecting session information from workers
[09:31:14.355] [local output]  - Worker #1 of 2
[09:31:14.355] [local output]  - Worker #2 of 2
[09:31:14.355] [local output] makeClusterPSOCK() ... done
[09:31:14.367] Packages needed by the future expression (n = 0): <none>
[09:31:14.367] Packages needed by future strategies (n = 0): <none>
[09:31:14.370] {
[09:31:14.370]     {
[09:31:14.370]         {
[09:31:14.370]             ...future.startTime <- base::Sys.time()
[09:31:14.370]             {
[09:31:14.370]                 {
[09:31:14.370]                   {
[09:31:14.370]                     {
[09:31:14.370]                       base::local({
[09:31:14.370]                         has_future <- base::requireNamespace("future", 
[09:31:14.370]                           quietly = TRUE)
[09:31:14.370]                         if (has_future) {
[09:31:14.370]                           ns <- base::getNamespace("future")
[09:31:14.370]                           version <- ns[[".package"]][["version"]]
[09:31:14.370]                           if (is.null(version)) 
[09:31:14.370]                             version <- utils::packageVersion("future")
[09:31:14.370]                         }
[09:31:14.370]                         else {
[09:31:14.370]                           version <- NULL
[09:31:14.370]                         }
[09:31:14.370]                         if (!has_future || version < "1.8.0") {
[09:31:14.370]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.370]                             "", base::R.version$version.string), 
[09:31:14.370]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.370]                               "release", "version")], collapse = " "), 
[09:31:14.370]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.370]                             info)
[09:31:14.370]                           info <- base::paste(info, collapse = "; ")
[09:31:14.370]                           if (!has_future) {
[09:31:14.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.370]                               info)
[09:31:14.370]                           }
[09:31:14.370]                           else {
[09:31:14.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.370]                               info, version)
[09:31:14.370]                           }
[09:31:14.370]                           base::stop(msg)
[09:31:14.370]                         }
[09:31:14.370]                       })
[09:31:14.370]                     }
[09:31:14.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.370]                     base::options(mc.cores = 1L)
[09:31:14.370]                   }
[09:31:14.370]                   ...future.strategy.old <- future::plan("list")
[09:31:14.370]                   options(future.plan = NULL)
[09:31:14.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.370]                 }
[09:31:14.370]                 ...future.workdir <- getwd()
[09:31:14.370]             }
[09:31:14.370]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.370]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.370]         }
[09:31:14.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.370]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.370]             base::names(...future.oldOptions))
[09:31:14.370]     }
[09:31:14.370]     if (FALSE) {
[09:31:14.370]     }
[09:31:14.370]     else {
[09:31:14.370]         if (TRUE) {
[09:31:14.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.370]                 open = "w")
[09:31:14.370]         }
[09:31:14.370]         else {
[09:31:14.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.370]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.370]         }
[09:31:14.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.370]             base::sink(type = "output", split = FALSE)
[09:31:14.370]             base::close(...future.stdout)
[09:31:14.370]         }, add = TRUE)
[09:31:14.370]     }
[09:31:14.370]     ...future.frame <- base::sys.nframe()
[09:31:14.370]     ...future.conditions <- base::list()
[09:31:14.370]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.370]     if (FALSE) {
[09:31:14.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.370]     }
[09:31:14.370]     ...future.result <- base::tryCatch({
[09:31:14.370]         base::withCallingHandlers({
[09:31:14.370]             ...future.value <- base::withVisible(base::local({
[09:31:14.370]                 ...future.makeSendCondition <- base::local({
[09:31:14.370]                   sendCondition <- NULL
[09:31:14.370]                   function(frame = 1L) {
[09:31:14.370]                     if (is.function(sendCondition)) 
[09:31:14.370]                       return(sendCondition)
[09:31:14.370]                     ns <- getNamespace("parallel")
[09:31:14.370]                     if (exists("sendData", mode = "function", 
[09:31:14.370]                       envir = ns)) {
[09:31:14.370]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.370]                         envir = ns)
[09:31:14.370]                       envir <- sys.frame(frame)
[09:31:14.370]                       master <- NULL
[09:31:14.370]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.370]                         !identical(envir, emptyenv())) {
[09:31:14.370]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.370]                           inherits = FALSE)) {
[09:31:14.370]                           master <- get("master", mode = "list", 
[09:31:14.370]                             envir = envir, inherits = FALSE)
[09:31:14.370]                           if (inherits(master, c("SOCKnode", 
[09:31:14.370]                             "SOCK0node"))) {
[09:31:14.370]                             sendCondition <<- function(cond) {
[09:31:14.370]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.370]                                 success = TRUE)
[09:31:14.370]                               parallel_sendData(master, data)
[09:31:14.370]                             }
[09:31:14.370]                             return(sendCondition)
[09:31:14.370]                           }
[09:31:14.370]                         }
[09:31:14.370]                         frame <- frame + 1L
[09:31:14.370]                         envir <- sys.frame(frame)
[09:31:14.370]                       }
[09:31:14.370]                     }
[09:31:14.370]                     sendCondition <<- function(cond) NULL
[09:31:14.370]                   }
[09:31:14.370]                 })
[09:31:14.370]                 withCallingHandlers({
[09:31:14.370]                   NA
[09:31:14.370]                 }, immediateCondition = function(cond) {
[09:31:14.370]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.370]                   sendCondition(cond)
[09:31:14.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.370]                   {
[09:31:14.370]                     inherits <- base::inherits
[09:31:14.370]                     invokeRestart <- base::invokeRestart
[09:31:14.370]                     is.null <- base::is.null
[09:31:14.370]                     muffled <- FALSE
[09:31:14.370]                     if (inherits(cond, "message")) {
[09:31:14.370]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.370]                       if (muffled) 
[09:31:14.370]                         invokeRestart("muffleMessage")
[09:31:14.370]                     }
[09:31:14.370]                     else if (inherits(cond, "warning")) {
[09:31:14.370]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.370]                       if (muffled) 
[09:31:14.370]                         invokeRestart("muffleWarning")
[09:31:14.370]                     }
[09:31:14.370]                     else if (inherits(cond, "condition")) {
[09:31:14.370]                       if (!is.null(pattern)) {
[09:31:14.370]                         computeRestarts <- base::computeRestarts
[09:31:14.370]                         grepl <- base::grepl
[09:31:14.370]                         restarts <- computeRestarts(cond)
[09:31:14.370]                         for (restart in restarts) {
[09:31:14.370]                           name <- restart$name
[09:31:14.370]                           if (is.null(name)) 
[09:31:14.370]                             next
[09:31:14.370]                           if (!grepl(pattern, name)) 
[09:31:14.370]                             next
[09:31:14.370]                           invokeRestart(restart)
[09:31:14.370]                           muffled <- TRUE
[09:31:14.370]                           break
[09:31:14.370]                         }
[09:31:14.370]                       }
[09:31:14.370]                     }
[09:31:14.370]                     invisible(muffled)
[09:31:14.370]                   }
[09:31:14.370]                   muffleCondition(cond)
[09:31:14.370]                 })
[09:31:14.370]             }))
[09:31:14.370]             future::FutureResult(value = ...future.value$value, 
[09:31:14.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.370]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.370]                     ...future.globalenv.names))
[09:31:14.370]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.370]         }, condition = base::local({
[09:31:14.370]             c <- base::c
[09:31:14.370]             inherits <- base::inherits
[09:31:14.370]             invokeRestart <- base::invokeRestart
[09:31:14.370]             length <- base::length
[09:31:14.370]             list <- base::list
[09:31:14.370]             seq.int <- base::seq.int
[09:31:14.370]             signalCondition <- base::signalCondition
[09:31:14.370]             sys.calls <- base::sys.calls
[09:31:14.370]             `[[` <- base::`[[`
[09:31:14.370]             `+` <- base::`+`
[09:31:14.370]             `<<-` <- base::`<<-`
[09:31:14.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.370]                   3L)]
[09:31:14.370]             }
[09:31:14.370]             function(cond) {
[09:31:14.370]                 is_error <- inherits(cond, "error")
[09:31:14.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.370]                   NULL)
[09:31:14.370]                 if (is_error) {
[09:31:14.370]                   sessionInformation <- function() {
[09:31:14.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.370]                       search = base::search(), system = base::Sys.info())
[09:31:14.370]                   }
[09:31:14.370]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.370]                     cond$call), session = sessionInformation(), 
[09:31:14.370]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.370]                   signalCondition(cond)
[09:31:14.370]                 }
[09:31:14.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.370]                 "immediateCondition"))) {
[09:31:14.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.370]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.370]                   if (TRUE && !signal) {
[09:31:14.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.370]                     {
[09:31:14.370]                       inherits <- base::inherits
[09:31:14.370]                       invokeRestart <- base::invokeRestart
[09:31:14.370]                       is.null <- base::is.null
[09:31:14.370]                       muffled <- FALSE
[09:31:14.370]                       if (inherits(cond, "message")) {
[09:31:14.370]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.370]                         if (muffled) 
[09:31:14.370]                           invokeRestart("muffleMessage")
[09:31:14.370]                       }
[09:31:14.370]                       else if (inherits(cond, "warning")) {
[09:31:14.370]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.370]                         if (muffled) 
[09:31:14.370]                           invokeRestart("muffleWarning")
[09:31:14.370]                       }
[09:31:14.370]                       else if (inherits(cond, "condition")) {
[09:31:14.370]                         if (!is.null(pattern)) {
[09:31:14.370]                           computeRestarts <- base::computeRestarts
[09:31:14.370]                           grepl <- base::grepl
[09:31:14.370]                           restarts <- computeRestarts(cond)
[09:31:14.370]                           for (restart in restarts) {
[09:31:14.370]                             name <- restart$name
[09:31:14.370]                             if (is.null(name)) 
[09:31:14.370]                               next
[09:31:14.370]                             if (!grepl(pattern, name)) 
[09:31:14.370]                               next
[09:31:14.370]                             invokeRestart(restart)
[09:31:14.370]                             muffled <- TRUE
[09:31:14.370]                             break
[09:31:14.370]                           }
[09:31:14.370]                         }
[09:31:14.370]                       }
[09:31:14.370]                       invisible(muffled)
[09:31:14.370]                     }
[09:31:14.370]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.370]                   }
[09:31:14.370]                 }
[09:31:14.370]                 else {
[09:31:14.370]                   if (TRUE) {
[09:31:14.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.370]                     {
[09:31:14.370]                       inherits <- base::inherits
[09:31:14.370]                       invokeRestart <- base::invokeRestart
[09:31:14.370]                       is.null <- base::is.null
[09:31:14.370]                       muffled <- FALSE
[09:31:14.370]                       if (inherits(cond, "message")) {
[09:31:14.370]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.370]                         if (muffled) 
[09:31:14.370]                           invokeRestart("muffleMessage")
[09:31:14.370]                       }
[09:31:14.370]                       else if (inherits(cond, "warning")) {
[09:31:14.370]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.370]                         if (muffled) 
[09:31:14.370]                           invokeRestart("muffleWarning")
[09:31:14.370]                       }
[09:31:14.370]                       else if (inherits(cond, "condition")) {
[09:31:14.370]                         if (!is.null(pattern)) {
[09:31:14.370]                           computeRestarts <- base::computeRestarts
[09:31:14.370]                           grepl <- base::grepl
[09:31:14.370]                           restarts <- computeRestarts(cond)
[09:31:14.370]                           for (restart in restarts) {
[09:31:14.370]                             name <- restart$name
[09:31:14.370]                             if (is.null(name)) 
[09:31:14.370]                               next
[09:31:14.370]                             if (!grepl(pattern, name)) 
[09:31:14.370]                               next
[09:31:14.370]                             invokeRestart(restart)
[09:31:14.370]                             muffled <- TRUE
[09:31:14.370]                             break
[09:31:14.370]                           }
[09:31:14.370]                         }
[09:31:14.370]                       }
[09:31:14.370]                       invisible(muffled)
[09:31:14.370]                     }
[09:31:14.370]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.370]                   }
[09:31:14.370]                 }
[09:31:14.370]             }
[09:31:14.370]         }))
[09:31:14.370]     }, error = function(ex) {
[09:31:14.370]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.370]                 ...future.rng), started = ...future.startTime, 
[09:31:14.370]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.370]             version = "1.8"), class = "FutureResult")
[09:31:14.370]     }, finally = {
[09:31:14.370]         if (!identical(...future.workdir, getwd())) 
[09:31:14.370]             setwd(...future.workdir)
[09:31:14.370]         {
[09:31:14.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.370]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.370]             }
[09:31:14.370]             base::options(...future.oldOptions)
[09:31:14.370]             if (.Platform$OS.type == "windows") {
[09:31:14.370]                 old_names <- names(...future.oldEnvVars)
[09:31:14.370]                 envs <- base::Sys.getenv()
[09:31:14.370]                 names <- names(envs)
[09:31:14.370]                 common <- intersect(names, old_names)
[09:31:14.370]                 added <- setdiff(names, old_names)
[09:31:14.370]                 removed <- setdiff(old_names, names)
[09:31:14.370]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.370]                   envs[common]]
[09:31:14.370]                 NAMES <- toupper(changed)
[09:31:14.370]                 args <- list()
[09:31:14.370]                 for (kk in seq_along(NAMES)) {
[09:31:14.370]                   name <- changed[[kk]]
[09:31:14.370]                   NAME <- NAMES[[kk]]
[09:31:14.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.370]                     next
[09:31:14.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.370]                 }
[09:31:14.370]                 NAMES <- toupper(added)
[09:31:14.370]                 for (kk in seq_along(NAMES)) {
[09:31:14.370]                   name <- added[[kk]]
[09:31:14.370]                   NAME <- NAMES[[kk]]
[09:31:14.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.370]                     next
[09:31:14.370]                   args[[name]] <- ""
[09:31:14.370]                 }
[09:31:14.370]                 NAMES <- toupper(removed)
[09:31:14.370]                 for (kk in seq_along(NAMES)) {
[09:31:14.370]                   name <- removed[[kk]]
[09:31:14.370]                   NAME <- NAMES[[kk]]
[09:31:14.370]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.370]                     next
[09:31:14.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.370]                 }
[09:31:14.370]                 if (length(args) > 0) 
[09:31:14.370]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.370]             }
[09:31:14.370]             else {
[09:31:14.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.370]             }
[09:31:14.370]             {
[09:31:14.370]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.370]                   0L) {
[09:31:14.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.370]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.370]                   base::options(opts)
[09:31:14.370]                 }
[09:31:14.370]                 {
[09:31:14.370]                   {
[09:31:14.370]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.370]                     NULL
[09:31:14.370]                   }
[09:31:14.370]                   options(future.plan = NULL)
[09:31:14.370]                   if (is.na(NA_character_)) 
[09:31:14.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.370]                     .init = FALSE)
[09:31:14.370]                 }
[09:31:14.370]             }
[09:31:14.370]         }
[09:31:14.370]     })
[09:31:14.370]     if (TRUE) {
[09:31:14.370]         base::sink(type = "output", split = FALSE)
[09:31:14.370]         if (TRUE) {
[09:31:14.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.370]         }
[09:31:14.370]         else {
[09:31:14.370]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.370]         }
[09:31:14.370]         base::close(...future.stdout)
[09:31:14.370]         ...future.stdout <- NULL
[09:31:14.370]     }
[09:31:14.370]     ...future.result$conditions <- ...future.conditions
[09:31:14.370]     ...future.result$finished <- base::Sys.time()
[09:31:14.370]     ...future.result
[09:31:14.370] }
[09:31:14.422] MultisessionFuture started
[09:31:14.422] result() for ClusterFuture ...
[09:31:14.423] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.423] - Validating connection of MultisessionFuture
[09:31:14.454] - received message: FutureResult
[09:31:14.454] - Received FutureResult
[09:31:14.454] - Erased future from FutureRegistry
[09:31:14.454] result() for ClusterFuture ...
[09:31:14.454] - result already collected: FutureResult
[09:31:14.455] result() for ClusterFuture ... done
[09:31:14.455] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.455] result() for ClusterFuture ... done
[09:31:14.455] result() for ClusterFuture ...
[09:31:14.455] - result already collected: FutureResult
[09:31:14.455] result() for ClusterFuture ... done
[09:31:14.455] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:14.459] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:14.459] getGlobalsAndPackages() ...
[09:31:14.459] Searching for globals...
[09:31:14.460] 
[09:31:14.460] Searching for globals ... DONE
[09:31:14.460] - globals: [0] <none>
[09:31:14.460] getGlobalsAndPackages() ... DONE
[09:31:14.460] run() for ‘Future’ ...
[09:31:14.460] - state: ‘created’
[09:31:14.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.474] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.475]   - Field: ‘node’
[09:31:14.475]   - Field: ‘label’
[09:31:14.475]   - Field: ‘local’
[09:31:14.475]   - Field: ‘owner’
[09:31:14.475]   - Field: ‘envir’
[09:31:14.475]   - Field: ‘workers’
[09:31:14.475]   - Field: ‘packages’
[09:31:14.476]   - Field: ‘gc’
[09:31:14.476]   - Field: ‘conditions’
[09:31:14.476]   - Field: ‘persistent’
[09:31:14.476]   - Field: ‘expr’
[09:31:14.476]   - Field: ‘uuid’
[09:31:14.476]   - Field: ‘seed’
[09:31:14.476]   - Field: ‘version’
[09:31:14.476]   - Field: ‘result’
[09:31:14.476]   - Field: ‘asynchronous’
[09:31:14.477]   - Field: ‘calls’
[09:31:14.477]   - Field: ‘globals’
[09:31:14.477]   - Field: ‘stdout’
[09:31:14.477]   - Field: ‘earlySignal’
[09:31:14.477]   - Field: ‘lazy’
[09:31:14.477]   - Field: ‘state’
[09:31:14.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.477] - Launch lazy future ...
[09:31:14.478] Packages needed by the future expression (n = 0): <none>
[09:31:14.478] Packages needed by future strategies (n = 0): <none>
[09:31:14.478] {
[09:31:14.478]     {
[09:31:14.478]         {
[09:31:14.478]             ...future.startTime <- base::Sys.time()
[09:31:14.478]             {
[09:31:14.478]                 {
[09:31:14.478]                   {
[09:31:14.478]                     {
[09:31:14.478]                       base::local({
[09:31:14.478]                         has_future <- base::requireNamespace("future", 
[09:31:14.478]                           quietly = TRUE)
[09:31:14.478]                         if (has_future) {
[09:31:14.478]                           ns <- base::getNamespace("future")
[09:31:14.478]                           version <- ns[[".package"]][["version"]]
[09:31:14.478]                           if (is.null(version)) 
[09:31:14.478]                             version <- utils::packageVersion("future")
[09:31:14.478]                         }
[09:31:14.478]                         else {
[09:31:14.478]                           version <- NULL
[09:31:14.478]                         }
[09:31:14.478]                         if (!has_future || version < "1.8.0") {
[09:31:14.478]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.478]                             "", base::R.version$version.string), 
[09:31:14.478]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.478]                               "release", "version")], collapse = " "), 
[09:31:14.478]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.478]                             info)
[09:31:14.478]                           info <- base::paste(info, collapse = "; ")
[09:31:14.478]                           if (!has_future) {
[09:31:14.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.478]                               info)
[09:31:14.478]                           }
[09:31:14.478]                           else {
[09:31:14.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.478]                               info, version)
[09:31:14.478]                           }
[09:31:14.478]                           base::stop(msg)
[09:31:14.478]                         }
[09:31:14.478]                       })
[09:31:14.478]                     }
[09:31:14.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.478]                     base::options(mc.cores = 1L)
[09:31:14.478]                   }
[09:31:14.478]                   ...future.strategy.old <- future::plan("list")
[09:31:14.478]                   options(future.plan = NULL)
[09:31:14.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.478]                 }
[09:31:14.478]                 ...future.workdir <- getwd()
[09:31:14.478]             }
[09:31:14.478]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.478]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.478]         }
[09:31:14.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.478]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.478]             base::names(...future.oldOptions))
[09:31:14.478]     }
[09:31:14.478]     if (FALSE) {
[09:31:14.478]     }
[09:31:14.478]     else {
[09:31:14.478]         if (TRUE) {
[09:31:14.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.478]                 open = "w")
[09:31:14.478]         }
[09:31:14.478]         else {
[09:31:14.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.478]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.478]         }
[09:31:14.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.478]             base::sink(type = "output", split = FALSE)
[09:31:14.478]             base::close(...future.stdout)
[09:31:14.478]         }, add = TRUE)
[09:31:14.478]     }
[09:31:14.478]     ...future.frame <- base::sys.nframe()
[09:31:14.478]     ...future.conditions <- base::list()
[09:31:14.478]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.478]     if (FALSE) {
[09:31:14.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.478]     }
[09:31:14.478]     ...future.result <- base::tryCatch({
[09:31:14.478]         base::withCallingHandlers({
[09:31:14.478]             ...future.value <- base::withVisible(base::local({
[09:31:14.478]                 ...future.makeSendCondition <- base::local({
[09:31:14.478]                   sendCondition <- NULL
[09:31:14.478]                   function(frame = 1L) {
[09:31:14.478]                     if (is.function(sendCondition)) 
[09:31:14.478]                       return(sendCondition)
[09:31:14.478]                     ns <- getNamespace("parallel")
[09:31:14.478]                     if (exists("sendData", mode = "function", 
[09:31:14.478]                       envir = ns)) {
[09:31:14.478]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.478]                         envir = ns)
[09:31:14.478]                       envir <- sys.frame(frame)
[09:31:14.478]                       master <- NULL
[09:31:14.478]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.478]                         !identical(envir, emptyenv())) {
[09:31:14.478]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.478]                           inherits = FALSE)) {
[09:31:14.478]                           master <- get("master", mode = "list", 
[09:31:14.478]                             envir = envir, inherits = FALSE)
[09:31:14.478]                           if (inherits(master, c("SOCKnode", 
[09:31:14.478]                             "SOCK0node"))) {
[09:31:14.478]                             sendCondition <<- function(cond) {
[09:31:14.478]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.478]                                 success = TRUE)
[09:31:14.478]                               parallel_sendData(master, data)
[09:31:14.478]                             }
[09:31:14.478]                             return(sendCondition)
[09:31:14.478]                           }
[09:31:14.478]                         }
[09:31:14.478]                         frame <- frame + 1L
[09:31:14.478]                         envir <- sys.frame(frame)
[09:31:14.478]                       }
[09:31:14.478]                     }
[09:31:14.478]                     sendCondition <<- function(cond) NULL
[09:31:14.478]                   }
[09:31:14.478]                 })
[09:31:14.478]                 withCallingHandlers({
[09:31:14.478]                   2
[09:31:14.478]                 }, immediateCondition = function(cond) {
[09:31:14.478]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.478]                   sendCondition(cond)
[09:31:14.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.478]                   {
[09:31:14.478]                     inherits <- base::inherits
[09:31:14.478]                     invokeRestart <- base::invokeRestart
[09:31:14.478]                     is.null <- base::is.null
[09:31:14.478]                     muffled <- FALSE
[09:31:14.478]                     if (inherits(cond, "message")) {
[09:31:14.478]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.478]                       if (muffled) 
[09:31:14.478]                         invokeRestart("muffleMessage")
[09:31:14.478]                     }
[09:31:14.478]                     else if (inherits(cond, "warning")) {
[09:31:14.478]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.478]                       if (muffled) 
[09:31:14.478]                         invokeRestart("muffleWarning")
[09:31:14.478]                     }
[09:31:14.478]                     else if (inherits(cond, "condition")) {
[09:31:14.478]                       if (!is.null(pattern)) {
[09:31:14.478]                         computeRestarts <- base::computeRestarts
[09:31:14.478]                         grepl <- base::grepl
[09:31:14.478]                         restarts <- computeRestarts(cond)
[09:31:14.478]                         for (restart in restarts) {
[09:31:14.478]                           name <- restart$name
[09:31:14.478]                           if (is.null(name)) 
[09:31:14.478]                             next
[09:31:14.478]                           if (!grepl(pattern, name)) 
[09:31:14.478]                             next
[09:31:14.478]                           invokeRestart(restart)
[09:31:14.478]                           muffled <- TRUE
[09:31:14.478]                           break
[09:31:14.478]                         }
[09:31:14.478]                       }
[09:31:14.478]                     }
[09:31:14.478]                     invisible(muffled)
[09:31:14.478]                   }
[09:31:14.478]                   muffleCondition(cond)
[09:31:14.478]                 })
[09:31:14.478]             }))
[09:31:14.478]             future::FutureResult(value = ...future.value$value, 
[09:31:14.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.478]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.478]                     ...future.globalenv.names))
[09:31:14.478]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.478]         }, condition = base::local({
[09:31:14.478]             c <- base::c
[09:31:14.478]             inherits <- base::inherits
[09:31:14.478]             invokeRestart <- base::invokeRestart
[09:31:14.478]             length <- base::length
[09:31:14.478]             list <- base::list
[09:31:14.478]             seq.int <- base::seq.int
[09:31:14.478]             signalCondition <- base::signalCondition
[09:31:14.478]             sys.calls <- base::sys.calls
[09:31:14.478]             `[[` <- base::`[[`
[09:31:14.478]             `+` <- base::`+`
[09:31:14.478]             `<<-` <- base::`<<-`
[09:31:14.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.478]                   3L)]
[09:31:14.478]             }
[09:31:14.478]             function(cond) {
[09:31:14.478]                 is_error <- inherits(cond, "error")
[09:31:14.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.478]                   NULL)
[09:31:14.478]                 if (is_error) {
[09:31:14.478]                   sessionInformation <- function() {
[09:31:14.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.478]                       search = base::search(), system = base::Sys.info())
[09:31:14.478]                   }
[09:31:14.478]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.478]                     cond$call), session = sessionInformation(), 
[09:31:14.478]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.478]                   signalCondition(cond)
[09:31:14.478]                 }
[09:31:14.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.478]                 "immediateCondition"))) {
[09:31:14.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.478]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.478]                   if (TRUE && !signal) {
[09:31:14.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.478]                     {
[09:31:14.478]                       inherits <- base::inherits
[09:31:14.478]                       invokeRestart <- base::invokeRestart
[09:31:14.478]                       is.null <- base::is.null
[09:31:14.478]                       muffled <- FALSE
[09:31:14.478]                       if (inherits(cond, "message")) {
[09:31:14.478]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.478]                         if (muffled) 
[09:31:14.478]                           invokeRestart("muffleMessage")
[09:31:14.478]                       }
[09:31:14.478]                       else if (inherits(cond, "warning")) {
[09:31:14.478]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.478]                         if (muffled) 
[09:31:14.478]                           invokeRestart("muffleWarning")
[09:31:14.478]                       }
[09:31:14.478]                       else if (inherits(cond, "condition")) {
[09:31:14.478]                         if (!is.null(pattern)) {
[09:31:14.478]                           computeRestarts <- base::computeRestarts
[09:31:14.478]                           grepl <- base::grepl
[09:31:14.478]                           restarts <- computeRestarts(cond)
[09:31:14.478]                           for (restart in restarts) {
[09:31:14.478]                             name <- restart$name
[09:31:14.478]                             if (is.null(name)) 
[09:31:14.478]                               next
[09:31:14.478]                             if (!grepl(pattern, name)) 
[09:31:14.478]                               next
[09:31:14.478]                             invokeRestart(restart)
[09:31:14.478]                             muffled <- TRUE
[09:31:14.478]                             break
[09:31:14.478]                           }
[09:31:14.478]                         }
[09:31:14.478]                       }
[09:31:14.478]                       invisible(muffled)
[09:31:14.478]                     }
[09:31:14.478]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.478]                   }
[09:31:14.478]                 }
[09:31:14.478]                 else {
[09:31:14.478]                   if (TRUE) {
[09:31:14.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.478]                     {
[09:31:14.478]                       inherits <- base::inherits
[09:31:14.478]                       invokeRestart <- base::invokeRestart
[09:31:14.478]                       is.null <- base::is.null
[09:31:14.478]                       muffled <- FALSE
[09:31:14.478]                       if (inherits(cond, "message")) {
[09:31:14.478]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.478]                         if (muffled) 
[09:31:14.478]                           invokeRestart("muffleMessage")
[09:31:14.478]                       }
[09:31:14.478]                       else if (inherits(cond, "warning")) {
[09:31:14.478]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.478]                         if (muffled) 
[09:31:14.478]                           invokeRestart("muffleWarning")
[09:31:14.478]                       }
[09:31:14.478]                       else if (inherits(cond, "condition")) {
[09:31:14.478]                         if (!is.null(pattern)) {
[09:31:14.478]                           computeRestarts <- base::computeRestarts
[09:31:14.478]                           grepl <- base::grepl
[09:31:14.478]                           restarts <- computeRestarts(cond)
[09:31:14.478]                           for (restart in restarts) {
[09:31:14.478]                             name <- restart$name
[09:31:14.478]                             if (is.null(name)) 
[09:31:14.478]                               next
[09:31:14.478]                             if (!grepl(pattern, name)) 
[09:31:14.478]                               next
[09:31:14.478]                             invokeRestart(restart)
[09:31:14.478]                             muffled <- TRUE
[09:31:14.478]                             break
[09:31:14.478]                           }
[09:31:14.478]                         }
[09:31:14.478]                       }
[09:31:14.478]                       invisible(muffled)
[09:31:14.478]                     }
[09:31:14.478]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.478]                   }
[09:31:14.478]                 }
[09:31:14.478]             }
[09:31:14.478]         }))
[09:31:14.478]     }, error = function(ex) {
[09:31:14.478]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.478]                 ...future.rng), started = ...future.startTime, 
[09:31:14.478]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.478]             version = "1.8"), class = "FutureResult")
[09:31:14.478]     }, finally = {
[09:31:14.478]         if (!identical(...future.workdir, getwd())) 
[09:31:14.478]             setwd(...future.workdir)
[09:31:14.478]         {
[09:31:14.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.478]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.478]             }
[09:31:14.478]             base::options(...future.oldOptions)
[09:31:14.478]             if (.Platform$OS.type == "windows") {
[09:31:14.478]                 old_names <- names(...future.oldEnvVars)
[09:31:14.478]                 envs <- base::Sys.getenv()
[09:31:14.478]                 names <- names(envs)
[09:31:14.478]                 common <- intersect(names, old_names)
[09:31:14.478]                 added <- setdiff(names, old_names)
[09:31:14.478]                 removed <- setdiff(old_names, names)
[09:31:14.478]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.478]                   envs[common]]
[09:31:14.478]                 NAMES <- toupper(changed)
[09:31:14.478]                 args <- list()
[09:31:14.478]                 for (kk in seq_along(NAMES)) {
[09:31:14.478]                   name <- changed[[kk]]
[09:31:14.478]                   NAME <- NAMES[[kk]]
[09:31:14.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.478]                     next
[09:31:14.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.478]                 }
[09:31:14.478]                 NAMES <- toupper(added)
[09:31:14.478]                 for (kk in seq_along(NAMES)) {
[09:31:14.478]                   name <- added[[kk]]
[09:31:14.478]                   NAME <- NAMES[[kk]]
[09:31:14.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.478]                     next
[09:31:14.478]                   args[[name]] <- ""
[09:31:14.478]                 }
[09:31:14.478]                 NAMES <- toupper(removed)
[09:31:14.478]                 for (kk in seq_along(NAMES)) {
[09:31:14.478]                   name <- removed[[kk]]
[09:31:14.478]                   NAME <- NAMES[[kk]]
[09:31:14.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.478]                     next
[09:31:14.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.478]                 }
[09:31:14.478]                 if (length(args) > 0) 
[09:31:14.478]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.478]             }
[09:31:14.478]             else {
[09:31:14.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.478]             }
[09:31:14.478]             {
[09:31:14.478]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.478]                   0L) {
[09:31:14.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.478]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.478]                   base::options(opts)
[09:31:14.478]                 }
[09:31:14.478]                 {
[09:31:14.478]                   {
[09:31:14.478]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.478]                     NULL
[09:31:14.478]                   }
[09:31:14.478]                   options(future.plan = NULL)
[09:31:14.478]                   if (is.na(NA_character_)) 
[09:31:14.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.478]                     .init = FALSE)
[09:31:14.478]                 }
[09:31:14.478]             }
[09:31:14.478]         }
[09:31:14.478]     })
[09:31:14.478]     if (TRUE) {
[09:31:14.478]         base::sink(type = "output", split = FALSE)
[09:31:14.478]         if (TRUE) {
[09:31:14.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.478]         }
[09:31:14.478]         else {
[09:31:14.478]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.478]         }
[09:31:14.478]         base::close(...future.stdout)
[09:31:14.478]         ...future.stdout <- NULL
[09:31:14.478]     }
[09:31:14.478]     ...future.result$conditions <- ...future.conditions
[09:31:14.478]     ...future.result$finished <- base::Sys.time()
[09:31:14.478]     ...future.result
[09:31:14.478] }
[09:31:14.481] MultisessionFuture started
[09:31:14.481] - Launch lazy future ... done
[09:31:14.482] run() for ‘MultisessionFuture’ ... done
[09:31:14.482] getGlobalsAndPackages() ...
[09:31:14.482] Searching for globals...
[09:31:14.482] 
[09:31:14.483] Searching for globals ... DONE
[09:31:14.483] - globals: [0] <none>
[09:31:14.483] getGlobalsAndPackages() ... DONE
[09:31:14.483] run() for ‘Future’ ...
[09:31:14.483] - state: ‘created’
[09:31:14.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.498]   - Field: ‘node’
[09:31:14.498]   - Field: ‘label’
[09:31:14.498]   - Field: ‘local’
[09:31:14.498]   - Field: ‘owner’
[09:31:14.499]   - Field: ‘envir’
[09:31:14.499]   - Field: ‘workers’
[09:31:14.499]   - Field: ‘packages’
[09:31:14.499]   - Field: ‘gc’
[09:31:14.499]   - Field: ‘conditions’
[09:31:14.499]   - Field: ‘persistent’
[09:31:14.499]   - Field: ‘expr’
[09:31:14.499]   - Field: ‘uuid’
[09:31:14.499]   - Field: ‘seed’
[09:31:14.500]   - Field: ‘version’
[09:31:14.500]   - Field: ‘result’
[09:31:14.500]   - Field: ‘asynchronous’
[09:31:14.500]   - Field: ‘calls’
[09:31:14.500]   - Field: ‘globals’
[09:31:14.500]   - Field: ‘stdout’
[09:31:14.500]   - Field: ‘earlySignal’
[09:31:14.500]   - Field: ‘lazy’
[09:31:14.500]   - Field: ‘state’
[09:31:14.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.501] - Launch lazy future ...
[09:31:14.501] Packages needed by the future expression (n = 0): <none>
[09:31:14.501] Packages needed by future strategies (n = 0): <none>
[09:31:14.502] {
[09:31:14.502]     {
[09:31:14.502]         {
[09:31:14.502]             ...future.startTime <- base::Sys.time()
[09:31:14.502]             {
[09:31:14.502]                 {
[09:31:14.502]                   {
[09:31:14.502]                     {
[09:31:14.502]                       base::local({
[09:31:14.502]                         has_future <- base::requireNamespace("future", 
[09:31:14.502]                           quietly = TRUE)
[09:31:14.502]                         if (has_future) {
[09:31:14.502]                           ns <- base::getNamespace("future")
[09:31:14.502]                           version <- ns[[".package"]][["version"]]
[09:31:14.502]                           if (is.null(version)) 
[09:31:14.502]                             version <- utils::packageVersion("future")
[09:31:14.502]                         }
[09:31:14.502]                         else {
[09:31:14.502]                           version <- NULL
[09:31:14.502]                         }
[09:31:14.502]                         if (!has_future || version < "1.8.0") {
[09:31:14.502]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.502]                             "", base::R.version$version.string), 
[09:31:14.502]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.502]                               "release", "version")], collapse = " "), 
[09:31:14.502]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.502]                             info)
[09:31:14.502]                           info <- base::paste(info, collapse = "; ")
[09:31:14.502]                           if (!has_future) {
[09:31:14.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.502]                               info)
[09:31:14.502]                           }
[09:31:14.502]                           else {
[09:31:14.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.502]                               info, version)
[09:31:14.502]                           }
[09:31:14.502]                           base::stop(msg)
[09:31:14.502]                         }
[09:31:14.502]                       })
[09:31:14.502]                     }
[09:31:14.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.502]                     base::options(mc.cores = 1L)
[09:31:14.502]                   }
[09:31:14.502]                   ...future.strategy.old <- future::plan("list")
[09:31:14.502]                   options(future.plan = NULL)
[09:31:14.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.502]                 }
[09:31:14.502]                 ...future.workdir <- getwd()
[09:31:14.502]             }
[09:31:14.502]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.502]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.502]         }
[09:31:14.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.502]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.502]             base::names(...future.oldOptions))
[09:31:14.502]     }
[09:31:14.502]     if (FALSE) {
[09:31:14.502]     }
[09:31:14.502]     else {
[09:31:14.502]         if (TRUE) {
[09:31:14.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.502]                 open = "w")
[09:31:14.502]         }
[09:31:14.502]         else {
[09:31:14.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.502]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.502]         }
[09:31:14.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.502]             base::sink(type = "output", split = FALSE)
[09:31:14.502]             base::close(...future.stdout)
[09:31:14.502]         }, add = TRUE)
[09:31:14.502]     }
[09:31:14.502]     ...future.frame <- base::sys.nframe()
[09:31:14.502]     ...future.conditions <- base::list()
[09:31:14.502]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.502]     if (FALSE) {
[09:31:14.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.502]     }
[09:31:14.502]     ...future.result <- base::tryCatch({
[09:31:14.502]         base::withCallingHandlers({
[09:31:14.502]             ...future.value <- base::withVisible(base::local({
[09:31:14.502]                 ...future.makeSendCondition <- base::local({
[09:31:14.502]                   sendCondition <- NULL
[09:31:14.502]                   function(frame = 1L) {
[09:31:14.502]                     if (is.function(sendCondition)) 
[09:31:14.502]                       return(sendCondition)
[09:31:14.502]                     ns <- getNamespace("parallel")
[09:31:14.502]                     if (exists("sendData", mode = "function", 
[09:31:14.502]                       envir = ns)) {
[09:31:14.502]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.502]                         envir = ns)
[09:31:14.502]                       envir <- sys.frame(frame)
[09:31:14.502]                       master <- NULL
[09:31:14.502]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.502]                         !identical(envir, emptyenv())) {
[09:31:14.502]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.502]                           inherits = FALSE)) {
[09:31:14.502]                           master <- get("master", mode = "list", 
[09:31:14.502]                             envir = envir, inherits = FALSE)
[09:31:14.502]                           if (inherits(master, c("SOCKnode", 
[09:31:14.502]                             "SOCK0node"))) {
[09:31:14.502]                             sendCondition <<- function(cond) {
[09:31:14.502]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.502]                                 success = TRUE)
[09:31:14.502]                               parallel_sendData(master, data)
[09:31:14.502]                             }
[09:31:14.502]                             return(sendCondition)
[09:31:14.502]                           }
[09:31:14.502]                         }
[09:31:14.502]                         frame <- frame + 1L
[09:31:14.502]                         envir <- sys.frame(frame)
[09:31:14.502]                       }
[09:31:14.502]                     }
[09:31:14.502]                     sendCondition <<- function(cond) NULL
[09:31:14.502]                   }
[09:31:14.502]                 })
[09:31:14.502]                 withCallingHandlers({
[09:31:14.502]                   NULL
[09:31:14.502]                 }, immediateCondition = function(cond) {
[09:31:14.502]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.502]                   sendCondition(cond)
[09:31:14.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.502]                   {
[09:31:14.502]                     inherits <- base::inherits
[09:31:14.502]                     invokeRestart <- base::invokeRestart
[09:31:14.502]                     is.null <- base::is.null
[09:31:14.502]                     muffled <- FALSE
[09:31:14.502]                     if (inherits(cond, "message")) {
[09:31:14.502]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.502]                       if (muffled) 
[09:31:14.502]                         invokeRestart("muffleMessage")
[09:31:14.502]                     }
[09:31:14.502]                     else if (inherits(cond, "warning")) {
[09:31:14.502]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.502]                       if (muffled) 
[09:31:14.502]                         invokeRestart("muffleWarning")
[09:31:14.502]                     }
[09:31:14.502]                     else if (inherits(cond, "condition")) {
[09:31:14.502]                       if (!is.null(pattern)) {
[09:31:14.502]                         computeRestarts <- base::computeRestarts
[09:31:14.502]                         grepl <- base::grepl
[09:31:14.502]                         restarts <- computeRestarts(cond)
[09:31:14.502]                         for (restart in restarts) {
[09:31:14.502]                           name <- restart$name
[09:31:14.502]                           if (is.null(name)) 
[09:31:14.502]                             next
[09:31:14.502]                           if (!grepl(pattern, name)) 
[09:31:14.502]                             next
[09:31:14.502]                           invokeRestart(restart)
[09:31:14.502]                           muffled <- TRUE
[09:31:14.502]                           break
[09:31:14.502]                         }
[09:31:14.502]                       }
[09:31:14.502]                     }
[09:31:14.502]                     invisible(muffled)
[09:31:14.502]                   }
[09:31:14.502]                   muffleCondition(cond)
[09:31:14.502]                 })
[09:31:14.502]             }))
[09:31:14.502]             future::FutureResult(value = ...future.value$value, 
[09:31:14.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.502]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.502]                     ...future.globalenv.names))
[09:31:14.502]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.502]         }, condition = base::local({
[09:31:14.502]             c <- base::c
[09:31:14.502]             inherits <- base::inherits
[09:31:14.502]             invokeRestart <- base::invokeRestart
[09:31:14.502]             length <- base::length
[09:31:14.502]             list <- base::list
[09:31:14.502]             seq.int <- base::seq.int
[09:31:14.502]             signalCondition <- base::signalCondition
[09:31:14.502]             sys.calls <- base::sys.calls
[09:31:14.502]             `[[` <- base::`[[`
[09:31:14.502]             `+` <- base::`+`
[09:31:14.502]             `<<-` <- base::`<<-`
[09:31:14.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.502]                   3L)]
[09:31:14.502]             }
[09:31:14.502]             function(cond) {
[09:31:14.502]                 is_error <- inherits(cond, "error")
[09:31:14.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.502]                   NULL)
[09:31:14.502]                 if (is_error) {
[09:31:14.502]                   sessionInformation <- function() {
[09:31:14.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.502]                       search = base::search(), system = base::Sys.info())
[09:31:14.502]                   }
[09:31:14.502]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.502]                     cond$call), session = sessionInformation(), 
[09:31:14.502]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.502]                   signalCondition(cond)
[09:31:14.502]                 }
[09:31:14.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.502]                 "immediateCondition"))) {
[09:31:14.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.502]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.502]                   if (TRUE && !signal) {
[09:31:14.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.502]                     {
[09:31:14.502]                       inherits <- base::inherits
[09:31:14.502]                       invokeRestart <- base::invokeRestart
[09:31:14.502]                       is.null <- base::is.null
[09:31:14.502]                       muffled <- FALSE
[09:31:14.502]                       if (inherits(cond, "message")) {
[09:31:14.502]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.502]                         if (muffled) 
[09:31:14.502]                           invokeRestart("muffleMessage")
[09:31:14.502]                       }
[09:31:14.502]                       else if (inherits(cond, "warning")) {
[09:31:14.502]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.502]                         if (muffled) 
[09:31:14.502]                           invokeRestart("muffleWarning")
[09:31:14.502]                       }
[09:31:14.502]                       else if (inherits(cond, "condition")) {
[09:31:14.502]                         if (!is.null(pattern)) {
[09:31:14.502]                           computeRestarts <- base::computeRestarts
[09:31:14.502]                           grepl <- base::grepl
[09:31:14.502]                           restarts <- computeRestarts(cond)
[09:31:14.502]                           for (restart in restarts) {
[09:31:14.502]                             name <- restart$name
[09:31:14.502]                             if (is.null(name)) 
[09:31:14.502]                               next
[09:31:14.502]                             if (!grepl(pattern, name)) 
[09:31:14.502]                               next
[09:31:14.502]                             invokeRestart(restart)
[09:31:14.502]                             muffled <- TRUE
[09:31:14.502]                             break
[09:31:14.502]                           }
[09:31:14.502]                         }
[09:31:14.502]                       }
[09:31:14.502]                       invisible(muffled)
[09:31:14.502]                     }
[09:31:14.502]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.502]                   }
[09:31:14.502]                 }
[09:31:14.502]                 else {
[09:31:14.502]                   if (TRUE) {
[09:31:14.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.502]                     {
[09:31:14.502]                       inherits <- base::inherits
[09:31:14.502]                       invokeRestart <- base::invokeRestart
[09:31:14.502]                       is.null <- base::is.null
[09:31:14.502]                       muffled <- FALSE
[09:31:14.502]                       if (inherits(cond, "message")) {
[09:31:14.502]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.502]                         if (muffled) 
[09:31:14.502]                           invokeRestart("muffleMessage")
[09:31:14.502]                       }
[09:31:14.502]                       else if (inherits(cond, "warning")) {
[09:31:14.502]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.502]                         if (muffled) 
[09:31:14.502]                           invokeRestart("muffleWarning")
[09:31:14.502]                       }
[09:31:14.502]                       else if (inherits(cond, "condition")) {
[09:31:14.502]                         if (!is.null(pattern)) {
[09:31:14.502]                           computeRestarts <- base::computeRestarts
[09:31:14.502]                           grepl <- base::grepl
[09:31:14.502]                           restarts <- computeRestarts(cond)
[09:31:14.502]                           for (restart in restarts) {
[09:31:14.502]                             name <- restart$name
[09:31:14.502]                             if (is.null(name)) 
[09:31:14.502]                               next
[09:31:14.502]                             if (!grepl(pattern, name)) 
[09:31:14.502]                               next
[09:31:14.502]                             invokeRestart(restart)
[09:31:14.502]                             muffled <- TRUE
[09:31:14.502]                             break
[09:31:14.502]                           }
[09:31:14.502]                         }
[09:31:14.502]                       }
[09:31:14.502]                       invisible(muffled)
[09:31:14.502]                     }
[09:31:14.502]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.502]                   }
[09:31:14.502]                 }
[09:31:14.502]             }
[09:31:14.502]         }))
[09:31:14.502]     }, error = function(ex) {
[09:31:14.502]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.502]                 ...future.rng), started = ...future.startTime, 
[09:31:14.502]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.502]             version = "1.8"), class = "FutureResult")
[09:31:14.502]     }, finally = {
[09:31:14.502]         if (!identical(...future.workdir, getwd())) 
[09:31:14.502]             setwd(...future.workdir)
[09:31:14.502]         {
[09:31:14.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.502]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.502]             }
[09:31:14.502]             base::options(...future.oldOptions)
[09:31:14.502]             if (.Platform$OS.type == "windows") {
[09:31:14.502]                 old_names <- names(...future.oldEnvVars)
[09:31:14.502]                 envs <- base::Sys.getenv()
[09:31:14.502]                 names <- names(envs)
[09:31:14.502]                 common <- intersect(names, old_names)
[09:31:14.502]                 added <- setdiff(names, old_names)
[09:31:14.502]                 removed <- setdiff(old_names, names)
[09:31:14.502]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.502]                   envs[common]]
[09:31:14.502]                 NAMES <- toupper(changed)
[09:31:14.502]                 args <- list()
[09:31:14.502]                 for (kk in seq_along(NAMES)) {
[09:31:14.502]                   name <- changed[[kk]]
[09:31:14.502]                   NAME <- NAMES[[kk]]
[09:31:14.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.502]                     next
[09:31:14.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.502]                 }
[09:31:14.502]                 NAMES <- toupper(added)
[09:31:14.502]                 for (kk in seq_along(NAMES)) {
[09:31:14.502]                   name <- added[[kk]]
[09:31:14.502]                   NAME <- NAMES[[kk]]
[09:31:14.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.502]                     next
[09:31:14.502]                   args[[name]] <- ""
[09:31:14.502]                 }
[09:31:14.502]                 NAMES <- toupper(removed)
[09:31:14.502]                 for (kk in seq_along(NAMES)) {
[09:31:14.502]                   name <- removed[[kk]]
[09:31:14.502]                   NAME <- NAMES[[kk]]
[09:31:14.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.502]                     next
[09:31:14.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.502]                 }
[09:31:14.502]                 if (length(args) > 0) 
[09:31:14.502]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.502]             }
[09:31:14.502]             else {
[09:31:14.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.502]             }
[09:31:14.502]             {
[09:31:14.502]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.502]                   0L) {
[09:31:14.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.502]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.502]                   base::options(opts)
[09:31:14.502]                 }
[09:31:14.502]                 {
[09:31:14.502]                   {
[09:31:14.502]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.502]                     NULL
[09:31:14.502]                   }
[09:31:14.502]                   options(future.plan = NULL)
[09:31:14.502]                   if (is.na(NA_character_)) 
[09:31:14.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.502]                     .init = FALSE)
[09:31:14.502]                 }
[09:31:14.502]             }
[09:31:14.502]         }
[09:31:14.502]     })
[09:31:14.502]     if (TRUE) {
[09:31:14.502]         base::sink(type = "output", split = FALSE)
[09:31:14.502]         if (TRUE) {
[09:31:14.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.502]         }
[09:31:14.502]         else {
[09:31:14.502]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.502]         }
[09:31:14.502]         base::close(...future.stdout)
[09:31:14.502]         ...future.stdout <- NULL
[09:31:14.502]     }
[09:31:14.502]     ...future.result$conditions <- ...future.conditions
[09:31:14.502]     ...future.result$finished <- base::Sys.time()
[09:31:14.502]     ...future.result
[09:31:14.502] }
[09:31:14.554] MultisessionFuture started
[09:31:14.554] - Launch lazy future ... done
[09:31:14.554] run() for ‘MultisessionFuture’ ... done
[09:31:14.555] getGlobalsAndPackages() ...
[09:31:14.555] Searching for globals...
[09:31:14.556] - globals found: [1] ‘{’
[09:31:14.556] Searching for globals ... DONE
[09:31:14.556] Resolving globals: FALSE
[09:31:14.556] 
[09:31:14.556] 
[09:31:14.556] getGlobalsAndPackages() ... DONE
[09:31:14.557] run() for ‘Future’ ...
[09:31:14.557] - state: ‘created’
[09:31:14.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.573]   - Field: ‘node’
[09:31:14.573]   - Field: ‘label’
[09:31:14.573]   - Field: ‘local’
[09:31:14.573]   - Field: ‘owner’
[09:31:14.573]   - Field: ‘envir’
[09:31:14.573]   - Field: ‘workers’
[09:31:14.573]   - Field: ‘packages’
[09:31:14.573]   - Field: ‘gc’
[09:31:14.573]   - Field: ‘conditions’
[09:31:14.573]   - Field: ‘persistent’
[09:31:14.574]   - Field: ‘expr’
[09:31:14.574]   - Field: ‘uuid’
[09:31:14.574]   - Field: ‘seed’
[09:31:14.574]   - Field: ‘version’
[09:31:14.574]   - Field: ‘result’
[09:31:14.574]   - Field: ‘asynchronous’
[09:31:14.574]   - Field: ‘calls’
[09:31:14.574]   - Field: ‘globals’
[09:31:14.574]   - Field: ‘stdout’
[09:31:14.574]   - Field: ‘earlySignal’
[09:31:14.574]   - Field: ‘lazy’
[09:31:14.575]   - Field: ‘state’
[09:31:14.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.575] - Launch lazy future ...
[09:31:14.575] Packages needed by the future expression (n = 0): <none>
[09:31:14.575] Packages needed by future strategies (n = 0): <none>
[09:31:14.576] {
[09:31:14.576]     {
[09:31:14.576]         {
[09:31:14.576]             ...future.startTime <- base::Sys.time()
[09:31:14.576]             {
[09:31:14.576]                 {
[09:31:14.576]                   {
[09:31:14.576]                     {
[09:31:14.576]                       base::local({
[09:31:14.576]                         has_future <- base::requireNamespace("future", 
[09:31:14.576]                           quietly = TRUE)
[09:31:14.576]                         if (has_future) {
[09:31:14.576]                           ns <- base::getNamespace("future")
[09:31:14.576]                           version <- ns[[".package"]][["version"]]
[09:31:14.576]                           if (is.null(version)) 
[09:31:14.576]                             version <- utils::packageVersion("future")
[09:31:14.576]                         }
[09:31:14.576]                         else {
[09:31:14.576]                           version <- NULL
[09:31:14.576]                         }
[09:31:14.576]                         if (!has_future || version < "1.8.0") {
[09:31:14.576]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.576]                             "", base::R.version$version.string), 
[09:31:14.576]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.576]                               "release", "version")], collapse = " "), 
[09:31:14.576]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.576]                             info)
[09:31:14.576]                           info <- base::paste(info, collapse = "; ")
[09:31:14.576]                           if (!has_future) {
[09:31:14.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.576]                               info)
[09:31:14.576]                           }
[09:31:14.576]                           else {
[09:31:14.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.576]                               info, version)
[09:31:14.576]                           }
[09:31:14.576]                           base::stop(msg)
[09:31:14.576]                         }
[09:31:14.576]                       })
[09:31:14.576]                     }
[09:31:14.576]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.576]                     base::options(mc.cores = 1L)
[09:31:14.576]                   }
[09:31:14.576]                   ...future.strategy.old <- future::plan("list")
[09:31:14.576]                   options(future.plan = NULL)
[09:31:14.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.576]                 }
[09:31:14.576]                 ...future.workdir <- getwd()
[09:31:14.576]             }
[09:31:14.576]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.576]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.576]         }
[09:31:14.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.576]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.576]             base::names(...future.oldOptions))
[09:31:14.576]     }
[09:31:14.576]     if (FALSE) {
[09:31:14.576]     }
[09:31:14.576]     else {
[09:31:14.576]         if (TRUE) {
[09:31:14.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.576]                 open = "w")
[09:31:14.576]         }
[09:31:14.576]         else {
[09:31:14.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.576]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.576]         }
[09:31:14.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.576]             base::sink(type = "output", split = FALSE)
[09:31:14.576]             base::close(...future.stdout)
[09:31:14.576]         }, add = TRUE)
[09:31:14.576]     }
[09:31:14.576]     ...future.frame <- base::sys.nframe()
[09:31:14.576]     ...future.conditions <- base::list()
[09:31:14.576]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.576]     if (FALSE) {
[09:31:14.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.576]     }
[09:31:14.576]     ...future.result <- base::tryCatch({
[09:31:14.576]         base::withCallingHandlers({
[09:31:14.576]             ...future.value <- base::withVisible(base::local({
[09:31:14.576]                 ...future.makeSendCondition <- base::local({
[09:31:14.576]                   sendCondition <- NULL
[09:31:14.576]                   function(frame = 1L) {
[09:31:14.576]                     if (is.function(sendCondition)) 
[09:31:14.576]                       return(sendCondition)
[09:31:14.576]                     ns <- getNamespace("parallel")
[09:31:14.576]                     if (exists("sendData", mode = "function", 
[09:31:14.576]                       envir = ns)) {
[09:31:14.576]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.576]                         envir = ns)
[09:31:14.576]                       envir <- sys.frame(frame)
[09:31:14.576]                       master <- NULL
[09:31:14.576]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.576]                         !identical(envir, emptyenv())) {
[09:31:14.576]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.576]                           inherits = FALSE)) {
[09:31:14.576]                           master <- get("master", mode = "list", 
[09:31:14.576]                             envir = envir, inherits = FALSE)
[09:31:14.576]                           if (inherits(master, c("SOCKnode", 
[09:31:14.576]                             "SOCK0node"))) {
[09:31:14.576]                             sendCondition <<- function(cond) {
[09:31:14.576]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.576]                                 success = TRUE)
[09:31:14.576]                               parallel_sendData(master, data)
[09:31:14.576]                             }
[09:31:14.576]                             return(sendCondition)
[09:31:14.576]                           }
[09:31:14.576]                         }
[09:31:14.576]                         frame <- frame + 1L
[09:31:14.576]                         envir <- sys.frame(frame)
[09:31:14.576]                       }
[09:31:14.576]                     }
[09:31:14.576]                     sendCondition <<- function(cond) NULL
[09:31:14.576]                   }
[09:31:14.576]                 })
[09:31:14.576]                 withCallingHandlers({
[09:31:14.576]                   {
[09:31:14.576]                     4
[09:31:14.576]                   }
[09:31:14.576]                 }, immediateCondition = function(cond) {
[09:31:14.576]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.576]                   sendCondition(cond)
[09:31:14.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.576]                   {
[09:31:14.576]                     inherits <- base::inherits
[09:31:14.576]                     invokeRestart <- base::invokeRestart
[09:31:14.576]                     is.null <- base::is.null
[09:31:14.576]                     muffled <- FALSE
[09:31:14.576]                     if (inherits(cond, "message")) {
[09:31:14.576]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.576]                       if (muffled) 
[09:31:14.576]                         invokeRestart("muffleMessage")
[09:31:14.576]                     }
[09:31:14.576]                     else if (inherits(cond, "warning")) {
[09:31:14.576]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.576]                       if (muffled) 
[09:31:14.576]                         invokeRestart("muffleWarning")
[09:31:14.576]                     }
[09:31:14.576]                     else if (inherits(cond, "condition")) {
[09:31:14.576]                       if (!is.null(pattern)) {
[09:31:14.576]                         computeRestarts <- base::computeRestarts
[09:31:14.576]                         grepl <- base::grepl
[09:31:14.576]                         restarts <- computeRestarts(cond)
[09:31:14.576]                         for (restart in restarts) {
[09:31:14.576]                           name <- restart$name
[09:31:14.576]                           if (is.null(name)) 
[09:31:14.576]                             next
[09:31:14.576]                           if (!grepl(pattern, name)) 
[09:31:14.576]                             next
[09:31:14.576]                           invokeRestart(restart)
[09:31:14.576]                           muffled <- TRUE
[09:31:14.576]                           break
[09:31:14.576]                         }
[09:31:14.576]                       }
[09:31:14.576]                     }
[09:31:14.576]                     invisible(muffled)
[09:31:14.576]                   }
[09:31:14.576]                   muffleCondition(cond)
[09:31:14.576]                 })
[09:31:14.576]             }))
[09:31:14.576]             future::FutureResult(value = ...future.value$value, 
[09:31:14.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.576]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.576]                     ...future.globalenv.names))
[09:31:14.576]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.576]         }, condition = base::local({
[09:31:14.576]             c <- base::c
[09:31:14.576]             inherits <- base::inherits
[09:31:14.576]             invokeRestart <- base::invokeRestart
[09:31:14.576]             length <- base::length
[09:31:14.576]             list <- base::list
[09:31:14.576]             seq.int <- base::seq.int
[09:31:14.576]             signalCondition <- base::signalCondition
[09:31:14.576]             sys.calls <- base::sys.calls
[09:31:14.576]             `[[` <- base::`[[`
[09:31:14.576]             `+` <- base::`+`
[09:31:14.576]             `<<-` <- base::`<<-`
[09:31:14.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.576]                   3L)]
[09:31:14.576]             }
[09:31:14.576]             function(cond) {
[09:31:14.576]                 is_error <- inherits(cond, "error")
[09:31:14.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.576]                   NULL)
[09:31:14.576]                 if (is_error) {
[09:31:14.576]                   sessionInformation <- function() {
[09:31:14.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.576]                       search = base::search(), system = base::Sys.info())
[09:31:14.576]                   }
[09:31:14.576]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.576]                     cond$call), session = sessionInformation(), 
[09:31:14.576]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.576]                   signalCondition(cond)
[09:31:14.576]                 }
[09:31:14.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.576]                 "immediateCondition"))) {
[09:31:14.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.576]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.576]                   if (TRUE && !signal) {
[09:31:14.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.576]                     {
[09:31:14.576]                       inherits <- base::inherits
[09:31:14.576]                       invokeRestart <- base::invokeRestart
[09:31:14.576]                       is.null <- base::is.null
[09:31:14.576]                       muffled <- FALSE
[09:31:14.576]                       if (inherits(cond, "message")) {
[09:31:14.576]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.576]                         if (muffled) 
[09:31:14.576]                           invokeRestart("muffleMessage")
[09:31:14.576]                       }
[09:31:14.576]                       else if (inherits(cond, "warning")) {
[09:31:14.576]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.576]                         if (muffled) 
[09:31:14.576]                           invokeRestart("muffleWarning")
[09:31:14.576]                       }
[09:31:14.576]                       else if (inherits(cond, "condition")) {
[09:31:14.576]                         if (!is.null(pattern)) {
[09:31:14.576]                           computeRestarts <- base::computeRestarts
[09:31:14.576]                           grepl <- base::grepl
[09:31:14.576]                           restarts <- computeRestarts(cond)
[09:31:14.576]                           for (restart in restarts) {
[09:31:14.576]                             name <- restart$name
[09:31:14.576]                             if (is.null(name)) 
[09:31:14.576]                               next
[09:31:14.576]                             if (!grepl(pattern, name)) 
[09:31:14.576]                               next
[09:31:14.576]                             invokeRestart(restart)
[09:31:14.576]                             muffled <- TRUE
[09:31:14.576]                             break
[09:31:14.576]                           }
[09:31:14.576]                         }
[09:31:14.576]                       }
[09:31:14.576]                       invisible(muffled)
[09:31:14.576]                     }
[09:31:14.576]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.576]                   }
[09:31:14.576]                 }
[09:31:14.576]                 else {
[09:31:14.576]                   if (TRUE) {
[09:31:14.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.576]                     {
[09:31:14.576]                       inherits <- base::inherits
[09:31:14.576]                       invokeRestart <- base::invokeRestart
[09:31:14.576]                       is.null <- base::is.null
[09:31:14.576]                       muffled <- FALSE
[09:31:14.576]                       if (inherits(cond, "message")) {
[09:31:14.576]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.576]                         if (muffled) 
[09:31:14.576]                           invokeRestart("muffleMessage")
[09:31:14.576]                       }
[09:31:14.576]                       else if (inherits(cond, "warning")) {
[09:31:14.576]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.576]                         if (muffled) 
[09:31:14.576]                           invokeRestart("muffleWarning")
[09:31:14.576]                       }
[09:31:14.576]                       else if (inherits(cond, "condition")) {
[09:31:14.576]                         if (!is.null(pattern)) {
[09:31:14.576]                           computeRestarts <- base::computeRestarts
[09:31:14.576]                           grepl <- base::grepl
[09:31:14.576]                           restarts <- computeRestarts(cond)
[09:31:14.576]                           for (restart in restarts) {
[09:31:14.576]                             name <- restart$name
[09:31:14.576]                             if (is.null(name)) 
[09:31:14.576]                               next
[09:31:14.576]                             if (!grepl(pattern, name)) 
[09:31:14.576]                               next
[09:31:14.576]                             invokeRestart(restart)
[09:31:14.576]                             muffled <- TRUE
[09:31:14.576]                             break
[09:31:14.576]                           }
[09:31:14.576]                         }
[09:31:14.576]                       }
[09:31:14.576]                       invisible(muffled)
[09:31:14.576]                     }
[09:31:14.576]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.576]                   }
[09:31:14.576]                 }
[09:31:14.576]             }
[09:31:14.576]         }))
[09:31:14.576]     }, error = function(ex) {
[09:31:14.576]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.576]                 ...future.rng), started = ...future.startTime, 
[09:31:14.576]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.576]             version = "1.8"), class = "FutureResult")
[09:31:14.576]     }, finally = {
[09:31:14.576]         if (!identical(...future.workdir, getwd())) 
[09:31:14.576]             setwd(...future.workdir)
[09:31:14.576]         {
[09:31:14.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.576]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.576]             }
[09:31:14.576]             base::options(...future.oldOptions)
[09:31:14.576]             if (.Platform$OS.type == "windows") {
[09:31:14.576]                 old_names <- names(...future.oldEnvVars)
[09:31:14.576]                 envs <- base::Sys.getenv()
[09:31:14.576]                 names <- names(envs)
[09:31:14.576]                 common <- intersect(names, old_names)
[09:31:14.576]                 added <- setdiff(names, old_names)
[09:31:14.576]                 removed <- setdiff(old_names, names)
[09:31:14.576]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.576]                   envs[common]]
[09:31:14.576]                 NAMES <- toupper(changed)
[09:31:14.576]                 args <- list()
[09:31:14.576]                 for (kk in seq_along(NAMES)) {
[09:31:14.576]                   name <- changed[[kk]]
[09:31:14.576]                   NAME <- NAMES[[kk]]
[09:31:14.576]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.576]                     next
[09:31:14.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.576]                 }
[09:31:14.576]                 NAMES <- toupper(added)
[09:31:14.576]                 for (kk in seq_along(NAMES)) {
[09:31:14.576]                   name <- added[[kk]]
[09:31:14.576]                   NAME <- NAMES[[kk]]
[09:31:14.576]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.576]                     next
[09:31:14.576]                   args[[name]] <- ""
[09:31:14.576]                 }
[09:31:14.576]                 NAMES <- toupper(removed)
[09:31:14.576]                 for (kk in seq_along(NAMES)) {
[09:31:14.576]                   name <- removed[[kk]]
[09:31:14.576]                   NAME <- NAMES[[kk]]
[09:31:14.576]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.576]                     next
[09:31:14.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.576]                 }
[09:31:14.576]                 if (length(args) > 0) 
[09:31:14.576]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.576]             }
[09:31:14.576]             else {
[09:31:14.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.576]             }
[09:31:14.576]             {
[09:31:14.576]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.576]                   0L) {
[09:31:14.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.576]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.576]                   base::options(opts)
[09:31:14.576]                 }
[09:31:14.576]                 {
[09:31:14.576]                   {
[09:31:14.576]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.576]                     NULL
[09:31:14.576]                   }
[09:31:14.576]                   options(future.plan = NULL)
[09:31:14.576]                   if (is.na(NA_character_)) 
[09:31:14.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.576]                     .init = FALSE)
[09:31:14.576]                 }
[09:31:14.576]             }
[09:31:14.576]         }
[09:31:14.576]     })
[09:31:14.576]     if (TRUE) {
[09:31:14.576]         base::sink(type = "output", split = FALSE)
[09:31:14.576]         if (TRUE) {
[09:31:14.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.576]         }
[09:31:14.576]         else {
[09:31:14.576]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.576]         }
[09:31:14.576]         base::close(...future.stdout)
[09:31:14.576]         ...future.stdout <- NULL
[09:31:14.576]     }
[09:31:14.576]     ...future.result$conditions <- ...future.conditions
[09:31:14.576]     ...future.result$finished <- base::Sys.time()
[09:31:14.576]     ...future.result
[09:31:14.576] }
[09:31:14.578] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:14.588] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.589] - Validating connection of MultisessionFuture
[09:31:14.589] - received message: FutureResult
[09:31:14.589] - Received FutureResult
[09:31:14.589] - Erased future from FutureRegistry
[09:31:14.589] result() for ClusterFuture ...
[09:31:14.589] - result already collected: FutureResult
[09:31:14.589] result() for ClusterFuture ... done
[09:31:14.589] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.590] result() for ClusterFuture ...
[09:31:14.590] - result already collected: FutureResult
[09:31:14.590] result() for ClusterFuture ... done
[09:31:14.590] result() for ClusterFuture ...
[09:31:14.590] - result already collected: FutureResult
[09:31:14.590] result() for ClusterFuture ... done
[09:31:14.591] MultisessionFuture started
[09:31:14.591] - Launch lazy future ... done
[09:31:14.591] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a3cb482cc0> 
<environment: 0x55a3cb9db5f0> 
[09:31:14.593] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.593] - Validating connection of MultisessionFuture
[09:31:14.593] - received message: FutureResult
[09:31:14.593] - Received FutureResult
[09:31:14.593] - Erased future from FutureRegistry
[09:31:14.593] result() for ClusterFuture ...
[09:31:14.594] - result already collected: FutureResult
[09:31:14.594] result() for ClusterFuture ... done
[09:31:14.594] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.596] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.596] - Validating connection of MultisessionFuture
[09:31:14.596] - received message: FutureResult
[09:31:14.596] - Received FutureResult
[09:31:14.596] - Erased future from FutureRegistry
[09:31:14.596] result() for ClusterFuture ...
[09:31:14.597] - result already collected: FutureResult
[09:31:14.597] result() for ClusterFuture ... done
[09:31:14.597] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.598] resolve() on environment ...
[09:31:14.598]  recursive: 0
[09:31:14.598]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.599] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.599] - nx: 4
[09:31:14.599] - relay: TRUE
[09:31:14.599] - stdout: TRUE
[09:31:14.599] - signal: TRUE
[09:31:14.599] - resignal: FALSE
[09:31:14.599] - force: TRUE
[09:31:14.599] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.599] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.599]  - until=2
[09:31:14.599]  - relaying element #2
[09:31:14.599] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.600] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.600] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.600]  length: 3 (resolved future 1)
[09:31:14.600] Future #2
[09:31:14.600] result() for ClusterFuture ...
[09:31:14.600] - result already collected: FutureResult
[09:31:14.600] result() for ClusterFuture ... done
[09:31:14.600] result() for ClusterFuture ...
[09:31:14.600] - result already collected: FutureResult
[09:31:14.600] result() for ClusterFuture ... done
[09:31:14.600] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:14.601] - nx: 4
[09:31:14.601] - relay: TRUE
[09:31:14.601] - stdout: TRUE
[09:31:14.601] - signal: TRUE
[09:31:14.601] - resignal: FALSE
[09:31:14.601] - force: TRUE
[09:31:14.601] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.601] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.601]  - until=2
[09:31:14.601]  - relaying element #2
[09:31:14.601] result() for ClusterFuture ...
[09:31:14.601] - result already collected: FutureResult
[09:31:14.602] result() for ClusterFuture ... done
[09:31:14.602] result() for ClusterFuture ...
[09:31:14.602] - result already collected: FutureResult
[09:31:14.602] result() for ClusterFuture ... done
[09:31:14.602] result() for ClusterFuture ...
[09:31:14.602] - result already collected: FutureResult
[09:31:14.602] result() for ClusterFuture ... done
[09:31:14.602] result() for ClusterFuture ...
[09:31:14.602] - result already collected: FutureResult
[09:31:14.602] result() for ClusterFuture ... done
[09:31:14.602] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.603] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.603] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:14.603]  length: 2 (resolved future 2)
[09:31:14.603] Future #3
[09:31:14.603] result() for ClusterFuture ...
[09:31:14.603] - result already collected: FutureResult
[09:31:14.603] result() for ClusterFuture ... done
[09:31:14.603] result() for ClusterFuture ...
[09:31:14.603] - result already collected: FutureResult
[09:31:14.603] result() for ClusterFuture ... done
[09:31:14.603] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:14.604] - nx: 4
[09:31:14.604] - relay: TRUE
[09:31:14.604] - stdout: TRUE
[09:31:14.604] - signal: TRUE
[09:31:14.604] - resignal: FALSE
[09:31:14.604] - force: TRUE
[09:31:14.604] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.604] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.604]  - until=3
[09:31:14.604]  - relaying element #3
[09:31:14.604] result() for ClusterFuture ...
[09:31:14.604] - result already collected: FutureResult
[09:31:14.605] result() for ClusterFuture ... done
[09:31:14.605] result() for ClusterFuture ...
[09:31:14.605] - result already collected: FutureResult
[09:31:14.605] result() for ClusterFuture ... done
[09:31:14.605] result() for ClusterFuture ...
[09:31:14.605] - result already collected: FutureResult
[09:31:14.605] result() for ClusterFuture ... done
[09:31:14.605] result() for ClusterFuture ...
[09:31:14.605] - result already collected: FutureResult
[09:31:14.605] result() for ClusterFuture ... done
[09:31:14.605] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.605] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.606] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:14.606]  length: 1 (resolved future 3)
[09:31:14.606] Future #4
[09:31:14.606] result() for ClusterFuture ...
[09:31:14.606] - result already collected: FutureResult
[09:31:14.606] result() for ClusterFuture ... done
[09:31:14.606] result() for ClusterFuture ...
[09:31:14.606] - result already collected: FutureResult
[09:31:14.606] result() for ClusterFuture ... done
[09:31:14.606] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:14.607] - nx: 4
[09:31:14.607] - relay: TRUE
[09:31:14.607] - stdout: TRUE
[09:31:14.607] - signal: TRUE
[09:31:14.607] - resignal: FALSE
[09:31:14.607] - force: TRUE
[09:31:14.607] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.607] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.607]  - until=4
[09:31:14.607]  - relaying element #4
[09:31:14.607] result() for ClusterFuture ...
[09:31:14.607] - result already collected: FutureResult
[09:31:14.607] result() for ClusterFuture ... done
[09:31:14.608] result() for ClusterFuture ...
[09:31:14.608] - result already collected: FutureResult
[09:31:14.608] result() for ClusterFuture ... done
[09:31:14.608] result() for ClusterFuture ...
[09:31:14.608] - result already collected: FutureResult
[09:31:14.608] result() for ClusterFuture ... done
[09:31:14.608] result() for ClusterFuture ...
[09:31:14.608] - result already collected: FutureResult
[09:31:14.608] result() for ClusterFuture ... done
[09:31:14.608] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.608] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.609] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:14.609]  length: 0 (resolved future 4)
[09:31:14.609] Relaying remaining futures
[09:31:14.609] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.609] - nx: 4
[09:31:14.609] - relay: TRUE
[09:31:14.609] - stdout: TRUE
[09:31:14.609] - signal: TRUE
[09:31:14.609] - resignal: FALSE
[09:31:14.609] - force: TRUE
[09:31:14.609] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.609] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.610] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.610] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.610] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.610] resolve() on environment ... DONE
[09:31:14.610] result() for ClusterFuture ...
[09:31:14.610] - result already collected: FutureResult
[09:31:14.610] result() for ClusterFuture ... done
[09:31:14.610] result() for ClusterFuture ...
[09:31:14.610] - result already collected: FutureResult
[09:31:14.610] result() for ClusterFuture ... done
[09:31:14.611] result() for ClusterFuture ...
[09:31:14.611] - result already collected: FutureResult
[09:31:14.611] result() for ClusterFuture ... done
[09:31:14.611] result() for ClusterFuture ...
[09:31:14.611] - result already collected: FutureResult
[09:31:14.611] result() for ClusterFuture ... done
[09:31:14.611] result() for ClusterFuture ...
[09:31:14.611] - result already collected: FutureResult
[09:31:14.611] result() for ClusterFuture ... done
[09:31:14.611] result() for ClusterFuture ...
[09:31:14.611] - result already collected: FutureResult
[09:31:14.611] result() for ClusterFuture ... done
<environment: 0x55a3cbeed660> 
Dimensions: c(1, 6)
[09:31:14.612] getGlobalsAndPackages() ...
[09:31:14.612] Searching for globals...
[09:31:14.612] 
[09:31:14.612] Searching for globals ... DONE
[09:31:14.612] - globals: [0] <none>
[09:31:14.613] getGlobalsAndPackages() ... DONE
[09:31:14.613] run() for ‘Future’ ...
[09:31:14.613] - state: ‘created’
[09:31:14.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.627] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.627]   - Field: ‘node’
[09:31:14.628]   - Field: ‘label’
[09:31:14.628]   - Field: ‘local’
[09:31:14.628]   - Field: ‘owner’
[09:31:14.628]   - Field: ‘envir’
[09:31:14.628]   - Field: ‘workers’
[09:31:14.628]   - Field: ‘packages’
[09:31:14.628]   - Field: ‘gc’
[09:31:14.628]   - Field: ‘conditions’
[09:31:14.628]   - Field: ‘persistent’
[09:31:14.629]   - Field: ‘expr’
[09:31:14.629]   - Field: ‘uuid’
[09:31:14.629]   - Field: ‘seed’
[09:31:14.629]   - Field: ‘version’
[09:31:14.629]   - Field: ‘result’
[09:31:14.629]   - Field: ‘asynchronous’
[09:31:14.629]   - Field: ‘calls’
[09:31:14.629]   - Field: ‘globals’
[09:31:14.629]   - Field: ‘stdout’
[09:31:14.629]   - Field: ‘earlySignal’
[09:31:14.629]   - Field: ‘lazy’
[09:31:14.630]   - Field: ‘state’
[09:31:14.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.630] - Launch lazy future ...
[09:31:14.630] Packages needed by the future expression (n = 0): <none>
[09:31:14.630] Packages needed by future strategies (n = 0): <none>
[09:31:14.630] {
[09:31:14.630]     {
[09:31:14.630]         {
[09:31:14.630]             ...future.startTime <- base::Sys.time()
[09:31:14.630]             {
[09:31:14.630]                 {
[09:31:14.630]                   {
[09:31:14.630]                     {
[09:31:14.630]                       base::local({
[09:31:14.630]                         has_future <- base::requireNamespace("future", 
[09:31:14.630]                           quietly = TRUE)
[09:31:14.630]                         if (has_future) {
[09:31:14.630]                           ns <- base::getNamespace("future")
[09:31:14.630]                           version <- ns[[".package"]][["version"]]
[09:31:14.630]                           if (is.null(version)) 
[09:31:14.630]                             version <- utils::packageVersion("future")
[09:31:14.630]                         }
[09:31:14.630]                         else {
[09:31:14.630]                           version <- NULL
[09:31:14.630]                         }
[09:31:14.630]                         if (!has_future || version < "1.8.0") {
[09:31:14.630]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.630]                             "", base::R.version$version.string), 
[09:31:14.630]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.630]                               "release", "version")], collapse = " "), 
[09:31:14.630]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.630]                             info)
[09:31:14.630]                           info <- base::paste(info, collapse = "; ")
[09:31:14.630]                           if (!has_future) {
[09:31:14.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.630]                               info)
[09:31:14.630]                           }
[09:31:14.630]                           else {
[09:31:14.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.630]                               info, version)
[09:31:14.630]                           }
[09:31:14.630]                           base::stop(msg)
[09:31:14.630]                         }
[09:31:14.630]                       })
[09:31:14.630]                     }
[09:31:14.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.630]                     base::options(mc.cores = 1L)
[09:31:14.630]                   }
[09:31:14.630]                   ...future.strategy.old <- future::plan("list")
[09:31:14.630]                   options(future.plan = NULL)
[09:31:14.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.630]                 }
[09:31:14.630]                 ...future.workdir <- getwd()
[09:31:14.630]             }
[09:31:14.630]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.630]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.630]         }
[09:31:14.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.630]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.630]             base::names(...future.oldOptions))
[09:31:14.630]     }
[09:31:14.630]     if (FALSE) {
[09:31:14.630]     }
[09:31:14.630]     else {
[09:31:14.630]         if (TRUE) {
[09:31:14.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.630]                 open = "w")
[09:31:14.630]         }
[09:31:14.630]         else {
[09:31:14.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.630]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.630]         }
[09:31:14.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.630]             base::sink(type = "output", split = FALSE)
[09:31:14.630]             base::close(...future.stdout)
[09:31:14.630]         }, add = TRUE)
[09:31:14.630]     }
[09:31:14.630]     ...future.frame <- base::sys.nframe()
[09:31:14.630]     ...future.conditions <- base::list()
[09:31:14.630]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.630]     if (FALSE) {
[09:31:14.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.630]     }
[09:31:14.630]     ...future.result <- base::tryCatch({
[09:31:14.630]         base::withCallingHandlers({
[09:31:14.630]             ...future.value <- base::withVisible(base::local({
[09:31:14.630]                 ...future.makeSendCondition <- base::local({
[09:31:14.630]                   sendCondition <- NULL
[09:31:14.630]                   function(frame = 1L) {
[09:31:14.630]                     if (is.function(sendCondition)) 
[09:31:14.630]                       return(sendCondition)
[09:31:14.630]                     ns <- getNamespace("parallel")
[09:31:14.630]                     if (exists("sendData", mode = "function", 
[09:31:14.630]                       envir = ns)) {
[09:31:14.630]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.630]                         envir = ns)
[09:31:14.630]                       envir <- sys.frame(frame)
[09:31:14.630]                       master <- NULL
[09:31:14.630]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.630]                         !identical(envir, emptyenv())) {
[09:31:14.630]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.630]                           inherits = FALSE)) {
[09:31:14.630]                           master <- get("master", mode = "list", 
[09:31:14.630]                             envir = envir, inherits = FALSE)
[09:31:14.630]                           if (inherits(master, c("SOCKnode", 
[09:31:14.630]                             "SOCK0node"))) {
[09:31:14.630]                             sendCondition <<- function(cond) {
[09:31:14.630]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.630]                                 success = TRUE)
[09:31:14.630]                               parallel_sendData(master, data)
[09:31:14.630]                             }
[09:31:14.630]                             return(sendCondition)
[09:31:14.630]                           }
[09:31:14.630]                         }
[09:31:14.630]                         frame <- frame + 1L
[09:31:14.630]                         envir <- sys.frame(frame)
[09:31:14.630]                       }
[09:31:14.630]                     }
[09:31:14.630]                     sendCondition <<- function(cond) NULL
[09:31:14.630]                   }
[09:31:14.630]                 })
[09:31:14.630]                 withCallingHandlers({
[09:31:14.630]                   2
[09:31:14.630]                 }, immediateCondition = function(cond) {
[09:31:14.630]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.630]                   sendCondition(cond)
[09:31:14.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.630]                   {
[09:31:14.630]                     inherits <- base::inherits
[09:31:14.630]                     invokeRestart <- base::invokeRestart
[09:31:14.630]                     is.null <- base::is.null
[09:31:14.630]                     muffled <- FALSE
[09:31:14.630]                     if (inherits(cond, "message")) {
[09:31:14.630]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.630]                       if (muffled) 
[09:31:14.630]                         invokeRestart("muffleMessage")
[09:31:14.630]                     }
[09:31:14.630]                     else if (inherits(cond, "warning")) {
[09:31:14.630]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.630]                       if (muffled) 
[09:31:14.630]                         invokeRestart("muffleWarning")
[09:31:14.630]                     }
[09:31:14.630]                     else if (inherits(cond, "condition")) {
[09:31:14.630]                       if (!is.null(pattern)) {
[09:31:14.630]                         computeRestarts <- base::computeRestarts
[09:31:14.630]                         grepl <- base::grepl
[09:31:14.630]                         restarts <- computeRestarts(cond)
[09:31:14.630]                         for (restart in restarts) {
[09:31:14.630]                           name <- restart$name
[09:31:14.630]                           if (is.null(name)) 
[09:31:14.630]                             next
[09:31:14.630]                           if (!grepl(pattern, name)) 
[09:31:14.630]                             next
[09:31:14.630]                           invokeRestart(restart)
[09:31:14.630]                           muffled <- TRUE
[09:31:14.630]                           break
[09:31:14.630]                         }
[09:31:14.630]                       }
[09:31:14.630]                     }
[09:31:14.630]                     invisible(muffled)
[09:31:14.630]                   }
[09:31:14.630]                   muffleCondition(cond)
[09:31:14.630]                 })
[09:31:14.630]             }))
[09:31:14.630]             future::FutureResult(value = ...future.value$value, 
[09:31:14.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.630]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.630]                     ...future.globalenv.names))
[09:31:14.630]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.630]         }, condition = base::local({
[09:31:14.630]             c <- base::c
[09:31:14.630]             inherits <- base::inherits
[09:31:14.630]             invokeRestart <- base::invokeRestart
[09:31:14.630]             length <- base::length
[09:31:14.630]             list <- base::list
[09:31:14.630]             seq.int <- base::seq.int
[09:31:14.630]             signalCondition <- base::signalCondition
[09:31:14.630]             sys.calls <- base::sys.calls
[09:31:14.630]             `[[` <- base::`[[`
[09:31:14.630]             `+` <- base::`+`
[09:31:14.630]             `<<-` <- base::`<<-`
[09:31:14.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.630]                   3L)]
[09:31:14.630]             }
[09:31:14.630]             function(cond) {
[09:31:14.630]                 is_error <- inherits(cond, "error")
[09:31:14.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.630]                   NULL)
[09:31:14.630]                 if (is_error) {
[09:31:14.630]                   sessionInformation <- function() {
[09:31:14.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.630]                       search = base::search(), system = base::Sys.info())
[09:31:14.630]                   }
[09:31:14.630]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.630]                     cond$call), session = sessionInformation(), 
[09:31:14.630]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.630]                   signalCondition(cond)
[09:31:14.630]                 }
[09:31:14.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.630]                 "immediateCondition"))) {
[09:31:14.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.630]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.630]                   if (TRUE && !signal) {
[09:31:14.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.630]                     {
[09:31:14.630]                       inherits <- base::inherits
[09:31:14.630]                       invokeRestart <- base::invokeRestart
[09:31:14.630]                       is.null <- base::is.null
[09:31:14.630]                       muffled <- FALSE
[09:31:14.630]                       if (inherits(cond, "message")) {
[09:31:14.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.630]                         if (muffled) 
[09:31:14.630]                           invokeRestart("muffleMessage")
[09:31:14.630]                       }
[09:31:14.630]                       else if (inherits(cond, "warning")) {
[09:31:14.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.630]                         if (muffled) 
[09:31:14.630]                           invokeRestart("muffleWarning")
[09:31:14.630]                       }
[09:31:14.630]                       else if (inherits(cond, "condition")) {
[09:31:14.630]                         if (!is.null(pattern)) {
[09:31:14.630]                           computeRestarts <- base::computeRestarts
[09:31:14.630]                           grepl <- base::grepl
[09:31:14.630]                           restarts <- computeRestarts(cond)
[09:31:14.630]                           for (restart in restarts) {
[09:31:14.630]                             name <- restart$name
[09:31:14.630]                             if (is.null(name)) 
[09:31:14.630]                               next
[09:31:14.630]                             if (!grepl(pattern, name)) 
[09:31:14.630]                               next
[09:31:14.630]                             invokeRestart(restart)
[09:31:14.630]                             muffled <- TRUE
[09:31:14.630]                             break
[09:31:14.630]                           }
[09:31:14.630]                         }
[09:31:14.630]                       }
[09:31:14.630]                       invisible(muffled)
[09:31:14.630]                     }
[09:31:14.630]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.630]                   }
[09:31:14.630]                 }
[09:31:14.630]                 else {
[09:31:14.630]                   if (TRUE) {
[09:31:14.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.630]                     {
[09:31:14.630]                       inherits <- base::inherits
[09:31:14.630]                       invokeRestart <- base::invokeRestart
[09:31:14.630]                       is.null <- base::is.null
[09:31:14.630]                       muffled <- FALSE
[09:31:14.630]                       if (inherits(cond, "message")) {
[09:31:14.630]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.630]                         if (muffled) 
[09:31:14.630]                           invokeRestart("muffleMessage")
[09:31:14.630]                       }
[09:31:14.630]                       else if (inherits(cond, "warning")) {
[09:31:14.630]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.630]                         if (muffled) 
[09:31:14.630]                           invokeRestart("muffleWarning")
[09:31:14.630]                       }
[09:31:14.630]                       else if (inherits(cond, "condition")) {
[09:31:14.630]                         if (!is.null(pattern)) {
[09:31:14.630]                           computeRestarts <- base::computeRestarts
[09:31:14.630]                           grepl <- base::grepl
[09:31:14.630]                           restarts <- computeRestarts(cond)
[09:31:14.630]                           for (restart in restarts) {
[09:31:14.630]                             name <- restart$name
[09:31:14.630]                             if (is.null(name)) 
[09:31:14.630]                               next
[09:31:14.630]                             if (!grepl(pattern, name)) 
[09:31:14.630]                               next
[09:31:14.630]                             invokeRestart(restart)
[09:31:14.630]                             muffled <- TRUE
[09:31:14.630]                             break
[09:31:14.630]                           }
[09:31:14.630]                         }
[09:31:14.630]                       }
[09:31:14.630]                       invisible(muffled)
[09:31:14.630]                     }
[09:31:14.630]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.630]                   }
[09:31:14.630]                 }
[09:31:14.630]             }
[09:31:14.630]         }))
[09:31:14.630]     }, error = function(ex) {
[09:31:14.630]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.630]                 ...future.rng), started = ...future.startTime, 
[09:31:14.630]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.630]             version = "1.8"), class = "FutureResult")
[09:31:14.630]     }, finally = {
[09:31:14.630]         if (!identical(...future.workdir, getwd())) 
[09:31:14.630]             setwd(...future.workdir)
[09:31:14.630]         {
[09:31:14.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.630]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.630]             }
[09:31:14.630]             base::options(...future.oldOptions)
[09:31:14.630]             if (.Platform$OS.type == "windows") {
[09:31:14.630]                 old_names <- names(...future.oldEnvVars)
[09:31:14.630]                 envs <- base::Sys.getenv()
[09:31:14.630]                 names <- names(envs)
[09:31:14.630]                 common <- intersect(names, old_names)
[09:31:14.630]                 added <- setdiff(names, old_names)
[09:31:14.630]                 removed <- setdiff(old_names, names)
[09:31:14.630]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.630]                   envs[common]]
[09:31:14.630]                 NAMES <- toupper(changed)
[09:31:14.630]                 args <- list()
[09:31:14.630]                 for (kk in seq_along(NAMES)) {
[09:31:14.630]                   name <- changed[[kk]]
[09:31:14.630]                   NAME <- NAMES[[kk]]
[09:31:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.630]                     next
[09:31:14.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.630]                 }
[09:31:14.630]                 NAMES <- toupper(added)
[09:31:14.630]                 for (kk in seq_along(NAMES)) {
[09:31:14.630]                   name <- added[[kk]]
[09:31:14.630]                   NAME <- NAMES[[kk]]
[09:31:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.630]                     next
[09:31:14.630]                   args[[name]] <- ""
[09:31:14.630]                 }
[09:31:14.630]                 NAMES <- toupper(removed)
[09:31:14.630]                 for (kk in seq_along(NAMES)) {
[09:31:14.630]                   name <- removed[[kk]]
[09:31:14.630]                   NAME <- NAMES[[kk]]
[09:31:14.630]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.630]                     next
[09:31:14.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.630]                 }
[09:31:14.630]                 if (length(args) > 0) 
[09:31:14.630]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.630]             }
[09:31:14.630]             else {
[09:31:14.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.630]             }
[09:31:14.630]             {
[09:31:14.630]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.630]                   0L) {
[09:31:14.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.630]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.630]                   base::options(opts)
[09:31:14.630]                 }
[09:31:14.630]                 {
[09:31:14.630]                   {
[09:31:14.630]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.630]                     NULL
[09:31:14.630]                   }
[09:31:14.630]                   options(future.plan = NULL)
[09:31:14.630]                   if (is.na(NA_character_)) 
[09:31:14.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.630]                     .init = FALSE)
[09:31:14.630]                 }
[09:31:14.630]             }
[09:31:14.630]         }
[09:31:14.630]     })
[09:31:14.630]     if (TRUE) {
[09:31:14.630]         base::sink(type = "output", split = FALSE)
[09:31:14.630]         if (TRUE) {
[09:31:14.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.630]         }
[09:31:14.630]         else {
[09:31:14.630]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.630]         }
[09:31:14.630]         base::close(...future.stdout)
[09:31:14.630]         ...future.stdout <- NULL
[09:31:14.630]     }
[09:31:14.630]     ...future.result$conditions <- ...future.conditions
[09:31:14.630]     ...future.result$finished <- base::Sys.time()
[09:31:14.630]     ...future.result
[09:31:14.630] }
[09:31:14.634] MultisessionFuture started
[09:31:14.634] - Launch lazy future ... done
[09:31:14.634] run() for ‘MultisessionFuture’ ... done
[09:31:14.634] getGlobalsAndPackages() ...
[09:31:14.634] Searching for globals...
[09:31:14.634] 
[09:31:14.634] Searching for globals ... DONE
[09:31:14.635] - globals: [0] <none>
[09:31:14.635] getGlobalsAndPackages() ... DONE
[09:31:14.635] run() for ‘Future’ ...
[09:31:14.635] - state: ‘created’
[09:31:14.635] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.649] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.649]   - Field: ‘node’
[09:31:14.649]   - Field: ‘label’
[09:31:14.649]   - Field: ‘local’
[09:31:14.649]   - Field: ‘owner’
[09:31:14.649]   - Field: ‘envir’
[09:31:14.649]   - Field: ‘workers’
[09:31:14.650]   - Field: ‘packages’
[09:31:14.650]   - Field: ‘gc’
[09:31:14.650]   - Field: ‘conditions’
[09:31:14.650]   - Field: ‘persistent’
[09:31:14.650]   - Field: ‘expr’
[09:31:14.650]   - Field: ‘uuid’
[09:31:14.650]   - Field: ‘seed’
[09:31:14.650]   - Field: ‘version’
[09:31:14.650]   - Field: ‘result’
[09:31:14.650]   - Field: ‘asynchronous’
[09:31:14.650]   - Field: ‘calls’
[09:31:14.651]   - Field: ‘globals’
[09:31:14.651]   - Field: ‘stdout’
[09:31:14.651]   - Field: ‘earlySignal’
[09:31:14.651]   - Field: ‘lazy’
[09:31:14.651]   - Field: ‘state’
[09:31:14.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.651] - Launch lazy future ...
[09:31:14.651] Packages needed by the future expression (n = 0): <none>
[09:31:14.651] Packages needed by future strategies (n = 0): <none>
[09:31:14.652] {
[09:31:14.652]     {
[09:31:14.652]         {
[09:31:14.652]             ...future.startTime <- base::Sys.time()
[09:31:14.652]             {
[09:31:14.652]                 {
[09:31:14.652]                   {
[09:31:14.652]                     {
[09:31:14.652]                       base::local({
[09:31:14.652]                         has_future <- base::requireNamespace("future", 
[09:31:14.652]                           quietly = TRUE)
[09:31:14.652]                         if (has_future) {
[09:31:14.652]                           ns <- base::getNamespace("future")
[09:31:14.652]                           version <- ns[[".package"]][["version"]]
[09:31:14.652]                           if (is.null(version)) 
[09:31:14.652]                             version <- utils::packageVersion("future")
[09:31:14.652]                         }
[09:31:14.652]                         else {
[09:31:14.652]                           version <- NULL
[09:31:14.652]                         }
[09:31:14.652]                         if (!has_future || version < "1.8.0") {
[09:31:14.652]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.652]                             "", base::R.version$version.string), 
[09:31:14.652]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.652]                               "release", "version")], collapse = " "), 
[09:31:14.652]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.652]                             info)
[09:31:14.652]                           info <- base::paste(info, collapse = "; ")
[09:31:14.652]                           if (!has_future) {
[09:31:14.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.652]                               info)
[09:31:14.652]                           }
[09:31:14.652]                           else {
[09:31:14.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.652]                               info, version)
[09:31:14.652]                           }
[09:31:14.652]                           base::stop(msg)
[09:31:14.652]                         }
[09:31:14.652]                       })
[09:31:14.652]                     }
[09:31:14.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.652]                     base::options(mc.cores = 1L)
[09:31:14.652]                   }
[09:31:14.652]                   ...future.strategy.old <- future::plan("list")
[09:31:14.652]                   options(future.plan = NULL)
[09:31:14.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.652]                 }
[09:31:14.652]                 ...future.workdir <- getwd()
[09:31:14.652]             }
[09:31:14.652]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.652]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.652]         }
[09:31:14.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.652]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.652]             base::names(...future.oldOptions))
[09:31:14.652]     }
[09:31:14.652]     if (FALSE) {
[09:31:14.652]     }
[09:31:14.652]     else {
[09:31:14.652]         if (TRUE) {
[09:31:14.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.652]                 open = "w")
[09:31:14.652]         }
[09:31:14.652]         else {
[09:31:14.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.652]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.652]         }
[09:31:14.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.652]             base::sink(type = "output", split = FALSE)
[09:31:14.652]             base::close(...future.stdout)
[09:31:14.652]         }, add = TRUE)
[09:31:14.652]     }
[09:31:14.652]     ...future.frame <- base::sys.nframe()
[09:31:14.652]     ...future.conditions <- base::list()
[09:31:14.652]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.652]     if (FALSE) {
[09:31:14.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.652]     }
[09:31:14.652]     ...future.result <- base::tryCatch({
[09:31:14.652]         base::withCallingHandlers({
[09:31:14.652]             ...future.value <- base::withVisible(base::local({
[09:31:14.652]                 ...future.makeSendCondition <- base::local({
[09:31:14.652]                   sendCondition <- NULL
[09:31:14.652]                   function(frame = 1L) {
[09:31:14.652]                     if (is.function(sendCondition)) 
[09:31:14.652]                       return(sendCondition)
[09:31:14.652]                     ns <- getNamespace("parallel")
[09:31:14.652]                     if (exists("sendData", mode = "function", 
[09:31:14.652]                       envir = ns)) {
[09:31:14.652]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.652]                         envir = ns)
[09:31:14.652]                       envir <- sys.frame(frame)
[09:31:14.652]                       master <- NULL
[09:31:14.652]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.652]                         !identical(envir, emptyenv())) {
[09:31:14.652]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.652]                           inherits = FALSE)) {
[09:31:14.652]                           master <- get("master", mode = "list", 
[09:31:14.652]                             envir = envir, inherits = FALSE)
[09:31:14.652]                           if (inherits(master, c("SOCKnode", 
[09:31:14.652]                             "SOCK0node"))) {
[09:31:14.652]                             sendCondition <<- function(cond) {
[09:31:14.652]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.652]                                 success = TRUE)
[09:31:14.652]                               parallel_sendData(master, data)
[09:31:14.652]                             }
[09:31:14.652]                             return(sendCondition)
[09:31:14.652]                           }
[09:31:14.652]                         }
[09:31:14.652]                         frame <- frame + 1L
[09:31:14.652]                         envir <- sys.frame(frame)
[09:31:14.652]                       }
[09:31:14.652]                     }
[09:31:14.652]                     sendCondition <<- function(cond) NULL
[09:31:14.652]                   }
[09:31:14.652]                 })
[09:31:14.652]                 withCallingHandlers({
[09:31:14.652]                   NULL
[09:31:14.652]                 }, immediateCondition = function(cond) {
[09:31:14.652]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.652]                   sendCondition(cond)
[09:31:14.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.652]                   {
[09:31:14.652]                     inherits <- base::inherits
[09:31:14.652]                     invokeRestart <- base::invokeRestart
[09:31:14.652]                     is.null <- base::is.null
[09:31:14.652]                     muffled <- FALSE
[09:31:14.652]                     if (inherits(cond, "message")) {
[09:31:14.652]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.652]                       if (muffled) 
[09:31:14.652]                         invokeRestart("muffleMessage")
[09:31:14.652]                     }
[09:31:14.652]                     else if (inherits(cond, "warning")) {
[09:31:14.652]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.652]                       if (muffled) 
[09:31:14.652]                         invokeRestart("muffleWarning")
[09:31:14.652]                     }
[09:31:14.652]                     else if (inherits(cond, "condition")) {
[09:31:14.652]                       if (!is.null(pattern)) {
[09:31:14.652]                         computeRestarts <- base::computeRestarts
[09:31:14.652]                         grepl <- base::grepl
[09:31:14.652]                         restarts <- computeRestarts(cond)
[09:31:14.652]                         for (restart in restarts) {
[09:31:14.652]                           name <- restart$name
[09:31:14.652]                           if (is.null(name)) 
[09:31:14.652]                             next
[09:31:14.652]                           if (!grepl(pattern, name)) 
[09:31:14.652]                             next
[09:31:14.652]                           invokeRestart(restart)
[09:31:14.652]                           muffled <- TRUE
[09:31:14.652]                           break
[09:31:14.652]                         }
[09:31:14.652]                       }
[09:31:14.652]                     }
[09:31:14.652]                     invisible(muffled)
[09:31:14.652]                   }
[09:31:14.652]                   muffleCondition(cond)
[09:31:14.652]                 })
[09:31:14.652]             }))
[09:31:14.652]             future::FutureResult(value = ...future.value$value, 
[09:31:14.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.652]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.652]                     ...future.globalenv.names))
[09:31:14.652]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.652]         }, condition = base::local({
[09:31:14.652]             c <- base::c
[09:31:14.652]             inherits <- base::inherits
[09:31:14.652]             invokeRestart <- base::invokeRestart
[09:31:14.652]             length <- base::length
[09:31:14.652]             list <- base::list
[09:31:14.652]             seq.int <- base::seq.int
[09:31:14.652]             signalCondition <- base::signalCondition
[09:31:14.652]             sys.calls <- base::sys.calls
[09:31:14.652]             `[[` <- base::`[[`
[09:31:14.652]             `+` <- base::`+`
[09:31:14.652]             `<<-` <- base::`<<-`
[09:31:14.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.652]                   3L)]
[09:31:14.652]             }
[09:31:14.652]             function(cond) {
[09:31:14.652]                 is_error <- inherits(cond, "error")
[09:31:14.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.652]                   NULL)
[09:31:14.652]                 if (is_error) {
[09:31:14.652]                   sessionInformation <- function() {
[09:31:14.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.652]                       search = base::search(), system = base::Sys.info())
[09:31:14.652]                   }
[09:31:14.652]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.652]                     cond$call), session = sessionInformation(), 
[09:31:14.652]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.652]                   signalCondition(cond)
[09:31:14.652]                 }
[09:31:14.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.652]                 "immediateCondition"))) {
[09:31:14.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.652]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.652]                   if (TRUE && !signal) {
[09:31:14.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.652]                     {
[09:31:14.652]                       inherits <- base::inherits
[09:31:14.652]                       invokeRestart <- base::invokeRestart
[09:31:14.652]                       is.null <- base::is.null
[09:31:14.652]                       muffled <- FALSE
[09:31:14.652]                       if (inherits(cond, "message")) {
[09:31:14.652]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.652]                         if (muffled) 
[09:31:14.652]                           invokeRestart("muffleMessage")
[09:31:14.652]                       }
[09:31:14.652]                       else if (inherits(cond, "warning")) {
[09:31:14.652]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.652]                         if (muffled) 
[09:31:14.652]                           invokeRestart("muffleWarning")
[09:31:14.652]                       }
[09:31:14.652]                       else if (inherits(cond, "condition")) {
[09:31:14.652]                         if (!is.null(pattern)) {
[09:31:14.652]                           computeRestarts <- base::computeRestarts
[09:31:14.652]                           grepl <- base::grepl
[09:31:14.652]                           restarts <- computeRestarts(cond)
[09:31:14.652]                           for (restart in restarts) {
[09:31:14.652]                             name <- restart$name
[09:31:14.652]                             if (is.null(name)) 
[09:31:14.652]                               next
[09:31:14.652]                             if (!grepl(pattern, name)) 
[09:31:14.652]                               next
[09:31:14.652]                             invokeRestart(restart)
[09:31:14.652]                             muffled <- TRUE
[09:31:14.652]                             break
[09:31:14.652]                           }
[09:31:14.652]                         }
[09:31:14.652]                       }
[09:31:14.652]                       invisible(muffled)
[09:31:14.652]                     }
[09:31:14.652]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.652]                   }
[09:31:14.652]                 }
[09:31:14.652]                 else {
[09:31:14.652]                   if (TRUE) {
[09:31:14.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.652]                     {
[09:31:14.652]                       inherits <- base::inherits
[09:31:14.652]                       invokeRestart <- base::invokeRestart
[09:31:14.652]                       is.null <- base::is.null
[09:31:14.652]                       muffled <- FALSE
[09:31:14.652]                       if (inherits(cond, "message")) {
[09:31:14.652]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.652]                         if (muffled) 
[09:31:14.652]                           invokeRestart("muffleMessage")
[09:31:14.652]                       }
[09:31:14.652]                       else if (inherits(cond, "warning")) {
[09:31:14.652]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.652]                         if (muffled) 
[09:31:14.652]                           invokeRestart("muffleWarning")
[09:31:14.652]                       }
[09:31:14.652]                       else if (inherits(cond, "condition")) {
[09:31:14.652]                         if (!is.null(pattern)) {
[09:31:14.652]                           computeRestarts <- base::computeRestarts
[09:31:14.652]                           grepl <- base::grepl
[09:31:14.652]                           restarts <- computeRestarts(cond)
[09:31:14.652]                           for (restart in restarts) {
[09:31:14.652]                             name <- restart$name
[09:31:14.652]                             if (is.null(name)) 
[09:31:14.652]                               next
[09:31:14.652]                             if (!grepl(pattern, name)) 
[09:31:14.652]                               next
[09:31:14.652]                             invokeRestart(restart)
[09:31:14.652]                             muffled <- TRUE
[09:31:14.652]                             break
[09:31:14.652]                           }
[09:31:14.652]                         }
[09:31:14.652]                       }
[09:31:14.652]                       invisible(muffled)
[09:31:14.652]                     }
[09:31:14.652]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.652]                   }
[09:31:14.652]                 }
[09:31:14.652]             }
[09:31:14.652]         }))
[09:31:14.652]     }, error = function(ex) {
[09:31:14.652]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.652]                 ...future.rng), started = ...future.startTime, 
[09:31:14.652]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.652]             version = "1.8"), class = "FutureResult")
[09:31:14.652]     }, finally = {
[09:31:14.652]         if (!identical(...future.workdir, getwd())) 
[09:31:14.652]             setwd(...future.workdir)
[09:31:14.652]         {
[09:31:14.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.652]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.652]             }
[09:31:14.652]             base::options(...future.oldOptions)
[09:31:14.652]             if (.Platform$OS.type == "windows") {
[09:31:14.652]                 old_names <- names(...future.oldEnvVars)
[09:31:14.652]                 envs <- base::Sys.getenv()
[09:31:14.652]                 names <- names(envs)
[09:31:14.652]                 common <- intersect(names, old_names)
[09:31:14.652]                 added <- setdiff(names, old_names)
[09:31:14.652]                 removed <- setdiff(old_names, names)
[09:31:14.652]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.652]                   envs[common]]
[09:31:14.652]                 NAMES <- toupper(changed)
[09:31:14.652]                 args <- list()
[09:31:14.652]                 for (kk in seq_along(NAMES)) {
[09:31:14.652]                   name <- changed[[kk]]
[09:31:14.652]                   NAME <- NAMES[[kk]]
[09:31:14.652]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.652]                     next
[09:31:14.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.652]                 }
[09:31:14.652]                 NAMES <- toupper(added)
[09:31:14.652]                 for (kk in seq_along(NAMES)) {
[09:31:14.652]                   name <- added[[kk]]
[09:31:14.652]                   NAME <- NAMES[[kk]]
[09:31:14.652]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.652]                     next
[09:31:14.652]                   args[[name]] <- ""
[09:31:14.652]                 }
[09:31:14.652]                 NAMES <- toupper(removed)
[09:31:14.652]                 for (kk in seq_along(NAMES)) {
[09:31:14.652]                   name <- removed[[kk]]
[09:31:14.652]                   NAME <- NAMES[[kk]]
[09:31:14.652]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.652]                     next
[09:31:14.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.652]                 }
[09:31:14.652]                 if (length(args) > 0) 
[09:31:14.652]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.652]             }
[09:31:14.652]             else {
[09:31:14.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.652]             }
[09:31:14.652]             {
[09:31:14.652]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.652]                   0L) {
[09:31:14.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.652]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.652]                   base::options(opts)
[09:31:14.652]                 }
[09:31:14.652]                 {
[09:31:14.652]                   {
[09:31:14.652]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.652]                     NULL
[09:31:14.652]                   }
[09:31:14.652]                   options(future.plan = NULL)
[09:31:14.652]                   if (is.na(NA_character_)) 
[09:31:14.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.652]                     .init = FALSE)
[09:31:14.652]                 }
[09:31:14.652]             }
[09:31:14.652]         }
[09:31:14.652]     })
[09:31:14.652]     if (TRUE) {
[09:31:14.652]         base::sink(type = "output", split = FALSE)
[09:31:14.652]         if (TRUE) {
[09:31:14.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.652]         }
[09:31:14.652]         else {
[09:31:14.652]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.652]         }
[09:31:14.652]         base::close(...future.stdout)
[09:31:14.652]         ...future.stdout <- NULL
[09:31:14.652]     }
[09:31:14.652]     ...future.result$conditions <- ...future.conditions
[09:31:14.652]     ...future.result$finished <- base::Sys.time()
[09:31:14.652]     ...future.result
[09:31:14.652] }
[09:31:14.655] MultisessionFuture started
[09:31:14.655] - Launch lazy future ... done
[09:31:14.655] run() for ‘MultisessionFuture’ ... done
[09:31:14.656] getGlobalsAndPackages() ...
[09:31:14.656] Searching for globals...
[09:31:14.662] - globals found: [1] ‘{’
[09:31:14.662] Searching for globals ... DONE
[09:31:14.662] Resolving globals: FALSE
[09:31:14.663] 
[09:31:14.663] 
[09:31:14.663] getGlobalsAndPackages() ... DONE
[09:31:14.663] run() for ‘Future’ ...
[09:31:14.663] - state: ‘created’
[09:31:14.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.677]   - Field: ‘node’
[09:31:14.677]   - Field: ‘label’
[09:31:14.677]   - Field: ‘local’
[09:31:14.677]   - Field: ‘owner’
[09:31:14.677]   - Field: ‘envir’
[09:31:14.677]   - Field: ‘workers’
[09:31:14.677]   - Field: ‘packages’
[09:31:14.678]   - Field: ‘gc’
[09:31:14.678]   - Field: ‘conditions’
[09:31:14.678]   - Field: ‘persistent’
[09:31:14.678]   - Field: ‘expr’
[09:31:14.678]   - Field: ‘uuid’
[09:31:14.678]   - Field: ‘seed’
[09:31:14.678]   - Field: ‘version’
[09:31:14.678]   - Field: ‘result’
[09:31:14.678]   - Field: ‘asynchronous’
[09:31:14.678]   - Field: ‘calls’
[09:31:14.678]   - Field: ‘globals’
[09:31:14.679]   - Field: ‘stdout’
[09:31:14.679]   - Field: ‘earlySignal’
[09:31:14.679]   - Field: ‘lazy’
[09:31:14.679]   - Field: ‘state’
[09:31:14.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.679] - Launch lazy future ...
[09:31:14.679] Packages needed by the future expression (n = 0): <none>
[09:31:14.679] Packages needed by future strategies (n = 0): <none>
[09:31:14.680] {
[09:31:14.680]     {
[09:31:14.680]         {
[09:31:14.680]             ...future.startTime <- base::Sys.time()
[09:31:14.680]             {
[09:31:14.680]                 {
[09:31:14.680]                   {
[09:31:14.680]                     {
[09:31:14.680]                       base::local({
[09:31:14.680]                         has_future <- base::requireNamespace("future", 
[09:31:14.680]                           quietly = TRUE)
[09:31:14.680]                         if (has_future) {
[09:31:14.680]                           ns <- base::getNamespace("future")
[09:31:14.680]                           version <- ns[[".package"]][["version"]]
[09:31:14.680]                           if (is.null(version)) 
[09:31:14.680]                             version <- utils::packageVersion("future")
[09:31:14.680]                         }
[09:31:14.680]                         else {
[09:31:14.680]                           version <- NULL
[09:31:14.680]                         }
[09:31:14.680]                         if (!has_future || version < "1.8.0") {
[09:31:14.680]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.680]                             "", base::R.version$version.string), 
[09:31:14.680]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.680]                               "release", "version")], collapse = " "), 
[09:31:14.680]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.680]                             info)
[09:31:14.680]                           info <- base::paste(info, collapse = "; ")
[09:31:14.680]                           if (!has_future) {
[09:31:14.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.680]                               info)
[09:31:14.680]                           }
[09:31:14.680]                           else {
[09:31:14.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.680]                               info, version)
[09:31:14.680]                           }
[09:31:14.680]                           base::stop(msg)
[09:31:14.680]                         }
[09:31:14.680]                       })
[09:31:14.680]                     }
[09:31:14.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.680]                     base::options(mc.cores = 1L)
[09:31:14.680]                   }
[09:31:14.680]                   ...future.strategy.old <- future::plan("list")
[09:31:14.680]                   options(future.plan = NULL)
[09:31:14.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.680]                 }
[09:31:14.680]                 ...future.workdir <- getwd()
[09:31:14.680]             }
[09:31:14.680]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.680]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.680]         }
[09:31:14.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.680]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.680]             base::names(...future.oldOptions))
[09:31:14.680]     }
[09:31:14.680]     if (FALSE) {
[09:31:14.680]     }
[09:31:14.680]     else {
[09:31:14.680]         if (TRUE) {
[09:31:14.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.680]                 open = "w")
[09:31:14.680]         }
[09:31:14.680]         else {
[09:31:14.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.680]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.680]         }
[09:31:14.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.680]             base::sink(type = "output", split = FALSE)
[09:31:14.680]             base::close(...future.stdout)
[09:31:14.680]         }, add = TRUE)
[09:31:14.680]     }
[09:31:14.680]     ...future.frame <- base::sys.nframe()
[09:31:14.680]     ...future.conditions <- base::list()
[09:31:14.680]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.680]     if (FALSE) {
[09:31:14.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.680]     }
[09:31:14.680]     ...future.result <- base::tryCatch({
[09:31:14.680]         base::withCallingHandlers({
[09:31:14.680]             ...future.value <- base::withVisible(base::local({
[09:31:14.680]                 ...future.makeSendCondition <- base::local({
[09:31:14.680]                   sendCondition <- NULL
[09:31:14.680]                   function(frame = 1L) {
[09:31:14.680]                     if (is.function(sendCondition)) 
[09:31:14.680]                       return(sendCondition)
[09:31:14.680]                     ns <- getNamespace("parallel")
[09:31:14.680]                     if (exists("sendData", mode = "function", 
[09:31:14.680]                       envir = ns)) {
[09:31:14.680]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.680]                         envir = ns)
[09:31:14.680]                       envir <- sys.frame(frame)
[09:31:14.680]                       master <- NULL
[09:31:14.680]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.680]                         !identical(envir, emptyenv())) {
[09:31:14.680]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.680]                           inherits = FALSE)) {
[09:31:14.680]                           master <- get("master", mode = "list", 
[09:31:14.680]                             envir = envir, inherits = FALSE)
[09:31:14.680]                           if (inherits(master, c("SOCKnode", 
[09:31:14.680]                             "SOCK0node"))) {
[09:31:14.680]                             sendCondition <<- function(cond) {
[09:31:14.680]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.680]                                 success = TRUE)
[09:31:14.680]                               parallel_sendData(master, data)
[09:31:14.680]                             }
[09:31:14.680]                             return(sendCondition)
[09:31:14.680]                           }
[09:31:14.680]                         }
[09:31:14.680]                         frame <- frame + 1L
[09:31:14.680]                         envir <- sys.frame(frame)
[09:31:14.680]                       }
[09:31:14.680]                     }
[09:31:14.680]                     sendCondition <<- function(cond) NULL
[09:31:14.680]                   }
[09:31:14.680]                 })
[09:31:14.680]                 withCallingHandlers({
[09:31:14.680]                   {
[09:31:14.680]                     4
[09:31:14.680]                   }
[09:31:14.680]                 }, immediateCondition = function(cond) {
[09:31:14.680]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.680]                   sendCondition(cond)
[09:31:14.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.680]                   {
[09:31:14.680]                     inherits <- base::inherits
[09:31:14.680]                     invokeRestart <- base::invokeRestart
[09:31:14.680]                     is.null <- base::is.null
[09:31:14.680]                     muffled <- FALSE
[09:31:14.680]                     if (inherits(cond, "message")) {
[09:31:14.680]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.680]                       if (muffled) 
[09:31:14.680]                         invokeRestart("muffleMessage")
[09:31:14.680]                     }
[09:31:14.680]                     else if (inherits(cond, "warning")) {
[09:31:14.680]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.680]                       if (muffled) 
[09:31:14.680]                         invokeRestart("muffleWarning")
[09:31:14.680]                     }
[09:31:14.680]                     else if (inherits(cond, "condition")) {
[09:31:14.680]                       if (!is.null(pattern)) {
[09:31:14.680]                         computeRestarts <- base::computeRestarts
[09:31:14.680]                         grepl <- base::grepl
[09:31:14.680]                         restarts <- computeRestarts(cond)
[09:31:14.680]                         for (restart in restarts) {
[09:31:14.680]                           name <- restart$name
[09:31:14.680]                           if (is.null(name)) 
[09:31:14.680]                             next
[09:31:14.680]                           if (!grepl(pattern, name)) 
[09:31:14.680]                             next
[09:31:14.680]                           invokeRestart(restart)
[09:31:14.680]                           muffled <- TRUE
[09:31:14.680]                           break
[09:31:14.680]                         }
[09:31:14.680]                       }
[09:31:14.680]                     }
[09:31:14.680]                     invisible(muffled)
[09:31:14.680]                   }
[09:31:14.680]                   muffleCondition(cond)
[09:31:14.680]                 })
[09:31:14.680]             }))
[09:31:14.680]             future::FutureResult(value = ...future.value$value, 
[09:31:14.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.680]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.680]                     ...future.globalenv.names))
[09:31:14.680]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.680]         }, condition = base::local({
[09:31:14.680]             c <- base::c
[09:31:14.680]             inherits <- base::inherits
[09:31:14.680]             invokeRestart <- base::invokeRestart
[09:31:14.680]             length <- base::length
[09:31:14.680]             list <- base::list
[09:31:14.680]             seq.int <- base::seq.int
[09:31:14.680]             signalCondition <- base::signalCondition
[09:31:14.680]             sys.calls <- base::sys.calls
[09:31:14.680]             `[[` <- base::`[[`
[09:31:14.680]             `+` <- base::`+`
[09:31:14.680]             `<<-` <- base::`<<-`
[09:31:14.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.680]                   3L)]
[09:31:14.680]             }
[09:31:14.680]             function(cond) {
[09:31:14.680]                 is_error <- inherits(cond, "error")
[09:31:14.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.680]                   NULL)
[09:31:14.680]                 if (is_error) {
[09:31:14.680]                   sessionInformation <- function() {
[09:31:14.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.680]                       search = base::search(), system = base::Sys.info())
[09:31:14.680]                   }
[09:31:14.680]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.680]                     cond$call), session = sessionInformation(), 
[09:31:14.680]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.680]                   signalCondition(cond)
[09:31:14.680]                 }
[09:31:14.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.680]                 "immediateCondition"))) {
[09:31:14.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.680]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.680]                   if (TRUE && !signal) {
[09:31:14.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.680]                     {
[09:31:14.680]                       inherits <- base::inherits
[09:31:14.680]                       invokeRestart <- base::invokeRestart
[09:31:14.680]                       is.null <- base::is.null
[09:31:14.680]                       muffled <- FALSE
[09:31:14.680]                       if (inherits(cond, "message")) {
[09:31:14.680]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.680]                         if (muffled) 
[09:31:14.680]                           invokeRestart("muffleMessage")
[09:31:14.680]                       }
[09:31:14.680]                       else if (inherits(cond, "warning")) {
[09:31:14.680]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.680]                         if (muffled) 
[09:31:14.680]                           invokeRestart("muffleWarning")
[09:31:14.680]                       }
[09:31:14.680]                       else if (inherits(cond, "condition")) {
[09:31:14.680]                         if (!is.null(pattern)) {
[09:31:14.680]                           computeRestarts <- base::computeRestarts
[09:31:14.680]                           grepl <- base::grepl
[09:31:14.680]                           restarts <- computeRestarts(cond)
[09:31:14.680]                           for (restart in restarts) {
[09:31:14.680]                             name <- restart$name
[09:31:14.680]                             if (is.null(name)) 
[09:31:14.680]                               next
[09:31:14.680]                             if (!grepl(pattern, name)) 
[09:31:14.680]                               next
[09:31:14.680]                             invokeRestart(restart)
[09:31:14.680]                             muffled <- TRUE
[09:31:14.680]                             break
[09:31:14.680]                           }
[09:31:14.680]                         }
[09:31:14.680]                       }
[09:31:14.680]                       invisible(muffled)
[09:31:14.680]                     }
[09:31:14.680]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.680]                   }
[09:31:14.680]                 }
[09:31:14.680]                 else {
[09:31:14.680]                   if (TRUE) {
[09:31:14.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.680]                     {
[09:31:14.680]                       inherits <- base::inherits
[09:31:14.680]                       invokeRestart <- base::invokeRestart
[09:31:14.680]                       is.null <- base::is.null
[09:31:14.680]                       muffled <- FALSE
[09:31:14.680]                       if (inherits(cond, "message")) {
[09:31:14.680]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.680]                         if (muffled) 
[09:31:14.680]                           invokeRestart("muffleMessage")
[09:31:14.680]                       }
[09:31:14.680]                       else if (inherits(cond, "warning")) {
[09:31:14.680]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.680]                         if (muffled) 
[09:31:14.680]                           invokeRestart("muffleWarning")
[09:31:14.680]                       }
[09:31:14.680]                       else if (inherits(cond, "condition")) {
[09:31:14.680]                         if (!is.null(pattern)) {
[09:31:14.680]                           computeRestarts <- base::computeRestarts
[09:31:14.680]                           grepl <- base::grepl
[09:31:14.680]                           restarts <- computeRestarts(cond)
[09:31:14.680]                           for (restart in restarts) {
[09:31:14.680]                             name <- restart$name
[09:31:14.680]                             if (is.null(name)) 
[09:31:14.680]                               next
[09:31:14.680]                             if (!grepl(pattern, name)) 
[09:31:14.680]                               next
[09:31:14.680]                             invokeRestart(restart)
[09:31:14.680]                             muffled <- TRUE
[09:31:14.680]                             break
[09:31:14.680]                           }
[09:31:14.680]                         }
[09:31:14.680]                       }
[09:31:14.680]                       invisible(muffled)
[09:31:14.680]                     }
[09:31:14.680]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.680]                   }
[09:31:14.680]                 }
[09:31:14.680]             }
[09:31:14.680]         }))
[09:31:14.680]     }, error = function(ex) {
[09:31:14.680]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.680]                 ...future.rng), started = ...future.startTime, 
[09:31:14.680]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.680]             version = "1.8"), class = "FutureResult")
[09:31:14.680]     }, finally = {
[09:31:14.680]         if (!identical(...future.workdir, getwd())) 
[09:31:14.680]             setwd(...future.workdir)
[09:31:14.680]         {
[09:31:14.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.680]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.680]             }
[09:31:14.680]             base::options(...future.oldOptions)
[09:31:14.680]             if (.Platform$OS.type == "windows") {
[09:31:14.680]                 old_names <- names(...future.oldEnvVars)
[09:31:14.680]                 envs <- base::Sys.getenv()
[09:31:14.680]                 names <- names(envs)
[09:31:14.680]                 common <- intersect(names, old_names)
[09:31:14.680]                 added <- setdiff(names, old_names)
[09:31:14.680]                 removed <- setdiff(old_names, names)
[09:31:14.680]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.680]                   envs[common]]
[09:31:14.680]                 NAMES <- toupper(changed)
[09:31:14.680]                 args <- list()
[09:31:14.680]                 for (kk in seq_along(NAMES)) {
[09:31:14.680]                   name <- changed[[kk]]
[09:31:14.680]                   NAME <- NAMES[[kk]]
[09:31:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.680]                     next
[09:31:14.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.680]                 }
[09:31:14.680]                 NAMES <- toupper(added)
[09:31:14.680]                 for (kk in seq_along(NAMES)) {
[09:31:14.680]                   name <- added[[kk]]
[09:31:14.680]                   NAME <- NAMES[[kk]]
[09:31:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.680]                     next
[09:31:14.680]                   args[[name]] <- ""
[09:31:14.680]                 }
[09:31:14.680]                 NAMES <- toupper(removed)
[09:31:14.680]                 for (kk in seq_along(NAMES)) {
[09:31:14.680]                   name <- removed[[kk]]
[09:31:14.680]                   NAME <- NAMES[[kk]]
[09:31:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.680]                     next
[09:31:14.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.680]                 }
[09:31:14.680]                 if (length(args) > 0) 
[09:31:14.680]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.680]             }
[09:31:14.680]             else {
[09:31:14.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.680]             }
[09:31:14.680]             {
[09:31:14.680]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.680]                   0L) {
[09:31:14.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.680]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.680]                   base::options(opts)
[09:31:14.680]                 }
[09:31:14.680]                 {
[09:31:14.680]                   {
[09:31:14.680]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.680]                     NULL
[09:31:14.680]                   }
[09:31:14.680]                   options(future.plan = NULL)
[09:31:14.680]                   if (is.na(NA_character_)) 
[09:31:14.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.680]                     .init = FALSE)
[09:31:14.680]                 }
[09:31:14.680]             }
[09:31:14.680]         }
[09:31:14.680]     })
[09:31:14.680]     if (TRUE) {
[09:31:14.680]         base::sink(type = "output", split = FALSE)
[09:31:14.680]         if (TRUE) {
[09:31:14.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.680]         }
[09:31:14.680]         else {
[09:31:14.680]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.680]         }
[09:31:14.680]         base::close(...future.stdout)
[09:31:14.680]         ...future.stdout <- NULL
[09:31:14.680]     }
[09:31:14.680]     ...future.result$conditions <- ...future.conditions
[09:31:14.680]     ...future.result$finished <- base::Sys.time()
[09:31:14.680]     ...future.result
[09:31:14.680] }
[09:31:14.682] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:14.692] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.693] - Validating connection of MultisessionFuture
[09:31:14.693] - received message: FutureResult
[09:31:14.693] - Received FutureResult
[09:31:14.693] - Erased future from FutureRegistry
[09:31:14.693] result() for ClusterFuture ...
[09:31:14.693] - result already collected: FutureResult
[09:31:14.693] result() for ClusterFuture ... done
[09:31:14.693] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.693] result() for ClusterFuture ...
[09:31:14.694] - result already collected: FutureResult
[09:31:14.694] result() for ClusterFuture ... done
[09:31:14.694] result() for ClusterFuture ...
[09:31:14.694] - result already collected: FutureResult
[09:31:14.694] result() for ClusterFuture ... done
[09:31:14.695] MultisessionFuture started
[09:31:14.695] - Launch lazy future ... done
[09:31:14.695] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a3cc7d4e68> 
<environment: 0x55a3cad48298> 
[09:31:14.697] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.697] - Validating connection of MultisessionFuture
[09:31:14.697] - received message: FutureResult
[09:31:14.697] - Received FutureResult
[09:31:14.697] - Erased future from FutureRegistry
[09:31:14.697] result() for ClusterFuture ...
[09:31:14.697] - result already collected: FutureResult
[09:31:14.697] result() for ClusterFuture ... done
[09:31:14.697] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.698] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.698] - Validating connection of MultisessionFuture
[09:31:14.698] - received message: FutureResult
[09:31:14.698] - Received FutureResult
[09:31:14.698] - Erased future from FutureRegistry
[09:31:14.698] result() for ClusterFuture ...
[09:31:14.698] - result already collected: FutureResult
[09:31:14.698] result() for ClusterFuture ... done
[09:31:14.699] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.700] resolve() on environment ...
[09:31:14.700]  recursive: 0
[09:31:14.700]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.700] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.700] - nx: 4
[09:31:14.701] - relay: TRUE
[09:31:14.701] - stdout: TRUE
[09:31:14.701] - signal: TRUE
[09:31:14.701] - resignal: FALSE
[09:31:14.701] - force: TRUE
[09:31:14.701] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.701] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.701]  - until=2
[09:31:14.701]  - relaying element #2
[09:31:14.701] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.701] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.701] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.702]  length: 3 (resolved future 1)
[09:31:14.702] Future #2
[09:31:14.702] result() for ClusterFuture ...
[09:31:14.702] - result already collected: FutureResult
[09:31:14.702] result() for ClusterFuture ... done
[09:31:14.702] result() for ClusterFuture ...
[09:31:14.702] - result already collected: FutureResult
[09:31:14.702] result() for ClusterFuture ... done
[09:31:14.702] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:14.702] - nx: 4
[09:31:14.702] - relay: TRUE
[09:31:14.702] - stdout: TRUE
[09:31:14.703] - signal: TRUE
[09:31:14.703] - resignal: FALSE
[09:31:14.703] - force: TRUE
[09:31:14.703] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.703] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.703]  - until=2
[09:31:14.703]  - relaying element #2
[09:31:14.703] result() for ClusterFuture ...
[09:31:14.703] - result already collected: FutureResult
[09:31:14.703] result() for ClusterFuture ... done
[09:31:14.703] result() for ClusterFuture ...
[09:31:14.703] - result already collected: FutureResult
[09:31:14.704] result() for ClusterFuture ... done
[09:31:14.704] result() for ClusterFuture ...
[09:31:14.704] - result already collected: FutureResult
[09:31:14.704] result() for ClusterFuture ... done
[09:31:14.704] result() for ClusterFuture ...
[09:31:14.704] - result already collected: FutureResult
[09:31:14.704] result() for ClusterFuture ... done
[09:31:14.704] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.704] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.704] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:14.705]  length: 2 (resolved future 2)
[09:31:14.705] Future #3
[09:31:14.705] result() for ClusterFuture ...
[09:31:14.705] - result already collected: FutureResult
[09:31:14.705] result() for ClusterFuture ... done
[09:31:14.705] result() for ClusterFuture ...
[09:31:14.705] - result already collected: FutureResult
[09:31:14.705] result() for ClusterFuture ... done
[09:31:14.705] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:14.705] - nx: 4
[09:31:14.705] - relay: TRUE
[09:31:14.705] - stdout: TRUE
[09:31:14.706] - signal: TRUE
[09:31:14.706] - resignal: FALSE
[09:31:14.706] - force: TRUE
[09:31:14.706] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.706] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.706]  - until=3
[09:31:14.706]  - relaying element #3
[09:31:14.706] result() for ClusterFuture ...
[09:31:14.706] - result already collected: FutureResult
[09:31:14.706] result() for ClusterFuture ... done
[09:31:14.706] result() for ClusterFuture ...
[09:31:14.706] - result already collected: FutureResult
[09:31:14.707] result() for ClusterFuture ... done
[09:31:14.707] result() for ClusterFuture ...
[09:31:14.707] - result already collected: FutureResult
[09:31:14.707] result() for ClusterFuture ... done
[09:31:14.707] result() for ClusterFuture ...
[09:31:14.707] - result already collected: FutureResult
[09:31:14.707] result() for ClusterFuture ... done
[09:31:14.707] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.707] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.707] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:14.707]  length: 1 (resolved future 3)
[09:31:14.708] Future #4
[09:31:14.708] result() for ClusterFuture ...
[09:31:14.708] - result already collected: FutureResult
[09:31:14.708] result() for ClusterFuture ... done
[09:31:14.708] result() for ClusterFuture ...
[09:31:14.708] - result already collected: FutureResult
[09:31:14.708] result() for ClusterFuture ... done
[09:31:14.708] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:14.708] - nx: 4
[09:31:14.708] - relay: TRUE
[09:31:14.709] - stdout: TRUE
[09:31:14.709] - signal: TRUE
[09:31:14.709] - resignal: FALSE
[09:31:14.709] - force: TRUE
[09:31:14.709] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.709] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.709]  - until=4
[09:31:14.709]  - relaying element #4
[09:31:14.709] result() for ClusterFuture ...
[09:31:14.709] - result already collected: FutureResult
[09:31:14.709] result() for ClusterFuture ... done
[09:31:14.709] result() for ClusterFuture ...
[09:31:14.710] - result already collected: FutureResult
[09:31:14.710] result() for ClusterFuture ... done
[09:31:14.710] result() for ClusterFuture ...
[09:31:14.710] - result already collected: FutureResult
[09:31:14.710] result() for ClusterFuture ... done
[09:31:14.710] result() for ClusterFuture ...
[09:31:14.710] - result already collected: FutureResult
[09:31:14.710] result() for ClusterFuture ... done
[09:31:14.710] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.710] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.710] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:14.710]  length: 0 (resolved future 4)
[09:31:14.711] Relaying remaining futures
[09:31:14.711] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.711] - nx: 4
[09:31:14.711] - relay: TRUE
[09:31:14.711] - stdout: TRUE
[09:31:14.711] - signal: TRUE
[09:31:14.711] - resignal: FALSE
[09:31:14.711] - force: TRUE
[09:31:14.711] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.711] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.711] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.711] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.712] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.712] resolve() on environment ... DONE
[09:31:14.712] result() for ClusterFuture ...
[09:31:14.712] - result already collected: FutureResult
[09:31:14.712] result() for ClusterFuture ... done
[09:31:14.712] result() for ClusterFuture ...
[09:31:14.712] - result already collected: FutureResult
[09:31:14.712] result() for ClusterFuture ... done
[09:31:14.712] result() for ClusterFuture ...
[09:31:14.712] - result already collected: FutureResult
[09:31:14.713] result() for ClusterFuture ... done
[09:31:14.713] result() for ClusterFuture ...
[09:31:14.713] - result already collected: FutureResult
[09:31:14.713] result() for ClusterFuture ... done
[09:31:14.713] result() for ClusterFuture ...
[09:31:14.713] - result already collected: FutureResult
[09:31:14.713] result() for ClusterFuture ... done
[09:31:14.713] result() for ClusterFuture ...
[09:31:14.713] - result already collected: FutureResult
[09:31:14.713] result() for ClusterFuture ... done
<environment: 0x55a3caa4d900> 
Dimensions: c(2, 3)
[09:31:14.714] getGlobalsAndPackages() ...
[09:31:14.714] Searching for globals...
[09:31:14.714] 
[09:31:14.714] Searching for globals ... DONE
[09:31:14.714] - globals: [0] <none>
[09:31:14.714] getGlobalsAndPackages() ... DONE
[09:31:14.715] run() for ‘Future’ ...
[09:31:14.715] - state: ‘created’
[09:31:14.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.728] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.729]   - Field: ‘node’
[09:31:14.729]   - Field: ‘label’
[09:31:14.729]   - Field: ‘local’
[09:31:14.729]   - Field: ‘owner’
[09:31:14.729]   - Field: ‘envir’
[09:31:14.729]   - Field: ‘workers’
[09:31:14.729]   - Field: ‘packages’
[09:31:14.729]   - Field: ‘gc’
[09:31:14.729]   - Field: ‘conditions’
[09:31:14.729]   - Field: ‘persistent’
[09:31:14.730]   - Field: ‘expr’
[09:31:14.730]   - Field: ‘uuid’
[09:31:14.730]   - Field: ‘seed’
[09:31:14.730]   - Field: ‘version’
[09:31:14.730]   - Field: ‘result’
[09:31:14.730]   - Field: ‘asynchronous’
[09:31:14.730]   - Field: ‘calls’
[09:31:14.730]   - Field: ‘globals’
[09:31:14.730]   - Field: ‘stdout’
[09:31:14.730]   - Field: ‘earlySignal’
[09:31:14.730]   - Field: ‘lazy’
[09:31:14.731]   - Field: ‘state’
[09:31:14.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.731] - Launch lazy future ...
[09:31:14.731] Packages needed by the future expression (n = 0): <none>
[09:31:14.731] Packages needed by future strategies (n = 0): <none>
[09:31:14.731] {
[09:31:14.731]     {
[09:31:14.731]         {
[09:31:14.731]             ...future.startTime <- base::Sys.time()
[09:31:14.731]             {
[09:31:14.731]                 {
[09:31:14.731]                   {
[09:31:14.731]                     {
[09:31:14.731]                       base::local({
[09:31:14.731]                         has_future <- base::requireNamespace("future", 
[09:31:14.731]                           quietly = TRUE)
[09:31:14.731]                         if (has_future) {
[09:31:14.731]                           ns <- base::getNamespace("future")
[09:31:14.731]                           version <- ns[[".package"]][["version"]]
[09:31:14.731]                           if (is.null(version)) 
[09:31:14.731]                             version <- utils::packageVersion("future")
[09:31:14.731]                         }
[09:31:14.731]                         else {
[09:31:14.731]                           version <- NULL
[09:31:14.731]                         }
[09:31:14.731]                         if (!has_future || version < "1.8.0") {
[09:31:14.731]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.731]                             "", base::R.version$version.string), 
[09:31:14.731]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.731]                               "release", "version")], collapse = " "), 
[09:31:14.731]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.731]                             info)
[09:31:14.731]                           info <- base::paste(info, collapse = "; ")
[09:31:14.731]                           if (!has_future) {
[09:31:14.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.731]                               info)
[09:31:14.731]                           }
[09:31:14.731]                           else {
[09:31:14.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.731]                               info, version)
[09:31:14.731]                           }
[09:31:14.731]                           base::stop(msg)
[09:31:14.731]                         }
[09:31:14.731]                       })
[09:31:14.731]                     }
[09:31:14.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.731]                     base::options(mc.cores = 1L)
[09:31:14.731]                   }
[09:31:14.731]                   ...future.strategy.old <- future::plan("list")
[09:31:14.731]                   options(future.plan = NULL)
[09:31:14.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.731]                 }
[09:31:14.731]                 ...future.workdir <- getwd()
[09:31:14.731]             }
[09:31:14.731]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.731]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.731]         }
[09:31:14.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.731]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.731]             base::names(...future.oldOptions))
[09:31:14.731]     }
[09:31:14.731]     if (FALSE) {
[09:31:14.731]     }
[09:31:14.731]     else {
[09:31:14.731]         if (TRUE) {
[09:31:14.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.731]                 open = "w")
[09:31:14.731]         }
[09:31:14.731]         else {
[09:31:14.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.731]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.731]         }
[09:31:14.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.731]             base::sink(type = "output", split = FALSE)
[09:31:14.731]             base::close(...future.stdout)
[09:31:14.731]         }, add = TRUE)
[09:31:14.731]     }
[09:31:14.731]     ...future.frame <- base::sys.nframe()
[09:31:14.731]     ...future.conditions <- base::list()
[09:31:14.731]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.731]     if (FALSE) {
[09:31:14.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.731]     }
[09:31:14.731]     ...future.result <- base::tryCatch({
[09:31:14.731]         base::withCallingHandlers({
[09:31:14.731]             ...future.value <- base::withVisible(base::local({
[09:31:14.731]                 ...future.makeSendCondition <- base::local({
[09:31:14.731]                   sendCondition <- NULL
[09:31:14.731]                   function(frame = 1L) {
[09:31:14.731]                     if (is.function(sendCondition)) 
[09:31:14.731]                       return(sendCondition)
[09:31:14.731]                     ns <- getNamespace("parallel")
[09:31:14.731]                     if (exists("sendData", mode = "function", 
[09:31:14.731]                       envir = ns)) {
[09:31:14.731]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.731]                         envir = ns)
[09:31:14.731]                       envir <- sys.frame(frame)
[09:31:14.731]                       master <- NULL
[09:31:14.731]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.731]                         !identical(envir, emptyenv())) {
[09:31:14.731]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.731]                           inherits = FALSE)) {
[09:31:14.731]                           master <- get("master", mode = "list", 
[09:31:14.731]                             envir = envir, inherits = FALSE)
[09:31:14.731]                           if (inherits(master, c("SOCKnode", 
[09:31:14.731]                             "SOCK0node"))) {
[09:31:14.731]                             sendCondition <<- function(cond) {
[09:31:14.731]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.731]                                 success = TRUE)
[09:31:14.731]                               parallel_sendData(master, data)
[09:31:14.731]                             }
[09:31:14.731]                             return(sendCondition)
[09:31:14.731]                           }
[09:31:14.731]                         }
[09:31:14.731]                         frame <- frame + 1L
[09:31:14.731]                         envir <- sys.frame(frame)
[09:31:14.731]                       }
[09:31:14.731]                     }
[09:31:14.731]                     sendCondition <<- function(cond) NULL
[09:31:14.731]                   }
[09:31:14.731]                 })
[09:31:14.731]                 withCallingHandlers({
[09:31:14.731]                   2
[09:31:14.731]                 }, immediateCondition = function(cond) {
[09:31:14.731]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.731]                   sendCondition(cond)
[09:31:14.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.731]                   {
[09:31:14.731]                     inherits <- base::inherits
[09:31:14.731]                     invokeRestart <- base::invokeRestart
[09:31:14.731]                     is.null <- base::is.null
[09:31:14.731]                     muffled <- FALSE
[09:31:14.731]                     if (inherits(cond, "message")) {
[09:31:14.731]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.731]                       if (muffled) 
[09:31:14.731]                         invokeRestart("muffleMessage")
[09:31:14.731]                     }
[09:31:14.731]                     else if (inherits(cond, "warning")) {
[09:31:14.731]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.731]                       if (muffled) 
[09:31:14.731]                         invokeRestart("muffleWarning")
[09:31:14.731]                     }
[09:31:14.731]                     else if (inherits(cond, "condition")) {
[09:31:14.731]                       if (!is.null(pattern)) {
[09:31:14.731]                         computeRestarts <- base::computeRestarts
[09:31:14.731]                         grepl <- base::grepl
[09:31:14.731]                         restarts <- computeRestarts(cond)
[09:31:14.731]                         for (restart in restarts) {
[09:31:14.731]                           name <- restart$name
[09:31:14.731]                           if (is.null(name)) 
[09:31:14.731]                             next
[09:31:14.731]                           if (!grepl(pattern, name)) 
[09:31:14.731]                             next
[09:31:14.731]                           invokeRestart(restart)
[09:31:14.731]                           muffled <- TRUE
[09:31:14.731]                           break
[09:31:14.731]                         }
[09:31:14.731]                       }
[09:31:14.731]                     }
[09:31:14.731]                     invisible(muffled)
[09:31:14.731]                   }
[09:31:14.731]                   muffleCondition(cond)
[09:31:14.731]                 })
[09:31:14.731]             }))
[09:31:14.731]             future::FutureResult(value = ...future.value$value, 
[09:31:14.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.731]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.731]                     ...future.globalenv.names))
[09:31:14.731]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.731]         }, condition = base::local({
[09:31:14.731]             c <- base::c
[09:31:14.731]             inherits <- base::inherits
[09:31:14.731]             invokeRestart <- base::invokeRestart
[09:31:14.731]             length <- base::length
[09:31:14.731]             list <- base::list
[09:31:14.731]             seq.int <- base::seq.int
[09:31:14.731]             signalCondition <- base::signalCondition
[09:31:14.731]             sys.calls <- base::sys.calls
[09:31:14.731]             `[[` <- base::`[[`
[09:31:14.731]             `+` <- base::`+`
[09:31:14.731]             `<<-` <- base::`<<-`
[09:31:14.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.731]                   3L)]
[09:31:14.731]             }
[09:31:14.731]             function(cond) {
[09:31:14.731]                 is_error <- inherits(cond, "error")
[09:31:14.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.731]                   NULL)
[09:31:14.731]                 if (is_error) {
[09:31:14.731]                   sessionInformation <- function() {
[09:31:14.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.731]                       search = base::search(), system = base::Sys.info())
[09:31:14.731]                   }
[09:31:14.731]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.731]                     cond$call), session = sessionInformation(), 
[09:31:14.731]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.731]                   signalCondition(cond)
[09:31:14.731]                 }
[09:31:14.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.731]                 "immediateCondition"))) {
[09:31:14.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.731]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.731]                   if (TRUE && !signal) {
[09:31:14.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.731]                     {
[09:31:14.731]                       inherits <- base::inherits
[09:31:14.731]                       invokeRestart <- base::invokeRestart
[09:31:14.731]                       is.null <- base::is.null
[09:31:14.731]                       muffled <- FALSE
[09:31:14.731]                       if (inherits(cond, "message")) {
[09:31:14.731]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.731]                         if (muffled) 
[09:31:14.731]                           invokeRestart("muffleMessage")
[09:31:14.731]                       }
[09:31:14.731]                       else if (inherits(cond, "warning")) {
[09:31:14.731]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.731]                         if (muffled) 
[09:31:14.731]                           invokeRestart("muffleWarning")
[09:31:14.731]                       }
[09:31:14.731]                       else if (inherits(cond, "condition")) {
[09:31:14.731]                         if (!is.null(pattern)) {
[09:31:14.731]                           computeRestarts <- base::computeRestarts
[09:31:14.731]                           grepl <- base::grepl
[09:31:14.731]                           restarts <- computeRestarts(cond)
[09:31:14.731]                           for (restart in restarts) {
[09:31:14.731]                             name <- restart$name
[09:31:14.731]                             if (is.null(name)) 
[09:31:14.731]                               next
[09:31:14.731]                             if (!grepl(pattern, name)) 
[09:31:14.731]                               next
[09:31:14.731]                             invokeRestart(restart)
[09:31:14.731]                             muffled <- TRUE
[09:31:14.731]                             break
[09:31:14.731]                           }
[09:31:14.731]                         }
[09:31:14.731]                       }
[09:31:14.731]                       invisible(muffled)
[09:31:14.731]                     }
[09:31:14.731]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.731]                   }
[09:31:14.731]                 }
[09:31:14.731]                 else {
[09:31:14.731]                   if (TRUE) {
[09:31:14.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.731]                     {
[09:31:14.731]                       inherits <- base::inherits
[09:31:14.731]                       invokeRestart <- base::invokeRestart
[09:31:14.731]                       is.null <- base::is.null
[09:31:14.731]                       muffled <- FALSE
[09:31:14.731]                       if (inherits(cond, "message")) {
[09:31:14.731]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.731]                         if (muffled) 
[09:31:14.731]                           invokeRestart("muffleMessage")
[09:31:14.731]                       }
[09:31:14.731]                       else if (inherits(cond, "warning")) {
[09:31:14.731]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.731]                         if (muffled) 
[09:31:14.731]                           invokeRestart("muffleWarning")
[09:31:14.731]                       }
[09:31:14.731]                       else if (inherits(cond, "condition")) {
[09:31:14.731]                         if (!is.null(pattern)) {
[09:31:14.731]                           computeRestarts <- base::computeRestarts
[09:31:14.731]                           grepl <- base::grepl
[09:31:14.731]                           restarts <- computeRestarts(cond)
[09:31:14.731]                           for (restart in restarts) {
[09:31:14.731]                             name <- restart$name
[09:31:14.731]                             if (is.null(name)) 
[09:31:14.731]                               next
[09:31:14.731]                             if (!grepl(pattern, name)) 
[09:31:14.731]                               next
[09:31:14.731]                             invokeRestart(restart)
[09:31:14.731]                             muffled <- TRUE
[09:31:14.731]                             break
[09:31:14.731]                           }
[09:31:14.731]                         }
[09:31:14.731]                       }
[09:31:14.731]                       invisible(muffled)
[09:31:14.731]                     }
[09:31:14.731]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.731]                   }
[09:31:14.731]                 }
[09:31:14.731]             }
[09:31:14.731]         }))
[09:31:14.731]     }, error = function(ex) {
[09:31:14.731]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.731]                 ...future.rng), started = ...future.startTime, 
[09:31:14.731]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.731]             version = "1.8"), class = "FutureResult")
[09:31:14.731]     }, finally = {
[09:31:14.731]         if (!identical(...future.workdir, getwd())) 
[09:31:14.731]             setwd(...future.workdir)
[09:31:14.731]         {
[09:31:14.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.731]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.731]             }
[09:31:14.731]             base::options(...future.oldOptions)
[09:31:14.731]             if (.Platform$OS.type == "windows") {
[09:31:14.731]                 old_names <- names(...future.oldEnvVars)
[09:31:14.731]                 envs <- base::Sys.getenv()
[09:31:14.731]                 names <- names(envs)
[09:31:14.731]                 common <- intersect(names, old_names)
[09:31:14.731]                 added <- setdiff(names, old_names)
[09:31:14.731]                 removed <- setdiff(old_names, names)
[09:31:14.731]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.731]                   envs[common]]
[09:31:14.731]                 NAMES <- toupper(changed)
[09:31:14.731]                 args <- list()
[09:31:14.731]                 for (kk in seq_along(NAMES)) {
[09:31:14.731]                   name <- changed[[kk]]
[09:31:14.731]                   NAME <- NAMES[[kk]]
[09:31:14.731]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.731]                     next
[09:31:14.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.731]                 }
[09:31:14.731]                 NAMES <- toupper(added)
[09:31:14.731]                 for (kk in seq_along(NAMES)) {
[09:31:14.731]                   name <- added[[kk]]
[09:31:14.731]                   NAME <- NAMES[[kk]]
[09:31:14.731]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.731]                     next
[09:31:14.731]                   args[[name]] <- ""
[09:31:14.731]                 }
[09:31:14.731]                 NAMES <- toupper(removed)
[09:31:14.731]                 for (kk in seq_along(NAMES)) {
[09:31:14.731]                   name <- removed[[kk]]
[09:31:14.731]                   NAME <- NAMES[[kk]]
[09:31:14.731]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.731]                     next
[09:31:14.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.731]                 }
[09:31:14.731]                 if (length(args) > 0) 
[09:31:14.731]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.731]             }
[09:31:14.731]             else {
[09:31:14.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.731]             }
[09:31:14.731]             {
[09:31:14.731]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.731]                   0L) {
[09:31:14.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.731]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.731]                   base::options(opts)
[09:31:14.731]                 }
[09:31:14.731]                 {
[09:31:14.731]                   {
[09:31:14.731]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.731]                     NULL
[09:31:14.731]                   }
[09:31:14.731]                   options(future.plan = NULL)
[09:31:14.731]                   if (is.na(NA_character_)) 
[09:31:14.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.731]                     .init = FALSE)
[09:31:14.731]                 }
[09:31:14.731]             }
[09:31:14.731]         }
[09:31:14.731]     })
[09:31:14.731]     if (TRUE) {
[09:31:14.731]         base::sink(type = "output", split = FALSE)
[09:31:14.731]         if (TRUE) {
[09:31:14.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.731]         }
[09:31:14.731]         else {
[09:31:14.731]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.731]         }
[09:31:14.731]         base::close(...future.stdout)
[09:31:14.731]         ...future.stdout <- NULL
[09:31:14.731]     }
[09:31:14.731]     ...future.result$conditions <- ...future.conditions
[09:31:14.731]     ...future.result$finished <- base::Sys.time()
[09:31:14.731]     ...future.result
[09:31:14.731] }
[09:31:14.734] MultisessionFuture started
[09:31:14.734] - Launch lazy future ... done
[09:31:14.734] run() for ‘MultisessionFuture’ ... done
[09:31:14.735] getGlobalsAndPackages() ...
[09:31:14.735] Searching for globals...
[09:31:14.735] 
[09:31:14.735] Searching for globals ... DONE
[09:31:14.735] - globals: [0] <none>
[09:31:14.735] getGlobalsAndPackages() ... DONE
[09:31:14.735] run() for ‘Future’ ...
[09:31:14.736] - state: ‘created’
[09:31:14.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.749]   - Field: ‘node’
[09:31:14.749]   - Field: ‘label’
[09:31:14.750]   - Field: ‘local’
[09:31:14.750]   - Field: ‘owner’
[09:31:14.750]   - Field: ‘envir’
[09:31:14.750]   - Field: ‘workers’
[09:31:14.750]   - Field: ‘packages’
[09:31:14.750]   - Field: ‘gc’
[09:31:14.750]   - Field: ‘conditions’
[09:31:14.750]   - Field: ‘persistent’
[09:31:14.750]   - Field: ‘expr’
[09:31:14.750]   - Field: ‘uuid’
[09:31:14.750]   - Field: ‘seed’
[09:31:14.751]   - Field: ‘version’
[09:31:14.751]   - Field: ‘result’
[09:31:14.751]   - Field: ‘asynchronous’
[09:31:14.751]   - Field: ‘calls’
[09:31:14.751]   - Field: ‘globals’
[09:31:14.751]   - Field: ‘stdout’
[09:31:14.751]   - Field: ‘earlySignal’
[09:31:14.751]   - Field: ‘lazy’
[09:31:14.751]   - Field: ‘state’
[09:31:14.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.751] - Launch lazy future ...
[09:31:14.752] Packages needed by the future expression (n = 0): <none>
[09:31:14.752] Packages needed by future strategies (n = 0): <none>
[09:31:14.752] {
[09:31:14.752]     {
[09:31:14.752]         {
[09:31:14.752]             ...future.startTime <- base::Sys.time()
[09:31:14.752]             {
[09:31:14.752]                 {
[09:31:14.752]                   {
[09:31:14.752]                     {
[09:31:14.752]                       base::local({
[09:31:14.752]                         has_future <- base::requireNamespace("future", 
[09:31:14.752]                           quietly = TRUE)
[09:31:14.752]                         if (has_future) {
[09:31:14.752]                           ns <- base::getNamespace("future")
[09:31:14.752]                           version <- ns[[".package"]][["version"]]
[09:31:14.752]                           if (is.null(version)) 
[09:31:14.752]                             version <- utils::packageVersion("future")
[09:31:14.752]                         }
[09:31:14.752]                         else {
[09:31:14.752]                           version <- NULL
[09:31:14.752]                         }
[09:31:14.752]                         if (!has_future || version < "1.8.0") {
[09:31:14.752]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.752]                             "", base::R.version$version.string), 
[09:31:14.752]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.752]                               "release", "version")], collapse = " "), 
[09:31:14.752]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.752]                             info)
[09:31:14.752]                           info <- base::paste(info, collapse = "; ")
[09:31:14.752]                           if (!has_future) {
[09:31:14.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.752]                               info)
[09:31:14.752]                           }
[09:31:14.752]                           else {
[09:31:14.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.752]                               info, version)
[09:31:14.752]                           }
[09:31:14.752]                           base::stop(msg)
[09:31:14.752]                         }
[09:31:14.752]                       })
[09:31:14.752]                     }
[09:31:14.752]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.752]                     base::options(mc.cores = 1L)
[09:31:14.752]                   }
[09:31:14.752]                   ...future.strategy.old <- future::plan("list")
[09:31:14.752]                   options(future.plan = NULL)
[09:31:14.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.752]                 }
[09:31:14.752]                 ...future.workdir <- getwd()
[09:31:14.752]             }
[09:31:14.752]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.752]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.752]         }
[09:31:14.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.752]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.752]             base::names(...future.oldOptions))
[09:31:14.752]     }
[09:31:14.752]     if (FALSE) {
[09:31:14.752]     }
[09:31:14.752]     else {
[09:31:14.752]         if (TRUE) {
[09:31:14.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.752]                 open = "w")
[09:31:14.752]         }
[09:31:14.752]         else {
[09:31:14.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.752]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.752]         }
[09:31:14.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.752]             base::sink(type = "output", split = FALSE)
[09:31:14.752]             base::close(...future.stdout)
[09:31:14.752]         }, add = TRUE)
[09:31:14.752]     }
[09:31:14.752]     ...future.frame <- base::sys.nframe()
[09:31:14.752]     ...future.conditions <- base::list()
[09:31:14.752]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.752]     if (FALSE) {
[09:31:14.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.752]     }
[09:31:14.752]     ...future.result <- base::tryCatch({
[09:31:14.752]         base::withCallingHandlers({
[09:31:14.752]             ...future.value <- base::withVisible(base::local({
[09:31:14.752]                 ...future.makeSendCondition <- base::local({
[09:31:14.752]                   sendCondition <- NULL
[09:31:14.752]                   function(frame = 1L) {
[09:31:14.752]                     if (is.function(sendCondition)) 
[09:31:14.752]                       return(sendCondition)
[09:31:14.752]                     ns <- getNamespace("parallel")
[09:31:14.752]                     if (exists("sendData", mode = "function", 
[09:31:14.752]                       envir = ns)) {
[09:31:14.752]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.752]                         envir = ns)
[09:31:14.752]                       envir <- sys.frame(frame)
[09:31:14.752]                       master <- NULL
[09:31:14.752]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.752]                         !identical(envir, emptyenv())) {
[09:31:14.752]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.752]                           inherits = FALSE)) {
[09:31:14.752]                           master <- get("master", mode = "list", 
[09:31:14.752]                             envir = envir, inherits = FALSE)
[09:31:14.752]                           if (inherits(master, c("SOCKnode", 
[09:31:14.752]                             "SOCK0node"))) {
[09:31:14.752]                             sendCondition <<- function(cond) {
[09:31:14.752]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.752]                                 success = TRUE)
[09:31:14.752]                               parallel_sendData(master, data)
[09:31:14.752]                             }
[09:31:14.752]                             return(sendCondition)
[09:31:14.752]                           }
[09:31:14.752]                         }
[09:31:14.752]                         frame <- frame + 1L
[09:31:14.752]                         envir <- sys.frame(frame)
[09:31:14.752]                       }
[09:31:14.752]                     }
[09:31:14.752]                     sendCondition <<- function(cond) NULL
[09:31:14.752]                   }
[09:31:14.752]                 })
[09:31:14.752]                 withCallingHandlers({
[09:31:14.752]                   NULL
[09:31:14.752]                 }, immediateCondition = function(cond) {
[09:31:14.752]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.752]                   sendCondition(cond)
[09:31:14.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.752]                   {
[09:31:14.752]                     inherits <- base::inherits
[09:31:14.752]                     invokeRestart <- base::invokeRestart
[09:31:14.752]                     is.null <- base::is.null
[09:31:14.752]                     muffled <- FALSE
[09:31:14.752]                     if (inherits(cond, "message")) {
[09:31:14.752]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.752]                       if (muffled) 
[09:31:14.752]                         invokeRestart("muffleMessage")
[09:31:14.752]                     }
[09:31:14.752]                     else if (inherits(cond, "warning")) {
[09:31:14.752]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.752]                       if (muffled) 
[09:31:14.752]                         invokeRestart("muffleWarning")
[09:31:14.752]                     }
[09:31:14.752]                     else if (inherits(cond, "condition")) {
[09:31:14.752]                       if (!is.null(pattern)) {
[09:31:14.752]                         computeRestarts <- base::computeRestarts
[09:31:14.752]                         grepl <- base::grepl
[09:31:14.752]                         restarts <- computeRestarts(cond)
[09:31:14.752]                         for (restart in restarts) {
[09:31:14.752]                           name <- restart$name
[09:31:14.752]                           if (is.null(name)) 
[09:31:14.752]                             next
[09:31:14.752]                           if (!grepl(pattern, name)) 
[09:31:14.752]                             next
[09:31:14.752]                           invokeRestart(restart)
[09:31:14.752]                           muffled <- TRUE
[09:31:14.752]                           break
[09:31:14.752]                         }
[09:31:14.752]                       }
[09:31:14.752]                     }
[09:31:14.752]                     invisible(muffled)
[09:31:14.752]                   }
[09:31:14.752]                   muffleCondition(cond)
[09:31:14.752]                 })
[09:31:14.752]             }))
[09:31:14.752]             future::FutureResult(value = ...future.value$value, 
[09:31:14.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.752]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.752]                     ...future.globalenv.names))
[09:31:14.752]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.752]         }, condition = base::local({
[09:31:14.752]             c <- base::c
[09:31:14.752]             inherits <- base::inherits
[09:31:14.752]             invokeRestart <- base::invokeRestart
[09:31:14.752]             length <- base::length
[09:31:14.752]             list <- base::list
[09:31:14.752]             seq.int <- base::seq.int
[09:31:14.752]             signalCondition <- base::signalCondition
[09:31:14.752]             sys.calls <- base::sys.calls
[09:31:14.752]             `[[` <- base::`[[`
[09:31:14.752]             `+` <- base::`+`
[09:31:14.752]             `<<-` <- base::`<<-`
[09:31:14.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.752]                   3L)]
[09:31:14.752]             }
[09:31:14.752]             function(cond) {
[09:31:14.752]                 is_error <- inherits(cond, "error")
[09:31:14.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.752]                   NULL)
[09:31:14.752]                 if (is_error) {
[09:31:14.752]                   sessionInformation <- function() {
[09:31:14.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.752]                       search = base::search(), system = base::Sys.info())
[09:31:14.752]                   }
[09:31:14.752]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.752]                     cond$call), session = sessionInformation(), 
[09:31:14.752]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.752]                   signalCondition(cond)
[09:31:14.752]                 }
[09:31:14.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.752]                 "immediateCondition"))) {
[09:31:14.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.752]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.752]                   if (TRUE && !signal) {
[09:31:14.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.752]                     {
[09:31:14.752]                       inherits <- base::inherits
[09:31:14.752]                       invokeRestart <- base::invokeRestart
[09:31:14.752]                       is.null <- base::is.null
[09:31:14.752]                       muffled <- FALSE
[09:31:14.752]                       if (inherits(cond, "message")) {
[09:31:14.752]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.752]                         if (muffled) 
[09:31:14.752]                           invokeRestart("muffleMessage")
[09:31:14.752]                       }
[09:31:14.752]                       else if (inherits(cond, "warning")) {
[09:31:14.752]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.752]                         if (muffled) 
[09:31:14.752]                           invokeRestart("muffleWarning")
[09:31:14.752]                       }
[09:31:14.752]                       else if (inherits(cond, "condition")) {
[09:31:14.752]                         if (!is.null(pattern)) {
[09:31:14.752]                           computeRestarts <- base::computeRestarts
[09:31:14.752]                           grepl <- base::grepl
[09:31:14.752]                           restarts <- computeRestarts(cond)
[09:31:14.752]                           for (restart in restarts) {
[09:31:14.752]                             name <- restart$name
[09:31:14.752]                             if (is.null(name)) 
[09:31:14.752]                               next
[09:31:14.752]                             if (!grepl(pattern, name)) 
[09:31:14.752]                               next
[09:31:14.752]                             invokeRestart(restart)
[09:31:14.752]                             muffled <- TRUE
[09:31:14.752]                             break
[09:31:14.752]                           }
[09:31:14.752]                         }
[09:31:14.752]                       }
[09:31:14.752]                       invisible(muffled)
[09:31:14.752]                     }
[09:31:14.752]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.752]                   }
[09:31:14.752]                 }
[09:31:14.752]                 else {
[09:31:14.752]                   if (TRUE) {
[09:31:14.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.752]                     {
[09:31:14.752]                       inherits <- base::inherits
[09:31:14.752]                       invokeRestart <- base::invokeRestart
[09:31:14.752]                       is.null <- base::is.null
[09:31:14.752]                       muffled <- FALSE
[09:31:14.752]                       if (inherits(cond, "message")) {
[09:31:14.752]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.752]                         if (muffled) 
[09:31:14.752]                           invokeRestart("muffleMessage")
[09:31:14.752]                       }
[09:31:14.752]                       else if (inherits(cond, "warning")) {
[09:31:14.752]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.752]                         if (muffled) 
[09:31:14.752]                           invokeRestart("muffleWarning")
[09:31:14.752]                       }
[09:31:14.752]                       else if (inherits(cond, "condition")) {
[09:31:14.752]                         if (!is.null(pattern)) {
[09:31:14.752]                           computeRestarts <- base::computeRestarts
[09:31:14.752]                           grepl <- base::grepl
[09:31:14.752]                           restarts <- computeRestarts(cond)
[09:31:14.752]                           for (restart in restarts) {
[09:31:14.752]                             name <- restart$name
[09:31:14.752]                             if (is.null(name)) 
[09:31:14.752]                               next
[09:31:14.752]                             if (!grepl(pattern, name)) 
[09:31:14.752]                               next
[09:31:14.752]                             invokeRestart(restart)
[09:31:14.752]                             muffled <- TRUE
[09:31:14.752]                             break
[09:31:14.752]                           }
[09:31:14.752]                         }
[09:31:14.752]                       }
[09:31:14.752]                       invisible(muffled)
[09:31:14.752]                     }
[09:31:14.752]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.752]                   }
[09:31:14.752]                 }
[09:31:14.752]             }
[09:31:14.752]         }))
[09:31:14.752]     }, error = function(ex) {
[09:31:14.752]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.752]                 ...future.rng), started = ...future.startTime, 
[09:31:14.752]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.752]             version = "1.8"), class = "FutureResult")
[09:31:14.752]     }, finally = {
[09:31:14.752]         if (!identical(...future.workdir, getwd())) 
[09:31:14.752]             setwd(...future.workdir)
[09:31:14.752]         {
[09:31:14.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.752]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.752]             }
[09:31:14.752]             base::options(...future.oldOptions)
[09:31:14.752]             if (.Platform$OS.type == "windows") {
[09:31:14.752]                 old_names <- names(...future.oldEnvVars)
[09:31:14.752]                 envs <- base::Sys.getenv()
[09:31:14.752]                 names <- names(envs)
[09:31:14.752]                 common <- intersect(names, old_names)
[09:31:14.752]                 added <- setdiff(names, old_names)
[09:31:14.752]                 removed <- setdiff(old_names, names)
[09:31:14.752]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.752]                   envs[common]]
[09:31:14.752]                 NAMES <- toupper(changed)
[09:31:14.752]                 args <- list()
[09:31:14.752]                 for (kk in seq_along(NAMES)) {
[09:31:14.752]                   name <- changed[[kk]]
[09:31:14.752]                   NAME <- NAMES[[kk]]
[09:31:14.752]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.752]                     next
[09:31:14.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.752]                 }
[09:31:14.752]                 NAMES <- toupper(added)
[09:31:14.752]                 for (kk in seq_along(NAMES)) {
[09:31:14.752]                   name <- added[[kk]]
[09:31:14.752]                   NAME <- NAMES[[kk]]
[09:31:14.752]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.752]                     next
[09:31:14.752]                   args[[name]] <- ""
[09:31:14.752]                 }
[09:31:14.752]                 NAMES <- toupper(removed)
[09:31:14.752]                 for (kk in seq_along(NAMES)) {
[09:31:14.752]                   name <- removed[[kk]]
[09:31:14.752]                   NAME <- NAMES[[kk]]
[09:31:14.752]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.752]                     next
[09:31:14.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.752]                 }
[09:31:14.752]                 if (length(args) > 0) 
[09:31:14.752]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.752]             }
[09:31:14.752]             else {
[09:31:14.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.752]             }
[09:31:14.752]             {
[09:31:14.752]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.752]                   0L) {
[09:31:14.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.752]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.752]                   base::options(opts)
[09:31:14.752]                 }
[09:31:14.752]                 {
[09:31:14.752]                   {
[09:31:14.752]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.752]                     NULL
[09:31:14.752]                   }
[09:31:14.752]                   options(future.plan = NULL)
[09:31:14.752]                   if (is.na(NA_character_)) 
[09:31:14.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.752]                     .init = FALSE)
[09:31:14.752]                 }
[09:31:14.752]             }
[09:31:14.752]         }
[09:31:14.752]     })
[09:31:14.752]     if (TRUE) {
[09:31:14.752]         base::sink(type = "output", split = FALSE)
[09:31:14.752]         if (TRUE) {
[09:31:14.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.752]         }
[09:31:14.752]         else {
[09:31:14.752]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.752]         }
[09:31:14.752]         base::close(...future.stdout)
[09:31:14.752]         ...future.stdout <- NULL
[09:31:14.752]     }
[09:31:14.752]     ...future.result$conditions <- ...future.conditions
[09:31:14.752]     ...future.result$finished <- base::Sys.time()
[09:31:14.752]     ...future.result
[09:31:14.752] }
[09:31:14.755] MultisessionFuture started
[09:31:14.755] - Launch lazy future ... done
[09:31:14.755] run() for ‘MultisessionFuture’ ... done
[09:31:14.756] getGlobalsAndPackages() ...
[09:31:14.756] Searching for globals...
[09:31:14.756] - globals found: [1] ‘{’
[09:31:14.756] Searching for globals ... DONE
[09:31:14.756] Resolving globals: FALSE
[09:31:14.757] 
[09:31:14.757] 
[09:31:14.757] getGlobalsAndPackages() ... DONE
[09:31:14.757] run() for ‘Future’ ...
[09:31:14.757] - state: ‘created’
[09:31:14.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.770] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.771]   - Field: ‘node’
[09:31:14.771]   - Field: ‘label’
[09:31:14.771]   - Field: ‘local’
[09:31:14.771]   - Field: ‘owner’
[09:31:14.771]   - Field: ‘envir’
[09:31:14.771]   - Field: ‘workers’
[09:31:14.771]   - Field: ‘packages’
[09:31:14.771]   - Field: ‘gc’
[09:31:14.771]   - Field: ‘conditions’
[09:31:14.772]   - Field: ‘persistent’
[09:31:14.772]   - Field: ‘expr’
[09:31:14.772]   - Field: ‘uuid’
[09:31:14.772]   - Field: ‘seed’
[09:31:14.772]   - Field: ‘version’
[09:31:14.772]   - Field: ‘result’
[09:31:14.772]   - Field: ‘asynchronous’
[09:31:14.772]   - Field: ‘calls’
[09:31:14.772]   - Field: ‘globals’
[09:31:14.772]   - Field: ‘stdout’
[09:31:14.773]   - Field: ‘earlySignal’
[09:31:14.773]   - Field: ‘lazy’
[09:31:14.773]   - Field: ‘state’
[09:31:14.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.773] - Launch lazy future ...
[09:31:14.773] Packages needed by the future expression (n = 0): <none>
[09:31:14.773] Packages needed by future strategies (n = 0): <none>
[09:31:14.774] {
[09:31:14.774]     {
[09:31:14.774]         {
[09:31:14.774]             ...future.startTime <- base::Sys.time()
[09:31:14.774]             {
[09:31:14.774]                 {
[09:31:14.774]                   {
[09:31:14.774]                     {
[09:31:14.774]                       base::local({
[09:31:14.774]                         has_future <- base::requireNamespace("future", 
[09:31:14.774]                           quietly = TRUE)
[09:31:14.774]                         if (has_future) {
[09:31:14.774]                           ns <- base::getNamespace("future")
[09:31:14.774]                           version <- ns[[".package"]][["version"]]
[09:31:14.774]                           if (is.null(version)) 
[09:31:14.774]                             version <- utils::packageVersion("future")
[09:31:14.774]                         }
[09:31:14.774]                         else {
[09:31:14.774]                           version <- NULL
[09:31:14.774]                         }
[09:31:14.774]                         if (!has_future || version < "1.8.0") {
[09:31:14.774]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.774]                             "", base::R.version$version.string), 
[09:31:14.774]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.774]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.774]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.774]                               "release", "version")], collapse = " "), 
[09:31:14.774]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.774]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.774]                             info)
[09:31:14.774]                           info <- base::paste(info, collapse = "; ")
[09:31:14.774]                           if (!has_future) {
[09:31:14.774]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.774]                               info)
[09:31:14.774]                           }
[09:31:14.774]                           else {
[09:31:14.774]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.774]                               info, version)
[09:31:14.774]                           }
[09:31:14.774]                           base::stop(msg)
[09:31:14.774]                         }
[09:31:14.774]                       })
[09:31:14.774]                     }
[09:31:14.774]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.774]                     base::options(mc.cores = 1L)
[09:31:14.774]                   }
[09:31:14.774]                   ...future.strategy.old <- future::plan("list")
[09:31:14.774]                   options(future.plan = NULL)
[09:31:14.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.774]                 }
[09:31:14.774]                 ...future.workdir <- getwd()
[09:31:14.774]             }
[09:31:14.774]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.774]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.774]         }
[09:31:14.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.774]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.774]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.774]             base::names(...future.oldOptions))
[09:31:14.774]     }
[09:31:14.774]     if (FALSE) {
[09:31:14.774]     }
[09:31:14.774]     else {
[09:31:14.774]         if (TRUE) {
[09:31:14.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.774]                 open = "w")
[09:31:14.774]         }
[09:31:14.774]         else {
[09:31:14.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.774]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.774]         }
[09:31:14.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.774]             base::sink(type = "output", split = FALSE)
[09:31:14.774]             base::close(...future.stdout)
[09:31:14.774]         }, add = TRUE)
[09:31:14.774]     }
[09:31:14.774]     ...future.frame <- base::sys.nframe()
[09:31:14.774]     ...future.conditions <- base::list()
[09:31:14.774]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.774]     if (FALSE) {
[09:31:14.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.774]     }
[09:31:14.774]     ...future.result <- base::tryCatch({
[09:31:14.774]         base::withCallingHandlers({
[09:31:14.774]             ...future.value <- base::withVisible(base::local({
[09:31:14.774]                 ...future.makeSendCondition <- base::local({
[09:31:14.774]                   sendCondition <- NULL
[09:31:14.774]                   function(frame = 1L) {
[09:31:14.774]                     if (is.function(sendCondition)) 
[09:31:14.774]                       return(sendCondition)
[09:31:14.774]                     ns <- getNamespace("parallel")
[09:31:14.774]                     if (exists("sendData", mode = "function", 
[09:31:14.774]                       envir = ns)) {
[09:31:14.774]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.774]                         envir = ns)
[09:31:14.774]                       envir <- sys.frame(frame)
[09:31:14.774]                       master <- NULL
[09:31:14.774]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.774]                         !identical(envir, emptyenv())) {
[09:31:14.774]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.774]                           inherits = FALSE)) {
[09:31:14.774]                           master <- get("master", mode = "list", 
[09:31:14.774]                             envir = envir, inherits = FALSE)
[09:31:14.774]                           if (inherits(master, c("SOCKnode", 
[09:31:14.774]                             "SOCK0node"))) {
[09:31:14.774]                             sendCondition <<- function(cond) {
[09:31:14.774]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.774]                                 success = TRUE)
[09:31:14.774]                               parallel_sendData(master, data)
[09:31:14.774]                             }
[09:31:14.774]                             return(sendCondition)
[09:31:14.774]                           }
[09:31:14.774]                         }
[09:31:14.774]                         frame <- frame + 1L
[09:31:14.774]                         envir <- sys.frame(frame)
[09:31:14.774]                       }
[09:31:14.774]                     }
[09:31:14.774]                     sendCondition <<- function(cond) NULL
[09:31:14.774]                   }
[09:31:14.774]                 })
[09:31:14.774]                 withCallingHandlers({
[09:31:14.774]                   {
[09:31:14.774]                     4
[09:31:14.774]                   }
[09:31:14.774]                 }, immediateCondition = function(cond) {
[09:31:14.774]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.774]                   sendCondition(cond)
[09:31:14.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.774]                   {
[09:31:14.774]                     inherits <- base::inherits
[09:31:14.774]                     invokeRestart <- base::invokeRestart
[09:31:14.774]                     is.null <- base::is.null
[09:31:14.774]                     muffled <- FALSE
[09:31:14.774]                     if (inherits(cond, "message")) {
[09:31:14.774]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.774]                       if (muffled) 
[09:31:14.774]                         invokeRestart("muffleMessage")
[09:31:14.774]                     }
[09:31:14.774]                     else if (inherits(cond, "warning")) {
[09:31:14.774]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.774]                       if (muffled) 
[09:31:14.774]                         invokeRestart("muffleWarning")
[09:31:14.774]                     }
[09:31:14.774]                     else if (inherits(cond, "condition")) {
[09:31:14.774]                       if (!is.null(pattern)) {
[09:31:14.774]                         computeRestarts <- base::computeRestarts
[09:31:14.774]                         grepl <- base::grepl
[09:31:14.774]                         restarts <- computeRestarts(cond)
[09:31:14.774]                         for (restart in restarts) {
[09:31:14.774]                           name <- restart$name
[09:31:14.774]                           if (is.null(name)) 
[09:31:14.774]                             next
[09:31:14.774]                           if (!grepl(pattern, name)) 
[09:31:14.774]                             next
[09:31:14.774]                           invokeRestart(restart)
[09:31:14.774]                           muffled <- TRUE
[09:31:14.774]                           break
[09:31:14.774]                         }
[09:31:14.774]                       }
[09:31:14.774]                     }
[09:31:14.774]                     invisible(muffled)
[09:31:14.774]                   }
[09:31:14.774]                   muffleCondition(cond)
[09:31:14.774]                 })
[09:31:14.774]             }))
[09:31:14.774]             future::FutureResult(value = ...future.value$value, 
[09:31:14.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.774]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.774]                     ...future.globalenv.names))
[09:31:14.774]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.774]         }, condition = base::local({
[09:31:14.774]             c <- base::c
[09:31:14.774]             inherits <- base::inherits
[09:31:14.774]             invokeRestart <- base::invokeRestart
[09:31:14.774]             length <- base::length
[09:31:14.774]             list <- base::list
[09:31:14.774]             seq.int <- base::seq.int
[09:31:14.774]             signalCondition <- base::signalCondition
[09:31:14.774]             sys.calls <- base::sys.calls
[09:31:14.774]             `[[` <- base::`[[`
[09:31:14.774]             `+` <- base::`+`
[09:31:14.774]             `<<-` <- base::`<<-`
[09:31:14.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.774]                   3L)]
[09:31:14.774]             }
[09:31:14.774]             function(cond) {
[09:31:14.774]                 is_error <- inherits(cond, "error")
[09:31:14.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.774]                   NULL)
[09:31:14.774]                 if (is_error) {
[09:31:14.774]                   sessionInformation <- function() {
[09:31:14.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.774]                       search = base::search(), system = base::Sys.info())
[09:31:14.774]                   }
[09:31:14.774]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.774]                     cond$call), session = sessionInformation(), 
[09:31:14.774]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.774]                   signalCondition(cond)
[09:31:14.774]                 }
[09:31:14.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.774]                 "immediateCondition"))) {
[09:31:14.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.774]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.774]                   if (TRUE && !signal) {
[09:31:14.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.774]                     {
[09:31:14.774]                       inherits <- base::inherits
[09:31:14.774]                       invokeRestart <- base::invokeRestart
[09:31:14.774]                       is.null <- base::is.null
[09:31:14.774]                       muffled <- FALSE
[09:31:14.774]                       if (inherits(cond, "message")) {
[09:31:14.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.774]                         if (muffled) 
[09:31:14.774]                           invokeRestart("muffleMessage")
[09:31:14.774]                       }
[09:31:14.774]                       else if (inherits(cond, "warning")) {
[09:31:14.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.774]                         if (muffled) 
[09:31:14.774]                           invokeRestart("muffleWarning")
[09:31:14.774]                       }
[09:31:14.774]                       else if (inherits(cond, "condition")) {
[09:31:14.774]                         if (!is.null(pattern)) {
[09:31:14.774]                           computeRestarts <- base::computeRestarts
[09:31:14.774]                           grepl <- base::grepl
[09:31:14.774]                           restarts <- computeRestarts(cond)
[09:31:14.774]                           for (restart in restarts) {
[09:31:14.774]                             name <- restart$name
[09:31:14.774]                             if (is.null(name)) 
[09:31:14.774]                               next
[09:31:14.774]                             if (!grepl(pattern, name)) 
[09:31:14.774]                               next
[09:31:14.774]                             invokeRestart(restart)
[09:31:14.774]                             muffled <- TRUE
[09:31:14.774]                             break
[09:31:14.774]                           }
[09:31:14.774]                         }
[09:31:14.774]                       }
[09:31:14.774]                       invisible(muffled)
[09:31:14.774]                     }
[09:31:14.774]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.774]                   }
[09:31:14.774]                 }
[09:31:14.774]                 else {
[09:31:14.774]                   if (TRUE) {
[09:31:14.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.774]                     {
[09:31:14.774]                       inherits <- base::inherits
[09:31:14.774]                       invokeRestart <- base::invokeRestart
[09:31:14.774]                       is.null <- base::is.null
[09:31:14.774]                       muffled <- FALSE
[09:31:14.774]                       if (inherits(cond, "message")) {
[09:31:14.774]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.774]                         if (muffled) 
[09:31:14.774]                           invokeRestart("muffleMessage")
[09:31:14.774]                       }
[09:31:14.774]                       else if (inherits(cond, "warning")) {
[09:31:14.774]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.774]                         if (muffled) 
[09:31:14.774]                           invokeRestart("muffleWarning")
[09:31:14.774]                       }
[09:31:14.774]                       else if (inherits(cond, "condition")) {
[09:31:14.774]                         if (!is.null(pattern)) {
[09:31:14.774]                           computeRestarts <- base::computeRestarts
[09:31:14.774]                           grepl <- base::grepl
[09:31:14.774]                           restarts <- computeRestarts(cond)
[09:31:14.774]                           for (restart in restarts) {
[09:31:14.774]                             name <- restart$name
[09:31:14.774]                             if (is.null(name)) 
[09:31:14.774]                               next
[09:31:14.774]                             if (!grepl(pattern, name)) 
[09:31:14.774]                               next
[09:31:14.774]                             invokeRestart(restart)
[09:31:14.774]                             muffled <- TRUE
[09:31:14.774]                             break
[09:31:14.774]                           }
[09:31:14.774]                         }
[09:31:14.774]                       }
[09:31:14.774]                       invisible(muffled)
[09:31:14.774]                     }
[09:31:14.774]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.774]                   }
[09:31:14.774]                 }
[09:31:14.774]             }
[09:31:14.774]         }))
[09:31:14.774]     }, error = function(ex) {
[09:31:14.774]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.774]                 ...future.rng), started = ...future.startTime, 
[09:31:14.774]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.774]             version = "1.8"), class = "FutureResult")
[09:31:14.774]     }, finally = {
[09:31:14.774]         if (!identical(...future.workdir, getwd())) 
[09:31:14.774]             setwd(...future.workdir)
[09:31:14.774]         {
[09:31:14.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.774]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.774]             }
[09:31:14.774]             base::options(...future.oldOptions)
[09:31:14.774]             if (.Platform$OS.type == "windows") {
[09:31:14.774]                 old_names <- names(...future.oldEnvVars)
[09:31:14.774]                 envs <- base::Sys.getenv()
[09:31:14.774]                 names <- names(envs)
[09:31:14.774]                 common <- intersect(names, old_names)
[09:31:14.774]                 added <- setdiff(names, old_names)
[09:31:14.774]                 removed <- setdiff(old_names, names)
[09:31:14.774]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.774]                   envs[common]]
[09:31:14.774]                 NAMES <- toupper(changed)
[09:31:14.774]                 args <- list()
[09:31:14.774]                 for (kk in seq_along(NAMES)) {
[09:31:14.774]                   name <- changed[[kk]]
[09:31:14.774]                   NAME <- NAMES[[kk]]
[09:31:14.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.774]                     next
[09:31:14.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.774]                 }
[09:31:14.774]                 NAMES <- toupper(added)
[09:31:14.774]                 for (kk in seq_along(NAMES)) {
[09:31:14.774]                   name <- added[[kk]]
[09:31:14.774]                   NAME <- NAMES[[kk]]
[09:31:14.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.774]                     next
[09:31:14.774]                   args[[name]] <- ""
[09:31:14.774]                 }
[09:31:14.774]                 NAMES <- toupper(removed)
[09:31:14.774]                 for (kk in seq_along(NAMES)) {
[09:31:14.774]                   name <- removed[[kk]]
[09:31:14.774]                   NAME <- NAMES[[kk]]
[09:31:14.774]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.774]                     next
[09:31:14.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.774]                 }
[09:31:14.774]                 if (length(args) > 0) 
[09:31:14.774]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.774]             }
[09:31:14.774]             else {
[09:31:14.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.774]             }
[09:31:14.774]             {
[09:31:14.774]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.774]                   0L) {
[09:31:14.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.774]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.774]                   base::options(opts)
[09:31:14.774]                 }
[09:31:14.774]                 {
[09:31:14.774]                   {
[09:31:14.774]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.774]                     NULL
[09:31:14.774]                   }
[09:31:14.774]                   options(future.plan = NULL)
[09:31:14.774]                   if (is.na(NA_character_)) 
[09:31:14.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.774]                     .init = FALSE)
[09:31:14.774]                 }
[09:31:14.774]             }
[09:31:14.774]         }
[09:31:14.774]     })
[09:31:14.774]     if (TRUE) {
[09:31:14.774]         base::sink(type = "output", split = FALSE)
[09:31:14.774]         if (TRUE) {
[09:31:14.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.774]         }
[09:31:14.774]         else {
[09:31:14.774]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.774]         }
[09:31:14.774]         base::close(...future.stdout)
[09:31:14.774]         ...future.stdout <- NULL
[09:31:14.774]     }
[09:31:14.774]     ...future.result$conditions <- ...future.conditions
[09:31:14.774]     ...future.result$finished <- base::Sys.time()
[09:31:14.774]     ...future.result
[09:31:14.774] }
[09:31:14.776] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:14.786] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.786] - Validating connection of MultisessionFuture
[09:31:14.787] - received message: FutureResult
[09:31:14.787] - Received FutureResult
[09:31:14.787] - Erased future from FutureRegistry
[09:31:14.787] result() for ClusterFuture ...
[09:31:14.787] - result already collected: FutureResult
[09:31:14.787] result() for ClusterFuture ... done
[09:31:14.787] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.787] result() for ClusterFuture ...
[09:31:14.788] - result already collected: FutureResult
[09:31:14.788] result() for ClusterFuture ... done
[09:31:14.788] result() for ClusterFuture ...
[09:31:14.788] - result already collected: FutureResult
[09:31:14.788] result() for ClusterFuture ... done
[09:31:14.789] MultisessionFuture started
[09:31:14.789] - Launch lazy future ... done
[09:31:14.789] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a3cb089158> 
<environment: 0x55a3cca960e0> 
[09:31:14.791] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.791] - Validating connection of MultisessionFuture
[09:31:14.791] - received message: FutureResult
[09:31:14.791] - Received FutureResult
[09:31:14.791] - Erased future from FutureRegistry
[09:31:14.791] result() for ClusterFuture ...
[09:31:14.791] - result already collected: FutureResult
[09:31:14.791] result() for ClusterFuture ... done
[09:31:14.791] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.792] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.792] - Validating connection of MultisessionFuture
[09:31:14.792] - received message: FutureResult
[09:31:14.792] - Received FutureResult
[09:31:14.792] - Erased future from FutureRegistry
[09:31:14.793] result() for ClusterFuture ...
[09:31:14.793] - result already collected: FutureResult
[09:31:14.793] result() for ClusterFuture ... done
[09:31:14.793] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.794] resolve() on environment ...
[09:31:14.794]  recursive: 0
[09:31:14.794]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.795] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.795] - nx: 4
[09:31:14.795] - relay: TRUE
[09:31:14.795] - stdout: TRUE
[09:31:14.795] - signal: TRUE
[09:31:14.795] - resignal: FALSE
[09:31:14.795] - force: TRUE
[09:31:14.795] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.795] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.795]  - until=2
[09:31:14.795]  - relaying element #2
[09:31:14.795] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.796] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.796] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.796]  length: 3 (resolved future 1)
[09:31:14.796] Future #2
[09:31:14.796] result() for ClusterFuture ...
[09:31:14.796] - result already collected: FutureResult
[09:31:14.796] result() for ClusterFuture ... done
[09:31:14.796] result() for ClusterFuture ...
[09:31:14.796] - result already collected: FutureResult
[09:31:14.796] result() for ClusterFuture ... done
[09:31:14.797] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:14.797] - nx: 4
[09:31:14.797] - relay: TRUE
[09:31:14.797] - stdout: TRUE
[09:31:14.797] - signal: TRUE
[09:31:14.797] - resignal: FALSE
[09:31:14.797] - force: TRUE
[09:31:14.797] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.797] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.797]  - until=2
[09:31:14.797]  - relaying element #2
[09:31:14.798] result() for ClusterFuture ...
[09:31:14.798] - result already collected: FutureResult
[09:31:14.798] result() for ClusterFuture ... done
[09:31:14.798] result() for ClusterFuture ...
[09:31:14.798] - result already collected: FutureResult
[09:31:14.798] result() for ClusterFuture ... done
[09:31:14.798] result() for ClusterFuture ...
[09:31:14.798] - result already collected: FutureResult
[09:31:14.798] result() for ClusterFuture ... done
[09:31:14.798] result() for ClusterFuture ...
[09:31:14.798] - result already collected: FutureResult
[09:31:14.798] result() for ClusterFuture ... done
[09:31:14.799] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.799] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.799] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:14.799]  length: 2 (resolved future 2)
[09:31:14.799] Future #3
[09:31:14.799] result() for ClusterFuture ...
[09:31:14.799] - result already collected: FutureResult
[09:31:14.799] result() for ClusterFuture ... done
[09:31:14.799] result() for ClusterFuture ...
[09:31:14.799] - result already collected: FutureResult
[09:31:14.799] result() for ClusterFuture ... done
[09:31:14.800] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:14.800] - nx: 4
[09:31:14.802] - relay: TRUE
[09:31:14.802] - stdout: TRUE
[09:31:14.802] - signal: TRUE
[09:31:14.802] - resignal: FALSE
[09:31:14.803] - force: TRUE
[09:31:14.803] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.803] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.803]  - until=3
[09:31:14.803]  - relaying element #3
[09:31:14.803] result() for ClusterFuture ...
[09:31:14.803] - result already collected: FutureResult
[09:31:14.803] result() for ClusterFuture ... done
[09:31:14.803] result() for ClusterFuture ...
[09:31:14.803] - result already collected: FutureResult
[09:31:14.803] result() for ClusterFuture ... done
[09:31:14.804] result() for ClusterFuture ...
[09:31:14.804] - result already collected: FutureResult
[09:31:14.804] result() for ClusterFuture ... done
[09:31:14.804] result() for ClusterFuture ...
[09:31:14.804] - result already collected: FutureResult
[09:31:14.804] result() for ClusterFuture ... done
[09:31:14.804] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.804] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.804] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:14.804]  length: 1 (resolved future 3)
[09:31:14.805] Future #4
[09:31:14.805] result() for ClusterFuture ...
[09:31:14.805] - result already collected: FutureResult
[09:31:14.805] result() for ClusterFuture ... done
[09:31:14.805] result() for ClusterFuture ...
[09:31:14.805] - result already collected: FutureResult
[09:31:14.805] result() for ClusterFuture ... done
[09:31:14.805] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:14.805] - nx: 4
[09:31:14.805] - relay: TRUE
[09:31:14.805] - stdout: TRUE
[09:31:14.805] - signal: TRUE
[09:31:14.806] - resignal: FALSE
[09:31:14.806] - force: TRUE
[09:31:14.806] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.806] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.806]  - until=4
[09:31:14.806]  - relaying element #4
[09:31:14.806] result() for ClusterFuture ...
[09:31:14.806] - result already collected: FutureResult
[09:31:14.806] result() for ClusterFuture ... done
[09:31:14.806] result() for ClusterFuture ...
[09:31:14.806] - result already collected: FutureResult
[09:31:14.806] result() for ClusterFuture ... done
[09:31:14.807] result() for ClusterFuture ...
[09:31:14.807] - result already collected: FutureResult
[09:31:14.807] result() for ClusterFuture ... done
[09:31:14.807] result() for ClusterFuture ...
[09:31:14.807] - result already collected: FutureResult
[09:31:14.807] result() for ClusterFuture ... done
[09:31:14.807] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.807] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.807] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:14.807]  length: 0 (resolved future 4)
[09:31:14.807] Relaying remaining futures
[09:31:14.807] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.808] - nx: 4
[09:31:14.808] - relay: TRUE
[09:31:14.808] - stdout: TRUE
[09:31:14.808] - signal: TRUE
[09:31:14.808] - resignal: FALSE
[09:31:14.808] - force: TRUE
[09:31:14.808] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.808] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.808] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.808] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.808] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.809] resolve() on environment ... DONE
[09:31:14.809] result() for ClusterFuture ...
[09:31:14.809] - result already collected: FutureResult
[09:31:14.809] result() for ClusterFuture ... done
[09:31:14.809] result() for ClusterFuture ...
[09:31:14.809] - result already collected: FutureResult
[09:31:14.809] result() for ClusterFuture ... done
[09:31:14.809] result() for ClusterFuture ...
[09:31:14.809] - result already collected: FutureResult
[09:31:14.809] result() for ClusterFuture ... done
[09:31:14.809] result() for ClusterFuture ...
[09:31:14.809] - result already collected: FutureResult
[09:31:14.810] result() for ClusterFuture ... done
[09:31:14.810] result() for ClusterFuture ...
[09:31:14.810] - result already collected: FutureResult
[09:31:14.810] result() for ClusterFuture ... done
[09:31:14.810] result() for ClusterFuture ...
[09:31:14.810] - result already collected: FutureResult
[09:31:14.810] result() for ClusterFuture ... done
<environment: 0x55a3ccc41718> 
Dimensions: c(2, 3, 1)
[09:31:14.810] getGlobalsAndPackages() ...
[09:31:14.811] Searching for globals...
[09:31:14.811] 
[09:31:14.811] Searching for globals ... DONE
[09:31:14.811] - globals: [0] <none>
[09:31:14.811] getGlobalsAndPackages() ... DONE
[09:31:14.811] run() for ‘Future’ ...
[09:31:14.811] - state: ‘created’
[09:31:14.812] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.825]   - Field: ‘node’
[09:31:14.825]   - Field: ‘label’
[09:31:14.825]   - Field: ‘local’
[09:31:14.825]   - Field: ‘owner’
[09:31:14.825]   - Field: ‘envir’
[09:31:14.825]   - Field: ‘workers’
[09:31:14.826]   - Field: ‘packages’
[09:31:14.826]   - Field: ‘gc’
[09:31:14.826]   - Field: ‘conditions’
[09:31:14.826]   - Field: ‘persistent’
[09:31:14.826]   - Field: ‘expr’
[09:31:14.826]   - Field: ‘uuid’
[09:31:14.826]   - Field: ‘seed’
[09:31:14.826]   - Field: ‘version’
[09:31:14.826]   - Field: ‘result’
[09:31:14.826]   - Field: ‘asynchronous’
[09:31:14.826]   - Field: ‘calls’
[09:31:14.827]   - Field: ‘globals’
[09:31:14.827]   - Field: ‘stdout’
[09:31:14.827]   - Field: ‘earlySignal’
[09:31:14.827]   - Field: ‘lazy’
[09:31:14.827]   - Field: ‘state’
[09:31:14.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.827] - Launch lazy future ...
[09:31:14.827] Packages needed by the future expression (n = 0): <none>
[09:31:14.827] Packages needed by future strategies (n = 0): <none>
[09:31:14.828] {
[09:31:14.828]     {
[09:31:14.828]         {
[09:31:14.828]             ...future.startTime <- base::Sys.time()
[09:31:14.828]             {
[09:31:14.828]                 {
[09:31:14.828]                   {
[09:31:14.828]                     {
[09:31:14.828]                       base::local({
[09:31:14.828]                         has_future <- base::requireNamespace("future", 
[09:31:14.828]                           quietly = TRUE)
[09:31:14.828]                         if (has_future) {
[09:31:14.828]                           ns <- base::getNamespace("future")
[09:31:14.828]                           version <- ns[[".package"]][["version"]]
[09:31:14.828]                           if (is.null(version)) 
[09:31:14.828]                             version <- utils::packageVersion("future")
[09:31:14.828]                         }
[09:31:14.828]                         else {
[09:31:14.828]                           version <- NULL
[09:31:14.828]                         }
[09:31:14.828]                         if (!has_future || version < "1.8.0") {
[09:31:14.828]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.828]                             "", base::R.version$version.string), 
[09:31:14.828]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.828]                               "release", "version")], collapse = " "), 
[09:31:14.828]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.828]                             info)
[09:31:14.828]                           info <- base::paste(info, collapse = "; ")
[09:31:14.828]                           if (!has_future) {
[09:31:14.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.828]                               info)
[09:31:14.828]                           }
[09:31:14.828]                           else {
[09:31:14.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.828]                               info, version)
[09:31:14.828]                           }
[09:31:14.828]                           base::stop(msg)
[09:31:14.828]                         }
[09:31:14.828]                       })
[09:31:14.828]                     }
[09:31:14.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.828]                     base::options(mc.cores = 1L)
[09:31:14.828]                   }
[09:31:14.828]                   ...future.strategy.old <- future::plan("list")
[09:31:14.828]                   options(future.plan = NULL)
[09:31:14.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.828]                 }
[09:31:14.828]                 ...future.workdir <- getwd()
[09:31:14.828]             }
[09:31:14.828]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.828]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.828]         }
[09:31:14.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.828]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.828]             base::names(...future.oldOptions))
[09:31:14.828]     }
[09:31:14.828]     if (FALSE) {
[09:31:14.828]     }
[09:31:14.828]     else {
[09:31:14.828]         if (TRUE) {
[09:31:14.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.828]                 open = "w")
[09:31:14.828]         }
[09:31:14.828]         else {
[09:31:14.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.828]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.828]         }
[09:31:14.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.828]             base::sink(type = "output", split = FALSE)
[09:31:14.828]             base::close(...future.stdout)
[09:31:14.828]         }, add = TRUE)
[09:31:14.828]     }
[09:31:14.828]     ...future.frame <- base::sys.nframe()
[09:31:14.828]     ...future.conditions <- base::list()
[09:31:14.828]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.828]     if (FALSE) {
[09:31:14.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.828]     }
[09:31:14.828]     ...future.result <- base::tryCatch({
[09:31:14.828]         base::withCallingHandlers({
[09:31:14.828]             ...future.value <- base::withVisible(base::local({
[09:31:14.828]                 ...future.makeSendCondition <- base::local({
[09:31:14.828]                   sendCondition <- NULL
[09:31:14.828]                   function(frame = 1L) {
[09:31:14.828]                     if (is.function(sendCondition)) 
[09:31:14.828]                       return(sendCondition)
[09:31:14.828]                     ns <- getNamespace("parallel")
[09:31:14.828]                     if (exists("sendData", mode = "function", 
[09:31:14.828]                       envir = ns)) {
[09:31:14.828]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.828]                         envir = ns)
[09:31:14.828]                       envir <- sys.frame(frame)
[09:31:14.828]                       master <- NULL
[09:31:14.828]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.828]                         !identical(envir, emptyenv())) {
[09:31:14.828]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.828]                           inherits = FALSE)) {
[09:31:14.828]                           master <- get("master", mode = "list", 
[09:31:14.828]                             envir = envir, inherits = FALSE)
[09:31:14.828]                           if (inherits(master, c("SOCKnode", 
[09:31:14.828]                             "SOCK0node"))) {
[09:31:14.828]                             sendCondition <<- function(cond) {
[09:31:14.828]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.828]                                 success = TRUE)
[09:31:14.828]                               parallel_sendData(master, data)
[09:31:14.828]                             }
[09:31:14.828]                             return(sendCondition)
[09:31:14.828]                           }
[09:31:14.828]                         }
[09:31:14.828]                         frame <- frame + 1L
[09:31:14.828]                         envir <- sys.frame(frame)
[09:31:14.828]                       }
[09:31:14.828]                     }
[09:31:14.828]                     sendCondition <<- function(cond) NULL
[09:31:14.828]                   }
[09:31:14.828]                 })
[09:31:14.828]                 withCallingHandlers({
[09:31:14.828]                   2
[09:31:14.828]                 }, immediateCondition = function(cond) {
[09:31:14.828]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.828]                   sendCondition(cond)
[09:31:14.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.828]                   {
[09:31:14.828]                     inherits <- base::inherits
[09:31:14.828]                     invokeRestart <- base::invokeRestart
[09:31:14.828]                     is.null <- base::is.null
[09:31:14.828]                     muffled <- FALSE
[09:31:14.828]                     if (inherits(cond, "message")) {
[09:31:14.828]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.828]                       if (muffled) 
[09:31:14.828]                         invokeRestart("muffleMessage")
[09:31:14.828]                     }
[09:31:14.828]                     else if (inherits(cond, "warning")) {
[09:31:14.828]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.828]                       if (muffled) 
[09:31:14.828]                         invokeRestart("muffleWarning")
[09:31:14.828]                     }
[09:31:14.828]                     else if (inherits(cond, "condition")) {
[09:31:14.828]                       if (!is.null(pattern)) {
[09:31:14.828]                         computeRestarts <- base::computeRestarts
[09:31:14.828]                         grepl <- base::grepl
[09:31:14.828]                         restarts <- computeRestarts(cond)
[09:31:14.828]                         for (restart in restarts) {
[09:31:14.828]                           name <- restart$name
[09:31:14.828]                           if (is.null(name)) 
[09:31:14.828]                             next
[09:31:14.828]                           if (!grepl(pattern, name)) 
[09:31:14.828]                             next
[09:31:14.828]                           invokeRestart(restart)
[09:31:14.828]                           muffled <- TRUE
[09:31:14.828]                           break
[09:31:14.828]                         }
[09:31:14.828]                       }
[09:31:14.828]                     }
[09:31:14.828]                     invisible(muffled)
[09:31:14.828]                   }
[09:31:14.828]                   muffleCondition(cond)
[09:31:14.828]                 })
[09:31:14.828]             }))
[09:31:14.828]             future::FutureResult(value = ...future.value$value, 
[09:31:14.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.828]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.828]                     ...future.globalenv.names))
[09:31:14.828]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.828]         }, condition = base::local({
[09:31:14.828]             c <- base::c
[09:31:14.828]             inherits <- base::inherits
[09:31:14.828]             invokeRestart <- base::invokeRestart
[09:31:14.828]             length <- base::length
[09:31:14.828]             list <- base::list
[09:31:14.828]             seq.int <- base::seq.int
[09:31:14.828]             signalCondition <- base::signalCondition
[09:31:14.828]             sys.calls <- base::sys.calls
[09:31:14.828]             `[[` <- base::`[[`
[09:31:14.828]             `+` <- base::`+`
[09:31:14.828]             `<<-` <- base::`<<-`
[09:31:14.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.828]                   3L)]
[09:31:14.828]             }
[09:31:14.828]             function(cond) {
[09:31:14.828]                 is_error <- inherits(cond, "error")
[09:31:14.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.828]                   NULL)
[09:31:14.828]                 if (is_error) {
[09:31:14.828]                   sessionInformation <- function() {
[09:31:14.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.828]                       search = base::search(), system = base::Sys.info())
[09:31:14.828]                   }
[09:31:14.828]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.828]                     cond$call), session = sessionInformation(), 
[09:31:14.828]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.828]                   signalCondition(cond)
[09:31:14.828]                 }
[09:31:14.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.828]                 "immediateCondition"))) {
[09:31:14.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.828]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.828]                   if (TRUE && !signal) {
[09:31:14.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.828]                     {
[09:31:14.828]                       inherits <- base::inherits
[09:31:14.828]                       invokeRestart <- base::invokeRestart
[09:31:14.828]                       is.null <- base::is.null
[09:31:14.828]                       muffled <- FALSE
[09:31:14.828]                       if (inherits(cond, "message")) {
[09:31:14.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.828]                         if (muffled) 
[09:31:14.828]                           invokeRestart("muffleMessage")
[09:31:14.828]                       }
[09:31:14.828]                       else if (inherits(cond, "warning")) {
[09:31:14.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.828]                         if (muffled) 
[09:31:14.828]                           invokeRestart("muffleWarning")
[09:31:14.828]                       }
[09:31:14.828]                       else if (inherits(cond, "condition")) {
[09:31:14.828]                         if (!is.null(pattern)) {
[09:31:14.828]                           computeRestarts <- base::computeRestarts
[09:31:14.828]                           grepl <- base::grepl
[09:31:14.828]                           restarts <- computeRestarts(cond)
[09:31:14.828]                           for (restart in restarts) {
[09:31:14.828]                             name <- restart$name
[09:31:14.828]                             if (is.null(name)) 
[09:31:14.828]                               next
[09:31:14.828]                             if (!grepl(pattern, name)) 
[09:31:14.828]                               next
[09:31:14.828]                             invokeRestart(restart)
[09:31:14.828]                             muffled <- TRUE
[09:31:14.828]                             break
[09:31:14.828]                           }
[09:31:14.828]                         }
[09:31:14.828]                       }
[09:31:14.828]                       invisible(muffled)
[09:31:14.828]                     }
[09:31:14.828]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.828]                   }
[09:31:14.828]                 }
[09:31:14.828]                 else {
[09:31:14.828]                   if (TRUE) {
[09:31:14.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.828]                     {
[09:31:14.828]                       inherits <- base::inherits
[09:31:14.828]                       invokeRestart <- base::invokeRestart
[09:31:14.828]                       is.null <- base::is.null
[09:31:14.828]                       muffled <- FALSE
[09:31:14.828]                       if (inherits(cond, "message")) {
[09:31:14.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.828]                         if (muffled) 
[09:31:14.828]                           invokeRestart("muffleMessage")
[09:31:14.828]                       }
[09:31:14.828]                       else if (inherits(cond, "warning")) {
[09:31:14.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.828]                         if (muffled) 
[09:31:14.828]                           invokeRestart("muffleWarning")
[09:31:14.828]                       }
[09:31:14.828]                       else if (inherits(cond, "condition")) {
[09:31:14.828]                         if (!is.null(pattern)) {
[09:31:14.828]                           computeRestarts <- base::computeRestarts
[09:31:14.828]                           grepl <- base::grepl
[09:31:14.828]                           restarts <- computeRestarts(cond)
[09:31:14.828]                           for (restart in restarts) {
[09:31:14.828]                             name <- restart$name
[09:31:14.828]                             if (is.null(name)) 
[09:31:14.828]                               next
[09:31:14.828]                             if (!grepl(pattern, name)) 
[09:31:14.828]                               next
[09:31:14.828]                             invokeRestart(restart)
[09:31:14.828]                             muffled <- TRUE
[09:31:14.828]                             break
[09:31:14.828]                           }
[09:31:14.828]                         }
[09:31:14.828]                       }
[09:31:14.828]                       invisible(muffled)
[09:31:14.828]                     }
[09:31:14.828]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.828]                   }
[09:31:14.828]                 }
[09:31:14.828]             }
[09:31:14.828]         }))
[09:31:14.828]     }, error = function(ex) {
[09:31:14.828]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.828]                 ...future.rng), started = ...future.startTime, 
[09:31:14.828]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.828]             version = "1.8"), class = "FutureResult")
[09:31:14.828]     }, finally = {
[09:31:14.828]         if (!identical(...future.workdir, getwd())) 
[09:31:14.828]             setwd(...future.workdir)
[09:31:14.828]         {
[09:31:14.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.828]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.828]             }
[09:31:14.828]             base::options(...future.oldOptions)
[09:31:14.828]             if (.Platform$OS.type == "windows") {
[09:31:14.828]                 old_names <- names(...future.oldEnvVars)
[09:31:14.828]                 envs <- base::Sys.getenv()
[09:31:14.828]                 names <- names(envs)
[09:31:14.828]                 common <- intersect(names, old_names)
[09:31:14.828]                 added <- setdiff(names, old_names)
[09:31:14.828]                 removed <- setdiff(old_names, names)
[09:31:14.828]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.828]                   envs[common]]
[09:31:14.828]                 NAMES <- toupper(changed)
[09:31:14.828]                 args <- list()
[09:31:14.828]                 for (kk in seq_along(NAMES)) {
[09:31:14.828]                   name <- changed[[kk]]
[09:31:14.828]                   NAME <- NAMES[[kk]]
[09:31:14.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.828]                     next
[09:31:14.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.828]                 }
[09:31:14.828]                 NAMES <- toupper(added)
[09:31:14.828]                 for (kk in seq_along(NAMES)) {
[09:31:14.828]                   name <- added[[kk]]
[09:31:14.828]                   NAME <- NAMES[[kk]]
[09:31:14.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.828]                     next
[09:31:14.828]                   args[[name]] <- ""
[09:31:14.828]                 }
[09:31:14.828]                 NAMES <- toupper(removed)
[09:31:14.828]                 for (kk in seq_along(NAMES)) {
[09:31:14.828]                   name <- removed[[kk]]
[09:31:14.828]                   NAME <- NAMES[[kk]]
[09:31:14.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.828]                     next
[09:31:14.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.828]                 }
[09:31:14.828]                 if (length(args) > 0) 
[09:31:14.828]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.828]             }
[09:31:14.828]             else {
[09:31:14.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.828]             }
[09:31:14.828]             {
[09:31:14.828]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.828]                   0L) {
[09:31:14.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.828]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.828]                   base::options(opts)
[09:31:14.828]                 }
[09:31:14.828]                 {
[09:31:14.828]                   {
[09:31:14.828]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.828]                     NULL
[09:31:14.828]                   }
[09:31:14.828]                   options(future.plan = NULL)
[09:31:14.828]                   if (is.na(NA_character_)) 
[09:31:14.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.828]                     .init = FALSE)
[09:31:14.828]                 }
[09:31:14.828]             }
[09:31:14.828]         }
[09:31:14.828]     })
[09:31:14.828]     if (TRUE) {
[09:31:14.828]         base::sink(type = "output", split = FALSE)
[09:31:14.828]         if (TRUE) {
[09:31:14.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.828]         }
[09:31:14.828]         else {
[09:31:14.828]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.828]         }
[09:31:14.828]         base::close(...future.stdout)
[09:31:14.828]         ...future.stdout <- NULL
[09:31:14.828]     }
[09:31:14.828]     ...future.result$conditions <- ...future.conditions
[09:31:14.828]     ...future.result$finished <- base::Sys.time()
[09:31:14.828]     ...future.result
[09:31:14.828] }
[09:31:14.830] MultisessionFuture started
[09:31:14.831] - Launch lazy future ... done
[09:31:14.831] run() for ‘MultisessionFuture’ ... done
[09:31:14.831] getGlobalsAndPackages() ...
[09:31:14.831] Searching for globals...
[09:31:14.831] 
[09:31:14.831] Searching for globals ... DONE
[09:31:14.831] - globals: [0] <none>
[09:31:14.831] getGlobalsAndPackages() ... DONE
[09:31:14.832] run() for ‘Future’ ...
[09:31:14.832] - state: ‘created’
[09:31:14.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.846]   - Field: ‘node’
[09:31:14.846]   - Field: ‘label’
[09:31:14.846]   - Field: ‘local’
[09:31:14.846]   - Field: ‘owner’
[09:31:14.846]   - Field: ‘envir’
[09:31:14.846]   - Field: ‘workers’
[09:31:14.846]   - Field: ‘packages’
[09:31:14.846]   - Field: ‘gc’
[09:31:14.846]   - Field: ‘conditions’
[09:31:14.846]   - Field: ‘persistent’
[09:31:14.847]   - Field: ‘expr’
[09:31:14.847]   - Field: ‘uuid’
[09:31:14.847]   - Field: ‘seed’
[09:31:14.847]   - Field: ‘version’
[09:31:14.847]   - Field: ‘result’
[09:31:14.847]   - Field: ‘asynchronous’
[09:31:14.847]   - Field: ‘calls’
[09:31:14.847]   - Field: ‘globals’
[09:31:14.847]   - Field: ‘stdout’
[09:31:14.847]   - Field: ‘earlySignal’
[09:31:14.847]   - Field: ‘lazy’
[09:31:14.848]   - Field: ‘state’
[09:31:14.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.848] - Launch lazy future ...
[09:31:14.848] Packages needed by the future expression (n = 0): <none>
[09:31:14.848] Packages needed by future strategies (n = 0): <none>
[09:31:14.849] {
[09:31:14.849]     {
[09:31:14.849]         {
[09:31:14.849]             ...future.startTime <- base::Sys.time()
[09:31:14.849]             {
[09:31:14.849]                 {
[09:31:14.849]                   {
[09:31:14.849]                     {
[09:31:14.849]                       base::local({
[09:31:14.849]                         has_future <- base::requireNamespace("future", 
[09:31:14.849]                           quietly = TRUE)
[09:31:14.849]                         if (has_future) {
[09:31:14.849]                           ns <- base::getNamespace("future")
[09:31:14.849]                           version <- ns[[".package"]][["version"]]
[09:31:14.849]                           if (is.null(version)) 
[09:31:14.849]                             version <- utils::packageVersion("future")
[09:31:14.849]                         }
[09:31:14.849]                         else {
[09:31:14.849]                           version <- NULL
[09:31:14.849]                         }
[09:31:14.849]                         if (!has_future || version < "1.8.0") {
[09:31:14.849]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.849]                             "", base::R.version$version.string), 
[09:31:14.849]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.849]                               "release", "version")], collapse = " "), 
[09:31:14.849]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.849]                             info)
[09:31:14.849]                           info <- base::paste(info, collapse = "; ")
[09:31:14.849]                           if (!has_future) {
[09:31:14.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.849]                               info)
[09:31:14.849]                           }
[09:31:14.849]                           else {
[09:31:14.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.849]                               info, version)
[09:31:14.849]                           }
[09:31:14.849]                           base::stop(msg)
[09:31:14.849]                         }
[09:31:14.849]                       })
[09:31:14.849]                     }
[09:31:14.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.849]                     base::options(mc.cores = 1L)
[09:31:14.849]                   }
[09:31:14.849]                   ...future.strategy.old <- future::plan("list")
[09:31:14.849]                   options(future.plan = NULL)
[09:31:14.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.849]                 }
[09:31:14.849]                 ...future.workdir <- getwd()
[09:31:14.849]             }
[09:31:14.849]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.849]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.849]         }
[09:31:14.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.849]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.849]             base::names(...future.oldOptions))
[09:31:14.849]     }
[09:31:14.849]     if (FALSE) {
[09:31:14.849]     }
[09:31:14.849]     else {
[09:31:14.849]         if (TRUE) {
[09:31:14.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.849]                 open = "w")
[09:31:14.849]         }
[09:31:14.849]         else {
[09:31:14.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.849]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.849]         }
[09:31:14.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.849]             base::sink(type = "output", split = FALSE)
[09:31:14.849]             base::close(...future.stdout)
[09:31:14.849]         }, add = TRUE)
[09:31:14.849]     }
[09:31:14.849]     ...future.frame <- base::sys.nframe()
[09:31:14.849]     ...future.conditions <- base::list()
[09:31:14.849]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.849]     if (FALSE) {
[09:31:14.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.849]     }
[09:31:14.849]     ...future.result <- base::tryCatch({
[09:31:14.849]         base::withCallingHandlers({
[09:31:14.849]             ...future.value <- base::withVisible(base::local({
[09:31:14.849]                 ...future.makeSendCondition <- base::local({
[09:31:14.849]                   sendCondition <- NULL
[09:31:14.849]                   function(frame = 1L) {
[09:31:14.849]                     if (is.function(sendCondition)) 
[09:31:14.849]                       return(sendCondition)
[09:31:14.849]                     ns <- getNamespace("parallel")
[09:31:14.849]                     if (exists("sendData", mode = "function", 
[09:31:14.849]                       envir = ns)) {
[09:31:14.849]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.849]                         envir = ns)
[09:31:14.849]                       envir <- sys.frame(frame)
[09:31:14.849]                       master <- NULL
[09:31:14.849]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.849]                         !identical(envir, emptyenv())) {
[09:31:14.849]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.849]                           inherits = FALSE)) {
[09:31:14.849]                           master <- get("master", mode = "list", 
[09:31:14.849]                             envir = envir, inherits = FALSE)
[09:31:14.849]                           if (inherits(master, c("SOCKnode", 
[09:31:14.849]                             "SOCK0node"))) {
[09:31:14.849]                             sendCondition <<- function(cond) {
[09:31:14.849]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.849]                                 success = TRUE)
[09:31:14.849]                               parallel_sendData(master, data)
[09:31:14.849]                             }
[09:31:14.849]                             return(sendCondition)
[09:31:14.849]                           }
[09:31:14.849]                         }
[09:31:14.849]                         frame <- frame + 1L
[09:31:14.849]                         envir <- sys.frame(frame)
[09:31:14.849]                       }
[09:31:14.849]                     }
[09:31:14.849]                     sendCondition <<- function(cond) NULL
[09:31:14.849]                   }
[09:31:14.849]                 })
[09:31:14.849]                 withCallingHandlers({
[09:31:14.849]                   NULL
[09:31:14.849]                 }, immediateCondition = function(cond) {
[09:31:14.849]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.849]                   sendCondition(cond)
[09:31:14.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.849]                   {
[09:31:14.849]                     inherits <- base::inherits
[09:31:14.849]                     invokeRestart <- base::invokeRestart
[09:31:14.849]                     is.null <- base::is.null
[09:31:14.849]                     muffled <- FALSE
[09:31:14.849]                     if (inherits(cond, "message")) {
[09:31:14.849]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.849]                       if (muffled) 
[09:31:14.849]                         invokeRestart("muffleMessage")
[09:31:14.849]                     }
[09:31:14.849]                     else if (inherits(cond, "warning")) {
[09:31:14.849]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.849]                       if (muffled) 
[09:31:14.849]                         invokeRestart("muffleWarning")
[09:31:14.849]                     }
[09:31:14.849]                     else if (inherits(cond, "condition")) {
[09:31:14.849]                       if (!is.null(pattern)) {
[09:31:14.849]                         computeRestarts <- base::computeRestarts
[09:31:14.849]                         grepl <- base::grepl
[09:31:14.849]                         restarts <- computeRestarts(cond)
[09:31:14.849]                         for (restart in restarts) {
[09:31:14.849]                           name <- restart$name
[09:31:14.849]                           if (is.null(name)) 
[09:31:14.849]                             next
[09:31:14.849]                           if (!grepl(pattern, name)) 
[09:31:14.849]                             next
[09:31:14.849]                           invokeRestart(restart)
[09:31:14.849]                           muffled <- TRUE
[09:31:14.849]                           break
[09:31:14.849]                         }
[09:31:14.849]                       }
[09:31:14.849]                     }
[09:31:14.849]                     invisible(muffled)
[09:31:14.849]                   }
[09:31:14.849]                   muffleCondition(cond)
[09:31:14.849]                 })
[09:31:14.849]             }))
[09:31:14.849]             future::FutureResult(value = ...future.value$value, 
[09:31:14.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.849]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.849]                     ...future.globalenv.names))
[09:31:14.849]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.849]         }, condition = base::local({
[09:31:14.849]             c <- base::c
[09:31:14.849]             inherits <- base::inherits
[09:31:14.849]             invokeRestart <- base::invokeRestart
[09:31:14.849]             length <- base::length
[09:31:14.849]             list <- base::list
[09:31:14.849]             seq.int <- base::seq.int
[09:31:14.849]             signalCondition <- base::signalCondition
[09:31:14.849]             sys.calls <- base::sys.calls
[09:31:14.849]             `[[` <- base::`[[`
[09:31:14.849]             `+` <- base::`+`
[09:31:14.849]             `<<-` <- base::`<<-`
[09:31:14.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.849]                   3L)]
[09:31:14.849]             }
[09:31:14.849]             function(cond) {
[09:31:14.849]                 is_error <- inherits(cond, "error")
[09:31:14.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.849]                   NULL)
[09:31:14.849]                 if (is_error) {
[09:31:14.849]                   sessionInformation <- function() {
[09:31:14.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.849]                       search = base::search(), system = base::Sys.info())
[09:31:14.849]                   }
[09:31:14.849]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.849]                     cond$call), session = sessionInformation(), 
[09:31:14.849]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.849]                   signalCondition(cond)
[09:31:14.849]                 }
[09:31:14.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.849]                 "immediateCondition"))) {
[09:31:14.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.849]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.849]                   if (TRUE && !signal) {
[09:31:14.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.849]                     {
[09:31:14.849]                       inherits <- base::inherits
[09:31:14.849]                       invokeRestart <- base::invokeRestart
[09:31:14.849]                       is.null <- base::is.null
[09:31:14.849]                       muffled <- FALSE
[09:31:14.849]                       if (inherits(cond, "message")) {
[09:31:14.849]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.849]                         if (muffled) 
[09:31:14.849]                           invokeRestart("muffleMessage")
[09:31:14.849]                       }
[09:31:14.849]                       else if (inherits(cond, "warning")) {
[09:31:14.849]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.849]                         if (muffled) 
[09:31:14.849]                           invokeRestart("muffleWarning")
[09:31:14.849]                       }
[09:31:14.849]                       else if (inherits(cond, "condition")) {
[09:31:14.849]                         if (!is.null(pattern)) {
[09:31:14.849]                           computeRestarts <- base::computeRestarts
[09:31:14.849]                           grepl <- base::grepl
[09:31:14.849]                           restarts <- computeRestarts(cond)
[09:31:14.849]                           for (restart in restarts) {
[09:31:14.849]                             name <- restart$name
[09:31:14.849]                             if (is.null(name)) 
[09:31:14.849]                               next
[09:31:14.849]                             if (!grepl(pattern, name)) 
[09:31:14.849]                               next
[09:31:14.849]                             invokeRestart(restart)
[09:31:14.849]                             muffled <- TRUE
[09:31:14.849]                             break
[09:31:14.849]                           }
[09:31:14.849]                         }
[09:31:14.849]                       }
[09:31:14.849]                       invisible(muffled)
[09:31:14.849]                     }
[09:31:14.849]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.849]                   }
[09:31:14.849]                 }
[09:31:14.849]                 else {
[09:31:14.849]                   if (TRUE) {
[09:31:14.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.849]                     {
[09:31:14.849]                       inherits <- base::inherits
[09:31:14.849]                       invokeRestart <- base::invokeRestart
[09:31:14.849]                       is.null <- base::is.null
[09:31:14.849]                       muffled <- FALSE
[09:31:14.849]                       if (inherits(cond, "message")) {
[09:31:14.849]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.849]                         if (muffled) 
[09:31:14.849]                           invokeRestart("muffleMessage")
[09:31:14.849]                       }
[09:31:14.849]                       else if (inherits(cond, "warning")) {
[09:31:14.849]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.849]                         if (muffled) 
[09:31:14.849]                           invokeRestart("muffleWarning")
[09:31:14.849]                       }
[09:31:14.849]                       else if (inherits(cond, "condition")) {
[09:31:14.849]                         if (!is.null(pattern)) {
[09:31:14.849]                           computeRestarts <- base::computeRestarts
[09:31:14.849]                           grepl <- base::grepl
[09:31:14.849]                           restarts <- computeRestarts(cond)
[09:31:14.849]                           for (restart in restarts) {
[09:31:14.849]                             name <- restart$name
[09:31:14.849]                             if (is.null(name)) 
[09:31:14.849]                               next
[09:31:14.849]                             if (!grepl(pattern, name)) 
[09:31:14.849]                               next
[09:31:14.849]                             invokeRestart(restart)
[09:31:14.849]                             muffled <- TRUE
[09:31:14.849]                             break
[09:31:14.849]                           }
[09:31:14.849]                         }
[09:31:14.849]                       }
[09:31:14.849]                       invisible(muffled)
[09:31:14.849]                     }
[09:31:14.849]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.849]                   }
[09:31:14.849]                 }
[09:31:14.849]             }
[09:31:14.849]         }))
[09:31:14.849]     }, error = function(ex) {
[09:31:14.849]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.849]                 ...future.rng), started = ...future.startTime, 
[09:31:14.849]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.849]             version = "1.8"), class = "FutureResult")
[09:31:14.849]     }, finally = {
[09:31:14.849]         if (!identical(...future.workdir, getwd())) 
[09:31:14.849]             setwd(...future.workdir)
[09:31:14.849]         {
[09:31:14.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.849]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.849]             }
[09:31:14.849]             base::options(...future.oldOptions)
[09:31:14.849]             if (.Platform$OS.type == "windows") {
[09:31:14.849]                 old_names <- names(...future.oldEnvVars)
[09:31:14.849]                 envs <- base::Sys.getenv()
[09:31:14.849]                 names <- names(envs)
[09:31:14.849]                 common <- intersect(names, old_names)
[09:31:14.849]                 added <- setdiff(names, old_names)
[09:31:14.849]                 removed <- setdiff(old_names, names)
[09:31:14.849]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.849]                   envs[common]]
[09:31:14.849]                 NAMES <- toupper(changed)
[09:31:14.849]                 args <- list()
[09:31:14.849]                 for (kk in seq_along(NAMES)) {
[09:31:14.849]                   name <- changed[[kk]]
[09:31:14.849]                   NAME <- NAMES[[kk]]
[09:31:14.849]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.849]                     next
[09:31:14.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.849]                 }
[09:31:14.849]                 NAMES <- toupper(added)
[09:31:14.849]                 for (kk in seq_along(NAMES)) {
[09:31:14.849]                   name <- added[[kk]]
[09:31:14.849]                   NAME <- NAMES[[kk]]
[09:31:14.849]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.849]                     next
[09:31:14.849]                   args[[name]] <- ""
[09:31:14.849]                 }
[09:31:14.849]                 NAMES <- toupper(removed)
[09:31:14.849]                 for (kk in seq_along(NAMES)) {
[09:31:14.849]                   name <- removed[[kk]]
[09:31:14.849]                   NAME <- NAMES[[kk]]
[09:31:14.849]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.849]                     next
[09:31:14.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.849]                 }
[09:31:14.849]                 if (length(args) > 0) 
[09:31:14.849]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.849]             }
[09:31:14.849]             else {
[09:31:14.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.849]             }
[09:31:14.849]             {
[09:31:14.849]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.849]                   0L) {
[09:31:14.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.849]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.849]                   base::options(opts)
[09:31:14.849]                 }
[09:31:14.849]                 {
[09:31:14.849]                   {
[09:31:14.849]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.849]                     NULL
[09:31:14.849]                   }
[09:31:14.849]                   options(future.plan = NULL)
[09:31:14.849]                   if (is.na(NA_character_)) 
[09:31:14.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.849]                     .init = FALSE)
[09:31:14.849]                 }
[09:31:14.849]             }
[09:31:14.849]         }
[09:31:14.849]     })
[09:31:14.849]     if (TRUE) {
[09:31:14.849]         base::sink(type = "output", split = FALSE)
[09:31:14.849]         if (TRUE) {
[09:31:14.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.849]         }
[09:31:14.849]         else {
[09:31:14.849]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.849]         }
[09:31:14.849]         base::close(...future.stdout)
[09:31:14.849]         ...future.stdout <- NULL
[09:31:14.849]     }
[09:31:14.849]     ...future.result$conditions <- ...future.conditions
[09:31:14.849]     ...future.result$finished <- base::Sys.time()
[09:31:14.849]     ...future.result
[09:31:14.849] }
[09:31:14.851] MultisessionFuture started
[09:31:14.851] - Launch lazy future ... done
[09:31:14.852] run() for ‘MultisessionFuture’ ... done
[09:31:14.852] getGlobalsAndPackages() ...
[09:31:14.852] Searching for globals...
[09:31:14.853] - globals found: [1] ‘{’
[09:31:14.853] Searching for globals ... DONE
[09:31:14.853] Resolving globals: FALSE
[09:31:14.853] 
[09:31:14.853] 
[09:31:14.853] getGlobalsAndPackages() ... DONE
[09:31:14.853] run() for ‘Future’ ...
[09:31:14.854] - state: ‘created’
[09:31:14.854] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.867] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.867]   - Field: ‘node’
[09:31:14.867]   - Field: ‘label’
[09:31:14.867]   - Field: ‘local’
[09:31:14.868]   - Field: ‘owner’
[09:31:14.868]   - Field: ‘envir’
[09:31:14.868]   - Field: ‘workers’
[09:31:14.868]   - Field: ‘packages’
[09:31:14.868]   - Field: ‘gc’
[09:31:14.868]   - Field: ‘conditions’
[09:31:14.868]   - Field: ‘persistent’
[09:31:14.868]   - Field: ‘expr’
[09:31:14.868]   - Field: ‘uuid’
[09:31:14.868]   - Field: ‘seed’
[09:31:14.868]   - Field: ‘version’
[09:31:14.869]   - Field: ‘result’
[09:31:14.869]   - Field: ‘asynchronous’
[09:31:14.869]   - Field: ‘calls’
[09:31:14.869]   - Field: ‘globals’
[09:31:14.869]   - Field: ‘stdout’
[09:31:14.869]   - Field: ‘earlySignal’
[09:31:14.869]   - Field: ‘lazy’
[09:31:14.869]   - Field: ‘state’
[09:31:14.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.869] - Launch lazy future ...
[09:31:14.870] Packages needed by the future expression (n = 0): <none>
[09:31:14.870] Packages needed by future strategies (n = 0): <none>
[09:31:14.870] {
[09:31:14.870]     {
[09:31:14.870]         {
[09:31:14.870]             ...future.startTime <- base::Sys.time()
[09:31:14.870]             {
[09:31:14.870]                 {
[09:31:14.870]                   {
[09:31:14.870]                     {
[09:31:14.870]                       base::local({
[09:31:14.870]                         has_future <- base::requireNamespace("future", 
[09:31:14.870]                           quietly = TRUE)
[09:31:14.870]                         if (has_future) {
[09:31:14.870]                           ns <- base::getNamespace("future")
[09:31:14.870]                           version <- ns[[".package"]][["version"]]
[09:31:14.870]                           if (is.null(version)) 
[09:31:14.870]                             version <- utils::packageVersion("future")
[09:31:14.870]                         }
[09:31:14.870]                         else {
[09:31:14.870]                           version <- NULL
[09:31:14.870]                         }
[09:31:14.870]                         if (!has_future || version < "1.8.0") {
[09:31:14.870]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.870]                             "", base::R.version$version.string), 
[09:31:14.870]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.870]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.870]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.870]                               "release", "version")], collapse = " "), 
[09:31:14.870]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.870]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.870]                             info)
[09:31:14.870]                           info <- base::paste(info, collapse = "; ")
[09:31:14.870]                           if (!has_future) {
[09:31:14.870]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.870]                               info)
[09:31:14.870]                           }
[09:31:14.870]                           else {
[09:31:14.870]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.870]                               info, version)
[09:31:14.870]                           }
[09:31:14.870]                           base::stop(msg)
[09:31:14.870]                         }
[09:31:14.870]                       })
[09:31:14.870]                     }
[09:31:14.870]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.870]                     base::options(mc.cores = 1L)
[09:31:14.870]                   }
[09:31:14.870]                   ...future.strategy.old <- future::plan("list")
[09:31:14.870]                   options(future.plan = NULL)
[09:31:14.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.870]                 }
[09:31:14.870]                 ...future.workdir <- getwd()
[09:31:14.870]             }
[09:31:14.870]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.870]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.870]         }
[09:31:14.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.870]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.870]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.870]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.870]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.870]             base::names(...future.oldOptions))
[09:31:14.870]     }
[09:31:14.870]     if (FALSE) {
[09:31:14.870]     }
[09:31:14.870]     else {
[09:31:14.870]         if (TRUE) {
[09:31:14.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.870]                 open = "w")
[09:31:14.870]         }
[09:31:14.870]         else {
[09:31:14.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.870]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.870]         }
[09:31:14.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.870]             base::sink(type = "output", split = FALSE)
[09:31:14.870]             base::close(...future.stdout)
[09:31:14.870]         }, add = TRUE)
[09:31:14.870]     }
[09:31:14.870]     ...future.frame <- base::sys.nframe()
[09:31:14.870]     ...future.conditions <- base::list()
[09:31:14.870]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.870]     if (FALSE) {
[09:31:14.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.870]     }
[09:31:14.870]     ...future.result <- base::tryCatch({
[09:31:14.870]         base::withCallingHandlers({
[09:31:14.870]             ...future.value <- base::withVisible(base::local({
[09:31:14.870]                 ...future.makeSendCondition <- base::local({
[09:31:14.870]                   sendCondition <- NULL
[09:31:14.870]                   function(frame = 1L) {
[09:31:14.870]                     if (is.function(sendCondition)) 
[09:31:14.870]                       return(sendCondition)
[09:31:14.870]                     ns <- getNamespace("parallel")
[09:31:14.870]                     if (exists("sendData", mode = "function", 
[09:31:14.870]                       envir = ns)) {
[09:31:14.870]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.870]                         envir = ns)
[09:31:14.870]                       envir <- sys.frame(frame)
[09:31:14.870]                       master <- NULL
[09:31:14.870]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.870]                         !identical(envir, emptyenv())) {
[09:31:14.870]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.870]                           inherits = FALSE)) {
[09:31:14.870]                           master <- get("master", mode = "list", 
[09:31:14.870]                             envir = envir, inherits = FALSE)
[09:31:14.870]                           if (inherits(master, c("SOCKnode", 
[09:31:14.870]                             "SOCK0node"))) {
[09:31:14.870]                             sendCondition <<- function(cond) {
[09:31:14.870]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.870]                                 success = TRUE)
[09:31:14.870]                               parallel_sendData(master, data)
[09:31:14.870]                             }
[09:31:14.870]                             return(sendCondition)
[09:31:14.870]                           }
[09:31:14.870]                         }
[09:31:14.870]                         frame <- frame + 1L
[09:31:14.870]                         envir <- sys.frame(frame)
[09:31:14.870]                       }
[09:31:14.870]                     }
[09:31:14.870]                     sendCondition <<- function(cond) NULL
[09:31:14.870]                   }
[09:31:14.870]                 })
[09:31:14.870]                 withCallingHandlers({
[09:31:14.870]                   {
[09:31:14.870]                     4
[09:31:14.870]                   }
[09:31:14.870]                 }, immediateCondition = function(cond) {
[09:31:14.870]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.870]                   sendCondition(cond)
[09:31:14.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.870]                   {
[09:31:14.870]                     inherits <- base::inherits
[09:31:14.870]                     invokeRestart <- base::invokeRestart
[09:31:14.870]                     is.null <- base::is.null
[09:31:14.870]                     muffled <- FALSE
[09:31:14.870]                     if (inherits(cond, "message")) {
[09:31:14.870]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.870]                       if (muffled) 
[09:31:14.870]                         invokeRestart("muffleMessage")
[09:31:14.870]                     }
[09:31:14.870]                     else if (inherits(cond, "warning")) {
[09:31:14.870]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.870]                       if (muffled) 
[09:31:14.870]                         invokeRestart("muffleWarning")
[09:31:14.870]                     }
[09:31:14.870]                     else if (inherits(cond, "condition")) {
[09:31:14.870]                       if (!is.null(pattern)) {
[09:31:14.870]                         computeRestarts <- base::computeRestarts
[09:31:14.870]                         grepl <- base::grepl
[09:31:14.870]                         restarts <- computeRestarts(cond)
[09:31:14.870]                         for (restart in restarts) {
[09:31:14.870]                           name <- restart$name
[09:31:14.870]                           if (is.null(name)) 
[09:31:14.870]                             next
[09:31:14.870]                           if (!grepl(pattern, name)) 
[09:31:14.870]                             next
[09:31:14.870]                           invokeRestart(restart)
[09:31:14.870]                           muffled <- TRUE
[09:31:14.870]                           break
[09:31:14.870]                         }
[09:31:14.870]                       }
[09:31:14.870]                     }
[09:31:14.870]                     invisible(muffled)
[09:31:14.870]                   }
[09:31:14.870]                   muffleCondition(cond)
[09:31:14.870]                 })
[09:31:14.870]             }))
[09:31:14.870]             future::FutureResult(value = ...future.value$value, 
[09:31:14.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.870]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.870]                     ...future.globalenv.names))
[09:31:14.870]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.870]         }, condition = base::local({
[09:31:14.870]             c <- base::c
[09:31:14.870]             inherits <- base::inherits
[09:31:14.870]             invokeRestart <- base::invokeRestart
[09:31:14.870]             length <- base::length
[09:31:14.870]             list <- base::list
[09:31:14.870]             seq.int <- base::seq.int
[09:31:14.870]             signalCondition <- base::signalCondition
[09:31:14.870]             sys.calls <- base::sys.calls
[09:31:14.870]             `[[` <- base::`[[`
[09:31:14.870]             `+` <- base::`+`
[09:31:14.870]             `<<-` <- base::`<<-`
[09:31:14.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.870]                   3L)]
[09:31:14.870]             }
[09:31:14.870]             function(cond) {
[09:31:14.870]                 is_error <- inherits(cond, "error")
[09:31:14.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.870]                   NULL)
[09:31:14.870]                 if (is_error) {
[09:31:14.870]                   sessionInformation <- function() {
[09:31:14.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.870]                       search = base::search(), system = base::Sys.info())
[09:31:14.870]                   }
[09:31:14.870]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.870]                     cond$call), session = sessionInformation(), 
[09:31:14.870]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.870]                   signalCondition(cond)
[09:31:14.870]                 }
[09:31:14.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.870]                 "immediateCondition"))) {
[09:31:14.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.870]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.870]                   if (TRUE && !signal) {
[09:31:14.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.870]                     {
[09:31:14.870]                       inherits <- base::inherits
[09:31:14.870]                       invokeRestart <- base::invokeRestart
[09:31:14.870]                       is.null <- base::is.null
[09:31:14.870]                       muffled <- FALSE
[09:31:14.870]                       if (inherits(cond, "message")) {
[09:31:14.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.870]                         if (muffled) 
[09:31:14.870]                           invokeRestart("muffleMessage")
[09:31:14.870]                       }
[09:31:14.870]                       else if (inherits(cond, "warning")) {
[09:31:14.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.870]                         if (muffled) 
[09:31:14.870]                           invokeRestart("muffleWarning")
[09:31:14.870]                       }
[09:31:14.870]                       else if (inherits(cond, "condition")) {
[09:31:14.870]                         if (!is.null(pattern)) {
[09:31:14.870]                           computeRestarts <- base::computeRestarts
[09:31:14.870]                           grepl <- base::grepl
[09:31:14.870]                           restarts <- computeRestarts(cond)
[09:31:14.870]                           for (restart in restarts) {
[09:31:14.870]                             name <- restart$name
[09:31:14.870]                             if (is.null(name)) 
[09:31:14.870]                               next
[09:31:14.870]                             if (!grepl(pattern, name)) 
[09:31:14.870]                               next
[09:31:14.870]                             invokeRestart(restart)
[09:31:14.870]                             muffled <- TRUE
[09:31:14.870]                             break
[09:31:14.870]                           }
[09:31:14.870]                         }
[09:31:14.870]                       }
[09:31:14.870]                       invisible(muffled)
[09:31:14.870]                     }
[09:31:14.870]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.870]                   }
[09:31:14.870]                 }
[09:31:14.870]                 else {
[09:31:14.870]                   if (TRUE) {
[09:31:14.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.870]                     {
[09:31:14.870]                       inherits <- base::inherits
[09:31:14.870]                       invokeRestart <- base::invokeRestart
[09:31:14.870]                       is.null <- base::is.null
[09:31:14.870]                       muffled <- FALSE
[09:31:14.870]                       if (inherits(cond, "message")) {
[09:31:14.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.870]                         if (muffled) 
[09:31:14.870]                           invokeRestart("muffleMessage")
[09:31:14.870]                       }
[09:31:14.870]                       else if (inherits(cond, "warning")) {
[09:31:14.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.870]                         if (muffled) 
[09:31:14.870]                           invokeRestart("muffleWarning")
[09:31:14.870]                       }
[09:31:14.870]                       else if (inherits(cond, "condition")) {
[09:31:14.870]                         if (!is.null(pattern)) {
[09:31:14.870]                           computeRestarts <- base::computeRestarts
[09:31:14.870]                           grepl <- base::grepl
[09:31:14.870]                           restarts <- computeRestarts(cond)
[09:31:14.870]                           for (restart in restarts) {
[09:31:14.870]                             name <- restart$name
[09:31:14.870]                             if (is.null(name)) 
[09:31:14.870]                               next
[09:31:14.870]                             if (!grepl(pattern, name)) 
[09:31:14.870]                               next
[09:31:14.870]                             invokeRestart(restart)
[09:31:14.870]                             muffled <- TRUE
[09:31:14.870]                             break
[09:31:14.870]                           }
[09:31:14.870]                         }
[09:31:14.870]                       }
[09:31:14.870]                       invisible(muffled)
[09:31:14.870]                     }
[09:31:14.870]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.870]                   }
[09:31:14.870]                 }
[09:31:14.870]             }
[09:31:14.870]         }))
[09:31:14.870]     }, error = function(ex) {
[09:31:14.870]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.870]                 ...future.rng), started = ...future.startTime, 
[09:31:14.870]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.870]             version = "1.8"), class = "FutureResult")
[09:31:14.870]     }, finally = {
[09:31:14.870]         if (!identical(...future.workdir, getwd())) 
[09:31:14.870]             setwd(...future.workdir)
[09:31:14.870]         {
[09:31:14.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.870]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.870]             }
[09:31:14.870]             base::options(...future.oldOptions)
[09:31:14.870]             if (.Platform$OS.type == "windows") {
[09:31:14.870]                 old_names <- names(...future.oldEnvVars)
[09:31:14.870]                 envs <- base::Sys.getenv()
[09:31:14.870]                 names <- names(envs)
[09:31:14.870]                 common <- intersect(names, old_names)
[09:31:14.870]                 added <- setdiff(names, old_names)
[09:31:14.870]                 removed <- setdiff(old_names, names)
[09:31:14.870]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.870]                   envs[common]]
[09:31:14.870]                 NAMES <- toupper(changed)
[09:31:14.870]                 args <- list()
[09:31:14.870]                 for (kk in seq_along(NAMES)) {
[09:31:14.870]                   name <- changed[[kk]]
[09:31:14.870]                   NAME <- NAMES[[kk]]
[09:31:14.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.870]                     next
[09:31:14.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.870]                 }
[09:31:14.870]                 NAMES <- toupper(added)
[09:31:14.870]                 for (kk in seq_along(NAMES)) {
[09:31:14.870]                   name <- added[[kk]]
[09:31:14.870]                   NAME <- NAMES[[kk]]
[09:31:14.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.870]                     next
[09:31:14.870]                   args[[name]] <- ""
[09:31:14.870]                 }
[09:31:14.870]                 NAMES <- toupper(removed)
[09:31:14.870]                 for (kk in seq_along(NAMES)) {
[09:31:14.870]                   name <- removed[[kk]]
[09:31:14.870]                   NAME <- NAMES[[kk]]
[09:31:14.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.870]                     next
[09:31:14.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.870]                 }
[09:31:14.870]                 if (length(args) > 0) 
[09:31:14.870]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.870]             }
[09:31:14.870]             else {
[09:31:14.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.870]             }
[09:31:14.870]             {
[09:31:14.870]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.870]                   0L) {
[09:31:14.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.870]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.870]                   base::options(opts)
[09:31:14.870]                 }
[09:31:14.870]                 {
[09:31:14.870]                   {
[09:31:14.870]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.870]                     NULL
[09:31:14.870]                   }
[09:31:14.870]                   options(future.plan = NULL)
[09:31:14.870]                   if (is.na(NA_character_)) 
[09:31:14.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.870]                     .init = FALSE)
[09:31:14.870]                 }
[09:31:14.870]             }
[09:31:14.870]         }
[09:31:14.870]     })
[09:31:14.870]     if (TRUE) {
[09:31:14.870]         base::sink(type = "output", split = FALSE)
[09:31:14.870]         if (TRUE) {
[09:31:14.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.870]         }
[09:31:14.870]         else {
[09:31:14.870]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.870]         }
[09:31:14.870]         base::close(...future.stdout)
[09:31:14.870]         ...future.stdout <- NULL
[09:31:14.870]     }
[09:31:14.870]     ...future.result$conditions <- ...future.conditions
[09:31:14.870]     ...future.result$finished <- base::Sys.time()
[09:31:14.870]     ...future.result
[09:31:14.870] }
[09:31:14.872] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:14.883] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.883] - Validating connection of MultisessionFuture
[09:31:14.883] - received message: FutureResult
[09:31:14.883] - Received FutureResult
[09:31:14.883] - Erased future from FutureRegistry
[09:31:14.883] result() for ClusterFuture ...
[09:31:14.883] - result already collected: FutureResult
[09:31:14.884] result() for ClusterFuture ... done
[09:31:14.884] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.884] result() for ClusterFuture ...
[09:31:14.884] - result already collected: FutureResult
[09:31:14.884] result() for ClusterFuture ... done
[09:31:14.884] result() for ClusterFuture ...
[09:31:14.884] - result already collected: FutureResult
[09:31:14.884] result() for ClusterFuture ... done
[09:31:14.885] MultisessionFuture started
[09:31:14.885] - Launch lazy future ... done
[09:31:14.885] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a3cae01300> 
<environment: 0x55a3cbf59210> 
[09:31:14.887] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.887] - Validating connection of MultisessionFuture
[09:31:14.887] - received message: FutureResult
[09:31:14.887] - Received FutureResult
[09:31:14.887] - Erased future from FutureRegistry
[09:31:14.887] result() for ClusterFuture ...
[09:31:14.888] - result already collected: FutureResult
[09:31:14.888] result() for ClusterFuture ... done
[09:31:14.888] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.888] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.888] - Validating connection of MultisessionFuture
[09:31:14.888] - received message: FutureResult
[09:31:14.888] - Received FutureResult
[09:31:14.889] - Erased future from FutureRegistry
[09:31:14.889] result() for ClusterFuture ...
[09:31:14.889] - result already collected: FutureResult
[09:31:14.889] result() for ClusterFuture ... done
[09:31:14.889] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.890] resolve() on environment ...
[09:31:14.890]  recursive: 0
[09:31:14.891]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.891] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.891] - nx: 4
[09:31:14.891] - relay: TRUE
[09:31:14.891] - stdout: TRUE
[09:31:14.891] - signal: TRUE
[09:31:14.891] - resignal: FALSE
[09:31:14.891] - force: TRUE
[09:31:14.891] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.891] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.891]  - until=2
[09:31:14.892]  - relaying element #2
[09:31:14.892] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.892] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.892] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.892]  length: 3 (resolved future 1)
[09:31:14.892] Future #2
[09:31:14.892] result() for ClusterFuture ...
[09:31:14.892] - result already collected: FutureResult
[09:31:14.892] result() for ClusterFuture ... done
[09:31:14.892] result() for ClusterFuture ...
[09:31:14.892] - result already collected: FutureResult
[09:31:14.893] result() for ClusterFuture ... done
[09:31:14.893] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:14.893] - nx: 4
[09:31:14.893] - relay: TRUE
[09:31:14.893] - stdout: TRUE
[09:31:14.893] - signal: TRUE
[09:31:14.893] - resignal: FALSE
[09:31:14.893] - force: TRUE
[09:31:14.893] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.893] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.893]  - until=2
[09:31:14.894]  - relaying element #2
[09:31:14.894] result() for ClusterFuture ...
[09:31:14.894] - result already collected: FutureResult
[09:31:14.894] result() for ClusterFuture ... done
[09:31:14.894] result() for ClusterFuture ...
[09:31:14.894] - result already collected: FutureResult
[09:31:14.894] result() for ClusterFuture ... done
[09:31:14.894] result() for ClusterFuture ...
[09:31:14.894] - result already collected: FutureResult
[09:31:14.894] result() for ClusterFuture ... done
[09:31:14.894] result() for ClusterFuture ...
[09:31:14.894] - result already collected: FutureResult
[09:31:14.895] result() for ClusterFuture ... done
[09:31:14.895] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.895] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.895] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:14.895]  length: 2 (resolved future 2)
[09:31:14.895] Future #3
[09:31:14.895] result() for ClusterFuture ...
[09:31:14.895] - result already collected: FutureResult
[09:31:14.895] result() for ClusterFuture ... done
[09:31:14.895] result() for ClusterFuture ...
[09:31:14.895] - result already collected: FutureResult
[09:31:14.896] result() for ClusterFuture ... done
[09:31:14.896] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:14.896] - nx: 4
[09:31:14.896] - relay: TRUE
[09:31:14.896] - stdout: TRUE
[09:31:14.896] - signal: TRUE
[09:31:14.896] - resignal: FALSE
[09:31:14.896] - force: TRUE
[09:31:14.896] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.896] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.896]  - until=3
[09:31:14.896]  - relaying element #3
[09:31:14.897] result() for ClusterFuture ...
[09:31:14.897] - result already collected: FutureResult
[09:31:14.897] result() for ClusterFuture ... done
[09:31:14.897] result() for ClusterFuture ...
[09:31:14.897] - result already collected: FutureResult
[09:31:14.897] result() for ClusterFuture ... done
[09:31:14.897] result() for ClusterFuture ...
[09:31:14.897] - result already collected: FutureResult
[09:31:14.897] result() for ClusterFuture ... done
[09:31:14.897] result() for ClusterFuture ...
[09:31:14.897] - result already collected: FutureResult
[09:31:14.898] result() for ClusterFuture ... done
[09:31:14.898] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.898] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.898] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:14.898]  length: 1 (resolved future 3)
[09:31:14.898] Future #4
[09:31:14.898] result() for ClusterFuture ...
[09:31:14.898] - result already collected: FutureResult
[09:31:14.898] result() for ClusterFuture ... done
[09:31:14.898] result() for ClusterFuture ...
[09:31:14.898] - result already collected: FutureResult
[09:31:14.898] result() for ClusterFuture ... done
[09:31:14.899] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:14.899] - nx: 4
[09:31:14.899] - relay: TRUE
[09:31:14.899] - stdout: TRUE
[09:31:14.899] - signal: TRUE
[09:31:14.899] - resignal: FALSE
[09:31:14.899] - force: TRUE
[09:31:14.899] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.899] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.899]  - until=4
[09:31:14.899]  - relaying element #4
[09:31:14.899] result() for ClusterFuture ...
[09:31:14.900] - result already collected: FutureResult
[09:31:14.900] result() for ClusterFuture ... done
[09:31:14.900] result() for ClusterFuture ...
[09:31:14.900] - result already collected: FutureResult
[09:31:14.900] result() for ClusterFuture ... done
[09:31:14.900] result() for ClusterFuture ...
[09:31:14.900] - result already collected: FutureResult
[09:31:14.900] result() for ClusterFuture ... done
[09:31:14.900] result() for ClusterFuture ...
[09:31:14.900] - result already collected: FutureResult
[09:31:14.900] result() for ClusterFuture ... done
[09:31:14.900] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.901] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.901] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:14.901]  length: 0 (resolved future 4)
[09:31:14.901] Relaying remaining futures
[09:31:14.901] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.901] - nx: 4
[09:31:14.901] - relay: TRUE
[09:31:14.901] - stdout: TRUE
[09:31:14.901] - signal: TRUE
[09:31:14.901] - resignal: FALSE
[09:31:14.901] - force: TRUE
[09:31:14.901] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.902] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.902] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.902] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.902] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.902] resolve() on environment ... DONE
[09:31:14.902] result() for ClusterFuture ...
[09:31:14.902] - result already collected: FutureResult
[09:31:14.902] result() for ClusterFuture ... done
[09:31:14.902] result() for ClusterFuture ...
[09:31:14.902] - result already collected: FutureResult
[09:31:14.902] result() for ClusterFuture ... done
[09:31:14.903] result() for ClusterFuture ...
[09:31:14.903] - result already collected: FutureResult
[09:31:14.903] result() for ClusterFuture ... done
[09:31:14.903] result() for ClusterFuture ...
[09:31:14.903] - result already collected: FutureResult
[09:31:14.903] result() for ClusterFuture ... done
[09:31:14.903] result() for ClusterFuture ...
[09:31:14.903] - result already collected: FutureResult
[09:31:14.903] result() for ClusterFuture ... done
[09:31:14.903] result() for ClusterFuture ...
[09:31:14.903] - result already collected: FutureResult
[09:31:14.903] result() for ClusterFuture ... done
<environment: 0x55a3cc17ce58> 
Dimensions: c(2, 1, 3, 1)
[09:31:14.904] getGlobalsAndPackages() ...
[09:31:14.904] Searching for globals...
[09:31:14.904] 
[09:31:14.904] Searching for globals ... DONE
[09:31:14.904] - globals: [0] <none>
[09:31:14.905] getGlobalsAndPackages() ... DONE
[09:31:14.905] run() for ‘Future’ ...
[09:31:14.905] - state: ‘created’
[09:31:14.905] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.918] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.918]   - Field: ‘node’
[09:31:14.919]   - Field: ‘label’
[09:31:14.919]   - Field: ‘local’
[09:31:14.919]   - Field: ‘owner’
[09:31:14.919]   - Field: ‘envir’
[09:31:14.919]   - Field: ‘workers’
[09:31:14.919]   - Field: ‘packages’
[09:31:14.919]   - Field: ‘gc’
[09:31:14.919]   - Field: ‘conditions’
[09:31:14.919]   - Field: ‘persistent’
[09:31:14.919]   - Field: ‘expr’
[09:31:14.919]   - Field: ‘uuid’
[09:31:14.919]   - Field: ‘seed’
[09:31:14.920]   - Field: ‘version’
[09:31:14.920]   - Field: ‘result’
[09:31:14.920]   - Field: ‘asynchronous’
[09:31:14.920]   - Field: ‘calls’
[09:31:14.920]   - Field: ‘globals’
[09:31:14.920]   - Field: ‘stdout’
[09:31:14.920]   - Field: ‘earlySignal’
[09:31:14.920]   - Field: ‘lazy’
[09:31:14.920]   - Field: ‘state’
[09:31:14.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.921] - Launch lazy future ...
[09:31:14.921] Packages needed by the future expression (n = 0): <none>
[09:31:14.921] Packages needed by future strategies (n = 0): <none>
[09:31:14.921] {
[09:31:14.921]     {
[09:31:14.921]         {
[09:31:14.921]             ...future.startTime <- base::Sys.time()
[09:31:14.921]             {
[09:31:14.921]                 {
[09:31:14.921]                   {
[09:31:14.921]                     {
[09:31:14.921]                       base::local({
[09:31:14.921]                         has_future <- base::requireNamespace("future", 
[09:31:14.921]                           quietly = TRUE)
[09:31:14.921]                         if (has_future) {
[09:31:14.921]                           ns <- base::getNamespace("future")
[09:31:14.921]                           version <- ns[[".package"]][["version"]]
[09:31:14.921]                           if (is.null(version)) 
[09:31:14.921]                             version <- utils::packageVersion("future")
[09:31:14.921]                         }
[09:31:14.921]                         else {
[09:31:14.921]                           version <- NULL
[09:31:14.921]                         }
[09:31:14.921]                         if (!has_future || version < "1.8.0") {
[09:31:14.921]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.921]                             "", base::R.version$version.string), 
[09:31:14.921]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.921]                               "release", "version")], collapse = " "), 
[09:31:14.921]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.921]                             info)
[09:31:14.921]                           info <- base::paste(info, collapse = "; ")
[09:31:14.921]                           if (!has_future) {
[09:31:14.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.921]                               info)
[09:31:14.921]                           }
[09:31:14.921]                           else {
[09:31:14.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.921]                               info, version)
[09:31:14.921]                           }
[09:31:14.921]                           base::stop(msg)
[09:31:14.921]                         }
[09:31:14.921]                       })
[09:31:14.921]                     }
[09:31:14.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.921]                     base::options(mc.cores = 1L)
[09:31:14.921]                   }
[09:31:14.921]                   ...future.strategy.old <- future::plan("list")
[09:31:14.921]                   options(future.plan = NULL)
[09:31:14.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.921]                 }
[09:31:14.921]                 ...future.workdir <- getwd()
[09:31:14.921]             }
[09:31:14.921]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.921]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.921]         }
[09:31:14.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.921]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.921]             base::names(...future.oldOptions))
[09:31:14.921]     }
[09:31:14.921]     if (FALSE) {
[09:31:14.921]     }
[09:31:14.921]     else {
[09:31:14.921]         if (TRUE) {
[09:31:14.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.921]                 open = "w")
[09:31:14.921]         }
[09:31:14.921]         else {
[09:31:14.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.921]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.921]         }
[09:31:14.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.921]             base::sink(type = "output", split = FALSE)
[09:31:14.921]             base::close(...future.stdout)
[09:31:14.921]         }, add = TRUE)
[09:31:14.921]     }
[09:31:14.921]     ...future.frame <- base::sys.nframe()
[09:31:14.921]     ...future.conditions <- base::list()
[09:31:14.921]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.921]     if (FALSE) {
[09:31:14.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.921]     }
[09:31:14.921]     ...future.result <- base::tryCatch({
[09:31:14.921]         base::withCallingHandlers({
[09:31:14.921]             ...future.value <- base::withVisible(base::local({
[09:31:14.921]                 ...future.makeSendCondition <- base::local({
[09:31:14.921]                   sendCondition <- NULL
[09:31:14.921]                   function(frame = 1L) {
[09:31:14.921]                     if (is.function(sendCondition)) 
[09:31:14.921]                       return(sendCondition)
[09:31:14.921]                     ns <- getNamespace("parallel")
[09:31:14.921]                     if (exists("sendData", mode = "function", 
[09:31:14.921]                       envir = ns)) {
[09:31:14.921]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.921]                         envir = ns)
[09:31:14.921]                       envir <- sys.frame(frame)
[09:31:14.921]                       master <- NULL
[09:31:14.921]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.921]                         !identical(envir, emptyenv())) {
[09:31:14.921]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.921]                           inherits = FALSE)) {
[09:31:14.921]                           master <- get("master", mode = "list", 
[09:31:14.921]                             envir = envir, inherits = FALSE)
[09:31:14.921]                           if (inherits(master, c("SOCKnode", 
[09:31:14.921]                             "SOCK0node"))) {
[09:31:14.921]                             sendCondition <<- function(cond) {
[09:31:14.921]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.921]                                 success = TRUE)
[09:31:14.921]                               parallel_sendData(master, data)
[09:31:14.921]                             }
[09:31:14.921]                             return(sendCondition)
[09:31:14.921]                           }
[09:31:14.921]                         }
[09:31:14.921]                         frame <- frame + 1L
[09:31:14.921]                         envir <- sys.frame(frame)
[09:31:14.921]                       }
[09:31:14.921]                     }
[09:31:14.921]                     sendCondition <<- function(cond) NULL
[09:31:14.921]                   }
[09:31:14.921]                 })
[09:31:14.921]                 withCallingHandlers({
[09:31:14.921]                   2
[09:31:14.921]                 }, immediateCondition = function(cond) {
[09:31:14.921]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.921]                   sendCondition(cond)
[09:31:14.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.921]                   {
[09:31:14.921]                     inherits <- base::inherits
[09:31:14.921]                     invokeRestart <- base::invokeRestart
[09:31:14.921]                     is.null <- base::is.null
[09:31:14.921]                     muffled <- FALSE
[09:31:14.921]                     if (inherits(cond, "message")) {
[09:31:14.921]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.921]                       if (muffled) 
[09:31:14.921]                         invokeRestart("muffleMessage")
[09:31:14.921]                     }
[09:31:14.921]                     else if (inherits(cond, "warning")) {
[09:31:14.921]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.921]                       if (muffled) 
[09:31:14.921]                         invokeRestart("muffleWarning")
[09:31:14.921]                     }
[09:31:14.921]                     else if (inherits(cond, "condition")) {
[09:31:14.921]                       if (!is.null(pattern)) {
[09:31:14.921]                         computeRestarts <- base::computeRestarts
[09:31:14.921]                         grepl <- base::grepl
[09:31:14.921]                         restarts <- computeRestarts(cond)
[09:31:14.921]                         for (restart in restarts) {
[09:31:14.921]                           name <- restart$name
[09:31:14.921]                           if (is.null(name)) 
[09:31:14.921]                             next
[09:31:14.921]                           if (!grepl(pattern, name)) 
[09:31:14.921]                             next
[09:31:14.921]                           invokeRestart(restart)
[09:31:14.921]                           muffled <- TRUE
[09:31:14.921]                           break
[09:31:14.921]                         }
[09:31:14.921]                       }
[09:31:14.921]                     }
[09:31:14.921]                     invisible(muffled)
[09:31:14.921]                   }
[09:31:14.921]                   muffleCondition(cond)
[09:31:14.921]                 })
[09:31:14.921]             }))
[09:31:14.921]             future::FutureResult(value = ...future.value$value, 
[09:31:14.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.921]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.921]                     ...future.globalenv.names))
[09:31:14.921]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.921]         }, condition = base::local({
[09:31:14.921]             c <- base::c
[09:31:14.921]             inherits <- base::inherits
[09:31:14.921]             invokeRestart <- base::invokeRestart
[09:31:14.921]             length <- base::length
[09:31:14.921]             list <- base::list
[09:31:14.921]             seq.int <- base::seq.int
[09:31:14.921]             signalCondition <- base::signalCondition
[09:31:14.921]             sys.calls <- base::sys.calls
[09:31:14.921]             `[[` <- base::`[[`
[09:31:14.921]             `+` <- base::`+`
[09:31:14.921]             `<<-` <- base::`<<-`
[09:31:14.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.921]                   3L)]
[09:31:14.921]             }
[09:31:14.921]             function(cond) {
[09:31:14.921]                 is_error <- inherits(cond, "error")
[09:31:14.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.921]                   NULL)
[09:31:14.921]                 if (is_error) {
[09:31:14.921]                   sessionInformation <- function() {
[09:31:14.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.921]                       search = base::search(), system = base::Sys.info())
[09:31:14.921]                   }
[09:31:14.921]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.921]                     cond$call), session = sessionInformation(), 
[09:31:14.921]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.921]                   signalCondition(cond)
[09:31:14.921]                 }
[09:31:14.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.921]                 "immediateCondition"))) {
[09:31:14.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.921]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.921]                   if (TRUE && !signal) {
[09:31:14.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.921]                     {
[09:31:14.921]                       inherits <- base::inherits
[09:31:14.921]                       invokeRestart <- base::invokeRestart
[09:31:14.921]                       is.null <- base::is.null
[09:31:14.921]                       muffled <- FALSE
[09:31:14.921]                       if (inherits(cond, "message")) {
[09:31:14.921]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.921]                         if (muffled) 
[09:31:14.921]                           invokeRestart("muffleMessage")
[09:31:14.921]                       }
[09:31:14.921]                       else if (inherits(cond, "warning")) {
[09:31:14.921]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.921]                         if (muffled) 
[09:31:14.921]                           invokeRestart("muffleWarning")
[09:31:14.921]                       }
[09:31:14.921]                       else if (inherits(cond, "condition")) {
[09:31:14.921]                         if (!is.null(pattern)) {
[09:31:14.921]                           computeRestarts <- base::computeRestarts
[09:31:14.921]                           grepl <- base::grepl
[09:31:14.921]                           restarts <- computeRestarts(cond)
[09:31:14.921]                           for (restart in restarts) {
[09:31:14.921]                             name <- restart$name
[09:31:14.921]                             if (is.null(name)) 
[09:31:14.921]                               next
[09:31:14.921]                             if (!grepl(pattern, name)) 
[09:31:14.921]                               next
[09:31:14.921]                             invokeRestart(restart)
[09:31:14.921]                             muffled <- TRUE
[09:31:14.921]                             break
[09:31:14.921]                           }
[09:31:14.921]                         }
[09:31:14.921]                       }
[09:31:14.921]                       invisible(muffled)
[09:31:14.921]                     }
[09:31:14.921]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.921]                   }
[09:31:14.921]                 }
[09:31:14.921]                 else {
[09:31:14.921]                   if (TRUE) {
[09:31:14.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.921]                     {
[09:31:14.921]                       inherits <- base::inherits
[09:31:14.921]                       invokeRestart <- base::invokeRestart
[09:31:14.921]                       is.null <- base::is.null
[09:31:14.921]                       muffled <- FALSE
[09:31:14.921]                       if (inherits(cond, "message")) {
[09:31:14.921]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.921]                         if (muffled) 
[09:31:14.921]                           invokeRestart("muffleMessage")
[09:31:14.921]                       }
[09:31:14.921]                       else if (inherits(cond, "warning")) {
[09:31:14.921]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.921]                         if (muffled) 
[09:31:14.921]                           invokeRestart("muffleWarning")
[09:31:14.921]                       }
[09:31:14.921]                       else if (inherits(cond, "condition")) {
[09:31:14.921]                         if (!is.null(pattern)) {
[09:31:14.921]                           computeRestarts <- base::computeRestarts
[09:31:14.921]                           grepl <- base::grepl
[09:31:14.921]                           restarts <- computeRestarts(cond)
[09:31:14.921]                           for (restart in restarts) {
[09:31:14.921]                             name <- restart$name
[09:31:14.921]                             if (is.null(name)) 
[09:31:14.921]                               next
[09:31:14.921]                             if (!grepl(pattern, name)) 
[09:31:14.921]                               next
[09:31:14.921]                             invokeRestart(restart)
[09:31:14.921]                             muffled <- TRUE
[09:31:14.921]                             break
[09:31:14.921]                           }
[09:31:14.921]                         }
[09:31:14.921]                       }
[09:31:14.921]                       invisible(muffled)
[09:31:14.921]                     }
[09:31:14.921]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.921]                   }
[09:31:14.921]                 }
[09:31:14.921]             }
[09:31:14.921]         }))
[09:31:14.921]     }, error = function(ex) {
[09:31:14.921]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.921]                 ...future.rng), started = ...future.startTime, 
[09:31:14.921]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.921]             version = "1.8"), class = "FutureResult")
[09:31:14.921]     }, finally = {
[09:31:14.921]         if (!identical(...future.workdir, getwd())) 
[09:31:14.921]             setwd(...future.workdir)
[09:31:14.921]         {
[09:31:14.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.921]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.921]             }
[09:31:14.921]             base::options(...future.oldOptions)
[09:31:14.921]             if (.Platform$OS.type == "windows") {
[09:31:14.921]                 old_names <- names(...future.oldEnvVars)
[09:31:14.921]                 envs <- base::Sys.getenv()
[09:31:14.921]                 names <- names(envs)
[09:31:14.921]                 common <- intersect(names, old_names)
[09:31:14.921]                 added <- setdiff(names, old_names)
[09:31:14.921]                 removed <- setdiff(old_names, names)
[09:31:14.921]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.921]                   envs[common]]
[09:31:14.921]                 NAMES <- toupper(changed)
[09:31:14.921]                 args <- list()
[09:31:14.921]                 for (kk in seq_along(NAMES)) {
[09:31:14.921]                   name <- changed[[kk]]
[09:31:14.921]                   NAME <- NAMES[[kk]]
[09:31:14.921]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.921]                     next
[09:31:14.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.921]                 }
[09:31:14.921]                 NAMES <- toupper(added)
[09:31:14.921]                 for (kk in seq_along(NAMES)) {
[09:31:14.921]                   name <- added[[kk]]
[09:31:14.921]                   NAME <- NAMES[[kk]]
[09:31:14.921]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.921]                     next
[09:31:14.921]                   args[[name]] <- ""
[09:31:14.921]                 }
[09:31:14.921]                 NAMES <- toupper(removed)
[09:31:14.921]                 for (kk in seq_along(NAMES)) {
[09:31:14.921]                   name <- removed[[kk]]
[09:31:14.921]                   NAME <- NAMES[[kk]]
[09:31:14.921]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.921]                     next
[09:31:14.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.921]                 }
[09:31:14.921]                 if (length(args) > 0) 
[09:31:14.921]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.921]             }
[09:31:14.921]             else {
[09:31:14.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.921]             }
[09:31:14.921]             {
[09:31:14.921]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.921]                   0L) {
[09:31:14.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.921]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.921]                   base::options(opts)
[09:31:14.921]                 }
[09:31:14.921]                 {
[09:31:14.921]                   {
[09:31:14.921]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.921]                     NULL
[09:31:14.921]                   }
[09:31:14.921]                   options(future.plan = NULL)
[09:31:14.921]                   if (is.na(NA_character_)) 
[09:31:14.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.921]                     .init = FALSE)
[09:31:14.921]                 }
[09:31:14.921]             }
[09:31:14.921]         }
[09:31:14.921]     })
[09:31:14.921]     if (TRUE) {
[09:31:14.921]         base::sink(type = "output", split = FALSE)
[09:31:14.921]         if (TRUE) {
[09:31:14.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.921]         }
[09:31:14.921]         else {
[09:31:14.921]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.921]         }
[09:31:14.921]         base::close(...future.stdout)
[09:31:14.921]         ...future.stdout <- NULL
[09:31:14.921]     }
[09:31:14.921]     ...future.result$conditions <- ...future.conditions
[09:31:14.921]     ...future.result$finished <- base::Sys.time()
[09:31:14.921]     ...future.result
[09:31:14.921] }
[09:31:14.924] MultisessionFuture started
[09:31:14.924] - Launch lazy future ... done
[09:31:14.924] run() for ‘MultisessionFuture’ ... done
[09:31:14.924] getGlobalsAndPackages() ...
[09:31:14.924] Searching for globals...
[09:31:14.925] 
[09:31:14.925] Searching for globals ... DONE
[09:31:14.925] - globals: [0] <none>
[09:31:14.925] getGlobalsAndPackages() ... DONE
[09:31:14.925] run() for ‘Future’ ...
[09:31:14.925] - state: ‘created’
[09:31:14.925] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.941] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.941]   - Field: ‘node’
[09:31:14.942]   - Field: ‘label’
[09:31:14.942]   - Field: ‘local’
[09:31:14.942]   - Field: ‘owner’
[09:31:14.942]   - Field: ‘envir’
[09:31:14.942]   - Field: ‘workers’
[09:31:14.942]   - Field: ‘packages’
[09:31:14.942]   - Field: ‘gc’
[09:31:14.942]   - Field: ‘conditions’
[09:31:14.942]   - Field: ‘persistent’
[09:31:14.942]   - Field: ‘expr’
[09:31:14.943]   - Field: ‘uuid’
[09:31:14.943]   - Field: ‘seed’
[09:31:14.943]   - Field: ‘version’
[09:31:14.943]   - Field: ‘result’
[09:31:14.943]   - Field: ‘asynchronous’
[09:31:14.943]   - Field: ‘calls’
[09:31:14.943]   - Field: ‘globals’
[09:31:14.943]   - Field: ‘stdout’
[09:31:14.943]   - Field: ‘earlySignal’
[09:31:14.943]   - Field: ‘lazy’
[09:31:14.943]   - Field: ‘state’
[09:31:14.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.944] - Launch lazy future ...
[09:31:14.944] Packages needed by the future expression (n = 0): <none>
[09:31:14.944] Packages needed by future strategies (n = 0): <none>
[09:31:14.944] {
[09:31:14.944]     {
[09:31:14.944]         {
[09:31:14.944]             ...future.startTime <- base::Sys.time()
[09:31:14.944]             {
[09:31:14.944]                 {
[09:31:14.944]                   {
[09:31:14.944]                     {
[09:31:14.944]                       base::local({
[09:31:14.944]                         has_future <- base::requireNamespace("future", 
[09:31:14.944]                           quietly = TRUE)
[09:31:14.944]                         if (has_future) {
[09:31:14.944]                           ns <- base::getNamespace("future")
[09:31:14.944]                           version <- ns[[".package"]][["version"]]
[09:31:14.944]                           if (is.null(version)) 
[09:31:14.944]                             version <- utils::packageVersion("future")
[09:31:14.944]                         }
[09:31:14.944]                         else {
[09:31:14.944]                           version <- NULL
[09:31:14.944]                         }
[09:31:14.944]                         if (!has_future || version < "1.8.0") {
[09:31:14.944]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.944]                             "", base::R.version$version.string), 
[09:31:14.944]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.944]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.944]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.944]                               "release", "version")], collapse = " "), 
[09:31:14.944]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.944]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.944]                             info)
[09:31:14.944]                           info <- base::paste(info, collapse = "; ")
[09:31:14.944]                           if (!has_future) {
[09:31:14.944]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.944]                               info)
[09:31:14.944]                           }
[09:31:14.944]                           else {
[09:31:14.944]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.944]                               info, version)
[09:31:14.944]                           }
[09:31:14.944]                           base::stop(msg)
[09:31:14.944]                         }
[09:31:14.944]                       })
[09:31:14.944]                     }
[09:31:14.944]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.944]                     base::options(mc.cores = 1L)
[09:31:14.944]                   }
[09:31:14.944]                   ...future.strategy.old <- future::plan("list")
[09:31:14.944]                   options(future.plan = NULL)
[09:31:14.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.944]                 }
[09:31:14.944]                 ...future.workdir <- getwd()
[09:31:14.944]             }
[09:31:14.944]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.944]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.944]         }
[09:31:14.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.944]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.944]             base::names(...future.oldOptions))
[09:31:14.944]     }
[09:31:14.944]     if (FALSE) {
[09:31:14.944]     }
[09:31:14.944]     else {
[09:31:14.944]         if (TRUE) {
[09:31:14.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.944]                 open = "w")
[09:31:14.944]         }
[09:31:14.944]         else {
[09:31:14.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.944]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.944]         }
[09:31:14.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.944]             base::sink(type = "output", split = FALSE)
[09:31:14.944]             base::close(...future.stdout)
[09:31:14.944]         }, add = TRUE)
[09:31:14.944]     }
[09:31:14.944]     ...future.frame <- base::sys.nframe()
[09:31:14.944]     ...future.conditions <- base::list()
[09:31:14.944]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.944]     if (FALSE) {
[09:31:14.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.944]     }
[09:31:14.944]     ...future.result <- base::tryCatch({
[09:31:14.944]         base::withCallingHandlers({
[09:31:14.944]             ...future.value <- base::withVisible(base::local({
[09:31:14.944]                 ...future.makeSendCondition <- base::local({
[09:31:14.944]                   sendCondition <- NULL
[09:31:14.944]                   function(frame = 1L) {
[09:31:14.944]                     if (is.function(sendCondition)) 
[09:31:14.944]                       return(sendCondition)
[09:31:14.944]                     ns <- getNamespace("parallel")
[09:31:14.944]                     if (exists("sendData", mode = "function", 
[09:31:14.944]                       envir = ns)) {
[09:31:14.944]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.944]                         envir = ns)
[09:31:14.944]                       envir <- sys.frame(frame)
[09:31:14.944]                       master <- NULL
[09:31:14.944]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.944]                         !identical(envir, emptyenv())) {
[09:31:14.944]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.944]                           inherits = FALSE)) {
[09:31:14.944]                           master <- get("master", mode = "list", 
[09:31:14.944]                             envir = envir, inherits = FALSE)
[09:31:14.944]                           if (inherits(master, c("SOCKnode", 
[09:31:14.944]                             "SOCK0node"))) {
[09:31:14.944]                             sendCondition <<- function(cond) {
[09:31:14.944]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.944]                                 success = TRUE)
[09:31:14.944]                               parallel_sendData(master, data)
[09:31:14.944]                             }
[09:31:14.944]                             return(sendCondition)
[09:31:14.944]                           }
[09:31:14.944]                         }
[09:31:14.944]                         frame <- frame + 1L
[09:31:14.944]                         envir <- sys.frame(frame)
[09:31:14.944]                       }
[09:31:14.944]                     }
[09:31:14.944]                     sendCondition <<- function(cond) NULL
[09:31:14.944]                   }
[09:31:14.944]                 })
[09:31:14.944]                 withCallingHandlers({
[09:31:14.944]                   NULL
[09:31:14.944]                 }, immediateCondition = function(cond) {
[09:31:14.944]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.944]                   sendCondition(cond)
[09:31:14.944]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.944]                   {
[09:31:14.944]                     inherits <- base::inherits
[09:31:14.944]                     invokeRestart <- base::invokeRestart
[09:31:14.944]                     is.null <- base::is.null
[09:31:14.944]                     muffled <- FALSE
[09:31:14.944]                     if (inherits(cond, "message")) {
[09:31:14.944]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.944]                       if (muffled) 
[09:31:14.944]                         invokeRestart("muffleMessage")
[09:31:14.944]                     }
[09:31:14.944]                     else if (inherits(cond, "warning")) {
[09:31:14.944]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.944]                       if (muffled) 
[09:31:14.944]                         invokeRestart("muffleWarning")
[09:31:14.944]                     }
[09:31:14.944]                     else if (inherits(cond, "condition")) {
[09:31:14.944]                       if (!is.null(pattern)) {
[09:31:14.944]                         computeRestarts <- base::computeRestarts
[09:31:14.944]                         grepl <- base::grepl
[09:31:14.944]                         restarts <- computeRestarts(cond)
[09:31:14.944]                         for (restart in restarts) {
[09:31:14.944]                           name <- restart$name
[09:31:14.944]                           if (is.null(name)) 
[09:31:14.944]                             next
[09:31:14.944]                           if (!grepl(pattern, name)) 
[09:31:14.944]                             next
[09:31:14.944]                           invokeRestart(restart)
[09:31:14.944]                           muffled <- TRUE
[09:31:14.944]                           break
[09:31:14.944]                         }
[09:31:14.944]                       }
[09:31:14.944]                     }
[09:31:14.944]                     invisible(muffled)
[09:31:14.944]                   }
[09:31:14.944]                   muffleCondition(cond)
[09:31:14.944]                 })
[09:31:14.944]             }))
[09:31:14.944]             future::FutureResult(value = ...future.value$value, 
[09:31:14.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.944]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.944]                     ...future.globalenv.names))
[09:31:14.944]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.944]         }, condition = base::local({
[09:31:14.944]             c <- base::c
[09:31:14.944]             inherits <- base::inherits
[09:31:14.944]             invokeRestart <- base::invokeRestart
[09:31:14.944]             length <- base::length
[09:31:14.944]             list <- base::list
[09:31:14.944]             seq.int <- base::seq.int
[09:31:14.944]             signalCondition <- base::signalCondition
[09:31:14.944]             sys.calls <- base::sys.calls
[09:31:14.944]             `[[` <- base::`[[`
[09:31:14.944]             `+` <- base::`+`
[09:31:14.944]             `<<-` <- base::`<<-`
[09:31:14.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.944]                   3L)]
[09:31:14.944]             }
[09:31:14.944]             function(cond) {
[09:31:14.944]                 is_error <- inherits(cond, "error")
[09:31:14.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.944]                   NULL)
[09:31:14.944]                 if (is_error) {
[09:31:14.944]                   sessionInformation <- function() {
[09:31:14.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.944]                       search = base::search(), system = base::Sys.info())
[09:31:14.944]                   }
[09:31:14.944]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.944]                     cond$call), session = sessionInformation(), 
[09:31:14.944]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.944]                   signalCondition(cond)
[09:31:14.944]                 }
[09:31:14.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.944]                 "immediateCondition"))) {
[09:31:14.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.944]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.944]                   if (TRUE && !signal) {
[09:31:14.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.944]                     {
[09:31:14.944]                       inherits <- base::inherits
[09:31:14.944]                       invokeRestart <- base::invokeRestart
[09:31:14.944]                       is.null <- base::is.null
[09:31:14.944]                       muffled <- FALSE
[09:31:14.944]                       if (inherits(cond, "message")) {
[09:31:14.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.944]                         if (muffled) 
[09:31:14.944]                           invokeRestart("muffleMessage")
[09:31:14.944]                       }
[09:31:14.944]                       else if (inherits(cond, "warning")) {
[09:31:14.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.944]                         if (muffled) 
[09:31:14.944]                           invokeRestart("muffleWarning")
[09:31:14.944]                       }
[09:31:14.944]                       else if (inherits(cond, "condition")) {
[09:31:14.944]                         if (!is.null(pattern)) {
[09:31:14.944]                           computeRestarts <- base::computeRestarts
[09:31:14.944]                           grepl <- base::grepl
[09:31:14.944]                           restarts <- computeRestarts(cond)
[09:31:14.944]                           for (restart in restarts) {
[09:31:14.944]                             name <- restart$name
[09:31:14.944]                             if (is.null(name)) 
[09:31:14.944]                               next
[09:31:14.944]                             if (!grepl(pattern, name)) 
[09:31:14.944]                               next
[09:31:14.944]                             invokeRestart(restart)
[09:31:14.944]                             muffled <- TRUE
[09:31:14.944]                             break
[09:31:14.944]                           }
[09:31:14.944]                         }
[09:31:14.944]                       }
[09:31:14.944]                       invisible(muffled)
[09:31:14.944]                     }
[09:31:14.944]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.944]                   }
[09:31:14.944]                 }
[09:31:14.944]                 else {
[09:31:14.944]                   if (TRUE) {
[09:31:14.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.944]                     {
[09:31:14.944]                       inherits <- base::inherits
[09:31:14.944]                       invokeRestart <- base::invokeRestart
[09:31:14.944]                       is.null <- base::is.null
[09:31:14.944]                       muffled <- FALSE
[09:31:14.944]                       if (inherits(cond, "message")) {
[09:31:14.944]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.944]                         if (muffled) 
[09:31:14.944]                           invokeRestart("muffleMessage")
[09:31:14.944]                       }
[09:31:14.944]                       else if (inherits(cond, "warning")) {
[09:31:14.944]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.944]                         if (muffled) 
[09:31:14.944]                           invokeRestart("muffleWarning")
[09:31:14.944]                       }
[09:31:14.944]                       else if (inherits(cond, "condition")) {
[09:31:14.944]                         if (!is.null(pattern)) {
[09:31:14.944]                           computeRestarts <- base::computeRestarts
[09:31:14.944]                           grepl <- base::grepl
[09:31:14.944]                           restarts <- computeRestarts(cond)
[09:31:14.944]                           for (restart in restarts) {
[09:31:14.944]                             name <- restart$name
[09:31:14.944]                             if (is.null(name)) 
[09:31:14.944]                               next
[09:31:14.944]                             if (!grepl(pattern, name)) 
[09:31:14.944]                               next
[09:31:14.944]                             invokeRestart(restart)
[09:31:14.944]                             muffled <- TRUE
[09:31:14.944]                             break
[09:31:14.944]                           }
[09:31:14.944]                         }
[09:31:14.944]                       }
[09:31:14.944]                       invisible(muffled)
[09:31:14.944]                     }
[09:31:14.944]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.944]                   }
[09:31:14.944]                 }
[09:31:14.944]             }
[09:31:14.944]         }))
[09:31:14.944]     }, error = function(ex) {
[09:31:14.944]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.944]                 ...future.rng), started = ...future.startTime, 
[09:31:14.944]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.944]             version = "1.8"), class = "FutureResult")
[09:31:14.944]     }, finally = {
[09:31:14.944]         if (!identical(...future.workdir, getwd())) 
[09:31:14.944]             setwd(...future.workdir)
[09:31:14.944]         {
[09:31:14.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.944]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.944]             }
[09:31:14.944]             base::options(...future.oldOptions)
[09:31:14.944]             if (.Platform$OS.type == "windows") {
[09:31:14.944]                 old_names <- names(...future.oldEnvVars)
[09:31:14.944]                 envs <- base::Sys.getenv()
[09:31:14.944]                 names <- names(envs)
[09:31:14.944]                 common <- intersect(names, old_names)
[09:31:14.944]                 added <- setdiff(names, old_names)
[09:31:14.944]                 removed <- setdiff(old_names, names)
[09:31:14.944]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.944]                   envs[common]]
[09:31:14.944]                 NAMES <- toupper(changed)
[09:31:14.944]                 args <- list()
[09:31:14.944]                 for (kk in seq_along(NAMES)) {
[09:31:14.944]                   name <- changed[[kk]]
[09:31:14.944]                   NAME <- NAMES[[kk]]
[09:31:14.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.944]                     next
[09:31:14.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.944]                 }
[09:31:14.944]                 NAMES <- toupper(added)
[09:31:14.944]                 for (kk in seq_along(NAMES)) {
[09:31:14.944]                   name <- added[[kk]]
[09:31:14.944]                   NAME <- NAMES[[kk]]
[09:31:14.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.944]                     next
[09:31:14.944]                   args[[name]] <- ""
[09:31:14.944]                 }
[09:31:14.944]                 NAMES <- toupper(removed)
[09:31:14.944]                 for (kk in seq_along(NAMES)) {
[09:31:14.944]                   name <- removed[[kk]]
[09:31:14.944]                   NAME <- NAMES[[kk]]
[09:31:14.944]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.944]                     next
[09:31:14.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.944]                 }
[09:31:14.944]                 if (length(args) > 0) 
[09:31:14.944]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.944]             }
[09:31:14.944]             else {
[09:31:14.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.944]             }
[09:31:14.944]             {
[09:31:14.944]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.944]                   0L) {
[09:31:14.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.944]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.944]                   base::options(opts)
[09:31:14.944]                 }
[09:31:14.944]                 {
[09:31:14.944]                   {
[09:31:14.944]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.944]                     NULL
[09:31:14.944]                   }
[09:31:14.944]                   options(future.plan = NULL)
[09:31:14.944]                   if (is.na(NA_character_)) 
[09:31:14.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.944]                     .init = FALSE)
[09:31:14.944]                 }
[09:31:14.944]             }
[09:31:14.944]         }
[09:31:14.944]     })
[09:31:14.944]     if (TRUE) {
[09:31:14.944]         base::sink(type = "output", split = FALSE)
[09:31:14.944]         if (TRUE) {
[09:31:14.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.944]         }
[09:31:14.944]         else {
[09:31:14.944]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.944]         }
[09:31:14.944]         base::close(...future.stdout)
[09:31:14.944]         ...future.stdout <- NULL
[09:31:14.944]     }
[09:31:14.944]     ...future.result$conditions <- ...future.conditions
[09:31:14.944]     ...future.result$finished <- base::Sys.time()
[09:31:14.944]     ...future.result
[09:31:14.944] }
[09:31:14.947] MultisessionFuture started
[09:31:14.947] - Launch lazy future ... done
[09:31:14.947] run() for ‘MultisessionFuture’ ... done
[09:31:14.948] getGlobalsAndPackages() ...
[09:31:14.948] Searching for globals...
[09:31:14.948] - globals found: [1] ‘{’
[09:31:14.948] Searching for globals ... DONE
[09:31:14.949] Resolving globals: FALSE
[09:31:14.949] 
[09:31:14.949] 
[09:31:14.949] getGlobalsAndPackages() ... DONE
[09:31:14.949] run() for ‘Future’ ...
[09:31:14.949] - state: ‘created’
[09:31:14.949] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:14.962] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:14.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:14.963]   - Field: ‘node’
[09:31:14.963]   - Field: ‘label’
[09:31:14.963]   - Field: ‘local’
[09:31:14.963]   - Field: ‘owner’
[09:31:14.963]   - Field: ‘envir’
[09:31:14.963]   - Field: ‘workers’
[09:31:14.963]   - Field: ‘packages’
[09:31:14.963]   - Field: ‘gc’
[09:31:14.963]   - Field: ‘conditions’
[09:31:14.963]   - Field: ‘persistent’
[09:31:14.963]   - Field: ‘expr’
[09:31:14.964]   - Field: ‘uuid’
[09:31:14.964]   - Field: ‘seed’
[09:31:14.964]   - Field: ‘version’
[09:31:14.964]   - Field: ‘result’
[09:31:14.964]   - Field: ‘asynchronous’
[09:31:14.964]   - Field: ‘calls’
[09:31:14.964]   - Field: ‘globals’
[09:31:14.964]   - Field: ‘stdout’
[09:31:14.964]   - Field: ‘earlySignal’
[09:31:14.964]   - Field: ‘lazy’
[09:31:14.964]   - Field: ‘state’
[09:31:14.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:14.965] - Launch lazy future ...
[09:31:14.965] Packages needed by the future expression (n = 0): <none>
[09:31:14.965] Packages needed by future strategies (n = 0): <none>
[09:31:14.965] {
[09:31:14.965]     {
[09:31:14.965]         {
[09:31:14.965]             ...future.startTime <- base::Sys.time()
[09:31:14.965]             {
[09:31:14.965]                 {
[09:31:14.965]                   {
[09:31:14.965]                     {
[09:31:14.965]                       base::local({
[09:31:14.965]                         has_future <- base::requireNamespace("future", 
[09:31:14.965]                           quietly = TRUE)
[09:31:14.965]                         if (has_future) {
[09:31:14.965]                           ns <- base::getNamespace("future")
[09:31:14.965]                           version <- ns[[".package"]][["version"]]
[09:31:14.965]                           if (is.null(version)) 
[09:31:14.965]                             version <- utils::packageVersion("future")
[09:31:14.965]                         }
[09:31:14.965]                         else {
[09:31:14.965]                           version <- NULL
[09:31:14.965]                         }
[09:31:14.965]                         if (!has_future || version < "1.8.0") {
[09:31:14.965]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:14.965]                             "", base::R.version$version.string), 
[09:31:14.965]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:14.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:14.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:14.965]                               "release", "version")], collapse = " "), 
[09:31:14.965]                             hostname = base::Sys.info()[["nodename"]])
[09:31:14.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:14.965]                             info)
[09:31:14.965]                           info <- base::paste(info, collapse = "; ")
[09:31:14.965]                           if (!has_future) {
[09:31:14.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:14.965]                               info)
[09:31:14.965]                           }
[09:31:14.965]                           else {
[09:31:14.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:14.965]                               info, version)
[09:31:14.965]                           }
[09:31:14.965]                           base::stop(msg)
[09:31:14.965]                         }
[09:31:14.965]                       })
[09:31:14.965]                     }
[09:31:14.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:14.965]                     base::options(mc.cores = 1L)
[09:31:14.965]                   }
[09:31:14.965]                   ...future.strategy.old <- future::plan("list")
[09:31:14.965]                   options(future.plan = NULL)
[09:31:14.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:14.965]                 }
[09:31:14.965]                 ...future.workdir <- getwd()
[09:31:14.965]             }
[09:31:14.965]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:14.965]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:14.965]         }
[09:31:14.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:14.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:14.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:14.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:14.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:14.965]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:14.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:14.965]             base::names(...future.oldOptions))
[09:31:14.965]     }
[09:31:14.965]     if (FALSE) {
[09:31:14.965]     }
[09:31:14.965]     else {
[09:31:14.965]         if (TRUE) {
[09:31:14.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:14.965]                 open = "w")
[09:31:14.965]         }
[09:31:14.965]         else {
[09:31:14.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:14.965]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:14.965]         }
[09:31:14.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:14.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:14.965]             base::sink(type = "output", split = FALSE)
[09:31:14.965]             base::close(...future.stdout)
[09:31:14.965]         }, add = TRUE)
[09:31:14.965]     }
[09:31:14.965]     ...future.frame <- base::sys.nframe()
[09:31:14.965]     ...future.conditions <- base::list()
[09:31:14.965]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:14.965]     if (FALSE) {
[09:31:14.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:14.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:14.965]     }
[09:31:14.965]     ...future.result <- base::tryCatch({
[09:31:14.965]         base::withCallingHandlers({
[09:31:14.965]             ...future.value <- base::withVisible(base::local({
[09:31:14.965]                 ...future.makeSendCondition <- base::local({
[09:31:14.965]                   sendCondition <- NULL
[09:31:14.965]                   function(frame = 1L) {
[09:31:14.965]                     if (is.function(sendCondition)) 
[09:31:14.965]                       return(sendCondition)
[09:31:14.965]                     ns <- getNamespace("parallel")
[09:31:14.965]                     if (exists("sendData", mode = "function", 
[09:31:14.965]                       envir = ns)) {
[09:31:14.965]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:14.965]                         envir = ns)
[09:31:14.965]                       envir <- sys.frame(frame)
[09:31:14.965]                       master <- NULL
[09:31:14.965]                       while (!identical(envir, .GlobalEnv) && 
[09:31:14.965]                         !identical(envir, emptyenv())) {
[09:31:14.965]                         if (exists("master", mode = "list", envir = envir, 
[09:31:14.965]                           inherits = FALSE)) {
[09:31:14.965]                           master <- get("master", mode = "list", 
[09:31:14.965]                             envir = envir, inherits = FALSE)
[09:31:14.965]                           if (inherits(master, c("SOCKnode", 
[09:31:14.965]                             "SOCK0node"))) {
[09:31:14.965]                             sendCondition <<- function(cond) {
[09:31:14.965]                               data <- list(type = "VALUE", value = cond, 
[09:31:14.965]                                 success = TRUE)
[09:31:14.965]                               parallel_sendData(master, data)
[09:31:14.965]                             }
[09:31:14.965]                             return(sendCondition)
[09:31:14.965]                           }
[09:31:14.965]                         }
[09:31:14.965]                         frame <- frame + 1L
[09:31:14.965]                         envir <- sys.frame(frame)
[09:31:14.965]                       }
[09:31:14.965]                     }
[09:31:14.965]                     sendCondition <<- function(cond) NULL
[09:31:14.965]                   }
[09:31:14.965]                 })
[09:31:14.965]                 withCallingHandlers({
[09:31:14.965]                   {
[09:31:14.965]                     4
[09:31:14.965]                   }
[09:31:14.965]                 }, immediateCondition = function(cond) {
[09:31:14.965]                   sendCondition <- ...future.makeSendCondition()
[09:31:14.965]                   sendCondition(cond)
[09:31:14.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.965]                   {
[09:31:14.965]                     inherits <- base::inherits
[09:31:14.965]                     invokeRestart <- base::invokeRestart
[09:31:14.965]                     is.null <- base::is.null
[09:31:14.965]                     muffled <- FALSE
[09:31:14.965]                     if (inherits(cond, "message")) {
[09:31:14.965]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:14.965]                       if (muffled) 
[09:31:14.965]                         invokeRestart("muffleMessage")
[09:31:14.965]                     }
[09:31:14.965]                     else if (inherits(cond, "warning")) {
[09:31:14.965]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:14.965]                       if (muffled) 
[09:31:14.965]                         invokeRestart("muffleWarning")
[09:31:14.965]                     }
[09:31:14.965]                     else if (inherits(cond, "condition")) {
[09:31:14.965]                       if (!is.null(pattern)) {
[09:31:14.965]                         computeRestarts <- base::computeRestarts
[09:31:14.965]                         grepl <- base::grepl
[09:31:14.965]                         restarts <- computeRestarts(cond)
[09:31:14.965]                         for (restart in restarts) {
[09:31:14.965]                           name <- restart$name
[09:31:14.965]                           if (is.null(name)) 
[09:31:14.965]                             next
[09:31:14.965]                           if (!grepl(pattern, name)) 
[09:31:14.965]                             next
[09:31:14.965]                           invokeRestart(restart)
[09:31:14.965]                           muffled <- TRUE
[09:31:14.965]                           break
[09:31:14.965]                         }
[09:31:14.965]                       }
[09:31:14.965]                     }
[09:31:14.965]                     invisible(muffled)
[09:31:14.965]                   }
[09:31:14.965]                   muffleCondition(cond)
[09:31:14.965]                 })
[09:31:14.965]             }))
[09:31:14.965]             future::FutureResult(value = ...future.value$value, 
[09:31:14.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.965]                   ...future.rng), globalenv = if (FALSE) 
[09:31:14.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:14.965]                     ...future.globalenv.names))
[09:31:14.965]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:14.965]         }, condition = base::local({
[09:31:14.965]             c <- base::c
[09:31:14.965]             inherits <- base::inherits
[09:31:14.965]             invokeRestart <- base::invokeRestart
[09:31:14.965]             length <- base::length
[09:31:14.965]             list <- base::list
[09:31:14.965]             seq.int <- base::seq.int
[09:31:14.965]             signalCondition <- base::signalCondition
[09:31:14.965]             sys.calls <- base::sys.calls
[09:31:14.965]             `[[` <- base::`[[`
[09:31:14.965]             `+` <- base::`+`
[09:31:14.965]             `<<-` <- base::`<<-`
[09:31:14.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:14.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:14.965]                   3L)]
[09:31:14.965]             }
[09:31:14.965]             function(cond) {
[09:31:14.965]                 is_error <- inherits(cond, "error")
[09:31:14.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:14.965]                   NULL)
[09:31:14.965]                 if (is_error) {
[09:31:14.965]                   sessionInformation <- function() {
[09:31:14.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:14.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:14.965]                       search = base::search(), system = base::Sys.info())
[09:31:14.965]                   }
[09:31:14.965]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:14.965]                     cond$call), session = sessionInformation(), 
[09:31:14.965]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:14.965]                   signalCondition(cond)
[09:31:14.965]                 }
[09:31:14.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:14.965]                 "immediateCondition"))) {
[09:31:14.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:14.965]                   ...future.conditions[[length(...future.conditions) + 
[09:31:14.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:14.965]                   if (TRUE && !signal) {
[09:31:14.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.965]                     {
[09:31:14.965]                       inherits <- base::inherits
[09:31:14.965]                       invokeRestart <- base::invokeRestart
[09:31:14.965]                       is.null <- base::is.null
[09:31:14.965]                       muffled <- FALSE
[09:31:14.965]                       if (inherits(cond, "message")) {
[09:31:14.965]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.965]                         if (muffled) 
[09:31:14.965]                           invokeRestart("muffleMessage")
[09:31:14.965]                       }
[09:31:14.965]                       else if (inherits(cond, "warning")) {
[09:31:14.965]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.965]                         if (muffled) 
[09:31:14.965]                           invokeRestart("muffleWarning")
[09:31:14.965]                       }
[09:31:14.965]                       else if (inherits(cond, "condition")) {
[09:31:14.965]                         if (!is.null(pattern)) {
[09:31:14.965]                           computeRestarts <- base::computeRestarts
[09:31:14.965]                           grepl <- base::grepl
[09:31:14.965]                           restarts <- computeRestarts(cond)
[09:31:14.965]                           for (restart in restarts) {
[09:31:14.965]                             name <- restart$name
[09:31:14.965]                             if (is.null(name)) 
[09:31:14.965]                               next
[09:31:14.965]                             if (!grepl(pattern, name)) 
[09:31:14.965]                               next
[09:31:14.965]                             invokeRestart(restart)
[09:31:14.965]                             muffled <- TRUE
[09:31:14.965]                             break
[09:31:14.965]                           }
[09:31:14.965]                         }
[09:31:14.965]                       }
[09:31:14.965]                       invisible(muffled)
[09:31:14.965]                     }
[09:31:14.965]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.965]                   }
[09:31:14.965]                 }
[09:31:14.965]                 else {
[09:31:14.965]                   if (TRUE) {
[09:31:14.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:14.965]                     {
[09:31:14.965]                       inherits <- base::inherits
[09:31:14.965]                       invokeRestart <- base::invokeRestart
[09:31:14.965]                       is.null <- base::is.null
[09:31:14.965]                       muffled <- FALSE
[09:31:14.965]                       if (inherits(cond, "message")) {
[09:31:14.965]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:14.965]                         if (muffled) 
[09:31:14.965]                           invokeRestart("muffleMessage")
[09:31:14.965]                       }
[09:31:14.965]                       else if (inherits(cond, "warning")) {
[09:31:14.965]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:14.965]                         if (muffled) 
[09:31:14.965]                           invokeRestart("muffleWarning")
[09:31:14.965]                       }
[09:31:14.965]                       else if (inherits(cond, "condition")) {
[09:31:14.965]                         if (!is.null(pattern)) {
[09:31:14.965]                           computeRestarts <- base::computeRestarts
[09:31:14.965]                           grepl <- base::grepl
[09:31:14.965]                           restarts <- computeRestarts(cond)
[09:31:14.965]                           for (restart in restarts) {
[09:31:14.965]                             name <- restart$name
[09:31:14.965]                             if (is.null(name)) 
[09:31:14.965]                               next
[09:31:14.965]                             if (!grepl(pattern, name)) 
[09:31:14.965]                               next
[09:31:14.965]                             invokeRestart(restart)
[09:31:14.965]                             muffled <- TRUE
[09:31:14.965]                             break
[09:31:14.965]                           }
[09:31:14.965]                         }
[09:31:14.965]                       }
[09:31:14.965]                       invisible(muffled)
[09:31:14.965]                     }
[09:31:14.965]                     muffleCondition(cond, pattern = "^muffle")
[09:31:14.965]                   }
[09:31:14.965]                 }
[09:31:14.965]             }
[09:31:14.965]         }))
[09:31:14.965]     }, error = function(ex) {
[09:31:14.965]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:14.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:14.965]                 ...future.rng), started = ...future.startTime, 
[09:31:14.965]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:14.965]             version = "1.8"), class = "FutureResult")
[09:31:14.965]     }, finally = {
[09:31:14.965]         if (!identical(...future.workdir, getwd())) 
[09:31:14.965]             setwd(...future.workdir)
[09:31:14.965]         {
[09:31:14.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:14.965]                 ...future.oldOptions$nwarnings <- NULL
[09:31:14.965]             }
[09:31:14.965]             base::options(...future.oldOptions)
[09:31:14.965]             if (.Platform$OS.type == "windows") {
[09:31:14.965]                 old_names <- names(...future.oldEnvVars)
[09:31:14.965]                 envs <- base::Sys.getenv()
[09:31:14.965]                 names <- names(envs)
[09:31:14.965]                 common <- intersect(names, old_names)
[09:31:14.965]                 added <- setdiff(names, old_names)
[09:31:14.965]                 removed <- setdiff(old_names, names)
[09:31:14.965]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:14.965]                   envs[common]]
[09:31:14.965]                 NAMES <- toupper(changed)
[09:31:14.965]                 args <- list()
[09:31:14.965]                 for (kk in seq_along(NAMES)) {
[09:31:14.965]                   name <- changed[[kk]]
[09:31:14.965]                   NAME <- NAMES[[kk]]
[09:31:14.965]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.965]                     next
[09:31:14.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.965]                 }
[09:31:14.965]                 NAMES <- toupper(added)
[09:31:14.965]                 for (kk in seq_along(NAMES)) {
[09:31:14.965]                   name <- added[[kk]]
[09:31:14.965]                   NAME <- NAMES[[kk]]
[09:31:14.965]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.965]                     next
[09:31:14.965]                   args[[name]] <- ""
[09:31:14.965]                 }
[09:31:14.965]                 NAMES <- toupper(removed)
[09:31:14.965]                 for (kk in seq_along(NAMES)) {
[09:31:14.965]                   name <- removed[[kk]]
[09:31:14.965]                   NAME <- NAMES[[kk]]
[09:31:14.965]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:14.965]                     next
[09:31:14.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:14.965]                 }
[09:31:14.965]                 if (length(args) > 0) 
[09:31:14.965]                   base::do.call(base::Sys.setenv, args = args)
[09:31:14.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:14.965]             }
[09:31:14.965]             else {
[09:31:14.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:14.965]             }
[09:31:14.965]             {
[09:31:14.965]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:14.965]                   0L) {
[09:31:14.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:14.965]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:14.965]                   base::options(opts)
[09:31:14.965]                 }
[09:31:14.965]                 {
[09:31:14.965]                   {
[09:31:14.965]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:14.965]                     NULL
[09:31:14.965]                   }
[09:31:14.965]                   options(future.plan = NULL)
[09:31:14.965]                   if (is.na(NA_character_)) 
[09:31:14.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:14.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:14.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:14.965]                     .init = FALSE)
[09:31:14.965]                 }
[09:31:14.965]             }
[09:31:14.965]         }
[09:31:14.965]     })
[09:31:14.965]     if (TRUE) {
[09:31:14.965]         base::sink(type = "output", split = FALSE)
[09:31:14.965]         if (TRUE) {
[09:31:14.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:14.965]         }
[09:31:14.965]         else {
[09:31:14.965]             ...future.result["stdout"] <- base::list(NULL)
[09:31:14.965]         }
[09:31:14.965]         base::close(...future.stdout)
[09:31:14.965]         ...future.stdout <- NULL
[09:31:14.965]     }
[09:31:14.965]     ...future.result$conditions <- ...future.conditions
[09:31:14.965]     ...future.result$finished <- base::Sys.time()
[09:31:14.965]     ...future.result
[09:31:14.965] }
[09:31:14.967] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:14.978] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.978] - Validating connection of MultisessionFuture
[09:31:14.978] - received message: FutureResult
[09:31:14.978] - Received FutureResult
[09:31:14.979] - Erased future from FutureRegistry
[09:31:14.979] result() for ClusterFuture ...
[09:31:14.979] - result already collected: FutureResult
[09:31:14.979] result() for ClusterFuture ... done
[09:31:14.979] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.979] result() for ClusterFuture ...
[09:31:14.979] - result already collected: FutureResult
[09:31:14.979] result() for ClusterFuture ... done
[09:31:14.979] result() for ClusterFuture ...
[09:31:14.979] - result already collected: FutureResult
[09:31:14.980] result() for ClusterFuture ... done
[09:31:14.980] MultisessionFuture started
[09:31:14.981] - Launch lazy future ... done
[09:31:14.981] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a3cca04de0> 
<environment: 0x55a3ca8341b0> 
[09:31:14.982] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.982] - Validating connection of MultisessionFuture
[09:31:14.982] - received message: FutureResult
[09:31:14.983] - Received FutureResult
[09:31:14.983] - Erased future from FutureRegistry
[09:31:14.983] result() for ClusterFuture ...
[09:31:14.983] - result already collected: FutureResult
[09:31:14.983] result() for ClusterFuture ... done
[09:31:14.983] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:14.983] receiveMessageFromWorker() for ClusterFuture ...
[09:31:14.983] - Validating connection of MultisessionFuture
[09:31:14.984] - received message: FutureResult
[09:31:14.984] - Received FutureResult
[09:31:14.984] - Erased future from FutureRegistry
[09:31:14.984] result() for ClusterFuture ...
[09:31:14.984] - result already collected: FutureResult
[09:31:14.984] result() for ClusterFuture ... done
[09:31:14.984] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[09:31:14.985] resolve() on environment ...
[09:31:14.985]  recursive: 0
[09:31:14.986]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[09:31:14.986] signalConditionsASAP(numeric, pos=1) ...
[09:31:14.986] - nx: 4
[09:31:14.986] - relay: TRUE
[09:31:14.986] - stdout: TRUE
[09:31:14.986] - signal: TRUE
[09:31:14.986] - resignal: FALSE
[09:31:14.986] - force: TRUE
[09:31:14.987] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.987] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.987]  - until=2
[09:31:14.987]  - relaying element #2
[09:31:14.987] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.987] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.987] signalConditionsASAP(NULL, pos=1) ... done
[09:31:14.987]  length: 3 (resolved future 1)
[09:31:14.987] Future #2
[09:31:14.987] result() for ClusterFuture ...
[09:31:14.987] - result already collected: FutureResult
[09:31:14.988] result() for ClusterFuture ... done
[09:31:14.988] result() for ClusterFuture ...
[09:31:14.988] - result already collected: FutureResult
[09:31:14.988] result() for ClusterFuture ... done
[09:31:14.988] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:14.988] - nx: 4
[09:31:14.988] - relay: TRUE
[09:31:14.988] - stdout: TRUE
[09:31:14.988] - signal: TRUE
[09:31:14.988] - resignal: FALSE
[09:31:14.988] - force: TRUE
[09:31:14.989] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[09:31:14.989] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[09:31:14.989]  - until=2
[09:31:14.989]  - relaying element #2
[09:31:14.989] result() for ClusterFuture ...
[09:31:14.989] - result already collected: FutureResult
[09:31:14.989] result() for ClusterFuture ... done
[09:31:14.989] result() for ClusterFuture ...
[09:31:14.989] - result already collected: FutureResult
[09:31:14.989] result() for ClusterFuture ... done
[09:31:14.990] result() for ClusterFuture ...
[09:31:14.990] - result already collected: FutureResult
[09:31:14.990] result() for ClusterFuture ... done
[09:31:14.990] result() for ClusterFuture ...
[09:31:14.990] - result already collected: FutureResult
[09:31:14.990] result() for ClusterFuture ... done
[09:31:14.990] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.990] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.990] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:14.990]  length: 2 (resolved future 2)
[09:31:14.990] Future #3
[09:31:14.990] result() for ClusterFuture ...
[09:31:14.991] - result already collected: FutureResult
[09:31:14.991] result() for ClusterFuture ... done
[09:31:14.991] result() for ClusterFuture ...
[09:31:14.991] - result already collected: FutureResult
[09:31:14.991] result() for ClusterFuture ... done
[09:31:14.991] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:14.991] - nx: 4
[09:31:14.991] - relay: TRUE
[09:31:14.991] - stdout: TRUE
[09:31:14.991] - signal: TRUE
[09:31:14.991] - resignal: FALSE
[09:31:14.991] - force: TRUE
[09:31:14.992] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[09:31:14.992] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[09:31:14.992]  - until=3
[09:31:14.992]  - relaying element #3
[09:31:14.992] result() for ClusterFuture ...
[09:31:14.992] - result already collected: FutureResult
[09:31:14.992] result() for ClusterFuture ... done
[09:31:14.992] result() for ClusterFuture ...
[09:31:14.992] - result already collected: FutureResult
[09:31:14.992] result() for ClusterFuture ... done
[09:31:14.992] result() for ClusterFuture ...
[09:31:14.993] - result already collected: FutureResult
[09:31:14.993] result() for ClusterFuture ... done
[09:31:14.993] result() for ClusterFuture ...
[09:31:14.993] - result already collected: FutureResult
[09:31:14.993] result() for ClusterFuture ... done
[09:31:14.993] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.993] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.993] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:14.993]  length: 1 (resolved future 3)
[09:31:14.993] Future #4
[09:31:14.993] result() for ClusterFuture ...
[09:31:14.994] - result already collected: FutureResult
[09:31:14.994] result() for ClusterFuture ... done
[09:31:14.994] result() for ClusterFuture ...
[09:31:14.994] - result already collected: FutureResult
[09:31:14.994] result() for ClusterFuture ... done
[09:31:14.994] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:14.994] - nx: 4
[09:31:14.994] - relay: TRUE
[09:31:14.994] - stdout: TRUE
[09:31:14.994] - signal: TRUE
[09:31:14.994] - resignal: FALSE
[09:31:14.994] - force: TRUE
[09:31:14.994] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[09:31:14.995] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[09:31:14.995]  - until=4
[09:31:14.995]  - relaying element #4
[09:31:14.995] result() for ClusterFuture ...
[09:31:14.995] - result already collected: FutureResult
[09:31:14.995] result() for ClusterFuture ... done
[09:31:14.995] result() for ClusterFuture ...
[09:31:14.995] - result already collected: FutureResult
[09:31:14.995] result() for ClusterFuture ... done
[09:31:14.995] result() for ClusterFuture ...
[09:31:14.995] - result already collected: FutureResult
[09:31:14.996] result() for ClusterFuture ... done
[09:31:14.996] result() for ClusterFuture ...
[09:31:14.996] - result already collected: FutureResult
[09:31:14.996] result() for ClusterFuture ... done
[09:31:14.996] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.996] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.996] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:14.996]  length: 0 (resolved future 4)
[09:31:14.996] Relaying remaining futures
[09:31:14.996] signalConditionsASAP(NULL, pos=0) ...
[09:31:14.996] - nx: 4
[09:31:14.996] - relay: TRUE
[09:31:14.997] - stdout: TRUE
[09:31:14.997] - signal: TRUE
[09:31:14.997] - resignal: FALSE
[09:31:14.997] - force: TRUE
[09:31:14.997] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.997] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[09:31:14.997] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[09:31:14.997] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[09:31:14.997] signalConditionsASAP(NULL, pos=0) ... done
[09:31:14.997] resolve() on environment ... DONE
[09:31:14.997] result() for ClusterFuture ...
[09:31:14.997] - result already collected: FutureResult
[09:31:14.998] result() for ClusterFuture ... done
[09:31:14.998] result() for ClusterFuture ...
[09:31:14.998] - result already collected: FutureResult
[09:31:14.998] result() for ClusterFuture ... done
[09:31:14.998] result() for ClusterFuture ...
[09:31:14.998] - result already collected: FutureResult
[09:31:14.998] result() for ClusterFuture ... done
[09:31:14.998] result() for ClusterFuture ...
[09:31:14.998] - result already collected: FutureResult
[09:31:14.998] result() for ClusterFuture ... done
[09:31:14.998] result() for ClusterFuture ...
[09:31:14.998] - result already collected: FutureResult
[09:31:14.999] result() for ClusterFuture ... done
[09:31:14.999] result() for ClusterFuture ...
[09:31:14.999] - result already collected: FutureResult
[09:31:14.999] result() for ClusterFuture ... done
<environment: 0x55a3ca377500> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[09:31:14.999] plan(): Setting new future strategy stack:
[09:31:15.000] List of future strategies:
[09:31:15.000] 1. multicore:
[09:31:15.000]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.000]    - tweaked: FALSE
[09:31:15.000]    - call: plan(strategy)
[09:31:15.004] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:15.004] getGlobalsAndPackages() ...
[09:31:15.004] Searching for globals...
[09:31:15.004] 
[09:31:15.005] Searching for globals ... DONE
[09:31:15.005] - globals: [0] <none>
[09:31:15.005] getGlobalsAndPackages() ... DONE
[09:31:15.005] run() for ‘Future’ ...
[09:31:15.005] - state: ‘created’
[09:31:15.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.009] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.009]   - Field: ‘label’
[09:31:15.009]   - Field: ‘local’
[09:31:15.009]   - Field: ‘owner’
[09:31:15.009]   - Field: ‘envir’
[09:31:15.009]   - Field: ‘workers’
[09:31:15.009]   - Field: ‘packages’
[09:31:15.009]   - Field: ‘gc’
[09:31:15.009]   - Field: ‘job’
[09:31:15.009]   - Field: ‘conditions’
[09:31:15.010]   - Field: ‘expr’
[09:31:15.010]   - Field: ‘uuid’
[09:31:15.010]   - Field: ‘seed’
[09:31:15.010]   - Field: ‘version’
[09:31:15.010]   - Field: ‘result’
[09:31:15.010]   - Field: ‘asynchronous’
[09:31:15.010]   - Field: ‘calls’
[09:31:15.010]   - Field: ‘globals’
[09:31:15.010]   - Field: ‘stdout’
[09:31:15.010]   - Field: ‘earlySignal’
[09:31:15.010]   - Field: ‘lazy’
[09:31:15.011]   - Field: ‘state’
[09:31:15.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.011] - Launch lazy future ...
[09:31:15.011] Packages needed by the future expression (n = 0): <none>
[09:31:15.011] Packages needed by future strategies (n = 0): <none>
[09:31:15.012] {
[09:31:15.012]     {
[09:31:15.012]         {
[09:31:15.012]             ...future.startTime <- base::Sys.time()
[09:31:15.012]             {
[09:31:15.012]                 {
[09:31:15.012]                   {
[09:31:15.012]                     {
[09:31:15.012]                       base::local({
[09:31:15.012]                         has_future <- base::requireNamespace("future", 
[09:31:15.012]                           quietly = TRUE)
[09:31:15.012]                         if (has_future) {
[09:31:15.012]                           ns <- base::getNamespace("future")
[09:31:15.012]                           version <- ns[[".package"]][["version"]]
[09:31:15.012]                           if (is.null(version)) 
[09:31:15.012]                             version <- utils::packageVersion("future")
[09:31:15.012]                         }
[09:31:15.012]                         else {
[09:31:15.012]                           version <- NULL
[09:31:15.012]                         }
[09:31:15.012]                         if (!has_future || version < "1.8.0") {
[09:31:15.012]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.012]                             "", base::R.version$version.string), 
[09:31:15.012]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.012]                               "release", "version")], collapse = " "), 
[09:31:15.012]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.012]                             info)
[09:31:15.012]                           info <- base::paste(info, collapse = "; ")
[09:31:15.012]                           if (!has_future) {
[09:31:15.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.012]                               info)
[09:31:15.012]                           }
[09:31:15.012]                           else {
[09:31:15.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.012]                               info, version)
[09:31:15.012]                           }
[09:31:15.012]                           base::stop(msg)
[09:31:15.012]                         }
[09:31:15.012]                       })
[09:31:15.012]                     }
[09:31:15.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.012]                     base::options(mc.cores = 1L)
[09:31:15.012]                   }
[09:31:15.012]                   ...future.strategy.old <- future::plan("list")
[09:31:15.012]                   options(future.plan = NULL)
[09:31:15.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.012]                 }
[09:31:15.012]                 ...future.workdir <- getwd()
[09:31:15.012]             }
[09:31:15.012]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.012]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.012]         }
[09:31:15.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.012]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.012]             base::names(...future.oldOptions))
[09:31:15.012]     }
[09:31:15.012]     if (FALSE) {
[09:31:15.012]     }
[09:31:15.012]     else {
[09:31:15.012]         if (TRUE) {
[09:31:15.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.012]                 open = "w")
[09:31:15.012]         }
[09:31:15.012]         else {
[09:31:15.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.012]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.012]         }
[09:31:15.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.012]             base::sink(type = "output", split = FALSE)
[09:31:15.012]             base::close(...future.stdout)
[09:31:15.012]         }, add = TRUE)
[09:31:15.012]     }
[09:31:15.012]     ...future.frame <- base::sys.nframe()
[09:31:15.012]     ...future.conditions <- base::list()
[09:31:15.012]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.012]     if (FALSE) {
[09:31:15.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.012]     }
[09:31:15.012]     ...future.result <- base::tryCatch({
[09:31:15.012]         base::withCallingHandlers({
[09:31:15.012]             ...future.value <- base::withVisible(base::local({
[09:31:15.012]                 withCallingHandlers({
[09:31:15.012]                   2
[09:31:15.012]                 }, immediateCondition = function(cond) {
[09:31:15.012]                   save_rds <- function (object, pathname, ...) 
[09:31:15.012]                   {
[09:31:15.012]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.012]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.012]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.012]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.012]                         fi_tmp[["mtime"]])
[09:31:15.012]                     }
[09:31:15.012]                     tryCatch({
[09:31:15.012]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.012]                     }, error = function(ex) {
[09:31:15.012]                       msg <- conditionMessage(ex)
[09:31:15.012]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.012]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.012]                         fi_tmp[["mtime"]], msg)
[09:31:15.012]                       ex$message <- msg
[09:31:15.012]                       stop(ex)
[09:31:15.012]                     })
[09:31:15.012]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.012]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.012]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.012]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.012]                       fi <- file.info(pathname)
[09:31:15.012]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.012]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.012]                         fi[["size"]], fi[["mtime"]])
[09:31:15.012]                       stop(msg)
[09:31:15.012]                     }
[09:31:15.012]                     invisible(pathname)
[09:31:15.012]                   }
[09:31:15.012]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.012]                     rootPath = tempdir()) 
[09:31:15.012]                   {
[09:31:15.012]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.012]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.012]                       tmpdir = path, fileext = ".rds")
[09:31:15.012]                     save_rds(obj, file)
[09:31:15.012]                   }
[09:31:15.012]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.012]                   {
[09:31:15.012]                     inherits <- base::inherits
[09:31:15.012]                     invokeRestart <- base::invokeRestart
[09:31:15.012]                     is.null <- base::is.null
[09:31:15.012]                     muffled <- FALSE
[09:31:15.012]                     if (inherits(cond, "message")) {
[09:31:15.012]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.012]                       if (muffled) 
[09:31:15.012]                         invokeRestart("muffleMessage")
[09:31:15.012]                     }
[09:31:15.012]                     else if (inherits(cond, "warning")) {
[09:31:15.012]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.012]                       if (muffled) 
[09:31:15.012]                         invokeRestart("muffleWarning")
[09:31:15.012]                     }
[09:31:15.012]                     else if (inherits(cond, "condition")) {
[09:31:15.012]                       if (!is.null(pattern)) {
[09:31:15.012]                         computeRestarts <- base::computeRestarts
[09:31:15.012]                         grepl <- base::grepl
[09:31:15.012]                         restarts <- computeRestarts(cond)
[09:31:15.012]                         for (restart in restarts) {
[09:31:15.012]                           name <- restart$name
[09:31:15.012]                           if (is.null(name)) 
[09:31:15.012]                             next
[09:31:15.012]                           if (!grepl(pattern, name)) 
[09:31:15.012]                             next
[09:31:15.012]                           invokeRestart(restart)
[09:31:15.012]                           muffled <- TRUE
[09:31:15.012]                           break
[09:31:15.012]                         }
[09:31:15.012]                       }
[09:31:15.012]                     }
[09:31:15.012]                     invisible(muffled)
[09:31:15.012]                   }
[09:31:15.012]                   muffleCondition(cond)
[09:31:15.012]                 })
[09:31:15.012]             }))
[09:31:15.012]             future::FutureResult(value = ...future.value$value, 
[09:31:15.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.012]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.012]                     ...future.globalenv.names))
[09:31:15.012]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.012]         }, condition = base::local({
[09:31:15.012]             c <- base::c
[09:31:15.012]             inherits <- base::inherits
[09:31:15.012]             invokeRestart <- base::invokeRestart
[09:31:15.012]             length <- base::length
[09:31:15.012]             list <- base::list
[09:31:15.012]             seq.int <- base::seq.int
[09:31:15.012]             signalCondition <- base::signalCondition
[09:31:15.012]             sys.calls <- base::sys.calls
[09:31:15.012]             `[[` <- base::`[[`
[09:31:15.012]             `+` <- base::`+`
[09:31:15.012]             `<<-` <- base::`<<-`
[09:31:15.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.012]                   3L)]
[09:31:15.012]             }
[09:31:15.012]             function(cond) {
[09:31:15.012]                 is_error <- inherits(cond, "error")
[09:31:15.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.012]                   NULL)
[09:31:15.012]                 if (is_error) {
[09:31:15.012]                   sessionInformation <- function() {
[09:31:15.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.012]                       search = base::search(), system = base::Sys.info())
[09:31:15.012]                   }
[09:31:15.012]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.012]                     cond$call), session = sessionInformation(), 
[09:31:15.012]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.012]                   signalCondition(cond)
[09:31:15.012]                 }
[09:31:15.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.012]                 "immediateCondition"))) {
[09:31:15.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.012]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.012]                   if (TRUE && !signal) {
[09:31:15.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.012]                     {
[09:31:15.012]                       inherits <- base::inherits
[09:31:15.012]                       invokeRestart <- base::invokeRestart
[09:31:15.012]                       is.null <- base::is.null
[09:31:15.012]                       muffled <- FALSE
[09:31:15.012]                       if (inherits(cond, "message")) {
[09:31:15.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.012]                         if (muffled) 
[09:31:15.012]                           invokeRestart("muffleMessage")
[09:31:15.012]                       }
[09:31:15.012]                       else if (inherits(cond, "warning")) {
[09:31:15.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.012]                         if (muffled) 
[09:31:15.012]                           invokeRestart("muffleWarning")
[09:31:15.012]                       }
[09:31:15.012]                       else if (inherits(cond, "condition")) {
[09:31:15.012]                         if (!is.null(pattern)) {
[09:31:15.012]                           computeRestarts <- base::computeRestarts
[09:31:15.012]                           grepl <- base::grepl
[09:31:15.012]                           restarts <- computeRestarts(cond)
[09:31:15.012]                           for (restart in restarts) {
[09:31:15.012]                             name <- restart$name
[09:31:15.012]                             if (is.null(name)) 
[09:31:15.012]                               next
[09:31:15.012]                             if (!grepl(pattern, name)) 
[09:31:15.012]                               next
[09:31:15.012]                             invokeRestart(restart)
[09:31:15.012]                             muffled <- TRUE
[09:31:15.012]                             break
[09:31:15.012]                           }
[09:31:15.012]                         }
[09:31:15.012]                       }
[09:31:15.012]                       invisible(muffled)
[09:31:15.012]                     }
[09:31:15.012]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.012]                   }
[09:31:15.012]                 }
[09:31:15.012]                 else {
[09:31:15.012]                   if (TRUE) {
[09:31:15.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.012]                     {
[09:31:15.012]                       inherits <- base::inherits
[09:31:15.012]                       invokeRestart <- base::invokeRestart
[09:31:15.012]                       is.null <- base::is.null
[09:31:15.012]                       muffled <- FALSE
[09:31:15.012]                       if (inherits(cond, "message")) {
[09:31:15.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.012]                         if (muffled) 
[09:31:15.012]                           invokeRestart("muffleMessage")
[09:31:15.012]                       }
[09:31:15.012]                       else if (inherits(cond, "warning")) {
[09:31:15.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.012]                         if (muffled) 
[09:31:15.012]                           invokeRestart("muffleWarning")
[09:31:15.012]                       }
[09:31:15.012]                       else if (inherits(cond, "condition")) {
[09:31:15.012]                         if (!is.null(pattern)) {
[09:31:15.012]                           computeRestarts <- base::computeRestarts
[09:31:15.012]                           grepl <- base::grepl
[09:31:15.012]                           restarts <- computeRestarts(cond)
[09:31:15.012]                           for (restart in restarts) {
[09:31:15.012]                             name <- restart$name
[09:31:15.012]                             if (is.null(name)) 
[09:31:15.012]                               next
[09:31:15.012]                             if (!grepl(pattern, name)) 
[09:31:15.012]                               next
[09:31:15.012]                             invokeRestart(restart)
[09:31:15.012]                             muffled <- TRUE
[09:31:15.012]                             break
[09:31:15.012]                           }
[09:31:15.012]                         }
[09:31:15.012]                       }
[09:31:15.012]                       invisible(muffled)
[09:31:15.012]                     }
[09:31:15.012]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.012]                   }
[09:31:15.012]                 }
[09:31:15.012]             }
[09:31:15.012]         }))
[09:31:15.012]     }, error = function(ex) {
[09:31:15.012]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.012]                 ...future.rng), started = ...future.startTime, 
[09:31:15.012]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.012]             version = "1.8"), class = "FutureResult")
[09:31:15.012]     }, finally = {
[09:31:15.012]         if (!identical(...future.workdir, getwd())) 
[09:31:15.012]             setwd(...future.workdir)
[09:31:15.012]         {
[09:31:15.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.012]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.012]             }
[09:31:15.012]             base::options(...future.oldOptions)
[09:31:15.012]             if (.Platform$OS.type == "windows") {
[09:31:15.012]                 old_names <- names(...future.oldEnvVars)
[09:31:15.012]                 envs <- base::Sys.getenv()
[09:31:15.012]                 names <- names(envs)
[09:31:15.012]                 common <- intersect(names, old_names)
[09:31:15.012]                 added <- setdiff(names, old_names)
[09:31:15.012]                 removed <- setdiff(old_names, names)
[09:31:15.012]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.012]                   envs[common]]
[09:31:15.012]                 NAMES <- toupper(changed)
[09:31:15.012]                 args <- list()
[09:31:15.012]                 for (kk in seq_along(NAMES)) {
[09:31:15.012]                   name <- changed[[kk]]
[09:31:15.012]                   NAME <- NAMES[[kk]]
[09:31:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.012]                     next
[09:31:15.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.012]                 }
[09:31:15.012]                 NAMES <- toupper(added)
[09:31:15.012]                 for (kk in seq_along(NAMES)) {
[09:31:15.012]                   name <- added[[kk]]
[09:31:15.012]                   NAME <- NAMES[[kk]]
[09:31:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.012]                     next
[09:31:15.012]                   args[[name]] <- ""
[09:31:15.012]                 }
[09:31:15.012]                 NAMES <- toupper(removed)
[09:31:15.012]                 for (kk in seq_along(NAMES)) {
[09:31:15.012]                   name <- removed[[kk]]
[09:31:15.012]                   NAME <- NAMES[[kk]]
[09:31:15.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.012]                     next
[09:31:15.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.012]                 }
[09:31:15.012]                 if (length(args) > 0) 
[09:31:15.012]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.012]             }
[09:31:15.012]             else {
[09:31:15.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.012]             }
[09:31:15.012]             {
[09:31:15.012]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.012]                   0L) {
[09:31:15.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.012]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.012]                   base::options(opts)
[09:31:15.012]                 }
[09:31:15.012]                 {
[09:31:15.012]                   {
[09:31:15.012]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.012]                     NULL
[09:31:15.012]                   }
[09:31:15.012]                   options(future.plan = NULL)
[09:31:15.012]                   if (is.na(NA_character_)) 
[09:31:15.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.012]                     .init = FALSE)
[09:31:15.012]                 }
[09:31:15.012]             }
[09:31:15.012]         }
[09:31:15.012]     })
[09:31:15.012]     if (TRUE) {
[09:31:15.012]         base::sink(type = "output", split = FALSE)
[09:31:15.012]         if (TRUE) {
[09:31:15.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.012]         }
[09:31:15.012]         else {
[09:31:15.012]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.012]         }
[09:31:15.012]         base::close(...future.stdout)
[09:31:15.012]         ...future.stdout <- NULL
[09:31:15.012]     }
[09:31:15.012]     ...future.result$conditions <- ...future.conditions
[09:31:15.012]     ...future.result$finished <- base::Sys.time()
[09:31:15.012]     ...future.result
[09:31:15.012] }
[09:31:15.014] requestCore(): workers = 2
[09:31:15.016] MulticoreFuture started
[09:31:15.017] - Launch lazy future ... done
[09:31:15.017] run() for ‘MulticoreFuture’ ... done
[09:31:15.017] getGlobalsAndPackages() ...
[09:31:15.017] Searching for globals...
[09:31:15.017] plan(): Setting new future strategy stack:
[09:31:15.018] 
[09:31:15.018] Searching for globals ... DONE
[09:31:15.017] List of future strategies:
[09:31:15.017] 1. sequential:
[09:31:15.017]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.017]    - tweaked: FALSE
[09:31:15.017]    - call: NULL
[09:31:15.018] - globals: [0] <none>
[09:31:15.018] getGlobalsAndPackages() ... DONE
[09:31:15.018] plan(): nbrOfWorkers() = 1
[09:31:15.019] run() for ‘Future’ ...
[09:31:15.019] - state: ‘created’
[09:31:15.019] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.020] plan(): Setting new future strategy stack:
[09:31:15.020] List of future strategies:
[09:31:15.020] 1. multicore:
[09:31:15.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.020]    - tweaked: FALSE
[09:31:15.020]    - call: plan(strategy)
[09:31:15.025] plan(): nbrOfWorkers() = 2
[09:31:15.025] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.026]   - Field: ‘label’
[09:31:15.026]   - Field: ‘local’
[09:31:15.026]   - Field: ‘owner’
[09:31:15.026]   - Field: ‘envir’
[09:31:15.026]   - Field: ‘workers’
[09:31:15.026]   - Field: ‘packages’
[09:31:15.027]   - Field: ‘gc’
[09:31:15.027]   - Field: ‘job’
[09:31:15.027]   - Field: ‘conditions’
[09:31:15.027]   - Field: ‘expr’
[09:31:15.027]   - Field: ‘uuid’
[09:31:15.027]   - Field: ‘seed’
[09:31:15.027]   - Field: ‘version’
[09:31:15.028]   - Field: ‘result’
[09:31:15.028]   - Field: ‘asynchronous’
[09:31:15.028]   - Field: ‘calls’
[09:31:15.028]   - Field: ‘globals’
[09:31:15.028]   - Field: ‘stdout’
[09:31:15.028]   - Field: ‘earlySignal’
[09:31:15.028]   - Field: ‘lazy’
[09:31:15.029]   - Field: ‘state’
[09:31:15.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.029] - Launch lazy future ...
[09:31:15.029] Packages needed by the future expression (n = 0): <none>
[09:31:15.029] Packages needed by future strategies (n = 0): <none>
[09:31:15.030] {
[09:31:15.030]     {
[09:31:15.030]         {
[09:31:15.030]             ...future.startTime <- base::Sys.time()
[09:31:15.030]             {
[09:31:15.030]                 {
[09:31:15.030]                   {
[09:31:15.030]                     {
[09:31:15.030]                       base::local({
[09:31:15.030]                         has_future <- base::requireNamespace("future", 
[09:31:15.030]                           quietly = TRUE)
[09:31:15.030]                         if (has_future) {
[09:31:15.030]                           ns <- base::getNamespace("future")
[09:31:15.030]                           version <- ns[[".package"]][["version"]]
[09:31:15.030]                           if (is.null(version)) 
[09:31:15.030]                             version <- utils::packageVersion("future")
[09:31:15.030]                         }
[09:31:15.030]                         else {
[09:31:15.030]                           version <- NULL
[09:31:15.030]                         }
[09:31:15.030]                         if (!has_future || version < "1.8.0") {
[09:31:15.030]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.030]                             "", base::R.version$version.string), 
[09:31:15.030]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.030]                               "release", "version")], collapse = " "), 
[09:31:15.030]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.030]                             info)
[09:31:15.030]                           info <- base::paste(info, collapse = "; ")
[09:31:15.030]                           if (!has_future) {
[09:31:15.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.030]                               info)
[09:31:15.030]                           }
[09:31:15.030]                           else {
[09:31:15.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.030]                               info, version)
[09:31:15.030]                           }
[09:31:15.030]                           base::stop(msg)
[09:31:15.030]                         }
[09:31:15.030]                       })
[09:31:15.030]                     }
[09:31:15.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.030]                     base::options(mc.cores = 1L)
[09:31:15.030]                   }
[09:31:15.030]                   ...future.strategy.old <- future::plan("list")
[09:31:15.030]                   options(future.plan = NULL)
[09:31:15.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.030]                 }
[09:31:15.030]                 ...future.workdir <- getwd()
[09:31:15.030]             }
[09:31:15.030]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.030]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.030]         }
[09:31:15.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.030]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.030]             base::names(...future.oldOptions))
[09:31:15.030]     }
[09:31:15.030]     if (FALSE) {
[09:31:15.030]     }
[09:31:15.030]     else {
[09:31:15.030]         if (TRUE) {
[09:31:15.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.030]                 open = "w")
[09:31:15.030]         }
[09:31:15.030]         else {
[09:31:15.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.030]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.030]         }
[09:31:15.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.030]             base::sink(type = "output", split = FALSE)
[09:31:15.030]             base::close(...future.stdout)
[09:31:15.030]         }, add = TRUE)
[09:31:15.030]     }
[09:31:15.030]     ...future.frame <- base::sys.nframe()
[09:31:15.030]     ...future.conditions <- base::list()
[09:31:15.030]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.030]     if (FALSE) {
[09:31:15.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.030]     }
[09:31:15.030]     ...future.result <- base::tryCatch({
[09:31:15.030]         base::withCallingHandlers({
[09:31:15.030]             ...future.value <- base::withVisible(base::local({
[09:31:15.030]                 withCallingHandlers({
[09:31:15.030]                   NULL
[09:31:15.030]                 }, immediateCondition = function(cond) {
[09:31:15.030]                   save_rds <- function (object, pathname, ...) 
[09:31:15.030]                   {
[09:31:15.030]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.030]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.030]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.030]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.030]                         fi_tmp[["mtime"]])
[09:31:15.030]                     }
[09:31:15.030]                     tryCatch({
[09:31:15.030]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.030]                     }, error = function(ex) {
[09:31:15.030]                       msg <- conditionMessage(ex)
[09:31:15.030]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.030]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.030]                         fi_tmp[["mtime"]], msg)
[09:31:15.030]                       ex$message <- msg
[09:31:15.030]                       stop(ex)
[09:31:15.030]                     })
[09:31:15.030]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.030]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.030]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.030]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.030]                       fi <- file.info(pathname)
[09:31:15.030]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.030]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.030]                         fi[["size"]], fi[["mtime"]])
[09:31:15.030]                       stop(msg)
[09:31:15.030]                     }
[09:31:15.030]                     invisible(pathname)
[09:31:15.030]                   }
[09:31:15.030]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.030]                     rootPath = tempdir()) 
[09:31:15.030]                   {
[09:31:15.030]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.030]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.030]                       tmpdir = path, fileext = ".rds")
[09:31:15.030]                     save_rds(obj, file)
[09:31:15.030]                   }
[09:31:15.030]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.030]                   {
[09:31:15.030]                     inherits <- base::inherits
[09:31:15.030]                     invokeRestart <- base::invokeRestart
[09:31:15.030]                     is.null <- base::is.null
[09:31:15.030]                     muffled <- FALSE
[09:31:15.030]                     if (inherits(cond, "message")) {
[09:31:15.030]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.030]                       if (muffled) 
[09:31:15.030]                         invokeRestart("muffleMessage")
[09:31:15.030]                     }
[09:31:15.030]                     else if (inherits(cond, "warning")) {
[09:31:15.030]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.030]                       if (muffled) 
[09:31:15.030]                         invokeRestart("muffleWarning")
[09:31:15.030]                     }
[09:31:15.030]                     else if (inherits(cond, "condition")) {
[09:31:15.030]                       if (!is.null(pattern)) {
[09:31:15.030]                         computeRestarts <- base::computeRestarts
[09:31:15.030]                         grepl <- base::grepl
[09:31:15.030]                         restarts <- computeRestarts(cond)
[09:31:15.030]                         for (restart in restarts) {
[09:31:15.030]                           name <- restart$name
[09:31:15.030]                           if (is.null(name)) 
[09:31:15.030]                             next
[09:31:15.030]                           if (!grepl(pattern, name)) 
[09:31:15.030]                             next
[09:31:15.030]                           invokeRestart(restart)
[09:31:15.030]                           muffled <- TRUE
[09:31:15.030]                           break
[09:31:15.030]                         }
[09:31:15.030]                       }
[09:31:15.030]                     }
[09:31:15.030]                     invisible(muffled)
[09:31:15.030]                   }
[09:31:15.030]                   muffleCondition(cond)
[09:31:15.030]                 })
[09:31:15.030]             }))
[09:31:15.030]             future::FutureResult(value = ...future.value$value, 
[09:31:15.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.030]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.030]                     ...future.globalenv.names))
[09:31:15.030]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.030]         }, condition = base::local({
[09:31:15.030]             c <- base::c
[09:31:15.030]             inherits <- base::inherits
[09:31:15.030]             invokeRestart <- base::invokeRestart
[09:31:15.030]             length <- base::length
[09:31:15.030]             list <- base::list
[09:31:15.030]             seq.int <- base::seq.int
[09:31:15.030]             signalCondition <- base::signalCondition
[09:31:15.030]             sys.calls <- base::sys.calls
[09:31:15.030]             `[[` <- base::`[[`
[09:31:15.030]             `+` <- base::`+`
[09:31:15.030]             `<<-` <- base::`<<-`
[09:31:15.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.030]                   3L)]
[09:31:15.030]             }
[09:31:15.030]             function(cond) {
[09:31:15.030]                 is_error <- inherits(cond, "error")
[09:31:15.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.030]                   NULL)
[09:31:15.030]                 if (is_error) {
[09:31:15.030]                   sessionInformation <- function() {
[09:31:15.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.030]                       search = base::search(), system = base::Sys.info())
[09:31:15.030]                   }
[09:31:15.030]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.030]                     cond$call), session = sessionInformation(), 
[09:31:15.030]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.030]                   signalCondition(cond)
[09:31:15.030]                 }
[09:31:15.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.030]                 "immediateCondition"))) {
[09:31:15.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.030]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.030]                   if (TRUE && !signal) {
[09:31:15.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.030]                     {
[09:31:15.030]                       inherits <- base::inherits
[09:31:15.030]                       invokeRestart <- base::invokeRestart
[09:31:15.030]                       is.null <- base::is.null
[09:31:15.030]                       muffled <- FALSE
[09:31:15.030]                       if (inherits(cond, "message")) {
[09:31:15.030]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.030]                         if (muffled) 
[09:31:15.030]                           invokeRestart("muffleMessage")
[09:31:15.030]                       }
[09:31:15.030]                       else if (inherits(cond, "warning")) {
[09:31:15.030]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.030]                         if (muffled) 
[09:31:15.030]                           invokeRestart("muffleWarning")
[09:31:15.030]                       }
[09:31:15.030]                       else if (inherits(cond, "condition")) {
[09:31:15.030]                         if (!is.null(pattern)) {
[09:31:15.030]                           computeRestarts <- base::computeRestarts
[09:31:15.030]                           grepl <- base::grepl
[09:31:15.030]                           restarts <- computeRestarts(cond)
[09:31:15.030]                           for (restart in restarts) {
[09:31:15.030]                             name <- restart$name
[09:31:15.030]                             if (is.null(name)) 
[09:31:15.030]                               next
[09:31:15.030]                             if (!grepl(pattern, name)) 
[09:31:15.030]                               next
[09:31:15.030]                             invokeRestart(restart)
[09:31:15.030]                             muffled <- TRUE
[09:31:15.030]                             break
[09:31:15.030]                           }
[09:31:15.030]                         }
[09:31:15.030]                       }
[09:31:15.030]                       invisible(muffled)
[09:31:15.030]                     }
[09:31:15.030]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.030]                   }
[09:31:15.030]                 }
[09:31:15.030]                 else {
[09:31:15.030]                   if (TRUE) {
[09:31:15.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.030]                     {
[09:31:15.030]                       inherits <- base::inherits
[09:31:15.030]                       invokeRestart <- base::invokeRestart
[09:31:15.030]                       is.null <- base::is.null
[09:31:15.030]                       muffled <- FALSE
[09:31:15.030]                       if (inherits(cond, "message")) {
[09:31:15.030]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.030]                         if (muffled) 
[09:31:15.030]                           invokeRestart("muffleMessage")
[09:31:15.030]                       }
[09:31:15.030]                       else if (inherits(cond, "warning")) {
[09:31:15.030]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.030]                         if (muffled) 
[09:31:15.030]                           invokeRestart("muffleWarning")
[09:31:15.030]                       }
[09:31:15.030]                       else if (inherits(cond, "condition")) {
[09:31:15.030]                         if (!is.null(pattern)) {
[09:31:15.030]                           computeRestarts <- base::computeRestarts
[09:31:15.030]                           grepl <- base::grepl
[09:31:15.030]                           restarts <- computeRestarts(cond)
[09:31:15.030]                           for (restart in restarts) {
[09:31:15.030]                             name <- restart$name
[09:31:15.030]                             if (is.null(name)) 
[09:31:15.030]                               next
[09:31:15.030]                             if (!grepl(pattern, name)) 
[09:31:15.030]                               next
[09:31:15.030]                             invokeRestart(restart)
[09:31:15.030]                             muffled <- TRUE
[09:31:15.030]                             break
[09:31:15.030]                           }
[09:31:15.030]                         }
[09:31:15.030]                       }
[09:31:15.030]                       invisible(muffled)
[09:31:15.030]                     }
[09:31:15.030]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.030]                   }
[09:31:15.030]                 }
[09:31:15.030]             }
[09:31:15.030]         }))
[09:31:15.030]     }, error = function(ex) {
[09:31:15.030]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.030]                 ...future.rng), started = ...future.startTime, 
[09:31:15.030]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.030]             version = "1.8"), class = "FutureResult")
[09:31:15.030]     }, finally = {
[09:31:15.030]         if (!identical(...future.workdir, getwd())) 
[09:31:15.030]             setwd(...future.workdir)
[09:31:15.030]         {
[09:31:15.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.030]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.030]             }
[09:31:15.030]             base::options(...future.oldOptions)
[09:31:15.030]             if (.Platform$OS.type == "windows") {
[09:31:15.030]                 old_names <- names(...future.oldEnvVars)
[09:31:15.030]                 envs <- base::Sys.getenv()
[09:31:15.030]                 names <- names(envs)
[09:31:15.030]                 common <- intersect(names, old_names)
[09:31:15.030]                 added <- setdiff(names, old_names)
[09:31:15.030]                 removed <- setdiff(old_names, names)
[09:31:15.030]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.030]                   envs[common]]
[09:31:15.030]                 NAMES <- toupper(changed)
[09:31:15.030]                 args <- list()
[09:31:15.030]                 for (kk in seq_along(NAMES)) {
[09:31:15.030]                   name <- changed[[kk]]
[09:31:15.030]                   NAME <- NAMES[[kk]]
[09:31:15.030]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.030]                     next
[09:31:15.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.030]                 }
[09:31:15.030]                 NAMES <- toupper(added)
[09:31:15.030]                 for (kk in seq_along(NAMES)) {
[09:31:15.030]                   name <- added[[kk]]
[09:31:15.030]                   NAME <- NAMES[[kk]]
[09:31:15.030]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.030]                     next
[09:31:15.030]                   args[[name]] <- ""
[09:31:15.030]                 }
[09:31:15.030]                 NAMES <- toupper(removed)
[09:31:15.030]                 for (kk in seq_along(NAMES)) {
[09:31:15.030]                   name <- removed[[kk]]
[09:31:15.030]                   NAME <- NAMES[[kk]]
[09:31:15.030]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.030]                     next
[09:31:15.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.030]                 }
[09:31:15.030]                 if (length(args) > 0) 
[09:31:15.030]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.030]             }
[09:31:15.030]             else {
[09:31:15.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.030]             }
[09:31:15.030]             {
[09:31:15.030]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.030]                   0L) {
[09:31:15.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.030]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.030]                   base::options(opts)
[09:31:15.030]                 }
[09:31:15.030]                 {
[09:31:15.030]                   {
[09:31:15.030]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.030]                     NULL
[09:31:15.030]                   }
[09:31:15.030]                   options(future.plan = NULL)
[09:31:15.030]                   if (is.na(NA_character_)) 
[09:31:15.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.030]                     .init = FALSE)
[09:31:15.030]                 }
[09:31:15.030]             }
[09:31:15.030]         }
[09:31:15.030]     })
[09:31:15.030]     if (TRUE) {
[09:31:15.030]         base::sink(type = "output", split = FALSE)
[09:31:15.030]         if (TRUE) {
[09:31:15.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.030]         }
[09:31:15.030]         else {
[09:31:15.030]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.030]         }
[09:31:15.030]         base::close(...future.stdout)
[09:31:15.030]         ...future.stdout <- NULL
[09:31:15.030]     }
[09:31:15.030]     ...future.result$conditions <- ...future.conditions
[09:31:15.030]     ...future.result$finished <- base::Sys.time()
[09:31:15.030]     ...future.result
[09:31:15.030] }
[09:31:15.034] requestCore(): workers = 2
[09:31:15.036] MulticoreFuture started
[09:31:15.037] - Launch lazy future ... done
[09:31:15.037] run() for ‘MulticoreFuture’ ... done
[09:31:15.037] plan(): Setting new future strategy stack:
[09:31:15.038] getGlobalsAndPackages() ...
[09:31:15.038] Searching for globals...
[09:31:15.038] List of future strategies:
[09:31:15.038] 1. sequential:
[09:31:15.038]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.038]    - tweaked: FALSE
[09:31:15.038]    - call: NULL
[09:31:15.039] plan(): nbrOfWorkers() = 1
[09:31:15.039] - globals found: [1] ‘{’
[09:31:15.039] Searching for globals ... DONE
[09:31:15.040] Resolving globals: FALSE
[09:31:15.040] 
[09:31:15.040] 
[09:31:15.040] getGlobalsAndPackages() ... DONE
[09:31:15.041] plan(): Setting new future strategy stack:
[09:31:15.041] run() for ‘Future’ ...
[09:31:15.041] - state: ‘created’
[09:31:15.041] List of future strategies:
[09:31:15.041] 1. multicore:
[09:31:15.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.041]    - tweaked: FALSE
[09:31:15.041]    - call: plan(strategy)
[09:31:15.041] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.046] plan(): nbrOfWorkers() = 2
[09:31:15.047] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.047] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.047]   - Field: ‘label’
[09:31:15.047]   - Field: ‘local’
[09:31:15.047]   - Field: ‘owner’
[09:31:15.047]   - Field: ‘envir’
[09:31:15.048]   - Field: ‘workers’
[09:31:15.048]   - Field: ‘packages’
[09:31:15.048]   - Field: ‘gc’
[09:31:15.048]   - Field: ‘job’
[09:31:15.048]   - Field: ‘conditions’
[09:31:15.048]   - Field: ‘expr’
[09:31:15.048]   - Field: ‘uuid’
[09:31:15.049]   - Field: ‘seed’
[09:31:15.049]   - Field: ‘version’
[09:31:15.049]   - Field: ‘result’
[09:31:15.049]   - Field: ‘asynchronous’
[09:31:15.049]   - Field: ‘calls’
[09:31:15.049]   - Field: ‘globals’
[09:31:15.049]   - Field: ‘stdout’
[09:31:15.049]   - Field: ‘earlySignal’
[09:31:15.050]   - Field: ‘lazy’
[09:31:15.050]   - Field: ‘state’
[09:31:15.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.050] - Launch lazy future ...
[09:31:15.050] Packages needed by the future expression (n = 0): <none>
[09:31:15.051] Packages needed by future strategies (n = 0): <none>
[09:31:15.051] {
[09:31:15.051]     {
[09:31:15.051]         {
[09:31:15.051]             ...future.startTime <- base::Sys.time()
[09:31:15.051]             {
[09:31:15.051]                 {
[09:31:15.051]                   {
[09:31:15.051]                     {
[09:31:15.051]                       base::local({
[09:31:15.051]                         has_future <- base::requireNamespace("future", 
[09:31:15.051]                           quietly = TRUE)
[09:31:15.051]                         if (has_future) {
[09:31:15.051]                           ns <- base::getNamespace("future")
[09:31:15.051]                           version <- ns[[".package"]][["version"]]
[09:31:15.051]                           if (is.null(version)) 
[09:31:15.051]                             version <- utils::packageVersion("future")
[09:31:15.051]                         }
[09:31:15.051]                         else {
[09:31:15.051]                           version <- NULL
[09:31:15.051]                         }
[09:31:15.051]                         if (!has_future || version < "1.8.0") {
[09:31:15.051]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.051]                             "", base::R.version$version.string), 
[09:31:15.051]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.051]                               "release", "version")], collapse = " "), 
[09:31:15.051]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.051]                             info)
[09:31:15.051]                           info <- base::paste(info, collapse = "; ")
[09:31:15.051]                           if (!has_future) {
[09:31:15.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.051]                               info)
[09:31:15.051]                           }
[09:31:15.051]                           else {
[09:31:15.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.051]                               info, version)
[09:31:15.051]                           }
[09:31:15.051]                           base::stop(msg)
[09:31:15.051]                         }
[09:31:15.051]                       })
[09:31:15.051]                     }
[09:31:15.051]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.051]                     base::options(mc.cores = 1L)
[09:31:15.051]                   }
[09:31:15.051]                   ...future.strategy.old <- future::plan("list")
[09:31:15.051]                   options(future.plan = NULL)
[09:31:15.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.051]                 }
[09:31:15.051]                 ...future.workdir <- getwd()
[09:31:15.051]             }
[09:31:15.051]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.051]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.051]         }
[09:31:15.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.051]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.051]             base::names(...future.oldOptions))
[09:31:15.051]     }
[09:31:15.051]     if (FALSE) {
[09:31:15.051]     }
[09:31:15.051]     else {
[09:31:15.051]         if (TRUE) {
[09:31:15.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.051]                 open = "w")
[09:31:15.051]         }
[09:31:15.051]         else {
[09:31:15.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.051]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.051]         }
[09:31:15.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.051]             base::sink(type = "output", split = FALSE)
[09:31:15.051]             base::close(...future.stdout)
[09:31:15.051]         }, add = TRUE)
[09:31:15.051]     }
[09:31:15.051]     ...future.frame <- base::sys.nframe()
[09:31:15.051]     ...future.conditions <- base::list()
[09:31:15.051]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.051]     if (FALSE) {
[09:31:15.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.051]     }
[09:31:15.051]     ...future.result <- base::tryCatch({
[09:31:15.051]         base::withCallingHandlers({
[09:31:15.051]             ...future.value <- base::withVisible(base::local({
[09:31:15.051]                 withCallingHandlers({
[09:31:15.051]                   {
[09:31:15.051]                     4
[09:31:15.051]                   }
[09:31:15.051]                 }, immediateCondition = function(cond) {
[09:31:15.051]                   save_rds <- function (object, pathname, ...) 
[09:31:15.051]                   {
[09:31:15.051]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.051]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.051]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.051]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.051]                         fi_tmp[["mtime"]])
[09:31:15.051]                     }
[09:31:15.051]                     tryCatch({
[09:31:15.051]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.051]                     }, error = function(ex) {
[09:31:15.051]                       msg <- conditionMessage(ex)
[09:31:15.051]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.051]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.051]                         fi_tmp[["mtime"]], msg)
[09:31:15.051]                       ex$message <- msg
[09:31:15.051]                       stop(ex)
[09:31:15.051]                     })
[09:31:15.051]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.051]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.051]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.051]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.051]                       fi <- file.info(pathname)
[09:31:15.051]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.051]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.051]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.051]                         fi[["size"]], fi[["mtime"]])
[09:31:15.051]                       stop(msg)
[09:31:15.051]                     }
[09:31:15.051]                     invisible(pathname)
[09:31:15.051]                   }
[09:31:15.051]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.051]                     rootPath = tempdir()) 
[09:31:15.051]                   {
[09:31:15.051]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.051]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.051]                       tmpdir = path, fileext = ".rds")
[09:31:15.051]                     save_rds(obj, file)
[09:31:15.051]                   }
[09:31:15.051]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.051]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.051]                   {
[09:31:15.051]                     inherits <- base::inherits
[09:31:15.051]                     invokeRestart <- base::invokeRestart
[09:31:15.051]                     is.null <- base::is.null
[09:31:15.051]                     muffled <- FALSE
[09:31:15.051]                     if (inherits(cond, "message")) {
[09:31:15.051]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.051]                       if (muffled) 
[09:31:15.051]                         invokeRestart("muffleMessage")
[09:31:15.051]                     }
[09:31:15.051]                     else if (inherits(cond, "warning")) {
[09:31:15.051]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.051]                       if (muffled) 
[09:31:15.051]                         invokeRestart("muffleWarning")
[09:31:15.051]                     }
[09:31:15.051]                     else if (inherits(cond, "condition")) {
[09:31:15.051]                       if (!is.null(pattern)) {
[09:31:15.051]                         computeRestarts <- base::computeRestarts
[09:31:15.051]                         grepl <- base::grepl
[09:31:15.051]                         restarts <- computeRestarts(cond)
[09:31:15.051]                         for (restart in restarts) {
[09:31:15.051]                           name <- restart$name
[09:31:15.051]                           if (is.null(name)) 
[09:31:15.051]                             next
[09:31:15.051]                           if (!grepl(pattern, name)) 
[09:31:15.051]                             next
[09:31:15.051]                           invokeRestart(restart)
[09:31:15.051]                           muffled <- TRUE
[09:31:15.051]                           break
[09:31:15.051]                         }
[09:31:15.051]                       }
[09:31:15.051]                     }
[09:31:15.051]                     invisible(muffled)
[09:31:15.051]                   }
[09:31:15.051]                   muffleCondition(cond)
[09:31:15.051]                 })
[09:31:15.051]             }))
[09:31:15.051]             future::FutureResult(value = ...future.value$value, 
[09:31:15.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.051]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.051]                     ...future.globalenv.names))
[09:31:15.051]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.051]         }, condition = base::local({
[09:31:15.051]             c <- base::c
[09:31:15.051]             inherits <- base::inherits
[09:31:15.051]             invokeRestart <- base::invokeRestart
[09:31:15.051]             length <- base::length
[09:31:15.051]             list <- base::list
[09:31:15.051]             seq.int <- base::seq.int
[09:31:15.051]             signalCondition <- base::signalCondition
[09:31:15.051]             sys.calls <- base::sys.calls
[09:31:15.051]             `[[` <- base::`[[`
[09:31:15.051]             `+` <- base::`+`
[09:31:15.051]             `<<-` <- base::`<<-`
[09:31:15.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.051]                   3L)]
[09:31:15.051]             }
[09:31:15.051]             function(cond) {
[09:31:15.051]                 is_error <- inherits(cond, "error")
[09:31:15.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.051]                   NULL)
[09:31:15.051]                 if (is_error) {
[09:31:15.051]                   sessionInformation <- function() {
[09:31:15.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.051]                       search = base::search(), system = base::Sys.info())
[09:31:15.051]                   }
[09:31:15.051]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.051]                     cond$call), session = sessionInformation(), 
[09:31:15.051]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.051]                   signalCondition(cond)
[09:31:15.051]                 }
[09:31:15.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.051]                 "immediateCondition"))) {
[09:31:15.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.051]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.051]                   if (TRUE && !signal) {
[09:31:15.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.051]                     {
[09:31:15.051]                       inherits <- base::inherits
[09:31:15.051]                       invokeRestart <- base::invokeRestart
[09:31:15.051]                       is.null <- base::is.null
[09:31:15.051]                       muffled <- FALSE
[09:31:15.051]                       if (inherits(cond, "message")) {
[09:31:15.051]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.051]                         if (muffled) 
[09:31:15.051]                           invokeRestart("muffleMessage")
[09:31:15.051]                       }
[09:31:15.051]                       else if (inherits(cond, "warning")) {
[09:31:15.051]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.051]                         if (muffled) 
[09:31:15.051]                           invokeRestart("muffleWarning")
[09:31:15.051]                       }
[09:31:15.051]                       else if (inherits(cond, "condition")) {
[09:31:15.051]                         if (!is.null(pattern)) {
[09:31:15.051]                           computeRestarts <- base::computeRestarts
[09:31:15.051]                           grepl <- base::grepl
[09:31:15.051]                           restarts <- computeRestarts(cond)
[09:31:15.051]                           for (restart in restarts) {
[09:31:15.051]                             name <- restart$name
[09:31:15.051]                             if (is.null(name)) 
[09:31:15.051]                               next
[09:31:15.051]                             if (!grepl(pattern, name)) 
[09:31:15.051]                               next
[09:31:15.051]                             invokeRestart(restart)
[09:31:15.051]                             muffled <- TRUE
[09:31:15.051]                             break
[09:31:15.051]                           }
[09:31:15.051]                         }
[09:31:15.051]                       }
[09:31:15.051]                       invisible(muffled)
[09:31:15.051]                     }
[09:31:15.051]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.051]                   }
[09:31:15.051]                 }
[09:31:15.051]                 else {
[09:31:15.051]                   if (TRUE) {
[09:31:15.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.051]                     {
[09:31:15.051]                       inherits <- base::inherits
[09:31:15.051]                       invokeRestart <- base::invokeRestart
[09:31:15.051]                       is.null <- base::is.null
[09:31:15.051]                       muffled <- FALSE
[09:31:15.051]                       if (inherits(cond, "message")) {
[09:31:15.051]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.051]                         if (muffled) 
[09:31:15.051]                           invokeRestart("muffleMessage")
[09:31:15.051]                       }
[09:31:15.051]                       else if (inherits(cond, "warning")) {
[09:31:15.051]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.051]                         if (muffled) 
[09:31:15.051]                           invokeRestart("muffleWarning")
[09:31:15.051]                       }
[09:31:15.051]                       else if (inherits(cond, "condition")) {
[09:31:15.051]                         if (!is.null(pattern)) {
[09:31:15.051]                           computeRestarts <- base::computeRestarts
[09:31:15.051]                           grepl <- base::grepl
[09:31:15.051]                           restarts <- computeRestarts(cond)
[09:31:15.051]                           for (restart in restarts) {
[09:31:15.051]                             name <- restart$name
[09:31:15.051]                             if (is.null(name)) 
[09:31:15.051]                               next
[09:31:15.051]                             if (!grepl(pattern, name)) 
[09:31:15.051]                               next
[09:31:15.051]                             invokeRestart(restart)
[09:31:15.051]                             muffled <- TRUE
[09:31:15.051]                             break
[09:31:15.051]                           }
[09:31:15.051]                         }
[09:31:15.051]                       }
[09:31:15.051]                       invisible(muffled)
[09:31:15.051]                     }
[09:31:15.051]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.051]                   }
[09:31:15.051]                 }
[09:31:15.051]             }
[09:31:15.051]         }))
[09:31:15.051]     }, error = function(ex) {
[09:31:15.051]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.051]                 ...future.rng), started = ...future.startTime, 
[09:31:15.051]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.051]             version = "1.8"), class = "FutureResult")
[09:31:15.051]     }, finally = {
[09:31:15.051]         if (!identical(...future.workdir, getwd())) 
[09:31:15.051]             setwd(...future.workdir)
[09:31:15.051]         {
[09:31:15.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.051]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.051]             }
[09:31:15.051]             base::options(...future.oldOptions)
[09:31:15.051]             if (.Platform$OS.type == "windows") {
[09:31:15.051]                 old_names <- names(...future.oldEnvVars)
[09:31:15.051]                 envs <- base::Sys.getenv()
[09:31:15.051]                 names <- names(envs)
[09:31:15.051]                 common <- intersect(names, old_names)
[09:31:15.051]                 added <- setdiff(names, old_names)
[09:31:15.051]                 removed <- setdiff(old_names, names)
[09:31:15.051]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.051]                   envs[common]]
[09:31:15.051]                 NAMES <- toupper(changed)
[09:31:15.051]                 args <- list()
[09:31:15.051]                 for (kk in seq_along(NAMES)) {
[09:31:15.051]                   name <- changed[[kk]]
[09:31:15.051]                   NAME <- NAMES[[kk]]
[09:31:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.051]                     next
[09:31:15.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.051]                 }
[09:31:15.051]                 NAMES <- toupper(added)
[09:31:15.051]                 for (kk in seq_along(NAMES)) {
[09:31:15.051]                   name <- added[[kk]]
[09:31:15.051]                   NAME <- NAMES[[kk]]
[09:31:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.051]                     next
[09:31:15.051]                   args[[name]] <- ""
[09:31:15.051]                 }
[09:31:15.051]                 NAMES <- toupper(removed)
[09:31:15.051]                 for (kk in seq_along(NAMES)) {
[09:31:15.051]                   name <- removed[[kk]]
[09:31:15.051]                   NAME <- NAMES[[kk]]
[09:31:15.051]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.051]                     next
[09:31:15.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.051]                 }
[09:31:15.051]                 if (length(args) > 0) 
[09:31:15.051]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.051]             }
[09:31:15.051]             else {
[09:31:15.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.051]             }
[09:31:15.051]             {
[09:31:15.051]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.051]                   0L) {
[09:31:15.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.051]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.051]                   base::options(opts)
[09:31:15.051]                 }
[09:31:15.051]                 {
[09:31:15.051]                   {
[09:31:15.051]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.051]                     NULL
[09:31:15.051]                   }
[09:31:15.051]                   options(future.plan = NULL)
[09:31:15.051]                   if (is.na(NA_character_)) 
[09:31:15.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.051]                     .init = FALSE)
[09:31:15.051]                 }
[09:31:15.051]             }
[09:31:15.051]         }
[09:31:15.051]     })
[09:31:15.051]     if (TRUE) {
[09:31:15.051]         base::sink(type = "output", split = FALSE)
[09:31:15.051]         if (TRUE) {
[09:31:15.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.051]         }
[09:31:15.051]         else {
[09:31:15.051]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.051]         }
[09:31:15.051]         base::close(...future.stdout)
[09:31:15.051]         ...future.stdout <- NULL
[09:31:15.051]     }
[09:31:15.051]     ...future.result$conditions <- ...future.conditions
[09:31:15.051]     ...future.result$finished <- base::Sys.time()
[09:31:15.051]     ...future.result
[09:31:15.051] }
[09:31:15.055] requestCore(): workers = 2
[09:31:15.055] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:15.066] result() for MulticoreFuture ...
[09:31:15.066] result() for MulticoreFuture ...
[09:31:15.067] result() for MulticoreFuture ... done
[09:31:15.067] result() for MulticoreFuture ... done
[09:31:15.067] result() for MulticoreFuture ...
[09:31:15.067] result() for MulticoreFuture ... done
[09:31:15.070] MulticoreFuture started
[09:31:15.070] - Launch lazy future ... done
[09:31:15.070] run() for ‘MulticoreFuture’ ... done
[09:31:15.071] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a3cbfc23e0> 
[09:31:15.071] List of future strategies:
[09:31:15.071] 1. sequential:
[09:31:15.071]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.071]    - tweaked: FALSE
[09:31:15.071]    - call: NULL
[09:31:15.073] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a3ccbbc628> 
[09:31:15.075] plan(): Setting new future strategy stack:
[09:31:15.075] List of future strategies:
[09:31:15.075] 1. multicore:
[09:31:15.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.075]    - tweaked: FALSE
[09:31:15.075]    - call: plan(strategy)
[09:31:15.081] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:15.083] resolve() on list environment ...
[09:31:15.084]  recursive: 0
[09:31:15.085]  length: 6
[09:31:15.085]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:15.085] signalConditionsASAP(numeric, pos=1) ...
[09:31:15.085] - nx: 6
[09:31:15.086] - relay: TRUE
[09:31:15.086] - stdout: TRUE
[09:31:15.086] - signal: TRUE
[09:31:15.086] - resignal: FALSE
[09:31:15.086] - force: TRUE
[09:31:15.086] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.086] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.086]  - until=2
[09:31:15.087]  - relaying element #2
[09:31:15.087] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.087] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.087] signalConditionsASAP(NULL, pos=1) ... done
[09:31:15.087]  length: 5 (resolved future 1)
[09:31:15.087] Future #2
[09:31:15.087] result() for MulticoreFuture ...
[09:31:15.088] result() for MulticoreFuture ... done
[09:31:15.088] result() for MulticoreFuture ...
[09:31:15.088] result() for MulticoreFuture ... done
[09:31:15.088] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:15.088] - nx: 6
[09:31:15.096] - relay: TRUE
[09:31:15.096] - stdout: TRUE
[09:31:15.097] - signal: TRUE
[09:31:15.097] - resignal: FALSE
[09:31:15.097] - force: TRUE
[09:31:15.098] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.098] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.099]  - until=2
[09:31:15.099]  - relaying element #2
[09:31:15.099] result() for MulticoreFuture ...
[09:31:15.099] result() for MulticoreFuture ... done
[09:31:15.099] result() for MulticoreFuture ...
[09:31:15.100] result() for MulticoreFuture ... done
[09:31:15.100] result() for MulticoreFuture ...
[09:31:15.100] result() for MulticoreFuture ... done
[09:31:15.100] result() for MulticoreFuture ...
[09:31:15.100] result() for MulticoreFuture ... done
[09:31:15.100] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.101] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:15.101]  length: 4 (resolved future 2)
[09:31:15.101] Future #3
[09:31:15.101] result() for MulticoreFuture ...
[09:31:15.102] result() for MulticoreFuture ...
[09:31:15.102] result() for MulticoreFuture ... done
[09:31:15.102] result() for MulticoreFuture ... done
[09:31:15.103] result() for MulticoreFuture ...
[09:31:15.103] result() for MulticoreFuture ... done
[09:31:15.103] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:15.103] - nx: 6
[09:31:15.103] - relay: TRUE
[09:31:15.103] - stdout: TRUE
[09:31:15.103] - signal: TRUE
[09:31:15.103] - resignal: FALSE
[09:31:15.104] - force: TRUE
[09:31:15.104] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.104] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.104]  - until=3
[09:31:15.104]  - relaying element #3
[09:31:15.104] result() for MulticoreFuture ...
[09:31:15.104] result() for MulticoreFuture ... done
[09:31:15.104] result() for MulticoreFuture ...
[09:31:15.105] result() for MulticoreFuture ... done
[09:31:15.105] result() for MulticoreFuture ...
[09:31:15.105] result() for MulticoreFuture ... done
[09:31:15.105] result() for MulticoreFuture ...
[09:31:15.105] result() for MulticoreFuture ... done
[09:31:15.105] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.105] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.106] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:15.106]  length: 3 (resolved future 3)
[09:31:15.106] Future #4
[09:31:15.106] result() for MulticoreFuture ...
[09:31:15.107] result() for MulticoreFuture ...
[09:31:15.107] result() for MulticoreFuture ... done
[09:31:15.107] result() for MulticoreFuture ... done
[09:31:15.107] result() for MulticoreFuture ...
[09:31:15.108] result() for MulticoreFuture ... done
[09:31:15.108] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:15.108] - nx: 6
[09:31:15.108] - relay: TRUE
[09:31:15.108] - stdout: TRUE
[09:31:15.108] - signal: TRUE
[09:31:15.109] - resignal: FALSE
[09:31:15.109] - force: TRUE
[09:31:15.109] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.109] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.109]  - until=4
[09:31:15.109]  - relaying element #4
[09:31:15.110] result() for MulticoreFuture ...
[09:31:15.110] result() for MulticoreFuture ... done
[09:31:15.110] result() for MulticoreFuture ...
[09:31:15.110] result() for MulticoreFuture ... done
[09:31:15.110] result() for MulticoreFuture ...
[09:31:15.110] result() for MulticoreFuture ... done
[09:31:15.110] result() for MulticoreFuture ...
[09:31:15.111] result() for MulticoreFuture ... done
[09:31:15.111] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.111] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.111] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:15.111]  length: 2 (resolved future 4)
[09:31:15.111] signalConditionsASAP(NULL, pos=5) ...
[09:31:15.111] - nx: 6
[09:31:15.112] - relay: TRUE
[09:31:15.112] - stdout: TRUE
[09:31:15.112] - signal: TRUE
[09:31:15.112] - resignal: FALSE
[09:31:15.112] - force: TRUE
[09:31:15.112] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.112] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.112]  - until=6
[09:31:15.112]  - relaying element #6
[09:31:15.112] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.113] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.113] signalConditionsASAP(NULL, pos=5) ... done
[09:31:15.113]  length: 1 (resolved future 5)
[09:31:15.113] signalConditionsASAP(numeric, pos=6) ...
[09:31:15.113] - nx: 6
[09:31:15.113] - relay: TRUE
[09:31:15.113] - stdout: TRUE
[09:31:15.113] - signal: TRUE
[09:31:15.113] - resignal: FALSE
[09:31:15.113] - force: TRUE
[09:31:15.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.114] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.114]  - until=6
[09:31:15.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.114] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.114] signalConditionsASAP(numeric, pos=6) ... done
[09:31:15.114]  length: 0 (resolved future 6)
[09:31:15.114] Relaying remaining futures
[09:31:15.114] signalConditionsASAP(NULL, pos=0) ...
[09:31:15.114] - nx: 6
[09:31:15.114] - relay: TRUE
[09:31:15.115] - stdout: TRUE
[09:31:15.115] - signal: TRUE
[09:31:15.115] - resignal: FALSE
[09:31:15.115] - force: TRUE
[09:31:15.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.115] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:15.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.115] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.115] signalConditionsASAP(NULL, pos=0) ... done
[09:31:15.115] resolve() on list environment ... DONE
[09:31:15.116] result() for MulticoreFuture ...
[09:31:15.116] result() for MulticoreFuture ... done
[09:31:15.116] result() for MulticoreFuture ...
[09:31:15.116] result() for MulticoreFuture ... done
[09:31:15.116] result() for MulticoreFuture ...
[09:31:15.116] result() for MulticoreFuture ... done
[09:31:15.116] result() for MulticoreFuture ...
[09:31:15.116] result() for MulticoreFuture ... done
[09:31:15.117] result() for MulticoreFuture ...
[09:31:15.117] result() for MulticoreFuture ... done
[09:31:15.117] result() for MulticoreFuture ...
[09:31:15.117] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3ccd0f498> 
Dimensions: c(1, 6)
[09:31:15.118] getGlobalsAndPackages() ...
[09:31:15.118] Searching for globals...
[09:31:15.118] 
[09:31:15.118] Searching for globals ... DONE
[09:31:15.118] - globals: [0] <none>
[09:31:15.119] getGlobalsAndPackages() ... DONE
[09:31:15.119] run() for ‘Future’ ...
[09:31:15.119] - state: ‘created’
[09:31:15.119] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.123]   - Field: ‘label’
[09:31:15.123]   - Field: ‘local’
[09:31:15.123]   - Field: ‘owner’
[09:31:15.124]   - Field: ‘envir’
[09:31:15.124]   - Field: ‘workers’
[09:31:15.124]   - Field: ‘packages’
[09:31:15.124]   - Field: ‘gc’
[09:31:15.124]   - Field: ‘job’
[09:31:15.124]   - Field: ‘conditions’
[09:31:15.124]   - Field: ‘expr’
[09:31:15.124]   - Field: ‘uuid’
[09:31:15.124]   - Field: ‘seed’
[09:31:15.125]   - Field: ‘version’
[09:31:15.125]   - Field: ‘result’
[09:31:15.125]   - Field: ‘asynchronous’
[09:31:15.125]   - Field: ‘calls’
[09:31:15.125]   - Field: ‘globals’
[09:31:15.125]   - Field: ‘stdout’
[09:31:15.125]   - Field: ‘earlySignal’
[09:31:15.125]   - Field: ‘lazy’
[09:31:15.125]   - Field: ‘state’
[09:31:15.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.126] - Launch lazy future ...
[09:31:15.126] Packages needed by the future expression (n = 0): <none>
[09:31:15.126] Packages needed by future strategies (n = 0): <none>
[09:31:15.127] {
[09:31:15.127]     {
[09:31:15.127]         {
[09:31:15.127]             ...future.startTime <- base::Sys.time()
[09:31:15.127]             {
[09:31:15.127]                 {
[09:31:15.127]                   {
[09:31:15.127]                     {
[09:31:15.127]                       base::local({
[09:31:15.127]                         has_future <- base::requireNamespace("future", 
[09:31:15.127]                           quietly = TRUE)
[09:31:15.127]                         if (has_future) {
[09:31:15.127]                           ns <- base::getNamespace("future")
[09:31:15.127]                           version <- ns[[".package"]][["version"]]
[09:31:15.127]                           if (is.null(version)) 
[09:31:15.127]                             version <- utils::packageVersion("future")
[09:31:15.127]                         }
[09:31:15.127]                         else {
[09:31:15.127]                           version <- NULL
[09:31:15.127]                         }
[09:31:15.127]                         if (!has_future || version < "1.8.0") {
[09:31:15.127]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.127]                             "", base::R.version$version.string), 
[09:31:15.127]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.127]                               "release", "version")], collapse = " "), 
[09:31:15.127]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.127]                             info)
[09:31:15.127]                           info <- base::paste(info, collapse = "; ")
[09:31:15.127]                           if (!has_future) {
[09:31:15.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.127]                               info)
[09:31:15.127]                           }
[09:31:15.127]                           else {
[09:31:15.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.127]                               info, version)
[09:31:15.127]                           }
[09:31:15.127]                           base::stop(msg)
[09:31:15.127]                         }
[09:31:15.127]                       })
[09:31:15.127]                     }
[09:31:15.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.127]                     base::options(mc.cores = 1L)
[09:31:15.127]                   }
[09:31:15.127]                   ...future.strategy.old <- future::plan("list")
[09:31:15.127]                   options(future.plan = NULL)
[09:31:15.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.127]                 }
[09:31:15.127]                 ...future.workdir <- getwd()
[09:31:15.127]             }
[09:31:15.127]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.127]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.127]         }
[09:31:15.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.127]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.127]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.127]             base::names(...future.oldOptions))
[09:31:15.127]     }
[09:31:15.127]     if (FALSE) {
[09:31:15.127]     }
[09:31:15.127]     else {
[09:31:15.127]         if (TRUE) {
[09:31:15.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.127]                 open = "w")
[09:31:15.127]         }
[09:31:15.127]         else {
[09:31:15.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.127]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.127]         }
[09:31:15.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.127]             base::sink(type = "output", split = FALSE)
[09:31:15.127]             base::close(...future.stdout)
[09:31:15.127]         }, add = TRUE)
[09:31:15.127]     }
[09:31:15.127]     ...future.frame <- base::sys.nframe()
[09:31:15.127]     ...future.conditions <- base::list()
[09:31:15.127]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.127]     if (FALSE) {
[09:31:15.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.127]     }
[09:31:15.127]     ...future.result <- base::tryCatch({
[09:31:15.127]         base::withCallingHandlers({
[09:31:15.127]             ...future.value <- base::withVisible(base::local({
[09:31:15.127]                 withCallingHandlers({
[09:31:15.127]                   2
[09:31:15.127]                 }, immediateCondition = function(cond) {
[09:31:15.127]                   save_rds <- function (object, pathname, ...) 
[09:31:15.127]                   {
[09:31:15.127]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.127]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.127]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.127]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.127]                         fi_tmp[["mtime"]])
[09:31:15.127]                     }
[09:31:15.127]                     tryCatch({
[09:31:15.127]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.127]                     }, error = function(ex) {
[09:31:15.127]                       msg <- conditionMessage(ex)
[09:31:15.127]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.127]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.127]                         fi_tmp[["mtime"]], msg)
[09:31:15.127]                       ex$message <- msg
[09:31:15.127]                       stop(ex)
[09:31:15.127]                     })
[09:31:15.127]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.127]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.127]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.127]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.127]                       fi <- file.info(pathname)
[09:31:15.127]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.127]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.127]                         fi[["size"]], fi[["mtime"]])
[09:31:15.127]                       stop(msg)
[09:31:15.127]                     }
[09:31:15.127]                     invisible(pathname)
[09:31:15.127]                   }
[09:31:15.127]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.127]                     rootPath = tempdir()) 
[09:31:15.127]                   {
[09:31:15.127]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.127]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.127]                       tmpdir = path, fileext = ".rds")
[09:31:15.127]                     save_rds(obj, file)
[09:31:15.127]                   }
[09:31:15.127]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.127]                   {
[09:31:15.127]                     inherits <- base::inherits
[09:31:15.127]                     invokeRestart <- base::invokeRestart
[09:31:15.127]                     is.null <- base::is.null
[09:31:15.127]                     muffled <- FALSE
[09:31:15.127]                     if (inherits(cond, "message")) {
[09:31:15.127]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.127]                       if (muffled) 
[09:31:15.127]                         invokeRestart("muffleMessage")
[09:31:15.127]                     }
[09:31:15.127]                     else if (inherits(cond, "warning")) {
[09:31:15.127]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.127]                       if (muffled) 
[09:31:15.127]                         invokeRestart("muffleWarning")
[09:31:15.127]                     }
[09:31:15.127]                     else if (inherits(cond, "condition")) {
[09:31:15.127]                       if (!is.null(pattern)) {
[09:31:15.127]                         computeRestarts <- base::computeRestarts
[09:31:15.127]                         grepl <- base::grepl
[09:31:15.127]                         restarts <- computeRestarts(cond)
[09:31:15.127]                         for (restart in restarts) {
[09:31:15.127]                           name <- restart$name
[09:31:15.127]                           if (is.null(name)) 
[09:31:15.127]                             next
[09:31:15.127]                           if (!grepl(pattern, name)) 
[09:31:15.127]                             next
[09:31:15.127]                           invokeRestart(restart)
[09:31:15.127]                           muffled <- TRUE
[09:31:15.127]                           break
[09:31:15.127]                         }
[09:31:15.127]                       }
[09:31:15.127]                     }
[09:31:15.127]                     invisible(muffled)
[09:31:15.127]                   }
[09:31:15.127]                   muffleCondition(cond)
[09:31:15.127]                 })
[09:31:15.127]             }))
[09:31:15.127]             future::FutureResult(value = ...future.value$value, 
[09:31:15.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.127]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.127]                     ...future.globalenv.names))
[09:31:15.127]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.127]         }, condition = base::local({
[09:31:15.127]             c <- base::c
[09:31:15.127]             inherits <- base::inherits
[09:31:15.127]             invokeRestart <- base::invokeRestart
[09:31:15.127]             length <- base::length
[09:31:15.127]             list <- base::list
[09:31:15.127]             seq.int <- base::seq.int
[09:31:15.127]             signalCondition <- base::signalCondition
[09:31:15.127]             sys.calls <- base::sys.calls
[09:31:15.127]             `[[` <- base::`[[`
[09:31:15.127]             `+` <- base::`+`
[09:31:15.127]             `<<-` <- base::`<<-`
[09:31:15.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.127]                   3L)]
[09:31:15.127]             }
[09:31:15.127]             function(cond) {
[09:31:15.127]                 is_error <- inherits(cond, "error")
[09:31:15.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.127]                   NULL)
[09:31:15.127]                 if (is_error) {
[09:31:15.127]                   sessionInformation <- function() {
[09:31:15.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.127]                       search = base::search(), system = base::Sys.info())
[09:31:15.127]                   }
[09:31:15.127]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.127]                     cond$call), session = sessionInformation(), 
[09:31:15.127]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.127]                   signalCondition(cond)
[09:31:15.127]                 }
[09:31:15.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.127]                 "immediateCondition"))) {
[09:31:15.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.127]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.127]                   if (TRUE && !signal) {
[09:31:15.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.127]                     {
[09:31:15.127]                       inherits <- base::inherits
[09:31:15.127]                       invokeRestart <- base::invokeRestart
[09:31:15.127]                       is.null <- base::is.null
[09:31:15.127]                       muffled <- FALSE
[09:31:15.127]                       if (inherits(cond, "message")) {
[09:31:15.127]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.127]                         if (muffled) 
[09:31:15.127]                           invokeRestart("muffleMessage")
[09:31:15.127]                       }
[09:31:15.127]                       else if (inherits(cond, "warning")) {
[09:31:15.127]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.127]                         if (muffled) 
[09:31:15.127]                           invokeRestart("muffleWarning")
[09:31:15.127]                       }
[09:31:15.127]                       else if (inherits(cond, "condition")) {
[09:31:15.127]                         if (!is.null(pattern)) {
[09:31:15.127]                           computeRestarts <- base::computeRestarts
[09:31:15.127]                           grepl <- base::grepl
[09:31:15.127]                           restarts <- computeRestarts(cond)
[09:31:15.127]                           for (restart in restarts) {
[09:31:15.127]                             name <- restart$name
[09:31:15.127]                             if (is.null(name)) 
[09:31:15.127]                               next
[09:31:15.127]                             if (!grepl(pattern, name)) 
[09:31:15.127]                               next
[09:31:15.127]                             invokeRestart(restart)
[09:31:15.127]                             muffled <- TRUE
[09:31:15.127]                             break
[09:31:15.127]                           }
[09:31:15.127]                         }
[09:31:15.127]                       }
[09:31:15.127]                       invisible(muffled)
[09:31:15.127]                     }
[09:31:15.127]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.127]                   }
[09:31:15.127]                 }
[09:31:15.127]                 else {
[09:31:15.127]                   if (TRUE) {
[09:31:15.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.127]                     {
[09:31:15.127]                       inherits <- base::inherits
[09:31:15.127]                       invokeRestart <- base::invokeRestart
[09:31:15.127]                       is.null <- base::is.null
[09:31:15.127]                       muffled <- FALSE
[09:31:15.127]                       if (inherits(cond, "message")) {
[09:31:15.127]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.127]                         if (muffled) 
[09:31:15.127]                           invokeRestart("muffleMessage")
[09:31:15.127]                       }
[09:31:15.127]                       else if (inherits(cond, "warning")) {
[09:31:15.127]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.127]                         if (muffled) 
[09:31:15.127]                           invokeRestart("muffleWarning")
[09:31:15.127]                       }
[09:31:15.127]                       else if (inherits(cond, "condition")) {
[09:31:15.127]                         if (!is.null(pattern)) {
[09:31:15.127]                           computeRestarts <- base::computeRestarts
[09:31:15.127]                           grepl <- base::grepl
[09:31:15.127]                           restarts <- computeRestarts(cond)
[09:31:15.127]                           for (restart in restarts) {
[09:31:15.127]                             name <- restart$name
[09:31:15.127]                             if (is.null(name)) 
[09:31:15.127]                               next
[09:31:15.127]                             if (!grepl(pattern, name)) 
[09:31:15.127]                               next
[09:31:15.127]                             invokeRestart(restart)
[09:31:15.127]                             muffled <- TRUE
[09:31:15.127]                             break
[09:31:15.127]                           }
[09:31:15.127]                         }
[09:31:15.127]                       }
[09:31:15.127]                       invisible(muffled)
[09:31:15.127]                     }
[09:31:15.127]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.127]                   }
[09:31:15.127]                 }
[09:31:15.127]             }
[09:31:15.127]         }))
[09:31:15.127]     }, error = function(ex) {
[09:31:15.127]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.127]                 ...future.rng), started = ...future.startTime, 
[09:31:15.127]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.127]             version = "1.8"), class = "FutureResult")
[09:31:15.127]     }, finally = {
[09:31:15.127]         if (!identical(...future.workdir, getwd())) 
[09:31:15.127]             setwd(...future.workdir)
[09:31:15.127]         {
[09:31:15.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.127]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.127]             }
[09:31:15.127]             base::options(...future.oldOptions)
[09:31:15.127]             if (.Platform$OS.type == "windows") {
[09:31:15.127]                 old_names <- names(...future.oldEnvVars)
[09:31:15.127]                 envs <- base::Sys.getenv()
[09:31:15.127]                 names <- names(envs)
[09:31:15.127]                 common <- intersect(names, old_names)
[09:31:15.127]                 added <- setdiff(names, old_names)
[09:31:15.127]                 removed <- setdiff(old_names, names)
[09:31:15.127]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.127]                   envs[common]]
[09:31:15.127]                 NAMES <- toupper(changed)
[09:31:15.127]                 args <- list()
[09:31:15.127]                 for (kk in seq_along(NAMES)) {
[09:31:15.127]                   name <- changed[[kk]]
[09:31:15.127]                   NAME <- NAMES[[kk]]
[09:31:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.127]                     next
[09:31:15.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.127]                 }
[09:31:15.127]                 NAMES <- toupper(added)
[09:31:15.127]                 for (kk in seq_along(NAMES)) {
[09:31:15.127]                   name <- added[[kk]]
[09:31:15.127]                   NAME <- NAMES[[kk]]
[09:31:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.127]                     next
[09:31:15.127]                   args[[name]] <- ""
[09:31:15.127]                 }
[09:31:15.127]                 NAMES <- toupper(removed)
[09:31:15.127]                 for (kk in seq_along(NAMES)) {
[09:31:15.127]                   name <- removed[[kk]]
[09:31:15.127]                   NAME <- NAMES[[kk]]
[09:31:15.127]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.127]                     next
[09:31:15.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.127]                 }
[09:31:15.127]                 if (length(args) > 0) 
[09:31:15.127]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.127]             }
[09:31:15.127]             else {
[09:31:15.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.127]             }
[09:31:15.127]             {
[09:31:15.127]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.127]                   0L) {
[09:31:15.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.127]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.127]                   base::options(opts)
[09:31:15.127]                 }
[09:31:15.127]                 {
[09:31:15.127]                   {
[09:31:15.127]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.127]                     NULL
[09:31:15.127]                   }
[09:31:15.127]                   options(future.plan = NULL)
[09:31:15.127]                   if (is.na(NA_character_)) 
[09:31:15.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.127]                     .init = FALSE)
[09:31:15.127]                 }
[09:31:15.127]             }
[09:31:15.127]         }
[09:31:15.127]     })
[09:31:15.127]     if (TRUE) {
[09:31:15.127]         base::sink(type = "output", split = FALSE)
[09:31:15.127]         if (TRUE) {
[09:31:15.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.127]         }
[09:31:15.127]         else {
[09:31:15.127]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.127]         }
[09:31:15.127]         base::close(...future.stdout)
[09:31:15.127]         ...future.stdout <- NULL
[09:31:15.127]     }
[09:31:15.127]     ...future.result$conditions <- ...future.conditions
[09:31:15.127]     ...future.result$finished <- base::Sys.time()
[09:31:15.127]     ...future.result
[09:31:15.127] }
[09:31:15.129] requestCore(): workers = 2
[09:31:15.131] MulticoreFuture started
[09:31:15.131] - Launch lazy future ... done
[09:31:15.132] run() for ‘MulticoreFuture’ ... done
[09:31:15.132] getGlobalsAndPackages() ...
[09:31:15.132] plan(): Setting new future strategy stack:
[09:31:15.132] Searching for globals...
[09:31:15.132] List of future strategies:
[09:31:15.132] 1. sequential:
[09:31:15.132]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.132]    - tweaked: FALSE
[09:31:15.132]    - call: NULL
[09:31:15.133] 
[09:31:15.133] Searching for globals ... DONE
[09:31:15.133] plan(): nbrOfWorkers() = 1
[09:31:15.133] - globals: [0] <none>
[09:31:15.134] getGlobalsAndPackages() ... DONE
[09:31:15.134] run() for ‘Future’ ...
[09:31:15.134] - state: ‘created’
[09:31:15.135] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.135] plan(): Setting new future strategy stack:
[09:31:15.135] List of future strategies:
[09:31:15.135] 1. multicore:
[09:31:15.135]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.135]    - tweaked: FALSE
[09:31:15.135]    - call: plan(strategy)
[09:31:15.140] plan(): nbrOfWorkers() = 2
[09:31:15.140] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.140]   - Field: ‘label’
[09:31:15.141]   - Field: ‘local’
[09:31:15.141]   - Field: ‘owner’
[09:31:15.141]   - Field: ‘envir’
[09:31:15.141]   - Field: ‘workers’
[09:31:15.141]   - Field: ‘packages’
[09:31:15.141]   - Field: ‘gc’
[09:31:15.142]   - Field: ‘job’
[09:31:15.142]   - Field: ‘conditions’
[09:31:15.142]   - Field: ‘expr’
[09:31:15.142]   - Field: ‘uuid’
[09:31:15.142]   - Field: ‘seed’
[09:31:15.143]   - Field: ‘version’
[09:31:15.143]   - Field: ‘result’
[09:31:15.143]   - Field: ‘asynchronous’
[09:31:15.143]   - Field: ‘calls’
[09:31:15.143]   - Field: ‘globals’
[09:31:15.143]   - Field: ‘stdout’
[09:31:15.143]   - Field: ‘earlySignal’
[09:31:15.144]   - Field: ‘lazy’
[09:31:15.144]   - Field: ‘state’
[09:31:15.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.144] - Launch lazy future ...
[09:31:15.145] Packages needed by the future expression (n = 0): <none>
[09:31:15.145] Packages needed by future strategies (n = 0): <none>
[09:31:15.146] {
[09:31:15.146]     {
[09:31:15.146]         {
[09:31:15.146]             ...future.startTime <- base::Sys.time()
[09:31:15.146]             {
[09:31:15.146]                 {
[09:31:15.146]                   {
[09:31:15.146]                     {
[09:31:15.146]                       base::local({
[09:31:15.146]                         has_future <- base::requireNamespace("future", 
[09:31:15.146]                           quietly = TRUE)
[09:31:15.146]                         if (has_future) {
[09:31:15.146]                           ns <- base::getNamespace("future")
[09:31:15.146]                           version <- ns[[".package"]][["version"]]
[09:31:15.146]                           if (is.null(version)) 
[09:31:15.146]                             version <- utils::packageVersion("future")
[09:31:15.146]                         }
[09:31:15.146]                         else {
[09:31:15.146]                           version <- NULL
[09:31:15.146]                         }
[09:31:15.146]                         if (!has_future || version < "1.8.0") {
[09:31:15.146]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.146]                             "", base::R.version$version.string), 
[09:31:15.146]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.146]                               "release", "version")], collapse = " "), 
[09:31:15.146]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.146]                             info)
[09:31:15.146]                           info <- base::paste(info, collapse = "; ")
[09:31:15.146]                           if (!has_future) {
[09:31:15.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.146]                               info)
[09:31:15.146]                           }
[09:31:15.146]                           else {
[09:31:15.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.146]                               info, version)
[09:31:15.146]                           }
[09:31:15.146]                           base::stop(msg)
[09:31:15.146]                         }
[09:31:15.146]                       })
[09:31:15.146]                     }
[09:31:15.146]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.146]                     base::options(mc.cores = 1L)
[09:31:15.146]                   }
[09:31:15.146]                   ...future.strategy.old <- future::plan("list")
[09:31:15.146]                   options(future.plan = NULL)
[09:31:15.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.146]                 }
[09:31:15.146]                 ...future.workdir <- getwd()
[09:31:15.146]             }
[09:31:15.146]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.146]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.146]         }
[09:31:15.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.146]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.146]             base::names(...future.oldOptions))
[09:31:15.146]     }
[09:31:15.146]     if (FALSE) {
[09:31:15.146]     }
[09:31:15.146]     else {
[09:31:15.146]         if (TRUE) {
[09:31:15.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.146]                 open = "w")
[09:31:15.146]         }
[09:31:15.146]         else {
[09:31:15.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.146]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.146]         }
[09:31:15.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.146]             base::sink(type = "output", split = FALSE)
[09:31:15.146]             base::close(...future.stdout)
[09:31:15.146]         }, add = TRUE)
[09:31:15.146]     }
[09:31:15.146]     ...future.frame <- base::sys.nframe()
[09:31:15.146]     ...future.conditions <- base::list()
[09:31:15.146]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.146]     if (FALSE) {
[09:31:15.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.146]     }
[09:31:15.146]     ...future.result <- base::tryCatch({
[09:31:15.146]         base::withCallingHandlers({
[09:31:15.146]             ...future.value <- base::withVisible(base::local({
[09:31:15.146]                 withCallingHandlers({
[09:31:15.146]                   NULL
[09:31:15.146]                 }, immediateCondition = function(cond) {
[09:31:15.146]                   save_rds <- function (object, pathname, ...) 
[09:31:15.146]                   {
[09:31:15.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.146]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.146]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.146]                         fi_tmp[["mtime"]])
[09:31:15.146]                     }
[09:31:15.146]                     tryCatch({
[09:31:15.146]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.146]                     }, error = function(ex) {
[09:31:15.146]                       msg <- conditionMessage(ex)
[09:31:15.146]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.146]                         fi_tmp[["mtime"]], msg)
[09:31:15.146]                       ex$message <- msg
[09:31:15.146]                       stop(ex)
[09:31:15.146]                     })
[09:31:15.146]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.146]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.146]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.146]                       fi <- file.info(pathname)
[09:31:15.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.146]                         fi[["size"]], fi[["mtime"]])
[09:31:15.146]                       stop(msg)
[09:31:15.146]                     }
[09:31:15.146]                     invisible(pathname)
[09:31:15.146]                   }
[09:31:15.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.146]                     rootPath = tempdir()) 
[09:31:15.146]                   {
[09:31:15.146]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.146]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.146]                       tmpdir = path, fileext = ".rds")
[09:31:15.146]                     save_rds(obj, file)
[09:31:15.146]                   }
[09:31:15.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.146]                   {
[09:31:15.146]                     inherits <- base::inherits
[09:31:15.146]                     invokeRestart <- base::invokeRestart
[09:31:15.146]                     is.null <- base::is.null
[09:31:15.146]                     muffled <- FALSE
[09:31:15.146]                     if (inherits(cond, "message")) {
[09:31:15.146]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.146]                       if (muffled) 
[09:31:15.146]                         invokeRestart("muffleMessage")
[09:31:15.146]                     }
[09:31:15.146]                     else if (inherits(cond, "warning")) {
[09:31:15.146]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.146]                       if (muffled) 
[09:31:15.146]                         invokeRestart("muffleWarning")
[09:31:15.146]                     }
[09:31:15.146]                     else if (inherits(cond, "condition")) {
[09:31:15.146]                       if (!is.null(pattern)) {
[09:31:15.146]                         computeRestarts <- base::computeRestarts
[09:31:15.146]                         grepl <- base::grepl
[09:31:15.146]                         restarts <- computeRestarts(cond)
[09:31:15.146]                         for (restart in restarts) {
[09:31:15.146]                           name <- restart$name
[09:31:15.146]                           if (is.null(name)) 
[09:31:15.146]                             next
[09:31:15.146]                           if (!grepl(pattern, name)) 
[09:31:15.146]                             next
[09:31:15.146]                           invokeRestart(restart)
[09:31:15.146]                           muffled <- TRUE
[09:31:15.146]                           break
[09:31:15.146]                         }
[09:31:15.146]                       }
[09:31:15.146]                     }
[09:31:15.146]                     invisible(muffled)
[09:31:15.146]                   }
[09:31:15.146]                   muffleCondition(cond)
[09:31:15.146]                 })
[09:31:15.146]             }))
[09:31:15.146]             future::FutureResult(value = ...future.value$value, 
[09:31:15.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.146]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.146]                     ...future.globalenv.names))
[09:31:15.146]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.146]         }, condition = base::local({
[09:31:15.146]             c <- base::c
[09:31:15.146]             inherits <- base::inherits
[09:31:15.146]             invokeRestart <- base::invokeRestart
[09:31:15.146]             length <- base::length
[09:31:15.146]             list <- base::list
[09:31:15.146]             seq.int <- base::seq.int
[09:31:15.146]             signalCondition <- base::signalCondition
[09:31:15.146]             sys.calls <- base::sys.calls
[09:31:15.146]             `[[` <- base::`[[`
[09:31:15.146]             `+` <- base::`+`
[09:31:15.146]             `<<-` <- base::`<<-`
[09:31:15.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.146]                   3L)]
[09:31:15.146]             }
[09:31:15.146]             function(cond) {
[09:31:15.146]                 is_error <- inherits(cond, "error")
[09:31:15.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.146]                   NULL)
[09:31:15.146]                 if (is_error) {
[09:31:15.146]                   sessionInformation <- function() {
[09:31:15.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.146]                       search = base::search(), system = base::Sys.info())
[09:31:15.146]                   }
[09:31:15.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.146]                     cond$call), session = sessionInformation(), 
[09:31:15.146]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.146]                   signalCondition(cond)
[09:31:15.146]                 }
[09:31:15.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.146]                 "immediateCondition"))) {
[09:31:15.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.146]                   if (TRUE && !signal) {
[09:31:15.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.146]                     {
[09:31:15.146]                       inherits <- base::inherits
[09:31:15.146]                       invokeRestart <- base::invokeRestart
[09:31:15.146]                       is.null <- base::is.null
[09:31:15.146]                       muffled <- FALSE
[09:31:15.146]                       if (inherits(cond, "message")) {
[09:31:15.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.146]                         if (muffled) 
[09:31:15.146]                           invokeRestart("muffleMessage")
[09:31:15.146]                       }
[09:31:15.146]                       else if (inherits(cond, "warning")) {
[09:31:15.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.146]                         if (muffled) 
[09:31:15.146]                           invokeRestart("muffleWarning")
[09:31:15.146]                       }
[09:31:15.146]                       else if (inherits(cond, "condition")) {
[09:31:15.146]                         if (!is.null(pattern)) {
[09:31:15.146]                           computeRestarts <- base::computeRestarts
[09:31:15.146]                           grepl <- base::grepl
[09:31:15.146]                           restarts <- computeRestarts(cond)
[09:31:15.146]                           for (restart in restarts) {
[09:31:15.146]                             name <- restart$name
[09:31:15.146]                             if (is.null(name)) 
[09:31:15.146]                               next
[09:31:15.146]                             if (!grepl(pattern, name)) 
[09:31:15.146]                               next
[09:31:15.146]                             invokeRestart(restart)
[09:31:15.146]                             muffled <- TRUE
[09:31:15.146]                             break
[09:31:15.146]                           }
[09:31:15.146]                         }
[09:31:15.146]                       }
[09:31:15.146]                       invisible(muffled)
[09:31:15.146]                     }
[09:31:15.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.146]                   }
[09:31:15.146]                 }
[09:31:15.146]                 else {
[09:31:15.146]                   if (TRUE) {
[09:31:15.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.146]                     {
[09:31:15.146]                       inherits <- base::inherits
[09:31:15.146]                       invokeRestart <- base::invokeRestart
[09:31:15.146]                       is.null <- base::is.null
[09:31:15.146]                       muffled <- FALSE
[09:31:15.146]                       if (inherits(cond, "message")) {
[09:31:15.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.146]                         if (muffled) 
[09:31:15.146]                           invokeRestart("muffleMessage")
[09:31:15.146]                       }
[09:31:15.146]                       else if (inherits(cond, "warning")) {
[09:31:15.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.146]                         if (muffled) 
[09:31:15.146]                           invokeRestart("muffleWarning")
[09:31:15.146]                       }
[09:31:15.146]                       else if (inherits(cond, "condition")) {
[09:31:15.146]                         if (!is.null(pattern)) {
[09:31:15.146]                           computeRestarts <- base::computeRestarts
[09:31:15.146]                           grepl <- base::grepl
[09:31:15.146]                           restarts <- computeRestarts(cond)
[09:31:15.146]                           for (restart in restarts) {
[09:31:15.146]                             name <- restart$name
[09:31:15.146]                             if (is.null(name)) 
[09:31:15.146]                               next
[09:31:15.146]                             if (!grepl(pattern, name)) 
[09:31:15.146]                               next
[09:31:15.146]                             invokeRestart(restart)
[09:31:15.146]                             muffled <- TRUE
[09:31:15.146]                             break
[09:31:15.146]                           }
[09:31:15.146]                         }
[09:31:15.146]                       }
[09:31:15.146]                       invisible(muffled)
[09:31:15.146]                     }
[09:31:15.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.146]                   }
[09:31:15.146]                 }
[09:31:15.146]             }
[09:31:15.146]         }))
[09:31:15.146]     }, error = function(ex) {
[09:31:15.146]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.146]                 ...future.rng), started = ...future.startTime, 
[09:31:15.146]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.146]             version = "1.8"), class = "FutureResult")
[09:31:15.146]     }, finally = {
[09:31:15.146]         if (!identical(...future.workdir, getwd())) 
[09:31:15.146]             setwd(...future.workdir)
[09:31:15.146]         {
[09:31:15.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.146]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.146]             }
[09:31:15.146]             base::options(...future.oldOptions)
[09:31:15.146]             if (.Platform$OS.type == "windows") {
[09:31:15.146]                 old_names <- names(...future.oldEnvVars)
[09:31:15.146]                 envs <- base::Sys.getenv()
[09:31:15.146]                 names <- names(envs)
[09:31:15.146]                 common <- intersect(names, old_names)
[09:31:15.146]                 added <- setdiff(names, old_names)
[09:31:15.146]                 removed <- setdiff(old_names, names)
[09:31:15.146]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.146]                   envs[common]]
[09:31:15.146]                 NAMES <- toupper(changed)
[09:31:15.146]                 args <- list()
[09:31:15.146]                 for (kk in seq_along(NAMES)) {
[09:31:15.146]                   name <- changed[[kk]]
[09:31:15.146]                   NAME <- NAMES[[kk]]
[09:31:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.146]                     next
[09:31:15.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.146]                 }
[09:31:15.146]                 NAMES <- toupper(added)
[09:31:15.146]                 for (kk in seq_along(NAMES)) {
[09:31:15.146]                   name <- added[[kk]]
[09:31:15.146]                   NAME <- NAMES[[kk]]
[09:31:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.146]                     next
[09:31:15.146]                   args[[name]] <- ""
[09:31:15.146]                 }
[09:31:15.146]                 NAMES <- toupper(removed)
[09:31:15.146]                 for (kk in seq_along(NAMES)) {
[09:31:15.146]                   name <- removed[[kk]]
[09:31:15.146]                   NAME <- NAMES[[kk]]
[09:31:15.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.146]                     next
[09:31:15.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.146]                 }
[09:31:15.146]                 if (length(args) > 0) 
[09:31:15.146]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.146]             }
[09:31:15.146]             else {
[09:31:15.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.146]             }
[09:31:15.146]             {
[09:31:15.146]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.146]                   0L) {
[09:31:15.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.146]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.146]                   base::options(opts)
[09:31:15.146]                 }
[09:31:15.146]                 {
[09:31:15.146]                   {
[09:31:15.146]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.146]                     NULL
[09:31:15.146]                   }
[09:31:15.146]                   options(future.plan = NULL)
[09:31:15.146]                   if (is.na(NA_character_)) 
[09:31:15.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.146]                     .init = FALSE)
[09:31:15.146]                 }
[09:31:15.146]             }
[09:31:15.146]         }
[09:31:15.146]     })
[09:31:15.146]     if (TRUE) {
[09:31:15.146]         base::sink(type = "output", split = FALSE)
[09:31:15.146]         if (TRUE) {
[09:31:15.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.146]         }
[09:31:15.146]         else {
[09:31:15.146]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.146]         }
[09:31:15.146]         base::close(...future.stdout)
[09:31:15.146]         ...future.stdout <- NULL
[09:31:15.146]     }
[09:31:15.146]     ...future.result$conditions <- ...future.conditions
[09:31:15.146]     ...future.result$finished <- base::Sys.time()
[09:31:15.146]     ...future.result
[09:31:15.146] }
[09:31:15.149] requestCore(): workers = 2
[09:31:15.152] MulticoreFuture started
[09:31:15.152] - Launch lazy future ... done
[09:31:15.152] run() for ‘MulticoreFuture’ ... done
[09:31:15.153] plan(): Setting new future strategy stack:
[09:31:15.153] getGlobalsAndPackages() ...
[09:31:15.154] Searching for globals...
[09:31:15.153] List of future strategies:
[09:31:15.153] 1. sequential:
[09:31:15.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.153]    - tweaked: FALSE
[09:31:15.153]    - call: NULL
[09:31:15.154] plan(): nbrOfWorkers() = 1
[09:31:15.155] - globals found: [1] ‘{’
[09:31:15.155] Searching for globals ... DONE
[09:31:15.155] Resolving globals: FALSE
[09:31:15.156] 
[09:31:15.156] 
[09:31:15.156] getGlobalsAndPackages() ... DONE
[09:31:15.156] plan(): Setting new future strategy stack:
[09:31:15.157] run() for ‘Future’ ...
[09:31:15.157] - state: ‘created’
[09:31:15.157] List of future strategies:
[09:31:15.157] 1. multicore:
[09:31:15.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.157]    - tweaked: FALSE
[09:31:15.157]    - call: plan(strategy)
[09:31:15.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.161] plan(): nbrOfWorkers() = 2
[09:31:15.162] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.162]   - Field: ‘label’
[09:31:15.162]   - Field: ‘local’
[09:31:15.162]   - Field: ‘owner’
[09:31:15.162]   - Field: ‘envir’
[09:31:15.163]   - Field: ‘workers’
[09:31:15.163]   - Field: ‘packages’
[09:31:15.163]   - Field: ‘gc’
[09:31:15.163]   - Field: ‘job’
[09:31:15.163]   - Field: ‘conditions’
[09:31:15.163]   - Field: ‘expr’
[09:31:15.163]   - Field: ‘uuid’
[09:31:15.164]   - Field: ‘seed’
[09:31:15.164]   - Field: ‘version’
[09:31:15.164]   - Field: ‘result’
[09:31:15.164]   - Field: ‘asynchronous’
[09:31:15.164]   - Field: ‘calls’
[09:31:15.164]   - Field: ‘globals’
[09:31:15.164]   - Field: ‘stdout’
[09:31:15.165]   - Field: ‘earlySignal’
[09:31:15.165]   - Field: ‘lazy’
[09:31:15.165]   - Field: ‘state’
[09:31:15.165] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.165] - Launch lazy future ...
[09:31:15.166] Packages needed by the future expression (n = 0): <none>
[09:31:15.166] Packages needed by future strategies (n = 0): <none>
[09:31:15.166] {
[09:31:15.166]     {
[09:31:15.166]         {
[09:31:15.166]             ...future.startTime <- base::Sys.time()
[09:31:15.166]             {
[09:31:15.166]                 {
[09:31:15.166]                   {
[09:31:15.166]                     {
[09:31:15.166]                       base::local({
[09:31:15.166]                         has_future <- base::requireNamespace("future", 
[09:31:15.166]                           quietly = TRUE)
[09:31:15.166]                         if (has_future) {
[09:31:15.166]                           ns <- base::getNamespace("future")
[09:31:15.166]                           version <- ns[[".package"]][["version"]]
[09:31:15.166]                           if (is.null(version)) 
[09:31:15.166]                             version <- utils::packageVersion("future")
[09:31:15.166]                         }
[09:31:15.166]                         else {
[09:31:15.166]                           version <- NULL
[09:31:15.166]                         }
[09:31:15.166]                         if (!has_future || version < "1.8.0") {
[09:31:15.166]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.166]                             "", base::R.version$version.string), 
[09:31:15.166]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.166]                               "release", "version")], collapse = " "), 
[09:31:15.166]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.166]                             info)
[09:31:15.166]                           info <- base::paste(info, collapse = "; ")
[09:31:15.166]                           if (!has_future) {
[09:31:15.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.166]                               info)
[09:31:15.166]                           }
[09:31:15.166]                           else {
[09:31:15.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.166]                               info, version)
[09:31:15.166]                           }
[09:31:15.166]                           base::stop(msg)
[09:31:15.166]                         }
[09:31:15.166]                       })
[09:31:15.166]                     }
[09:31:15.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.166]                     base::options(mc.cores = 1L)
[09:31:15.166]                   }
[09:31:15.166]                   ...future.strategy.old <- future::plan("list")
[09:31:15.166]                   options(future.plan = NULL)
[09:31:15.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.166]                 }
[09:31:15.166]                 ...future.workdir <- getwd()
[09:31:15.166]             }
[09:31:15.166]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.166]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.166]         }
[09:31:15.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.166]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.166]             base::names(...future.oldOptions))
[09:31:15.166]     }
[09:31:15.166]     if (FALSE) {
[09:31:15.166]     }
[09:31:15.166]     else {
[09:31:15.166]         if (TRUE) {
[09:31:15.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.166]                 open = "w")
[09:31:15.166]         }
[09:31:15.166]         else {
[09:31:15.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.166]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.166]         }
[09:31:15.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.166]             base::sink(type = "output", split = FALSE)
[09:31:15.166]             base::close(...future.stdout)
[09:31:15.166]         }, add = TRUE)
[09:31:15.166]     }
[09:31:15.166]     ...future.frame <- base::sys.nframe()
[09:31:15.166]     ...future.conditions <- base::list()
[09:31:15.166]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.166]     if (FALSE) {
[09:31:15.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.166]     }
[09:31:15.166]     ...future.result <- base::tryCatch({
[09:31:15.166]         base::withCallingHandlers({
[09:31:15.166]             ...future.value <- base::withVisible(base::local({
[09:31:15.166]                 withCallingHandlers({
[09:31:15.166]                   {
[09:31:15.166]                     4
[09:31:15.166]                   }
[09:31:15.166]                 }, immediateCondition = function(cond) {
[09:31:15.166]                   save_rds <- function (object, pathname, ...) 
[09:31:15.166]                   {
[09:31:15.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.166]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.166]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.166]                         fi_tmp[["mtime"]])
[09:31:15.166]                     }
[09:31:15.166]                     tryCatch({
[09:31:15.166]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.166]                     }, error = function(ex) {
[09:31:15.166]                       msg <- conditionMessage(ex)
[09:31:15.166]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.166]                         fi_tmp[["mtime"]], msg)
[09:31:15.166]                       ex$message <- msg
[09:31:15.166]                       stop(ex)
[09:31:15.166]                     })
[09:31:15.166]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.166]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.166]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.166]                       fi <- file.info(pathname)
[09:31:15.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.166]                         fi[["size"]], fi[["mtime"]])
[09:31:15.166]                       stop(msg)
[09:31:15.166]                     }
[09:31:15.166]                     invisible(pathname)
[09:31:15.166]                   }
[09:31:15.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.166]                     rootPath = tempdir()) 
[09:31:15.166]                   {
[09:31:15.166]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.166]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.166]                       tmpdir = path, fileext = ".rds")
[09:31:15.166]                     save_rds(obj, file)
[09:31:15.166]                   }
[09:31:15.166]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.166]                   {
[09:31:15.166]                     inherits <- base::inherits
[09:31:15.166]                     invokeRestart <- base::invokeRestart
[09:31:15.166]                     is.null <- base::is.null
[09:31:15.166]                     muffled <- FALSE
[09:31:15.166]                     if (inherits(cond, "message")) {
[09:31:15.166]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.166]                       if (muffled) 
[09:31:15.166]                         invokeRestart("muffleMessage")
[09:31:15.166]                     }
[09:31:15.166]                     else if (inherits(cond, "warning")) {
[09:31:15.166]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.166]                       if (muffled) 
[09:31:15.166]                         invokeRestart("muffleWarning")
[09:31:15.166]                     }
[09:31:15.166]                     else if (inherits(cond, "condition")) {
[09:31:15.166]                       if (!is.null(pattern)) {
[09:31:15.166]                         computeRestarts <- base::computeRestarts
[09:31:15.166]                         grepl <- base::grepl
[09:31:15.166]                         restarts <- computeRestarts(cond)
[09:31:15.166]                         for (restart in restarts) {
[09:31:15.166]                           name <- restart$name
[09:31:15.166]                           if (is.null(name)) 
[09:31:15.166]                             next
[09:31:15.166]                           if (!grepl(pattern, name)) 
[09:31:15.166]                             next
[09:31:15.166]                           invokeRestart(restart)
[09:31:15.166]                           muffled <- TRUE
[09:31:15.166]                           break
[09:31:15.166]                         }
[09:31:15.166]                       }
[09:31:15.166]                     }
[09:31:15.166]                     invisible(muffled)
[09:31:15.166]                   }
[09:31:15.166]                   muffleCondition(cond)
[09:31:15.166]                 })
[09:31:15.166]             }))
[09:31:15.166]             future::FutureResult(value = ...future.value$value, 
[09:31:15.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.166]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.166]                     ...future.globalenv.names))
[09:31:15.166]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.166]         }, condition = base::local({
[09:31:15.166]             c <- base::c
[09:31:15.166]             inherits <- base::inherits
[09:31:15.166]             invokeRestart <- base::invokeRestart
[09:31:15.166]             length <- base::length
[09:31:15.166]             list <- base::list
[09:31:15.166]             seq.int <- base::seq.int
[09:31:15.166]             signalCondition <- base::signalCondition
[09:31:15.166]             sys.calls <- base::sys.calls
[09:31:15.166]             `[[` <- base::`[[`
[09:31:15.166]             `+` <- base::`+`
[09:31:15.166]             `<<-` <- base::`<<-`
[09:31:15.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.166]                   3L)]
[09:31:15.166]             }
[09:31:15.166]             function(cond) {
[09:31:15.166]                 is_error <- inherits(cond, "error")
[09:31:15.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.166]                   NULL)
[09:31:15.166]                 if (is_error) {
[09:31:15.166]                   sessionInformation <- function() {
[09:31:15.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.166]                       search = base::search(), system = base::Sys.info())
[09:31:15.166]                   }
[09:31:15.166]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.166]                     cond$call), session = sessionInformation(), 
[09:31:15.166]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.166]                   signalCondition(cond)
[09:31:15.166]                 }
[09:31:15.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.166]                 "immediateCondition"))) {
[09:31:15.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.166]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.166]                   if (TRUE && !signal) {
[09:31:15.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.166]                     {
[09:31:15.166]                       inherits <- base::inherits
[09:31:15.166]                       invokeRestart <- base::invokeRestart
[09:31:15.166]                       is.null <- base::is.null
[09:31:15.166]                       muffled <- FALSE
[09:31:15.166]                       if (inherits(cond, "message")) {
[09:31:15.166]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.166]                         if (muffled) 
[09:31:15.166]                           invokeRestart("muffleMessage")
[09:31:15.166]                       }
[09:31:15.166]                       else if (inherits(cond, "warning")) {
[09:31:15.166]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.166]                         if (muffled) 
[09:31:15.166]                           invokeRestart("muffleWarning")
[09:31:15.166]                       }
[09:31:15.166]                       else if (inherits(cond, "condition")) {
[09:31:15.166]                         if (!is.null(pattern)) {
[09:31:15.166]                           computeRestarts <- base::computeRestarts
[09:31:15.166]                           grepl <- base::grepl
[09:31:15.166]                           restarts <- computeRestarts(cond)
[09:31:15.166]                           for (restart in restarts) {
[09:31:15.166]                             name <- restart$name
[09:31:15.166]                             if (is.null(name)) 
[09:31:15.166]                               next
[09:31:15.166]                             if (!grepl(pattern, name)) 
[09:31:15.166]                               next
[09:31:15.166]                             invokeRestart(restart)
[09:31:15.166]                             muffled <- TRUE
[09:31:15.166]                             break
[09:31:15.166]                           }
[09:31:15.166]                         }
[09:31:15.166]                       }
[09:31:15.166]                       invisible(muffled)
[09:31:15.166]                     }
[09:31:15.166]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.166]                   }
[09:31:15.166]                 }
[09:31:15.166]                 else {
[09:31:15.166]                   if (TRUE) {
[09:31:15.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.166]                     {
[09:31:15.166]                       inherits <- base::inherits
[09:31:15.166]                       invokeRestart <- base::invokeRestart
[09:31:15.166]                       is.null <- base::is.null
[09:31:15.166]                       muffled <- FALSE
[09:31:15.166]                       if (inherits(cond, "message")) {
[09:31:15.166]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.166]                         if (muffled) 
[09:31:15.166]                           invokeRestart("muffleMessage")
[09:31:15.166]                       }
[09:31:15.166]                       else if (inherits(cond, "warning")) {
[09:31:15.166]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.166]                         if (muffled) 
[09:31:15.166]                           invokeRestart("muffleWarning")
[09:31:15.166]                       }
[09:31:15.166]                       else if (inherits(cond, "condition")) {
[09:31:15.166]                         if (!is.null(pattern)) {
[09:31:15.166]                           computeRestarts <- base::computeRestarts
[09:31:15.166]                           grepl <- base::grepl
[09:31:15.166]                           restarts <- computeRestarts(cond)
[09:31:15.166]                           for (restart in restarts) {
[09:31:15.166]                             name <- restart$name
[09:31:15.166]                             if (is.null(name)) 
[09:31:15.166]                               next
[09:31:15.166]                             if (!grepl(pattern, name)) 
[09:31:15.166]                               next
[09:31:15.166]                             invokeRestart(restart)
[09:31:15.166]                             muffled <- TRUE
[09:31:15.166]                             break
[09:31:15.166]                           }
[09:31:15.166]                         }
[09:31:15.166]                       }
[09:31:15.166]                       invisible(muffled)
[09:31:15.166]                     }
[09:31:15.166]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.166]                   }
[09:31:15.166]                 }
[09:31:15.166]             }
[09:31:15.166]         }))
[09:31:15.166]     }, error = function(ex) {
[09:31:15.166]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.166]                 ...future.rng), started = ...future.startTime, 
[09:31:15.166]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.166]             version = "1.8"), class = "FutureResult")
[09:31:15.166]     }, finally = {
[09:31:15.166]         if (!identical(...future.workdir, getwd())) 
[09:31:15.166]             setwd(...future.workdir)
[09:31:15.166]         {
[09:31:15.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.166]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.166]             }
[09:31:15.166]             base::options(...future.oldOptions)
[09:31:15.166]             if (.Platform$OS.type == "windows") {
[09:31:15.166]                 old_names <- names(...future.oldEnvVars)
[09:31:15.166]                 envs <- base::Sys.getenv()
[09:31:15.166]                 names <- names(envs)
[09:31:15.166]                 common <- intersect(names, old_names)
[09:31:15.166]                 added <- setdiff(names, old_names)
[09:31:15.166]                 removed <- setdiff(old_names, names)
[09:31:15.166]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.166]                   envs[common]]
[09:31:15.166]                 NAMES <- toupper(changed)
[09:31:15.166]                 args <- list()
[09:31:15.166]                 for (kk in seq_along(NAMES)) {
[09:31:15.166]                   name <- changed[[kk]]
[09:31:15.166]                   NAME <- NAMES[[kk]]
[09:31:15.166]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.166]                     next
[09:31:15.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.166]                 }
[09:31:15.166]                 NAMES <- toupper(added)
[09:31:15.166]                 for (kk in seq_along(NAMES)) {
[09:31:15.166]                   name <- added[[kk]]
[09:31:15.166]                   NAME <- NAMES[[kk]]
[09:31:15.166]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.166]                     next
[09:31:15.166]                   args[[name]] <- ""
[09:31:15.166]                 }
[09:31:15.166]                 NAMES <- toupper(removed)
[09:31:15.166]                 for (kk in seq_along(NAMES)) {
[09:31:15.166]                   name <- removed[[kk]]
[09:31:15.166]                   NAME <- NAMES[[kk]]
[09:31:15.166]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.166]                     next
[09:31:15.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.166]                 }
[09:31:15.166]                 if (length(args) > 0) 
[09:31:15.166]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.166]             }
[09:31:15.166]             else {
[09:31:15.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.166]             }
[09:31:15.166]             {
[09:31:15.166]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.166]                   0L) {
[09:31:15.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.166]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.166]                   base::options(opts)
[09:31:15.166]                 }
[09:31:15.166]                 {
[09:31:15.166]                   {
[09:31:15.166]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.166]                     NULL
[09:31:15.166]                   }
[09:31:15.166]                   options(future.plan = NULL)
[09:31:15.166]                   if (is.na(NA_character_)) 
[09:31:15.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.166]                     .init = FALSE)
[09:31:15.166]                 }
[09:31:15.166]             }
[09:31:15.166]         }
[09:31:15.166]     })
[09:31:15.166]     if (TRUE) {
[09:31:15.166]         base::sink(type = "output", split = FALSE)
[09:31:15.166]         if (TRUE) {
[09:31:15.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.166]         }
[09:31:15.166]         else {
[09:31:15.166]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.166]         }
[09:31:15.166]         base::close(...future.stdout)
[09:31:15.166]         ...future.stdout <- NULL
[09:31:15.166]     }
[09:31:15.166]     ...future.result$conditions <- ...future.conditions
[09:31:15.166]     ...future.result$finished <- base::Sys.time()
[09:31:15.166]     ...future.result
[09:31:15.166] }
[09:31:15.170] requestCore(): workers = 2
[09:31:15.170] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:15.181] result() for MulticoreFuture ...
[09:31:15.182] result() for MulticoreFuture ...
[09:31:15.182] result() for MulticoreFuture ... done
[09:31:15.182] result() for MulticoreFuture ... done
[09:31:15.182] result() for MulticoreFuture ...
[09:31:15.182] result() for MulticoreFuture ... done
[09:31:15.185] MulticoreFuture started
[09:31:15.186] - Launch lazy future ... done
[09:31:15.186] run() for ‘MulticoreFuture’ ... done
[09:31:15.187] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a3ca9a8758> 
[09:31:15.187] List of future strategies:
[09:31:15.187] 1. sequential:
[09:31:15.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.187]    - tweaked: FALSE
[09:31:15.187]    - call: NULL
[09:31:15.188] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a3cc03a7e0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[09:31:15.191] plan(): Setting new future strategy stack:
List of 2
  ..$ :[09:31:15.191] List of future strategies:
[09:31:15.191] 1. multicore:
[09:31:15.191]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.191]    - tweaked: FALSE
[09:31:15.191]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[09:31:15.197] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:15.201] resolve() on list environment ...
[09:31:15.201]  recursive: 0
[09:31:15.202]  length: 6
[09:31:15.202]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:15.203] signalConditionsASAP(numeric, pos=1) ...
[09:31:15.203] - nx: 6
[09:31:15.203] - relay: TRUE
[09:31:15.203] - stdout: TRUE
[09:31:15.203] - signal: TRUE
[09:31:15.203] - resignal: FALSE
[09:31:15.203] - force: TRUE
[09:31:15.203] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.204] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.204]  - until=2
[09:31:15.204]  - relaying element #2
[09:31:15.204] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.204] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.204] signalConditionsASAP(NULL, pos=1) ... done
[09:31:15.204]  length: 5 (resolved future 1)
[09:31:15.205] Future #2
[09:31:15.205] result() for MulticoreFuture ...
[09:31:15.205] result() for MulticoreFuture ... done
[09:31:15.205] result() for MulticoreFuture ...
[09:31:15.205] result() for MulticoreFuture ... done
[09:31:15.205] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:15.205] - nx: 6
[09:31:15.206] - relay: TRUE
[09:31:15.206] - stdout: TRUE
[09:31:15.206] - signal: TRUE
[09:31:15.206] - resignal: FALSE
[09:31:15.206] - force: TRUE
[09:31:15.206] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.206] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.206]  - until=2
[09:31:15.207]  - relaying element #2
[09:31:15.207] result() for MulticoreFuture ...
[09:31:15.207] result() for MulticoreFuture ... done
[09:31:15.207] result() for MulticoreFuture ...
[09:31:15.207] result() for MulticoreFuture ... done
[09:31:15.207] result() for MulticoreFuture ...
[09:31:15.207] result() for MulticoreFuture ... done
[09:31:15.207] result() for MulticoreFuture ...
[09:31:15.208] result() for MulticoreFuture ... done
[09:31:15.208] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.208] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.208] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:15.208]  length: 4 (resolved future 2)
[09:31:15.208] Future #3
[09:31:15.209] result() for MulticoreFuture ...
[09:31:15.209] result() for MulticoreFuture ...
[09:31:15.210] result() for MulticoreFuture ... done
[09:31:15.210] result() for MulticoreFuture ... done
[09:31:15.210] result() for MulticoreFuture ...
[09:31:15.210] result() for MulticoreFuture ... done
[09:31:15.210] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:15.210] - nx: 6
[09:31:15.210] - relay: TRUE
[09:31:15.210] - stdout: TRUE
[09:31:15.211] - signal: TRUE
[09:31:15.211] - resignal: FALSE
[09:31:15.211] - force: TRUE
[09:31:15.211] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.211] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.211]  - until=3
[09:31:15.211]  - relaying element #3
[09:31:15.211] result() for MulticoreFuture ...
[09:31:15.212] result() for MulticoreFuture ... done
[09:31:15.212] result() for MulticoreFuture ...
[09:31:15.212] result() for MulticoreFuture ... done
[09:31:15.212] result() for MulticoreFuture ...
[09:31:15.212] result() for MulticoreFuture ... done
[09:31:15.212] result() for MulticoreFuture ...
[09:31:15.212] result() for MulticoreFuture ... done
[09:31:15.213] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.213] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.213] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:15.213]  length: 3 (resolved future 3)
[09:31:15.213] Future #4
[09:31:15.213] result() for MulticoreFuture ...
[09:31:15.214] result() for MulticoreFuture ...
[09:31:15.214] result() for MulticoreFuture ... done
[09:31:15.214] result() for MulticoreFuture ... done
[09:31:15.215] result() for MulticoreFuture ...
[09:31:15.215] result() for MulticoreFuture ... done
[09:31:15.215] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:15.215] - nx: 6
[09:31:15.215] - relay: TRUE
[09:31:15.215] - stdout: TRUE
[09:31:15.216] - signal: TRUE
[09:31:15.216] - resignal: FALSE
[09:31:15.216] - force: TRUE
[09:31:15.216] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.216] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.216]  - until=4
[09:31:15.217]  - relaying element #4
[09:31:15.217] result() for MulticoreFuture ...
[09:31:15.217] result() for MulticoreFuture ... done
[09:31:15.217] result() for MulticoreFuture ...
[09:31:15.217] result() for MulticoreFuture ... done
[09:31:15.217] result() for MulticoreFuture ...
[09:31:15.218] result() for MulticoreFuture ... done
[09:31:15.218] result() for MulticoreFuture ...
[09:31:15.218] result() for MulticoreFuture ... done
[09:31:15.218] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.218] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.218] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:15.218]  length: 2 (resolved future 4)
[09:31:15.218] signalConditionsASAP(NULL, pos=5) ...
[09:31:15.218] - nx: 6
[09:31:15.219] - relay: TRUE
[09:31:15.219] - stdout: TRUE
[09:31:15.219] - signal: TRUE
[09:31:15.219] - resignal: FALSE
[09:31:15.219] - force: TRUE
[09:31:15.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.219] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.219]  - until=6
[09:31:15.219]  - relaying element #6
[09:31:15.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.219] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.220] signalConditionsASAP(NULL, pos=5) ... done
[09:31:15.220]  length: 1 (resolved future 5)
[09:31:15.220] signalConditionsASAP(numeric, pos=6) ...
[09:31:15.220] - nx: 6
[09:31:15.220] - relay: TRUE
[09:31:15.220] - stdout: TRUE
[09:31:15.220] - signal: TRUE
[09:31:15.220] - resignal: FALSE
[09:31:15.220] - force: TRUE
[09:31:15.221] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.221] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.221]  - until=6
[09:31:15.221] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.221] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.221] signalConditionsASAP(numeric, pos=6) ... done
[09:31:15.221]  length: 0 (resolved future 6)
[09:31:15.221] Relaying remaining futures
[09:31:15.221] signalConditionsASAP(NULL, pos=0) ...
[09:31:15.221] - nx: 6
[09:31:15.222] - relay: TRUE
[09:31:15.222] - stdout: TRUE
[09:31:15.222] - signal: TRUE
[09:31:15.222] - resignal: FALSE
[09:31:15.222] - force: TRUE
[09:31:15.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.222] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:15.222] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.222] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.222] signalConditionsASAP(NULL, pos=0) ... done
[09:31:15.223] resolve() on list environment ... DONE
[09:31:15.223] result() for MulticoreFuture ...
[09:31:15.223] result() for MulticoreFuture ... done
[09:31:15.223] result() for MulticoreFuture ...
[09:31:15.223] result() for MulticoreFuture ... done
[09:31:15.223] result() for MulticoreFuture ...
[09:31:15.223] result() for MulticoreFuture ... done
[09:31:15.223] result() for MulticoreFuture ...
[09:31:15.223] result() for MulticoreFuture ... done
[09:31:15.224] result() for MulticoreFuture ...
[09:31:15.224] result() for MulticoreFuture ... done
[09:31:15.224] result() for MulticoreFuture ...
[09:31:15.224] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cc33d900> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:15.226] getGlobalsAndPackages() ...
[09:31:15.226] Searching for globals...
[09:31:15.226] 
[09:31:15.227] Searching for globals ... DONE
[09:31:15.227] - globals: [0] <none>
[09:31:15.227] getGlobalsAndPackages() ... DONE
[09:31:15.227] run() for ‘Future’ ...
[09:31:15.227] - state: ‘created’
[09:31:15.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.231] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.232]   - Field: ‘label’
[09:31:15.232]   - Field: ‘local’
[09:31:15.232]   - Field: ‘owner’
[09:31:15.232]   - Field: ‘envir’
[09:31:15.232]   - Field: ‘workers’
[09:31:15.232]   - Field: ‘packages’
[09:31:15.232]   - Field: ‘gc’
[09:31:15.233]   - Field: ‘job’
[09:31:15.233]   - Field: ‘conditions’
[09:31:15.233]   - Field: ‘expr’
[09:31:15.233]   - Field: ‘uuid’
[09:31:15.233]   - Field: ‘seed’
[09:31:15.233]   - Field: ‘version’
[09:31:15.233]   - Field: ‘result’
[09:31:15.237]   - Field: ‘asynchronous’
[09:31:15.237]   - Field: ‘calls’
[09:31:15.237]   - Field: ‘globals’
[09:31:15.238]   - Field: ‘stdout’
[09:31:15.238]   - Field: ‘earlySignal’
[09:31:15.238]   - Field: ‘lazy’
[09:31:15.238]   - Field: ‘state’
[09:31:15.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.238] - Launch lazy future ...
[09:31:15.239] Packages needed by the future expression (n = 0): <none>
[09:31:15.239] Packages needed by future strategies (n = 0): <none>
[09:31:15.240] {
[09:31:15.240]     {
[09:31:15.240]         {
[09:31:15.240]             ...future.startTime <- base::Sys.time()
[09:31:15.240]             {
[09:31:15.240]                 {
[09:31:15.240]                   {
[09:31:15.240]                     {
[09:31:15.240]                       base::local({
[09:31:15.240]                         has_future <- base::requireNamespace("future", 
[09:31:15.240]                           quietly = TRUE)
[09:31:15.240]                         if (has_future) {
[09:31:15.240]                           ns <- base::getNamespace("future")
[09:31:15.240]                           version <- ns[[".package"]][["version"]]
[09:31:15.240]                           if (is.null(version)) 
[09:31:15.240]                             version <- utils::packageVersion("future")
[09:31:15.240]                         }
[09:31:15.240]                         else {
[09:31:15.240]                           version <- NULL
[09:31:15.240]                         }
[09:31:15.240]                         if (!has_future || version < "1.8.0") {
[09:31:15.240]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.240]                             "", base::R.version$version.string), 
[09:31:15.240]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.240]                               "release", "version")], collapse = " "), 
[09:31:15.240]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.240]                             info)
[09:31:15.240]                           info <- base::paste(info, collapse = "; ")
[09:31:15.240]                           if (!has_future) {
[09:31:15.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.240]                               info)
[09:31:15.240]                           }
[09:31:15.240]                           else {
[09:31:15.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.240]                               info, version)
[09:31:15.240]                           }
[09:31:15.240]                           base::stop(msg)
[09:31:15.240]                         }
[09:31:15.240]                       })
[09:31:15.240]                     }
[09:31:15.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.240]                     base::options(mc.cores = 1L)
[09:31:15.240]                   }
[09:31:15.240]                   ...future.strategy.old <- future::plan("list")
[09:31:15.240]                   options(future.plan = NULL)
[09:31:15.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.240]                 }
[09:31:15.240]                 ...future.workdir <- getwd()
[09:31:15.240]             }
[09:31:15.240]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.240]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.240]         }
[09:31:15.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.240]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.240]             base::names(...future.oldOptions))
[09:31:15.240]     }
[09:31:15.240]     if (FALSE) {
[09:31:15.240]     }
[09:31:15.240]     else {
[09:31:15.240]         if (TRUE) {
[09:31:15.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.240]                 open = "w")
[09:31:15.240]         }
[09:31:15.240]         else {
[09:31:15.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.240]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.240]         }
[09:31:15.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.240]             base::sink(type = "output", split = FALSE)
[09:31:15.240]             base::close(...future.stdout)
[09:31:15.240]         }, add = TRUE)
[09:31:15.240]     }
[09:31:15.240]     ...future.frame <- base::sys.nframe()
[09:31:15.240]     ...future.conditions <- base::list()
[09:31:15.240]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.240]     if (FALSE) {
[09:31:15.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.240]     }
[09:31:15.240]     ...future.result <- base::tryCatch({
[09:31:15.240]         base::withCallingHandlers({
[09:31:15.240]             ...future.value <- base::withVisible(base::local({
[09:31:15.240]                 withCallingHandlers({
[09:31:15.240]                   2
[09:31:15.240]                 }, immediateCondition = function(cond) {
[09:31:15.240]                   save_rds <- function (object, pathname, ...) 
[09:31:15.240]                   {
[09:31:15.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.240]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.240]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.240]                         fi_tmp[["mtime"]])
[09:31:15.240]                     }
[09:31:15.240]                     tryCatch({
[09:31:15.240]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.240]                     }, error = function(ex) {
[09:31:15.240]                       msg <- conditionMessage(ex)
[09:31:15.240]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.240]                         fi_tmp[["mtime"]], msg)
[09:31:15.240]                       ex$message <- msg
[09:31:15.240]                       stop(ex)
[09:31:15.240]                     })
[09:31:15.240]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.240]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.240]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.240]                       fi <- file.info(pathname)
[09:31:15.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.240]                         fi[["size"]], fi[["mtime"]])
[09:31:15.240]                       stop(msg)
[09:31:15.240]                     }
[09:31:15.240]                     invisible(pathname)
[09:31:15.240]                   }
[09:31:15.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.240]                     rootPath = tempdir()) 
[09:31:15.240]                   {
[09:31:15.240]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.240]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.240]                       tmpdir = path, fileext = ".rds")
[09:31:15.240]                     save_rds(obj, file)
[09:31:15.240]                   }
[09:31:15.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.240]                   {
[09:31:15.240]                     inherits <- base::inherits
[09:31:15.240]                     invokeRestart <- base::invokeRestart
[09:31:15.240]                     is.null <- base::is.null
[09:31:15.240]                     muffled <- FALSE
[09:31:15.240]                     if (inherits(cond, "message")) {
[09:31:15.240]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.240]                       if (muffled) 
[09:31:15.240]                         invokeRestart("muffleMessage")
[09:31:15.240]                     }
[09:31:15.240]                     else if (inherits(cond, "warning")) {
[09:31:15.240]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.240]                       if (muffled) 
[09:31:15.240]                         invokeRestart("muffleWarning")
[09:31:15.240]                     }
[09:31:15.240]                     else if (inherits(cond, "condition")) {
[09:31:15.240]                       if (!is.null(pattern)) {
[09:31:15.240]                         computeRestarts <- base::computeRestarts
[09:31:15.240]                         grepl <- base::grepl
[09:31:15.240]                         restarts <- computeRestarts(cond)
[09:31:15.240]                         for (restart in restarts) {
[09:31:15.240]                           name <- restart$name
[09:31:15.240]                           if (is.null(name)) 
[09:31:15.240]                             next
[09:31:15.240]                           if (!grepl(pattern, name)) 
[09:31:15.240]                             next
[09:31:15.240]                           invokeRestart(restart)
[09:31:15.240]                           muffled <- TRUE
[09:31:15.240]                           break
[09:31:15.240]                         }
[09:31:15.240]                       }
[09:31:15.240]                     }
[09:31:15.240]                     invisible(muffled)
[09:31:15.240]                   }
[09:31:15.240]                   muffleCondition(cond)
[09:31:15.240]                 })
[09:31:15.240]             }))
[09:31:15.240]             future::FutureResult(value = ...future.value$value, 
[09:31:15.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.240]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.240]                     ...future.globalenv.names))
[09:31:15.240]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.240]         }, condition = base::local({
[09:31:15.240]             c <- base::c
[09:31:15.240]             inherits <- base::inherits
[09:31:15.240]             invokeRestart <- base::invokeRestart
[09:31:15.240]             length <- base::length
[09:31:15.240]             list <- base::list
[09:31:15.240]             seq.int <- base::seq.int
[09:31:15.240]             signalCondition <- base::signalCondition
[09:31:15.240]             sys.calls <- base::sys.calls
[09:31:15.240]             `[[` <- base::`[[`
[09:31:15.240]             `+` <- base::`+`
[09:31:15.240]             `<<-` <- base::`<<-`
[09:31:15.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.240]                   3L)]
[09:31:15.240]             }
[09:31:15.240]             function(cond) {
[09:31:15.240]                 is_error <- inherits(cond, "error")
[09:31:15.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.240]                   NULL)
[09:31:15.240]                 if (is_error) {
[09:31:15.240]                   sessionInformation <- function() {
[09:31:15.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.240]                       search = base::search(), system = base::Sys.info())
[09:31:15.240]                   }
[09:31:15.240]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.240]                     cond$call), session = sessionInformation(), 
[09:31:15.240]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.240]                   signalCondition(cond)
[09:31:15.240]                 }
[09:31:15.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.240]                 "immediateCondition"))) {
[09:31:15.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.240]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.240]                   if (TRUE && !signal) {
[09:31:15.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.240]                     {
[09:31:15.240]                       inherits <- base::inherits
[09:31:15.240]                       invokeRestart <- base::invokeRestart
[09:31:15.240]                       is.null <- base::is.null
[09:31:15.240]                       muffled <- FALSE
[09:31:15.240]                       if (inherits(cond, "message")) {
[09:31:15.240]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.240]                         if (muffled) 
[09:31:15.240]                           invokeRestart("muffleMessage")
[09:31:15.240]                       }
[09:31:15.240]                       else if (inherits(cond, "warning")) {
[09:31:15.240]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.240]                         if (muffled) 
[09:31:15.240]                           invokeRestart("muffleWarning")
[09:31:15.240]                       }
[09:31:15.240]                       else if (inherits(cond, "condition")) {
[09:31:15.240]                         if (!is.null(pattern)) {
[09:31:15.240]                           computeRestarts <- base::computeRestarts
[09:31:15.240]                           grepl <- base::grepl
[09:31:15.240]                           restarts <- computeRestarts(cond)
[09:31:15.240]                           for (restart in restarts) {
[09:31:15.240]                             name <- restart$name
[09:31:15.240]                             if (is.null(name)) 
[09:31:15.240]                               next
[09:31:15.240]                             if (!grepl(pattern, name)) 
[09:31:15.240]                               next
[09:31:15.240]                             invokeRestart(restart)
[09:31:15.240]                             muffled <- TRUE
[09:31:15.240]                             break
[09:31:15.240]                           }
[09:31:15.240]                         }
[09:31:15.240]                       }
[09:31:15.240]                       invisible(muffled)
[09:31:15.240]                     }
[09:31:15.240]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.240]                   }
[09:31:15.240]                 }
[09:31:15.240]                 else {
[09:31:15.240]                   if (TRUE) {
[09:31:15.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.240]                     {
[09:31:15.240]                       inherits <- base::inherits
[09:31:15.240]                       invokeRestart <- base::invokeRestart
[09:31:15.240]                       is.null <- base::is.null
[09:31:15.240]                       muffled <- FALSE
[09:31:15.240]                       if (inherits(cond, "message")) {
[09:31:15.240]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.240]                         if (muffled) 
[09:31:15.240]                           invokeRestart("muffleMessage")
[09:31:15.240]                       }
[09:31:15.240]                       else if (inherits(cond, "warning")) {
[09:31:15.240]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.240]                         if (muffled) 
[09:31:15.240]                           invokeRestart("muffleWarning")
[09:31:15.240]                       }
[09:31:15.240]                       else if (inherits(cond, "condition")) {
[09:31:15.240]                         if (!is.null(pattern)) {
[09:31:15.240]                           computeRestarts <- base::computeRestarts
[09:31:15.240]                           grepl <- base::grepl
[09:31:15.240]                           restarts <- computeRestarts(cond)
[09:31:15.240]                           for (restart in restarts) {
[09:31:15.240]                             name <- restart$name
[09:31:15.240]                             if (is.null(name)) 
[09:31:15.240]                               next
[09:31:15.240]                             if (!grepl(pattern, name)) 
[09:31:15.240]                               next
[09:31:15.240]                             invokeRestart(restart)
[09:31:15.240]                             muffled <- TRUE
[09:31:15.240]                             break
[09:31:15.240]                           }
[09:31:15.240]                         }
[09:31:15.240]                       }
[09:31:15.240]                       invisible(muffled)
[09:31:15.240]                     }
[09:31:15.240]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.240]                   }
[09:31:15.240]                 }
[09:31:15.240]             }
[09:31:15.240]         }))
[09:31:15.240]     }, error = function(ex) {
[09:31:15.240]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.240]                 ...future.rng), started = ...future.startTime, 
[09:31:15.240]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.240]             version = "1.8"), class = "FutureResult")
[09:31:15.240]     }, finally = {
[09:31:15.240]         if (!identical(...future.workdir, getwd())) 
[09:31:15.240]             setwd(...future.workdir)
[09:31:15.240]         {
[09:31:15.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.240]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.240]             }
[09:31:15.240]             base::options(...future.oldOptions)
[09:31:15.240]             if (.Platform$OS.type == "windows") {
[09:31:15.240]                 old_names <- names(...future.oldEnvVars)
[09:31:15.240]                 envs <- base::Sys.getenv()
[09:31:15.240]                 names <- names(envs)
[09:31:15.240]                 common <- intersect(names, old_names)
[09:31:15.240]                 added <- setdiff(names, old_names)
[09:31:15.240]                 removed <- setdiff(old_names, names)
[09:31:15.240]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.240]                   envs[common]]
[09:31:15.240]                 NAMES <- toupper(changed)
[09:31:15.240]                 args <- list()
[09:31:15.240]                 for (kk in seq_along(NAMES)) {
[09:31:15.240]                   name <- changed[[kk]]
[09:31:15.240]                   NAME <- NAMES[[kk]]
[09:31:15.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.240]                     next
[09:31:15.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.240]                 }
[09:31:15.240]                 NAMES <- toupper(added)
[09:31:15.240]                 for (kk in seq_along(NAMES)) {
[09:31:15.240]                   name <- added[[kk]]
[09:31:15.240]                   NAME <- NAMES[[kk]]
[09:31:15.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.240]                     next
[09:31:15.240]                   args[[name]] <- ""
[09:31:15.240]                 }
[09:31:15.240]                 NAMES <- toupper(removed)
[09:31:15.240]                 for (kk in seq_along(NAMES)) {
[09:31:15.240]                   name <- removed[[kk]]
[09:31:15.240]                   NAME <- NAMES[[kk]]
[09:31:15.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.240]                     next
[09:31:15.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.240]                 }
[09:31:15.240]                 if (length(args) > 0) 
[09:31:15.240]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.240]             }
[09:31:15.240]             else {
[09:31:15.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.240]             }
[09:31:15.240]             {
[09:31:15.240]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.240]                   0L) {
[09:31:15.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.240]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.240]                   base::options(opts)
[09:31:15.240]                 }
[09:31:15.240]                 {
[09:31:15.240]                   {
[09:31:15.240]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.240]                     NULL
[09:31:15.240]                   }
[09:31:15.240]                   options(future.plan = NULL)
[09:31:15.240]                   if (is.na(NA_character_)) 
[09:31:15.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.240]                     .init = FALSE)
[09:31:15.240]                 }
[09:31:15.240]             }
[09:31:15.240]         }
[09:31:15.240]     })
[09:31:15.240]     if (TRUE) {
[09:31:15.240]         base::sink(type = "output", split = FALSE)
[09:31:15.240]         if (TRUE) {
[09:31:15.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.240]         }
[09:31:15.240]         else {
[09:31:15.240]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.240]         }
[09:31:15.240]         base::close(...future.stdout)
[09:31:15.240]         ...future.stdout <- NULL
[09:31:15.240]     }
[09:31:15.240]     ...future.result$conditions <- ...future.conditions
[09:31:15.240]     ...future.result$finished <- base::Sys.time()
[09:31:15.240]     ...future.result
[09:31:15.240] }
[09:31:15.242] requestCore(): workers = 2
[09:31:15.244] MulticoreFuture started
[09:31:15.244] - Launch lazy future ... done
[09:31:15.245] run() for ‘MulticoreFuture’ ... done
[09:31:15.245] getGlobalsAndPackages() ...
[09:31:15.245] plan(): Setting new future strategy stack:
[09:31:15.245] Searching for globals...
[09:31:15.246] 
[09:31:15.245] List of future strategies:
[09:31:15.245] 1. sequential:
[09:31:15.245]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.245]    - tweaked: FALSE
[09:31:15.245]    - call: NULL
[09:31:15.246] Searching for globals ... DONE
[09:31:15.247] plan(): nbrOfWorkers() = 1
[09:31:15.247] - globals: [0] <none>
[09:31:15.247] getGlobalsAndPackages() ... DONE
[09:31:15.247] run() for ‘Future’ ...
[09:31:15.247] - state: ‘created’
[09:31:15.248] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.248] plan(): Setting new future strategy stack:
[09:31:15.249] List of future strategies:
[09:31:15.249] 1. multicore:
[09:31:15.249]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.249]    - tweaked: FALSE
[09:31:15.249]    - call: plan(strategy)
[09:31:15.253] plan(): nbrOfWorkers() = 2
[09:31:15.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.253]   - Field: ‘label’
[09:31:15.253]   - Field: ‘local’
[09:31:15.254]   - Field: ‘owner’
[09:31:15.254]   - Field: ‘envir’
[09:31:15.254]   - Field: ‘workers’
[09:31:15.254]   - Field: ‘packages’
[09:31:15.254]   - Field: ‘gc’
[09:31:15.254]   - Field: ‘job’
[09:31:15.255]   - Field: ‘conditions’
[09:31:15.255]   - Field: ‘expr’
[09:31:15.255]   - Field: ‘uuid’
[09:31:15.255]   - Field: ‘seed’
[09:31:15.255]   - Field: ‘version’
[09:31:15.255]   - Field: ‘result’
[09:31:15.255]   - Field: ‘asynchronous’
[09:31:15.256]   - Field: ‘calls’
[09:31:15.256]   - Field: ‘globals’
[09:31:15.256]   - Field: ‘stdout’
[09:31:15.256]   - Field: ‘earlySignal’
[09:31:15.256]   - Field: ‘lazy’
[09:31:15.256]   - Field: ‘state’
[09:31:15.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.257] - Launch lazy future ...
[09:31:15.257] Packages needed by the future expression (n = 0): <none>
[09:31:15.257] Packages needed by future strategies (n = 0): <none>
[09:31:15.258] {
[09:31:15.258]     {
[09:31:15.258]         {
[09:31:15.258]             ...future.startTime <- base::Sys.time()
[09:31:15.258]             {
[09:31:15.258]                 {
[09:31:15.258]                   {
[09:31:15.258]                     {
[09:31:15.258]                       base::local({
[09:31:15.258]                         has_future <- base::requireNamespace("future", 
[09:31:15.258]                           quietly = TRUE)
[09:31:15.258]                         if (has_future) {
[09:31:15.258]                           ns <- base::getNamespace("future")
[09:31:15.258]                           version <- ns[[".package"]][["version"]]
[09:31:15.258]                           if (is.null(version)) 
[09:31:15.258]                             version <- utils::packageVersion("future")
[09:31:15.258]                         }
[09:31:15.258]                         else {
[09:31:15.258]                           version <- NULL
[09:31:15.258]                         }
[09:31:15.258]                         if (!has_future || version < "1.8.0") {
[09:31:15.258]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.258]                             "", base::R.version$version.string), 
[09:31:15.258]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.258]                               "release", "version")], collapse = " "), 
[09:31:15.258]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.258]                             info)
[09:31:15.258]                           info <- base::paste(info, collapse = "; ")
[09:31:15.258]                           if (!has_future) {
[09:31:15.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.258]                               info)
[09:31:15.258]                           }
[09:31:15.258]                           else {
[09:31:15.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.258]                               info, version)
[09:31:15.258]                           }
[09:31:15.258]                           base::stop(msg)
[09:31:15.258]                         }
[09:31:15.258]                       })
[09:31:15.258]                     }
[09:31:15.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.258]                     base::options(mc.cores = 1L)
[09:31:15.258]                   }
[09:31:15.258]                   ...future.strategy.old <- future::plan("list")
[09:31:15.258]                   options(future.plan = NULL)
[09:31:15.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.258]                 }
[09:31:15.258]                 ...future.workdir <- getwd()
[09:31:15.258]             }
[09:31:15.258]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.258]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.258]         }
[09:31:15.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.258]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.258]             base::names(...future.oldOptions))
[09:31:15.258]     }
[09:31:15.258]     if (FALSE) {
[09:31:15.258]     }
[09:31:15.258]     else {
[09:31:15.258]         if (TRUE) {
[09:31:15.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.258]                 open = "w")
[09:31:15.258]         }
[09:31:15.258]         else {
[09:31:15.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.258]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.258]         }
[09:31:15.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.258]             base::sink(type = "output", split = FALSE)
[09:31:15.258]             base::close(...future.stdout)
[09:31:15.258]         }, add = TRUE)
[09:31:15.258]     }
[09:31:15.258]     ...future.frame <- base::sys.nframe()
[09:31:15.258]     ...future.conditions <- base::list()
[09:31:15.258]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.258]     if (FALSE) {
[09:31:15.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.258]     }
[09:31:15.258]     ...future.result <- base::tryCatch({
[09:31:15.258]         base::withCallingHandlers({
[09:31:15.258]             ...future.value <- base::withVisible(base::local({
[09:31:15.258]                 withCallingHandlers({
[09:31:15.258]                   NULL
[09:31:15.258]                 }, immediateCondition = function(cond) {
[09:31:15.258]                   save_rds <- function (object, pathname, ...) 
[09:31:15.258]                   {
[09:31:15.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.258]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.258]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.258]                         fi_tmp[["mtime"]])
[09:31:15.258]                     }
[09:31:15.258]                     tryCatch({
[09:31:15.258]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.258]                     }, error = function(ex) {
[09:31:15.258]                       msg <- conditionMessage(ex)
[09:31:15.258]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.258]                         fi_tmp[["mtime"]], msg)
[09:31:15.258]                       ex$message <- msg
[09:31:15.258]                       stop(ex)
[09:31:15.258]                     })
[09:31:15.258]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.258]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.258]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.258]                       fi <- file.info(pathname)
[09:31:15.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.258]                         fi[["size"]], fi[["mtime"]])
[09:31:15.258]                       stop(msg)
[09:31:15.258]                     }
[09:31:15.258]                     invisible(pathname)
[09:31:15.258]                   }
[09:31:15.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.258]                     rootPath = tempdir()) 
[09:31:15.258]                   {
[09:31:15.258]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.258]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.258]                       tmpdir = path, fileext = ".rds")
[09:31:15.258]                     save_rds(obj, file)
[09:31:15.258]                   }
[09:31:15.258]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.258]                   {
[09:31:15.258]                     inherits <- base::inherits
[09:31:15.258]                     invokeRestart <- base::invokeRestart
[09:31:15.258]                     is.null <- base::is.null
[09:31:15.258]                     muffled <- FALSE
[09:31:15.258]                     if (inherits(cond, "message")) {
[09:31:15.258]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.258]                       if (muffled) 
[09:31:15.258]                         invokeRestart("muffleMessage")
[09:31:15.258]                     }
[09:31:15.258]                     else if (inherits(cond, "warning")) {
[09:31:15.258]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.258]                       if (muffled) 
[09:31:15.258]                         invokeRestart("muffleWarning")
[09:31:15.258]                     }
[09:31:15.258]                     else if (inherits(cond, "condition")) {
[09:31:15.258]                       if (!is.null(pattern)) {
[09:31:15.258]                         computeRestarts <- base::computeRestarts
[09:31:15.258]                         grepl <- base::grepl
[09:31:15.258]                         restarts <- computeRestarts(cond)
[09:31:15.258]                         for (restart in restarts) {
[09:31:15.258]                           name <- restart$name
[09:31:15.258]                           if (is.null(name)) 
[09:31:15.258]                             next
[09:31:15.258]                           if (!grepl(pattern, name)) 
[09:31:15.258]                             next
[09:31:15.258]                           invokeRestart(restart)
[09:31:15.258]                           muffled <- TRUE
[09:31:15.258]                           break
[09:31:15.258]                         }
[09:31:15.258]                       }
[09:31:15.258]                     }
[09:31:15.258]                     invisible(muffled)
[09:31:15.258]                   }
[09:31:15.258]                   muffleCondition(cond)
[09:31:15.258]                 })
[09:31:15.258]             }))
[09:31:15.258]             future::FutureResult(value = ...future.value$value, 
[09:31:15.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.258]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.258]                     ...future.globalenv.names))
[09:31:15.258]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.258]         }, condition = base::local({
[09:31:15.258]             c <- base::c
[09:31:15.258]             inherits <- base::inherits
[09:31:15.258]             invokeRestart <- base::invokeRestart
[09:31:15.258]             length <- base::length
[09:31:15.258]             list <- base::list
[09:31:15.258]             seq.int <- base::seq.int
[09:31:15.258]             signalCondition <- base::signalCondition
[09:31:15.258]             sys.calls <- base::sys.calls
[09:31:15.258]             `[[` <- base::`[[`
[09:31:15.258]             `+` <- base::`+`
[09:31:15.258]             `<<-` <- base::`<<-`
[09:31:15.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.258]                   3L)]
[09:31:15.258]             }
[09:31:15.258]             function(cond) {
[09:31:15.258]                 is_error <- inherits(cond, "error")
[09:31:15.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.258]                   NULL)
[09:31:15.258]                 if (is_error) {
[09:31:15.258]                   sessionInformation <- function() {
[09:31:15.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.258]                       search = base::search(), system = base::Sys.info())
[09:31:15.258]                   }
[09:31:15.258]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.258]                     cond$call), session = sessionInformation(), 
[09:31:15.258]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.258]                   signalCondition(cond)
[09:31:15.258]                 }
[09:31:15.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.258]                 "immediateCondition"))) {
[09:31:15.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.258]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.258]                   if (TRUE && !signal) {
[09:31:15.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.258]                     {
[09:31:15.258]                       inherits <- base::inherits
[09:31:15.258]                       invokeRestart <- base::invokeRestart
[09:31:15.258]                       is.null <- base::is.null
[09:31:15.258]                       muffled <- FALSE
[09:31:15.258]                       if (inherits(cond, "message")) {
[09:31:15.258]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.258]                         if (muffled) 
[09:31:15.258]                           invokeRestart("muffleMessage")
[09:31:15.258]                       }
[09:31:15.258]                       else if (inherits(cond, "warning")) {
[09:31:15.258]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.258]                         if (muffled) 
[09:31:15.258]                           invokeRestart("muffleWarning")
[09:31:15.258]                       }
[09:31:15.258]                       else if (inherits(cond, "condition")) {
[09:31:15.258]                         if (!is.null(pattern)) {
[09:31:15.258]                           computeRestarts <- base::computeRestarts
[09:31:15.258]                           grepl <- base::grepl
[09:31:15.258]                           restarts <- computeRestarts(cond)
[09:31:15.258]                           for (restart in restarts) {
[09:31:15.258]                             name <- restart$name
[09:31:15.258]                             if (is.null(name)) 
[09:31:15.258]                               next
[09:31:15.258]                             if (!grepl(pattern, name)) 
[09:31:15.258]                               next
[09:31:15.258]                             invokeRestart(restart)
[09:31:15.258]                             muffled <- TRUE
[09:31:15.258]                             break
[09:31:15.258]                           }
[09:31:15.258]                         }
[09:31:15.258]                       }
[09:31:15.258]                       invisible(muffled)
[09:31:15.258]                     }
[09:31:15.258]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.258]                   }
[09:31:15.258]                 }
[09:31:15.258]                 else {
[09:31:15.258]                   if (TRUE) {
[09:31:15.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.258]                     {
[09:31:15.258]                       inherits <- base::inherits
[09:31:15.258]                       invokeRestart <- base::invokeRestart
[09:31:15.258]                       is.null <- base::is.null
[09:31:15.258]                       muffled <- FALSE
[09:31:15.258]                       if (inherits(cond, "message")) {
[09:31:15.258]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.258]                         if (muffled) 
[09:31:15.258]                           invokeRestart("muffleMessage")
[09:31:15.258]                       }
[09:31:15.258]                       else if (inherits(cond, "warning")) {
[09:31:15.258]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.258]                         if (muffled) 
[09:31:15.258]                           invokeRestart("muffleWarning")
[09:31:15.258]                       }
[09:31:15.258]                       else if (inherits(cond, "condition")) {
[09:31:15.258]                         if (!is.null(pattern)) {
[09:31:15.258]                           computeRestarts <- base::computeRestarts
[09:31:15.258]                           grepl <- base::grepl
[09:31:15.258]                           restarts <- computeRestarts(cond)
[09:31:15.258]                           for (restart in restarts) {
[09:31:15.258]                             name <- restart$name
[09:31:15.258]                             if (is.null(name)) 
[09:31:15.258]                               next
[09:31:15.258]                             if (!grepl(pattern, name)) 
[09:31:15.258]                               next
[09:31:15.258]                             invokeRestart(restart)
[09:31:15.258]                             muffled <- TRUE
[09:31:15.258]                             break
[09:31:15.258]                           }
[09:31:15.258]                         }
[09:31:15.258]                       }
[09:31:15.258]                       invisible(muffled)
[09:31:15.258]                     }
[09:31:15.258]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.258]                   }
[09:31:15.258]                 }
[09:31:15.258]             }
[09:31:15.258]         }))
[09:31:15.258]     }, error = function(ex) {
[09:31:15.258]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.258]                 ...future.rng), started = ...future.startTime, 
[09:31:15.258]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.258]             version = "1.8"), class = "FutureResult")
[09:31:15.258]     }, finally = {
[09:31:15.258]         if (!identical(...future.workdir, getwd())) 
[09:31:15.258]             setwd(...future.workdir)
[09:31:15.258]         {
[09:31:15.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.258]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.258]             }
[09:31:15.258]             base::options(...future.oldOptions)
[09:31:15.258]             if (.Platform$OS.type == "windows") {
[09:31:15.258]                 old_names <- names(...future.oldEnvVars)
[09:31:15.258]                 envs <- base::Sys.getenv()
[09:31:15.258]                 names <- names(envs)
[09:31:15.258]                 common <- intersect(names, old_names)
[09:31:15.258]                 added <- setdiff(names, old_names)
[09:31:15.258]                 removed <- setdiff(old_names, names)
[09:31:15.258]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.258]                   envs[common]]
[09:31:15.258]                 NAMES <- toupper(changed)
[09:31:15.258]                 args <- list()
[09:31:15.258]                 for (kk in seq_along(NAMES)) {
[09:31:15.258]                   name <- changed[[kk]]
[09:31:15.258]                   NAME <- NAMES[[kk]]
[09:31:15.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.258]                     next
[09:31:15.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.258]                 }
[09:31:15.258]                 NAMES <- toupper(added)
[09:31:15.258]                 for (kk in seq_along(NAMES)) {
[09:31:15.258]                   name <- added[[kk]]
[09:31:15.258]                   NAME <- NAMES[[kk]]
[09:31:15.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.258]                     next
[09:31:15.258]                   args[[name]] <- ""
[09:31:15.258]                 }
[09:31:15.258]                 NAMES <- toupper(removed)
[09:31:15.258]                 for (kk in seq_along(NAMES)) {
[09:31:15.258]                   name <- removed[[kk]]
[09:31:15.258]                   NAME <- NAMES[[kk]]
[09:31:15.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.258]                     next
[09:31:15.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.258]                 }
[09:31:15.258]                 if (length(args) > 0) 
[09:31:15.258]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.258]             }
[09:31:15.258]             else {
[09:31:15.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.258]             }
[09:31:15.258]             {
[09:31:15.258]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.258]                   0L) {
[09:31:15.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.258]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.258]                   base::options(opts)
[09:31:15.258]                 }
[09:31:15.258]                 {
[09:31:15.258]                   {
[09:31:15.258]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.258]                     NULL
[09:31:15.258]                   }
[09:31:15.258]                   options(future.plan = NULL)
[09:31:15.258]                   if (is.na(NA_character_)) 
[09:31:15.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.258]                     .init = FALSE)
[09:31:15.258]                 }
[09:31:15.258]             }
[09:31:15.258]         }
[09:31:15.258]     })
[09:31:15.258]     if (TRUE) {
[09:31:15.258]         base::sink(type = "output", split = FALSE)
[09:31:15.258]         if (TRUE) {
[09:31:15.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.258]         }
[09:31:15.258]         else {
[09:31:15.258]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.258]         }
[09:31:15.258]         base::close(...future.stdout)
[09:31:15.258]         ...future.stdout <- NULL
[09:31:15.258]     }
[09:31:15.258]     ...future.result$conditions <- ...future.conditions
[09:31:15.258]     ...future.result$finished <- base::Sys.time()
[09:31:15.258]     ...future.result
[09:31:15.258] }
[09:31:15.261] requestCore(): workers = 2
[09:31:15.264] MulticoreFuture started
[09:31:15.264] - Launch lazy future ... done
[09:31:15.264] run() for ‘MulticoreFuture’ ... done
[09:31:15.265] plan(): Setting new future strategy stack:
[09:31:15.265] getGlobalsAndPackages() ...
[09:31:15.265] Searching for globals...
[09:31:15.265] List of future strategies:
[09:31:15.265] 1. sequential:
[09:31:15.265]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.265]    - tweaked: FALSE
[09:31:15.265]    - call: NULL
[09:31:15.266] plan(): nbrOfWorkers() = 1
[09:31:15.267] - globals found: [1] ‘{’
[09:31:15.267] Searching for globals ... DONE
[09:31:15.267] Resolving globals: FALSE
[09:31:15.268] 
[09:31:15.268] 
[09:31:15.268] getGlobalsAndPackages() ... DONE
[09:31:15.268] plan(): Setting new future strategy stack:
[09:31:15.268] run() for ‘Future’ ...
[09:31:15.269] - state: ‘created’
[09:31:15.269] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.268] List of future strategies:
[09:31:15.268] 1. multicore:
[09:31:15.268]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.268]    - tweaked: FALSE
[09:31:15.268]    - call: plan(strategy)
[09:31:15.274] plan(): nbrOfWorkers() = 2
[09:31:15.274] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.274] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.274]   - Field: ‘label’
[09:31:15.274]   - Field: ‘local’
[09:31:15.274]   - Field: ‘owner’
[09:31:15.275]   - Field: ‘envir’
[09:31:15.275]   - Field: ‘workers’
[09:31:15.275]   - Field: ‘packages’
[09:31:15.275]   - Field: ‘gc’
[09:31:15.275]   - Field: ‘job’
[09:31:15.275]   - Field: ‘conditions’
[09:31:15.275]   - Field: ‘expr’
[09:31:15.276]   - Field: ‘uuid’
[09:31:15.276]   - Field: ‘seed’
[09:31:15.276]   - Field: ‘version’
[09:31:15.276]   - Field: ‘result’
[09:31:15.276]   - Field: ‘asynchronous’
[09:31:15.276]   - Field: ‘calls’
[09:31:15.276]   - Field: ‘globals’
[09:31:15.277]   - Field: ‘stdout’
[09:31:15.277]   - Field: ‘earlySignal’
[09:31:15.277]   - Field: ‘lazy’
[09:31:15.277]   - Field: ‘state’
[09:31:15.277] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.277] - Launch lazy future ...
[09:31:15.278] Packages needed by the future expression (n = 0): <none>
[09:31:15.278] Packages needed by future strategies (n = 0): <none>
[09:31:15.279] {
[09:31:15.279]     {
[09:31:15.279]         {
[09:31:15.279]             ...future.startTime <- base::Sys.time()
[09:31:15.279]             {
[09:31:15.279]                 {
[09:31:15.279]                   {
[09:31:15.279]                     {
[09:31:15.279]                       base::local({
[09:31:15.279]                         has_future <- base::requireNamespace("future", 
[09:31:15.279]                           quietly = TRUE)
[09:31:15.279]                         if (has_future) {
[09:31:15.279]                           ns <- base::getNamespace("future")
[09:31:15.279]                           version <- ns[[".package"]][["version"]]
[09:31:15.279]                           if (is.null(version)) 
[09:31:15.279]                             version <- utils::packageVersion("future")
[09:31:15.279]                         }
[09:31:15.279]                         else {
[09:31:15.279]                           version <- NULL
[09:31:15.279]                         }
[09:31:15.279]                         if (!has_future || version < "1.8.0") {
[09:31:15.279]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.279]                             "", base::R.version$version.string), 
[09:31:15.279]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.279]                               "release", "version")], collapse = " "), 
[09:31:15.279]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.279]                             info)
[09:31:15.279]                           info <- base::paste(info, collapse = "; ")
[09:31:15.279]                           if (!has_future) {
[09:31:15.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.279]                               info)
[09:31:15.279]                           }
[09:31:15.279]                           else {
[09:31:15.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.279]                               info, version)
[09:31:15.279]                           }
[09:31:15.279]                           base::stop(msg)
[09:31:15.279]                         }
[09:31:15.279]                       })
[09:31:15.279]                     }
[09:31:15.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.279]                     base::options(mc.cores = 1L)
[09:31:15.279]                   }
[09:31:15.279]                   ...future.strategy.old <- future::plan("list")
[09:31:15.279]                   options(future.plan = NULL)
[09:31:15.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.279]                 }
[09:31:15.279]                 ...future.workdir <- getwd()
[09:31:15.279]             }
[09:31:15.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.279]         }
[09:31:15.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.279]             base::names(...future.oldOptions))
[09:31:15.279]     }
[09:31:15.279]     if (FALSE) {
[09:31:15.279]     }
[09:31:15.279]     else {
[09:31:15.279]         if (TRUE) {
[09:31:15.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.279]                 open = "w")
[09:31:15.279]         }
[09:31:15.279]         else {
[09:31:15.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.279]         }
[09:31:15.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.279]             base::sink(type = "output", split = FALSE)
[09:31:15.279]             base::close(...future.stdout)
[09:31:15.279]         }, add = TRUE)
[09:31:15.279]     }
[09:31:15.279]     ...future.frame <- base::sys.nframe()
[09:31:15.279]     ...future.conditions <- base::list()
[09:31:15.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.279]     if (FALSE) {
[09:31:15.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.279]     }
[09:31:15.279]     ...future.result <- base::tryCatch({
[09:31:15.279]         base::withCallingHandlers({
[09:31:15.279]             ...future.value <- base::withVisible(base::local({
[09:31:15.279]                 withCallingHandlers({
[09:31:15.279]                   {
[09:31:15.279]                     4
[09:31:15.279]                   }
[09:31:15.279]                 }, immediateCondition = function(cond) {
[09:31:15.279]                   save_rds <- function (object, pathname, ...) 
[09:31:15.279]                   {
[09:31:15.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.279]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.279]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.279]                         fi_tmp[["mtime"]])
[09:31:15.279]                     }
[09:31:15.279]                     tryCatch({
[09:31:15.279]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.279]                     }, error = function(ex) {
[09:31:15.279]                       msg <- conditionMessage(ex)
[09:31:15.279]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.279]                         fi_tmp[["mtime"]], msg)
[09:31:15.279]                       ex$message <- msg
[09:31:15.279]                       stop(ex)
[09:31:15.279]                     })
[09:31:15.279]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.279]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.279]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.279]                       fi <- file.info(pathname)
[09:31:15.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.279]                         fi[["size"]], fi[["mtime"]])
[09:31:15.279]                       stop(msg)
[09:31:15.279]                     }
[09:31:15.279]                     invisible(pathname)
[09:31:15.279]                   }
[09:31:15.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.279]                     rootPath = tempdir()) 
[09:31:15.279]                   {
[09:31:15.279]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.279]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.279]                       tmpdir = path, fileext = ".rds")
[09:31:15.279]                     save_rds(obj, file)
[09:31:15.279]                   }
[09:31:15.279]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.279]                   {
[09:31:15.279]                     inherits <- base::inherits
[09:31:15.279]                     invokeRestart <- base::invokeRestart
[09:31:15.279]                     is.null <- base::is.null
[09:31:15.279]                     muffled <- FALSE
[09:31:15.279]                     if (inherits(cond, "message")) {
[09:31:15.279]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.279]                       if (muffled) 
[09:31:15.279]                         invokeRestart("muffleMessage")
[09:31:15.279]                     }
[09:31:15.279]                     else if (inherits(cond, "warning")) {
[09:31:15.279]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.279]                       if (muffled) 
[09:31:15.279]                         invokeRestart("muffleWarning")
[09:31:15.279]                     }
[09:31:15.279]                     else if (inherits(cond, "condition")) {
[09:31:15.279]                       if (!is.null(pattern)) {
[09:31:15.279]                         computeRestarts <- base::computeRestarts
[09:31:15.279]                         grepl <- base::grepl
[09:31:15.279]                         restarts <- computeRestarts(cond)
[09:31:15.279]                         for (restart in restarts) {
[09:31:15.279]                           name <- restart$name
[09:31:15.279]                           if (is.null(name)) 
[09:31:15.279]                             next
[09:31:15.279]                           if (!grepl(pattern, name)) 
[09:31:15.279]                             next
[09:31:15.279]                           invokeRestart(restart)
[09:31:15.279]                           muffled <- TRUE
[09:31:15.279]                           break
[09:31:15.279]                         }
[09:31:15.279]                       }
[09:31:15.279]                     }
[09:31:15.279]                     invisible(muffled)
[09:31:15.279]                   }
[09:31:15.279]                   muffleCondition(cond)
[09:31:15.279]                 })
[09:31:15.279]             }))
[09:31:15.279]             future::FutureResult(value = ...future.value$value, 
[09:31:15.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.279]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.279]                     ...future.globalenv.names))
[09:31:15.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.279]         }, condition = base::local({
[09:31:15.279]             c <- base::c
[09:31:15.279]             inherits <- base::inherits
[09:31:15.279]             invokeRestart <- base::invokeRestart
[09:31:15.279]             length <- base::length
[09:31:15.279]             list <- base::list
[09:31:15.279]             seq.int <- base::seq.int
[09:31:15.279]             signalCondition <- base::signalCondition
[09:31:15.279]             sys.calls <- base::sys.calls
[09:31:15.279]             `[[` <- base::`[[`
[09:31:15.279]             `+` <- base::`+`
[09:31:15.279]             `<<-` <- base::`<<-`
[09:31:15.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.279]                   3L)]
[09:31:15.279]             }
[09:31:15.279]             function(cond) {
[09:31:15.279]                 is_error <- inherits(cond, "error")
[09:31:15.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.279]                   NULL)
[09:31:15.279]                 if (is_error) {
[09:31:15.279]                   sessionInformation <- function() {
[09:31:15.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.279]                       search = base::search(), system = base::Sys.info())
[09:31:15.279]                   }
[09:31:15.279]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.279]                     cond$call), session = sessionInformation(), 
[09:31:15.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.279]                   signalCondition(cond)
[09:31:15.279]                 }
[09:31:15.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.279]                 "immediateCondition"))) {
[09:31:15.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.279]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.279]                   if (TRUE && !signal) {
[09:31:15.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.279]                     {
[09:31:15.279]                       inherits <- base::inherits
[09:31:15.279]                       invokeRestart <- base::invokeRestart
[09:31:15.279]                       is.null <- base::is.null
[09:31:15.279]                       muffled <- FALSE
[09:31:15.279]                       if (inherits(cond, "message")) {
[09:31:15.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.279]                         if (muffled) 
[09:31:15.279]                           invokeRestart("muffleMessage")
[09:31:15.279]                       }
[09:31:15.279]                       else if (inherits(cond, "warning")) {
[09:31:15.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.279]                         if (muffled) 
[09:31:15.279]                           invokeRestart("muffleWarning")
[09:31:15.279]                       }
[09:31:15.279]                       else if (inherits(cond, "condition")) {
[09:31:15.279]                         if (!is.null(pattern)) {
[09:31:15.279]                           computeRestarts <- base::computeRestarts
[09:31:15.279]                           grepl <- base::grepl
[09:31:15.279]                           restarts <- computeRestarts(cond)
[09:31:15.279]                           for (restart in restarts) {
[09:31:15.279]                             name <- restart$name
[09:31:15.279]                             if (is.null(name)) 
[09:31:15.279]                               next
[09:31:15.279]                             if (!grepl(pattern, name)) 
[09:31:15.279]                               next
[09:31:15.279]                             invokeRestart(restart)
[09:31:15.279]                             muffled <- TRUE
[09:31:15.279]                             break
[09:31:15.279]                           }
[09:31:15.279]                         }
[09:31:15.279]                       }
[09:31:15.279]                       invisible(muffled)
[09:31:15.279]                     }
[09:31:15.279]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.279]                   }
[09:31:15.279]                 }
[09:31:15.279]                 else {
[09:31:15.279]                   if (TRUE) {
[09:31:15.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.279]                     {
[09:31:15.279]                       inherits <- base::inherits
[09:31:15.279]                       invokeRestart <- base::invokeRestart
[09:31:15.279]                       is.null <- base::is.null
[09:31:15.279]                       muffled <- FALSE
[09:31:15.279]                       if (inherits(cond, "message")) {
[09:31:15.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.279]                         if (muffled) 
[09:31:15.279]                           invokeRestart("muffleMessage")
[09:31:15.279]                       }
[09:31:15.279]                       else if (inherits(cond, "warning")) {
[09:31:15.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.279]                         if (muffled) 
[09:31:15.279]                           invokeRestart("muffleWarning")
[09:31:15.279]                       }
[09:31:15.279]                       else if (inherits(cond, "condition")) {
[09:31:15.279]                         if (!is.null(pattern)) {
[09:31:15.279]                           computeRestarts <- base::computeRestarts
[09:31:15.279]                           grepl <- base::grepl
[09:31:15.279]                           restarts <- computeRestarts(cond)
[09:31:15.279]                           for (restart in restarts) {
[09:31:15.279]                             name <- restart$name
[09:31:15.279]                             if (is.null(name)) 
[09:31:15.279]                               next
[09:31:15.279]                             if (!grepl(pattern, name)) 
[09:31:15.279]                               next
[09:31:15.279]                             invokeRestart(restart)
[09:31:15.279]                             muffled <- TRUE
[09:31:15.279]                             break
[09:31:15.279]                           }
[09:31:15.279]                         }
[09:31:15.279]                       }
[09:31:15.279]                       invisible(muffled)
[09:31:15.279]                     }
[09:31:15.279]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.279]                   }
[09:31:15.279]                 }
[09:31:15.279]             }
[09:31:15.279]         }))
[09:31:15.279]     }, error = function(ex) {
[09:31:15.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.279]                 ...future.rng), started = ...future.startTime, 
[09:31:15.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.279]             version = "1.8"), class = "FutureResult")
[09:31:15.279]     }, finally = {
[09:31:15.279]         if (!identical(...future.workdir, getwd())) 
[09:31:15.279]             setwd(...future.workdir)
[09:31:15.279]         {
[09:31:15.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.279]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.279]             }
[09:31:15.279]             base::options(...future.oldOptions)
[09:31:15.279]             if (.Platform$OS.type == "windows") {
[09:31:15.279]                 old_names <- names(...future.oldEnvVars)
[09:31:15.279]                 envs <- base::Sys.getenv()
[09:31:15.279]                 names <- names(envs)
[09:31:15.279]                 common <- intersect(names, old_names)
[09:31:15.279]                 added <- setdiff(names, old_names)
[09:31:15.279]                 removed <- setdiff(old_names, names)
[09:31:15.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.279]                   envs[common]]
[09:31:15.279]                 NAMES <- toupper(changed)
[09:31:15.279]                 args <- list()
[09:31:15.279]                 for (kk in seq_along(NAMES)) {
[09:31:15.279]                   name <- changed[[kk]]
[09:31:15.279]                   NAME <- NAMES[[kk]]
[09:31:15.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.279]                     next
[09:31:15.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.279]                 }
[09:31:15.279]                 NAMES <- toupper(added)
[09:31:15.279]                 for (kk in seq_along(NAMES)) {
[09:31:15.279]                   name <- added[[kk]]
[09:31:15.279]                   NAME <- NAMES[[kk]]
[09:31:15.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.279]                     next
[09:31:15.279]                   args[[name]] <- ""
[09:31:15.279]                 }
[09:31:15.279]                 NAMES <- toupper(removed)
[09:31:15.279]                 for (kk in seq_along(NAMES)) {
[09:31:15.279]                   name <- removed[[kk]]
[09:31:15.279]                   NAME <- NAMES[[kk]]
[09:31:15.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.279]                     next
[09:31:15.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.279]                 }
[09:31:15.279]                 if (length(args) > 0) 
[09:31:15.279]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.279]             }
[09:31:15.279]             else {
[09:31:15.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.279]             }
[09:31:15.279]             {
[09:31:15.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.279]                   0L) {
[09:31:15.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.279]                   base::options(opts)
[09:31:15.279]                 }
[09:31:15.279]                 {
[09:31:15.279]                   {
[09:31:15.279]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.279]                     NULL
[09:31:15.279]                   }
[09:31:15.279]                   options(future.plan = NULL)
[09:31:15.279]                   if (is.na(NA_character_)) 
[09:31:15.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.279]                     .init = FALSE)
[09:31:15.279]                 }
[09:31:15.279]             }
[09:31:15.279]         }
[09:31:15.279]     })
[09:31:15.279]     if (TRUE) {
[09:31:15.279]         base::sink(type = "output", split = FALSE)
[09:31:15.279]         if (TRUE) {
[09:31:15.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.279]         }
[09:31:15.279]         else {
[09:31:15.279]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.279]         }
[09:31:15.279]         base::close(...future.stdout)
[09:31:15.279]         ...future.stdout <- NULL
[09:31:15.279]     }
[09:31:15.279]     ...future.result$conditions <- ...future.conditions
[09:31:15.279]     ...future.result$finished <- base::Sys.time()
[09:31:15.279]     ...future.result
[09:31:15.279] }
[09:31:15.282] requestCore(): workers = 2
[09:31:15.282] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:15.293] result() for MulticoreFuture ...
[09:31:15.294] result() for MulticoreFuture ...
[09:31:15.294] result() for MulticoreFuture ... done
[09:31:15.294] result() for MulticoreFuture ... done
[09:31:15.294] result() for MulticoreFuture ...
[09:31:15.294] result() for MulticoreFuture ... done
[09:31:15.297] MulticoreFuture started
[09:31:15.297] - Launch lazy future ... done
[09:31:15.298] run() for ‘MulticoreFuture’ ... done
[09:31:15.298] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a3ccd20078> 
[09:31:15.299] List of future strategies:
[09:31:15.299] 1. sequential:
[09:31:15.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.299]    - tweaked: FALSE
[09:31:15.299]    - call: NULL
[09:31:15.300] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a3ca636d00> 
 - attr(*, "dim.")=[09:31:15.303] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ :[09:31:15.303] List of future strategies:
[09:31:15.303] 1. multicore:
[09:31:15.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.303]    - tweaked: FALSE
[09:31:15.303]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[09:31:15.309] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:15.313] resolve() on list environment ...
[09:31:15.314]  recursive: 0
[09:31:15.315]  length: 6
[09:31:15.315]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:15.316] signalConditionsASAP(numeric, pos=1) ...
[09:31:15.316] - nx: 6
[09:31:15.316] - relay: TRUE
[09:31:15.316] - stdout: TRUE
[09:31:15.316] - signal: TRUE
[09:31:15.316] - resignal: FALSE
[09:31:15.317] - force: TRUE
[09:31:15.317] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.317] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.317]  - until=2
[09:31:15.317]  - relaying element #2
[09:31:15.317] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.317] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.318] signalConditionsASAP(NULL, pos=1) ... done
[09:31:15.318]  length: 5 (resolved future 1)
[09:31:15.318] Future #2
[09:31:15.318] result() for MulticoreFuture ...
[09:31:15.318] result() for MulticoreFuture ... done
[09:31:15.318] result() for MulticoreFuture ...
[09:31:15.319] result() for MulticoreFuture ... done
[09:31:15.319] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:15.319] - nx: 6
[09:31:15.319] - relay: TRUE
[09:31:15.319] - stdout: TRUE
[09:31:15.319] - signal: TRUE
[09:31:15.319] - resignal: FALSE
[09:31:15.320] - force: TRUE
[09:31:15.320] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.320] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.320]  - until=2
[09:31:15.320]  - relaying element #2
[09:31:15.320] result() for MulticoreFuture ...
[09:31:15.320] result() for MulticoreFuture ... done
[09:31:15.321] result() for MulticoreFuture ...
[09:31:15.321] result() for MulticoreFuture ... done
[09:31:15.321] result() for MulticoreFuture ...
[09:31:15.321] result() for MulticoreFuture ... done
[09:31:15.321] result() for MulticoreFuture ...
[09:31:15.321] result() for MulticoreFuture ... done
[09:31:15.321] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.321] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.322] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:15.322]  length: 4 (resolved future 2)
[09:31:15.322] Future #3
[09:31:15.322] result() for MulticoreFuture ...
[09:31:15.323] result() for MulticoreFuture ...
[09:31:15.323] result() for MulticoreFuture ... done
[09:31:15.323] result() for MulticoreFuture ... done
[09:31:15.323] result() for MulticoreFuture ...
[09:31:15.324] result() for MulticoreFuture ... done
[09:31:15.324] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:15.324] - nx: 6
[09:31:15.324] - relay: TRUE
[09:31:15.324] - stdout: TRUE
[09:31:15.324] - signal: TRUE
[09:31:15.324] - resignal: FALSE
[09:31:15.324] - force: TRUE
[09:31:15.325] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.325] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.325]  - until=3
[09:31:15.325]  - relaying element #3
[09:31:15.325] result() for MulticoreFuture ...
[09:31:15.325] result() for MulticoreFuture ... done
[09:31:15.325] result() for MulticoreFuture ...
[09:31:15.325] result() for MulticoreFuture ... done
[09:31:15.326] result() for MulticoreFuture ...
[09:31:15.326] result() for MulticoreFuture ... done
[09:31:15.326] result() for MulticoreFuture ...
[09:31:15.326] result() for MulticoreFuture ... done
[09:31:15.326] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.326] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.326] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:15.327]  length: 3 (resolved future 3)
[09:31:15.327] Future #4
[09:31:15.327] result() for MulticoreFuture ...
[09:31:15.328] result() for MulticoreFuture ...
[09:31:15.328] result() for MulticoreFuture ... done
[09:31:15.328] result() for MulticoreFuture ... done
[09:31:15.328] result() for MulticoreFuture ...
[09:31:15.329] result() for MulticoreFuture ... done
[09:31:15.329] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:15.329] - nx: 6
[09:31:15.329] - relay: TRUE
[09:31:15.329] - stdout: TRUE
[09:31:15.329] - signal: TRUE
[09:31:15.330] - resignal: FALSE
[09:31:15.330] - force: TRUE
[09:31:15.330] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.330] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.330]  - until=4
[09:31:15.330]  - relaying element #4
[09:31:15.331] result() for MulticoreFuture ...
[09:31:15.331] result() for MulticoreFuture ... done
[09:31:15.331] result() for MulticoreFuture ...
[09:31:15.331] result() for MulticoreFuture ... done
[09:31:15.331] result() for MulticoreFuture ...
[09:31:15.331] result() for MulticoreFuture ... done
[09:31:15.332] result() for MulticoreFuture ...
[09:31:15.332] result() for MulticoreFuture ... done
[09:31:15.332] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.332] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.332] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:15.332]  length: 2 (resolved future 4)
[09:31:15.332] signalConditionsASAP(NULL, pos=5) ...
[09:31:15.333] - nx: 6
[09:31:15.333] - relay: TRUE
[09:31:15.333] - stdout: TRUE
[09:31:15.333] - signal: TRUE
[09:31:15.333] - resignal: FALSE
[09:31:15.333] - force: TRUE
[09:31:15.333] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.333] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.333]  - until=6
[09:31:15.333]  - relaying element #6
[09:31:15.334] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.334] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.334] signalConditionsASAP(NULL, pos=5) ... done
[09:31:15.334]  length: 1 (resolved future 5)
[09:31:15.334] signalConditionsASAP(numeric, pos=6) ...
[09:31:15.334] - nx: 6
[09:31:15.334] - relay: TRUE
[09:31:15.334] - stdout: TRUE
[09:31:15.334] - signal: TRUE
[09:31:15.334] - resignal: FALSE
[09:31:15.335] - force: TRUE
[09:31:15.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.335] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.335]  - until=6
[09:31:15.335] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.335] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.335] signalConditionsASAP(numeric, pos=6) ... done
[09:31:15.335]  length: 0 (resolved future 6)
[09:31:15.335] Relaying remaining futures
[09:31:15.335] signalConditionsASAP(NULL, pos=0) ...
[09:31:15.336] - nx: 6
[09:31:15.336] - relay: TRUE
[09:31:15.336] - stdout: TRUE
[09:31:15.336] - signal: TRUE
[09:31:15.336] - resignal: FALSE
[09:31:15.336] - force: TRUE
[09:31:15.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:15.336] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.336] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.337] signalConditionsASAP(NULL, pos=0) ... done
[09:31:15.337] resolve() on list environment ... DONE
[09:31:15.337] result() for MulticoreFuture ...
[09:31:15.337] result() for MulticoreFuture ... done
[09:31:15.337] result() for MulticoreFuture ...
[09:31:15.337] result() for MulticoreFuture ... done
[09:31:15.337] result() for MulticoreFuture ...
[09:31:15.337] result() for MulticoreFuture ... done
[09:31:15.338] result() for MulticoreFuture ...
[09:31:15.338] result() for MulticoreFuture ... done
[09:31:15.338] result() for MulticoreFuture ...
[09:31:15.338] result() for MulticoreFuture ... done
[09:31:15.338] result() for MulticoreFuture ...
[09:31:15.338] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3c92eec28> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:15.340] getGlobalsAndPackages() ...
[09:31:15.340] Searching for globals...
[09:31:15.341] 
[09:31:15.341] Searching for globals ... DONE
[09:31:15.341] - globals: [0] <none>
[09:31:15.341] getGlobalsAndPackages() ... DONE
[09:31:15.341] run() for ‘Future’ ...
[09:31:15.341] - state: ‘created’
[09:31:15.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.346]   - Field: ‘label’
[09:31:15.346]   - Field: ‘local’
[09:31:15.346]   - Field: ‘owner’
[09:31:15.346]   - Field: ‘envir’
[09:31:15.346]   - Field: ‘workers’
[09:31:15.347]   - Field: ‘packages’
[09:31:15.347]   - Field: ‘gc’
[09:31:15.347]   - Field: ‘job’
[09:31:15.347]   - Field: ‘conditions’
[09:31:15.347]   - Field: ‘expr’
[09:31:15.347]   - Field: ‘uuid’
[09:31:15.347]   - Field: ‘seed’
[09:31:15.347]   - Field: ‘version’
[09:31:15.347]   - Field: ‘result’
[09:31:15.347]   - Field: ‘asynchronous’
[09:31:15.348]   - Field: ‘calls’
[09:31:15.348]   - Field: ‘globals’
[09:31:15.348]   - Field: ‘stdout’
[09:31:15.348]   - Field: ‘earlySignal’
[09:31:15.348]   - Field: ‘lazy’
[09:31:15.348]   - Field: ‘state’
[09:31:15.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.348] - Launch lazy future ...
[09:31:15.349] Packages needed by the future expression (n = 0): <none>
[09:31:15.349] Packages needed by future strategies (n = 0): <none>
[09:31:15.349] {
[09:31:15.349]     {
[09:31:15.349]         {
[09:31:15.349]             ...future.startTime <- base::Sys.time()
[09:31:15.349]             {
[09:31:15.349]                 {
[09:31:15.349]                   {
[09:31:15.349]                     {
[09:31:15.349]                       base::local({
[09:31:15.349]                         has_future <- base::requireNamespace("future", 
[09:31:15.349]                           quietly = TRUE)
[09:31:15.349]                         if (has_future) {
[09:31:15.349]                           ns <- base::getNamespace("future")
[09:31:15.349]                           version <- ns[[".package"]][["version"]]
[09:31:15.349]                           if (is.null(version)) 
[09:31:15.349]                             version <- utils::packageVersion("future")
[09:31:15.349]                         }
[09:31:15.349]                         else {
[09:31:15.349]                           version <- NULL
[09:31:15.349]                         }
[09:31:15.349]                         if (!has_future || version < "1.8.0") {
[09:31:15.349]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.349]                             "", base::R.version$version.string), 
[09:31:15.349]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.349]                               "release", "version")], collapse = " "), 
[09:31:15.349]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.349]                             info)
[09:31:15.349]                           info <- base::paste(info, collapse = "; ")
[09:31:15.349]                           if (!has_future) {
[09:31:15.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.349]                               info)
[09:31:15.349]                           }
[09:31:15.349]                           else {
[09:31:15.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.349]                               info, version)
[09:31:15.349]                           }
[09:31:15.349]                           base::stop(msg)
[09:31:15.349]                         }
[09:31:15.349]                       })
[09:31:15.349]                     }
[09:31:15.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.349]                     base::options(mc.cores = 1L)
[09:31:15.349]                   }
[09:31:15.349]                   ...future.strategy.old <- future::plan("list")
[09:31:15.349]                   options(future.plan = NULL)
[09:31:15.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.349]                 }
[09:31:15.349]                 ...future.workdir <- getwd()
[09:31:15.349]             }
[09:31:15.349]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.349]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.349]         }
[09:31:15.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.349]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.349]             base::names(...future.oldOptions))
[09:31:15.349]     }
[09:31:15.349]     if (FALSE) {
[09:31:15.349]     }
[09:31:15.349]     else {
[09:31:15.349]         if (TRUE) {
[09:31:15.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.349]                 open = "w")
[09:31:15.349]         }
[09:31:15.349]         else {
[09:31:15.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.349]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.349]         }
[09:31:15.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.349]             base::sink(type = "output", split = FALSE)
[09:31:15.349]             base::close(...future.stdout)
[09:31:15.349]         }, add = TRUE)
[09:31:15.349]     }
[09:31:15.349]     ...future.frame <- base::sys.nframe()
[09:31:15.349]     ...future.conditions <- base::list()
[09:31:15.349]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.349]     if (FALSE) {
[09:31:15.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.349]     }
[09:31:15.349]     ...future.result <- base::tryCatch({
[09:31:15.349]         base::withCallingHandlers({
[09:31:15.349]             ...future.value <- base::withVisible(base::local({
[09:31:15.349]                 withCallingHandlers({
[09:31:15.349]                   2
[09:31:15.349]                 }, immediateCondition = function(cond) {
[09:31:15.349]                   save_rds <- function (object, pathname, ...) 
[09:31:15.349]                   {
[09:31:15.349]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.349]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.349]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.349]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.349]                         fi_tmp[["mtime"]])
[09:31:15.349]                     }
[09:31:15.349]                     tryCatch({
[09:31:15.349]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.349]                     }, error = function(ex) {
[09:31:15.349]                       msg <- conditionMessage(ex)
[09:31:15.349]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.349]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.349]                         fi_tmp[["mtime"]], msg)
[09:31:15.349]                       ex$message <- msg
[09:31:15.349]                       stop(ex)
[09:31:15.349]                     })
[09:31:15.349]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.349]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.349]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.349]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.349]                       fi <- file.info(pathname)
[09:31:15.349]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.349]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.349]                         fi[["size"]], fi[["mtime"]])
[09:31:15.349]                       stop(msg)
[09:31:15.349]                     }
[09:31:15.349]                     invisible(pathname)
[09:31:15.349]                   }
[09:31:15.349]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.349]                     rootPath = tempdir()) 
[09:31:15.349]                   {
[09:31:15.349]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.349]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.349]                       tmpdir = path, fileext = ".rds")
[09:31:15.349]                     save_rds(obj, file)
[09:31:15.349]                   }
[09:31:15.349]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.349]                   {
[09:31:15.349]                     inherits <- base::inherits
[09:31:15.349]                     invokeRestart <- base::invokeRestart
[09:31:15.349]                     is.null <- base::is.null
[09:31:15.349]                     muffled <- FALSE
[09:31:15.349]                     if (inherits(cond, "message")) {
[09:31:15.349]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.349]                       if (muffled) 
[09:31:15.349]                         invokeRestart("muffleMessage")
[09:31:15.349]                     }
[09:31:15.349]                     else if (inherits(cond, "warning")) {
[09:31:15.349]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.349]                       if (muffled) 
[09:31:15.349]                         invokeRestart("muffleWarning")
[09:31:15.349]                     }
[09:31:15.349]                     else if (inherits(cond, "condition")) {
[09:31:15.349]                       if (!is.null(pattern)) {
[09:31:15.349]                         computeRestarts <- base::computeRestarts
[09:31:15.349]                         grepl <- base::grepl
[09:31:15.349]                         restarts <- computeRestarts(cond)
[09:31:15.349]                         for (restart in restarts) {
[09:31:15.349]                           name <- restart$name
[09:31:15.349]                           if (is.null(name)) 
[09:31:15.349]                             next
[09:31:15.349]                           if (!grepl(pattern, name)) 
[09:31:15.349]                             next
[09:31:15.349]                           invokeRestart(restart)
[09:31:15.349]                           muffled <- TRUE
[09:31:15.349]                           break
[09:31:15.349]                         }
[09:31:15.349]                       }
[09:31:15.349]                     }
[09:31:15.349]                     invisible(muffled)
[09:31:15.349]                   }
[09:31:15.349]                   muffleCondition(cond)
[09:31:15.349]                 })
[09:31:15.349]             }))
[09:31:15.349]             future::FutureResult(value = ...future.value$value, 
[09:31:15.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.349]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.349]                     ...future.globalenv.names))
[09:31:15.349]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.349]         }, condition = base::local({
[09:31:15.349]             c <- base::c
[09:31:15.349]             inherits <- base::inherits
[09:31:15.349]             invokeRestart <- base::invokeRestart
[09:31:15.349]             length <- base::length
[09:31:15.349]             list <- base::list
[09:31:15.349]             seq.int <- base::seq.int
[09:31:15.349]             signalCondition <- base::signalCondition
[09:31:15.349]             sys.calls <- base::sys.calls
[09:31:15.349]             `[[` <- base::`[[`
[09:31:15.349]             `+` <- base::`+`
[09:31:15.349]             `<<-` <- base::`<<-`
[09:31:15.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.349]                   3L)]
[09:31:15.349]             }
[09:31:15.349]             function(cond) {
[09:31:15.349]                 is_error <- inherits(cond, "error")
[09:31:15.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.349]                   NULL)
[09:31:15.349]                 if (is_error) {
[09:31:15.349]                   sessionInformation <- function() {
[09:31:15.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.349]                       search = base::search(), system = base::Sys.info())
[09:31:15.349]                   }
[09:31:15.349]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.349]                     cond$call), session = sessionInformation(), 
[09:31:15.349]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.349]                   signalCondition(cond)
[09:31:15.349]                 }
[09:31:15.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.349]                 "immediateCondition"))) {
[09:31:15.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.349]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.349]                   if (TRUE && !signal) {
[09:31:15.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.349]                     {
[09:31:15.349]                       inherits <- base::inherits
[09:31:15.349]                       invokeRestart <- base::invokeRestart
[09:31:15.349]                       is.null <- base::is.null
[09:31:15.349]                       muffled <- FALSE
[09:31:15.349]                       if (inherits(cond, "message")) {
[09:31:15.349]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.349]                         if (muffled) 
[09:31:15.349]                           invokeRestart("muffleMessage")
[09:31:15.349]                       }
[09:31:15.349]                       else if (inherits(cond, "warning")) {
[09:31:15.349]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.349]                         if (muffled) 
[09:31:15.349]                           invokeRestart("muffleWarning")
[09:31:15.349]                       }
[09:31:15.349]                       else if (inherits(cond, "condition")) {
[09:31:15.349]                         if (!is.null(pattern)) {
[09:31:15.349]                           computeRestarts <- base::computeRestarts
[09:31:15.349]                           grepl <- base::grepl
[09:31:15.349]                           restarts <- computeRestarts(cond)
[09:31:15.349]                           for (restart in restarts) {
[09:31:15.349]                             name <- restart$name
[09:31:15.349]                             if (is.null(name)) 
[09:31:15.349]                               next
[09:31:15.349]                             if (!grepl(pattern, name)) 
[09:31:15.349]                               next
[09:31:15.349]                             invokeRestart(restart)
[09:31:15.349]                             muffled <- TRUE
[09:31:15.349]                             break
[09:31:15.349]                           }
[09:31:15.349]                         }
[09:31:15.349]                       }
[09:31:15.349]                       invisible(muffled)
[09:31:15.349]                     }
[09:31:15.349]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.349]                   }
[09:31:15.349]                 }
[09:31:15.349]                 else {
[09:31:15.349]                   if (TRUE) {
[09:31:15.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.349]                     {
[09:31:15.349]                       inherits <- base::inherits
[09:31:15.349]                       invokeRestart <- base::invokeRestart
[09:31:15.349]                       is.null <- base::is.null
[09:31:15.349]                       muffled <- FALSE
[09:31:15.349]                       if (inherits(cond, "message")) {
[09:31:15.349]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.349]                         if (muffled) 
[09:31:15.349]                           invokeRestart("muffleMessage")
[09:31:15.349]                       }
[09:31:15.349]                       else if (inherits(cond, "warning")) {
[09:31:15.349]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.349]                         if (muffled) 
[09:31:15.349]                           invokeRestart("muffleWarning")
[09:31:15.349]                       }
[09:31:15.349]                       else if (inherits(cond, "condition")) {
[09:31:15.349]                         if (!is.null(pattern)) {
[09:31:15.349]                           computeRestarts <- base::computeRestarts
[09:31:15.349]                           grepl <- base::grepl
[09:31:15.349]                           restarts <- computeRestarts(cond)
[09:31:15.349]                           for (restart in restarts) {
[09:31:15.349]                             name <- restart$name
[09:31:15.349]                             if (is.null(name)) 
[09:31:15.349]                               next
[09:31:15.349]                             if (!grepl(pattern, name)) 
[09:31:15.349]                               next
[09:31:15.349]                             invokeRestart(restart)
[09:31:15.349]                             muffled <- TRUE
[09:31:15.349]                             break
[09:31:15.349]                           }
[09:31:15.349]                         }
[09:31:15.349]                       }
[09:31:15.349]                       invisible(muffled)
[09:31:15.349]                     }
[09:31:15.349]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.349]                   }
[09:31:15.349]                 }
[09:31:15.349]             }
[09:31:15.349]         }))
[09:31:15.349]     }, error = function(ex) {
[09:31:15.349]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.349]                 ...future.rng), started = ...future.startTime, 
[09:31:15.349]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.349]             version = "1.8"), class = "FutureResult")
[09:31:15.349]     }, finally = {
[09:31:15.349]         if (!identical(...future.workdir, getwd())) 
[09:31:15.349]             setwd(...future.workdir)
[09:31:15.349]         {
[09:31:15.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.349]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.349]             }
[09:31:15.349]             base::options(...future.oldOptions)
[09:31:15.349]             if (.Platform$OS.type == "windows") {
[09:31:15.349]                 old_names <- names(...future.oldEnvVars)
[09:31:15.349]                 envs <- base::Sys.getenv()
[09:31:15.349]                 names <- names(envs)
[09:31:15.349]                 common <- intersect(names, old_names)
[09:31:15.349]                 added <- setdiff(names, old_names)
[09:31:15.349]                 removed <- setdiff(old_names, names)
[09:31:15.349]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.349]                   envs[common]]
[09:31:15.349]                 NAMES <- toupper(changed)
[09:31:15.349]                 args <- list()
[09:31:15.349]                 for (kk in seq_along(NAMES)) {
[09:31:15.349]                   name <- changed[[kk]]
[09:31:15.349]                   NAME <- NAMES[[kk]]
[09:31:15.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.349]                     next
[09:31:15.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.349]                 }
[09:31:15.349]                 NAMES <- toupper(added)
[09:31:15.349]                 for (kk in seq_along(NAMES)) {
[09:31:15.349]                   name <- added[[kk]]
[09:31:15.349]                   NAME <- NAMES[[kk]]
[09:31:15.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.349]                     next
[09:31:15.349]                   args[[name]] <- ""
[09:31:15.349]                 }
[09:31:15.349]                 NAMES <- toupper(removed)
[09:31:15.349]                 for (kk in seq_along(NAMES)) {
[09:31:15.349]                   name <- removed[[kk]]
[09:31:15.349]                   NAME <- NAMES[[kk]]
[09:31:15.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.349]                     next
[09:31:15.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.349]                 }
[09:31:15.349]                 if (length(args) > 0) 
[09:31:15.349]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.349]             }
[09:31:15.349]             else {
[09:31:15.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.349]             }
[09:31:15.349]             {
[09:31:15.349]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.349]                   0L) {
[09:31:15.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.349]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.349]                   base::options(opts)
[09:31:15.349]                 }
[09:31:15.349]                 {
[09:31:15.349]                   {
[09:31:15.349]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.349]                     NULL
[09:31:15.349]                   }
[09:31:15.349]                   options(future.plan = NULL)
[09:31:15.349]                   if (is.na(NA_character_)) 
[09:31:15.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.349]                     .init = FALSE)
[09:31:15.349]                 }
[09:31:15.349]             }
[09:31:15.349]         }
[09:31:15.349]     })
[09:31:15.349]     if (TRUE) {
[09:31:15.349]         base::sink(type = "output", split = FALSE)
[09:31:15.349]         if (TRUE) {
[09:31:15.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.349]         }
[09:31:15.349]         else {
[09:31:15.349]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.349]         }
[09:31:15.349]         base::close(...future.stdout)
[09:31:15.349]         ...future.stdout <- NULL
[09:31:15.349]     }
[09:31:15.349]     ...future.result$conditions <- ...future.conditions
[09:31:15.349]     ...future.result$finished <- base::Sys.time()
[09:31:15.349]     ...future.result
[09:31:15.349] }
[09:31:15.352] requestCore(): workers = 2
[09:31:15.354] MulticoreFuture started
[09:31:15.354] - Launch lazy future ... done
[09:31:15.354] run() for ‘MulticoreFuture’ ... done
[09:31:15.355] getGlobalsAndPackages() ...
[09:31:15.355] Searching for globals...
[09:31:15.355] plan(): Setting new future strategy stack:
[09:31:15.356] 
[09:31:15.356] Searching for globals ... DONE
[09:31:15.355] List of future strategies:
[09:31:15.355] 1. sequential:
[09:31:15.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.355]    - tweaked: FALSE
[09:31:15.355]    - call: NULL
[09:31:15.356] - globals: [0] <none>
[09:31:15.356] getGlobalsAndPackages() ... DONE
[09:31:15.356] plan(): nbrOfWorkers() = 1
[09:31:15.357] run() for ‘Future’ ...
[09:31:15.357] - state: ‘created’
[09:31:15.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.358] plan(): Setting new future strategy stack:
[09:31:15.358] List of future strategies:
[09:31:15.358] 1. multicore:
[09:31:15.358]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.358]    - tweaked: FALSE
[09:31:15.358]    - call: plan(strategy)
[09:31:15.362] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.362] plan(): nbrOfWorkers() = 2
[09:31:15.363]   - Field: ‘label’
[09:31:15.363]   - Field: ‘local’
[09:31:15.363]   - Field: ‘owner’
[09:31:15.363]   - Field: ‘envir’
[09:31:15.363]   - Field: ‘workers’
[09:31:15.363]   - Field: ‘packages’
[09:31:15.363]   - Field: ‘gc’
[09:31:15.364]   - Field: ‘job’
[09:31:15.364]   - Field: ‘conditions’
[09:31:15.364]   - Field: ‘expr’
[09:31:15.364]   - Field: ‘uuid’
[09:31:15.364]   - Field: ‘seed’
[09:31:15.364]   - Field: ‘version’
[09:31:15.364]   - Field: ‘result’
[09:31:15.364]   - Field: ‘asynchronous’
[09:31:15.365]   - Field: ‘calls’
[09:31:15.365]   - Field: ‘globals’
[09:31:15.365]   - Field: ‘stdout’
[09:31:15.365]   - Field: ‘earlySignal’
[09:31:15.365]   - Field: ‘lazy’
[09:31:15.365]   - Field: ‘state’
[09:31:15.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.366] - Launch lazy future ...
[09:31:15.366] Packages needed by the future expression (n = 0): <none>
[09:31:15.366] Packages needed by future strategies (n = 0): <none>
[09:31:15.367] {
[09:31:15.367]     {
[09:31:15.367]         {
[09:31:15.367]             ...future.startTime <- base::Sys.time()
[09:31:15.367]             {
[09:31:15.367]                 {
[09:31:15.367]                   {
[09:31:15.367]                     {
[09:31:15.367]                       base::local({
[09:31:15.367]                         has_future <- base::requireNamespace("future", 
[09:31:15.367]                           quietly = TRUE)
[09:31:15.367]                         if (has_future) {
[09:31:15.367]                           ns <- base::getNamespace("future")
[09:31:15.367]                           version <- ns[[".package"]][["version"]]
[09:31:15.367]                           if (is.null(version)) 
[09:31:15.367]                             version <- utils::packageVersion("future")
[09:31:15.367]                         }
[09:31:15.367]                         else {
[09:31:15.367]                           version <- NULL
[09:31:15.367]                         }
[09:31:15.367]                         if (!has_future || version < "1.8.0") {
[09:31:15.367]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.367]                             "", base::R.version$version.string), 
[09:31:15.367]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.367]                               "release", "version")], collapse = " "), 
[09:31:15.367]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.367]                             info)
[09:31:15.367]                           info <- base::paste(info, collapse = "; ")
[09:31:15.367]                           if (!has_future) {
[09:31:15.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.367]                               info)
[09:31:15.367]                           }
[09:31:15.367]                           else {
[09:31:15.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.367]                               info, version)
[09:31:15.367]                           }
[09:31:15.367]                           base::stop(msg)
[09:31:15.367]                         }
[09:31:15.367]                       })
[09:31:15.367]                     }
[09:31:15.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.367]                     base::options(mc.cores = 1L)
[09:31:15.367]                   }
[09:31:15.367]                   ...future.strategy.old <- future::plan("list")
[09:31:15.367]                   options(future.plan = NULL)
[09:31:15.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.367]                 }
[09:31:15.367]                 ...future.workdir <- getwd()
[09:31:15.367]             }
[09:31:15.367]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.367]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.367]         }
[09:31:15.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.367]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.367]             base::names(...future.oldOptions))
[09:31:15.367]     }
[09:31:15.367]     if (FALSE) {
[09:31:15.367]     }
[09:31:15.367]     else {
[09:31:15.367]         if (TRUE) {
[09:31:15.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.367]                 open = "w")
[09:31:15.367]         }
[09:31:15.367]         else {
[09:31:15.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.367]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.367]         }
[09:31:15.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.367]             base::sink(type = "output", split = FALSE)
[09:31:15.367]             base::close(...future.stdout)
[09:31:15.367]         }, add = TRUE)
[09:31:15.367]     }
[09:31:15.367]     ...future.frame <- base::sys.nframe()
[09:31:15.367]     ...future.conditions <- base::list()
[09:31:15.367]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.367]     if (FALSE) {
[09:31:15.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.367]     }
[09:31:15.367]     ...future.result <- base::tryCatch({
[09:31:15.367]         base::withCallingHandlers({
[09:31:15.367]             ...future.value <- base::withVisible(base::local({
[09:31:15.367]                 withCallingHandlers({
[09:31:15.367]                   NULL
[09:31:15.367]                 }, immediateCondition = function(cond) {
[09:31:15.367]                   save_rds <- function (object, pathname, ...) 
[09:31:15.367]                   {
[09:31:15.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.367]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.367]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.367]                         fi_tmp[["mtime"]])
[09:31:15.367]                     }
[09:31:15.367]                     tryCatch({
[09:31:15.367]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.367]                     }, error = function(ex) {
[09:31:15.367]                       msg <- conditionMessage(ex)
[09:31:15.367]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.367]                         fi_tmp[["mtime"]], msg)
[09:31:15.367]                       ex$message <- msg
[09:31:15.367]                       stop(ex)
[09:31:15.367]                     })
[09:31:15.367]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.367]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.367]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.367]                       fi <- file.info(pathname)
[09:31:15.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.367]                         fi[["size"]], fi[["mtime"]])
[09:31:15.367]                       stop(msg)
[09:31:15.367]                     }
[09:31:15.367]                     invisible(pathname)
[09:31:15.367]                   }
[09:31:15.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.367]                     rootPath = tempdir()) 
[09:31:15.367]                   {
[09:31:15.367]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.367]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.367]                       tmpdir = path, fileext = ".rds")
[09:31:15.367]                     save_rds(obj, file)
[09:31:15.367]                   }
[09:31:15.367]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.367]                   {
[09:31:15.367]                     inherits <- base::inherits
[09:31:15.367]                     invokeRestart <- base::invokeRestart
[09:31:15.367]                     is.null <- base::is.null
[09:31:15.367]                     muffled <- FALSE
[09:31:15.367]                     if (inherits(cond, "message")) {
[09:31:15.367]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.367]                       if (muffled) 
[09:31:15.367]                         invokeRestart("muffleMessage")
[09:31:15.367]                     }
[09:31:15.367]                     else if (inherits(cond, "warning")) {
[09:31:15.367]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.367]                       if (muffled) 
[09:31:15.367]                         invokeRestart("muffleWarning")
[09:31:15.367]                     }
[09:31:15.367]                     else if (inherits(cond, "condition")) {
[09:31:15.367]                       if (!is.null(pattern)) {
[09:31:15.367]                         computeRestarts <- base::computeRestarts
[09:31:15.367]                         grepl <- base::grepl
[09:31:15.367]                         restarts <- computeRestarts(cond)
[09:31:15.367]                         for (restart in restarts) {
[09:31:15.367]                           name <- restart$name
[09:31:15.367]                           if (is.null(name)) 
[09:31:15.367]                             next
[09:31:15.367]                           if (!grepl(pattern, name)) 
[09:31:15.367]                             next
[09:31:15.367]                           invokeRestart(restart)
[09:31:15.367]                           muffled <- TRUE
[09:31:15.367]                           break
[09:31:15.367]                         }
[09:31:15.367]                       }
[09:31:15.367]                     }
[09:31:15.367]                     invisible(muffled)
[09:31:15.367]                   }
[09:31:15.367]                   muffleCondition(cond)
[09:31:15.367]                 })
[09:31:15.367]             }))
[09:31:15.367]             future::FutureResult(value = ...future.value$value, 
[09:31:15.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.367]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.367]                     ...future.globalenv.names))
[09:31:15.367]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.367]         }, condition = base::local({
[09:31:15.367]             c <- base::c
[09:31:15.367]             inherits <- base::inherits
[09:31:15.367]             invokeRestart <- base::invokeRestart
[09:31:15.367]             length <- base::length
[09:31:15.367]             list <- base::list
[09:31:15.367]             seq.int <- base::seq.int
[09:31:15.367]             signalCondition <- base::signalCondition
[09:31:15.367]             sys.calls <- base::sys.calls
[09:31:15.367]             `[[` <- base::`[[`
[09:31:15.367]             `+` <- base::`+`
[09:31:15.367]             `<<-` <- base::`<<-`
[09:31:15.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.367]                   3L)]
[09:31:15.367]             }
[09:31:15.367]             function(cond) {
[09:31:15.367]                 is_error <- inherits(cond, "error")
[09:31:15.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.367]                   NULL)
[09:31:15.367]                 if (is_error) {
[09:31:15.367]                   sessionInformation <- function() {
[09:31:15.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.367]                       search = base::search(), system = base::Sys.info())
[09:31:15.367]                   }
[09:31:15.367]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.367]                     cond$call), session = sessionInformation(), 
[09:31:15.367]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.367]                   signalCondition(cond)
[09:31:15.367]                 }
[09:31:15.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.367]                 "immediateCondition"))) {
[09:31:15.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.367]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.367]                   if (TRUE && !signal) {
[09:31:15.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.367]                     {
[09:31:15.367]                       inherits <- base::inherits
[09:31:15.367]                       invokeRestart <- base::invokeRestart
[09:31:15.367]                       is.null <- base::is.null
[09:31:15.367]                       muffled <- FALSE
[09:31:15.367]                       if (inherits(cond, "message")) {
[09:31:15.367]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.367]                         if (muffled) 
[09:31:15.367]                           invokeRestart("muffleMessage")
[09:31:15.367]                       }
[09:31:15.367]                       else if (inherits(cond, "warning")) {
[09:31:15.367]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.367]                         if (muffled) 
[09:31:15.367]                           invokeRestart("muffleWarning")
[09:31:15.367]                       }
[09:31:15.367]                       else if (inherits(cond, "condition")) {
[09:31:15.367]                         if (!is.null(pattern)) {
[09:31:15.367]                           computeRestarts <- base::computeRestarts
[09:31:15.367]                           grepl <- base::grepl
[09:31:15.367]                           restarts <- computeRestarts(cond)
[09:31:15.367]                           for (restart in restarts) {
[09:31:15.367]                             name <- restart$name
[09:31:15.367]                             if (is.null(name)) 
[09:31:15.367]                               next
[09:31:15.367]                             if (!grepl(pattern, name)) 
[09:31:15.367]                               next
[09:31:15.367]                             invokeRestart(restart)
[09:31:15.367]                             muffled <- TRUE
[09:31:15.367]                             break
[09:31:15.367]                           }
[09:31:15.367]                         }
[09:31:15.367]                       }
[09:31:15.367]                       invisible(muffled)
[09:31:15.367]                     }
[09:31:15.367]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.367]                   }
[09:31:15.367]                 }
[09:31:15.367]                 else {
[09:31:15.367]                   if (TRUE) {
[09:31:15.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.367]                     {
[09:31:15.367]                       inherits <- base::inherits
[09:31:15.367]                       invokeRestart <- base::invokeRestart
[09:31:15.367]                       is.null <- base::is.null
[09:31:15.367]                       muffled <- FALSE
[09:31:15.367]                       if (inherits(cond, "message")) {
[09:31:15.367]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.367]                         if (muffled) 
[09:31:15.367]                           invokeRestart("muffleMessage")
[09:31:15.367]                       }
[09:31:15.367]                       else if (inherits(cond, "warning")) {
[09:31:15.367]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.367]                         if (muffled) 
[09:31:15.367]                           invokeRestart("muffleWarning")
[09:31:15.367]                       }
[09:31:15.367]                       else if (inherits(cond, "condition")) {
[09:31:15.367]                         if (!is.null(pattern)) {
[09:31:15.367]                           computeRestarts <- base::computeRestarts
[09:31:15.367]                           grepl <- base::grepl
[09:31:15.367]                           restarts <- computeRestarts(cond)
[09:31:15.367]                           for (restart in restarts) {
[09:31:15.367]                             name <- restart$name
[09:31:15.367]                             if (is.null(name)) 
[09:31:15.367]                               next
[09:31:15.367]                             if (!grepl(pattern, name)) 
[09:31:15.367]                               next
[09:31:15.367]                             invokeRestart(restart)
[09:31:15.367]                             muffled <- TRUE
[09:31:15.367]                             break
[09:31:15.367]                           }
[09:31:15.367]                         }
[09:31:15.367]                       }
[09:31:15.367]                       invisible(muffled)
[09:31:15.367]                     }
[09:31:15.367]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.367]                   }
[09:31:15.367]                 }
[09:31:15.367]             }
[09:31:15.367]         }))
[09:31:15.367]     }, error = function(ex) {
[09:31:15.367]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.367]                 ...future.rng), started = ...future.startTime, 
[09:31:15.367]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.367]             version = "1.8"), class = "FutureResult")
[09:31:15.367]     }, finally = {
[09:31:15.367]         if (!identical(...future.workdir, getwd())) 
[09:31:15.367]             setwd(...future.workdir)
[09:31:15.367]         {
[09:31:15.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.367]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.367]             }
[09:31:15.367]             base::options(...future.oldOptions)
[09:31:15.367]             if (.Platform$OS.type == "windows") {
[09:31:15.367]                 old_names <- names(...future.oldEnvVars)
[09:31:15.367]                 envs <- base::Sys.getenv()
[09:31:15.367]                 names <- names(envs)
[09:31:15.367]                 common <- intersect(names, old_names)
[09:31:15.367]                 added <- setdiff(names, old_names)
[09:31:15.367]                 removed <- setdiff(old_names, names)
[09:31:15.367]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.367]                   envs[common]]
[09:31:15.367]                 NAMES <- toupper(changed)
[09:31:15.367]                 args <- list()
[09:31:15.367]                 for (kk in seq_along(NAMES)) {
[09:31:15.367]                   name <- changed[[kk]]
[09:31:15.367]                   NAME <- NAMES[[kk]]
[09:31:15.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.367]                     next
[09:31:15.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.367]                 }
[09:31:15.367]                 NAMES <- toupper(added)
[09:31:15.367]                 for (kk in seq_along(NAMES)) {
[09:31:15.367]                   name <- added[[kk]]
[09:31:15.367]                   NAME <- NAMES[[kk]]
[09:31:15.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.367]                     next
[09:31:15.367]                   args[[name]] <- ""
[09:31:15.367]                 }
[09:31:15.367]                 NAMES <- toupper(removed)
[09:31:15.367]                 for (kk in seq_along(NAMES)) {
[09:31:15.367]                   name <- removed[[kk]]
[09:31:15.367]                   NAME <- NAMES[[kk]]
[09:31:15.367]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.367]                     next
[09:31:15.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.367]                 }
[09:31:15.367]                 if (length(args) > 0) 
[09:31:15.367]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.367]             }
[09:31:15.367]             else {
[09:31:15.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.367]             }
[09:31:15.367]             {
[09:31:15.367]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.367]                   0L) {
[09:31:15.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.367]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.367]                   base::options(opts)
[09:31:15.367]                 }
[09:31:15.367]                 {
[09:31:15.367]                   {
[09:31:15.367]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.367]                     NULL
[09:31:15.367]                   }
[09:31:15.367]                   options(future.plan = NULL)
[09:31:15.367]                   if (is.na(NA_character_)) 
[09:31:15.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.367]                     .init = FALSE)
[09:31:15.367]                 }
[09:31:15.367]             }
[09:31:15.367]         }
[09:31:15.367]     })
[09:31:15.367]     if (TRUE) {
[09:31:15.367]         base::sink(type = "output", split = FALSE)
[09:31:15.367]         if (TRUE) {
[09:31:15.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.367]         }
[09:31:15.367]         else {
[09:31:15.367]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.367]         }
[09:31:15.367]         base::close(...future.stdout)
[09:31:15.367]         ...future.stdout <- NULL
[09:31:15.367]     }
[09:31:15.367]     ...future.result$conditions <- ...future.conditions
[09:31:15.367]     ...future.result$finished <- base::Sys.time()
[09:31:15.367]     ...future.result
[09:31:15.367] }
[09:31:15.370] requestCore(): workers = 2
[09:31:15.372] MulticoreFuture started
[09:31:15.373] - Launch lazy future ... done
[09:31:15.373] run() for ‘MulticoreFuture’ ... done
[09:31:15.373] plan(): Setting new future strategy stack:
[09:31:15.374] getGlobalsAndPackages() ...
[09:31:15.374] Searching for globals...
[09:31:15.374] List of future strategies:
[09:31:15.374] 1. sequential:
[09:31:15.374]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.374]    - tweaked: FALSE
[09:31:15.374]    - call: NULL
[09:31:15.375] plan(): nbrOfWorkers() = 1
[09:31:15.375] - globals found: [1] ‘{’
[09:31:15.375] Searching for globals ... DONE
[09:31:15.376] Resolving globals: FALSE
[09:31:15.376] 
[09:31:15.376] 
[09:31:15.376] getGlobalsAndPackages() ... DONE
[09:31:15.377] plan(): Setting new future strategy stack:
[09:31:15.377] run() for ‘Future’ ...
[09:31:15.377] - state: ‘created’
[09:31:15.377] List of future strategies:
[09:31:15.377] 1. multicore:
[09:31:15.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.377]    - tweaked: FALSE
[09:31:15.377]    - call: plan(strategy)
[09:31:15.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.382] plan(): nbrOfWorkers() = 2
[09:31:15.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.383]   - Field: ‘label’
[09:31:15.383]   - Field: ‘local’
[09:31:15.383]   - Field: ‘owner’
[09:31:15.383]   - Field: ‘envir’
[09:31:15.383]   - Field: ‘workers’
[09:31:15.383]   - Field: ‘packages’
[09:31:15.384]   - Field: ‘gc’
[09:31:15.384]   - Field: ‘job’
[09:31:15.384]   - Field: ‘conditions’
[09:31:15.384]   - Field: ‘expr’
[09:31:15.384]   - Field: ‘uuid’
[09:31:15.384]   - Field: ‘seed’
[09:31:15.385]   - Field: ‘version’
[09:31:15.385]   - Field: ‘result’
[09:31:15.385]   - Field: ‘asynchronous’
[09:31:15.385]   - Field: ‘calls’
[09:31:15.385]   - Field: ‘globals’
[09:31:15.385]   - Field: ‘stdout’
[09:31:15.385]   - Field: ‘earlySignal’
[09:31:15.385]   - Field: ‘lazy’
[09:31:15.386]   - Field: ‘state’
[09:31:15.386] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.386] - Launch lazy future ...
[09:31:15.386] Packages needed by the future expression (n = 0): <none>
[09:31:15.386] Packages needed by future strategies (n = 0): <none>
[09:31:15.387] {
[09:31:15.387]     {
[09:31:15.387]         {
[09:31:15.387]             ...future.startTime <- base::Sys.time()
[09:31:15.387]             {
[09:31:15.387]                 {
[09:31:15.387]                   {
[09:31:15.387]                     {
[09:31:15.387]                       base::local({
[09:31:15.387]                         has_future <- base::requireNamespace("future", 
[09:31:15.387]                           quietly = TRUE)
[09:31:15.387]                         if (has_future) {
[09:31:15.387]                           ns <- base::getNamespace("future")
[09:31:15.387]                           version <- ns[[".package"]][["version"]]
[09:31:15.387]                           if (is.null(version)) 
[09:31:15.387]                             version <- utils::packageVersion("future")
[09:31:15.387]                         }
[09:31:15.387]                         else {
[09:31:15.387]                           version <- NULL
[09:31:15.387]                         }
[09:31:15.387]                         if (!has_future || version < "1.8.0") {
[09:31:15.387]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.387]                             "", base::R.version$version.string), 
[09:31:15.387]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.387]                               "release", "version")], collapse = " "), 
[09:31:15.387]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.387]                             info)
[09:31:15.387]                           info <- base::paste(info, collapse = "; ")
[09:31:15.387]                           if (!has_future) {
[09:31:15.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.387]                               info)
[09:31:15.387]                           }
[09:31:15.387]                           else {
[09:31:15.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.387]                               info, version)
[09:31:15.387]                           }
[09:31:15.387]                           base::stop(msg)
[09:31:15.387]                         }
[09:31:15.387]                       })
[09:31:15.387]                     }
[09:31:15.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.387]                     base::options(mc.cores = 1L)
[09:31:15.387]                   }
[09:31:15.387]                   ...future.strategy.old <- future::plan("list")
[09:31:15.387]                   options(future.plan = NULL)
[09:31:15.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.387]                 }
[09:31:15.387]                 ...future.workdir <- getwd()
[09:31:15.387]             }
[09:31:15.387]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.387]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.387]         }
[09:31:15.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.387]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.387]             base::names(...future.oldOptions))
[09:31:15.387]     }
[09:31:15.387]     if (FALSE) {
[09:31:15.387]     }
[09:31:15.387]     else {
[09:31:15.387]         if (TRUE) {
[09:31:15.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.387]                 open = "w")
[09:31:15.387]         }
[09:31:15.387]         else {
[09:31:15.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.387]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.387]         }
[09:31:15.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.387]             base::sink(type = "output", split = FALSE)
[09:31:15.387]             base::close(...future.stdout)
[09:31:15.387]         }, add = TRUE)
[09:31:15.387]     }
[09:31:15.387]     ...future.frame <- base::sys.nframe()
[09:31:15.387]     ...future.conditions <- base::list()
[09:31:15.387]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.387]     if (FALSE) {
[09:31:15.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.387]     }
[09:31:15.387]     ...future.result <- base::tryCatch({
[09:31:15.387]         base::withCallingHandlers({
[09:31:15.387]             ...future.value <- base::withVisible(base::local({
[09:31:15.387]                 withCallingHandlers({
[09:31:15.387]                   {
[09:31:15.387]                     4
[09:31:15.387]                   }
[09:31:15.387]                 }, immediateCondition = function(cond) {
[09:31:15.387]                   save_rds <- function (object, pathname, ...) 
[09:31:15.387]                   {
[09:31:15.387]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.387]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.387]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.387]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.387]                         fi_tmp[["mtime"]])
[09:31:15.387]                     }
[09:31:15.387]                     tryCatch({
[09:31:15.387]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.387]                     }, error = function(ex) {
[09:31:15.387]                       msg <- conditionMessage(ex)
[09:31:15.387]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.387]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.387]                         fi_tmp[["mtime"]], msg)
[09:31:15.387]                       ex$message <- msg
[09:31:15.387]                       stop(ex)
[09:31:15.387]                     })
[09:31:15.387]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.387]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.387]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.387]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.387]                       fi <- file.info(pathname)
[09:31:15.387]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.387]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.387]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.387]                         fi[["size"]], fi[["mtime"]])
[09:31:15.387]                       stop(msg)
[09:31:15.387]                     }
[09:31:15.387]                     invisible(pathname)
[09:31:15.387]                   }
[09:31:15.387]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.387]                     rootPath = tempdir()) 
[09:31:15.387]                   {
[09:31:15.387]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.387]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.387]                       tmpdir = path, fileext = ".rds")
[09:31:15.387]                     save_rds(obj, file)
[09:31:15.387]                   }
[09:31:15.387]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.387]                   {
[09:31:15.387]                     inherits <- base::inherits
[09:31:15.387]                     invokeRestart <- base::invokeRestart
[09:31:15.387]                     is.null <- base::is.null
[09:31:15.387]                     muffled <- FALSE
[09:31:15.387]                     if (inherits(cond, "message")) {
[09:31:15.387]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.387]                       if (muffled) 
[09:31:15.387]                         invokeRestart("muffleMessage")
[09:31:15.387]                     }
[09:31:15.387]                     else if (inherits(cond, "warning")) {
[09:31:15.387]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.387]                       if (muffled) 
[09:31:15.387]                         invokeRestart("muffleWarning")
[09:31:15.387]                     }
[09:31:15.387]                     else if (inherits(cond, "condition")) {
[09:31:15.387]                       if (!is.null(pattern)) {
[09:31:15.387]                         computeRestarts <- base::computeRestarts
[09:31:15.387]                         grepl <- base::grepl
[09:31:15.387]                         restarts <- computeRestarts(cond)
[09:31:15.387]                         for (restart in restarts) {
[09:31:15.387]                           name <- restart$name
[09:31:15.387]                           if (is.null(name)) 
[09:31:15.387]                             next
[09:31:15.387]                           if (!grepl(pattern, name)) 
[09:31:15.387]                             next
[09:31:15.387]                           invokeRestart(restart)
[09:31:15.387]                           muffled <- TRUE
[09:31:15.387]                           break
[09:31:15.387]                         }
[09:31:15.387]                       }
[09:31:15.387]                     }
[09:31:15.387]                     invisible(muffled)
[09:31:15.387]                   }
[09:31:15.387]                   muffleCondition(cond)
[09:31:15.387]                 })
[09:31:15.387]             }))
[09:31:15.387]             future::FutureResult(value = ...future.value$value, 
[09:31:15.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.387]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.387]                     ...future.globalenv.names))
[09:31:15.387]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.387]         }, condition = base::local({
[09:31:15.387]             c <- base::c
[09:31:15.387]             inherits <- base::inherits
[09:31:15.387]             invokeRestart <- base::invokeRestart
[09:31:15.387]             length <- base::length
[09:31:15.387]             list <- base::list
[09:31:15.387]             seq.int <- base::seq.int
[09:31:15.387]             signalCondition <- base::signalCondition
[09:31:15.387]             sys.calls <- base::sys.calls
[09:31:15.387]             `[[` <- base::`[[`
[09:31:15.387]             `+` <- base::`+`
[09:31:15.387]             `<<-` <- base::`<<-`
[09:31:15.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.387]                   3L)]
[09:31:15.387]             }
[09:31:15.387]             function(cond) {
[09:31:15.387]                 is_error <- inherits(cond, "error")
[09:31:15.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.387]                   NULL)
[09:31:15.387]                 if (is_error) {
[09:31:15.387]                   sessionInformation <- function() {
[09:31:15.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.387]                       search = base::search(), system = base::Sys.info())
[09:31:15.387]                   }
[09:31:15.387]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.387]                     cond$call), session = sessionInformation(), 
[09:31:15.387]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.387]                   signalCondition(cond)
[09:31:15.387]                 }
[09:31:15.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.387]                 "immediateCondition"))) {
[09:31:15.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.387]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.387]                   if (TRUE && !signal) {
[09:31:15.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.387]                     {
[09:31:15.387]                       inherits <- base::inherits
[09:31:15.387]                       invokeRestart <- base::invokeRestart
[09:31:15.387]                       is.null <- base::is.null
[09:31:15.387]                       muffled <- FALSE
[09:31:15.387]                       if (inherits(cond, "message")) {
[09:31:15.387]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.387]                         if (muffled) 
[09:31:15.387]                           invokeRestart("muffleMessage")
[09:31:15.387]                       }
[09:31:15.387]                       else if (inherits(cond, "warning")) {
[09:31:15.387]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.387]                         if (muffled) 
[09:31:15.387]                           invokeRestart("muffleWarning")
[09:31:15.387]                       }
[09:31:15.387]                       else if (inherits(cond, "condition")) {
[09:31:15.387]                         if (!is.null(pattern)) {
[09:31:15.387]                           computeRestarts <- base::computeRestarts
[09:31:15.387]                           grepl <- base::grepl
[09:31:15.387]                           restarts <- computeRestarts(cond)
[09:31:15.387]                           for (restart in restarts) {
[09:31:15.387]                             name <- restart$name
[09:31:15.387]                             if (is.null(name)) 
[09:31:15.387]                               next
[09:31:15.387]                             if (!grepl(pattern, name)) 
[09:31:15.387]                               next
[09:31:15.387]                             invokeRestart(restart)
[09:31:15.387]                             muffled <- TRUE
[09:31:15.387]                             break
[09:31:15.387]                           }
[09:31:15.387]                         }
[09:31:15.387]                       }
[09:31:15.387]                       invisible(muffled)
[09:31:15.387]                     }
[09:31:15.387]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.387]                   }
[09:31:15.387]                 }
[09:31:15.387]                 else {
[09:31:15.387]                   if (TRUE) {
[09:31:15.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.387]                     {
[09:31:15.387]                       inherits <- base::inherits
[09:31:15.387]                       invokeRestart <- base::invokeRestart
[09:31:15.387]                       is.null <- base::is.null
[09:31:15.387]                       muffled <- FALSE
[09:31:15.387]                       if (inherits(cond, "message")) {
[09:31:15.387]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.387]                         if (muffled) 
[09:31:15.387]                           invokeRestart("muffleMessage")
[09:31:15.387]                       }
[09:31:15.387]                       else if (inherits(cond, "warning")) {
[09:31:15.387]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.387]                         if (muffled) 
[09:31:15.387]                           invokeRestart("muffleWarning")
[09:31:15.387]                       }
[09:31:15.387]                       else if (inherits(cond, "condition")) {
[09:31:15.387]                         if (!is.null(pattern)) {
[09:31:15.387]                           computeRestarts <- base::computeRestarts
[09:31:15.387]                           grepl <- base::grepl
[09:31:15.387]                           restarts <- computeRestarts(cond)
[09:31:15.387]                           for (restart in restarts) {
[09:31:15.387]                             name <- restart$name
[09:31:15.387]                             if (is.null(name)) 
[09:31:15.387]                               next
[09:31:15.387]                             if (!grepl(pattern, name)) 
[09:31:15.387]                               next
[09:31:15.387]                             invokeRestart(restart)
[09:31:15.387]                             muffled <- TRUE
[09:31:15.387]                             break
[09:31:15.387]                           }
[09:31:15.387]                         }
[09:31:15.387]                       }
[09:31:15.387]                       invisible(muffled)
[09:31:15.387]                     }
[09:31:15.387]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.387]                   }
[09:31:15.387]                 }
[09:31:15.387]             }
[09:31:15.387]         }))
[09:31:15.387]     }, error = function(ex) {
[09:31:15.387]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.387]                 ...future.rng), started = ...future.startTime, 
[09:31:15.387]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.387]             version = "1.8"), class = "FutureResult")
[09:31:15.387]     }, finally = {
[09:31:15.387]         if (!identical(...future.workdir, getwd())) 
[09:31:15.387]             setwd(...future.workdir)
[09:31:15.387]         {
[09:31:15.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.387]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.387]             }
[09:31:15.387]             base::options(...future.oldOptions)
[09:31:15.387]             if (.Platform$OS.type == "windows") {
[09:31:15.387]                 old_names <- names(...future.oldEnvVars)
[09:31:15.387]                 envs <- base::Sys.getenv()
[09:31:15.387]                 names <- names(envs)
[09:31:15.387]                 common <- intersect(names, old_names)
[09:31:15.387]                 added <- setdiff(names, old_names)
[09:31:15.387]                 removed <- setdiff(old_names, names)
[09:31:15.387]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.387]                   envs[common]]
[09:31:15.387]                 NAMES <- toupper(changed)
[09:31:15.387]                 args <- list()
[09:31:15.387]                 for (kk in seq_along(NAMES)) {
[09:31:15.387]                   name <- changed[[kk]]
[09:31:15.387]                   NAME <- NAMES[[kk]]
[09:31:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.387]                     next
[09:31:15.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.387]                 }
[09:31:15.387]                 NAMES <- toupper(added)
[09:31:15.387]                 for (kk in seq_along(NAMES)) {
[09:31:15.387]                   name <- added[[kk]]
[09:31:15.387]                   NAME <- NAMES[[kk]]
[09:31:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.387]                     next
[09:31:15.387]                   args[[name]] <- ""
[09:31:15.387]                 }
[09:31:15.387]                 NAMES <- toupper(removed)
[09:31:15.387]                 for (kk in seq_along(NAMES)) {
[09:31:15.387]                   name <- removed[[kk]]
[09:31:15.387]                   NAME <- NAMES[[kk]]
[09:31:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.387]                     next
[09:31:15.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.387]                 }
[09:31:15.387]                 if (length(args) > 0) 
[09:31:15.387]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.387]             }
[09:31:15.387]             else {
[09:31:15.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.387]             }
[09:31:15.387]             {
[09:31:15.387]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.387]                   0L) {
[09:31:15.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.387]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.387]                   base::options(opts)
[09:31:15.387]                 }
[09:31:15.387]                 {
[09:31:15.387]                   {
[09:31:15.387]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.387]                     NULL
[09:31:15.387]                   }
[09:31:15.387]                   options(future.plan = NULL)
[09:31:15.387]                   if (is.na(NA_character_)) 
[09:31:15.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.387]                     .init = FALSE)
[09:31:15.387]                 }
[09:31:15.387]             }
[09:31:15.387]         }
[09:31:15.387]     })
[09:31:15.387]     if (TRUE) {
[09:31:15.387]         base::sink(type = "output", split = FALSE)
[09:31:15.387]         if (TRUE) {
[09:31:15.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.387]         }
[09:31:15.387]         else {
[09:31:15.387]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.387]         }
[09:31:15.387]         base::close(...future.stdout)
[09:31:15.387]         ...future.stdout <- NULL
[09:31:15.387]     }
[09:31:15.387]     ...future.result$conditions <- ...future.conditions
[09:31:15.387]     ...future.result$finished <- base::Sys.time()
[09:31:15.387]     ...future.result
[09:31:15.387] }
[09:31:15.390] requestCore(): workers = 2
[09:31:15.391] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:15.401] result() for MulticoreFuture ...
[09:31:15.402] result() for MulticoreFuture ...
[09:31:15.402] result() for MulticoreFuture ... done
[09:31:15.402] result() for MulticoreFuture ... done
[09:31:15.403] result() for MulticoreFuture ...
[09:31:15.403] result() for MulticoreFuture ... done
[09:31:15.405] MulticoreFuture started
[09:31:15.406] - Launch lazy future ... done
[09:31:15.406] run() for ‘MulticoreFuture’ ... done
[09:31:15.406] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a3cc3d0328> 
[09:31:15.407] List of future strategies:
[09:31:15.407] 1. sequential:
[09:31:15.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.407]    - tweaked: FALSE
[09:31:15.407]    - call: NULL
[09:31:15.408] plan(): nbrOfWorkers() = 1
[09:31:15.421] plan(): Setting new future strategy stack:
[09:31:15.422] List of future strategies:
[09:31:15.422] 1. multicore:
[09:31:15.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.422]    - tweaked: FALSE
[09:31:15.422]    - call: plan(strategy)
Classes 'listenv', 'environment' <environment: 0x55a3cc377a00> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:15.430] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:15.434] resolve() on list environment ...
[09:31:15.434]  recursive: 0
[09:31:15.435]  length: 6
[09:31:15.435]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:15.435] signalConditionsASAP(numeric, pos=1) ...
[09:31:15.435] - nx: 6
[09:31:15.436] - relay: TRUE
[09:31:15.436] - stdout: TRUE
[09:31:15.436] - signal: TRUE
[09:31:15.436] - resignal: FALSE
[09:31:15.436] - force: TRUE
[09:31:15.436] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.436] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.436]  - until=2
[09:31:15.437]  - relaying element #2
[09:31:15.437] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.437] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.437] signalConditionsASAP(NULL, pos=1) ... done
[09:31:15.437]  length: 5 (resolved future 1)
[09:31:15.437] Future #2
[09:31:15.437] result() for MulticoreFuture ...
[09:31:15.438] result() for MulticoreFuture ... done
[09:31:15.438] result() for MulticoreFuture ...
[09:31:15.438] result() for MulticoreFuture ... done
[09:31:15.438] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:15.438] - nx: 6
[09:31:15.438] - relay: TRUE
[09:31:15.438] - stdout: TRUE
[09:31:15.438] - signal: TRUE
[09:31:15.439] - resignal: FALSE
[09:31:15.439] - force: TRUE
[09:31:15.439] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.439] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.439]  - until=2
[09:31:15.439]  - relaying element #2
[09:31:15.439] result() for MulticoreFuture ...
[09:31:15.439] result() for MulticoreFuture ... done
[09:31:15.440] result() for MulticoreFuture ...
[09:31:15.440] result() for MulticoreFuture ... done
[09:31:15.440] result() for MulticoreFuture ...
[09:31:15.440] result() for MulticoreFuture ... done
[09:31:15.440] result() for MulticoreFuture ...
[09:31:15.440] result() for MulticoreFuture ... done
[09:31:15.440] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.440] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.441] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:15.441]  length: 4 (resolved future 2)
[09:31:15.441] Future #3
[09:31:15.441] result() for MulticoreFuture ...
[09:31:15.442] result() for MulticoreFuture ...
[09:31:15.442] result() for MulticoreFuture ... done
[09:31:15.442] result() for MulticoreFuture ... done
[09:31:15.442] result() for MulticoreFuture ...
[09:31:15.442] result() for MulticoreFuture ... done
[09:31:15.443] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:15.443] - nx: 6
[09:31:15.443] - relay: TRUE
[09:31:15.443] - stdout: TRUE
[09:31:15.443] - signal: TRUE
[09:31:15.443] - resignal: FALSE
[09:31:15.443] - force: TRUE
[09:31:15.443] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.443] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.444]  - until=3
[09:31:15.444]  - relaying element #3
[09:31:15.444] result() for MulticoreFuture ...
[09:31:15.444] result() for MulticoreFuture ... done
[09:31:15.444] result() for MulticoreFuture ...
[09:31:15.444] result() for MulticoreFuture ... done
[09:31:15.444] result() for MulticoreFuture ...
[09:31:15.445] result() for MulticoreFuture ... done
[09:31:15.445] result() for MulticoreFuture ...
[09:31:15.445] result() for MulticoreFuture ... done
[09:31:15.445] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.445] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.445] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:15.445]  length: 3 (resolved future 3)
[09:31:15.446] Future #4
[09:31:15.446] result() for MulticoreFuture ...
[09:31:15.446] result() for MulticoreFuture ...
[09:31:15.447] result() for MulticoreFuture ... done
[09:31:15.447] result() for MulticoreFuture ... done
[09:31:15.447] result() for MulticoreFuture ...
[09:31:15.447] result() for MulticoreFuture ... done
[09:31:15.447] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:15.448] - nx: 6
[09:31:15.448] - relay: TRUE
[09:31:15.448] - stdout: TRUE
[09:31:15.448] - signal: TRUE
[09:31:15.448] - resignal: FALSE
[09:31:15.448] - force: TRUE
[09:31:15.448] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.448] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.449]  - until=4
[09:31:15.449]  - relaying element #4
[09:31:15.449] result() for MulticoreFuture ...
[09:31:15.449] result() for MulticoreFuture ... done
[09:31:15.449] result() for MulticoreFuture ...
[09:31:15.449] result() for MulticoreFuture ... done
[09:31:15.450] result() for MulticoreFuture ...
[09:31:15.450] result() for MulticoreFuture ... done
[09:31:15.450] result() for MulticoreFuture ...
[09:31:15.450] result() for MulticoreFuture ... done
[09:31:15.450] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.450] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.450] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:15.451]  length: 2 (resolved future 4)
[09:31:15.451] signalConditionsASAP(NULL, pos=5) ...
[09:31:15.451] - nx: 6
[09:31:15.451] - relay: TRUE
[09:31:15.451] - stdout: TRUE
[09:31:15.451] - signal: TRUE
[09:31:15.451] - resignal: FALSE
[09:31:15.452] - force: TRUE
[09:31:15.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.452] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.452]  - until=6
[09:31:15.452]  - relaying element #6
[09:31:15.452] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.452] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.452] signalConditionsASAP(NULL, pos=5) ... done
[09:31:15.452]  length: 1 (resolved future 5)
[09:31:15.453] signalConditionsASAP(numeric, pos=6) ...
[09:31:15.453] - nx: 6
[09:31:15.453] - relay: TRUE
[09:31:15.453] - stdout: TRUE
[09:31:15.453] - signal: TRUE
[09:31:15.453] - resignal: FALSE
[09:31:15.453] - force: TRUE
[09:31:15.453] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.453] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.453]  - until=6
[09:31:15.454] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.454] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.454] signalConditionsASAP(numeric, pos=6) ... done
[09:31:15.454]  length: 0 (resolved future 6)
[09:31:15.454] Relaying remaining futures
[09:31:15.454] signalConditionsASAP(NULL, pos=0) ...
[09:31:15.454] - nx: 6
[09:31:15.454] - relay: TRUE
[09:31:15.454] - stdout: TRUE
[09:31:15.455] - signal: TRUE
[09:31:15.455] - resignal: FALSE
[09:31:15.455] - force: TRUE
[09:31:15.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.455] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:15.455] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.455] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.455] signalConditionsASAP(NULL, pos=0) ... done
[09:31:15.455] resolve() on list environment ... DONE
[09:31:15.456] result() for MulticoreFuture ...
[09:31:15.456] result() for MulticoreFuture ... done
[09:31:15.456] result() for MulticoreFuture ...
[09:31:15.456] result() for MulticoreFuture ... done
[09:31:15.456] result() for MulticoreFuture ...
[09:31:15.456] result() for MulticoreFuture ... done
[09:31:15.456] result() for MulticoreFuture ...
[09:31:15.456] result() for MulticoreFuture ... done
[09:31:15.457] result() for MulticoreFuture ...
[09:31:15.457] result() for MulticoreFuture ... done
[09:31:15.457] result() for MulticoreFuture ...
[09:31:15.457] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cb073300> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:15.459] getGlobalsAndPackages() ...
[09:31:15.460] Searching for globals...
[09:31:15.460] 
[09:31:15.460] Searching for globals ... DONE
[09:31:15.460] - globals: [0] <none>
[09:31:15.460] getGlobalsAndPackages() ... DONE
[09:31:15.461] run() for ‘Future’ ...
[09:31:15.461] - state: ‘created’
[09:31:15.461] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.465] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.465] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.465]   - Field: ‘label’
[09:31:15.465]   - Field: ‘local’
[09:31:15.465]   - Field: ‘owner’
[09:31:15.466]   - Field: ‘envir’
[09:31:15.466]   - Field: ‘workers’
[09:31:15.466]   - Field: ‘packages’
[09:31:15.466]   - Field: ‘gc’
[09:31:15.466]   - Field: ‘job’
[09:31:15.466]   - Field: ‘conditions’
[09:31:15.466]   - Field: ‘expr’
[09:31:15.466]   - Field: ‘uuid’
[09:31:15.466]   - Field: ‘seed’
[09:31:15.466]   - Field: ‘version’
[09:31:15.467]   - Field: ‘result’
[09:31:15.467]   - Field: ‘asynchronous’
[09:31:15.467]   - Field: ‘calls’
[09:31:15.467]   - Field: ‘globals’
[09:31:15.467]   - Field: ‘stdout’
[09:31:15.467]   - Field: ‘earlySignal’
[09:31:15.467]   - Field: ‘lazy’
[09:31:15.467]   - Field: ‘state’
[09:31:15.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.468] - Launch lazy future ...
[09:31:15.468] Packages needed by the future expression (n = 0): <none>
[09:31:15.468] Packages needed by future strategies (n = 0): <none>
[09:31:15.469] {
[09:31:15.469]     {
[09:31:15.469]         {
[09:31:15.469]             ...future.startTime <- base::Sys.time()
[09:31:15.469]             {
[09:31:15.469]                 {
[09:31:15.469]                   {
[09:31:15.469]                     {
[09:31:15.469]                       base::local({
[09:31:15.469]                         has_future <- base::requireNamespace("future", 
[09:31:15.469]                           quietly = TRUE)
[09:31:15.469]                         if (has_future) {
[09:31:15.469]                           ns <- base::getNamespace("future")
[09:31:15.469]                           version <- ns[[".package"]][["version"]]
[09:31:15.469]                           if (is.null(version)) 
[09:31:15.469]                             version <- utils::packageVersion("future")
[09:31:15.469]                         }
[09:31:15.469]                         else {
[09:31:15.469]                           version <- NULL
[09:31:15.469]                         }
[09:31:15.469]                         if (!has_future || version < "1.8.0") {
[09:31:15.469]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.469]                             "", base::R.version$version.string), 
[09:31:15.469]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.469]                               "release", "version")], collapse = " "), 
[09:31:15.469]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.469]                             info)
[09:31:15.469]                           info <- base::paste(info, collapse = "; ")
[09:31:15.469]                           if (!has_future) {
[09:31:15.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.469]                               info)
[09:31:15.469]                           }
[09:31:15.469]                           else {
[09:31:15.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.469]                               info, version)
[09:31:15.469]                           }
[09:31:15.469]                           base::stop(msg)
[09:31:15.469]                         }
[09:31:15.469]                       })
[09:31:15.469]                     }
[09:31:15.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.469]                     base::options(mc.cores = 1L)
[09:31:15.469]                   }
[09:31:15.469]                   ...future.strategy.old <- future::plan("list")
[09:31:15.469]                   options(future.plan = NULL)
[09:31:15.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.469]                 }
[09:31:15.469]                 ...future.workdir <- getwd()
[09:31:15.469]             }
[09:31:15.469]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.469]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.469]         }
[09:31:15.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.469]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.469]             base::names(...future.oldOptions))
[09:31:15.469]     }
[09:31:15.469]     if (FALSE) {
[09:31:15.469]     }
[09:31:15.469]     else {
[09:31:15.469]         if (TRUE) {
[09:31:15.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.469]                 open = "w")
[09:31:15.469]         }
[09:31:15.469]         else {
[09:31:15.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.469]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.469]         }
[09:31:15.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.469]             base::sink(type = "output", split = FALSE)
[09:31:15.469]             base::close(...future.stdout)
[09:31:15.469]         }, add = TRUE)
[09:31:15.469]     }
[09:31:15.469]     ...future.frame <- base::sys.nframe()
[09:31:15.469]     ...future.conditions <- base::list()
[09:31:15.469]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.469]     if (FALSE) {
[09:31:15.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.469]     }
[09:31:15.469]     ...future.result <- base::tryCatch({
[09:31:15.469]         base::withCallingHandlers({
[09:31:15.469]             ...future.value <- base::withVisible(base::local({
[09:31:15.469]                 withCallingHandlers({
[09:31:15.469]                   2
[09:31:15.469]                 }, immediateCondition = function(cond) {
[09:31:15.469]                   save_rds <- function (object, pathname, ...) 
[09:31:15.469]                   {
[09:31:15.469]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.469]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.469]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.469]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.469]                         fi_tmp[["mtime"]])
[09:31:15.469]                     }
[09:31:15.469]                     tryCatch({
[09:31:15.469]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.469]                     }, error = function(ex) {
[09:31:15.469]                       msg <- conditionMessage(ex)
[09:31:15.469]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.469]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.469]                         fi_tmp[["mtime"]], msg)
[09:31:15.469]                       ex$message <- msg
[09:31:15.469]                       stop(ex)
[09:31:15.469]                     })
[09:31:15.469]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.469]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.469]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.469]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.469]                       fi <- file.info(pathname)
[09:31:15.469]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.469]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.469]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.469]                         fi[["size"]], fi[["mtime"]])
[09:31:15.469]                       stop(msg)
[09:31:15.469]                     }
[09:31:15.469]                     invisible(pathname)
[09:31:15.469]                   }
[09:31:15.469]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.469]                     rootPath = tempdir()) 
[09:31:15.469]                   {
[09:31:15.469]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.469]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.469]                       tmpdir = path, fileext = ".rds")
[09:31:15.469]                     save_rds(obj, file)
[09:31:15.469]                   }
[09:31:15.469]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.469]                   {
[09:31:15.469]                     inherits <- base::inherits
[09:31:15.469]                     invokeRestart <- base::invokeRestart
[09:31:15.469]                     is.null <- base::is.null
[09:31:15.469]                     muffled <- FALSE
[09:31:15.469]                     if (inherits(cond, "message")) {
[09:31:15.469]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.469]                       if (muffled) 
[09:31:15.469]                         invokeRestart("muffleMessage")
[09:31:15.469]                     }
[09:31:15.469]                     else if (inherits(cond, "warning")) {
[09:31:15.469]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.469]                       if (muffled) 
[09:31:15.469]                         invokeRestart("muffleWarning")
[09:31:15.469]                     }
[09:31:15.469]                     else if (inherits(cond, "condition")) {
[09:31:15.469]                       if (!is.null(pattern)) {
[09:31:15.469]                         computeRestarts <- base::computeRestarts
[09:31:15.469]                         grepl <- base::grepl
[09:31:15.469]                         restarts <- computeRestarts(cond)
[09:31:15.469]                         for (restart in restarts) {
[09:31:15.469]                           name <- restart$name
[09:31:15.469]                           if (is.null(name)) 
[09:31:15.469]                             next
[09:31:15.469]                           if (!grepl(pattern, name)) 
[09:31:15.469]                             next
[09:31:15.469]                           invokeRestart(restart)
[09:31:15.469]                           muffled <- TRUE
[09:31:15.469]                           break
[09:31:15.469]                         }
[09:31:15.469]                       }
[09:31:15.469]                     }
[09:31:15.469]                     invisible(muffled)
[09:31:15.469]                   }
[09:31:15.469]                   muffleCondition(cond)
[09:31:15.469]                 })
[09:31:15.469]             }))
[09:31:15.469]             future::FutureResult(value = ...future.value$value, 
[09:31:15.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.469]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.469]                     ...future.globalenv.names))
[09:31:15.469]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.469]         }, condition = base::local({
[09:31:15.469]             c <- base::c
[09:31:15.469]             inherits <- base::inherits
[09:31:15.469]             invokeRestart <- base::invokeRestart
[09:31:15.469]             length <- base::length
[09:31:15.469]             list <- base::list
[09:31:15.469]             seq.int <- base::seq.int
[09:31:15.469]             signalCondition <- base::signalCondition
[09:31:15.469]             sys.calls <- base::sys.calls
[09:31:15.469]             `[[` <- base::`[[`
[09:31:15.469]             `+` <- base::`+`
[09:31:15.469]             `<<-` <- base::`<<-`
[09:31:15.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.469]                   3L)]
[09:31:15.469]             }
[09:31:15.469]             function(cond) {
[09:31:15.469]                 is_error <- inherits(cond, "error")
[09:31:15.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.469]                   NULL)
[09:31:15.469]                 if (is_error) {
[09:31:15.469]                   sessionInformation <- function() {
[09:31:15.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.469]                       search = base::search(), system = base::Sys.info())
[09:31:15.469]                   }
[09:31:15.469]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.469]                     cond$call), session = sessionInformation(), 
[09:31:15.469]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.469]                   signalCondition(cond)
[09:31:15.469]                 }
[09:31:15.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.469]                 "immediateCondition"))) {
[09:31:15.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.469]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.469]                   if (TRUE && !signal) {
[09:31:15.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.469]                     {
[09:31:15.469]                       inherits <- base::inherits
[09:31:15.469]                       invokeRestart <- base::invokeRestart
[09:31:15.469]                       is.null <- base::is.null
[09:31:15.469]                       muffled <- FALSE
[09:31:15.469]                       if (inherits(cond, "message")) {
[09:31:15.469]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.469]                         if (muffled) 
[09:31:15.469]                           invokeRestart("muffleMessage")
[09:31:15.469]                       }
[09:31:15.469]                       else if (inherits(cond, "warning")) {
[09:31:15.469]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.469]                         if (muffled) 
[09:31:15.469]                           invokeRestart("muffleWarning")
[09:31:15.469]                       }
[09:31:15.469]                       else if (inherits(cond, "condition")) {
[09:31:15.469]                         if (!is.null(pattern)) {
[09:31:15.469]                           computeRestarts <- base::computeRestarts
[09:31:15.469]                           grepl <- base::grepl
[09:31:15.469]                           restarts <- computeRestarts(cond)
[09:31:15.469]                           for (restart in restarts) {
[09:31:15.469]                             name <- restart$name
[09:31:15.469]                             if (is.null(name)) 
[09:31:15.469]                               next
[09:31:15.469]                             if (!grepl(pattern, name)) 
[09:31:15.469]                               next
[09:31:15.469]                             invokeRestart(restart)
[09:31:15.469]                             muffled <- TRUE
[09:31:15.469]                             break
[09:31:15.469]                           }
[09:31:15.469]                         }
[09:31:15.469]                       }
[09:31:15.469]                       invisible(muffled)
[09:31:15.469]                     }
[09:31:15.469]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.469]                   }
[09:31:15.469]                 }
[09:31:15.469]                 else {
[09:31:15.469]                   if (TRUE) {
[09:31:15.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.469]                     {
[09:31:15.469]                       inherits <- base::inherits
[09:31:15.469]                       invokeRestart <- base::invokeRestart
[09:31:15.469]                       is.null <- base::is.null
[09:31:15.469]                       muffled <- FALSE
[09:31:15.469]                       if (inherits(cond, "message")) {
[09:31:15.469]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.469]                         if (muffled) 
[09:31:15.469]                           invokeRestart("muffleMessage")
[09:31:15.469]                       }
[09:31:15.469]                       else if (inherits(cond, "warning")) {
[09:31:15.469]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.469]                         if (muffled) 
[09:31:15.469]                           invokeRestart("muffleWarning")
[09:31:15.469]                       }
[09:31:15.469]                       else if (inherits(cond, "condition")) {
[09:31:15.469]                         if (!is.null(pattern)) {
[09:31:15.469]                           computeRestarts <- base::computeRestarts
[09:31:15.469]                           grepl <- base::grepl
[09:31:15.469]                           restarts <- computeRestarts(cond)
[09:31:15.469]                           for (restart in restarts) {
[09:31:15.469]                             name <- restart$name
[09:31:15.469]                             if (is.null(name)) 
[09:31:15.469]                               next
[09:31:15.469]                             if (!grepl(pattern, name)) 
[09:31:15.469]                               next
[09:31:15.469]                             invokeRestart(restart)
[09:31:15.469]                             muffled <- TRUE
[09:31:15.469]                             break
[09:31:15.469]                           }
[09:31:15.469]                         }
[09:31:15.469]                       }
[09:31:15.469]                       invisible(muffled)
[09:31:15.469]                     }
[09:31:15.469]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.469]                   }
[09:31:15.469]                 }
[09:31:15.469]             }
[09:31:15.469]         }))
[09:31:15.469]     }, error = function(ex) {
[09:31:15.469]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.469]                 ...future.rng), started = ...future.startTime, 
[09:31:15.469]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.469]             version = "1.8"), class = "FutureResult")
[09:31:15.469]     }, finally = {
[09:31:15.469]         if (!identical(...future.workdir, getwd())) 
[09:31:15.469]             setwd(...future.workdir)
[09:31:15.469]         {
[09:31:15.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.469]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.469]             }
[09:31:15.469]             base::options(...future.oldOptions)
[09:31:15.469]             if (.Platform$OS.type == "windows") {
[09:31:15.469]                 old_names <- names(...future.oldEnvVars)
[09:31:15.469]                 envs <- base::Sys.getenv()
[09:31:15.469]                 names <- names(envs)
[09:31:15.469]                 common <- intersect(names, old_names)
[09:31:15.469]                 added <- setdiff(names, old_names)
[09:31:15.469]                 removed <- setdiff(old_names, names)
[09:31:15.469]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.469]                   envs[common]]
[09:31:15.469]                 NAMES <- toupper(changed)
[09:31:15.469]                 args <- list()
[09:31:15.469]                 for (kk in seq_along(NAMES)) {
[09:31:15.469]                   name <- changed[[kk]]
[09:31:15.469]                   NAME <- NAMES[[kk]]
[09:31:15.469]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.469]                     next
[09:31:15.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.469]                 }
[09:31:15.469]                 NAMES <- toupper(added)
[09:31:15.469]                 for (kk in seq_along(NAMES)) {
[09:31:15.469]                   name <- added[[kk]]
[09:31:15.469]                   NAME <- NAMES[[kk]]
[09:31:15.469]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.469]                     next
[09:31:15.469]                   args[[name]] <- ""
[09:31:15.469]                 }
[09:31:15.469]                 NAMES <- toupper(removed)
[09:31:15.469]                 for (kk in seq_along(NAMES)) {
[09:31:15.469]                   name <- removed[[kk]]
[09:31:15.469]                   NAME <- NAMES[[kk]]
[09:31:15.469]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.469]                     next
[09:31:15.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.469]                 }
[09:31:15.469]                 if (length(args) > 0) 
[09:31:15.469]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.469]             }
[09:31:15.469]             else {
[09:31:15.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.469]             }
[09:31:15.469]             {
[09:31:15.469]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.469]                   0L) {
[09:31:15.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.469]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.469]                   base::options(opts)
[09:31:15.469]                 }
[09:31:15.469]                 {
[09:31:15.469]                   {
[09:31:15.469]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.469]                     NULL
[09:31:15.469]                   }
[09:31:15.469]                   options(future.plan = NULL)
[09:31:15.469]                   if (is.na(NA_character_)) 
[09:31:15.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.469]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.469]                     .init = FALSE)
[09:31:15.469]                 }
[09:31:15.469]             }
[09:31:15.469]         }
[09:31:15.469]     })
[09:31:15.469]     if (TRUE) {
[09:31:15.469]         base::sink(type = "output", split = FALSE)
[09:31:15.469]         if (TRUE) {
[09:31:15.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.469]         }
[09:31:15.469]         else {
[09:31:15.469]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.469]         }
[09:31:15.469]         base::close(...future.stdout)
[09:31:15.469]         ...future.stdout <- NULL
[09:31:15.469]     }
[09:31:15.469]     ...future.result$conditions <- ...future.conditions
[09:31:15.469]     ...future.result$finished <- base::Sys.time()
[09:31:15.469]     ...future.result
[09:31:15.469] }
[09:31:15.471] requestCore(): workers = 2
[09:31:15.473] MulticoreFuture started
[09:31:15.473] - Launch lazy future ... done
[09:31:15.474] run() for ‘MulticoreFuture’ ... done
[09:31:15.474] getGlobalsAndPackages() ...
[09:31:15.474] Searching for globals...
[09:31:15.474] plan(): Setting new future strategy stack:
[09:31:15.475] 
[09:31:15.474] List of future strategies:
[09:31:15.474] 1. sequential:
[09:31:15.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.474]    - tweaked: FALSE
[09:31:15.474]    - call: NULL
[09:31:15.475] Searching for globals ... DONE
[09:31:15.475] - globals: [0] <none>
[09:31:15.475] plan(): nbrOfWorkers() = 1
[09:31:15.475] getGlobalsAndPackages() ... DONE
[09:31:15.476] run() for ‘Future’ ...
[09:31:15.476] - state: ‘created’
[09:31:15.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.477] plan(): Setting new future strategy stack:
[09:31:15.477] List of future strategies:
[09:31:15.477] 1. multicore:
[09:31:15.477]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.477]    - tweaked: FALSE
[09:31:15.477]    - call: plan(strategy)
[09:31:15.482] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.482] plan(): nbrOfWorkers() = 2
[09:31:15.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.482]   - Field: ‘label’
[09:31:15.482]   - Field: ‘local’
[09:31:15.482]   - Field: ‘owner’
[09:31:15.482]   - Field: ‘envir’
[09:31:15.482]   - Field: ‘workers’
[09:31:15.483]   - Field: ‘packages’
[09:31:15.483]   - Field: ‘gc’
[09:31:15.483]   - Field: ‘job’
[09:31:15.483]   - Field: ‘conditions’
[09:31:15.483]   - Field: ‘expr’
[09:31:15.483]   - Field: ‘uuid’
[09:31:15.483]   - Field: ‘seed’
[09:31:15.484]   - Field: ‘version’
[09:31:15.484]   - Field: ‘result’
[09:31:15.484]   - Field: ‘asynchronous’
[09:31:15.484]   - Field: ‘calls’
[09:31:15.484]   - Field: ‘globals’
[09:31:15.484]   - Field: ‘stdout’
[09:31:15.484]   - Field: ‘earlySignal’
[09:31:15.485]   - Field: ‘lazy’
[09:31:15.485]   - Field: ‘state’
[09:31:15.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.485] - Launch lazy future ...
[09:31:15.485] Packages needed by the future expression (n = 0): <none>
[09:31:15.486] Packages needed by future strategies (n = 0): <none>
[09:31:15.486] {
[09:31:15.486]     {
[09:31:15.486]         {
[09:31:15.486]             ...future.startTime <- base::Sys.time()
[09:31:15.486]             {
[09:31:15.486]                 {
[09:31:15.486]                   {
[09:31:15.486]                     {
[09:31:15.486]                       base::local({
[09:31:15.486]                         has_future <- base::requireNamespace("future", 
[09:31:15.486]                           quietly = TRUE)
[09:31:15.486]                         if (has_future) {
[09:31:15.486]                           ns <- base::getNamespace("future")
[09:31:15.486]                           version <- ns[[".package"]][["version"]]
[09:31:15.486]                           if (is.null(version)) 
[09:31:15.486]                             version <- utils::packageVersion("future")
[09:31:15.486]                         }
[09:31:15.486]                         else {
[09:31:15.486]                           version <- NULL
[09:31:15.486]                         }
[09:31:15.486]                         if (!has_future || version < "1.8.0") {
[09:31:15.486]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.486]                             "", base::R.version$version.string), 
[09:31:15.486]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.486]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.486]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.486]                               "release", "version")], collapse = " "), 
[09:31:15.486]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.486]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.486]                             info)
[09:31:15.486]                           info <- base::paste(info, collapse = "; ")
[09:31:15.486]                           if (!has_future) {
[09:31:15.486]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.486]                               info)
[09:31:15.486]                           }
[09:31:15.486]                           else {
[09:31:15.486]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.486]                               info, version)
[09:31:15.486]                           }
[09:31:15.486]                           base::stop(msg)
[09:31:15.486]                         }
[09:31:15.486]                       })
[09:31:15.486]                     }
[09:31:15.486]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.486]                     base::options(mc.cores = 1L)
[09:31:15.486]                   }
[09:31:15.486]                   ...future.strategy.old <- future::plan("list")
[09:31:15.486]                   options(future.plan = NULL)
[09:31:15.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.486]                 }
[09:31:15.486]                 ...future.workdir <- getwd()
[09:31:15.486]             }
[09:31:15.486]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.486]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.486]         }
[09:31:15.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.486]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.486]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.486]             base::names(...future.oldOptions))
[09:31:15.486]     }
[09:31:15.486]     if (FALSE) {
[09:31:15.486]     }
[09:31:15.486]     else {
[09:31:15.486]         if (TRUE) {
[09:31:15.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.486]                 open = "w")
[09:31:15.486]         }
[09:31:15.486]         else {
[09:31:15.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.486]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.486]         }
[09:31:15.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.486]             base::sink(type = "output", split = FALSE)
[09:31:15.486]             base::close(...future.stdout)
[09:31:15.486]         }, add = TRUE)
[09:31:15.486]     }
[09:31:15.486]     ...future.frame <- base::sys.nframe()
[09:31:15.486]     ...future.conditions <- base::list()
[09:31:15.486]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.486]     if (FALSE) {
[09:31:15.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.486]     }
[09:31:15.486]     ...future.result <- base::tryCatch({
[09:31:15.486]         base::withCallingHandlers({
[09:31:15.486]             ...future.value <- base::withVisible(base::local({
[09:31:15.486]                 withCallingHandlers({
[09:31:15.486]                   NULL
[09:31:15.486]                 }, immediateCondition = function(cond) {
[09:31:15.486]                   save_rds <- function (object, pathname, ...) 
[09:31:15.486]                   {
[09:31:15.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.486]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.486]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.486]                         fi_tmp[["mtime"]])
[09:31:15.486]                     }
[09:31:15.486]                     tryCatch({
[09:31:15.486]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.486]                     }, error = function(ex) {
[09:31:15.486]                       msg <- conditionMessage(ex)
[09:31:15.486]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.486]                         fi_tmp[["mtime"]], msg)
[09:31:15.486]                       ex$message <- msg
[09:31:15.486]                       stop(ex)
[09:31:15.486]                     })
[09:31:15.486]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.486]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.486]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.486]                       fi <- file.info(pathname)
[09:31:15.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.486]                         fi[["size"]], fi[["mtime"]])
[09:31:15.486]                       stop(msg)
[09:31:15.486]                     }
[09:31:15.486]                     invisible(pathname)
[09:31:15.486]                   }
[09:31:15.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.486]                     rootPath = tempdir()) 
[09:31:15.486]                   {
[09:31:15.486]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.486]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.486]                       tmpdir = path, fileext = ".rds")
[09:31:15.486]                     save_rds(obj, file)
[09:31:15.486]                   }
[09:31:15.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.486]                   {
[09:31:15.486]                     inherits <- base::inherits
[09:31:15.486]                     invokeRestart <- base::invokeRestart
[09:31:15.486]                     is.null <- base::is.null
[09:31:15.486]                     muffled <- FALSE
[09:31:15.486]                     if (inherits(cond, "message")) {
[09:31:15.486]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.486]                       if (muffled) 
[09:31:15.486]                         invokeRestart("muffleMessage")
[09:31:15.486]                     }
[09:31:15.486]                     else if (inherits(cond, "warning")) {
[09:31:15.486]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.486]                       if (muffled) 
[09:31:15.486]                         invokeRestart("muffleWarning")
[09:31:15.486]                     }
[09:31:15.486]                     else if (inherits(cond, "condition")) {
[09:31:15.486]                       if (!is.null(pattern)) {
[09:31:15.486]                         computeRestarts <- base::computeRestarts
[09:31:15.486]                         grepl <- base::grepl
[09:31:15.486]                         restarts <- computeRestarts(cond)
[09:31:15.486]                         for (restart in restarts) {
[09:31:15.486]                           name <- restart$name
[09:31:15.486]                           if (is.null(name)) 
[09:31:15.486]                             next
[09:31:15.486]                           if (!grepl(pattern, name)) 
[09:31:15.486]                             next
[09:31:15.486]                           invokeRestart(restart)
[09:31:15.486]                           muffled <- TRUE
[09:31:15.486]                           break
[09:31:15.486]                         }
[09:31:15.486]                       }
[09:31:15.486]                     }
[09:31:15.486]                     invisible(muffled)
[09:31:15.486]                   }
[09:31:15.486]                   muffleCondition(cond)
[09:31:15.486]                 })
[09:31:15.486]             }))
[09:31:15.486]             future::FutureResult(value = ...future.value$value, 
[09:31:15.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.486]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.486]                     ...future.globalenv.names))
[09:31:15.486]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.486]         }, condition = base::local({
[09:31:15.486]             c <- base::c
[09:31:15.486]             inherits <- base::inherits
[09:31:15.486]             invokeRestart <- base::invokeRestart
[09:31:15.486]             length <- base::length
[09:31:15.486]             list <- base::list
[09:31:15.486]             seq.int <- base::seq.int
[09:31:15.486]             signalCondition <- base::signalCondition
[09:31:15.486]             sys.calls <- base::sys.calls
[09:31:15.486]             `[[` <- base::`[[`
[09:31:15.486]             `+` <- base::`+`
[09:31:15.486]             `<<-` <- base::`<<-`
[09:31:15.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.486]                   3L)]
[09:31:15.486]             }
[09:31:15.486]             function(cond) {
[09:31:15.486]                 is_error <- inherits(cond, "error")
[09:31:15.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.486]                   NULL)
[09:31:15.486]                 if (is_error) {
[09:31:15.486]                   sessionInformation <- function() {
[09:31:15.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.486]                       search = base::search(), system = base::Sys.info())
[09:31:15.486]                   }
[09:31:15.486]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.486]                     cond$call), session = sessionInformation(), 
[09:31:15.486]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.486]                   signalCondition(cond)
[09:31:15.486]                 }
[09:31:15.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.486]                 "immediateCondition"))) {
[09:31:15.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.486]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.486]                   if (TRUE && !signal) {
[09:31:15.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.486]                     {
[09:31:15.486]                       inherits <- base::inherits
[09:31:15.486]                       invokeRestart <- base::invokeRestart
[09:31:15.486]                       is.null <- base::is.null
[09:31:15.486]                       muffled <- FALSE
[09:31:15.486]                       if (inherits(cond, "message")) {
[09:31:15.486]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.486]                         if (muffled) 
[09:31:15.486]                           invokeRestart("muffleMessage")
[09:31:15.486]                       }
[09:31:15.486]                       else if (inherits(cond, "warning")) {
[09:31:15.486]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.486]                         if (muffled) 
[09:31:15.486]                           invokeRestart("muffleWarning")
[09:31:15.486]                       }
[09:31:15.486]                       else if (inherits(cond, "condition")) {
[09:31:15.486]                         if (!is.null(pattern)) {
[09:31:15.486]                           computeRestarts <- base::computeRestarts
[09:31:15.486]                           grepl <- base::grepl
[09:31:15.486]                           restarts <- computeRestarts(cond)
[09:31:15.486]                           for (restart in restarts) {
[09:31:15.486]                             name <- restart$name
[09:31:15.486]                             if (is.null(name)) 
[09:31:15.486]                               next
[09:31:15.486]                             if (!grepl(pattern, name)) 
[09:31:15.486]                               next
[09:31:15.486]                             invokeRestart(restart)
[09:31:15.486]                             muffled <- TRUE
[09:31:15.486]                             break
[09:31:15.486]                           }
[09:31:15.486]                         }
[09:31:15.486]                       }
[09:31:15.486]                       invisible(muffled)
[09:31:15.486]                     }
[09:31:15.486]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.486]                   }
[09:31:15.486]                 }
[09:31:15.486]                 else {
[09:31:15.486]                   if (TRUE) {
[09:31:15.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.486]                     {
[09:31:15.486]                       inherits <- base::inherits
[09:31:15.486]                       invokeRestart <- base::invokeRestart
[09:31:15.486]                       is.null <- base::is.null
[09:31:15.486]                       muffled <- FALSE
[09:31:15.486]                       if (inherits(cond, "message")) {
[09:31:15.486]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.486]                         if (muffled) 
[09:31:15.486]                           invokeRestart("muffleMessage")
[09:31:15.486]                       }
[09:31:15.486]                       else if (inherits(cond, "warning")) {
[09:31:15.486]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.486]                         if (muffled) 
[09:31:15.486]                           invokeRestart("muffleWarning")
[09:31:15.486]                       }
[09:31:15.486]                       else if (inherits(cond, "condition")) {
[09:31:15.486]                         if (!is.null(pattern)) {
[09:31:15.486]                           computeRestarts <- base::computeRestarts
[09:31:15.486]                           grepl <- base::grepl
[09:31:15.486]                           restarts <- computeRestarts(cond)
[09:31:15.486]                           for (restart in restarts) {
[09:31:15.486]                             name <- restart$name
[09:31:15.486]                             if (is.null(name)) 
[09:31:15.486]                               next
[09:31:15.486]                             if (!grepl(pattern, name)) 
[09:31:15.486]                               next
[09:31:15.486]                             invokeRestart(restart)
[09:31:15.486]                             muffled <- TRUE
[09:31:15.486]                             break
[09:31:15.486]                           }
[09:31:15.486]                         }
[09:31:15.486]                       }
[09:31:15.486]                       invisible(muffled)
[09:31:15.486]                     }
[09:31:15.486]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.486]                   }
[09:31:15.486]                 }
[09:31:15.486]             }
[09:31:15.486]         }))
[09:31:15.486]     }, error = function(ex) {
[09:31:15.486]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.486]                 ...future.rng), started = ...future.startTime, 
[09:31:15.486]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.486]             version = "1.8"), class = "FutureResult")
[09:31:15.486]     }, finally = {
[09:31:15.486]         if (!identical(...future.workdir, getwd())) 
[09:31:15.486]             setwd(...future.workdir)
[09:31:15.486]         {
[09:31:15.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.486]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.486]             }
[09:31:15.486]             base::options(...future.oldOptions)
[09:31:15.486]             if (.Platform$OS.type == "windows") {
[09:31:15.486]                 old_names <- names(...future.oldEnvVars)
[09:31:15.486]                 envs <- base::Sys.getenv()
[09:31:15.486]                 names <- names(envs)
[09:31:15.486]                 common <- intersect(names, old_names)
[09:31:15.486]                 added <- setdiff(names, old_names)
[09:31:15.486]                 removed <- setdiff(old_names, names)
[09:31:15.486]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.486]                   envs[common]]
[09:31:15.486]                 NAMES <- toupper(changed)
[09:31:15.486]                 args <- list()
[09:31:15.486]                 for (kk in seq_along(NAMES)) {
[09:31:15.486]                   name <- changed[[kk]]
[09:31:15.486]                   NAME <- NAMES[[kk]]
[09:31:15.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.486]                     next
[09:31:15.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.486]                 }
[09:31:15.486]                 NAMES <- toupper(added)
[09:31:15.486]                 for (kk in seq_along(NAMES)) {
[09:31:15.486]                   name <- added[[kk]]
[09:31:15.486]                   NAME <- NAMES[[kk]]
[09:31:15.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.486]                     next
[09:31:15.486]                   args[[name]] <- ""
[09:31:15.486]                 }
[09:31:15.486]                 NAMES <- toupper(removed)
[09:31:15.486]                 for (kk in seq_along(NAMES)) {
[09:31:15.486]                   name <- removed[[kk]]
[09:31:15.486]                   NAME <- NAMES[[kk]]
[09:31:15.486]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.486]                     next
[09:31:15.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.486]                 }
[09:31:15.486]                 if (length(args) > 0) 
[09:31:15.486]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.486]             }
[09:31:15.486]             else {
[09:31:15.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.486]             }
[09:31:15.486]             {
[09:31:15.486]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.486]                   0L) {
[09:31:15.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.486]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.486]                   base::options(opts)
[09:31:15.486]                 }
[09:31:15.486]                 {
[09:31:15.486]                   {
[09:31:15.486]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.486]                     NULL
[09:31:15.486]                   }
[09:31:15.486]                   options(future.plan = NULL)
[09:31:15.486]                   if (is.na(NA_character_)) 
[09:31:15.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.486]                     .init = FALSE)
[09:31:15.486]                 }
[09:31:15.486]             }
[09:31:15.486]         }
[09:31:15.486]     })
[09:31:15.486]     if (TRUE) {
[09:31:15.486]         base::sink(type = "output", split = FALSE)
[09:31:15.486]         if (TRUE) {
[09:31:15.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.486]         }
[09:31:15.486]         else {
[09:31:15.486]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.486]         }
[09:31:15.486]         base::close(...future.stdout)
[09:31:15.486]         ...future.stdout <- NULL
[09:31:15.486]     }
[09:31:15.486]     ...future.result$conditions <- ...future.conditions
[09:31:15.486]     ...future.result$finished <- base::Sys.time()
[09:31:15.486]     ...future.result
[09:31:15.486] }
[09:31:15.490] requestCore(): workers = 2
[09:31:15.492] MulticoreFuture started
[09:31:15.493] - Launch lazy future ... done
[09:31:15.493] run() for ‘MulticoreFuture’ ... done
[09:31:15.494] plan(): Setting new future strategy stack:
[09:31:15.494] getGlobalsAndPackages() ...
[09:31:15.494] Searching for globals...
[09:31:15.494] List of future strategies:
[09:31:15.494] 1. sequential:
[09:31:15.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.494]    - tweaked: FALSE
[09:31:15.494]    - call: NULL
[09:31:15.495] plan(): nbrOfWorkers() = 1
[09:31:15.495] - globals found: [1] ‘{’
[09:31:15.496] Searching for globals ... DONE
[09:31:15.496] Resolving globals: FALSE
[09:31:15.496] 
[09:31:15.497] 
[09:31:15.497] getGlobalsAndPackages() ... DONE
[09:31:15.497] plan(): Setting new future strategy stack:
[09:31:15.497] run() for ‘Future’ ...
[09:31:15.497] - state: ‘created’
[09:31:15.497] List of future strategies:
[09:31:15.497] 1. multicore:
[09:31:15.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.497]    - tweaked: FALSE
[09:31:15.497]    - call: plan(strategy)
[09:31:15.497] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.502] plan(): nbrOfWorkers() = 2
[09:31:15.503] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.503] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:15.503]   - Field: ‘label’
[09:31:15.503]   - Field: ‘local’
[09:31:15.503]   - Field: ‘owner’
[09:31:15.504]   - Field: ‘envir’
[09:31:15.504]   - Field: ‘workers’
[09:31:15.504]   - Field: ‘packages’
[09:31:15.504]   - Field: ‘gc’
[09:31:15.504]   - Field: ‘job’
[09:31:15.504]   - Field: ‘conditions’
[09:31:15.504]   - Field: ‘expr’
[09:31:15.505]   - Field: ‘uuid’
[09:31:15.505]   - Field: ‘seed’
[09:31:15.505]   - Field: ‘version’
[09:31:15.505]   - Field: ‘result’
[09:31:15.505]   - Field: ‘asynchronous’
[09:31:15.505]   - Field: ‘calls’
[09:31:15.505]   - Field: ‘globals’
[09:31:15.506]   - Field: ‘stdout’
[09:31:15.506]   - Field: ‘earlySignal’
[09:31:15.506]   - Field: ‘lazy’
[09:31:15.506]   - Field: ‘state’
[09:31:15.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:15.506] - Launch lazy future ...
[09:31:15.507] Packages needed by the future expression (n = 0): <none>
[09:31:15.507] Packages needed by future strategies (n = 0): <none>
[09:31:15.507] {
[09:31:15.507]     {
[09:31:15.507]         {
[09:31:15.507]             ...future.startTime <- base::Sys.time()
[09:31:15.507]             {
[09:31:15.507]                 {
[09:31:15.507]                   {
[09:31:15.507]                     {
[09:31:15.507]                       base::local({
[09:31:15.507]                         has_future <- base::requireNamespace("future", 
[09:31:15.507]                           quietly = TRUE)
[09:31:15.507]                         if (has_future) {
[09:31:15.507]                           ns <- base::getNamespace("future")
[09:31:15.507]                           version <- ns[[".package"]][["version"]]
[09:31:15.507]                           if (is.null(version)) 
[09:31:15.507]                             version <- utils::packageVersion("future")
[09:31:15.507]                         }
[09:31:15.507]                         else {
[09:31:15.507]                           version <- NULL
[09:31:15.507]                         }
[09:31:15.507]                         if (!has_future || version < "1.8.0") {
[09:31:15.507]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.507]                             "", base::R.version$version.string), 
[09:31:15.507]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.507]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.507]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.507]                               "release", "version")], collapse = " "), 
[09:31:15.507]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.507]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.507]                             info)
[09:31:15.507]                           info <- base::paste(info, collapse = "; ")
[09:31:15.507]                           if (!has_future) {
[09:31:15.507]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.507]                               info)
[09:31:15.507]                           }
[09:31:15.507]                           else {
[09:31:15.507]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.507]                               info, version)
[09:31:15.507]                           }
[09:31:15.507]                           base::stop(msg)
[09:31:15.507]                         }
[09:31:15.507]                       })
[09:31:15.507]                     }
[09:31:15.507]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.507]                     base::options(mc.cores = 1L)
[09:31:15.507]                   }
[09:31:15.507]                   ...future.strategy.old <- future::plan("list")
[09:31:15.507]                   options(future.plan = NULL)
[09:31:15.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.507]                 }
[09:31:15.507]                 ...future.workdir <- getwd()
[09:31:15.507]             }
[09:31:15.507]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.507]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.507]         }
[09:31:15.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.507]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.507]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.507]             base::names(...future.oldOptions))
[09:31:15.507]     }
[09:31:15.507]     if (FALSE) {
[09:31:15.507]     }
[09:31:15.507]     else {
[09:31:15.507]         if (TRUE) {
[09:31:15.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.507]                 open = "w")
[09:31:15.507]         }
[09:31:15.507]         else {
[09:31:15.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.507]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.507]         }
[09:31:15.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.507]             base::sink(type = "output", split = FALSE)
[09:31:15.507]             base::close(...future.stdout)
[09:31:15.507]         }, add = TRUE)
[09:31:15.507]     }
[09:31:15.507]     ...future.frame <- base::sys.nframe()
[09:31:15.507]     ...future.conditions <- base::list()
[09:31:15.507]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.507]     if (FALSE) {
[09:31:15.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.507]     }
[09:31:15.507]     ...future.result <- base::tryCatch({
[09:31:15.507]         base::withCallingHandlers({
[09:31:15.507]             ...future.value <- base::withVisible(base::local({
[09:31:15.507]                 withCallingHandlers({
[09:31:15.507]                   {
[09:31:15.507]                     4
[09:31:15.507]                   }
[09:31:15.507]                 }, immediateCondition = function(cond) {
[09:31:15.507]                   save_rds <- function (object, pathname, ...) 
[09:31:15.507]                   {
[09:31:15.507]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:15.507]                     if (file_test("-f", pathname_tmp)) {
[09:31:15.507]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.507]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:15.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.507]                         fi_tmp[["mtime"]])
[09:31:15.507]                     }
[09:31:15.507]                     tryCatch({
[09:31:15.507]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:15.507]                     }, error = function(ex) {
[09:31:15.507]                       msg <- conditionMessage(ex)
[09:31:15.507]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.507]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:15.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.507]                         fi_tmp[["mtime"]], msg)
[09:31:15.507]                       ex$message <- msg
[09:31:15.507]                       stop(ex)
[09:31:15.507]                     })
[09:31:15.507]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:15.507]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:15.507]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:15.507]                       fi_tmp <- file.info(pathname_tmp)
[09:31:15.507]                       fi <- file.info(pathname)
[09:31:15.507]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:15.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:15.507]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:15.507]                         fi[["size"]], fi[["mtime"]])
[09:31:15.507]                       stop(msg)
[09:31:15.507]                     }
[09:31:15.507]                     invisible(pathname)
[09:31:15.507]                   }
[09:31:15.507]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:15.507]                     rootPath = tempdir()) 
[09:31:15.507]                   {
[09:31:15.507]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:15.507]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:15.507]                       tmpdir = path, fileext = ".rds")
[09:31:15.507]                     save_rds(obj, file)
[09:31:15.507]                   }
[09:31:15.507]                   saveImmediateCondition(cond, path = "/tmp/RtmpS7JS9w/.future/immediateConditions")
[09:31:15.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.507]                   {
[09:31:15.507]                     inherits <- base::inherits
[09:31:15.507]                     invokeRestart <- base::invokeRestart
[09:31:15.507]                     is.null <- base::is.null
[09:31:15.507]                     muffled <- FALSE
[09:31:15.507]                     if (inherits(cond, "message")) {
[09:31:15.507]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.507]                       if (muffled) 
[09:31:15.507]                         invokeRestart("muffleMessage")
[09:31:15.507]                     }
[09:31:15.507]                     else if (inherits(cond, "warning")) {
[09:31:15.507]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.507]                       if (muffled) 
[09:31:15.507]                         invokeRestart("muffleWarning")
[09:31:15.507]                     }
[09:31:15.507]                     else if (inherits(cond, "condition")) {
[09:31:15.507]                       if (!is.null(pattern)) {
[09:31:15.507]                         computeRestarts <- base::computeRestarts
[09:31:15.507]                         grepl <- base::grepl
[09:31:15.507]                         restarts <- computeRestarts(cond)
[09:31:15.507]                         for (restart in restarts) {
[09:31:15.507]                           name <- restart$name
[09:31:15.507]                           if (is.null(name)) 
[09:31:15.507]                             next
[09:31:15.507]                           if (!grepl(pattern, name)) 
[09:31:15.507]                             next
[09:31:15.507]                           invokeRestart(restart)
[09:31:15.507]                           muffled <- TRUE
[09:31:15.507]                           break
[09:31:15.507]                         }
[09:31:15.507]                       }
[09:31:15.507]                     }
[09:31:15.507]                     invisible(muffled)
[09:31:15.507]                   }
[09:31:15.507]                   muffleCondition(cond)
[09:31:15.507]                 })
[09:31:15.507]             }))
[09:31:15.507]             future::FutureResult(value = ...future.value$value, 
[09:31:15.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.507]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.507]                     ...future.globalenv.names))
[09:31:15.507]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.507]         }, condition = base::local({
[09:31:15.507]             c <- base::c
[09:31:15.507]             inherits <- base::inherits
[09:31:15.507]             invokeRestart <- base::invokeRestart
[09:31:15.507]             length <- base::length
[09:31:15.507]             list <- base::list
[09:31:15.507]             seq.int <- base::seq.int
[09:31:15.507]             signalCondition <- base::signalCondition
[09:31:15.507]             sys.calls <- base::sys.calls
[09:31:15.507]             `[[` <- base::`[[`
[09:31:15.507]             `+` <- base::`+`
[09:31:15.507]             `<<-` <- base::`<<-`
[09:31:15.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.507]                   3L)]
[09:31:15.507]             }
[09:31:15.507]             function(cond) {
[09:31:15.507]                 is_error <- inherits(cond, "error")
[09:31:15.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.507]                   NULL)
[09:31:15.507]                 if (is_error) {
[09:31:15.507]                   sessionInformation <- function() {
[09:31:15.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.507]                       search = base::search(), system = base::Sys.info())
[09:31:15.507]                   }
[09:31:15.507]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.507]                     cond$call), session = sessionInformation(), 
[09:31:15.507]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.507]                   signalCondition(cond)
[09:31:15.507]                 }
[09:31:15.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.507]                 "immediateCondition"))) {
[09:31:15.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.507]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.507]                   if (TRUE && !signal) {
[09:31:15.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.507]                     {
[09:31:15.507]                       inherits <- base::inherits
[09:31:15.507]                       invokeRestart <- base::invokeRestart
[09:31:15.507]                       is.null <- base::is.null
[09:31:15.507]                       muffled <- FALSE
[09:31:15.507]                       if (inherits(cond, "message")) {
[09:31:15.507]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.507]                         if (muffled) 
[09:31:15.507]                           invokeRestart("muffleMessage")
[09:31:15.507]                       }
[09:31:15.507]                       else if (inherits(cond, "warning")) {
[09:31:15.507]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.507]                         if (muffled) 
[09:31:15.507]                           invokeRestart("muffleWarning")
[09:31:15.507]                       }
[09:31:15.507]                       else if (inherits(cond, "condition")) {
[09:31:15.507]                         if (!is.null(pattern)) {
[09:31:15.507]                           computeRestarts <- base::computeRestarts
[09:31:15.507]                           grepl <- base::grepl
[09:31:15.507]                           restarts <- computeRestarts(cond)
[09:31:15.507]                           for (restart in restarts) {
[09:31:15.507]                             name <- restart$name
[09:31:15.507]                             if (is.null(name)) 
[09:31:15.507]                               next
[09:31:15.507]                             if (!grepl(pattern, name)) 
[09:31:15.507]                               next
[09:31:15.507]                             invokeRestart(restart)
[09:31:15.507]                             muffled <- TRUE
[09:31:15.507]                             break
[09:31:15.507]                           }
[09:31:15.507]                         }
[09:31:15.507]                       }
[09:31:15.507]                       invisible(muffled)
[09:31:15.507]                     }
[09:31:15.507]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.507]                   }
[09:31:15.507]                 }
[09:31:15.507]                 else {
[09:31:15.507]                   if (TRUE) {
[09:31:15.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.507]                     {
[09:31:15.507]                       inherits <- base::inherits
[09:31:15.507]                       invokeRestart <- base::invokeRestart
[09:31:15.507]                       is.null <- base::is.null
[09:31:15.507]                       muffled <- FALSE
[09:31:15.507]                       if (inherits(cond, "message")) {
[09:31:15.507]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.507]                         if (muffled) 
[09:31:15.507]                           invokeRestart("muffleMessage")
[09:31:15.507]                       }
[09:31:15.507]                       else if (inherits(cond, "warning")) {
[09:31:15.507]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.507]                         if (muffled) 
[09:31:15.507]                           invokeRestart("muffleWarning")
[09:31:15.507]                       }
[09:31:15.507]                       else if (inherits(cond, "condition")) {
[09:31:15.507]                         if (!is.null(pattern)) {
[09:31:15.507]                           computeRestarts <- base::computeRestarts
[09:31:15.507]                           grepl <- base::grepl
[09:31:15.507]                           restarts <- computeRestarts(cond)
[09:31:15.507]                           for (restart in restarts) {
[09:31:15.507]                             name <- restart$name
[09:31:15.507]                             if (is.null(name)) 
[09:31:15.507]                               next
[09:31:15.507]                             if (!grepl(pattern, name)) 
[09:31:15.507]                               next
[09:31:15.507]                             invokeRestart(restart)
[09:31:15.507]                             muffled <- TRUE
[09:31:15.507]                             break
[09:31:15.507]                           }
[09:31:15.507]                         }
[09:31:15.507]                       }
[09:31:15.507]                       invisible(muffled)
[09:31:15.507]                     }
[09:31:15.507]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.507]                   }
[09:31:15.507]                 }
[09:31:15.507]             }
[09:31:15.507]         }))
[09:31:15.507]     }, error = function(ex) {
[09:31:15.507]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.507]                 ...future.rng), started = ...future.startTime, 
[09:31:15.507]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.507]             version = "1.8"), class = "FutureResult")
[09:31:15.507]     }, finally = {
[09:31:15.507]         if (!identical(...future.workdir, getwd())) 
[09:31:15.507]             setwd(...future.workdir)
[09:31:15.507]         {
[09:31:15.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.507]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.507]             }
[09:31:15.507]             base::options(...future.oldOptions)
[09:31:15.507]             if (.Platform$OS.type == "windows") {
[09:31:15.507]                 old_names <- names(...future.oldEnvVars)
[09:31:15.507]                 envs <- base::Sys.getenv()
[09:31:15.507]                 names <- names(envs)
[09:31:15.507]                 common <- intersect(names, old_names)
[09:31:15.507]                 added <- setdiff(names, old_names)
[09:31:15.507]                 removed <- setdiff(old_names, names)
[09:31:15.507]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.507]                   envs[common]]
[09:31:15.507]                 NAMES <- toupper(changed)
[09:31:15.507]                 args <- list()
[09:31:15.507]                 for (kk in seq_along(NAMES)) {
[09:31:15.507]                   name <- changed[[kk]]
[09:31:15.507]                   NAME <- NAMES[[kk]]
[09:31:15.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.507]                     next
[09:31:15.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.507]                 }
[09:31:15.507]                 NAMES <- toupper(added)
[09:31:15.507]                 for (kk in seq_along(NAMES)) {
[09:31:15.507]                   name <- added[[kk]]
[09:31:15.507]                   NAME <- NAMES[[kk]]
[09:31:15.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.507]                     next
[09:31:15.507]                   args[[name]] <- ""
[09:31:15.507]                 }
[09:31:15.507]                 NAMES <- toupper(removed)
[09:31:15.507]                 for (kk in seq_along(NAMES)) {
[09:31:15.507]                   name <- removed[[kk]]
[09:31:15.507]                   NAME <- NAMES[[kk]]
[09:31:15.507]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.507]                     next
[09:31:15.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.507]                 }
[09:31:15.507]                 if (length(args) > 0) 
[09:31:15.507]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.507]             }
[09:31:15.507]             else {
[09:31:15.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.507]             }
[09:31:15.507]             {
[09:31:15.507]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.507]                   0L) {
[09:31:15.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.507]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.507]                   base::options(opts)
[09:31:15.507]                 }
[09:31:15.507]                 {
[09:31:15.507]                   {
[09:31:15.507]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.507]                     NULL
[09:31:15.507]                   }
[09:31:15.507]                   options(future.plan = NULL)
[09:31:15.507]                   if (is.na(NA_character_)) 
[09:31:15.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.507]                     .init = FALSE)
[09:31:15.507]                 }
[09:31:15.507]             }
[09:31:15.507]         }
[09:31:15.507]     })
[09:31:15.507]     if (TRUE) {
[09:31:15.507]         base::sink(type = "output", split = FALSE)
[09:31:15.507]         if (TRUE) {
[09:31:15.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.507]         }
[09:31:15.507]         else {
[09:31:15.507]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.507]         }
[09:31:15.507]         base::close(...future.stdout)
[09:31:15.507]         ...future.stdout <- NULL
[09:31:15.507]     }
[09:31:15.507]     ...future.result$conditions <- ...future.conditions
[09:31:15.507]     ...future.result$finished <- base::Sys.time()
[09:31:15.507]     ...future.result
[09:31:15.507] }
[09:31:15.511] requestCore(): workers = 2
[09:31:15.511] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:15.522] result() for MulticoreFuture ...
[09:31:15.523] result() for MulticoreFuture ...
[09:31:15.523] result() for MulticoreFuture ... done
[09:31:15.523] result() for MulticoreFuture ... done
[09:31:15.524] result() for MulticoreFuture ...
[09:31:15.524] result() for MulticoreFuture ... done
[09:31:15.526] MulticoreFuture started
[09:31:15.527] - Launch lazy future ... done
[09:31:15.527] run() for ‘MulticoreFuture’ ... done
[09:31:15.527] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a3cb3c2168> 
[09:31:15.528] List of future strategies:
[09:31:15.528] 1. sequential:
[09:31:15.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:15.528]    - tweaked: FALSE
[09:31:15.528]    - call: NULL
[09:31:15.529] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a3cc74e960> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[09:31:15.532] plan(): Setting new future strategy stack:
List of 4
  ..$ :[09:31:15.532] List of future strategies:
[09:31:15.532] 1. multicore:
[09:31:15.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:15.532]    - tweaked: FALSE
[09:31:15.532]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:15.538] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:15.542] resolve() on list environment ...
[09:31:15.543]  recursive: 0
[09:31:15.544]  length: 6
[09:31:15.544]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:15.544] signalConditionsASAP(numeric, pos=1) ...
[09:31:15.544] - nx: 6
[09:31:15.545] - relay: TRUE
[09:31:15.545] - stdout: TRUE
[09:31:15.545] - signal: TRUE
[09:31:15.545] - resignal: FALSE
[09:31:15.545] - force: TRUE
[09:31:15.545] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.545] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.545]  - until=2
[09:31:15.546]  - relaying element #2
[09:31:15.546] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.546] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.546] signalConditionsASAP(NULL, pos=1) ... done
[09:31:15.546]  length: 5 (resolved future 1)
[09:31:15.546] Future #2
[09:31:15.546] result() for MulticoreFuture ...
[09:31:15.547] result() for MulticoreFuture ... done
[09:31:15.547] result() for MulticoreFuture ...
[09:31:15.547] result() for MulticoreFuture ... done
[09:31:15.547] signalConditionsASAP(MulticoreFuture, pos=2) ...
[09:31:15.547] - nx: 6
[09:31:15.547] - relay: TRUE
[09:31:15.547] - stdout: TRUE
[09:31:15.547] - signal: TRUE
[09:31:15.548] - resignal: FALSE
[09:31:15.548] - force: TRUE
[09:31:15.548] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.548] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:15.548]  - until=2
[09:31:15.548]  - relaying element #2
[09:31:15.548] result() for MulticoreFuture ...
[09:31:15.548] result() for MulticoreFuture ... done
[09:31:15.549] result() for MulticoreFuture ...
[09:31:15.549] result() for MulticoreFuture ... done
[09:31:15.549] result() for MulticoreFuture ...
[09:31:15.549] result() for MulticoreFuture ... done
[09:31:15.549] result() for MulticoreFuture ...
[09:31:15.549] result() for MulticoreFuture ... done
[09:31:15.549] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.549] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.550] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[09:31:15.550]  length: 4 (resolved future 2)
[09:31:15.550] Future #3
[09:31:15.550] result() for MulticoreFuture ...
[09:31:15.551] result() for MulticoreFuture ...
[09:31:15.551] result() for MulticoreFuture ... done
[09:31:15.551] result() for MulticoreFuture ... done
[09:31:15.551] result() for MulticoreFuture ...
[09:31:15.552] result() for MulticoreFuture ... done
[09:31:15.552] signalConditionsASAP(MulticoreFuture, pos=3) ...
[09:31:15.552] - nx: 6
[09:31:15.552] - relay: TRUE
[09:31:15.552] - stdout: TRUE
[09:31:15.552] - signal: TRUE
[09:31:15.552] - resignal: FALSE
[09:31:15.552] - force: TRUE
[09:31:15.553] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.553] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:15.553]  - until=3
[09:31:15.553]  - relaying element #3
[09:31:15.553] result() for MulticoreFuture ...
[09:31:15.553] result() for MulticoreFuture ... done
[09:31:15.553] result() for MulticoreFuture ...
[09:31:15.553] result() for MulticoreFuture ... done
[09:31:15.554] result() for MulticoreFuture ...
[09:31:15.554] result() for MulticoreFuture ... done
[09:31:15.554] result() for MulticoreFuture ...
[09:31:15.554] result() for MulticoreFuture ... done
[09:31:15.554] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.554] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.554] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[09:31:15.554]  length: 3 (resolved future 3)
[09:31:15.555] Future #4
[09:31:15.555] result() for MulticoreFuture ...
[09:31:15.556] result() for MulticoreFuture ...
[09:31:15.556] result() for MulticoreFuture ... done
[09:31:15.556] result() for MulticoreFuture ... done
[09:31:15.556] result() for MulticoreFuture ...
[09:31:15.557] result() for MulticoreFuture ... done
[09:31:15.557] signalConditionsASAP(MulticoreFuture, pos=4) ...
[09:31:15.562] - nx: 6
[09:31:15.562] - relay: TRUE
[09:31:15.562] - stdout: TRUE
[09:31:15.562] - signal: TRUE
[09:31:15.563] - resignal: FALSE
[09:31:15.563] - force: TRUE
[09:31:15.563] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.563] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:15.563]  - until=4
[09:31:15.564]  - relaying element #4
[09:31:15.564] result() for MulticoreFuture ...
[09:31:15.564] result() for MulticoreFuture ... done
[09:31:15.564] result() for MulticoreFuture ...
[09:31:15.564] result() for MulticoreFuture ... done
[09:31:15.564] result() for MulticoreFuture ...
[09:31:15.564] result() for MulticoreFuture ... done
[09:31:15.564] result() for MulticoreFuture ...
[09:31:15.565] result() for MulticoreFuture ... done
[09:31:15.565] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.565] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.565] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[09:31:15.565]  length: 2 (resolved future 4)
[09:31:15.565] signalConditionsASAP(NULL, pos=5) ...
[09:31:15.565] - nx: 6
[09:31:15.565] - relay: TRUE
[09:31:15.565] - stdout: TRUE
[09:31:15.566] - signal: TRUE
[09:31:15.566] - resignal: FALSE
[09:31:15.566] - force: TRUE
[09:31:15.566] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.566] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.566]  - until=6
[09:31:15.566]  - relaying element #6
[09:31:15.566] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.566] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.566] signalConditionsASAP(NULL, pos=5) ... done
[09:31:15.567]  length: 1 (resolved future 5)
[09:31:15.567] signalConditionsASAP(numeric, pos=6) ...
[09:31:15.567] - nx: 6
[09:31:15.567] - relay: TRUE
[09:31:15.567] - stdout: TRUE
[09:31:15.567] - signal: TRUE
[09:31:15.567] - resignal: FALSE
[09:31:15.567] - force: TRUE
[09:31:15.567] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:15.567] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.568]  - until=6
[09:31:15.568] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.568] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.568] signalConditionsASAP(numeric, pos=6) ... done
[09:31:15.568]  length: 0 (resolved future 6)
[09:31:15.568] Relaying remaining futures
[09:31:15.568] signalConditionsASAP(NULL, pos=0) ...
[09:31:15.568] - nx: 6
[09:31:15.568] - relay: TRUE
[09:31:15.568] - stdout: TRUE
[09:31:15.569] - signal: TRUE
[09:31:15.569] - resignal: FALSE
[09:31:15.569] - force: TRUE
[09:31:15.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.569] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:15.569] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:15.569] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:15.569] signalConditionsASAP(NULL, pos=0) ... done
[09:31:15.569] resolve() on list environment ... DONE
[09:31:15.570] result() for MulticoreFuture ...
[09:31:15.570] result() for MulticoreFuture ... done
[09:31:15.570] result() for MulticoreFuture ...
[09:31:15.570] result() for MulticoreFuture ... done
[09:31:15.570] result() for MulticoreFuture ...
[09:31:15.570] result() for MulticoreFuture ... done
[09:31:15.570] result() for MulticoreFuture ...
[09:31:15.570] result() for MulticoreFuture ... done
[09:31:15.571] result() for MulticoreFuture ...
[09:31:15.571] result() for MulticoreFuture ... done
[09:31:15.571] result() for MulticoreFuture ...
[09:31:15.571] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cca1f8e0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[09:31:15.573] plan(): Setting new future strategy stack:
[09:31:15.574] List of future strategies:
[09:31:15.574] 1. multisession:
[09:31:15.574]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:15.574]    - tweaked: FALSE
[09:31:15.574]    - call: plan(strategy)
[09:31:15.574] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:15.574] multisession:
[09:31:15.574] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:15.574] - tweaked: FALSE
[09:31:15.574] - call: plan(strategy)
[09:31:15.578] getGlobalsAndPackages() ...
[09:31:15.578] Not searching for globals
[09:31:15.578] - globals: [0] <none>
[09:31:15.578] getGlobalsAndPackages() ... DONE
[09:31:15.579] [local output] makeClusterPSOCK() ...
[09:31:15.582] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:15.583] [local output] Base port: 11516
[09:31:15.583] [local output] Getting setup options for 2 cluster nodes ...
[09:31:15.583] [local output]  - Node 1 of 2 ...
[09:31:15.583] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:15.584] [local output] Rscript port: 11516

[09:31:15.584] [local output]  - Node 2 of 2 ...
[09:31:15.585] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:15.585] [local output] Rscript port: 11516

[09:31:15.586] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:15.586] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:15.586] [local output] Setting up PSOCK nodes in parallel
[09:31:15.586] List of 36
[09:31:15.586]  $ worker          : chr "localhost"
[09:31:15.586]   ..- attr(*, "localhost")= logi TRUE
[09:31:15.586]  $ master          : chr "localhost"
[09:31:15.586]  $ port            : int 11516
[09:31:15.586]  $ connectTimeout  : num 120
[09:31:15.586]  $ timeout         : num 2592000
[09:31:15.586]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:15.586]  $ homogeneous     : logi TRUE
[09:31:15.586]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:15.586]  $ rscript_envs    : NULL
[09:31:15.586]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:15.586]  $ rscript_startup : NULL
[09:31:15.586]  $ rscript_sh      : chr "sh"
[09:31:15.586]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:15.586]  $ methods         : logi TRUE
[09:31:15.586]  $ socketOptions   : chr "no-delay"
[09:31:15.586]  $ useXDR          : logi FALSE
[09:31:15.586]  $ outfile         : chr "/dev/null"
[09:31:15.586]  $ renice          : int NA
[09:31:15.586]  $ rshcmd          : NULL
[09:31:15.586]  $ user            : chr(0) 
[09:31:15.586]  $ revtunnel       : logi FALSE
[09:31:15.586]  $ rshlogfile      : NULL
[09:31:15.586]  $ rshopts         : chr(0) 
[09:31:15.586]  $ rank            : int 1
[09:31:15.586]  $ manual          : logi FALSE
[09:31:15.586]  $ dryrun          : logi FALSE
[09:31:15.586]  $ quiet           : logi FALSE
[09:31:15.586]  $ setup_strategy  : chr "parallel"
[09:31:15.586]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:15.586]  $ pidfile         : chr "/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a47360313d61.pid"
[09:31:15.586]  $ rshcmd_label    : NULL
[09:31:15.586]  $ rsh_call        : NULL
[09:31:15.586]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:15.586]  $ localMachine    : logi TRUE
[09:31:15.586]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:15.586]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:15.586]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:15.586]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:15.586]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:15.586]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:15.586]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:15.586]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:15.586]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:15.586]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:15.586]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:15.586]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:15.586]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:15.586]  $ arguments       :List of 28
[09:31:15.586]   ..$ worker          : chr "localhost"
[09:31:15.586]   ..$ master          : NULL
[09:31:15.586]   ..$ port            : int 11516
[09:31:15.586]   ..$ connectTimeout  : num 120
[09:31:15.586]   ..$ timeout         : num 2592000
[09:31:15.586]   ..$ rscript         : NULL
[09:31:15.586]   ..$ homogeneous     : NULL
[09:31:15.586]   ..$ rscript_args    : NULL
[09:31:15.586]   ..$ rscript_envs    : NULL
[09:31:15.586]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:15.586]   ..$ rscript_startup : NULL
[09:31:15.586]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:15.586]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:15.586]   ..$ methods         : logi TRUE
[09:31:15.586]   ..$ socketOptions   : chr "no-delay"
[09:31:15.586]   ..$ useXDR          : logi FALSE
[09:31:15.586]   ..$ outfile         : chr "/dev/null"
[09:31:15.586]   ..$ renice          : int NA
[09:31:15.586]   ..$ rshcmd          : NULL
[09:31:15.586]   ..$ user            : NULL
[09:31:15.586]   ..$ revtunnel       : logi NA
[09:31:15.586]   ..$ rshlogfile      : NULL
[09:31:15.586]   ..$ rshopts         : NULL
[09:31:15.586]   ..$ rank            : int 1
[09:31:15.586]   ..$ manual          : logi FALSE
[09:31:15.586]   ..$ dryrun          : logi FALSE
[09:31:15.586]   ..$ quiet           : logi FALSE
[09:31:15.586]   ..$ setup_strategy  : chr "parallel"
[09:31:15.586]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:15.605] [local output] System call to launch all workers:
[09:31:15.605] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpS7JS9w/worker.rank=1.parallelly.parent=42099.a47360313d61.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11516 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:15.605] [local output] Starting PSOCK main server
[09:31:15.606] [local output] Workers launched
[09:31:15.607] [local output] Waiting for workers to connect back
[09:31:15.607]  - [local output] 0 workers out of 2 ready
[09:31:15.842]  - [local output] 0 workers out of 2 ready
[09:31:15.842]  - [local output] 1 workers out of 2 ready
[09:31:15.851]  - [local output] 1 workers out of 2 ready
[09:31:15.852]  - [local output] 2 workers out of 2 ready
[09:31:15.852] [local output] Launching of workers completed
[09:31:15.852] [local output] Collecting session information from workers
[09:31:15.852] [local output]  - Worker #1 of 2
[09:31:15.853] [local output]  - Worker #2 of 2
[09:31:15.853] [local output] makeClusterPSOCK() ... done
[09:31:15.864] Packages needed by the future expression (n = 0): <none>
[09:31:15.864] Packages needed by future strategies (n = 0): <none>
[09:31:15.865] {
[09:31:15.865]     {
[09:31:15.865]         {
[09:31:15.865]             ...future.startTime <- base::Sys.time()
[09:31:15.865]             {
[09:31:15.865]                 {
[09:31:15.865]                   {
[09:31:15.865]                     {
[09:31:15.865]                       base::local({
[09:31:15.865]                         has_future <- base::requireNamespace("future", 
[09:31:15.865]                           quietly = TRUE)
[09:31:15.865]                         if (has_future) {
[09:31:15.865]                           ns <- base::getNamespace("future")
[09:31:15.865]                           version <- ns[[".package"]][["version"]]
[09:31:15.865]                           if (is.null(version)) 
[09:31:15.865]                             version <- utils::packageVersion("future")
[09:31:15.865]                         }
[09:31:15.865]                         else {
[09:31:15.865]                           version <- NULL
[09:31:15.865]                         }
[09:31:15.865]                         if (!has_future || version < "1.8.0") {
[09:31:15.865]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.865]                             "", base::R.version$version.string), 
[09:31:15.865]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.865]                               "release", "version")], collapse = " "), 
[09:31:15.865]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.865]                             info)
[09:31:15.865]                           info <- base::paste(info, collapse = "; ")
[09:31:15.865]                           if (!has_future) {
[09:31:15.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.865]                               info)
[09:31:15.865]                           }
[09:31:15.865]                           else {
[09:31:15.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.865]                               info, version)
[09:31:15.865]                           }
[09:31:15.865]                           base::stop(msg)
[09:31:15.865]                         }
[09:31:15.865]                       })
[09:31:15.865]                     }
[09:31:15.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.865]                     base::options(mc.cores = 1L)
[09:31:15.865]                   }
[09:31:15.865]                   ...future.strategy.old <- future::plan("list")
[09:31:15.865]                   options(future.plan = NULL)
[09:31:15.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.865]                 }
[09:31:15.865]                 ...future.workdir <- getwd()
[09:31:15.865]             }
[09:31:15.865]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.865]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.865]         }
[09:31:15.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.865]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.865]             base::names(...future.oldOptions))
[09:31:15.865]     }
[09:31:15.865]     if (FALSE) {
[09:31:15.865]     }
[09:31:15.865]     else {
[09:31:15.865]         if (TRUE) {
[09:31:15.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.865]                 open = "w")
[09:31:15.865]         }
[09:31:15.865]         else {
[09:31:15.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.865]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.865]         }
[09:31:15.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.865]             base::sink(type = "output", split = FALSE)
[09:31:15.865]             base::close(...future.stdout)
[09:31:15.865]         }, add = TRUE)
[09:31:15.865]     }
[09:31:15.865]     ...future.frame <- base::sys.nframe()
[09:31:15.865]     ...future.conditions <- base::list()
[09:31:15.865]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.865]     if (FALSE) {
[09:31:15.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.865]     }
[09:31:15.865]     ...future.result <- base::tryCatch({
[09:31:15.865]         base::withCallingHandlers({
[09:31:15.865]             ...future.value <- base::withVisible(base::local({
[09:31:15.865]                 ...future.makeSendCondition <- base::local({
[09:31:15.865]                   sendCondition <- NULL
[09:31:15.865]                   function(frame = 1L) {
[09:31:15.865]                     if (is.function(sendCondition)) 
[09:31:15.865]                       return(sendCondition)
[09:31:15.865]                     ns <- getNamespace("parallel")
[09:31:15.865]                     if (exists("sendData", mode = "function", 
[09:31:15.865]                       envir = ns)) {
[09:31:15.865]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:15.865]                         envir = ns)
[09:31:15.865]                       envir <- sys.frame(frame)
[09:31:15.865]                       master <- NULL
[09:31:15.865]                       while (!identical(envir, .GlobalEnv) && 
[09:31:15.865]                         !identical(envir, emptyenv())) {
[09:31:15.865]                         if (exists("master", mode = "list", envir = envir, 
[09:31:15.865]                           inherits = FALSE)) {
[09:31:15.865]                           master <- get("master", mode = "list", 
[09:31:15.865]                             envir = envir, inherits = FALSE)
[09:31:15.865]                           if (inherits(master, c("SOCKnode", 
[09:31:15.865]                             "SOCK0node"))) {
[09:31:15.865]                             sendCondition <<- function(cond) {
[09:31:15.865]                               data <- list(type = "VALUE", value = cond, 
[09:31:15.865]                                 success = TRUE)
[09:31:15.865]                               parallel_sendData(master, data)
[09:31:15.865]                             }
[09:31:15.865]                             return(sendCondition)
[09:31:15.865]                           }
[09:31:15.865]                         }
[09:31:15.865]                         frame <- frame + 1L
[09:31:15.865]                         envir <- sys.frame(frame)
[09:31:15.865]                       }
[09:31:15.865]                     }
[09:31:15.865]                     sendCondition <<- function(cond) NULL
[09:31:15.865]                   }
[09:31:15.865]                 })
[09:31:15.865]                 withCallingHandlers({
[09:31:15.865]                   NA
[09:31:15.865]                 }, immediateCondition = function(cond) {
[09:31:15.865]                   sendCondition <- ...future.makeSendCondition()
[09:31:15.865]                   sendCondition(cond)
[09:31:15.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.865]                   {
[09:31:15.865]                     inherits <- base::inherits
[09:31:15.865]                     invokeRestart <- base::invokeRestart
[09:31:15.865]                     is.null <- base::is.null
[09:31:15.865]                     muffled <- FALSE
[09:31:15.865]                     if (inherits(cond, "message")) {
[09:31:15.865]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.865]                       if (muffled) 
[09:31:15.865]                         invokeRestart("muffleMessage")
[09:31:15.865]                     }
[09:31:15.865]                     else if (inherits(cond, "warning")) {
[09:31:15.865]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.865]                       if (muffled) 
[09:31:15.865]                         invokeRestart("muffleWarning")
[09:31:15.865]                     }
[09:31:15.865]                     else if (inherits(cond, "condition")) {
[09:31:15.865]                       if (!is.null(pattern)) {
[09:31:15.865]                         computeRestarts <- base::computeRestarts
[09:31:15.865]                         grepl <- base::grepl
[09:31:15.865]                         restarts <- computeRestarts(cond)
[09:31:15.865]                         for (restart in restarts) {
[09:31:15.865]                           name <- restart$name
[09:31:15.865]                           if (is.null(name)) 
[09:31:15.865]                             next
[09:31:15.865]                           if (!grepl(pattern, name)) 
[09:31:15.865]                             next
[09:31:15.865]                           invokeRestart(restart)
[09:31:15.865]                           muffled <- TRUE
[09:31:15.865]                           break
[09:31:15.865]                         }
[09:31:15.865]                       }
[09:31:15.865]                     }
[09:31:15.865]                     invisible(muffled)
[09:31:15.865]                   }
[09:31:15.865]                   muffleCondition(cond)
[09:31:15.865]                 })
[09:31:15.865]             }))
[09:31:15.865]             future::FutureResult(value = ...future.value$value, 
[09:31:15.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.865]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.865]                     ...future.globalenv.names))
[09:31:15.865]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.865]         }, condition = base::local({
[09:31:15.865]             c <- base::c
[09:31:15.865]             inherits <- base::inherits
[09:31:15.865]             invokeRestart <- base::invokeRestart
[09:31:15.865]             length <- base::length
[09:31:15.865]             list <- base::list
[09:31:15.865]             seq.int <- base::seq.int
[09:31:15.865]             signalCondition <- base::signalCondition
[09:31:15.865]             sys.calls <- base::sys.calls
[09:31:15.865]             `[[` <- base::`[[`
[09:31:15.865]             `+` <- base::`+`
[09:31:15.865]             `<<-` <- base::`<<-`
[09:31:15.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.865]                   3L)]
[09:31:15.865]             }
[09:31:15.865]             function(cond) {
[09:31:15.865]                 is_error <- inherits(cond, "error")
[09:31:15.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.865]                   NULL)
[09:31:15.865]                 if (is_error) {
[09:31:15.865]                   sessionInformation <- function() {
[09:31:15.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.865]                       search = base::search(), system = base::Sys.info())
[09:31:15.865]                   }
[09:31:15.865]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.865]                     cond$call), session = sessionInformation(), 
[09:31:15.865]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.865]                   signalCondition(cond)
[09:31:15.865]                 }
[09:31:15.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.865]                 "immediateCondition"))) {
[09:31:15.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.865]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.865]                   if (TRUE && !signal) {
[09:31:15.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.865]                     {
[09:31:15.865]                       inherits <- base::inherits
[09:31:15.865]                       invokeRestart <- base::invokeRestart
[09:31:15.865]                       is.null <- base::is.null
[09:31:15.865]                       muffled <- FALSE
[09:31:15.865]                       if (inherits(cond, "message")) {
[09:31:15.865]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.865]                         if (muffled) 
[09:31:15.865]                           invokeRestart("muffleMessage")
[09:31:15.865]                       }
[09:31:15.865]                       else if (inherits(cond, "warning")) {
[09:31:15.865]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.865]                         if (muffled) 
[09:31:15.865]                           invokeRestart("muffleWarning")
[09:31:15.865]                       }
[09:31:15.865]                       else if (inherits(cond, "condition")) {
[09:31:15.865]                         if (!is.null(pattern)) {
[09:31:15.865]                           computeRestarts <- base::computeRestarts
[09:31:15.865]                           grepl <- base::grepl
[09:31:15.865]                           restarts <- computeRestarts(cond)
[09:31:15.865]                           for (restart in restarts) {
[09:31:15.865]                             name <- restart$name
[09:31:15.865]                             if (is.null(name)) 
[09:31:15.865]                               next
[09:31:15.865]                             if (!grepl(pattern, name)) 
[09:31:15.865]                               next
[09:31:15.865]                             invokeRestart(restart)
[09:31:15.865]                             muffled <- TRUE
[09:31:15.865]                             break
[09:31:15.865]                           }
[09:31:15.865]                         }
[09:31:15.865]                       }
[09:31:15.865]                       invisible(muffled)
[09:31:15.865]                     }
[09:31:15.865]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.865]                   }
[09:31:15.865]                 }
[09:31:15.865]                 else {
[09:31:15.865]                   if (TRUE) {
[09:31:15.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.865]                     {
[09:31:15.865]                       inherits <- base::inherits
[09:31:15.865]                       invokeRestart <- base::invokeRestart
[09:31:15.865]                       is.null <- base::is.null
[09:31:15.865]                       muffled <- FALSE
[09:31:15.865]                       if (inherits(cond, "message")) {
[09:31:15.865]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.865]                         if (muffled) 
[09:31:15.865]                           invokeRestart("muffleMessage")
[09:31:15.865]                       }
[09:31:15.865]                       else if (inherits(cond, "warning")) {
[09:31:15.865]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.865]                         if (muffled) 
[09:31:15.865]                           invokeRestart("muffleWarning")
[09:31:15.865]                       }
[09:31:15.865]                       else if (inherits(cond, "condition")) {
[09:31:15.865]                         if (!is.null(pattern)) {
[09:31:15.865]                           computeRestarts <- base::computeRestarts
[09:31:15.865]                           grepl <- base::grepl
[09:31:15.865]                           restarts <- computeRestarts(cond)
[09:31:15.865]                           for (restart in restarts) {
[09:31:15.865]                             name <- restart$name
[09:31:15.865]                             if (is.null(name)) 
[09:31:15.865]                               next
[09:31:15.865]                             if (!grepl(pattern, name)) 
[09:31:15.865]                               next
[09:31:15.865]                             invokeRestart(restart)
[09:31:15.865]                             muffled <- TRUE
[09:31:15.865]                             break
[09:31:15.865]                           }
[09:31:15.865]                         }
[09:31:15.865]                       }
[09:31:15.865]                       invisible(muffled)
[09:31:15.865]                     }
[09:31:15.865]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.865]                   }
[09:31:15.865]                 }
[09:31:15.865]             }
[09:31:15.865]         }))
[09:31:15.865]     }, error = function(ex) {
[09:31:15.865]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.865]                 ...future.rng), started = ...future.startTime, 
[09:31:15.865]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.865]             version = "1.8"), class = "FutureResult")
[09:31:15.865]     }, finally = {
[09:31:15.865]         if (!identical(...future.workdir, getwd())) 
[09:31:15.865]             setwd(...future.workdir)
[09:31:15.865]         {
[09:31:15.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.865]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.865]             }
[09:31:15.865]             base::options(...future.oldOptions)
[09:31:15.865]             if (.Platform$OS.type == "windows") {
[09:31:15.865]                 old_names <- names(...future.oldEnvVars)
[09:31:15.865]                 envs <- base::Sys.getenv()
[09:31:15.865]                 names <- names(envs)
[09:31:15.865]                 common <- intersect(names, old_names)
[09:31:15.865]                 added <- setdiff(names, old_names)
[09:31:15.865]                 removed <- setdiff(old_names, names)
[09:31:15.865]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.865]                   envs[common]]
[09:31:15.865]                 NAMES <- toupper(changed)
[09:31:15.865]                 args <- list()
[09:31:15.865]                 for (kk in seq_along(NAMES)) {
[09:31:15.865]                   name <- changed[[kk]]
[09:31:15.865]                   NAME <- NAMES[[kk]]
[09:31:15.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.865]                     next
[09:31:15.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.865]                 }
[09:31:15.865]                 NAMES <- toupper(added)
[09:31:15.865]                 for (kk in seq_along(NAMES)) {
[09:31:15.865]                   name <- added[[kk]]
[09:31:15.865]                   NAME <- NAMES[[kk]]
[09:31:15.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.865]                     next
[09:31:15.865]                   args[[name]] <- ""
[09:31:15.865]                 }
[09:31:15.865]                 NAMES <- toupper(removed)
[09:31:15.865]                 for (kk in seq_along(NAMES)) {
[09:31:15.865]                   name <- removed[[kk]]
[09:31:15.865]                   NAME <- NAMES[[kk]]
[09:31:15.865]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.865]                     next
[09:31:15.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.865]                 }
[09:31:15.865]                 if (length(args) > 0) 
[09:31:15.865]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.865]             }
[09:31:15.865]             else {
[09:31:15.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.865]             }
[09:31:15.865]             {
[09:31:15.865]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.865]                   0L) {
[09:31:15.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.865]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.865]                   base::options(opts)
[09:31:15.865]                 }
[09:31:15.865]                 {
[09:31:15.865]                   {
[09:31:15.865]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.865]                     NULL
[09:31:15.865]                   }
[09:31:15.865]                   options(future.plan = NULL)
[09:31:15.865]                   if (is.na(NA_character_)) 
[09:31:15.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.865]                     .init = FALSE)
[09:31:15.865]                 }
[09:31:15.865]             }
[09:31:15.865]         }
[09:31:15.865]     })
[09:31:15.865]     if (TRUE) {
[09:31:15.865]         base::sink(type = "output", split = FALSE)
[09:31:15.865]         if (TRUE) {
[09:31:15.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.865]         }
[09:31:15.865]         else {
[09:31:15.865]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.865]         }
[09:31:15.865]         base::close(...future.stdout)
[09:31:15.865]         ...future.stdout <- NULL
[09:31:15.865]     }
[09:31:15.865]     ...future.result$conditions <- ...future.conditions
[09:31:15.865]     ...future.result$finished <- base::Sys.time()
[09:31:15.865]     ...future.result
[09:31:15.865] }
[09:31:15.916] MultisessionFuture started
[09:31:15.916] result() for ClusterFuture ...
[09:31:15.916] receiveMessageFromWorker() for ClusterFuture ...
[09:31:15.916] - Validating connection of MultisessionFuture
[09:31:15.947] - received message: FutureResult
[09:31:15.948] - Received FutureResult
[09:31:15.948] - Erased future from FutureRegistry
[09:31:15.948] result() for ClusterFuture ...
[09:31:15.948] - result already collected: FutureResult
[09:31:15.948] result() for ClusterFuture ... done
[09:31:15.948] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:15.948] result() for ClusterFuture ... done
[09:31:15.948] result() for ClusterFuture ...
[09:31:15.948] - result already collected: FutureResult
[09:31:15.948] result() for ClusterFuture ... done
[09:31:15.949] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:15.952] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[09:31:15.953] getGlobalsAndPackages() ...
[09:31:15.953] Searching for globals...
[09:31:15.953] 
[09:31:15.953] Searching for globals ... DONE
[09:31:15.954] - globals: [0] <none>
[09:31:15.954] getGlobalsAndPackages() ... DONE
[09:31:15.954] run() for ‘Future’ ...
[09:31:15.954] - state: ‘created’
[09:31:15.954] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.968] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:15.968]   - Field: ‘node’
[09:31:15.968]   - Field: ‘label’
[09:31:15.968]   - Field: ‘local’
[09:31:15.968]   - Field: ‘owner’
[09:31:15.968]   - Field: ‘envir’
[09:31:15.968]   - Field: ‘workers’
[09:31:15.969]   - Field: ‘packages’
[09:31:15.969]   - Field: ‘gc’
[09:31:15.969]   - Field: ‘conditions’
[09:31:15.969]   - Field: ‘persistent’
[09:31:15.969]   - Field: ‘expr’
[09:31:15.969]   - Field: ‘uuid’
[09:31:15.969]   - Field: ‘seed’
[09:31:15.969]   - Field: ‘version’
[09:31:15.969]   - Field: ‘result’
[09:31:15.969]   - Field: ‘asynchronous’
[09:31:15.969]   - Field: ‘calls’
[09:31:15.970]   - Field: ‘globals’
[09:31:15.970]   - Field: ‘stdout’
[09:31:15.970]   - Field: ‘earlySignal’
[09:31:15.970]   - Field: ‘lazy’
[09:31:15.970]   - Field: ‘state’
[09:31:15.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:15.970] - Launch lazy future ...
[09:31:15.970] Packages needed by the future expression (n = 0): <none>
[09:31:15.970] Packages needed by future strategies (n = 0): <none>
[09:31:15.971] {
[09:31:15.971]     {
[09:31:15.971]         {
[09:31:15.971]             ...future.startTime <- base::Sys.time()
[09:31:15.971]             {
[09:31:15.971]                 {
[09:31:15.971]                   {
[09:31:15.971]                     {
[09:31:15.971]                       base::local({
[09:31:15.971]                         has_future <- base::requireNamespace("future", 
[09:31:15.971]                           quietly = TRUE)
[09:31:15.971]                         if (has_future) {
[09:31:15.971]                           ns <- base::getNamespace("future")
[09:31:15.971]                           version <- ns[[".package"]][["version"]]
[09:31:15.971]                           if (is.null(version)) 
[09:31:15.971]                             version <- utils::packageVersion("future")
[09:31:15.971]                         }
[09:31:15.971]                         else {
[09:31:15.971]                           version <- NULL
[09:31:15.971]                         }
[09:31:15.971]                         if (!has_future || version < "1.8.0") {
[09:31:15.971]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.971]                             "", base::R.version$version.string), 
[09:31:15.971]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.971]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.971]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.971]                               "release", "version")], collapse = " "), 
[09:31:15.971]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.971]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.971]                             info)
[09:31:15.971]                           info <- base::paste(info, collapse = "; ")
[09:31:15.971]                           if (!has_future) {
[09:31:15.971]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.971]                               info)
[09:31:15.971]                           }
[09:31:15.971]                           else {
[09:31:15.971]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.971]                               info, version)
[09:31:15.971]                           }
[09:31:15.971]                           base::stop(msg)
[09:31:15.971]                         }
[09:31:15.971]                       })
[09:31:15.971]                     }
[09:31:15.971]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.971]                     base::options(mc.cores = 1L)
[09:31:15.971]                   }
[09:31:15.971]                   ...future.strategy.old <- future::plan("list")
[09:31:15.971]                   options(future.plan = NULL)
[09:31:15.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.971]                 }
[09:31:15.971]                 ...future.workdir <- getwd()
[09:31:15.971]             }
[09:31:15.971]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.971]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.971]         }
[09:31:15.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.971]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.971]             base::names(...future.oldOptions))
[09:31:15.971]     }
[09:31:15.971]     if (FALSE) {
[09:31:15.971]     }
[09:31:15.971]     else {
[09:31:15.971]         if (TRUE) {
[09:31:15.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.971]                 open = "w")
[09:31:15.971]         }
[09:31:15.971]         else {
[09:31:15.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.971]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.971]         }
[09:31:15.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.971]             base::sink(type = "output", split = FALSE)
[09:31:15.971]             base::close(...future.stdout)
[09:31:15.971]         }, add = TRUE)
[09:31:15.971]     }
[09:31:15.971]     ...future.frame <- base::sys.nframe()
[09:31:15.971]     ...future.conditions <- base::list()
[09:31:15.971]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.971]     if (FALSE) {
[09:31:15.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.971]     }
[09:31:15.971]     ...future.result <- base::tryCatch({
[09:31:15.971]         base::withCallingHandlers({
[09:31:15.971]             ...future.value <- base::withVisible(base::local({
[09:31:15.971]                 ...future.makeSendCondition <- base::local({
[09:31:15.971]                   sendCondition <- NULL
[09:31:15.971]                   function(frame = 1L) {
[09:31:15.971]                     if (is.function(sendCondition)) 
[09:31:15.971]                       return(sendCondition)
[09:31:15.971]                     ns <- getNamespace("parallel")
[09:31:15.971]                     if (exists("sendData", mode = "function", 
[09:31:15.971]                       envir = ns)) {
[09:31:15.971]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:15.971]                         envir = ns)
[09:31:15.971]                       envir <- sys.frame(frame)
[09:31:15.971]                       master <- NULL
[09:31:15.971]                       while (!identical(envir, .GlobalEnv) && 
[09:31:15.971]                         !identical(envir, emptyenv())) {
[09:31:15.971]                         if (exists("master", mode = "list", envir = envir, 
[09:31:15.971]                           inherits = FALSE)) {
[09:31:15.971]                           master <- get("master", mode = "list", 
[09:31:15.971]                             envir = envir, inherits = FALSE)
[09:31:15.971]                           if (inherits(master, c("SOCKnode", 
[09:31:15.971]                             "SOCK0node"))) {
[09:31:15.971]                             sendCondition <<- function(cond) {
[09:31:15.971]                               data <- list(type = "VALUE", value = cond, 
[09:31:15.971]                                 success = TRUE)
[09:31:15.971]                               parallel_sendData(master, data)
[09:31:15.971]                             }
[09:31:15.971]                             return(sendCondition)
[09:31:15.971]                           }
[09:31:15.971]                         }
[09:31:15.971]                         frame <- frame + 1L
[09:31:15.971]                         envir <- sys.frame(frame)
[09:31:15.971]                       }
[09:31:15.971]                     }
[09:31:15.971]                     sendCondition <<- function(cond) NULL
[09:31:15.971]                   }
[09:31:15.971]                 })
[09:31:15.971]                 withCallingHandlers({
[09:31:15.971]                   2
[09:31:15.971]                 }, immediateCondition = function(cond) {
[09:31:15.971]                   sendCondition <- ...future.makeSendCondition()
[09:31:15.971]                   sendCondition(cond)
[09:31:15.971]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.971]                   {
[09:31:15.971]                     inherits <- base::inherits
[09:31:15.971]                     invokeRestart <- base::invokeRestart
[09:31:15.971]                     is.null <- base::is.null
[09:31:15.971]                     muffled <- FALSE
[09:31:15.971]                     if (inherits(cond, "message")) {
[09:31:15.971]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.971]                       if (muffled) 
[09:31:15.971]                         invokeRestart("muffleMessage")
[09:31:15.971]                     }
[09:31:15.971]                     else if (inherits(cond, "warning")) {
[09:31:15.971]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.971]                       if (muffled) 
[09:31:15.971]                         invokeRestart("muffleWarning")
[09:31:15.971]                     }
[09:31:15.971]                     else if (inherits(cond, "condition")) {
[09:31:15.971]                       if (!is.null(pattern)) {
[09:31:15.971]                         computeRestarts <- base::computeRestarts
[09:31:15.971]                         grepl <- base::grepl
[09:31:15.971]                         restarts <- computeRestarts(cond)
[09:31:15.971]                         for (restart in restarts) {
[09:31:15.971]                           name <- restart$name
[09:31:15.971]                           if (is.null(name)) 
[09:31:15.971]                             next
[09:31:15.971]                           if (!grepl(pattern, name)) 
[09:31:15.971]                             next
[09:31:15.971]                           invokeRestart(restart)
[09:31:15.971]                           muffled <- TRUE
[09:31:15.971]                           break
[09:31:15.971]                         }
[09:31:15.971]                       }
[09:31:15.971]                     }
[09:31:15.971]                     invisible(muffled)
[09:31:15.971]                   }
[09:31:15.971]                   muffleCondition(cond)
[09:31:15.971]                 })
[09:31:15.971]             }))
[09:31:15.971]             future::FutureResult(value = ...future.value$value, 
[09:31:15.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.971]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.971]                     ...future.globalenv.names))
[09:31:15.971]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.971]         }, condition = base::local({
[09:31:15.971]             c <- base::c
[09:31:15.971]             inherits <- base::inherits
[09:31:15.971]             invokeRestart <- base::invokeRestart
[09:31:15.971]             length <- base::length
[09:31:15.971]             list <- base::list
[09:31:15.971]             seq.int <- base::seq.int
[09:31:15.971]             signalCondition <- base::signalCondition
[09:31:15.971]             sys.calls <- base::sys.calls
[09:31:15.971]             `[[` <- base::`[[`
[09:31:15.971]             `+` <- base::`+`
[09:31:15.971]             `<<-` <- base::`<<-`
[09:31:15.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.971]                   3L)]
[09:31:15.971]             }
[09:31:15.971]             function(cond) {
[09:31:15.971]                 is_error <- inherits(cond, "error")
[09:31:15.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.971]                   NULL)
[09:31:15.971]                 if (is_error) {
[09:31:15.971]                   sessionInformation <- function() {
[09:31:15.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.971]                       search = base::search(), system = base::Sys.info())
[09:31:15.971]                   }
[09:31:15.971]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.971]                     cond$call), session = sessionInformation(), 
[09:31:15.971]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.971]                   signalCondition(cond)
[09:31:15.971]                 }
[09:31:15.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.971]                 "immediateCondition"))) {
[09:31:15.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.971]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.971]                   if (TRUE && !signal) {
[09:31:15.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.971]                     {
[09:31:15.971]                       inherits <- base::inherits
[09:31:15.971]                       invokeRestart <- base::invokeRestart
[09:31:15.971]                       is.null <- base::is.null
[09:31:15.971]                       muffled <- FALSE
[09:31:15.971]                       if (inherits(cond, "message")) {
[09:31:15.971]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.971]                         if (muffled) 
[09:31:15.971]                           invokeRestart("muffleMessage")
[09:31:15.971]                       }
[09:31:15.971]                       else if (inherits(cond, "warning")) {
[09:31:15.971]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.971]                         if (muffled) 
[09:31:15.971]                           invokeRestart("muffleWarning")
[09:31:15.971]                       }
[09:31:15.971]                       else if (inherits(cond, "condition")) {
[09:31:15.971]                         if (!is.null(pattern)) {
[09:31:15.971]                           computeRestarts <- base::computeRestarts
[09:31:15.971]                           grepl <- base::grepl
[09:31:15.971]                           restarts <- computeRestarts(cond)
[09:31:15.971]                           for (restart in restarts) {
[09:31:15.971]                             name <- restart$name
[09:31:15.971]                             if (is.null(name)) 
[09:31:15.971]                               next
[09:31:15.971]                             if (!grepl(pattern, name)) 
[09:31:15.971]                               next
[09:31:15.971]                             invokeRestart(restart)
[09:31:15.971]                             muffled <- TRUE
[09:31:15.971]                             break
[09:31:15.971]                           }
[09:31:15.971]                         }
[09:31:15.971]                       }
[09:31:15.971]                       invisible(muffled)
[09:31:15.971]                     }
[09:31:15.971]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.971]                   }
[09:31:15.971]                 }
[09:31:15.971]                 else {
[09:31:15.971]                   if (TRUE) {
[09:31:15.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.971]                     {
[09:31:15.971]                       inherits <- base::inherits
[09:31:15.971]                       invokeRestart <- base::invokeRestart
[09:31:15.971]                       is.null <- base::is.null
[09:31:15.971]                       muffled <- FALSE
[09:31:15.971]                       if (inherits(cond, "message")) {
[09:31:15.971]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.971]                         if (muffled) 
[09:31:15.971]                           invokeRestart("muffleMessage")
[09:31:15.971]                       }
[09:31:15.971]                       else if (inherits(cond, "warning")) {
[09:31:15.971]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.971]                         if (muffled) 
[09:31:15.971]                           invokeRestart("muffleWarning")
[09:31:15.971]                       }
[09:31:15.971]                       else if (inherits(cond, "condition")) {
[09:31:15.971]                         if (!is.null(pattern)) {
[09:31:15.971]                           computeRestarts <- base::computeRestarts
[09:31:15.971]                           grepl <- base::grepl
[09:31:15.971]                           restarts <- computeRestarts(cond)
[09:31:15.971]                           for (restart in restarts) {
[09:31:15.971]                             name <- restart$name
[09:31:15.971]                             if (is.null(name)) 
[09:31:15.971]                               next
[09:31:15.971]                             if (!grepl(pattern, name)) 
[09:31:15.971]                               next
[09:31:15.971]                             invokeRestart(restart)
[09:31:15.971]                             muffled <- TRUE
[09:31:15.971]                             break
[09:31:15.971]                           }
[09:31:15.971]                         }
[09:31:15.971]                       }
[09:31:15.971]                       invisible(muffled)
[09:31:15.971]                     }
[09:31:15.971]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.971]                   }
[09:31:15.971]                 }
[09:31:15.971]             }
[09:31:15.971]         }))
[09:31:15.971]     }, error = function(ex) {
[09:31:15.971]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.971]                 ...future.rng), started = ...future.startTime, 
[09:31:15.971]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.971]             version = "1.8"), class = "FutureResult")
[09:31:15.971]     }, finally = {
[09:31:15.971]         if (!identical(...future.workdir, getwd())) 
[09:31:15.971]             setwd(...future.workdir)
[09:31:15.971]         {
[09:31:15.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.971]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.971]             }
[09:31:15.971]             base::options(...future.oldOptions)
[09:31:15.971]             if (.Platform$OS.type == "windows") {
[09:31:15.971]                 old_names <- names(...future.oldEnvVars)
[09:31:15.971]                 envs <- base::Sys.getenv()
[09:31:15.971]                 names <- names(envs)
[09:31:15.971]                 common <- intersect(names, old_names)
[09:31:15.971]                 added <- setdiff(names, old_names)
[09:31:15.971]                 removed <- setdiff(old_names, names)
[09:31:15.971]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.971]                   envs[common]]
[09:31:15.971]                 NAMES <- toupper(changed)
[09:31:15.971]                 args <- list()
[09:31:15.971]                 for (kk in seq_along(NAMES)) {
[09:31:15.971]                   name <- changed[[kk]]
[09:31:15.971]                   NAME <- NAMES[[kk]]
[09:31:15.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.971]                     next
[09:31:15.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.971]                 }
[09:31:15.971]                 NAMES <- toupper(added)
[09:31:15.971]                 for (kk in seq_along(NAMES)) {
[09:31:15.971]                   name <- added[[kk]]
[09:31:15.971]                   NAME <- NAMES[[kk]]
[09:31:15.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.971]                     next
[09:31:15.971]                   args[[name]] <- ""
[09:31:15.971]                 }
[09:31:15.971]                 NAMES <- toupper(removed)
[09:31:15.971]                 for (kk in seq_along(NAMES)) {
[09:31:15.971]                   name <- removed[[kk]]
[09:31:15.971]                   NAME <- NAMES[[kk]]
[09:31:15.971]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.971]                     next
[09:31:15.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.971]                 }
[09:31:15.971]                 if (length(args) > 0) 
[09:31:15.971]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.971]             }
[09:31:15.971]             else {
[09:31:15.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.971]             }
[09:31:15.971]             {
[09:31:15.971]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.971]                   0L) {
[09:31:15.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.971]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.971]                   base::options(opts)
[09:31:15.971]                 }
[09:31:15.971]                 {
[09:31:15.971]                   {
[09:31:15.971]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.971]                     NULL
[09:31:15.971]                   }
[09:31:15.971]                   options(future.plan = NULL)
[09:31:15.971]                   if (is.na(NA_character_)) 
[09:31:15.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.971]                     .init = FALSE)
[09:31:15.971]                 }
[09:31:15.971]             }
[09:31:15.971]         }
[09:31:15.971]     })
[09:31:15.971]     if (TRUE) {
[09:31:15.971]         base::sink(type = "output", split = FALSE)
[09:31:15.971]         if (TRUE) {
[09:31:15.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.971]         }
[09:31:15.971]         else {
[09:31:15.971]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.971]         }
[09:31:15.971]         base::close(...future.stdout)
[09:31:15.971]         ...future.stdout <- NULL
[09:31:15.971]     }
[09:31:15.971]     ...future.result$conditions <- ...future.conditions
[09:31:15.971]     ...future.result$finished <- base::Sys.time()
[09:31:15.971]     ...future.result
[09:31:15.971] }
[09:31:15.974] MultisessionFuture started
[09:31:15.974] - Launch lazy future ... done
[09:31:15.974] run() for ‘MultisessionFuture’ ... done
[09:31:15.974] getGlobalsAndPackages() ...
[09:31:15.974] Searching for globals...
[09:31:15.975] 
[09:31:15.975] Searching for globals ... DONE
[09:31:15.975] - globals: [0] <none>
[09:31:15.975] getGlobalsAndPackages() ... DONE
[09:31:15.975] run() for ‘Future’ ...
[09:31:15.975] - state: ‘created’
[09:31:15.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:15.989] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:15.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:15.989]   - Field: ‘node’
[09:31:15.989]   - Field: ‘label’
[09:31:15.989]   - Field: ‘local’
[09:31:15.989]   - Field: ‘owner’
[09:31:15.989]   - Field: ‘envir’
[09:31:15.989]   - Field: ‘workers’
[09:31:15.990]   - Field: ‘packages’
[09:31:15.990]   - Field: ‘gc’
[09:31:15.990]   - Field: ‘conditions’
[09:31:15.990]   - Field: ‘persistent’
[09:31:15.990]   - Field: ‘expr’
[09:31:15.990]   - Field: ‘uuid’
[09:31:15.990]   - Field: ‘seed’
[09:31:15.990]   - Field: ‘version’
[09:31:15.990]   - Field: ‘result’
[09:31:15.990]   - Field: ‘asynchronous’
[09:31:15.990]   - Field: ‘calls’
[09:31:15.991]   - Field: ‘globals’
[09:31:15.991]   - Field: ‘stdout’
[09:31:15.991]   - Field: ‘earlySignal’
[09:31:15.991]   - Field: ‘lazy’
[09:31:15.991]   - Field: ‘state’
[09:31:15.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:15.991] - Launch lazy future ...
[09:31:15.991] Packages needed by the future expression (n = 0): <none>
[09:31:15.991] Packages needed by future strategies (n = 0): <none>
[09:31:15.992] {
[09:31:15.992]     {
[09:31:15.992]         {
[09:31:15.992]             ...future.startTime <- base::Sys.time()
[09:31:15.992]             {
[09:31:15.992]                 {
[09:31:15.992]                   {
[09:31:15.992]                     {
[09:31:15.992]                       base::local({
[09:31:15.992]                         has_future <- base::requireNamespace("future", 
[09:31:15.992]                           quietly = TRUE)
[09:31:15.992]                         if (has_future) {
[09:31:15.992]                           ns <- base::getNamespace("future")
[09:31:15.992]                           version <- ns[[".package"]][["version"]]
[09:31:15.992]                           if (is.null(version)) 
[09:31:15.992]                             version <- utils::packageVersion("future")
[09:31:15.992]                         }
[09:31:15.992]                         else {
[09:31:15.992]                           version <- NULL
[09:31:15.992]                         }
[09:31:15.992]                         if (!has_future || version < "1.8.0") {
[09:31:15.992]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:15.992]                             "", base::R.version$version.string), 
[09:31:15.992]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:15.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:15.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:15.992]                               "release", "version")], collapse = " "), 
[09:31:15.992]                             hostname = base::Sys.info()[["nodename"]])
[09:31:15.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:15.992]                             info)
[09:31:15.992]                           info <- base::paste(info, collapse = "; ")
[09:31:15.992]                           if (!has_future) {
[09:31:15.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:15.992]                               info)
[09:31:15.992]                           }
[09:31:15.992]                           else {
[09:31:15.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:15.992]                               info, version)
[09:31:15.992]                           }
[09:31:15.992]                           base::stop(msg)
[09:31:15.992]                         }
[09:31:15.992]                       })
[09:31:15.992]                     }
[09:31:15.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:15.992]                     base::options(mc.cores = 1L)
[09:31:15.992]                   }
[09:31:15.992]                   ...future.strategy.old <- future::plan("list")
[09:31:15.992]                   options(future.plan = NULL)
[09:31:15.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:15.992]                 }
[09:31:15.992]                 ...future.workdir <- getwd()
[09:31:15.992]             }
[09:31:15.992]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:15.992]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:15.992]         }
[09:31:15.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:15.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:15.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:15.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:15.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:15.992]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:15.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:15.992]             base::names(...future.oldOptions))
[09:31:15.992]     }
[09:31:15.992]     if (FALSE) {
[09:31:15.992]     }
[09:31:15.992]     else {
[09:31:15.992]         if (TRUE) {
[09:31:15.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:15.992]                 open = "w")
[09:31:15.992]         }
[09:31:15.992]         else {
[09:31:15.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:15.992]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:15.992]         }
[09:31:15.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:15.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:15.992]             base::sink(type = "output", split = FALSE)
[09:31:15.992]             base::close(...future.stdout)
[09:31:15.992]         }, add = TRUE)
[09:31:15.992]     }
[09:31:15.992]     ...future.frame <- base::sys.nframe()
[09:31:15.992]     ...future.conditions <- base::list()
[09:31:15.992]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:15.992]     if (FALSE) {
[09:31:15.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:15.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:15.992]     }
[09:31:15.992]     ...future.result <- base::tryCatch({
[09:31:15.992]         base::withCallingHandlers({
[09:31:15.992]             ...future.value <- base::withVisible(base::local({
[09:31:15.992]                 ...future.makeSendCondition <- base::local({
[09:31:15.992]                   sendCondition <- NULL
[09:31:15.992]                   function(frame = 1L) {
[09:31:15.992]                     if (is.function(sendCondition)) 
[09:31:15.992]                       return(sendCondition)
[09:31:15.992]                     ns <- getNamespace("parallel")
[09:31:15.992]                     if (exists("sendData", mode = "function", 
[09:31:15.992]                       envir = ns)) {
[09:31:15.992]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:15.992]                         envir = ns)
[09:31:15.992]                       envir <- sys.frame(frame)
[09:31:15.992]                       master <- NULL
[09:31:15.992]                       while (!identical(envir, .GlobalEnv) && 
[09:31:15.992]                         !identical(envir, emptyenv())) {
[09:31:15.992]                         if (exists("master", mode = "list", envir = envir, 
[09:31:15.992]                           inherits = FALSE)) {
[09:31:15.992]                           master <- get("master", mode = "list", 
[09:31:15.992]                             envir = envir, inherits = FALSE)
[09:31:15.992]                           if (inherits(master, c("SOCKnode", 
[09:31:15.992]                             "SOCK0node"))) {
[09:31:15.992]                             sendCondition <<- function(cond) {
[09:31:15.992]                               data <- list(type = "VALUE", value = cond, 
[09:31:15.992]                                 success = TRUE)
[09:31:15.992]                               parallel_sendData(master, data)
[09:31:15.992]                             }
[09:31:15.992]                             return(sendCondition)
[09:31:15.992]                           }
[09:31:15.992]                         }
[09:31:15.992]                         frame <- frame + 1L
[09:31:15.992]                         envir <- sys.frame(frame)
[09:31:15.992]                       }
[09:31:15.992]                     }
[09:31:15.992]                     sendCondition <<- function(cond) NULL
[09:31:15.992]                   }
[09:31:15.992]                 })
[09:31:15.992]                 withCallingHandlers({
[09:31:15.992]                   NULL
[09:31:15.992]                 }, immediateCondition = function(cond) {
[09:31:15.992]                   sendCondition <- ...future.makeSendCondition()
[09:31:15.992]                   sendCondition(cond)
[09:31:15.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.992]                   {
[09:31:15.992]                     inherits <- base::inherits
[09:31:15.992]                     invokeRestart <- base::invokeRestart
[09:31:15.992]                     is.null <- base::is.null
[09:31:15.992]                     muffled <- FALSE
[09:31:15.992]                     if (inherits(cond, "message")) {
[09:31:15.992]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:15.992]                       if (muffled) 
[09:31:15.992]                         invokeRestart("muffleMessage")
[09:31:15.992]                     }
[09:31:15.992]                     else if (inherits(cond, "warning")) {
[09:31:15.992]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:15.992]                       if (muffled) 
[09:31:15.992]                         invokeRestart("muffleWarning")
[09:31:15.992]                     }
[09:31:15.992]                     else if (inherits(cond, "condition")) {
[09:31:15.992]                       if (!is.null(pattern)) {
[09:31:15.992]                         computeRestarts <- base::computeRestarts
[09:31:15.992]                         grepl <- base::grepl
[09:31:15.992]                         restarts <- computeRestarts(cond)
[09:31:15.992]                         for (restart in restarts) {
[09:31:15.992]                           name <- restart$name
[09:31:15.992]                           if (is.null(name)) 
[09:31:15.992]                             next
[09:31:15.992]                           if (!grepl(pattern, name)) 
[09:31:15.992]                             next
[09:31:15.992]                           invokeRestart(restart)
[09:31:15.992]                           muffled <- TRUE
[09:31:15.992]                           break
[09:31:15.992]                         }
[09:31:15.992]                       }
[09:31:15.992]                     }
[09:31:15.992]                     invisible(muffled)
[09:31:15.992]                   }
[09:31:15.992]                   muffleCondition(cond)
[09:31:15.992]                 })
[09:31:15.992]             }))
[09:31:15.992]             future::FutureResult(value = ...future.value$value, 
[09:31:15.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.992]                   ...future.rng), globalenv = if (FALSE) 
[09:31:15.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:15.992]                     ...future.globalenv.names))
[09:31:15.992]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:15.992]         }, condition = base::local({
[09:31:15.992]             c <- base::c
[09:31:15.992]             inherits <- base::inherits
[09:31:15.992]             invokeRestart <- base::invokeRestart
[09:31:15.992]             length <- base::length
[09:31:15.992]             list <- base::list
[09:31:15.992]             seq.int <- base::seq.int
[09:31:15.992]             signalCondition <- base::signalCondition
[09:31:15.992]             sys.calls <- base::sys.calls
[09:31:15.992]             `[[` <- base::`[[`
[09:31:15.992]             `+` <- base::`+`
[09:31:15.992]             `<<-` <- base::`<<-`
[09:31:15.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:15.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:15.992]                   3L)]
[09:31:15.992]             }
[09:31:15.992]             function(cond) {
[09:31:15.992]                 is_error <- inherits(cond, "error")
[09:31:15.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:15.992]                   NULL)
[09:31:15.992]                 if (is_error) {
[09:31:15.992]                   sessionInformation <- function() {
[09:31:15.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:15.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:15.992]                       search = base::search(), system = base::Sys.info())
[09:31:15.992]                   }
[09:31:15.992]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:15.992]                     cond$call), session = sessionInformation(), 
[09:31:15.992]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:15.992]                   signalCondition(cond)
[09:31:15.992]                 }
[09:31:15.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:15.992]                 "immediateCondition"))) {
[09:31:15.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:15.992]                   ...future.conditions[[length(...future.conditions) + 
[09:31:15.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:15.992]                   if (TRUE && !signal) {
[09:31:15.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.992]                     {
[09:31:15.992]                       inherits <- base::inherits
[09:31:15.992]                       invokeRestart <- base::invokeRestart
[09:31:15.992]                       is.null <- base::is.null
[09:31:15.992]                       muffled <- FALSE
[09:31:15.992]                       if (inherits(cond, "message")) {
[09:31:15.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.992]                         if (muffled) 
[09:31:15.992]                           invokeRestart("muffleMessage")
[09:31:15.992]                       }
[09:31:15.992]                       else if (inherits(cond, "warning")) {
[09:31:15.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.992]                         if (muffled) 
[09:31:15.992]                           invokeRestart("muffleWarning")
[09:31:15.992]                       }
[09:31:15.992]                       else if (inherits(cond, "condition")) {
[09:31:15.992]                         if (!is.null(pattern)) {
[09:31:15.992]                           computeRestarts <- base::computeRestarts
[09:31:15.992]                           grepl <- base::grepl
[09:31:15.992]                           restarts <- computeRestarts(cond)
[09:31:15.992]                           for (restart in restarts) {
[09:31:15.992]                             name <- restart$name
[09:31:15.992]                             if (is.null(name)) 
[09:31:15.992]                               next
[09:31:15.992]                             if (!grepl(pattern, name)) 
[09:31:15.992]                               next
[09:31:15.992]                             invokeRestart(restart)
[09:31:15.992]                             muffled <- TRUE
[09:31:15.992]                             break
[09:31:15.992]                           }
[09:31:15.992]                         }
[09:31:15.992]                       }
[09:31:15.992]                       invisible(muffled)
[09:31:15.992]                     }
[09:31:15.992]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.992]                   }
[09:31:15.992]                 }
[09:31:15.992]                 else {
[09:31:15.992]                   if (TRUE) {
[09:31:15.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:15.992]                     {
[09:31:15.992]                       inherits <- base::inherits
[09:31:15.992]                       invokeRestart <- base::invokeRestart
[09:31:15.992]                       is.null <- base::is.null
[09:31:15.992]                       muffled <- FALSE
[09:31:15.992]                       if (inherits(cond, "message")) {
[09:31:15.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:15.992]                         if (muffled) 
[09:31:15.992]                           invokeRestart("muffleMessage")
[09:31:15.992]                       }
[09:31:15.992]                       else if (inherits(cond, "warning")) {
[09:31:15.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:15.992]                         if (muffled) 
[09:31:15.992]                           invokeRestart("muffleWarning")
[09:31:15.992]                       }
[09:31:15.992]                       else if (inherits(cond, "condition")) {
[09:31:15.992]                         if (!is.null(pattern)) {
[09:31:15.992]                           computeRestarts <- base::computeRestarts
[09:31:15.992]                           grepl <- base::grepl
[09:31:15.992]                           restarts <- computeRestarts(cond)
[09:31:15.992]                           for (restart in restarts) {
[09:31:15.992]                             name <- restart$name
[09:31:15.992]                             if (is.null(name)) 
[09:31:15.992]                               next
[09:31:15.992]                             if (!grepl(pattern, name)) 
[09:31:15.992]                               next
[09:31:15.992]                             invokeRestart(restart)
[09:31:15.992]                             muffled <- TRUE
[09:31:15.992]                             break
[09:31:15.992]                           }
[09:31:15.992]                         }
[09:31:15.992]                       }
[09:31:15.992]                       invisible(muffled)
[09:31:15.992]                     }
[09:31:15.992]                     muffleCondition(cond, pattern = "^muffle")
[09:31:15.992]                   }
[09:31:15.992]                 }
[09:31:15.992]             }
[09:31:15.992]         }))
[09:31:15.992]     }, error = function(ex) {
[09:31:15.992]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:15.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:15.992]                 ...future.rng), started = ...future.startTime, 
[09:31:15.992]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:15.992]             version = "1.8"), class = "FutureResult")
[09:31:15.992]     }, finally = {
[09:31:15.992]         if (!identical(...future.workdir, getwd())) 
[09:31:15.992]             setwd(...future.workdir)
[09:31:15.992]         {
[09:31:15.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:15.992]                 ...future.oldOptions$nwarnings <- NULL
[09:31:15.992]             }
[09:31:15.992]             base::options(...future.oldOptions)
[09:31:15.992]             if (.Platform$OS.type == "windows") {
[09:31:15.992]                 old_names <- names(...future.oldEnvVars)
[09:31:15.992]                 envs <- base::Sys.getenv()
[09:31:15.992]                 names <- names(envs)
[09:31:15.992]                 common <- intersect(names, old_names)
[09:31:15.992]                 added <- setdiff(names, old_names)
[09:31:15.992]                 removed <- setdiff(old_names, names)
[09:31:15.992]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:15.992]                   envs[common]]
[09:31:15.992]                 NAMES <- toupper(changed)
[09:31:15.992]                 args <- list()
[09:31:15.992]                 for (kk in seq_along(NAMES)) {
[09:31:15.992]                   name <- changed[[kk]]
[09:31:15.992]                   NAME <- NAMES[[kk]]
[09:31:15.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.992]                     next
[09:31:15.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.992]                 }
[09:31:15.992]                 NAMES <- toupper(added)
[09:31:15.992]                 for (kk in seq_along(NAMES)) {
[09:31:15.992]                   name <- added[[kk]]
[09:31:15.992]                   NAME <- NAMES[[kk]]
[09:31:15.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.992]                     next
[09:31:15.992]                   args[[name]] <- ""
[09:31:15.992]                 }
[09:31:15.992]                 NAMES <- toupper(removed)
[09:31:15.992]                 for (kk in seq_along(NAMES)) {
[09:31:15.992]                   name <- removed[[kk]]
[09:31:15.992]                   NAME <- NAMES[[kk]]
[09:31:15.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:15.992]                     next
[09:31:15.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:15.992]                 }
[09:31:15.992]                 if (length(args) > 0) 
[09:31:15.992]                   base::do.call(base::Sys.setenv, args = args)
[09:31:15.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:15.992]             }
[09:31:15.992]             else {
[09:31:15.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:15.992]             }
[09:31:15.992]             {
[09:31:15.992]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:15.992]                   0L) {
[09:31:15.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:15.992]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:15.992]                   base::options(opts)
[09:31:15.992]                 }
[09:31:15.992]                 {
[09:31:15.992]                   {
[09:31:15.992]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:15.992]                     NULL
[09:31:15.992]                   }
[09:31:15.992]                   options(future.plan = NULL)
[09:31:15.992]                   if (is.na(NA_character_)) 
[09:31:15.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:15.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:15.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:15.992]                     .init = FALSE)
[09:31:15.992]                 }
[09:31:15.992]             }
[09:31:15.992]         }
[09:31:15.992]     })
[09:31:15.992]     if (TRUE) {
[09:31:15.992]         base::sink(type = "output", split = FALSE)
[09:31:15.992]         if (TRUE) {
[09:31:15.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:15.992]         }
[09:31:15.992]         else {
[09:31:15.992]             ...future.result["stdout"] <- base::list(NULL)
[09:31:15.992]         }
[09:31:15.992]         base::close(...future.stdout)
[09:31:15.992]         ...future.stdout <- NULL
[09:31:15.992]     }
[09:31:15.992]     ...future.result$conditions <- ...future.conditions
[09:31:15.992]     ...future.result$finished <- base::Sys.time()
[09:31:15.992]     ...future.result
[09:31:15.992] }
[09:31:16.043] MultisessionFuture started
[09:31:16.043] - Launch lazy future ... done
[09:31:16.044] run() for ‘MultisessionFuture’ ... done
[09:31:16.044] getGlobalsAndPackages() ...
[09:31:16.044] Searching for globals...
[09:31:16.045] - globals found: [1] ‘{’
[09:31:16.046] Searching for globals ... DONE
[09:31:16.046] Resolving globals: FALSE
[09:31:16.046] 
[09:31:16.046] 
[09:31:16.047] getGlobalsAndPackages() ... DONE
[09:31:16.047] run() for ‘Future’ ...
[09:31:16.047] - state: ‘created’
[09:31:16.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.065]   - Field: ‘node’
[09:31:16.065]   - Field: ‘label’
[09:31:16.066]   - Field: ‘local’
[09:31:16.066]   - Field: ‘owner’
[09:31:16.066]   - Field: ‘envir’
[09:31:16.066]   - Field: ‘workers’
[09:31:16.066]   - Field: ‘packages’
[09:31:16.066]   - Field: ‘gc’
[09:31:16.066]   - Field: ‘conditions’
[09:31:16.067]   - Field: ‘persistent’
[09:31:16.067]   - Field: ‘expr’
[09:31:16.067]   - Field: ‘uuid’
[09:31:16.067]   - Field: ‘seed’
[09:31:16.067]   - Field: ‘version’
[09:31:16.071]   - Field: ‘result’
[09:31:16.071]   - Field: ‘asynchronous’
[09:31:16.071]   - Field: ‘calls’
[09:31:16.072]   - Field: ‘globals’
[09:31:16.072]   - Field: ‘stdout’
[09:31:16.072]   - Field: ‘earlySignal’
[09:31:16.072]   - Field: ‘lazy’
[09:31:16.072]   - Field: ‘state’
[09:31:16.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.073] - Launch lazy future ...
[09:31:16.073] Packages needed by the future expression (n = 0): <none>
[09:31:16.073] Packages needed by future strategies (n = 0): <none>
[09:31:16.074] {
[09:31:16.074]     {
[09:31:16.074]         {
[09:31:16.074]             ...future.startTime <- base::Sys.time()
[09:31:16.074]             {
[09:31:16.074]                 {
[09:31:16.074]                   {
[09:31:16.074]                     {
[09:31:16.074]                       base::local({
[09:31:16.074]                         has_future <- base::requireNamespace("future", 
[09:31:16.074]                           quietly = TRUE)
[09:31:16.074]                         if (has_future) {
[09:31:16.074]                           ns <- base::getNamespace("future")
[09:31:16.074]                           version <- ns[[".package"]][["version"]]
[09:31:16.074]                           if (is.null(version)) 
[09:31:16.074]                             version <- utils::packageVersion("future")
[09:31:16.074]                         }
[09:31:16.074]                         else {
[09:31:16.074]                           version <- NULL
[09:31:16.074]                         }
[09:31:16.074]                         if (!has_future || version < "1.8.0") {
[09:31:16.074]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.074]                             "", base::R.version$version.string), 
[09:31:16.074]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.074]                               "release", "version")], collapse = " "), 
[09:31:16.074]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.074]                             info)
[09:31:16.074]                           info <- base::paste(info, collapse = "; ")
[09:31:16.074]                           if (!has_future) {
[09:31:16.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.074]                               info)
[09:31:16.074]                           }
[09:31:16.074]                           else {
[09:31:16.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.074]                               info, version)
[09:31:16.074]                           }
[09:31:16.074]                           base::stop(msg)
[09:31:16.074]                         }
[09:31:16.074]                       })
[09:31:16.074]                     }
[09:31:16.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.074]                     base::options(mc.cores = 1L)
[09:31:16.074]                   }
[09:31:16.074]                   ...future.strategy.old <- future::plan("list")
[09:31:16.074]                   options(future.plan = NULL)
[09:31:16.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.074]                 }
[09:31:16.074]                 ...future.workdir <- getwd()
[09:31:16.074]             }
[09:31:16.074]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.074]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.074]         }
[09:31:16.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.074]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.074]             base::names(...future.oldOptions))
[09:31:16.074]     }
[09:31:16.074]     if (FALSE) {
[09:31:16.074]     }
[09:31:16.074]     else {
[09:31:16.074]         if (TRUE) {
[09:31:16.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.074]                 open = "w")
[09:31:16.074]         }
[09:31:16.074]         else {
[09:31:16.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.074]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.074]         }
[09:31:16.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.074]             base::sink(type = "output", split = FALSE)
[09:31:16.074]             base::close(...future.stdout)
[09:31:16.074]         }, add = TRUE)
[09:31:16.074]     }
[09:31:16.074]     ...future.frame <- base::sys.nframe()
[09:31:16.074]     ...future.conditions <- base::list()
[09:31:16.074]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.074]     if (FALSE) {
[09:31:16.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.074]     }
[09:31:16.074]     ...future.result <- base::tryCatch({
[09:31:16.074]         base::withCallingHandlers({
[09:31:16.074]             ...future.value <- base::withVisible(base::local({
[09:31:16.074]                 ...future.makeSendCondition <- base::local({
[09:31:16.074]                   sendCondition <- NULL
[09:31:16.074]                   function(frame = 1L) {
[09:31:16.074]                     if (is.function(sendCondition)) 
[09:31:16.074]                       return(sendCondition)
[09:31:16.074]                     ns <- getNamespace("parallel")
[09:31:16.074]                     if (exists("sendData", mode = "function", 
[09:31:16.074]                       envir = ns)) {
[09:31:16.074]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.074]                         envir = ns)
[09:31:16.074]                       envir <- sys.frame(frame)
[09:31:16.074]                       master <- NULL
[09:31:16.074]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.074]                         !identical(envir, emptyenv())) {
[09:31:16.074]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.074]                           inherits = FALSE)) {
[09:31:16.074]                           master <- get("master", mode = "list", 
[09:31:16.074]                             envir = envir, inherits = FALSE)
[09:31:16.074]                           if (inherits(master, c("SOCKnode", 
[09:31:16.074]                             "SOCK0node"))) {
[09:31:16.074]                             sendCondition <<- function(cond) {
[09:31:16.074]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.074]                                 success = TRUE)
[09:31:16.074]                               parallel_sendData(master, data)
[09:31:16.074]                             }
[09:31:16.074]                             return(sendCondition)
[09:31:16.074]                           }
[09:31:16.074]                         }
[09:31:16.074]                         frame <- frame + 1L
[09:31:16.074]                         envir <- sys.frame(frame)
[09:31:16.074]                       }
[09:31:16.074]                     }
[09:31:16.074]                     sendCondition <<- function(cond) NULL
[09:31:16.074]                   }
[09:31:16.074]                 })
[09:31:16.074]                 withCallingHandlers({
[09:31:16.074]                   {
[09:31:16.074]                     4
[09:31:16.074]                   }
[09:31:16.074]                 }, immediateCondition = function(cond) {
[09:31:16.074]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.074]                   sendCondition(cond)
[09:31:16.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.074]                   {
[09:31:16.074]                     inherits <- base::inherits
[09:31:16.074]                     invokeRestart <- base::invokeRestart
[09:31:16.074]                     is.null <- base::is.null
[09:31:16.074]                     muffled <- FALSE
[09:31:16.074]                     if (inherits(cond, "message")) {
[09:31:16.074]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.074]                       if (muffled) 
[09:31:16.074]                         invokeRestart("muffleMessage")
[09:31:16.074]                     }
[09:31:16.074]                     else if (inherits(cond, "warning")) {
[09:31:16.074]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.074]                       if (muffled) 
[09:31:16.074]                         invokeRestart("muffleWarning")
[09:31:16.074]                     }
[09:31:16.074]                     else if (inherits(cond, "condition")) {
[09:31:16.074]                       if (!is.null(pattern)) {
[09:31:16.074]                         computeRestarts <- base::computeRestarts
[09:31:16.074]                         grepl <- base::grepl
[09:31:16.074]                         restarts <- computeRestarts(cond)
[09:31:16.074]                         for (restart in restarts) {
[09:31:16.074]                           name <- restart$name
[09:31:16.074]                           if (is.null(name)) 
[09:31:16.074]                             next
[09:31:16.074]                           if (!grepl(pattern, name)) 
[09:31:16.074]                             next
[09:31:16.074]                           invokeRestart(restart)
[09:31:16.074]                           muffled <- TRUE
[09:31:16.074]                           break
[09:31:16.074]                         }
[09:31:16.074]                       }
[09:31:16.074]                     }
[09:31:16.074]                     invisible(muffled)
[09:31:16.074]                   }
[09:31:16.074]                   muffleCondition(cond)
[09:31:16.074]                 })
[09:31:16.074]             }))
[09:31:16.074]             future::FutureResult(value = ...future.value$value, 
[09:31:16.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.074]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.074]                     ...future.globalenv.names))
[09:31:16.074]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.074]         }, condition = base::local({
[09:31:16.074]             c <- base::c
[09:31:16.074]             inherits <- base::inherits
[09:31:16.074]             invokeRestart <- base::invokeRestart
[09:31:16.074]             length <- base::length
[09:31:16.074]             list <- base::list
[09:31:16.074]             seq.int <- base::seq.int
[09:31:16.074]             signalCondition <- base::signalCondition
[09:31:16.074]             sys.calls <- base::sys.calls
[09:31:16.074]             `[[` <- base::`[[`
[09:31:16.074]             `+` <- base::`+`
[09:31:16.074]             `<<-` <- base::`<<-`
[09:31:16.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.074]                   3L)]
[09:31:16.074]             }
[09:31:16.074]             function(cond) {
[09:31:16.074]                 is_error <- inherits(cond, "error")
[09:31:16.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.074]                   NULL)
[09:31:16.074]                 if (is_error) {
[09:31:16.074]                   sessionInformation <- function() {
[09:31:16.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.074]                       search = base::search(), system = base::Sys.info())
[09:31:16.074]                   }
[09:31:16.074]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.074]                     cond$call), session = sessionInformation(), 
[09:31:16.074]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.074]                   signalCondition(cond)
[09:31:16.074]                 }
[09:31:16.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.074]                 "immediateCondition"))) {
[09:31:16.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.074]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.074]                   if (TRUE && !signal) {
[09:31:16.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.074]                     {
[09:31:16.074]                       inherits <- base::inherits
[09:31:16.074]                       invokeRestart <- base::invokeRestart
[09:31:16.074]                       is.null <- base::is.null
[09:31:16.074]                       muffled <- FALSE
[09:31:16.074]                       if (inherits(cond, "message")) {
[09:31:16.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.074]                         if (muffled) 
[09:31:16.074]                           invokeRestart("muffleMessage")
[09:31:16.074]                       }
[09:31:16.074]                       else if (inherits(cond, "warning")) {
[09:31:16.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.074]                         if (muffled) 
[09:31:16.074]                           invokeRestart("muffleWarning")
[09:31:16.074]                       }
[09:31:16.074]                       else if (inherits(cond, "condition")) {
[09:31:16.074]                         if (!is.null(pattern)) {
[09:31:16.074]                           computeRestarts <- base::computeRestarts
[09:31:16.074]                           grepl <- base::grepl
[09:31:16.074]                           restarts <- computeRestarts(cond)
[09:31:16.074]                           for (restart in restarts) {
[09:31:16.074]                             name <- restart$name
[09:31:16.074]                             if (is.null(name)) 
[09:31:16.074]                               next
[09:31:16.074]                             if (!grepl(pattern, name)) 
[09:31:16.074]                               next
[09:31:16.074]                             invokeRestart(restart)
[09:31:16.074]                             muffled <- TRUE
[09:31:16.074]                             break
[09:31:16.074]                           }
[09:31:16.074]                         }
[09:31:16.074]                       }
[09:31:16.074]                       invisible(muffled)
[09:31:16.074]                     }
[09:31:16.074]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.074]                   }
[09:31:16.074]                 }
[09:31:16.074]                 else {
[09:31:16.074]                   if (TRUE) {
[09:31:16.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.074]                     {
[09:31:16.074]                       inherits <- base::inherits
[09:31:16.074]                       invokeRestart <- base::invokeRestart
[09:31:16.074]                       is.null <- base::is.null
[09:31:16.074]                       muffled <- FALSE
[09:31:16.074]                       if (inherits(cond, "message")) {
[09:31:16.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.074]                         if (muffled) 
[09:31:16.074]                           invokeRestart("muffleMessage")
[09:31:16.074]                       }
[09:31:16.074]                       else if (inherits(cond, "warning")) {
[09:31:16.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.074]                         if (muffled) 
[09:31:16.074]                           invokeRestart("muffleWarning")
[09:31:16.074]                       }
[09:31:16.074]                       else if (inherits(cond, "condition")) {
[09:31:16.074]                         if (!is.null(pattern)) {
[09:31:16.074]                           computeRestarts <- base::computeRestarts
[09:31:16.074]                           grepl <- base::grepl
[09:31:16.074]                           restarts <- computeRestarts(cond)
[09:31:16.074]                           for (restart in restarts) {
[09:31:16.074]                             name <- restart$name
[09:31:16.074]                             if (is.null(name)) 
[09:31:16.074]                               next
[09:31:16.074]                             if (!grepl(pattern, name)) 
[09:31:16.074]                               next
[09:31:16.074]                             invokeRestart(restart)
[09:31:16.074]                             muffled <- TRUE
[09:31:16.074]                             break
[09:31:16.074]                           }
[09:31:16.074]                         }
[09:31:16.074]                       }
[09:31:16.074]                       invisible(muffled)
[09:31:16.074]                     }
[09:31:16.074]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.074]                   }
[09:31:16.074]                 }
[09:31:16.074]             }
[09:31:16.074]         }))
[09:31:16.074]     }, error = function(ex) {
[09:31:16.074]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.074]                 ...future.rng), started = ...future.startTime, 
[09:31:16.074]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.074]             version = "1.8"), class = "FutureResult")
[09:31:16.074]     }, finally = {
[09:31:16.074]         if (!identical(...future.workdir, getwd())) 
[09:31:16.074]             setwd(...future.workdir)
[09:31:16.074]         {
[09:31:16.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.074]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.074]             }
[09:31:16.074]             base::options(...future.oldOptions)
[09:31:16.074]             if (.Platform$OS.type == "windows") {
[09:31:16.074]                 old_names <- names(...future.oldEnvVars)
[09:31:16.074]                 envs <- base::Sys.getenv()
[09:31:16.074]                 names <- names(envs)
[09:31:16.074]                 common <- intersect(names, old_names)
[09:31:16.074]                 added <- setdiff(names, old_names)
[09:31:16.074]                 removed <- setdiff(old_names, names)
[09:31:16.074]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.074]                   envs[common]]
[09:31:16.074]                 NAMES <- toupper(changed)
[09:31:16.074]                 args <- list()
[09:31:16.074]                 for (kk in seq_along(NAMES)) {
[09:31:16.074]                   name <- changed[[kk]]
[09:31:16.074]                   NAME <- NAMES[[kk]]
[09:31:16.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.074]                     next
[09:31:16.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.074]                 }
[09:31:16.074]                 NAMES <- toupper(added)
[09:31:16.074]                 for (kk in seq_along(NAMES)) {
[09:31:16.074]                   name <- added[[kk]]
[09:31:16.074]                   NAME <- NAMES[[kk]]
[09:31:16.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.074]                     next
[09:31:16.074]                   args[[name]] <- ""
[09:31:16.074]                 }
[09:31:16.074]                 NAMES <- toupper(removed)
[09:31:16.074]                 for (kk in seq_along(NAMES)) {
[09:31:16.074]                   name <- removed[[kk]]
[09:31:16.074]                   NAME <- NAMES[[kk]]
[09:31:16.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.074]                     next
[09:31:16.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.074]                 }
[09:31:16.074]                 if (length(args) > 0) 
[09:31:16.074]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.074]             }
[09:31:16.074]             else {
[09:31:16.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.074]             }
[09:31:16.074]             {
[09:31:16.074]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.074]                   0L) {
[09:31:16.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.074]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.074]                   base::options(opts)
[09:31:16.074]                 }
[09:31:16.074]                 {
[09:31:16.074]                   {
[09:31:16.074]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.074]                     NULL
[09:31:16.074]                   }
[09:31:16.074]                   options(future.plan = NULL)
[09:31:16.074]                   if (is.na(NA_character_)) 
[09:31:16.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.074]                     .init = FALSE)
[09:31:16.074]                 }
[09:31:16.074]             }
[09:31:16.074]         }
[09:31:16.074]     })
[09:31:16.074]     if (TRUE) {
[09:31:16.074]         base::sink(type = "output", split = FALSE)
[09:31:16.074]         if (TRUE) {
[09:31:16.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.074]         }
[09:31:16.074]         else {
[09:31:16.074]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.074]         }
[09:31:16.074]         base::close(...future.stdout)
[09:31:16.074]         ...future.stdout <- NULL
[09:31:16.074]     }
[09:31:16.074]     ...future.result$conditions <- ...future.conditions
[09:31:16.074]     ...future.result$finished <- base::Sys.time()
[09:31:16.074]     ...future.result
[09:31:16.074] }
[09:31:16.078] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:16.089] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.089] - Validating connection of MultisessionFuture
[09:31:16.089] - received message: FutureResult
[09:31:16.089] - Received FutureResult
[09:31:16.089] - Erased future from FutureRegistry
[09:31:16.089] result() for ClusterFuture ...
[09:31:16.089] - result already collected: FutureResult
[09:31:16.090] result() for ClusterFuture ... done
[09:31:16.090] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.090] result() for ClusterFuture ...
[09:31:16.090] - result already collected: FutureResult
[09:31:16.090] result() for ClusterFuture ... done
[09:31:16.090] result() for ClusterFuture ...
[09:31:16.090] - result already collected: FutureResult
[09:31:16.090] result() for ClusterFuture ... done
[09:31:16.091] MultisessionFuture started
[09:31:16.091] - Launch lazy future ... done
[09:31:16.092] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cc3fa150> 
Classes 'listenv', 'environment' <environment: 0x55a3cb1953f0> 
[09:31:16.095] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.096] - Validating connection of MultisessionFuture
[09:31:16.096] - received message: FutureResult
[09:31:16.096] - Received FutureResult
[09:31:16.096] - Erased future from FutureRegistry
[09:31:16.096] result() for ClusterFuture ...
[09:31:16.096] - result already collected: FutureResult
[09:31:16.097] result() for ClusterFuture ... done
[09:31:16.097] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.098] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.098] - Validating connection of MultisessionFuture
[09:31:16.098] - received message: FutureResult
[09:31:16.098] - Received FutureResult
[09:31:16.099] - Erased future from FutureRegistry
[09:31:16.099] result() for ClusterFuture ...
[09:31:16.099] - result already collected: FutureResult
[09:31:16.099] result() for ClusterFuture ... done
[09:31:16.099] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:16.100] resolve() on list environment ...
[09:31:16.101]  recursive: 0
[09:31:16.101]  length: 6
[09:31:16.101]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:16.102] signalConditionsASAP(numeric, pos=1) ...
[09:31:16.102] - nx: 6
[09:31:16.102] - relay: TRUE
[09:31:16.102] - stdout: TRUE
[09:31:16.102] - signal: TRUE
[09:31:16.102] - resignal: FALSE
[09:31:16.102] - force: TRUE
[09:31:16.102] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.102] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.102]  - until=2
[09:31:16.102]  - relaying element #2
[09:31:16.103] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.103] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.103] signalConditionsASAP(NULL, pos=1) ... done
[09:31:16.103]  length: 5 (resolved future 1)
[09:31:16.103] Future #2
[09:31:16.103] result() for ClusterFuture ...
[09:31:16.103] - result already collected: FutureResult
[09:31:16.103] result() for ClusterFuture ... done
[09:31:16.103] result() for ClusterFuture ...
[09:31:16.103] - result already collected: FutureResult
[09:31:16.103] result() for ClusterFuture ... done
[09:31:16.104] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:16.104] - nx: 6
[09:31:16.104] - relay: TRUE
[09:31:16.104] - stdout: TRUE
[09:31:16.104] - signal: TRUE
[09:31:16.104] - resignal: FALSE
[09:31:16.104] - force: TRUE
[09:31:16.104] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.104] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.104]  - until=2
[09:31:16.104]  - relaying element #2
[09:31:16.105] result() for ClusterFuture ...
[09:31:16.105] - result already collected: FutureResult
[09:31:16.105] result() for ClusterFuture ... done
[09:31:16.105] result() for ClusterFuture ...
[09:31:16.105] - result already collected: FutureResult
[09:31:16.105] result() for ClusterFuture ... done
[09:31:16.105] result() for ClusterFuture ...
[09:31:16.105] - result already collected: FutureResult
[09:31:16.105] result() for ClusterFuture ... done
[09:31:16.105] result() for ClusterFuture ...
[09:31:16.105] - result already collected: FutureResult
[09:31:16.105] result() for ClusterFuture ... done
[09:31:16.106] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.106] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.106] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:16.106]  length: 4 (resolved future 2)
[09:31:16.106] Future #3
[09:31:16.106] result() for ClusterFuture ...
[09:31:16.106] - result already collected: FutureResult
[09:31:16.106] result() for ClusterFuture ... done
[09:31:16.106] result() for ClusterFuture ...
[09:31:16.106] - result already collected: FutureResult
[09:31:16.106] result() for ClusterFuture ... done
[09:31:16.107] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:16.107] - nx: 6
[09:31:16.107] - relay: TRUE
[09:31:16.107] - stdout: TRUE
[09:31:16.107] - signal: TRUE
[09:31:16.107] - resignal: FALSE
[09:31:16.107] - force: TRUE
[09:31:16.107] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.107] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.107]  - until=3
[09:31:16.107]  - relaying element #3
[09:31:16.107] result() for ClusterFuture ...
[09:31:16.107] - result already collected: FutureResult
[09:31:16.108] result() for ClusterFuture ... done
[09:31:16.108] result() for ClusterFuture ...
[09:31:16.108] - result already collected: FutureResult
[09:31:16.108] result() for ClusterFuture ... done
[09:31:16.108] result() for ClusterFuture ...
[09:31:16.108] - result already collected: FutureResult
[09:31:16.108] result() for ClusterFuture ... done
[09:31:16.108] result() for ClusterFuture ...
[09:31:16.108] - result already collected: FutureResult
[09:31:16.108] result() for ClusterFuture ... done
[09:31:16.108] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.109] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.109] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:16.109]  length: 3 (resolved future 3)
[09:31:16.109] Future #4
[09:31:16.109] result() for ClusterFuture ...
[09:31:16.109] - result already collected: FutureResult
[09:31:16.109] result() for ClusterFuture ... done
[09:31:16.109] result() for ClusterFuture ...
[09:31:16.109] - result already collected: FutureResult
[09:31:16.109] result() for ClusterFuture ... done
[09:31:16.109] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:16.110] - nx: 6
[09:31:16.110] - relay: TRUE
[09:31:16.110] - stdout: TRUE
[09:31:16.110] - signal: TRUE
[09:31:16.110] - resignal: FALSE
[09:31:16.110] - force: TRUE
[09:31:16.110] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.110] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.110]  - until=4
[09:31:16.110]  - relaying element #4
[09:31:16.110] result() for ClusterFuture ...
[09:31:16.110] - result already collected: FutureResult
[09:31:16.111] result() for ClusterFuture ... done
[09:31:16.111] result() for ClusterFuture ...
[09:31:16.111] - result already collected: FutureResult
[09:31:16.111] result() for ClusterFuture ... done
[09:31:16.111] result() for ClusterFuture ...
[09:31:16.111] - result already collected: FutureResult
[09:31:16.111] result() for ClusterFuture ... done
[09:31:16.111] result() for ClusterFuture ...
[09:31:16.111] - result already collected: FutureResult
[09:31:16.111] result() for ClusterFuture ... done
[09:31:16.111] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.112] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.112] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:16.112]  length: 2 (resolved future 4)
[09:31:16.112] signalConditionsASAP(NULL, pos=5) ...
[09:31:16.112] - nx: 6
[09:31:16.112] - relay: TRUE
[09:31:16.112] - stdout: TRUE
[09:31:16.112] - signal: TRUE
[09:31:16.112] - resignal: FALSE
[09:31:16.112] - force: TRUE
[09:31:16.112] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.113] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.113]  - until=6
[09:31:16.113]  - relaying element #6
[09:31:16.113] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.113] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.113] signalConditionsASAP(NULL, pos=5) ... done
[09:31:16.113]  length: 1 (resolved future 5)
[09:31:16.113] signalConditionsASAP(numeric, pos=6) ...
[09:31:16.113] - nx: 6
[09:31:16.113] - relay: TRUE
[09:31:16.113] - stdout: TRUE
[09:31:16.113] - signal: TRUE
[09:31:16.114] - resignal: FALSE
[09:31:16.114] - force: TRUE
[09:31:16.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.114] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.114]  - until=6
[09:31:16.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.114] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.114] signalConditionsASAP(numeric, pos=6) ... done
[09:31:16.114]  length: 0 (resolved future 6)
[09:31:16.114] Relaying remaining futures
[09:31:16.114] signalConditionsASAP(NULL, pos=0) ...
[09:31:16.115] - nx: 6
[09:31:16.115] - relay: TRUE
[09:31:16.115] - stdout: TRUE
[09:31:16.115] - signal: TRUE
[09:31:16.115] - resignal: FALSE
[09:31:16.115] - force: TRUE
[09:31:16.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.115] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:16.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.115] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.115] signalConditionsASAP(NULL, pos=0) ... done
[09:31:16.115] resolve() on list environment ... DONE
[09:31:16.116] result() for ClusterFuture ...
[09:31:16.116] - result already collected: FutureResult
[09:31:16.116] result() for ClusterFuture ... done
[09:31:16.116] result() for ClusterFuture ...
[09:31:16.116] - result already collected: FutureResult
[09:31:16.116] result() for ClusterFuture ... done
[09:31:16.116] result() for ClusterFuture ...
[09:31:16.116] - result already collected: FutureResult
[09:31:16.116] result() for ClusterFuture ... done
[09:31:16.116] result() for ClusterFuture ...
[09:31:16.117] - result already collected: FutureResult
[09:31:16.117] result() for ClusterFuture ... done
[09:31:16.117] result() for ClusterFuture ...
[09:31:16.117] - result already collected: FutureResult
[09:31:16.117] result() for ClusterFuture ... done
[09:31:16.117] result() for ClusterFuture ...
[09:31:16.117] - result already collected: FutureResult
[09:31:16.117] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cad1c3d0> 
Dimensions: c(1, 6)
[09:31:16.118] getGlobalsAndPackages() ...
[09:31:16.118] Searching for globals...
[09:31:16.118] 
[09:31:16.118] Searching for globals ... DONE
[09:31:16.118] - globals: [0] <none>
[09:31:16.118] getGlobalsAndPackages() ... DONE
[09:31:16.119] run() for ‘Future’ ...
[09:31:16.119] - state: ‘created’
[09:31:16.119] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.133] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.133]   - Field: ‘node’
[09:31:16.133]   - Field: ‘label’
[09:31:16.133]   - Field: ‘local’
[09:31:16.133]   - Field: ‘owner’
[09:31:16.133]   - Field: ‘envir’
[09:31:16.133]   - Field: ‘workers’
[09:31:16.133]   - Field: ‘packages’
[09:31:16.133]   - Field: ‘gc’
[09:31:16.134]   - Field: ‘conditions’
[09:31:16.134]   - Field: ‘persistent’
[09:31:16.134]   - Field: ‘expr’
[09:31:16.134]   - Field: ‘uuid’
[09:31:16.134]   - Field: ‘seed’
[09:31:16.134]   - Field: ‘version’
[09:31:16.134]   - Field: ‘result’
[09:31:16.134]   - Field: ‘asynchronous’
[09:31:16.134]   - Field: ‘calls’
[09:31:16.134]   - Field: ‘globals’
[09:31:16.134]   - Field: ‘stdout’
[09:31:16.135]   - Field: ‘earlySignal’
[09:31:16.135]   - Field: ‘lazy’
[09:31:16.135]   - Field: ‘state’
[09:31:16.135] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.135] - Launch lazy future ...
[09:31:16.135] Packages needed by the future expression (n = 0): <none>
[09:31:16.135] Packages needed by future strategies (n = 0): <none>
[09:31:16.136] {
[09:31:16.136]     {
[09:31:16.136]         {
[09:31:16.136]             ...future.startTime <- base::Sys.time()
[09:31:16.136]             {
[09:31:16.136]                 {
[09:31:16.136]                   {
[09:31:16.136]                     {
[09:31:16.136]                       base::local({
[09:31:16.136]                         has_future <- base::requireNamespace("future", 
[09:31:16.136]                           quietly = TRUE)
[09:31:16.136]                         if (has_future) {
[09:31:16.136]                           ns <- base::getNamespace("future")
[09:31:16.136]                           version <- ns[[".package"]][["version"]]
[09:31:16.136]                           if (is.null(version)) 
[09:31:16.136]                             version <- utils::packageVersion("future")
[09:31:16.136]                         }
[09:31:16.136]                         else {
[09:31:16.136]                           version <- NULL
[09:31:16.136]                         }
[09:31:16.136]                         if (!has_future || version < "1.8.0") {
[09:31:16.136]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.136]                             "", base::R.version$version.string), 
[09:31:16.136]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.136]                               "release", "version")], collapse = " "), 
[09:31:16.136]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.136]                             info)
[09:31:16.136]                           info <- base::paste(info, collapse = "; ")
[09:31:16.136]                           if (!has_future) {
[09:31:16.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.136]                               info)
[09:31:16.136]                           }
[09:31:16.136]                           else {
[09:31:16.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.136]                               info, version)
[09:31:16.136]                           }
[09:31:16.136]                           base::stop(msg)
[09:31:16.136]                         }
[09:31:16.136]                       })
[09:31:16.136]                     }
[09:31:16.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.136]                     base::options(mc.cores = 1L)
[09:31:16.136]                   }
[09:31:16.136]                   ...future.strategy.old <- future::plan("list")
[09:31:16.136]                   options(future.plan = NULL)
[09:31:16.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.136]                 }
[09:31:16.136]                 ...future.workdir <- getwd()
[09:31:16.136]             }
[09:31:16.136]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.136]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.136]         }
[09:31:16.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.136]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.136]             base::names(...future.oldOptions))
[09:31:16.136]     }
[09:31:16.136]     if (FALSE) {
[09:31:16.136]     }
[09:31:16.136]     else {
[09:31:16.136]         if (TRUE) {
[09:31:16.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.136]                 open = "w")
[09:31:16.136]         }
[09:31:16.136]         else {
[09:31:16.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.136]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.136]         }
[09:31:16.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.136]             base::sink(type = "output", split = FALSE)
[09:31:16.136]             base::close(...future.stdout)
[09:31:16.136]         }, add = TRUE)
[09:31:16.136]     }
[09:31:16.136]     ...future.frame <- base::sys.nframe()
[09:31:16.136]     ...future.conditions <- base::list()
[09:31:16.136]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.136]     if (FALSE) {
[09:31:16.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.136]     }
[09:31:16.136]     ...future.result <- base::tryCatch({
[09:31:16.136]         base::withCallingHandlers({
[09:31:16.136]             ...future.value <- base::withVisible(base::local({
[09:31:16.136]                 ...future.makeSendCondition <- base::local({
[09:31:16.136]                   sendCondition <- NULL
[09:31:16.136]                   function(frame = 1L) {
[09:31:16.136]                     if (is.function(sendCondition)) 
[09:31:16.136]                       return(sendCondition)
[09:31:16.136]                     ns <- getNamespace("parallel")
[09:31:16.136]                     if (exists("sendData", mode = "function", 
[09:31:16.136]                       envir = ns)) {
[09:31:16.136]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.136]                         envir = ns)
[09:31:16.136]                       envir <- sys.frame(frame)
[09:31:16.136]                       master <- NULL
[09:31:16.136]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.136]                         !identical(envir, emptyenv())) {
[09:31:16.136]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.136]                           inherits = FALSE)) {
[09:31:16.136]                           master <- get("master", mode = "list", 
[09:31:16.136]                             envir = envir, inherits = FALSE)
[09:31:16.136]                           if (inherits(master, c("SOCKnode", 
[09:31:16.136]                             "SOCK0node"))) {
[09:31:16.136]                             sendCondition <<- function(cond) {
[09:31:16.136]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.136]                                 success = TRUE)
[09:31:16.136]                               parallel_sendData(master, data)
[09:31:16.136]                             }
[09:31:16.136]                             return(sendCondition)
[09:31:16.136]                           }
[09:31:16.136]                         }
[09:31:16.136]                         frame <- frame + 1L
[09:31:16.136]                         envir <- sys.frame(frame)
[09:31:16.136]                       }
[09:31:16.136]                     }
[09:31:16.136]                     sendCondition <<- function(cond) NULL
[09:31:16.136]                   }
[09:31:16.136]                 })
[09:31:16.136]                 withCallingHandlers({
[09:31:16.136]                   2
[09:31:16.136]                 }, immediateCondition = function(cond) {
[09:31:16.136]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.136]                   sendCondition(cond)
[09:31:16.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.136]                   {
[09:31:16.136]                     inherits <- base::inherits
[09:31:16.136]                     invokeRestart <- base::invokeRestart
[09:31:16.136]                     is.null <- base::is.null
[09:31:16.136]                     muffled <- FALSE
[09:31:16.136]                     if (inherits(cond, "message")) {
[09:31:16.136]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.136]                       if (muffled) 
[09:31:16.136]                         invokeRestart("muffleMessage")
[09:31:16.136]                     }
[09:31:16.136]                     else if (inherits(cond, "warning")) {
[09:31:16.136]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.136]                       if (muffled) 
[09:31:16.136]                         invokeRestart("muffleWarning")
[09:31:16.136]                     }
[09:31:16.136]                     else if (inherits(cond, "condition")) {
[09:31:16.136]                       if (!is.null(pattern)) {
[09:31:16.136]                         computeRestarts <- base::computeRestarts
[09:31:16.136]                         grepl <- base::grepl
[09:31:16.136]                         restarts <- computeRestarts(cond)
[09:31:16.136]                         for (restart in restarts) {
[09:31:16.136]                           name <- restart$name
[09:31:16.136]                           if (is.null(name)) 
[09:31:16.136]                             next
[09:31:16.136]                           if (!grepl(pattern, name)) 
[09:31:16.136]                             next
[09:31:16.136]                           invokeRestart(restart)
[09:31:16.136]                           muffled <- TRUE
[09:31:16.136]                           break
[09:31:16.136]                         }
[09:31:16.136]                       }
[09:31:16.136]                     }
[09:31:16.136]                     invisible(muffled)
[09:31:16.136]                   }
[09:31:16.136]                   muffleCondition(cond)
[09:31:16.136]                 })
[09:31:16.136]             }))
[09:31:16.136]             future::FutureResult(value = ...future.value$value, 
[09:31:16.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.136]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.136]                     ...future.globalenv.names))
[09:31:16.136]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.136]         }, condition = base::local({
[09:31:16.136]             c <- base::c
[09:31:16.136]             inherits <- base::inherits
[09:31:16.136]             invokeRestart <- base::invokeRestart
[09:31:16.136]             length <- base::length
[09:31:16.136]             list <- base::list
[09:31:16.136]             seq.int <- base::seq.int
[09:31:16.136]             signalCondition <- base::signalCondition
[09:31:16.136]             sys.calls <- base::sys.calls
[09:31:16.136]             `[[` <- base::`[[`
[09:31:16.136]             `+` <- base::`+`
[09:31:16.136]             `<<-` <- base::`<<-`
[09:31:16.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.136]                   3L)]
[09:31:16.136]             }
[09:31:16.136]             function(cond) {
[09:31:16.136]                 is_error <- inherits(cond, "error")
[09:31:16.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.136]                   NULL)
[09:31:16.136]                 if (is_error) {
[09:31:16.136]                   sessionInformation <- function() {
[09:31:16.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.136]                       search = base::search(), system = base::Sys.info())
[09:31:16.136]                   }
[09:31:16.136]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.136]                     cond$call), session = sessionInformation(), 
[09:31:16.136]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.136]                   signalCondition(cond)
[09:31:16.136]                 }
[09:31:16.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.136]                 "immediateCondition"))) {
[09:31:16.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.136]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.136]                   if (TRUE && !signal) {
[09:31:16.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.136]                     {
[09:31:16.136]                       inherits <- base::inherits
[09:31:16.136]                       invokeRestart <- base::invokeRestart
[09:31:16.136]                       is.null <- base::is.null
[09:31:16.136]                       muffled <- FALSE
[09:31:16.136]                       if (inherits(cond, "message")) {
[09:31:16.136]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.136]                         if (muffled) 
[09:31:16.136]                           invokeRestart("muffleMessage")
[09:31:16.136]                       }
[09:31:16.136]                       else if (inherits(cond, "warning")) {
[09:31:16.136]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.136]                         if (muffled) 
[09:31:16.136]                           invokeRestart("muffleWarning")
[09:31:16.136]                       }
[09:31:16.136]                       else if (inherits(cond, "condition")) {
[09:31:16.136]                         if (!is.null(pattern)) {
[09:31:16.136]                           computeRestarts <- base::computeRestarts
[09:31:16.136]                           grepl <- base::grepl
[09:31:16.136]                           restarts <- computeRestarts(cond)
[09:31:16.136]                           for (restart in restarts) {
[09:31:16.136]                             name <- restart$name
[09:31:16.136]                             if (is.null(name)) 
[09:31:16.136]                               next
[09:31:16.136]                             if (!grepl(pattern, name)) 
[09:31:16.136]                               next
[09:31:16.136]                             invokeRestart(restart)
[09:31:16.136]                             muffled <- TRUE
[09:31:16.136]                             break
[09:31:16.136]                           }
[09:31:16.136]                         }
[09:31:16.136]                       }
[09:31:16.136]                       invisible(muffled)
[09:31:16.136]                     }
[09:31:16.136]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.136]                   }
[09:31:16.136]                 }
[09:31:16.136]                 else {
[09:31:16.136]                   if (TRUE) {
[09:31:16.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.136]                     {
[09:31:16.136]                       inherits <- base::inherits
[09:31:16.136]                       invokeRestart <- base::invokeRestart
[09:31:16.136]                       is.null <- base::is.null
[09:31:16.136]                       muffled <- FALSE
[09:31:16.136]                       if (inherits(cond, "message")) {
[09:31:16.136]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.136]                         if (muffled) 
[09:31:16.136]                           invokeRestart("muffleMessage")
[09:31:16.136]                       }
[09:31:16.136]                       else if (inherits(cond, "warning")) {
[09:31:16.136]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.136]                         if (muffled) 
[09:31:16.136]                           invokeRestart("muffleWarning")
[09:31:16.136]                       }
[09:31:16.136]                       else if (inherits(cond, "condition")) {
[09:31:16.136]                         if (!is.null(pattern)) {
[09:31:16.136]                           computeRestarts <- base::computeRestarts
[09:31:16.136]                           grepl <- base::grepl
[09:31:16.136]                           restarts <- computeRestarts(cond)
[09:31:16.136]                           for (restart in restarts) {
[09:31:16.136]                             name <- restart$name
[09:31:16.136]                             if (is.null(name)) 
[09:31:16.136]                               next
[09:31:16.136]                             if (!grepl(pattern, name)) 
[09:31:16.136]                               next
[09:31:16.136]                             invokeRestart(restart)
[09:31:16.136]                             muffled <- TRUE
[09:31:16.136]                             break
[09:31:16.136]                           }
[09:31:16.136]                         }
[09:31:16.136]                       }
[09:31:16.136]                       invisible(muffled)
[09:31:16.136]                     }
[09:31:16.136]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.136]                   }
[09:31:16.136]                 }
[09:31:16.136]             }
[09:31:16.136]         }))
[09:31:16.136]     }, error = function(ex) {
[09:31:16.136]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.136]                 ...future.rng), started = ...future.startTime, 
[09:31:16.136]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.136]             version = "1.8"), class = "FutureResult")
[09:31:16.136]     }, finally = {
[09:31:16.136]         if (!identical(...future.workdir, getwd())) 
[09:31:16.136]             setwd(...future.workdir)
[09:31:16.136]         {
[09:31:16.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.136]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.136]             }
[09:31:16.136]             base::options(...future.oldOptions)
[09:31:16.136]             if (.Platform$OS.type == "windows") {
[09:31:16.136]                 old_names <- names(...future.oldEnvVars)
[09:31:16.136]                 envs <- base::Sys.getenv()
[09:31:16.136]                 names <- names(envs)
[09:31:16.136]                 common <- intersect(names, old_names)
[09:31:16.136]                 added <- setdiff(names, old_names)
[09:31:16.136]                 removed <- setdiff(old_names, names)
[09:31:16.136]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.136]                   envs[common]]
[09:31:16.136]                 NAMES <- toupper(changed)
[09:31:16.136]                 args <- list()
[09:31:16.136]                 for (kk in seq_along(NAMES)) {
[09:31:16.136]                   name <- changed[[kk]]
[09:31:16.136]                   NAME <- NAMES[[kk]]
[09:31:16.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.136]                     next
[09:31:16.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.136]                 }
[09:31:16.136]                 NAMES <- toupper(added)
[09:31:16.136]                 for (kk in seq_along(NAMES)) {
[09:31:16.136]                   name <- added[[kk]]
[09:31:16.136]                   NAME <- NAMES[[kk]]
[09:31:16.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.136]                     next
[09:31:16.136]                   args[[name]] <- ""
[09:31:16.136]                 }
[09:31:16.136]                 NAMES <- toupper(removed)
[09:31:16.136]                 for (kk in seq_along(NAMES)) {
[09:31:16.136]                   name <- removed[[kk]]
[09:31:16.136]                   NAME <- NAMES[[kk]]
[09:31:16.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.136]                     next
[09:31:16.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.136]                 }
[09:31:16.136]                 if (length(args) > 0) 
[09:31:16.136]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.136]             }
[09:31:16.136]             else {
[09:31:16.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.136]             }
[09:31:16.136]             {
[09:31:16.136]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.136]                   0L) {
[09:31:16.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.136]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.136]                   base::options(opts)
[09:31:16.136]                 }
[09:31:16.136]                 {
[09:31:16.136]                   {
[09:31:16.136]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.136]                     NULL
[09:31:16.136]                   }
[09:31:16.136]                   options(future.plan = NULL)
[09:31:16.136]                   if (is.na(NA_character_)) 
[09:31:16.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.136]                     .init = FALSE)
[09:31:16.136]                 }
[09:31:16.136]             }
[09:31:16.136]         }
[09:31:16.136]     })
[09:31:16.136]     if (TRUE) {
[09:31:16.136]         base::sink(type = "output", split = FALSE)
[09:31:16.136]         if (TRUE) {
[09:31:16.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.136]         }
[09:31:16.136]         else {
[09:31:16.136]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.136]         }
[09:31:16.136]         base::close(...future.stdout)
[09:31:16.136]         ...future.stdout <- NULL
[09:31:16.136]     }
[09:31:16.136]     ...future.result$conditions <- ...future.conditions
[09:31:16.136]     ...future.result$finished <- base::Sys.time()
[09:31:16.136]     ...future.result
[09:31:16.136] }
[09:31:16.139] MultisessionFuture started
[09:31:16.139] - Launch lazy future ... done
[09:31:16.139] run() for ‘MultisessionFuture’ ... done
[09:31:16.139] getGlobalsAndPackages() ...
[09:31:16.139] Searching for globals...
[09:31:16.140] 
[09:31:16.140] Searching for globals ... DONE
[09:31:16.140] - globals: [0] <none>
[09:31:16.140] getGlobalsAndPackages() ... DONE
[09:31:16.141] run() for ‘Future’ ...
[09:31:16.141] - state: ‘created’
[09:31:16.141] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.154]   - Field: ‘node’
[09:31:16.155]   - Field: ‘label’
[09:31:16.155]   - Field: ‘local’
[09:31:16.155]   - Field: ‘owner’
[09:31:16.155]   - Field: ‘envir’
[09:31:16.155]   - Field: ‘workers’
[09:31:16.155]   - Field: ‘packages’
[09:31:16.155]   - Field: ‘gc’
[09:31:16.155]   - Field: ‘conditions’
[09:31:16.155]   - Field: ‘persistent’
[09:31:16.155]   - Field: ‘expr’
[09:31:16.155]   - Field: ‘uuid’
[09:31:16.156]   - Field: ‘seed’
[09:31:16.156]   - Field: ‘version’
[09:31:16.156]   - Field: ‘result’
[09:31:16.156]   - Field: ‘asynchronous’
[09:31:16.156]   - Field: ‘calls’
[09:31:16.156]   - Field: ‘globals’
[09:31:16.156]   - Field: ‘stdout’
[09:31:16.156]   - Field: ‘earlySignal’
[09:31:16.156]   - Field: ‘lazy’
[09:31:16.156]   - Field: ‘state’
[09:31:16.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.157] - Launch lazy future ...
[09:31:16.157] Packages needed by the future expression (n = 0): <none>
[09:31:16.157] Packages needed by future strategies (n = 0): <none>
[09:31:16.157] {
[09:31:16.157]     {
[09:31:16.157]         {
[09:31:16.157]             ...future.startTime <- base::Sys.time()
[09:31:16.157]             {
[09:31:16.157]                 {
[09:31:16.157]                   {
[09:31:16.157]                     {
[09:31:16.157]                       base::local({
[09:31:16.157]                         has_future <- base::requireNamespace("future", 
[09:31:16.157]                           quietly = TRUE)
[09:31:16.157]                         if (has_future) {
[09:31:16.157]                           ns <- base::getNamespace("future")
[09:31:16.157]                           version <- ns[[".package"]][["version"]]
[09:31:16.157]                           if (is.null(version)) 
[09:31:16.157]                             version <- utils::packageVersion("future")
[09:31:16.157]                         }
[09:31:16.157]                         else {
[09:31:16.157]                           version <- NULL
[09:31:16.157]                         }
[09:31:16.157]                         if (!has_future || version < "1.8.0") {
[09:31:16.157]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.157]                             "", base::R.version$version.string), 
[09:31:16.157]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.157]                               "release", "version")], collapse = " "), 
[09:31:16.157]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.157]                             info)
[09:31:16.157]                           info <- base::paste(info, collapse = "; ")
[09:31:16.157]                           if (!has_future) {
[09:31:16.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.157]                               info)
[09:31:16.157]                           }
[09:31:16.157]                           else {
[09:31:16.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.157]                               info, version)
[09:31:16.157]                           }
[09:31:16.157]                           base::stop(msg)
[09:31:16.157]                         }
[09:31:16.157]                       })
[09:31:16.157]                     }
[09:31:16.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.157]                     base::options(mc.cores = 1L)
[09:31:16.157]                   }
[09:31:16.157]                   ...future.strategy.old <- future::plan("list")
[09:31:16.157]                   options(future.plan = NULL)
[09:31:16.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.157]                 }
[09:31:16.157]                 ...future.workdir <- getwd()
[09:31:16.157]             }
[09:31:16.157]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.157]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.157]         }
[09:31:16.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.157]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.157]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.157]             base::names(...future.oldOptions))
[09:31:16.157]     }
[09:31:16.157]     if (FALSE) {
[09:31:16.157]     }
[09:31:16.157]     else {
[09:31:16.157]         if (TRUE) {
[09:31:16.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.157]                 open = "w")
[09:31:16.157]         }
[09:31:16.157]         else {
[09:31:16.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.157]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.157]         }
[09:31:16.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.157]             base::sink(type = "output", split = FALSE)
[09:31:16.157]             base::close(...future.stdout)
[09:31:16.157]         }, add = TRUE)
[09:31:16.157]     }
[09:31:16.157]     ...future.frame <- base::sys.nframe()
[09:31:16.157]     ...future.conditions <- base::list()
[09:31:16.157]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.157]     if (FALSE) {
[09:31:16.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.157]     }
[09:31:16.157]     ...future.result <- base::tryCatch({
[09:31:16.157]         base::withCallingHandlers({
[09:31:16.157]             ...future.value <- base::withVisible(base::local({
[09:31:16.157]                 ...future.makeSendCondition <- base::local({
[09:31:16.157]                   sendCondition <- NULL
[09:31:16.157]                   function(frame = 1L) {
[09:31:16.157]                     if (is.function(sendCondition)) 
[09:31:16.157]                       return(sendCondition)
[09:31:16.157]                     ns <- getNamespace("parallel")
[09:31:16.157]                     if (exists("sendData", mode = "function", 
[09:31:16.157]                       envir = ns)) {
[09:31:16.157]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.157]                         envir = ns)
[09:31:16.157]                       envir <- sys.frame(frame)
[09:31:16.157]                       master <- NULL
[09:31:16.157]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.157]                         !identical(envir, emptyenv())) {
[09:31:16.157]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.157]                           inherits = FALSE)) {
[09:31:16.157]                           master <- get("master", mode = "list", 
[09:31:16.157]                             envir = envir, inherits = FALSE)
[09:31:16.157]                           if (inherits(master, c("SOCKnode", 
[09:31:16.157]                             "SOCK0node"))) {
[09:31:16.157]                             sendCondition <<- function(cond) {
[09:31:16.157]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.157]                                 success = TRUE)
[09:31:16.157]                               parallel_sendData(master, data)
[09:31:16.157]                             }
[09:31:16.157]                             return(sendCondition)
[09:31:16.157]                           }
[09:31:16.157]                         }
[09:31:16.157]                         frame <- frame + 1L
[09:31:16.157]                         envir <- sys.frame(frame)
[09:31:16.157]                       }
[09:31:16.157]                     }
[09:31:16.157]                     sendCondition <<- function(cond) NULL
[09:31:16.157]                   }
[09:31:16.157]                 })
[09:31:16.157]                 withCallingHandlers({
[09:31:16.157]                   NULL
[09:31:16.157]                 }, immediateCondition = function(cond) {
[09:31:16.157]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.157]                   sendCondition(cond)
[09:31:16.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.157]                   {
[09:31:16.157]                     inherits <- base::inherits
[09:31:16.157]                     invokeRestart <- base::invokeRestart
[09:31:16.157]                     is.null <- base::is.null
[09:31:16.157]                     muffled <- FALSE
[09:31:16.157]                     if (inherits(cond, "message")) {
[09:31:16.157]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.157]                       if (muffled) 
[09:31:16.157]                         invokeRestart("muffleMessage")
[09:31:16.157]                     }
[09:31:16.157]                     else if (inherits(cond, "warning")) {
[09:31:16.157]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.157]                       if (muffled) 
[09:31:16.157]                         invokeRestart("muffleWarning")
[09:31:16.157]                     }
[09:31:16.157]                     else if (inherits(cond, "condition")) {
[09:31:16.157]                       if (!is.null(pattern)) {
[09:31:16.157]                         computeRestarts <- base::computeRestarts
[09:31:16.157]                         grepl <- base::grepl
[09:31:16.157]                         restarts <- computeRestarts(cond)
[09:31:16.157]                         for (restart in restarts) {
[09:31:16.157]                           name <- restart$name
[09:31:16.157]                           if (is.null(name)) 
[09:31:16.157]                             next
[09:31:16.157]                           if (!grepl(pattern, name)) 
[09:31:16.157]                             next
[09:31:16.157]                           invokeRestart(restart)
[09:31:16.157]                           muffled <- TRUE
[09:31:16.157]                           break
[09:31:16.157]                         }
[09:31:16.157]                       }
[09:31:16.157]                     }
[09:31:16.157]                     invisible(muffled)
[09:31:16.157]                   }
[09:31:16.157]                   muffleCondition(cond)
[09:31:16.157]                 })
[09:31:16.157]             }))
[09:31:16.157]             future::FutureResult(value = ...future.value$value, 
[09:31:16.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.157]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.157]                     ...future.globalenv.names))
[09:31:16.157]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.157]         }, condition = base::local({
[09:31:16.157]             c <- base::c
[09:31:16.157]             inherits <- base::inherits
[09:31:16.157]             invokeRestart <- base::invokeRestart
[09:31:16.157]             length <- base::length
[09:31:16.157]             list <- base::list
[09:31:16.157]             seq.int <- base::seq.int
[09:31:16.157]             signalCondition <- base::signalCondition
[09:31:16.157]             sys.calls <- base::sys.calls
[09:31:16.157]             `[[` <- base::`[[`
[09:31:16.157]             `+` <- base::`+`
[09:31:16.157]             `<<-` <- base::`<<-`
[09:31:16.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.157]                   3L)]
[09:31:16.157]             }
[09:31:16.157]             function(cond) {
[09:31:16.157]                 is_error <- inherits(cond, "error")
[09:31:16.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.157]                   NULL)
[09:31:16.157]                 if (is_error) {
[09:31:16.157]                   sessionInformation <- function() {
[09:31:16.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.157]                       search = base::search(), system = base::Sys.info())
[09:31:16.157]                   }
[09:31:16.157]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.157]                     cond$call), session = sessionInformation(), 
[09:31:16.157]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.157]                   signalCondition(cond)
[09:31:16.157]                 }
[09:31:16.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.157]                 "immediateCondition"))) {
[09:31:16.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.157]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.157]                   if (TRUE && !signal) {
[09:31:16.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.157]                     {
[09:31:16.157]                       inherits <- base::inherits
[09:31:16.157]                       invokeRestart <- base::invokeRestart
[09:31:16.157]                       is.null <- base::is.null
[09:31:16.157]                       muffled <- FALSE
[09:31:16.157]                       if (inherits(cond, "message")) {
[09:31:16.157]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.157]                         if (muffled) 
[09:31:16.157]                           invokeRestart("muffleMessage")
[09:31:16.157]                       }
[09:31:16.157]                       else if (inherits(cond, "warning")) {
[09:31:16.157]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.157]                         if (muffled) 
[09:31:16.157]                           invokeRestart("muffleWarning")
[09:31:16.157]                       }
[09:31:16.157]                       else if (inherits(cond, "condition")) {
[09:31:16.157]                         if (!is.null(pattern)) {
[09:31:16.157]                           computeRestarts <- base::computeRestarts
[09:31:16.157]                           grepl <- base::grepl
[09:31:16.157]                           restarts <- computeRestarts(cond)
[09:31:16.157]                           for (restart in restarts) {
[09:31:16.157]                             name <- restart$name
[09:31:16.157]                             if (is.null(name)) 
[09:31:16.157]                               next
[09:31:16.157]                             if (!grepl(pattern, name)) 
[09:31:16.157]                               next
[09:31:16.157]                             invokeRestart(restart)
[09:31:16.157]                             muffled <- TRUE
[09:31:16.157]                             break
[09:31:16.157]                           }
[09:31:16.157]                         }
[09:31:16.157]                       }
[09:31:16.157]                       invisible(muffled)
[09:31:16.157]                     }
[09:31:16.157]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.157]                   }
[09:31:16.157]                 }
[09:31:16.157]                 else {
[09:31:16.157]                   if (TRUE) {
[09:31:16.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.157]                     {
[09:31:16.157]                       inherits <- base::inherits
[09:31:16.157]                       invokeRestart <- base::invokeRestart
[09:31:16.157]                       is.null <- base::is.null
[09:31:16.157]                       muffled <- FALSE
[09:31:16.157]                       if (inherits(cond, "message")) {
[09:31:16.157]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.157]                         if (muffled) 
[09:31:16.157]                           invokeRestart("muffleMessage")
[09:31:16.157]                       }
[09:31:16.157]                       else if (inherits(cond, "warning")) {
[09:31:16.157]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.157]                         if (muffled) 
[09:31:16.157]                           invokeRestart("muffleWarning")
[09:31:16.157]                       }
[09:31:16.157]                       else if (inherits(cond, "condition")) {
[09:31:16.157]                         if (!is.null(pattern)) {
[09:31:16.157]                           computeRestarts <- base::computeRestarts
[09:31:16.157]                           grepl <- base::grepl
[09:31:16.157]                           restarts <- computeRestarts(cond)
[09:31:16.157]                           for (restart in restarts) {
[09:31:16.157]                             name <- restart$name
[09:31:16.157]                             if (is.null(name)) 
[09:31:16.157]                               next
[09:31:16.157]                             if (!grepl(pattern, name)) 
[09:31:16.157]                               next
[09:31:16.157]                             invokeRestart(restart)
[09:31:16.157]                             muffled <- TRUE
[09:31:16.157]                             break
[09:31:16.157]                           }
[09:31:16.157]                         }
[09:31:16.157]                       }
[09:31:16.157]                       invisible(muffled)
[09:31:16.157]                     }
[09:31:16.157]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.157]                   }
[09:31:16.157]                 }
[09:31:16.157]             }
[09:31:16.157]         }))
[09:31:16.157]     }, error = function(ex) {
[09:31:16.157]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.157]                 ...future.rng), started = ...future.startTime, 
[09:31:16.157]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.157]             version = "1.8"), class = "FutureResult")
[09:31:16.157]     }, finally = {
[09:31:16.157]         if (!identical(...future.workdir, getwd())) 
[09:31:16.157]             setwd(...future.workdir)
[09:31:16.157]         {
[09:31:16.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.157]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.157]             }
[09:31:16.157]             base::options(...future.oldOptions)
[09:31:16.157]             if (.Platform$OS.type == "windows") {
[09:31:16.157]                 old_names <- names(...future.oldEnvVars)
[09:31:16.157]                 envs <- base::Sys.getenv()
[09:31:16.157]                 names <- names(envs)
[09:31:16.157]                 common <- intersect(names, old_names)
[09:31:16.157]                 added <- setdiff(names, old_names)
[09:31:16.157]                 removed <- setdiff(old_names, names)
[09:31:16.157]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.157]                   envs[common]]
[09:31:16.157]                 NAMES <- toupper(changed)
[09:31:16.157]                 args <- list()
[09:31:16.157]                 for (kk in seq_along(NAMES)) {
[09:31:16.157]                   name <- changed[[kk]]
[09:31:16.157]                   NAME <- NAMES[[kk]]
[09:31:16.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.157]                     next
[09:31:16.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.157]                 }
[09:31:16.157]                 NAMES <- toupper(added)
[09:31:16.157]                 for (kk in seq_along(NAMES)) {
[09:31:16.157]                   name <- added[[kk]]
[09:31:16.157]                   NAME <- NAMES[[kk]]
[09:31:16.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.157]                     next
[09:31:16.157]                   args[[name]] <- ""
[09:31:16.157]                 }
[09:31:16.157]                 NAMES <- toupper(removed)
[09:31:16.157]                 for (kk in seq_along(NAMES)) {
[09:31:16.157]                   name <- removed[[kk]]
[09:31:16.157]                   NAME <- NAMES[[kk]]
[09:31:16.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.157]                     next
[09:31:16.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.157]                 }
[09:31:16.157]                 if (length(args) > 0) 
[09:31:16.157]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.157]             }
[09:31:16.157]             else {
[09:31:16.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.157]             }
[09:31:16.157]             {
[09:31:16.157]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.157]                   0L) {
[09:31:16.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.157]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.157]                   base::options(opts)
[09:31:16.157]                 }
[09:31:16.157]                 {
[09:31:16.157]                   {
[09:31:16.157]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.157]                     NULL
[09:31:16.157]                   }
[09:31:16.157]                   options(future.plan = NULL)
[09:31:16.157]                   if (is.na(NA_character_)) 
[09:31:16.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.157]                     .init = FALSE)
[09:31:16.157]                 }
[09:31:16.157]             }
[09:31:16.157]         }
[09:31:16.157]     })
[09:31:16.157]     if (TRUE) {
[09:31:16.157]         base::sink(type = "output", split = FALSE)
[09:31:16.157]         if (TRUE) {
[09:31:16.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.157]         }
[09:31:16.157]         else {
[09:31:16.157]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.157]         }
[09:31:16.157]         base::close(...future.stdout)
[09:31:16.157]         ...future.stdout <- NULL
[09:31:16.157]     }
[09:31:16.157]     ...future.result$conditions <- ...future.conditions
[09:31:16.157]     ...future.result$finished <- base::Sys.time()
[09:31:16.157]     ...future.result
[09:31:16.157] }
[09:31:16.160] MultisessionFuture started
[09:31:16.160] - Launch lazy future ... done
[09:31:16.160] run() for ‘MultisessionFuture’ ... done
[09:31:16.161] getGlobalsAndPackages() ...
[09:31:16.161] Searching for globals...
[09:31:16.162] - globals found: [1] ‘{’
[09:31:16.162] Searching for globals ... DONE
[09:31:16.162] Resolving globals: FALSE
[09:31:16.162] 
[09:31:16.162] 
[09:31:16.162] getGlobalsAndPackages() ... DONE
[09:31:16.162] run() for ‘Future’ ...
[09:31:16.162] - state: ‘created’
[09:31:16.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.176]   - Field: ‘node’
[09:31:16.176]   - Field: ‘label’
[09:31:16.176]   - Field: ‘local’
[09:31:16.176]   - Field: ‘owner’
[09:31:16.177]   - Field: ‘envir’
[09:31:16.177]   - Field: ‘workers’
[09:31:16.177]   - Field: ‘packages’
[09:31:16.177]   - Field: ‘gc’
[09:31:16.177]   - Field: ‘conditions’
[09:31:16.177]   - Field: ‘persistent’
[09:31:16.177]   - Field: ‘expr’
[09:31:16.177]   - Field: ‘uuid’
[09:31:16.177]   - Field: ‘seed’
[09:31:16.177]   - Field: ‘version’
[09:31:16.177]   - Field: ‘result’
[09:31:16.177]   - Field: ‘asynchronous’
[09:31:16.178]   - Field: ‘calls’
[09:31:16.178]   - Field: ‘globals’
[09:31:16.178]   - Field: ‘stdout’
[09:31:16.178]   - Field: ‘earlySignal’
[09:31:16.178]   - Field: ‘lazy’
[09:31:16.178]   - Field: ‘state’
[09:31:16.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.178] - Launch lazy future ...
[09:31:16.178] Packages needed by the future expression (n = 0): <none>
[09:31:16.179] Packages needed by future strategies (n = 0): <none>
[09:31:16.179] {
[09:31:16.179]     {
[09:31:16.179]         {
[09:31:16.179]             ...future.startTime <- base::Sys.time()
[09:31:16.179]             {
[09:31:16.179]                 {
[09:31:16.179]                   {
[09:31:16.179]                     {
[09:31:16.179]                       base::local({
[09:31:16.179]                         has_future <- base::requireNamespace("future", 
[09:31:16.179]                           quietly = TRUE)
[09:31:16.179]                         if (has_future) {
[09:31:16.179]                           ns <- base::getNamespace("future")
[09:31:16.179]                           version <- ns[[".package"]][["version"]]
[09:31:16.179]                           if (is.null(version)) 
[09:31:16.179]                             version <- utils::packageVersion("future")
[09:31:16.179]                         }
[09:31:16.179]                         else {
[09:31:16.179]                           version <- NULL
[09:31:16.179]                         }
[09:31:16.179]                         if (!has_future || version < "1.8.0") {
[09:31:16.179]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.179]                             "", base::R.version$version.string), 
[09:31:16.179]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.179]                               "release", "version")], collapse = " "), 
[09:31:16.179]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.179]                             info)
[09:31:16.179]                           info <- base::paste(info, collapse = "; ")
[09:31:16.179]                           if (!has_future) {
[09:31:16.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.179]                               info)
[09:31:16.179]                           }
[09:31:16.179]                           else {
[09:31:16.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.179]                               info, version)
[09:31:16.179]                           }
[09:31:16.179]                           base::stop(msg)
[09:31:16.179]                         }
[09:31:16.179]                       })
[09:31:16.179]                     }
[09:31:16.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.179]                     base::options(mc.cores = 1L)
[09:31:16.179]                   }
[09:31:16.179]                   ...future.strategy.old <- future::plan("list")
[09:31:16.179]                   options(future.plan = NULL)
[09:31:16.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.179]                 }
[09:31:16.179]                 ...future.workdir <- getwd()
[09:31:16.179]             }
[09:31:16.179]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.179]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.179]         }
[09:31:16.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.179]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.179]             base::names(...future.oldOptions))
[09:31:16.179]     }
[09:31:16.179]     if (FALSE) {
[09:31:16.179]     }
[09:31:16.179]     else {
[09:31:16.179]         if (TRUE) {
[09:31:16.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.179]                 open = "w")
[09:31:16.179]         }
[09:31:16.179]         else {
[09:31:16.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.179]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.179]         }
[09:31:16.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.179]             base::sink(type = "output", split = FALSE)
[09:31:16.179]             base::close(...future.stdout)
[09:31:16.179]         }, add = TRUE)
[09:31:16.179]     }
[09:31:16.179]     ...future.frame <- base::sys.nframe()
[09:31:16.179]     ...future.conditions <- base::list()
[09:31:16.179]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.179]     if (FALSE) {
[09:31:16.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.179]     }
[09:31:16.179]     ...future.result <- base::tryCatch({
[09:31:16.179]         base::withCallingHandlers({
[09:31:16.179]             ...future.value <- base::withVisible(base::local({
[09:31:16.179]                 ...future.makeSendCondition <- base::local({
[09:31:16.179]                   sendCondition <- NULL
[09:31:16.179]                   function(frame = 1L) {
[09:31:16.179]                     if (is.function(sendCondition)) 
[09:31:16.179]                       return(sendCondition)
[09:31:16.179]                     ns <- getNamespace("parallel")
[09:31:16.179]                     if (exists("sendData", mode = "function", 
[09:31:16.179]                       envir = ns)) {
[09:31:16.179]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.179]                         envir = ns)
[09:31:16.179]                       envir <- sys.frame(frame)
[09:31:16.179]                       master <- NULL
[09:31:16.179]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.179]                         !identical(envir, emptyenv())) {
[09:31:16.179]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.179]                           inherits = FALSE)) {
[09:31:16.179]                           master <- get("master", mode = "list", 
[09:31:16.179]                             envir = envir, inherits = FALSE)
[09:31:16.179]                           if (inherits(master, c("SOCKnode", 
[09:31:16.179]                             "SOCK0node"))) {
[09:31:16.179]                             sendCondition <<- function(cond) {
[09:31:16.179]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.179]                                 success = TRUE)
[09:31:16.179]                               parallel_sendData(master, data)
[09:31:16.179]                             }
[09:31:16.179]                             return(sendCondition)
[09:31:16.179]                           }
[09:31:16.179]                         }
[09:31:16.179]                         frame <- frame + 1L
[09:31:16.179]                         envir <- sys.frame(frame)
[09:31:16.179]                       }
[09:31:16.179]                     }
[09:31:16.179]                     sendCondition <<- function(cond) NULL
[09:31:16.179]                   }
[09:31:16.179]                 })
[09:31:16.179]                 withCallingHandlers({
[09:31:16.179]                   {
[09:31:16.179]                     4
[09:31:16.179]                   }
[09:31:16.179]                 }, immediateCondition = function(cond) {
[09:31:16.179]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.179]                   sendCondition(cond)
[09:31:16.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.179]                   {
[09:31:16.179]                     inherits <- base::inherits
[09:31:16.179]                     invokeRestart <- base::invokeRestart
[09:31:16.179]                     is.null <- base::is.null
[09:31:16.179]                     muffled <- FALSE
[09:31:16.179]                     if (inherits(cond, "message")) {
[09:31:16.179]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.179]                       if (muffled) 
[09:31:16.179]                         invokeRestart("muffleMessage")
[09:31:16.179]                     }
[09:31:16.179]                     else if (inherits(cond, "warning")) {
[09:31:16.179]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.179]                       if (muffled) 
[09:31:16.179]                         invokeRestart("muffleWarning")
[09:31:16.179]                     }
[09:31:16.179]                     else if (inherits(cond, "condition")) {
[09:31:16.179]                       if (!is.null(pattern)) {
[09:31:16.179]                         computeRestarts <- base::computeRestarts
[09:31:16.179]                         grepl <- base::grepl
[09:31:16.179]                         restarts <- computeRestarts(cond)
[09:31:16.179]                         for (restart in restarts) {
[09:31:16.179]                           name <- restart$name
[09:31:16.179]                           if (is.null(name)) 
[09:31:16.179]                             next
[09:31:16.179]                           if (!grepl(pattern, name)) 
[09:31:16.179]                             next
[09:31:16.179]                           invokeRestart(restart)
[09:31:16.179]                           muffled <- TRUE
[09:31:16.179]                           break
[09:31:16.179]                         }
[09:31:16.179]                       }
[09:31:16.179]                     }
[09:31:16.179]                     invisible(muffled)
[09:31:16.179]                   }
[09:31:16.179]                   muffleCondition(cond)
[09:31:16.179]                 })
[09:31:16.179]             }))
[09:31:16.179]             future::FutureResult(value = ...future.value$value, 
[09:31:16.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.179]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.179]                     ...future.globalenv.names))
[09:31:16.179]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.179]         }, condition = base::local({
[09:31:16.179]             c <- base::c
[09:31:16.179]             inherits <- base::inherits
[09:31:16.179]             invokeRestart <- base::invokeRestart
[09:31:16.179]             length <- base::length
[09:31:16.179]             list <- base::list
[09:31:16.179]             seq.int <- base::seq.int
[09:31:16.179]             signalCondition <- base::signalCondition
[09:31:16.179]             sys.calls <- base::sys.calls
[09:31:16.179]             `[[` <- base::`[[`
[09:31:16.179]             `+` <- base::`+`
[09:31:16.179]             `<<-` <- base::`<<-`
[09:31:16.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.179]                   3L)]
[09:31:16.179]             }
[09:31:16.179]             function(cond) {
[09:31:16.179]                 is_error <- inherits(cond, "error")
[09:31:16.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.179]                   NULL)
[09:31:16.179]                 if (is_error) {
[09:31:16.179]                   sessionInformation <- function() {
[09:31:16.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.179]                       search = base::search(), system = base::Sys.info())
[09:31:16.179]                   }
[09:31:16.179]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.179]                     cond$call), session = sessionInformation(), 
[09:31:16.179]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.179]                   signalCondition(cond)
[09:31:16.179]                 }
[09:31:16.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.179]                 "immediateCondition"))) {
[09:31:16.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.179]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.179]                   if (TRUE && !signal) {
[09:31:16.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.179]                     {
[09:31:16.179]                       inherits <- base::inherits
[09:31:16.179]                       invokeRestart <- base::invokeRestart
[09:31:16.179]                       is.null <- base::is.null
[09:31:16.179]                       muffled <- FALSE
[09:31:16.179]                       if (inherits(cond, "message")) {
[09:31:16.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.179]                         if (muffled) 
[09:31:16.179]                           invokeRestart("muffleMessage")
[09:31:16.179]                       }
[09:31:16.179]                       else if (inherits(cond, "warning")) {
[09:31:16.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.179]                         if (muffled) 
[09:31:16.179]                           invokeRestart("muffleWarning")
[09:31:16.179]                       }
[09:31:16.179]                       else if (inherits(cond, "condition")) {
[09:31:16.179]                         if (!is.null(pattern)) {
[09:31:16.179]                           computeRestarts <- base::computeRestarts
[09:31:16.179]                           grepl <- base::grepl
[09:31:16.179]                           restarts <- computeRestarts(cond)
[09:31:16.179]                           for (restart in restarts) {
[09:31:16.179]                             name <- restart$name
[09:31:16.179]                             if (is.null(name)) 
[09:31:16.179]                               next
[09:31:16.179]                             if (!grepl(pattern, name)) 
[09:31:16.179]                               next
[09:31:16.179]                             invokeRestart(restart)
[09:31:16.179]                             muffled <- TRUE
[09:31:16.179]                             break
[09:31:16.179]                           }
[09:31:16.179]                         }
[09:31:16.179]                       }
[09:31:16.179]                       invisible(muffled)
[09:31:16.179]                     }
[09:31:16.179]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.179]                   }
[09:31:16.179]                 }
[09:31:16.179]                 else {
[09:31:16.179]                   if (TRUE) {
[09:31:16.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.179]                     {
[09:31:16.179]                       inherits <- base::inherits
[09:31:16.179]                       invokeRestart <- base::invokeRestart
[09:31:16.179]                       is.null <- base::is.null
[09:31:16.179]                       muffled <- FALSE
[09:31:16.179]                       if (inherits(cond, "message")) {
[09:31:16.179]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.179]                         if (muffled) 
[09:31:16.179]                           invokeRestart("muffleMessage")
[09:31:16.179]                       }
[09:31:16.179]                       else if (inherits(cond, "warning")) {
[09:31:16.179]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.179]                         if (muffled) 
[09:31:16.179]                           invokeRestart("muffleWarning")
[09:31:16.179]                       }
[09:31:16.179]                       else if (inherits(cond, "condition")) {
[09:31:16.179]                         if (!is.null(pattern)) {
[09:31:16.179]                           computeRestarts <- base::computeRestarts
[09:31:16.179]                           grepl <- base::grepl
[09:31:16.179]                           restarts <- computeRestarts(cond)
[09:31:16.179]                           for (restart in restarts) {
[09:31:16.179]                             name <- restart$name
[09:31:16.179]                             if (is.null(name)) 
[09:31:16.179]                               next
[09:31:16.179]                             if (!grepl(pattern, name)) 
[09:31:16.179]                               next
[09:31:16.179]                             invokeRestart(restart)
[09:31:16.179]                             muffled <- TRUE
[09:31:16.179]                             break
[09:31:16.179]                           }
[09:31:16.179]                         }
[09:31:16.179]                       }
[09:31:16.179]                       invisible(muffled)
[09:31:16.179]                     }
[09:31:16.179]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.179]                   }
[09:31:16.179]                 }
[09:31:16.179]             }
[09:31:16.179]         }))
[09:31:16.179]     }, error = function(ex) {
[09:31:16.179]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.179]                 ...future.rng), started = ...future.startTime, 
[09:31:16.179]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.179]             version = "1.8"), class = "FutureResult")
[09:31:16.179]     }, finally = {
[09:31:16.179]         if (!identical(...future.workdir, getwd())) 
[09:31:16.179]             setwd(...future.workdir)
[09:31:16.179]         {
[09:31:16.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.179]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.179]             }
[09:31:16.179]             base::options(...future.oldOptions)
[09:31:16.179]             if (.Platform$OS.type == "windows") {
[09:31:16.179]                 old_names <- names(...future.oldEnvVars)
[09:31:16.179]                 envs <- base::Sys.getenv()
[09:31:16.179]                 names <- names(envs)
[09:31:16.179]                 common <- intersect(names, old_names)
[09:31:16.179]                 added <- setdiff(names, old_names)
[09:31:16.179]                 removed <- setdiff(old_names, names)
[09:31:16.179]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.179]                   envs[common]]
[09:31:16.179]                 NAMES <- toupper(changed)
[09:31:16.179]                 args <- list()
[09:31:16.179]                 for (kk in seq_along(NAMES)) {
[09:31:16.179]                   name <- changed[[kk]]
[09:31:16.179]                   NAME <- NAMES[[kk]]
[09:31:16.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.179]                     next
[09:31:16.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.179]                 }
[09:31:16.179]                 NAMES <- toupper(added)
[09:31:16.179]                 for (kk in seq_along(NAMES)) {
[09:31:16.179]                   name <- added[[kk]]
[09:31:16.179]                   NAME <- NAMES[[kk]]
[09:31:16.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.179]                     next
[09:31:16.179]                   args[[name]] <- ""
[09:31:16.179]                 }
[09:31:16.179]                 NAMES <- toupper(removed)
[09:31:16.179]                 for (kk in seq_along(NAMES)) {
[09:31:16.179]                   name <- removed[[kk]]
[09:31:16.179]                   NAME <- NAMES[[kk]]
[09:31:16.179]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.179]                     next
[09:31:16.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.179]                 }
[09:31:16.179]                 if (length(args) > 0) 
[09:31:16.179]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.179]             }
[09:31:16.179]             else {
[09:31:16.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.179]             }
[09:31:16.179]             {
[09:31:16.179]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.179]                   0L) {
[09:31:16.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.179]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.179]                   base::options(opts)
[09:31:16.179]                 }
[09:31:16.179]                 {
[09:31:16.179]                   {
[09:31:16.179]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.179]                     NULL
[09:31:16.179]                   }
[09:31:16.179]                   options(future.plan = NULL)
[09:31:16.179]                   if (is.na(NA_character_)) 
[09:31:16.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.179]                     .init = FALSE)
[09:31:16.179]                 }
[09:31:16.179]             }
[09:31:16.179]         }
[09:31:16.179]     })
[09:31:16.179]     if (TRUE) {
[09:31:16.179]         base::sink(type = "output", split = FALSE)
[09:31:16.179]         if (TRUE) {
[09:31:16.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.179]         }
[09:31:16.179]         else {
[09:31:16.179]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.179]         }
[09:31:16.179]         base::close(...future.stdout)
[09:31:16.179]         ...future.stdout <- NULL
[09:31:16.179]     }
[09:31:16.179]     ...future.result$conditions <- ...future.conditions
[09:31:16.179]     ...future.result$finished <- base::Sys.time()
[09:31:16.179]     ...future.result
[09:31:16.179] }
[09:31:16.181] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:16.192] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.192] - Validating connection of MultisessionFuture
[09:31:16.192] - received message: FutureResult
[09:31:16.192] - Received FutureResult
[09:31:16.192] - Erased future from FutureRegistry
[09:31:16.193] result() for ClusterFuture ...
[09:31:16.193] - result already collected: FutureResult
[09:31:16.193] result() for ClusterFuture ... done
[09:31:16.193] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.193] result() for ClusterFuture ...
[09:31:16.193] - result already collected: FutureResult
[09:31:16.193] result() for ClusterFuture ... done
[09:31:16.193] result() for ClusterFuture ...
[09:31:16.193] - result already collected: FutureResult
[09:31:16.193] result() for ClusterFuture ... done
[09:31:16.194] MultisessionFuture started
[09:31:16.194] - Launch lazy future ... done
[09:31:16.194] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cba9e950> 
Classes 'listenv', 'environment' <environment: 0x55a3ccb40410> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[09:31:16.198] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.198] - Validating connection of MultisessionFuture
[09:31:16.198] - received message: FutureResult
[09:31:16.199] - Received FutureResult
[09:31:16.199] - Erased future from FutureRegistry
[09:31:16.199] result() for ClusterFuture ...
[09:31:16.199] - result already collected: FutureResult
[09:31:16.199] result() for ClusterFuture ... done
[09:31:16.199] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.199] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.200] - Validating connection of MultisessionFuture
[09:31:16.200] - received message: FutureResult
[09:31:16.200] - Received FutureResult
[09:31:16.200] - Erased future from FutureRegistry
[09:31:16.200] result() for ClusterFuture ...
[09:31:16.200] - result already collected: FutureResult
[09:31:16.200] result() for ClusterFuture ... done
[09:31:16.200] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:16.205] resolve() on list environment ...
[09:31:16.205]  recursive: 0
[09:31:16.206]  length: 6
[09:31:16.206]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:16.206] signalConditionsASAP(numeric, pos=1) ...
[09:31:16.206] - nx: 6
[09:31:16.207] - relay: TRUE
[09:31:16.207] - stdout: TRUE
[09:31:16.207] - signal: TRUE
[09:31:16.207] - resignal: FALSE
[09:31:16.207] - force: TRUE
[09:31:16.207] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.207] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.207]  - until=2
[09:31:16.207]  - relaying element #2
[09:31:16.207] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.207] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.207] signalConditionsASAP(NULL, pos=1) ... done
[09:31:16.208]  length: 5 (resolved future 1)
[09:31:16.208] Future #2
[09:31:16.208] result() for ClusterFuture ...
[09:31:16.208] - result already collected: FutureResult
[09:31:16.208] result() for ClusterFuture ... done
[09:31:16.208] result() for ClusterFuture ...
[09:31:16.208] - result already collected: FutureResult
[09:31:16.208] result() for ClusterFuture ... done
[09:31:16.208] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:16.208] - nx: 6
[09:31:16.209] - relay: TRUE
[09:31:16.209] - stdout: TRUE
[09:31:16.209] - signal: TRUE
[09:31:16.209] - resignal: FALSE
[09:31:16.209] - force: TRUE
[09:31:16.209] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.209] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.209]  - until=2
[09:31:16.209]  - relaying element #2
[09:31:16.209] result() for ClusterFuture ...
[09:31:16.209] - result already collected: FutureResult
[09:31:16.209] result() for ClusterFuture ... done
[09:31:16.210] result() for ClusterFuture ...
[09:31:16.210] - result already collected: FutureResult
[09:31:16.210] result() for ClusterFuture ... done
[09:31:16.210] result() for ClusterFuture ...
[09:31:16.210] - result already collected: FutureResult
[09:31:16.210] result() for ClusterFuture ... done
[09:31:16.210] result() for ClusterFuture ...
[09:31:16.210] - result already collected: FutureResult
[09:31:16.210] result() for ClusterFuture ... done
[09:31:16.210] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.210] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.210] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:16.211]  length: 4 (resolved future 2)
[09:31:16.211] Future #3
[09:31:16.211] result() for ClusterFuture ...
[09:31:16.211] - result already collected: FutureResult
[09:31:16.211] result() for ClusterFuture ... done
[09:31:16.211] result() for ClusterFuture ...
[09:31:16.211] - result already collected: FutureResult
[09:31:16.211] result() for ClusterFuture ... done
[09:31:16.211] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:16.211] - nx: 6
[09:31:16.211] - relay: TRUE
[09:31:16.212] - stdout: TRUE
[09:31:16.212] - signal: TRUE
[09:31:16.212] - resignal: FALSE
[09:31:16.212] - force: TRUE
[09:31:16.212] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.212] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.212]  - until=3
[09:31:16.212]  - relaying element #3
[09:31:16.212] result() for ClusterFuture ...
[09:31:16.212] - result already collected: FutureResult
[09:31:16.212] result() for ClusterFuture ... done
[09:31:16.212] result() for ClusterFuture ...
[09:31:16.213] - result already collected: FutureResult
[09:31:16.213] result() for ClusterFuture ... done
[09:31:16.213] result() for ClusterFuture ...
[09:31:16.213] - result already collected: FutureResult
[09:31:16.213] result() for ClusterFuture ... done
[09:31:16.213] result() for ClusterFuture ...
[09:31:16.213] - result already collected: FutureResult
[09:31:16.213] result() for ClusterFuture ... done
[09:31:16.213] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.213] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.213] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:16.213]  length: 3 (resolved future 3)
[09:31:16.214] Future #4
[09:31:16.214] result() for ClusterFuture ...
[09:31:16.214] - result already collected: FutureResult
[09:31:16.214] result() for ClusterFuture ... done
[09:31:16.214] result() for ClusterFuture ...
[09:31:16.214] - result already collected: FutureResult
[09:31:16.214] result() for ClusterFuture ... done
[09:31:16.214] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:16.214] - nx: 6
[09:31:16.214] - relay: TRUE
[09:31:16.214] - stdout: TRUE
[09:31:16.215] - signal: TRUE
[09:31:16.215] - resignal: FALSE
[09:31:16.215] - force: TRUE
[09:31:16.215] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.215] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.215]  - until=4
[09:31:16.215]  - relaying element #4
[09:31:16.215] result() for ClusterFuture ...
[09:31:16.215] - result already collected: FutureResult
[09:31:16.215] result() for ClusterFuture ... done
[09:31:16.215] result() for ClusterFuture ...
[09:31:16.215] - result already collected: FutureResult
[09:31:16.215] result() for ClusterFuture ... done
[09:31:16.216] result() for ClusterFuture ...
[09:31:16.216] - result already collected: FutureResult
[09:31:16.216] result() for ClusterFuture ... done
[09:31:16.216] result() for ClusterFuture ...
[09:31:16.216] - result already collected: FutureResult
[09:31:16.216] result() for ClusterFuture ... done
[09:31:16.216] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.216] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.216] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:16.216]  length: 2 (resolved future 4)
[09:31:16.216] signalConditionsASAP(NULL, pos=5) ...
[09:31:16.217] - nx: 6
[09:31:16.217] - relay: TRUE
[09:31:16.217] - stdout: TRUE
[09:31:16.217] - signal: TRUE
[09:31:16.217] - resignal: FALSE
[09:31:16.217] - force: TRUE
[09:31:16.217] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.217] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.217]  - until=6
[09:31:16.217]  - relaying element #6
[09:31:16.217] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.217] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.218] signalConditionsASAP(NULL, pos=5) ... done
[09:31:16.218]  length: 1 (resolved future 5)
[09:31:16.218] signalConditionsASAP(numeric, pos=6) ...
[09:31:16.218] - nx: 6
[09:31:16.218] - relay: TRUE
[09:31:16.218] - stdout: TRUE
[09:31:16.218] - signal: TRUE
[09:31:16.218] - resignal: FALSE
[09:31:16.218] - force: TRUE
[09:31:16.218] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.218] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.218]  - until=6
[09:31:16.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.219] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.219] signalConditionsASAP(numeric, pos=6) ... done
[09:31:16.219]  length: 0 (resolved future 6)
[09:31:16.219] Relaying remaining futures
[09:31:16.219] signalConditionsASAP(NULL, pos=0) ...
[09:31:16.219] - nx: 6
[09:31:16.219] - relay: TRUE
[09:31:16.219] - stdout: TRUE
[09:31:16.219] - signal: TRUE
[09:31:16.219] - resignal: FALSE
[09:31:16.219] - force: TRUE
[09:31:16.219] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.220] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:16.220] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.220] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.220] signalConditionsASAP(NULL, pos=0) ... done
[09:31:16.220] resolve() on list environment ... DONE
[09:31:16.220] result() for ClusterFuture ...
[09:31:16.220] - result already collected: FutureResult
[09:31:16.220] result() for ClusterFuture ... done
[09:31:16.220] result() for ClusterFuture ...
[09:31:16.220] - result already collected: FutureResult
[09:31:16.221] result() for ClusterFuture ... done
[09:31:16.221] result() for ClusterFuture ...
[09:31:16.221] - result already collected: FutureResult
[09:31:16.221] result() for ClusterFuture ... done
[09:31:16.221] result() for ClusterFuture ...
[09:31:16.221] - result already collected: FutureResult
[09:31:16.221] result() for ClusterFuture ... done
[09:31:16.221] result() for ClusterFuture ...
[09:31:16.221] - result already collected: FutureResult
[09:31:16.221] result() for ClusterFuture ... done
[09:31:16.222] result() for ClusterFuture ...
[09:31:16.222] - result already collected: FutureResult
[09:31:16.222] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3ccfc4e38> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[09:31:16.223] getGlobalsAndPackages() ...
[09:31:16.223] Searching for globals...
[09:31:16.224] 
[09:31:16.224] Searching for globals ... DONE
[09:31:16.224] - globals: [0] <none>
[09:31:16.224] getGlobalsAndPackages() ... DONE
[09:31:16.224] run() for ‘Future’ ...
[09:31:16.224] - state: ‘created’
[09:31:16.224] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.240]   - Field: ‘node’
[09:31:16.240]   - Field: ‘label’
[09:31:16.241]   - Field: ‘local’
[09:31:16.241]   - Field: ‘owner’
[09:31:16.241]   - Field: ‘envir’
[09:31:16.241]   - Field: ‘workers’
[09:31:16.241]   - Field: ‘packages’
[09:31:16.241]   - Field: ‘gc’
[09:31:16.241]   - Field: ‘conditions’
[09:31:16.241]   - Field: ‘persistent’
[09:31:16.241]   - Field: ‘expr’
[09:31:16.241]   - Field: ‘uuid’
[09:31:16.241]   - Field: ‘seed’
[09:31:16.242]   - Field: ‘version’
[09:31:16.242]   - Field: ‘result’
[09:31:16.242]   - Field: ‘asynchronous’
[09:31:16.242]   - Field: ‘calls’
[09:31:16.242]   - Field: ‘globals’
[09:31:16.242]   - Field: ‘stdout’
[09:31:16.242]   - Field: ‘earlySignal’
[09:31:16.242]   - Field: ‘lazy’
[09:31:16.242]   - Field: ‘state’
[09:31:16.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.242] - Launch lazy future ...
[09:31:16.243] Packages needed by the future expression (n = 0): <none>
[09:31:16.243] Packages needed by future strategies (n = 0): <none>
[09:31:16.243] {
[09:31:16.243]     {
[09:31:16.243]         {
[09:31:16.243]             ...future.startTime <- base::Sys.time()
[09:31:16.243]             {
[09:31:16.243]                 {
[09:31:16.243]                   {
[09:31:16.243]                     {
[09:31:16.243]                       base::local({
[09:31:16.243]                         has_future <- base::requireNamespace("future", 
[09:31:16.243]                           quietly = TRUE)
[09:31:16.243]                         if (has_future) {
[09:31:16.243]                           ns <- base::getNamespace("future")
[09:31:16.243]                           version <- ns[[".package"]][["version"]]
[09:31:16.243]                           if (is.null(version)) 
[09:31:16.243]                             version <- utils::packageVersion("future")
[09:31:16.243]                         }
[09:31:16.243]                         else {
[09:31:16.243]                           version <- NULL
[09:31:16.243]                         }
[09:31:16.243]                         if (!has_future || version < "1.8.0") {
[09:31:16.243]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.243]                             "", base::R.version$version.string), 
[09:31:16.243]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.243]                               "release", "version")], collapse = " "), 
[09:31:16.243]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.243]                             info)
[09:31:16.243]                           info <- base::paste(info, collapse = "; ")
[09:31:16.243]                           if (!has_future) {
[09:31:16.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.243]                               info)
[09:31:16.243]                           }
[09:31:16.243]                           else {
[09:31:16.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.243]                               info, version)
[09:31:16.243]                           }
[09:31:16.243]                           base::stop(msg)
[09:31:16.243]                         }
[09:31:16.243]                       })
[09:31:16.243]                     }
[09:31:16.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.243]                     base::options(mc.cores = 1L)
[09:31:16.243]                   }
[09:31:16.243]                   ...future.strategy.old <- future::plan("list")
[09:31:16.243]                   options(future.plan = NULL)
[09:31:16.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.243]                 }
[09:31:16.243]                 ...future.workdir <- getwd()
[09:31:16.243]             }
[09:31:16.243]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.243]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.243]         }
[09:31:16.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.243]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.243]             base::names(...future.oldOptions))
[09:31:16.243]     }
[09:31:16.243]     if (FALSE) {
[09:31:16.243]     }
[09:31:16.243]     else {
[09:31:16.243]         if (TRUE) {
[09:31:16.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.243]                 open = "w")
[09:31:16.243]         }
[09:31:16.243]         else {
[09:31:16.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.243]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.243]         }
[09:31:16.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.243]             base::sink(type = "output", split = FALSE)
[09:31:16.243]             base::close(...future.stdout)
[09:31:16.243]         }, add = TRUE)
[09:31:16.243]     }
[09:31:16.243]     ...future.frame <- base::sys.nframe()
[09:31:16.243]     ...future.conditions <- base::list()
[09:31:16.243]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.243]     if (FALSE) {
[09:31:16.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.243]     }
[09:31:16.243]     ...future.result <- base::tryCatch({
[09:31:16.243]         base::withCallingHandlers({
[09:31:16.243]             ...future.value <- base::withVisible(base::local({
[09:31:16.243]                 ...future.makeSendCondition <- base::local({
[09:31:16.243]                   sendCondition <- NULL
[09:31:16.243]                   function(frame = 1L) {
[09:31:16.243]                     if (is.function(sendCondition)) 
[09:31:16.243]                       return(sendCondition)
[09:31:16.243]                     ns <- getNamespace("parallel")
[09:31:16.243]                     if (exists("sendData", mode = "function", 
[09:31:16.243]                       envir = ns)) {
[09:31:16.243]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.243]                         envir = ns)
[09:31:16.243]                       envir <- sys.frame(frame)
[09:31:16.243]                       master <- NULL
[09:31:16.243]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.243]                         !identical(envir, emptyenv())) {
[09:31:16.243]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.243]                           inherits = FALSE)) {
[09:31:16.243]                           master <- get("master", mode = "list", 
[09:31:16.243]                             envir = envir, inherits = FALSE)
[09:31:16.243]                           if (inherits(master, c("SOCKnode", 
[09:31:16.243]                             "SOCK0node"))) {
[09:31:16.243]                             sendCondition <<- function(cond) {
[09:31:16.243]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.243]                                 success = TRUE)
[09:31:16.243]                               parallel_sendData(master, data)
[09:31:16.243]                             }
[09:31:16.243]                             return(sendCondition)
[09:31:16.243]                           }
[09:31:16.243]                         }
[09:31:16.243]                         frame <- frame + 1L
[09:31:16.243]                         envir <- sys.frame(frame)
[09:31:16.243]                       }
[09:31:16.243]                     }
[09:31:16.243]                     sendCondition <<- function(cond) NULL
[09:31:16.243]                   }
[09:31:16.243]                 })
[09:31:16.243]                 withCallingHandlers({
[09:31:16.243]                   2
[09:31:16.243]                 }, immediateCondition = function(cond) {
[09:31:16.243]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.243]                   sendCondition(cond)
[09:31:16.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.243]                   {
[09:31:16.243]                     inherits <- base::inherits
[09:31:16.243]                     invokeRestart <- base::invokeRestart
[09:31:16.243]                     is.null <- base::is.null
[09:31:16.243]                     muffled <- FALSE
[09:31:16.243]                     if (inherits(cond, "message")) {
[09:31:16.243]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.243]                       if (muffled) 
[09:31:16.243]                         invokeRestart("muffleMessage")
[09:31:16.243]                     }
[09:31:16.243]                     else if (inherits(cond, "warning")) {
[09:31:16.243]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.243]                       if (muffled) 
[09:31:16.243]                         invokeRestart("muffleWarning")
[09:31:16.243]                     }
[09:31:16.243]                     else if (inherits(cond, "condition")) {
[09:31:16.243]                       if (!is.null(pattern)) {
[09:31:16.243]                         computeRestarts <- base::computeRestarts
[09:31:16.243]                         grepl <- base::grepl
[09:31:16.243]                         restarts <- computeRestarts(cond)
[09:31:16.243]                         for (restart in restarts) {
[09:31:16.243]                           name <- restart$name
[09:31:16.243]                           if (is.null(name)) 
[09:31:16.243]                             next
[09:31:16.243]                           if (!grepl(pattern, name)) 
[09:31:16.243]                             next
[09:31:16.243]                           invokeRestart(restart)
[09:31:16.243]                           muffled <- TRUE
[09:31:16.243]                           break
[09:31:16.243]                         }
[09:31:16.243]                       }
[09:31:16.243]                     }
[09:31:16.243]                     invisible(muffled)
[09:31:16.243]                   }
[09:31:16.243]                   muffleCondition(cond)
[09:31:16.243]                 })
[09:31:16.243]             }))
[09:31:16.243]             future::FutureResult(value = ...future.value$value, 
[09:31:16.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.243]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.243]                     ...future.globalenv.names))
[09:31:16.243]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.243]         }, condition = base::local({
[09:31:16.243]             c <- base::c
[09:31:16.243]             inherits <- base::inherits
[09:31:16.243]             invokeRestart <- base::invokeRestart
[09:31:16.243]             length <- base::length
[09:31:16.243]             list <- base::list
[09:31:16.243]             seq.int <- base::seq.int
[09:31:16.243]             signalCondition <- base::signalCondition
[09:31:16.243]             sys.calls <- base::sys.calls
[09:31:16.243]             `[[` <- base::`[[`
[09:31:16.243]             `+` <- base::`+`
[09:31:16.243]             `<<-` <- base::`<<-`
[09:31:16.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.243]                   3L)]
[09:31:16.243]             }
[09:31:16.243]             function(cond) {
[09:31:16.243]                 is_error <- inherits(cond, "error")
[09:31:16.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.243]                   NULL)
[09:31:16.243]                 if (is_error) {
[09:31:16.243]                   sessionInformation <- function() {
[09:31:16.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.243]                       search = base::search(), system = base::Sys.info())
[09:31:16.243]                   }
[09:31:16.243]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.243]                     cond$call), session = sessionInformation(), 
[09:31:16.243]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.243]                   signalCondition(cond)
[09:31:16.243]                 }
[09:31:16.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.243]                 "immediateCondition"))) {
[09:31:16.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.243]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.243]                   if (TRUE && !signal) {
[09:31:16.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.243]                     {
[09:31:16.243]                       inherits <- base::inherits
[09:31:16.243]                       invokeRestart <- base::invokeRestart
[09:31:16.243]                       is.null <- base::is.null
[09:31:16.243]                       muffled <- FALSE
[09:31:16.243]                       if (inherits(cond, "message")) {
[09:31:16.243]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.243]                         if (muffled) 
[09:31:16.243]                           invokeRestart("muffleMessage")
[09:31:16.243]                       }
[09:31:16.243]                       else if (inherits(cond, "warning")) {
[09:31:16.243]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.243]                         if (muffled) 
[09:31:16.243]                           invokeRestart("muffleWarning")
[09:31:16.243]                       }
[09:31:16.243]                       else if (inherits(cond, "condition")) {
[09:31:16.243]                         if (!is.null(pattern)) {
[09:31:16.243]                           computeRestarts <- base::computeRestarts
[09:31:16.243]                           grepl <- base::grepl
[09:31:16.243]                           restarts <- computeRestarts(cond)
[09:31:16.243]                           for (restart in restarts) {
[09:31:16.243]                             name <- restart$name
[09:31:16.243]                             if (is.null(name)) 
[09:31:16.243]                               next
[09:31:16.243]                             if (!grepl(pattern, name)) 
[09:31:16.243]                               next
[09:31:16.243]                             invokeRestart(restart)
[09:31:16.243]                             muffled <- TRUE
[09:31:16.243]                             break
[09:31:16.243]                           }
[09:31:16.243]                         }
[09:31:16.243]                       }
[09:31:16.243]                       invisible(muffled)
[09:31:16.243]                     }
[09:31:16.243]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.243]                   }
[09:31:16.243]                 }
[09:31:16.243]                 else {
[09:31:16.243]                   if (TRUE) {
[09:31:16.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.243]                     {
[09:31:16.243]                       inherits <- base::inherits
[09:31:16.243]                       invokeRestart <- base::invokeRestart
[09:31:16.243]                       is.null <- base::is.null
[09:31:16.243]                       muffled <- FALSE
[09:31:16.243]                       if (inherits(cond, "message")) {
[09:31:16.243]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.243]                         if (muffled) 
[09:31:16.243]                           invokeRestart("muffleMessage")
[09:31:16.243]                       }
[09:31:16.243]                       else if (inherits(cond, "warning")) {
[09:31:16.243]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.243]                         if (muffled) 
[09:31:16.243]                           invokeRestart("muffleWarning")
[09:31:16.243]                       }
[09:31:16.243]                       else if (inherits(cond, "condition")) {
[09:31:16.243]                         if (!is.null(pattern)) {
[09:31:16.243]                           computeRestarts <- base::computeRestarts
[09:31:16.243]                           grepl <- base::grepl
[09:31:16.243]                           restarts <- computeRestarts(cond)
[09:31:16.243]                           for (restart in restarts) {
[09:31:16.243]                             name <- restart$name
[09:31:16.243]                             if (is.null(name)) 
[09:31:16.243]                               next
[09:31:16.243]                             if (!grepl(pattern, name)) 
[09:31:16.243]                               next
[09:31:16.243]                             invokeRestart(restart)
[09:31:16.243]                             muffled <- TRUE
[09:31:16.243]                             break
[09:31:16.243]                           }
[09:31:16.243]                         }
[09:31:16.243]                       }
[09:31:16.243]                       invisible(muffled)
[09:31:16.243]                     }
[09:31:16.243]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.243]                   }
[09:31:16.243]                 }
[09:31:16.243]             }
[09:31:16.243]         }))
[09:31:16.243]     }, error = function(ex) {
[09:31:16.243]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.243]                 ...future.rng), started = ...future.startTime, 
[09:31:16.243]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.243]             version = "1.8"), class = "FutureResult")
[09:31:16.243]     }, finally = {
[09:31:16.243]         if (!identical(...future.workdir, getwd())) 
[09:31:16.243]             setwd(...future.workdir)
[09:31:16.243]         {
[09:31:16.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.243]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.243]             }
[09:31:16.243]             base::options(...future.oldOptions)
[09:31:16.243]             if (.Platform$OS.type == "windows") {
[09:31:16.243]                 old_names <- names(...future.oldEnvVars)
[09:31:16.243]                 envs <- base::Sys.getenv()
[09:31:16.243]                 names <- names(envs)
[09:31:16.243]                 common <- intersect(names, old_names)
[09:31:16.243]                 added <- setdiff(names, old_names)
[09:31:16.243]                 removed <- setdiff(old_names, names)
[09:31:16.243]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.243]                   envs[common]]
[09:31:16.243]                 NAMES <- toupper(changed)
[09:31:16.243]                 args <- list()
[09:31:16.243]                 for (kk in seq_along(NAMES)) {
[09:31:16.243]                   name <- changed[[kk]]
[09:31:16.243]                   NAME <- NAMES[[kk]]
[09:31:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.243]                     next
[09:31:16.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.243]                 }
[09:31:16.243]                 NAMES <- toupper(added)
[09:31:16.243]                 for (kk in seq_along(NAMES)) {
[09:31:16.243]                   name <- added[[kk]]
[09:31:16.243]                   NAME <- NAMES[[kk]]
[09:31:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.243]                     next
[09:31:16.243]                   args[[name]] <- ""
[09:31:16.243]                 }
[09:31:16.243]                 NAMES <- toupper(removed)
[09:31:16.243]                 for (kk in seq_along(NAMES)) {
[09:31:16.243]                   name <- removed[[kk]]
[09:31:16.243]                   NAME <- NAMES[[kk]]
[09:31:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.243]                     next
[09:31:16.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.243]                 }
[09:31:16.243]                 if (length(args) > 0) 
[09:31:16.243]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.243]             }
[09:31:16.243]             else {
[09:31:16.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.243]             }
[09:31:16.243]             {
[09:31:16.243]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.243]                   0L) {
[09:31:16.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.243]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.243]                   base::options(opts)
[09:31:16.243]                 }
[09:31:16.243]                 {
[09:31:16.243]                   {
[09:31:16.243]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.243]                     NULL
[09:31:16.243]                   }
[09:31:16.243]                   options(future.plan = NULL)
[09:31:16.243]                   if (is.na(NA_character_)) 
[09:31:16.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.243]                     .init = FALSE)
[09:31:16.243]                 }
[09:31:16.243]             }
[09:31:16.243]         }
[09:31:16.243]     })
[09:31:16.243]     if (TRUE) {
[09:31:16.243]         base::sink(type = "output", split = FALSE)
[09:31:16.243]         if (TRUE) {
[09:31:16.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.243]         }
[09:31:16.243]         else {
[09:31:16.243]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.243]         }
[09:31:16.243]         base::close(...future.stdout)
[09:31:16.243]         ...future.stdout <- NULL
[09:31:16.243]     }
[09:31:16.243]     ...future.result$conditions <- ...future.conditions
[09:31:16.243]     ...future.result$finished <- base::Sys.time()
[09:31:16.243]     ...future.result
[09:31:16.243] }
[09:31:16.246] MultisessionFuture started
[09:31:16.246] - Launch lazy future ... done
[09:31:16.246] run() for ‘MultisessionFuture’ ... done
[09:31:16.247] getGlobalsAndPackages() ...
[09:31:16.247] Searching for globals...
[09:31:16.247] 
[09:31:16.247] Searching for globals ... DONE
[09:31:16.248] - globals: [0] <none>
[09:31:16.248] getGlobalsAndPackages() ... DONE
[09:31:16.248] run() for ‘Future’ ...
[09:31:16.248] - state: ‘created’
[09:31:16.248] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.262] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.262]   - Field: ‘node’
[09:31:16.262]   - Field: ‘label’
[09:31:16.262]   - Field: ‘local’
[09:31:16.262]   - Field: ‘owner’
[09:31:16.262]   - Field: ‘envir’
[09:31:16.262]   - Field: ‘workers’
[09:31:16.262]   - Field: ‘packages’
[09:31:16.263]   - Field: ‘gc’
[09:31:16.263]   - Field: ‘conditions’
[09:31:16.263]   - Field: ‘persistent’
[09:31:16.263]   - Field: ‘expr’
[09:31:16.263]   - Field: ‘uuid’
[09:31:16.263]   - Field: ‘seed’
[09:31:16.263]   - Field: ‘version’
[09:31:16.263]   - Field: ‘result’
[09:31:16.263]   - Field: ‘asynchronous’
[09:31:16.263]   - Field: ‘calls’
[09:31:16.263]   - Field: ‘globals’
[09:31:16.264]   - Field: ‘stdout’
[09:31:16.264]   - Field: ‘earlySignal’
[09:31:16.264]   - Field: ‘lazy’
[09:31:16.264]   - Field: ‘state’
[09:31:16.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.264] - Launch lazy future ...
[09:31:16.264] Packages needed by the future expression (n = 0): <none>
[09:31:16.264] Packages needed by future strategies (n = 0): <none>
[09:31:16.265] {
[09:31:16.265]     {
[09:31:16.265]         {
[09:31:16.265]             ...future.startTime <- base::Sys.time()
[09:31:16.265]             {
[09:31:16.265]                 {
[09:31:16.265]                   {
[09:31:16.265]                     {
[09:31:16.265]                       base::local({
[09:31:16.265]                         has_future <- base::requireNamespace("future", 
[09:31:16.265]                           quietly = TRUE)
[09:31:16.265]                         if (has_future) {
[09:31:16.265]                           ns <- base::getNamespace("future")
[09:31:16.265]                           version <- ns[[".package"]][["version"]]
[09:31:16.265]                           if (is.null(version)) 
[09:31:16.265]                             version <- utils::packageVersion("future")
[09:31:16.265]                         }
[09:31:16.265]                         else {
[09:31:16.265]                           version <- NULL
[09:31:16.265]                         }
[09:31:16.265]                         if (!has_future || version < "1.8.0") {
[09:31:16.265]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.265]                             "", base::R.version$version.string), 
[09:31:16.265]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.265]                               "release", "version")], collapse = " "), 
[09:31:16.265]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.265]                             info)
[09:31:16.265]                           info <- base::paste(info, collapse = "; ")
[09:31:16.265]                           if (!has_future) {
[09:31:16.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.265]                               info)
[09:31:16.265]                           }
[09:31:16.265]                           else {
[09:31:16.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.265]                               info, version)
[09:31:16.265]                           }
[09:31:16.265]                           base::stop(msg)
[09:31:16.265]                         }
[09:31:16.265]                       })
[09:31:16.265]                     }
[09:31:16.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.265]                     base::options(mc.cores = 1L)
[09:31:16.265]                   }
[09:31:16.265]                   ...future.strategy.old <- future::plan("list")
[09:31:16.265]                   options(future.plan = NULL)
[09:31:16.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.265]                 }
[09:31:16.265]                 ...future.workdir <- getwd()
[09:31:16.265]             }
[09:31:16.265]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.265]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.265]         }
[09:31:16.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.265]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.265]             base::names(...future.oldOptions))
[09:31:16.265]     }
[09:31:16.265]     if (FALSE) {
[09:31:16.265]     }
[09:31:16.265]     else {
[09:31:16.265]         if (TRUE) {
[09:31:16.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.265]                 open = "w")
[09:31:16.265]         }
[09:31:16.265]         else {
[09:31:16.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.265]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.265]         }
[09:31:16.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.265]             base::sink(type = "output", split = FALSE)
[09:31:16.265]             base::close(...future.stdout)
[09:31:16.265]         }, add = TRUE)
[09:31:16.265]     }
[09:31:16.265]     ...future.frame <- base::sys.nframe()
[09:31:16.265]     ...future.conditions <- base::list()
[09:31:16.265]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.265]     if (FALSE) {
[09:31:16.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.265]     }
[09:31:16.265]     ...future.result <- base::tryCatch({
[09:31:16.265]         base::withCallingHandlers({
[09:31:16.265]             ...future.value <- base::withVisible(base::local({
[09:31:16.265]                 ...future.makeSendCondition <- base::local({
[09:31:16.265]                   sendCondition <- NULL
[09:31:16.265]                   function(frame = 1L) {
[09:31:16.265]                     if (is.function(sendCondition)) 
[09:31:16.265]                       return(sendCondition)
[09:31:16.265]                     ns <- getNamespace("parallel")
[09:31:16.265]                     if (exists("sendData", mode = "function", 
[09:31:16.265]                       envir = ns)) {
[09:31:16.265]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.265]                         envir = ns)
[09:31:16.265]                       envir <- sys.frame(frame)
[09:31:16.265]                       master <- NULL
[09:31:16.265]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.265]                         !identical(envir, emptyenv())) {
[09:31:16.265]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.265]                           inherits = FALSE)) {
[09:31:16.265]                           master <- get("master", mode = "list", 
[09:31:16.265]                             envir = envir, inherits = FALSE)
[09:31:16.265]                           if (inherits(master, c("SOCKnode", 
[09:31:16.265]                             "SOCK0node"))) {
[09:31:16.265]                             sendCondition <<- function(cond) {
[09:31:16.265]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.265]                                 success = TRUE)
[09:31:16.265]                               parallel_sendData(master, data)
[09:31:16.265]                             }
[09:31:16.265]                             return(sendCondition)
[09:31:16.265]                           }
[09:31:16.265]                         }
[09:31:16.265]                         frame <- frame + 1L
[09:31:16.265]                         envir <- sys.frame(frame)
[09:31:16.265]                       }
[09:31:16.265]                     }
[09:31:16.265]                     sendCondition <<- function(cond) NULL
[09:31:16.265]                   }
[09:31:16.265]                 })
[09:31:16.265]                 withCallingHandlers({
[09:31:16.265]                   NULL
[09:31:16.265]                 }, immediateCondition = function(cond) {
[09:31:16.265]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.265]                   sendCondition(cond)
[09:31:16.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.265]                   {
[09:31:16.265]                     inherits <- base::inherits
[09:31:16.265]                     invokeRestart <- base::invokeRestart
[09:31:16.265]                     is.null <- base::is.null
[09:31:16.265]                     muffled <- FALSE
[09:31:16.265]                     if (inherits(cond, "message")) {
[09:31:16.265]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.265]                       if (muffled) 
[09:31:16.265]                         invokeRestart("muffleMessage")
[09:31:16.265]                     }
[09:31:16.265]                     else if (inherits(cond, "warning")) {
[09:31:16.265]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.265]                       if (muffled) 
[09:31:16.265]                         invokeRestart("muffleWarning")
[09:31:16.265]                     }
[09:31:16.265]                     else if (inherits(cond, "condition")) {
[09:31:16.265]                       if (!is.null(pattern)) {
[09:31:16.265]                         computeRestarts <- base::computeRestarts
[09:31:16.265]                         grepl <- base::grepl
[09:31:16.265]                         restarts <- computeRestarts(cond)
[09:31:16.265]                         for (restart in restarts) {
[09:31:16.265]                           name <- restart$name
[09:31:16.265]                           if (is.null(name)) 
[09:31:16.265]                             next
[09:31:16.265]                           if (!grepl(pattern, name)) 
[09:31:16.265]                             next
[09:31:16.265]                           invokeRestart(restart)
[09:31:16.265]                           muffled <- TRUE
[09:31:16.265]                           break
[09:31:16.265]                         }
[09:31:16.265]                       }
[09:31:16.265]                     }
[09:31:16.265]                     invisible(muffled)
[09:31:16.265]                   }
[09:31:16.265]                   muffleCondition(cond)
[09:31:16.265]                 })
[09:31:16.265]             }))
[09:31:16.265]             future::FutureResult(value = ...future.value$value, 
[09:31:16.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.265]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.265]                     ...future.globalenv.names))
[09:31:16.265]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.265]         }, condition = base::local({
[09:31:16.265]             c <- base::c
[09:31:16.265]             inherits <- base::inherits
[09:31:16.265]             invokeRestart <- base::invokeRestart
[09:31:16.265]             length <- base::length
[09:31:16.265]             list <- base::list
[09:31:16.265]             seq.int <- base::seq.int
[09:31:16.265]             signalCondition <- base::signalCondition
[09:31:16.265]             sys.calls <- base::sys.calls
[09:31:16.265]             `[[` <- base::`[[`
[09:31:16.265]             `+` <- base::`+`
[09:31:16.265]             `<<-` <- base::`<<-`
[09:31:16.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.265]                   3L)]
[09:31:16.265]             }
[09:31:16.265]             function(cond) {
[09:31:16.265]                 is_error <- inherits(cond, "error")
[09:31:16.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.265]                   NULL)
[09:31:16.265]                 if (is_error) {
[09:31:16.265]                   sessionInformation <- function() {
[09:31:16.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.265]                       search = base::search(), system = base::Sys.info())
[09:31:16.265]                   }
[09:31:16.265]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.265]                     cond$call), session = sessionInformation(), 
[09:31:16.265]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.265]                   signalCondition(cond)
[09:31:16.265]                 }
[09:31:16.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.265]                 "immediateCondition"))) {
[09:31:16.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.265]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.265]                   if (TRUE && !signal) {
[09:31:16.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.265]                     {
[09:31:16.265]                       inherits <- base::inherits
[09:31:16.265]                       invokeRestart <- base::invokeRestart
[09:31:16.265]                       is.null <- base::is.null
[09:31:16.265]                       muffled <- FALSE
[09:31:16.265]                       if (inherits(cond, "message")) {
[09:31:16.265]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.265]                         if (muffled) 
[09:31:16.265]                           invokeRestart("muffleMessage")
[09:31:16.265]                       }
[09:31:16.265]                       else if (inherits(cond, "warning")) {
[09:31:16.265]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.265]                         if (muffled) 
[09:31:16.265]                           invokeRestart("muffleWarning")
[09:31:16.265]                       }
[09:31:16.265]                       else if (inherits(cond, "condition")) {
[09:31:16.265]                         if (!is.null(pattern)) {
[09:31:16.265]                           computeRestarts <- base::computeRestarts
[09:31:16.265]                           grepl <- base::grepl
[09:31:16.265]                           restarts <- computeRestarts(cond)
[09:31:16.265]                           for (restart in restarts) {
[09:31:16.265]                             name <- restart$name
[09:31:16.265]                             if (is.null(name)) 
[09:31:16.265]                               next
[09:31:16.265]                             if (!grepl(pattern, name)) 
[09:31:16.265]                               next
[09:31:16.265]                             invokeRestart(restart)
[09:31:16.265]                             muffled <- TRUE
[09:31:16.265]                             break
[09:31:16.265]                           }
[09:31:16.265]                         }
[09:31:16.265]                       }
[09:31:16.265]                       invisible(muffled)
[09:31:16.265]                     }
[09:31:16.265]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.265]                   }
[09:31:16.265]                 }
[09:31:16.265]                 else {
[09:31:16.265]                   if (TRUE) {
[09:31:16.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.265]                     {
[09:31:16.265]                       inherits <- base::inherits
[09:31:16.265]                       invokeRestart <- base::invokeRestart
[09:31:16.265]                       is.null <- base::is.null
[09:31:16.265]                       muffled <- FALSE
[09:31:16.265]                       if (inherits(cond, "message")) {
[09:31:16.265]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.265]                         if (muffled) 
[09:31:16.265]                           invokeRestart("muffleMessage")
[09:31:16.265]                       }
[09:31:16.265]                       else if (inherits(cond, "warning")) {
[09:31:16.265]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.265]                         if (muffled) 
[09:31:16.265]                           invokeRestart("muffleWarning")
[09:31:16.265]                       }
[09:31:16.265]                       else if (inherits(cond, "condition")) {
[09:31:16.265]                         if (!is.null(pattern)) {
[09:31:16.265]                           computeRestarts <- base::computeRestarts
[09:31:16.265]                           grepl <- base::grepl
[09:31:16.265]                           restarts <- computeRestarts(cond)
[09:31:16.265]                           for (restart in restarts) {
[09:31:16.265]                             name <- restart$name
[09:31:16.265]                             if (is.null(name)) 
[09:31:16.265]                               next
[09:31:16.265]                             if (!grepl(pattern, name)) 
[09:31:16.265]                               next
[09:31:16.265]                             invokeRestart(restart)
[09:31:16.265]                             muffled <- TRUE
[09:31:16.265]                             break
[09:31:16.265]                           }
[09:31:16.265]                         }
[09:31:16.265]                       }
[09:31:16.265]                       invisible(muffled)
[09:31:16.265]                     }
[09:31:16.265]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.265]                   }
[09:31:16.265]                 }
[09:31:16.265]             }
[09:31:16.265]         }))
[09:31:16.265]     }, error = function(ex) {
[09:31:16.265]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.265]                 ...future.rng), started = ...future.startTime, 
[09:31:16.265]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.265]             version = "1.8"), class = "FutureResult")
[09:31:16.265]     }, finally = {
[09:31:16.265]         if (!identical(...future.workdir, getwd())) 
[09:31:16.265]             setwd(...future.workdir)
[09:31:16.265]         {
[09:31:16.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.265]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.265]             }
[09:31:16.265]             base::options(...future.oldOptions)
[09:31:16.265]             if (.Platform$OS.type == "windows") {
[09:31:16.265]                 old_names <- names(...future.oldEnvVars)
[09:31:16.265]                 envs <- base::Sys.getenv()
[09:31:16.265]                 names <- names(envs)
[09:31:16.265]                 common <- intersect(names, old_names)
[09:31:16.265]                 added <- setdiff(names, old_names)
[09:31:16.265]                 removed <- setdiff(old_names, names)
[09:31:16.265]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.265]                   envs[common]]
[09:31:16.265]                 NAMES <- toupper(changed)
[09:31:16.265]                 args <- list()
[09:31:16.265]                 for (kk in seq_along(NAMES)) {
[09:31:16.265]                   name <- changed[[kk]]
[09:31:16.265]                   NAME <- NAMES[[kk]]
[09:31:16.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.265]                     next
[09:31:16.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.265]                 }
[09:31:16.265]                 NAMES <- toupper(added)
[09:31:16.265]                 for (kk in seq_along(NAMES)) {
[09:31:16.265]                   name <- added[[kk]]
[09:31:16.265]                   NAME <- NAMES[[kk]]
[09:31:16.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.265]                     next
[09:31:16.265]                   args[[name]] <- ""
[09:31:16.265]                 }
[09:31:16.265]                 NAMES <- toupper(removed)
[09:31:16.265]                 for (kk in seq_along(NAMES)) {
[09:31:16.265]                   name <- removed[[kk]]
[09:31:16.265]                   NAME <- NAMES[[kk]]
[09:31:16.265]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.265]                     next
[09:31:16.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.265]                 }
[09:31:16.265]                 if (length(args) > 0) 
[09:31:16.265]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.265]             }
[09:31:16.265]             else {
[09:31:16.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.265]             }
[09:31:16.265]             {
[09:31:16.265]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.265]                   0L) {
[09:31:16.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.265]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.265]                   base::options(opts)
[09:31:16.265]                 }
[09:31:16.265]                 {
[09:31:16.265]                   {
[09:31:16.265]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.265]                     NULL
[09:31:16.265]                   }
[09:31:16.265]                   options(future.plan = NULL)
[09:31:16.265]                   if (is.na(NA_character_)) 
[09:31:16.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.265]                     .init = FALSE)
[09:31:16.265]                 }
[09:31:16.265]             }
[09:31:16.265]         }
[09:31:16.265]     })
[09:31:16.265]     if (TRUE) {
[09:31:16.265]         base::sink(type = "output", split = FALSE)
[09:31:16.265]         if (TRUE) {
[09:31:16.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.265]         }
[09:31:16.265]         else {
[09:31:16.265]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.265]         }
[09:31:16.265]         base::close(...future.stdout)
[09:31:16.265]         ...future.stdout <- NULL
[09:31:16.265]     }
[09:31:16.265]     ...future.result$conditions <- ...future.conditions
[09:31:16.265]     ...future.result$finished <- base::Sys.time()
[09:31:16.265]     ...future.result
[09:31:16.265] }
[09:31:16.268] MultisessionFuture started
[09:31:16.268] - Launch lazy future ... done
[09:31:16.268] run() for ‘MultisessionFuture’ ... done
[09:31:16.268] getGlobalsAndPackages() ...
[09:31:16.268] Searching for globals...
[09:31:16.269] - globals found: [1] ‘{’
[09:31:16.269] Searching for globals ... DONE
[09:31:16.269] Resolving globals: FALSE
[09:31:16.269] 
[09:31:16.269] 
[09:31:16.270] getGlobalsAndPackages() ... DONE
[09:31:16.270] run() for ‘Future’ ...
[09:31:16.270] - state: ‘created’
[09:31:16.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.283]   - Field: ‘node’
[09:31:16.284]   - Field: ‘label’
[09:31:16.284]   - Field: ‘local’
[09:31:16.284]   - Field: ‘owner’
[09:31:16.284]   - Field: ‘envir’
[09:31:16.284]   - Field: ‘workers’
[09:31:16.284]   - Field: ‘packages’
[09:31:16.284]   - Field: ‘gc’
[09:31:16.284]   - Field: ‘conditions’
[09:31:16.284]   - Field: ‘persistent’
[09:31:16.284]   - Field: ‘expr’
[09:31:16.285]   - Field: ‘uuid’
[09:31:16.285]   - Field: ‘seed’
[09:31:16.285]   - Field: ‘version’
[09:31:16.285]   - Field: ‘result’
[09:31:16.285]   - Field: ‘asynchronous’
[09:31:16.285]   - Field: ‘calls’
[09:31:16.285]   - Field: ‘globals’
[09:31:16.285]   - Field: ‘stdout’
[09:31:16.285]   - Field: ‘earlySignal’
[09:31:16.285]   - Field: ‘lazy’
[09:31:16.285]   - Field: ‘state’
[09:31:16.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.286] - Launch lazy future ...
[09:31:16.286] Packages needed by the future expression (n = 0): <none>
[09:31:16.286] Packages needed by future strategies (n = 0): <none>
[09:31:16.286] {
[09:31:16.286]     {
[09:31:16.286]         {
[09:31:16.286]             ...future.startTime <- base::Sys.time()
[09:31:16.286]             {
[09:31:16.286]                 {
[09:31:16.286]                   {
[09:31:16.286]                     {
[09:31:16.286]                       base::local({
[09:31:16.286]                         has_future <- base::requireNamespace("future", 
[09:31:16.286]                           quietly = TRUE)
[09:31:16.286]                         if (has_future) {
[09:31:16.286]                           ns <- base::getNamespace("future")
[09:31:16.286]                           version <- ns[[".package"]][["version"]]
[09:31:16.286]                           if (is.null(version)) 
[09:31:16.286]                             version <- utils::packageVersion("future")
[09:31:16.286]                         }
[09:31:16.286]                         else {
[09:31:16.286]                           version <- NULL
[09:31:16.286]                         }
[09:31:16.286]                         if (!has_future || version < "1.8.0") {
[09:31:16.286]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.286]                             "", base::R.version$version.string), 
[09:31:16.286]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.286]                               "release", "version")], collapse = " "), 
[09:31:16.286]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.286]                             info)
[09:31:16.286]                           info <- base::paste(info, collapse = "; ")
[09:31:16.286]                           if (!has_future) {
[09:31:16.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.286]                               info)
[09:31:16.286]                           }
[09:31:16.286]                           else {
[09:31:16.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.286]                               info, version)
[09:31:16.286]                           }
[09:31:16.286]                           base::stop(msg)
[09:31:16.286]                         }
[09:31:16.286]                       })
[09:31:16.286]                     }
[09:31:16.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.286]                     base::options(mc.cores = 1L)
[09:31:16.286]                   }
[09:31:16.286]                   ...future.strategy.old <- future::plan("list")
[09:31:16.286]                   options(future.plan = NULL)
[09:31:16.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.286]                 }
[09:31:16.286]                 ...future.workdir <- getwd()
[09:31:16.286]             }
[09:31:16.286]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.286]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.286]         }
[09:31:16.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.286]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.286]             base::names(...future.oldOptions))
[09:31:16.286]     }
[09:31:16.286]     if (FALSE) {
[09:31:16.286]     }
[09:31:16.286]     else {
[09:31:16.286]         if (TRUE) {
[09:31:16.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.286]                 open = "w")
[09:31:16.286]         }
[09:31:16.286]         else {
[09:31:16.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.286]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.286]         }
[09:31:16.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.286]             base::sink(type = "output", split = FALSE)
[09:31:16.286]             base::close(...future.stdout)
[09:31:16.286]         }, add = TRUE)
[09:31:16.286]     }
[09:31:16.286]     ...future.frame <- base::sys.nframe()
[09:31:16.286]     ...future.conditions <- base::list()
[09:31:16.286]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.286]     if (FALSE) {
[09:31:16.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.286]     }
[09:31:16.286]     ...future.result <- base::tryCatch({
[09:31:16.286]         base::withCallingHandlers({
[09:31:16.286]             ...future.value <- base::withVisible(base::local({
[09:31:16.286]                 ...future.makeSendCondition <- base::local({
[09:31:16.286]                   sendCondition <- NULL
[09:31:16.286]                   function(frame = 1L) {
[09:31:16.286]                     if (is.function(sendCondition)) 
[09:31:16.286]                       return(sendCondition)
[09:31:16.286]                     ns <- getNamespace("parallel")
[09:31:16.286]                     if (exists("sendData", mode = "function", 
[09:31:16.286]                       envir = ns)) {
[09:31:16.286]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.286]                         envir = ns)
[09:31:16.286]                       envir <- sys.frame(frame)
[09:31:16.286]                       master <- NULL
[09:31:16.286]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.286]                         !identical(envir, emptyenv())) {
[09:31:16.286]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.286]                           inherits = FALSE)) {
[09:31:16.286]                           master <- get("master", mode = "list", 
[09:31:16.286]                             envir = envir, inherits = FALSE)
[09:31:16.286]                           if (inherits(master, c("SOCKnode", 
[09:31:16.286]                             "SOCK0node"))) {
[09:31:16.286]                             sendCondition <<- function(cond) {
[09:31:16.286]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.286]                                 success = TRUE)
[09:31:16.286]                               parallel_sendData(master, data)
[09:31:16.286]                             }
[09:31:16.286]                             return(sendCondition)
[09:31:16.286]                           }
[09:31:16.286]                         }
[09:31:16.286]                         frame <- frame + 1L
[09:31:16.286]                         envir <- sys.frame(frame)
[09:31:16.286]                       }
[09:31:16.286]                     }
[09:31:16.286]                     sendCondition <<- function(cond) NULL
[09:31:16.286]                   }
[09:31:16.286]                 })
[09:31:16.286]                 withCallingHandlers({
[09:31:16.286]                   {
[09:31:16.286]                     4
[09:31:16.286]                   }
[09:31:16.286]                 }, immediateCondition = function(cond) {
[09:31:16.286]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.286]                   sendCondition(cond)
[09:31:16.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.286]                   {
[09:31:16.286]                     inherits <- base::inherits
[09:31:16.286]                     invokeRestart <- base::invokeRestart
[09:31:16.286]                     is.null <- base::is.null
[09:31:16.286]                     muffled <- FALSE
[09:31:16.286]                     if (inherits(cond, "message")) {
[09:31:16.286]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.286]                       if (muffled) 
[09:31:16.286]                         invokeRestart("muffleMessage")
[09:31:16.286]                     }
[09:31:16.286]                     else if (inherits(cond, "warning")) {
[09:31:16.286]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.286]                       if (muffled) 
[09:31:16.286]                         invokeRestart("muffleWarning")
[09:31:16.286]                     }
[09:31:16.286]                     else if (inherits(cond, "condition")) {
[09:31:16.286]                       if (!is.null(pattern)) {
[09:31:16.286]                         computeRestarts <- base::computeRestarts
[09:31:16.286]                         grepl <- base::grepl
[09:31:16.286]                         restarts <- computeRestarts(cond)
[09:31:16.286]                         for (restart in restarts) {
[09:31:16.286]                           name <- restart$name
[09:31:16.286]                           if (is.null(name)) 
[09:31:16.286]                             next
[09:31:16.286]                           if (!grepl(pattern, name)) 
[09:31:16.286]                             next
[09:31:16.286]                           invokeRestart(restart)
[09:31:16.286]                           muffled <- TRUE
[09:31:16.286]                           break
[09:31:16.286]                         }
[09:31:16.286]                       }
[09:31:16.286]                     }
[09:31:16.286]                     invisible(muffled)
[09:31:16.286]                   }
[09:31:16.286]                   muffleCondition(cond)
[09:31:16.286]                 })
[09:31:16.286]             }))
[09:31:16.286]             future::FutureResult(value = ...future.value$value, 
[09:31:16.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.286]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.286]                     ...future.globalenv.names))
[09:31:16.286]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.286]         }, condition = base::local({
[09:31:16.286]             c <- base::c
[09:31:16.286]             inherits <- base::inherits
[09:31:16.286]             invokeRestart <- base::invokeRestart
[09:31:16.286]             length <- base::length
[09:31:16.286]             list <- base::list
[09:31:16.286]             seq.int <- base::seq.int
[09:31:16.286]             signalCondition <- base::signalCondition
[09:31:16.286]             sys.calls <- base::sys.calls
[09:31:16.286]             `[[` <- base::`[[`
[09:31:16.286]             `+` <- base::`+`
[09:31:16.286]             `<<-` <- base::`<<-`
[09:31:16.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.286]                   3L)]
[09:31:16.286]             }
[09:31:16.286]             function(cond) {
[09:31:16.286]                 is_error <- inherits(cond, "error")
[09:31:16.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.286]                   NULL)
[09:31:16.286]                 if (is_error) {
[09:31:16.286]                   sessionInformation <- function() {
[09:31:16.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.286]                       search = base::search(), system = base::Sys.info())
[09:31:16.286]                   }
[09:31:16.286]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.286]                     cond$call), session = sessionInformation(), 
[09:31:16.286]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.286]                   signalCondition(cond)
[09:31:16.286]                 }
[09:31:16.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.286]                 "immediateCondition"))) {
[09:31:16.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.286]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.286]                   if (TRUE && !signal) {
[09:31:16.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.286]                     {
[09:31:16.286]                       inherits <- base::inherits
[09:31:16.286]                       invokeRestart <- base::invokeRestart
[09:31:16.286]                       is.null <- base::is.null
[09:31:16.286]                       muffled <- FALSE
[09:31:16.286]                       if (inherits(cond, "message")) {
[09:31:16.286]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.286]                         if (muffled) 
[09:31:16.286]                           invokeRestart("muffleMessage")
[09:31:16.286]                       }
[09:31:16.286]                       else if (inherits(cond, "warning")) {
[09:31:16.286]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.286]                         if (muffled) 
[09:31:16.286]                           invokeRestart("muffleWarning")
[09:31:16.286]                       }
[09:31:16.286]                       else if (inherits(cond, "condition")) {
[09:31:16.286]                         if (!is.null(pattern)) {
[09:31:16.286]                           computeRestarts <- base::computeRestarts
[09:31:16.286]                           grepl <- base::grepl
[09:31:16.286]                           restarts <- computeRestarts(cond)
[09:31:16.286]                           for (restart in restarts) {
[09:31:16.286]                             name <- restart$name
[09:31:16.286]                             if (is.null(name)) 
[09:31:16.286]                               next
[09:31:16.286]                             if (!grepl(pattern, name)) 
[09:31:16.286]                               next
[09:31:16.286]                             invokeRestart(restart)
[09:31:16.286]                             muffled <- TRUE
[09:31:16.286]                             break
[09:31:16.286]                           }
[09:31:16.286]                         }
[09:31:16.286]                       }
[09:31:16.286]                       invisible(muffled)
[09:31:16.286]                     }
[09:31:16.286]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.286]                   }
[09:31:16.286]                 }
[09:31:16.286]                 else {
[09:31:16.286]                   if (TRUE) {
[09:31:16.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.286]                     {
[09:31:16.286]                       inherits <- base::inherits
[09:31:16.286]                       invokeRestart <- base::invokeRestart
[09:31:16.286]                       is.null <- base::is.null
[09:31:16.286]                       muffled <- FALSE
[09:31:16.286]                       if (inherits(cond, "message")) {
[09:31:16.286]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.286]                         if (muffled) 
[09:31:16.286]                           invokeRestart("muffleMessage")
[09:31:16.286]                       }
[09:31:16.286]                       else if (inherits(cond, "warning")) {
[09:31:16.286]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.286]                         if (muffled) 
[09:31:16.286]                           invokeRestart("muffleWarning")
[09:31:16.286]                       }
[09:31:16.286]                       else if (inherits(cond, "condition")) {
[09:31:16.286]                         if (!is.null(pattern)) {
[09:31:16.286]                           computeRestarts <- base::computeRestarts
[09:31:16.286]                           grepl <- base::grepl
[09:31:16.286]                           restarts <- computeRestarts(cond)
[09:31:16.286]                           for (restart in restarts) {
[09:31:16.286]                             name <- restart$name
[09:31:16.286]                             if (is.null(name)) 
[09:31:16.286]                               next
[09:31:16.286]                             if (!grepl(pattern, name)) 
[09:31:16.286]                               next
[09:31:16.286]                             invokeRestart(restart)
[09:31:16.286]                             muffled <- TRUE
[09:31:16.286]                             break
[09:31:16.286]                           }
[09:31:16.286]                         }
[09:31:16.286]                       }
[09:31:16.286]                       invisible(muffled)
[09:31:16.286]                     }
[09:31:16.286]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.286]                   }
[09:31:16.286]                 }
[09:31:16.286]             }
[09:31:16.286]         }))
[09:31:16.286]     }, error = function(ex) {
[09:31:16.286]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.286]                 ...future.rng), started = ...future.startTime, 
[09:31:16.286]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.286]             version = "1.8"), class = "FutureResult")
[09:31:16.286]     }, finally = {
[09:31:16.286]         if (!identical(...future.workdir, getwd())) 
[09:31:16.286]             setwd(...future.workdir)
[09:31:16.286]         {
[09:31:16.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.286]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.286]             }
[09:31:16.286]             base::options(...future.oldOptions)
[09:31:16.286]             if (.Platform$OS.type == "windows") {
[09:31:16.286]                 old_names <- names(...future.oldEnvVars)
[09:31:16.286]                 envs <- base::Sys.getenv()
[09:31:16.286]                 names <- names(envs)
[09:31:16.286]                 common <- intersect(names, old_names)
[09:31:16.286]                 added <- setdiff(names, old_names)
[09:31:16.286]                 removed <- setdiff(old_names, names)
[09:31:16.286]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.286]                   envs[common]]
[09:31:16.286]                 NAMES <- toupper(changed)
[09:31:16.286]                 args <- list()
[09:31:16.286]                 for (kk in seq_along(NAMES)) {
[09:31:16.286]                   name <- changed[[kk]]
[09:31:16.286]                   NAME <- NAMES[[kk]]
[09:31:16.286]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.286]                     next
[09:31:16.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.286]                 }
[09:31:16.286]                 NAMES <- toupper(added)
[09:31:16.286]                 for (kk in seq_along(NAMES)) {
[09:31:16.286]                   name <- added[[kk]]
[09:31:16.286]                   NAME <- NAMES[[kk]]
[09:31:16.286]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.286]                     next
[09:31:16.286]                   args[[name]] <- ""
[09:31:16.286]                 }
[09:31:16.286]                 NAMES <- toupper(removed)
[09:31:16.286]                 for (kk in seq_along(NAMES)) {
[09:31:16.286]                   name <- removed[[kk]]
[09:31:16.286]                   NAME <- NAMES[[kk]]
[09:31:16.286]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.286]                     next
[09:31:16.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.286]                 }
[09:31:16.286]                 if (length(args) > 0) 
[09:31:16.286]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.286]             }
[09:31:16.286]             else {
[09:31:16.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.286]             }
[09:31:16.286]             {
[09:31:16.286]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.286]                   0L) {
[09:31:16.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.286]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.286]                   base::options(opts)
[09:31:16.286]                 }
[09:31:16.286]                 {
[09:31:16.286]                   {
[09:31:16.286]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.286]                     NULL
[09:31:16.286]                   }
[09:31:16.286]                   options(future.plan = NULL)
[09:31:16.286]                   if (is.na(NA_character_)) 
[09:31:16.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.286]                     .init = FALSE)
[09:31:16.286]                 }
[09:31:16.286]             }
[09:31:16.286]         }
[09:31:16.286]     })
[09:31:16.286]     if (TRUE) {
[09:31:16.286]         base::sink(type = "output", split = FALSE)
[09:31:16.286]         if (TRUE) {
[09:31:16.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.286]         }
[09:31:16.286]         else {
[09:31:16.286]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.286]         }
[09:31:16.286]         base::close(...future.stdout)
[09:31:16.286]         ...future.stdout <- NULL
[09:31:16.286]     }
[09:31:16.286]     ...future.result$conditions <- ...future.conditions
[09:31:16.286]     ...future.result$finished <- base::Sys.time()
[09:31:16.286]     ...future.result
[09:31:16.286] }
[09:31:16.288] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:16.299] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.299] - Validating connection of MultisessionFuture
[09:31:16.299] - received message: FutureResult
[09:31:16.300] - Received FutureResult
[09:31:16.300] - Erased future from FutureRegistry
[09:31:16.300] result() for ClusterFuture ...
[09:31:16.300] - result already collected: FutureResult
[09:31:16.300] result() for ClusterFuture ... done
[09:31:16.300] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.300] result() for ClusterFuture ...
[09:31:16.300] - result already collected: FutureResult
[09:31:16.300] result() for ClusterFuture ... done
[09:31:16.300] result() for ClusterFuture ...
[09:31:16.301] - result already collected: FutureResult
[09:31:16.301] result() for ClusterFuture ... done
[09:31:16.302] MultisessionFuture started
[09:31:16.302] - Launch lazy future ... done
[09:31:16.302] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3ca082bc0> 
Classes 'listenv', 'environment' <environment: 0x55a3cc766e78> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[09:31:16.305] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.306] - Validating connection of MultisessionFuture
[09:31:16.306] - received message: FutureResult
[09:31:16.306] - Received FutureResult
[09:31:16.306] - Erased future from FutureRegistry
[09:31:16.306] result() for ClusterFuture ...
[09:31:16.306] - result already collected: FutureResult
[09:31:16.306] result() for ClusterFuture ... done
[09:31:16.306] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.307] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.307] - Validating connection of MultisessionFuture
[09:31:16.307] - received message: FutureResult
[09:31:16.307] - Received FutureResult
[09:31:16.307] - Erased future from FutureRegistry
[09:31:16.307] result() for ClusterFuture ...
[09:31:16.308] - result already collected: FutureResult
[09:31:16.308] result() for ClusterFuture ... done
[09:31:16.308] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:16.310] resolve() on list environment ...
[09:31:16.310]  recursive: 0
[09:31:16.311]  length: 6
[09:31:16.311]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:16.311] signalConditionsASAP(numeric, pos=1) ...
[09:31:16.311] - nx: 6
[09:31:16.311] - relay: TRUE
[09:31:16.311] - stdout: TRUE
[09:31:16.311] - signal: TRUE
[09:31:16.312] - resignal: FALSE
[09:31:16.312] - force: TRUE
[09:31:16.312] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.312] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.312]  - until=2
[09:31:16.312]  - relaying element #2
[09:31:16.312] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.312] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.312] signalConditionsASAP(NULL, pos=1) ... done
[09:31:16.312]  length: 5 (resolved future 1)
[09:31:16.313] Future #2
[09:31:16.313] result() for ClusterFuture ...
[09:31:16.313] - result already collected: FutureResult
[09:31:16.313] result() for ClusterFuture ... done
[09:31:16.313] result() for ClusterFuture ...
[09:31:16.313] - result already collected: FutureResult
[09:31:16.313] result() for ClusterFuture ... done
[09:31:16.313] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:16.313] - nx: 6
[09:31:16.313] - relay: TRUE
[09:31:16.313] - stdout: TRUE
[09:31:16.313] - signal: TRUE
[09:31:16.314] - resignal: FALSE
[09:31:16.314] - force: TRUE
[09:31:16.314] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.314] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.314]  - until=2
[09:31:16.314]  - relaying element #2
[09:31:16.314] result() for ClusterFuture ...
[09:31:16.314] - result already collected: FutureResult
[09:31:16.314] result() for ClusterFuture ... done
[09:31:16.314] result() for ClusterFuture ...
[09:31:16.314] - result already collected: FutureResult
[09:31:16.314] result() for ClusterFuture ... done
[09:31:16.315] result() for ClusterFuture ...
[09:31:16.315] - result already collected: FutureResult
[09:31:16.315] result() for ClusterFuture ... done
[09:31:16.315] result() for ClusterFuture ...
[09:31:16.315] - result already collected: FutureResult
[09:31:16.315] result() for ClusterFuture ... done
[09:31:16.315] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.315] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.315] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:16.315]  length: 4 (resolved future 2)
[09:31:16.315] Future #3
[09:31:16.316] result() for ClusterFuture ...
[09:31:16.316] - result already collected: FutureResult
[09:31:16.316] result() for ClusterFuture ... done
[09:31:16.316] result() for ClusterFuture ...
[09:31:16.316] - result already collected: FutureResult
[09:31:16.316] result() for ClusterFuture ... done
[09:31:16.316] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:16.316] - nx: 6
[09:31:16.316] - relay: TRUE
[09:31:16.316] - stdout: TRUE
[09:31:16.316] - signal: TRUE
[09:31:16.317] - resignal: FALSE
[09:31:16.319] - force: TRUE
[09:31:16.320] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.320] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.320]  - until=3
[09:31:16.320]  - relaying element #3
[09:31:16.320] result() for ClusterFuture ...
[09:31:16.320] - result already collected: FutureResult
[09:31:16.320] result() for ClusterFuture ... done
[09:31:16.320] result() for ClusterFuture ...
[09:31:16.321] - result already collected: FutureResult
[09:31:16.321] result() for ClusterFuture ... done
[09:31:16.321] result() for ClusterFuture ...
[09:31:16.321] - result already collected: FutureResult
[09:31:16.321] result() for ClusterFuture ... done
[09:31:16.321] result() for ClusterFuture ...
[09:31:16.321] - result already collected: FutureResult
[09:31:16.321] result() for ClusterFuture ... done
[09:31:16.321] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.321] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.321] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:16.322]  length: 3 (resolved future 3)
[09:31:16.322] Future #4
[09:31:16.322] result() for ClusterFuture ...
[09:31:16.322] - result already collected: FutureResult
[09:31:16.322] result() for ClusterFuture ... done
[09:31:16.322] result() for ClusterFuture ...
[09:31:16.322] - result already collected: FutureResult
[09:31:16.322] result() for ClusterFuture ... done
[09:31:16.322] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:16.322] - nx: 6
[09:31:16.322] - relay: TRUE
[09:31:16.323] - stdout: TRUE
[09:31:16.323] - signal: TRUE
[09:31:16.323] - resignal: FALSE
[09:31:16.323] - force: TRUE
[09:31:16.323] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.323] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.323]  - until=4
[09:31:16.323]  - relaying element #4
[09:31:16.323] result() for ClusterFuture ...
[09:31:16.323] - result already collected: FutureResult
[09:31:16.323] result() for ClusterFuture ... done
[09:31:16.323] result() for ClusterFuture ...
[09:31:16.323] - result already collected: FutureResult
[09:31:16.324] result() for ClusterFuture ... done
[09:31:16.324] result() for ClusterFuture ...
[09:31:16.324] - result already collected: FutureResult
[09:31:16.324] result() for ClusterFuture ... done
[09:31:16.324] result() for ClusterFuture ...
[09:31:16.324] - result already collected: FutureResult
[09:31:16.324] result() for ClusterFuture ... done
[09:31:16.324] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.324] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.324] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:16.324]  length: 2 (resolved future 4)
[09:31:16.325] signalConditionsASAP(NULL, pos=5) ...
[09:31:16.325] - nx: 6
[09:31:16.325] - relay: TRUE
[09:31:16.325] - stdout: TRUE
[09:31:16.325] - signal: TRUE
[09:31:16.325] - resignal: FALSE
[09:31:16.325] - force: TRUE
[09:31:16.325] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.325] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.325]  - until=6
[09:31:16.325]  - relaying element #6
[09:31:16.325] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.326] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.326] signalConditionsASAP(NULL, pos=5) ... done
[09:31:16.326]  length: 1 (resolved future 5)
[09:31:16.326] signalConditionsASAP(numeric, pos=6) ...
[09:31:16.326] - nx: 6
[09:31:16.326] - relay: TRUE
[09:31:16.326] - stdout: TRUE
[09:31:16.326] - signal: TRUE
[09:31:16.326] - resignal: FALSE
[09:31:16.326] - force: TRUE
[09:31:16.326] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.326] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.327]  - until=6
[09:31:16.327] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.327] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.327] signalConditionsASAP(numeric, pos=6) ... done
[09:31:16.327]  length: 0 (resolved future 6)
[09:31:16.327] Relaying remaining futures
[09:31:16.327] signalConditionsASAP(NULL, pos=0) ...
[09:31:16.327] - nx: 6
[09:31:16.327] - relay: TRUE
[09:31:16.327] - stdout: TRUE
[09:31:16.327] - signal: TRUE
[09:31:16.327] - resignal: FALSE
[09:31:16.327] - force: TRUE
[09:31:16.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.328] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:16.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.328] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.328] signalConditionsASAP(NULL, pos=0) ... done
[09:31:16.328] resolve() on list environment ... DONE
[09:31:16.328] result() for ClusterFuture ...
[09:31:16.328] - result already collected: FutureResult
[09:31:16.328] result() for ClusterFuture ... done
[09:31:16.328] result() for ClusterFuture ...
[09:31:16.329] - result already collected: FutureResult
[09:31:16.329] result() for ClusterFuture ... done
[09:31:16.329] result() for ClusterFuture ...
[09:31:16.329] - result already collected: FutureResult
[09:31:16.329] result() for ClusterFuture ... done
[09:31:16.329] result() for ClusterFuture ...
[09:31:16.329] - result already collected: FutureResult
[09:31:16.329] result() for ClusterFuture ... done
[09:31:16.329] result() for ClusterFuture ...
[09:31:16.329] - result already collected: FutureResult
[09:31:16.330] result() for ClusterFuture ... done
[09:31:16.330] result() for ClusterFuture ...
[09:31:16.330] - result already collected: FutureResult
[09:31:16.330] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3ccab2ac8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[09:31:16.331] getGlobalsAndPackages() ...
[09:31:16.332] Searching for globals...
[09:31:16.332] 
[09:31:16.332] Searching for globals ... DONE
[09:31:16.332] - globals: [0] <none>
[09:31:16.332] getGlobalsAndPackages() ... DONE
[09:31:16.332] run() for ‘Future’ ...
[09:31:16.333] - state: ‘created’
[09:31:16.333] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.346] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.347]   - Field: ‘node’
[09:31:16.347]   - Field: ‘label’
[09:31:16.347]   - Field: ‘local’
[09:31:16.347]   - Field: ‘owner’
[09:31:16.347]   - Field: ‘envir’
[09:31:16.347]   - Field: ‘workers’
[09:31:16.347]   - Field: ‘packages’
[09:31:16.347]   - Field: ‘gc’
[09:31:16.347]   - Field: ‘conditions’
[09:31:16.348]   - Field: ‘persistent’
[09:31:16.348]   - Field: ‘expr’
[09:31:16.348]   - Field: ‘uuid’
[09:31:16.348]   - Field: ‘seed’
[09:31:16.348]   - Field: ‘version’
[09:31:16.348]   - Field: ‘result’
[09:31:16.348]   - Field: ‘asynchronous’
[09:31:16.348]   - Field: ‘calls’
[09:31:16.348]   - Field: ‘globals’
[09:31:16.348]   - Field: ‘stdout’
[09:31:16.348]   - Field: ‘earlySignal’
[09:31:16.349]   - Field: ‘lazy’
[09:31:16.349]   - Field: ‘state’
[09:31:16.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.349] - Launch lazy future ...
[09:31:16.349] Packages needed by the future expression (n = 0): <none>
[09:31:16.349] Packages needed by future strategies (n = 0): <none>
[09:31:16.350] {
[09:31:16.350]     {
[09:31:16.350]         {
[09:31:16.350]             ...future.startTime <- base::Sys.time()
[09:31:16.350]             {
[09:31:16.350]                 {
[09:31:16.350]                   {
[09:31:16.350]                     {
[09:31:16.350]                       base::local({
[09:31:16.350]                         has_future <- base::requireNamespace("future", 
[09:31:16.350]                           quietly = TRUE)
[09:31:16.350]                         if (has_future) {
[09:31:16.350]                           ns <- base::getNamespace("future")
[09:31:16.350]                           version <- ns[[".package"]][["version"]]
[09:31:16.350]                           if (is.null(version)) 
[09:31:16.350]                             version <- utils::packageVersion("future")
[09:31:16.350]                         }
[09:31:16.350]                         else {
[09:31:16.350]                           version <- NULL
[09:31:16.350]                         }
[09:31:16.350]                         if (!has_future || version < "1.8.0") {
[09:31:16.350]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.350]                             "", base::R.version$version.string), 
[09:31:16.350]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.350]                               "release", "version")], collapse = " "), 
[09:31:16.350]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.350]                             info)
[09:31:16.350]                           info <- base::paste(info, collapse = "; ")
[09:31:16.350]                           if (!has_future) {
[09:31:16.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.350]                               info)
[09:31:16.350]                           }
[09:31:16.350]                           else {
[09:31:16.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.350]                               info, version)
[09:31:16.350]                           }
[09:31:16.350]                           base::stop(msg)
[09:31:16.350]                         }
[09:31:16.350]                       })
[09:31:16.350]                     }
[09:31:16.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.350]                     base::options(mc.cores = 1L)
[09:31:16.350]                   }
[09:31:16.350]                   ...future.strategy.old <- future::plan("list")
[09:31:16.350]                   options(future.plan = NULL)
[09:31:16.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.350]                 }
[09:31:16.350]                 ...future.workdir <- getwd()
[09:31:16.350]             }
[09:31:16.350]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.350]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.350]         }
[09:31:16.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.350]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.350]             base::names(...future.oldOptions))
[09:31:16.350]     }
[09:31:16.350]     if (FALSE) {
[09:31:16.350]     }
[09:31:16.350]     else {
[09:31:16.350]         if (TRUE) {
[09:31:16.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.350]                 open = "w")
[09:31:16.350]         }
[09:31:16.350]         else {
[09:31:16.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.350]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.350]         }
[09:31:16.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.350]             base::sink(type = "output", split = FALSE)
[09:31:16.350]             base::close(...future.stdout)
[09:31:16.350]         }, add = TRUE)
[09:31:16.350]     }
[09:31:16.350]     ...future.frame <- base::sys.nframe()
[09:31:16.350]     ...future.conditions <- base::list()
[09:31:16.350]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.350]     if (FALSE) {
[09:31:16.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.350]     }
[09:31:16.350]     ...future.result <- base::tryCatch({
[09:31:16.350]         base::withCallingHandlers({
[09:31:16.350]             ...future.value <- base::withVisible(base::local({
[09:31:16.350]                 ...future.makeSendCondition <- base::local({
[09:31:16.350]                   sendCondition <- NULL
[09:31:16.350]                   function(frame = 1L) {
[09:31:16.350]                     if (is.function(sendCondition)) 
[09:31:16.350]                       return(sendCondition)
[09:31:16.350]                     ns <- getNamespace("parallel")
[09:31:16.350]                     if (exists("sendData", mode = "function", 
[09:31:16.350]                       envir = ns)) {
[09:31:16.350]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.350]                         envir = ns)
[09:31:16.350]                       envir <- sys.frame(frame)
[09:31:16.350]                       master <- NULL
[09:31:16.350]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.350]                         !identical(envir, emptyenv())) {
[09:31:16.350]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.350]                           inherits = FALSE)) {
[09:31:16.350]                           master <- get("master", mode = "list", 
[09:31:16.350]                             envir = envir, inherits = FALSE)
[09:31:16.350]                           if (inherits(master, c("SOCKnode", 
[09:31:16.350]                             "SOCK0node"))) {
[09:31:16.350]                             sendCondition <<- function(cond) {
[09:31:16.350]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.350]                                 success = TRUE)
[09:31:16.350]                               parallel_sendData(master, data)
[09:31:16.350]                             }
[09:31:16.350]                             return(sendCondition)
[09:31:16.350]                           }
[09:31:16.350]                         }
[09:31:16.350]                         frame <- frame + 1L
[09:31:16.350]                         envir <- sys.frame(frame)
[09:31:16.350]                       }
[09:31:16.350]                     }
[09:31:16.350]                     sendCondition <<- function(cond) NULL
[09:31:16.350]                   }
[09:31:16.350]                 })
[09:31:16.350]                 withCallingHandlers({
[09:31:16.350]                   2
[09:31:16.350]                 }, immediateCondition = function(cond) {
[09:31:16.350]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.350]                   sendCondition(cond)
[09:31:16.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.350]                   {
[09:31:16.350]                     inherits <- base::inherits
[09:31:16.350]                     invokeRestart <- base::invokeRestart
[09:31:16.350]                     is.null <- base::is.null
[09:31:16.350]                     muffled <- FALSE
[09:31:16.350]                     if (inherits(cond, "message")) {
[09:31:16.350]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.350]                       if (muffled) 
[09:31:16.350]                         invokeRestart("muffleMessage")
[09:31:16.350]                     }
[09:31:16.350]                     else if (inherits(cond, "warning")) {
[09:31:16.350]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.350]                       if (muffled) 
[09:31:16.350]                         invokeRestart("muffleWarning")
[09:31:16.350]                     }
[09:31:16.350]                     else if (inherits(cond, "condition")) {
[09:31:16.350]                       if (!is.null(pattern)) {
[09:31:16.350]                         computeRestarts <- base::computeRestarts
[09:31:16.350]                         grepl <- base::grepl
[09:31:16.350]                         restarts <- computeRestarts(cond)
[09:31:16.350]                         for (restart in restarts) {
[09:31:16.350]                           name <- restart$name
[09:31:16.350]                           if (is.null(name)) 
[09:31:16.350]                             next
[09:31:16.350]                           if (!grepl(pattern, name)) 
[09:31:16.350]                             next
[09:31:16.350]                           invokeRestart(restart)
[09:31:16.350]                           muffled <- TRUE
[09:31:16.350]                           break
[09:31:16.350]                         }
[09:31:16.350]                       }
[09:31:16.350]                     }
[09:31:16.350]                     invisible(muffled)
[09:31:16.350]                   }
[09:31:16.350]                   muffleCondition(cond)
[09:31:16.350]                 })
[09:31:16.350]             }))
[09:31:16.350]             future::FutureResult(value = ...future.value$value, 
[09:31:16.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.350]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.350]                     ...future.globalenv.names))
[09:31:16.350]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.350]         }, condition = base::local({
[09:31:16.350]             c <- base::c
[09:31:16.350]             inherits <- base::inherits
[09:31:16.350]             invokeRestart <- base::invokeRestart
[09:31:16.350]             length <- base::length
[09:31:16.350]             list <- base::list
[09:31:16.350]             seq.int <- base::seq.int
[09:31:16.350]             signalCondition <- base::signalCondition
[09:31:16.350]             sys.calls <- base::sys.calls
[09:31:16.350]             `[[` <- base::`[[`
[09:31:16.350]             `+` <- base::`+`
[09:31:16.350]             `<<-` <- base::`<<-`
[09:31:16.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.350]                   3L)]
[09:31:16.350]             }
[09:31:16.350]             function(cond) {
[09:31:16.350]                 is_error <- inherits(cond, "error")
[09:31:16.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.350]                   NULL)
[09:31:16.350]                 if (is_error) {
[09:31:16.350]                   sessionInformation <- function() {
[09:31:16.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.350]                       search = base::search(), system = base::Sys.info())
[09:31:16.350]                   }
[09:31:16.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.350]                     cond$call), session = sessionInformation(), 
[09:31:16.350]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.350]                   signalCondition(cond)
[09:31:16.350]                 }
[09:31:16.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.350]                 "immediateCondition"))) {
[09:31:16.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.350]                   if (TRUE && !signal) {
[09:31:16.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.350]                     {
[09:31:16.350]                       inherits <- base::inherits
[09:31:16.350]                       invokeRestart <- base::invokeRestart
[09:31:16.350]                       is.null <- base::is.null
[09:31:16.350]                       muffled <- FALSE
[09:31:16.350]                       if (inherits(cond, "message")) {
[09:31:16.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.350]                         if (muffled) 
[09:31:16.350]                           invokeRestart("muffleMessage")
[09:31:16.350]                       }
[09:31:16.350]                       else if (inherits(cond, "warning")) {
[09:31:16.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.350]                         if (muffled) 
[09:31:16.350]                           invokeRestart("muffleWarning")
[09:31:16.350]                       }
[09:31:16.350]                       else if (inherits(cond, "condition")) {
[09:31:16.350]                         if (!is.null(pattern)) {
[09:31:16.350]                           computeRestarts <- base::computeRestarts
[09:31:16.350]                           grepl <- base::grepl
[09:31:16.350]                           restarts <- computeRestarts(cond)
[09:31:16.350]                           for (restart in restarts) {
[09:31:16.350]                             name <- restart$name
[09:31:16.350]                             if (is.null(name)) 
[09:31:16.350]                               next
[09:31:16.350]                             if (!grepl(pattern, name)) 
[09:31:16.350]                               next
[09:31:16.350]                             invokeRestart(restart)
[09:31:16.350]                             muffled <- TRUE
[09:31:16.350]                             break
[09:31:16.350]                           }
[09:31:16.350]                         }
[09:31:16.350]                       }
[09:31:16.350]                       invisible(muffled)
[09:31:16.350]                     }
[09:31:16.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.350]                   }
[09:31:16.350]                 }
[09:31:16.350]                 else {
[09:31:16.350]                   if (TRUE) {
[09:31:16.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.350]                     {
[09:31:16.350]                       inherits <- base::inherits
[09:31:16.350]                       invokeRestart <- base::invokeRestart
[09:31:16.350]                       is.null <- base::is.null
[09:31:16.350]                       muffled <- FALSE
[09:31:16.350]                       if (inherits(cond, "message")) {
[09:31:16.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.350]                         if (muffled) 
[09:31:16.350]                           invokeRestart("muffleMessage")
[09:31:16.350]                       }
[09:31:16.350]                       else if (inherits(cond, "warning")) {
[09:31:16.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.350]                         if (muffled) 
[09:31:16.350]                           invokeRestart("muffleWarning")
[09:31:16.350]                       }
[09:31:16.350]                       else if (inherits(cond, "condition")) {
[09:31:16.350]                         if (!is.null(pattern)) {
[09:31:16.350]                           computeRestarts <- base::computeRestarts
[09:31:16.350]                           grepl <- base::grepl
[09:31:16.350]                           restarts <- computeRestarts(cond)
[09:31:16.350]                           for (restart in restarts) {
[09:31:16.350]                             name <- restart$name
[09:31:16.350]                             if (is.null(name)) 
[09:31:16.350]                               next
[09:31:16.350]                             if (!grepl(pattern, name)) 
[09:31:16.350]                               next
[09:31:16.350]                             invokeRestart(restart)
[09:31:16.350]                             muffled <- TRUE
[09:31:16.350]                             break
[09:31:16.350]                           }
[09:31:16.350]                         }
[09:31:16.350]                       }
[09:31:16.350]                       invisible(muffled)
[09:31:16.350]                     }
[09:31:16.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.350]                   }
[09:31:16.350]                 }
[09:31:16.350]             }
[09:31:16.350]         }))
[09:31:16.350]     }, error = function(ex) {
[09:31:16.350]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.350]                 ...future.rng), started = ...future.startTime, 
[09:31:16.350]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.350]             version = "1.8"), class = "FutureResult")
[09:31:16.350]     }, finally = {
[09:31:16.350]         if (!identical(...future.workdir, getwd())) 
[09:31:16.350]             setwd(...future.workdir)
[09:31:16.350]         {
[09:31:16.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.350]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.350]             }
[09:31:16.350]             base::options(...future.oldOptions)
[09:31:16.350]             if (.Platform$OS.type == "windows") {
[09:31:16.350]                 old_names <- names(...future.oldEnvVars)
[09:31:16.350]                 envs <- base::Sys.getenv()
[09:31:16.350]                 names <- names(envs)
[09:31:16.350]                 common <- intersect(names, old_names)
[09:31:16.350]                 added <- setdiff(names, old_names)
[09:31:16.350]                 removed <- setdiff(old_names, names)
[09:31:16.350]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.350]                   envs[common]]
[09:31:16.350]                 NAMES <- toupper(changed)
[09:31:16.350]                 args <- list()
[09:31:16.350]                 for (kk in seq_along(NAMES)) {
[09:31:16.350]                   name <- changed[[kk]]
[09:31:16.350]                   NAME <- NAMES[[kk]]
[09:31:16.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.350]                     next
[09:31:16.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.350]                 }
[09:31:16.350]                 NAMES <- toupper(added)
[09:31:16.350]                 for (kk in seq_along(NAMES)) {
[09:31:16.350]                   name <- added[[kk]]
[09:31:16.350]                   NAME <- NAMES[[kk]]
[09:31:16.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.350]                     next
[09:31:16.350]                   args[[name]] <- ""
[09:31:16.350]                 }
[09:31:16.350]                 NAMES <- toupper(removed)
[09:31:16.350]                 for (kk in seq_along(NAMES)) {
[09:31:16.350]                   name <- removed[[kk]]
[09:31:16.350]                   NAME <- NAMES[[kk]]
[09:31:16.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.350]                     next
[09:31:16.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.350]                 }
[09:31:16.350]                 if (length(args) > 0) 
[09:31:16.350]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.350]             }
[09:31:16.350]             else {
[09:31:16.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.350]             }
[09:31:16.350]             {
[09:31:16.350]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.350]                   0L) {
[09:31:16.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.350]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.350]                   base::options(opts)
[09:31:16.350]                 }
[09:31:16.350]                 {
[09:31:16.350]                   {
[09:31:16.350]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.350]                     NULL
[09:31:16.350]                   }
[09:31:16.350]                   options(future.plan = NULL)
[09:31:16.350]                   if (is.na(NA_character_)) 
[09:31:16.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.350]                     .init = FALSE)
[09:31:16.350]                 }
[09:31:16.350]             }
[09:31:16.350]         }
[09:31:16.350]     })
[09:31:16.350]     if (TRUE) {
[09:31:16.350]         base::sink(type = "output", split = FALSE)
[09:31:16.350]         if (TRUE) {
[09:31:16.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.350]         }
[09:31:16.350]         else {
[09:31:16.350]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.350]         }
[09:31:16.350]         base::close(...future.stdout)
[09:31:16.350]         ...future.stdout <- NULL
[09:31:16.350]     }
[09:31:16.350]     ...future.result$conditions <- ...future.conditions
[09:31:16.350]     ...future.result$finished <- base::Sys.time()
[09:31:16.350]     ...future.result
[09:31:16.350] }
[09:31:16.353] MultisessionFuture started
[09:31:16.353] - Launch lazy future ... done
[09:31:16.353] run() for ‘MultisessionFuture’ ... done
[09:31:16.353] getGlobalsAndPackages() ...
[09:31:16.353] Searching for globals...
[09:31:16.353] 
[09:31:16.353] Searching for globals ... DONE
[09:31:16.353] - globals: [0] <none>
[09:31:16.354] getGlobalsAndPackages() ... DONE
[09:31:16.354] run() for ‘Future’ ...
[09:31:16.354] - state: ‘created’
[09:31:16.354] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.369] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.370]   - Field: ‘node’
[09:31:16.370]   - Field: ‘label’
[09:31:16.370]   - Field: ‘local’
[09:31:16.370]   - Field: ‘owner’
[09:31:16.370]   - Field: ‘envir’
[09:31:16.370]   - Field: ‘workers’
[09:31:16.370]   - Field: ‘packages’
[09:31:16.370]   - Field: ‘gc’
[09:31:16.370]   - Field: ‘conditions’
[09:31:16.371]   - Field: ‘persistent’
[09:31:16.371]   - Field: ‘expr’
[09:31:16.371]   - Field: ‘uuid’
[09:31:16.371]   - Field: ‘seed’
[09:31:16.371]   - Field: ‘version’
[09:31:16.371]   - Field: ‘result’
[09:31:16.371]   - Field: ‘asynchronous’
[09:31:16.371]   - Field: ‘calls’
[09:31:16.371]   - Field: ‘globals’
[09:31:16.371]   - Field: ‘stdout’
[09:31:16.371]   - Field: ‘earlySignal’
[09:31:16.371]   - Field: ‘lazy’
[09:31:16.372]   - Field: ‘state’
[09:31:16.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.372] - Launch lazy future ...
[09:31:16.372] Packages needed by the future expression (n = 0): <none>
[09:31:16.372] Packages needed by future strategies (n = 0): <none>
[09:31:16.373] {
[09:31:16.373]     {
[09:31:16.373]         {
[09:31:16.373]             ...future.startTime <- base::Sys.time()
[09:31:16.373]             {
[09:31:16.373]                 {
[09:31:16.373]                   {
[09:31:16.373]                     {
[09:31:16.373]                       base::local({
[09:31:16.373]                         has_future <- base::requireNamespace("future", 
[09:31:16.373]                           quietly = TRUE)
[09:31:16.373]                         if (has_future) {
[09:31:16.373]                           ns <- base::getNamespace("future")
[09:31:16.373]                           version <- ns[[".package"]][["version"]]
[09:31:16.373]                           if (is.null(version)) 
[09:31:16.373]                             version <- utils::packageVersion("future")
[09:31:16.373]                         }
[09:31:16.373]                         else {
[09:31:16.373]                           version <- NULL
[09:31:16.373]                         }
[09:31:16.373]                         if (!has_future || version < "1.8.0") {
[09:31:16.373]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.373]                             "", base::R.version$version.string), 
[09:31:16.373]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.373]                               "release", "version")], collapse = " "), 
[09:31:16.373]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.373]                             info)
[09:31:16.373]                           info <- base::paste(info, collapse = "; ")
[09:31:16.373]                           if (!has_future) {
[09:31:16.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.373]                               info)
[09:31:16.373]                           }
[09:31:16.373]                           else {
[09:31:16.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.373]                               info, version)
[09:31:16.373]                           }
[09:31:16.373]                           base::stop(msg)
[09:31:16.373]                         }
[09:31:16.373]                       })
[09:31:16.373]                     }
[09:31:16.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.373]                     base::options(mc.cores = 1L)
[09:31:16.373]                   }
[09:31:16.373]                   ...future.strategy.old <- future::plan("list")
[09:31:16.373]                   options(future.plan = NULL)
[09:31:16.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.373]                 }
[09:31:16.373]                 ...future.workdir <- getwd()
[09:31:16.373]             }
[09:31:16.373]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.373]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.373]         }
[09:31:16.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.373]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.373]             base::names(...future.oldOptions))
[09:31:16.373]     }
[09:31:16.373]     if (FALSE) {
[09:31:16.373]     }
[09:31:16.373]     else {
[09:31:16.373]         if (TRUE) {
[09:31:16.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.373]                 open = "w")
[09:31:16.373]         }
[09:31:16.373]         else {
[09:31:16.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.373]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.373]         }
[09:31:16.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.373]             base::sink(type = "output", split = FALSE)
[09:31:16.373]             base::close(...future.stdout)
[09:31:16.373]         }, add = TRUE)
[09:31:16.373]     }
[09:31:16.373]     ...future.frame <- base::sys.nframe()
[09:31:16.373]     ...future.conditions <- base::list()
[09:31:16.373]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.373]     if (FALSE) {
[09:31:16.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.373]     }
[09:31:16.373]     ...future.result <- base::tryCatch({
[09:31:16.373]         base::withCallingHandlers({
[09:31:16.373]             ...future.value <- base::withVisible(base::local({
[09:31:16.373]                 ...future.makeSendCondition <- base::local({
[09:31:16.373]                   sendCondition <- NULL
[09:31:16.373]                   function(frame = 1L) {
[09:31:16.373]                     if (is.function(sendCondition)) 
[09:31:16.373]                       return(sendCondition)
[09:31:16.373]                     ns <- getNamespace("parallel")
[09:31:16.373]                     if (exists("sendData", mode = "function", 
[09:31:16.373]                       envir = ns)) {
[09:31:16.373]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.373]                         envir = ns)
[09:31:16.373]                       envir <- sys.frame(frame)
[09:31:16.373]                       master <- NULL
[09:31:16.373]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.373]                         !identical(envir, emptyenv())) {
[09:31:16.373]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.373]                           inherits = FALSE)) {
[09:31:16.373]                           master <- get("master", mode = "list", 
[09:31:16.373]                             envir = envir, inherits = FALSE)
[09:31:16.373]                           if (inherits(master, c("SOCKnode", 
[09:31:16.373]                             "SOCK0node"))) {
[09:31:16.373]                             sendCondition <<- function(cond) {
[09:31:16.373]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.373]                                 success = TRUE)
[09:31:16.373]                               parallel_sendData(master, data)
[09:31:16.373]                             }
[09:31:16.373]                             return(sendCondition)
[09:31:16.373]                           }
[09:31:16.373]                         }
[09:31:16.373]                         frame <- frame + 1L
[09:31:16.373]                         envir <- sys.frame(frame)
[09:31:16.373]                       }
[09:31:16.373]                     }
[09:31:16.373]                     sendCondition <<- function(cond) NULL
[09:31:16.373]                   }
[09:31:16.373]                 })
[09:31:16.373]                 withCallingHandlers({
[09:31:16.373]                   NULL
[09:31:16.373]                 }, immediateCondition = function(cond) {
[09:31:16.373]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.373]                   sendCondition(cond)
[09:31:16.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.373]                   {
[09:31:16.373]                     inherits <- base::inherits
[09:31:16.373]                     invokeRestart <- base::invokeRestart
[09:31:16.373]                     is.null <- base::is.null
[09:31:16.373]                     muffled <- FALSE
[09:31:16.373]                     if (inherits(cond, "message")) {
[09:31:16.373]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.373]                       if (muffled) 
[09:31:16.373]                         invokeRestart("muffleMessage")
[09:31:16.373]                     }
[09:31:16.373]                     else if (inherits(cond, "warning")) {
[09:31:16.373]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.373]                       if (muffled) 
[09:31:16.373]                         invokeRestart("muffleWarning")
[09:31:16.373]                     }
[09:31:16.373]                     else if (inherits(cond, "condition")) {
[09:31:16.373]                       if (!is.null(pattern)) {
[09:31:16.373]                         computeRestarts <- base::computeRestarts
[09:31:16.373]                         grepl <- base::grepl
[09:31:16.373]                         restarts <- computeRestarts(cond)
[09:31:16.373]                         for (restart in restarts) {
[09:31:16.373]                           name <- restart$name
[09:31:16.373]                           if (is.null(name)) 
[09:31:16.373]                             next
[09:31:16.373]                           if (!grepl(pattern, name)) 
[09:31:16.373]                             next
[09:31:16.373]                           invokeRestart(restart)
[09:31:16.373]                           muffled <- TRUE
[09:31:16.373]                           break
[09:31:16.373]                         }
[09:31:16.373]                       }
[09:31:16.373]                     }
[09:31:16.373]                     invisible(muffled)
[09:31:16.373]                   }
[09:31:16.373]                   muffleCondition(cond)
[09:31:16.373]                 })
[09:31:16.373]             }))
[09:31:16.373]             future::FutureResult(value = ...future.value$value, 
[09:31:16.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.373]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.373]                     ...future.globalenv.names))
[09:31:16.373]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.373]         }, condition = base::local({
[09:31:16.373]             c <- base::c
[09:31:16.373]             inherits <- base::inherits
[09:31:16.373]             invokeRestart <- base::invokeRestart
[09:31:16.373]             length <- base::length
[09:31:16.373]             list <- base::list
[09:31:16.373]             seq.int <- base::seq.int
[09:31:16.373]             signalCondition <- base::signalCondition
[09:31:16.373]             sys.calls <- base::sys.calls
[09:31:16.373]             `[[` <- base::`[[`
[09:31:16.373]             `+` <- base::`+`
[09:31:16.373]             `<<-` <- base::`<<-`
[09:31:16.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.373]                   3L)]
[09:31:16.373]             }
[09:31:16.373]             function(cond) {
[09:31:16.373]                 is_error <- inherits(cond, "error")
[09:31:16.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.373]                   NULL)
[09:31:16.373]                 if (is_error) {
[09:31:16.373]                   sessionInformation <- function() {
[09:31:16.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.373]                       search = base::search(), system = base::Sys.info())
[09:31:16.373]                   }
[09:31:16.373]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.373]                     cond$call), session = sessionInformation(), 
[09:31:16.373]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.373]                   signalCondition(cond)
[09:31:16.373]                 }
[09:31:16.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.373]                 "immediateCondition"))) {
[09:31:16.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.373]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.373]                   if (TRUE && !signal) {
[09:31:16.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.373]                     {
[09:31:16.373]                       inherits <- base::inherits
[09:31:16.373]                       invokeRestart <- base::invokeRestart
[09:31:16.373]                       is.null <- base::is.null
[09:31:16.373]                       muffled <- FALSE
[09:31:16.373]                       if (inherits(cond, "message")) {
[09:31:16.373]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.373]                         if (muffled) 
[09:31:16.373]                           invokeRestart("muffleMessage")
[09:31:16.373]                       }
[09:31:16.373]                       else if (inherits(cond, "warning")) {
[09:31:16.373]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.373]                         if (muffled) 
[09:31:16.373]                           invokeRestart("muffleWarning")
[09:31:16.373]                       }
[09:31:16.373]                       else if (inherits(cond, "condition")) {
[09:31:16.373]                         if (!is.null(pattern)) {
[09:31:16.373]                           computeRestarts <- base::computeRestarts
[09:31:16.373]                           grepl <- base::grepl
[09:31:16.373]                           restarts <- computeRestarts(cond)
[09:31:16.373]                           for (restart in restarts) {
[09:31:16.373]                             name <- restart$name
[09:31:16.373]                             if (is.null(name)) 
[09:31:16.373]                               next
[09:31:16.373]                             if (!grepl(pattern, name)) 
[09:31:16.373]                               next
[09:31:16.373]                             invokeRestart(restart)
[09:31:16.373]                             muffled <- TRUE
[09:31:16.373]                             break
[09:31:16.373]                           }
[09:31:16.373]                         }
[09:31:16.373]                       }
[09:31:16.373]                       invisible(muffled)
[09:31:16.373]                     }
[09:31:16.373]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.373]                   }
[09:31:16.373]                 }
[09:31:16.373]                 else {
[09:31:16.373]                   if (TRUE) {
[09:31:16.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.373]                     {
[09:31:16.373]                       inherits <- base::inherits
[09:31:16.373]                       invokeRestart <- base::invokeRestart
[09:31:16.373]                       is.null <- base::is.null
[09:31:16.373]                       muffled <- FALSE
[09:31:16.373]                       if (inherits(cond, "message")) {
[09:31:16.373]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.373]                         if (muffled) 
[09:31:16.373]                           invokeRestart("muffleMessage")
[09:31:16.373]                       }
[09:31:16.373]                       else if (inherits(cond, "warning")) {
[09:31:16.373]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.373]                         if (muffled) 
[09:31:16.373]                           invokeRestart("muffleWarning")
[09:31:16.373]                       }
[09:31:16.373]                       else if (inherits(cond, "condition")) {
[09:31:16.373]                         if (!is.null(pattern)) {
[09:31:16.373]                           computeRestarts <- base::computeRestarts
[09:31:16.373]                           grepl <- base::grepl
[09:31:16.373]                           restarts <- computeRestarts(cond)
[09:31:16.373]                           for (restart in restarts) {
[09:31:16.373]                             name <- restart$name
[09:31:16.373]                             if (is.null(name)) 
[09:31:16.373]                               next
[09:31:16.373]                             if (!grepl(pattern, name)) 
[09:31:16.373]                               next
[09:31:16.373]                             invokeRestart(restart)
[09:31:16.373]                             muffled <- TRUE
[09:31:16.373]                             break
[09:31:16.373]                           }
[09:31:16.373]                         }
[09:31:16.373]                       }
[09:31:16.373]                       invisible(muffled)
[09:31:16.373]                     }
[09:31:16.373]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.373]                   }
[09:31:16.373]                 }
[09:31:16.373]             }
[09:31:16.373]         }))
[09:31:16.373]     }, error = function(ex) {
[09:31:16.373]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.373]                 ...future.rng), started = ...future.startTime, 
[09:31:16.373]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.373]             version = "1.8"), class = "FutureResult")
[09:31:16.373]     }, finally = {
[09:31:16.373]         if (!identical(...future.workdir, getwd())) 
[09:31:16.373]             setwd(...future.workdir)
[09:31:16.373]         {
[09:31:16.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.373]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.373]             }
[09:31:16.373]             base::options(...future.oldOptions)
[09:31:16.373]             if (.Platform$OS.type == "windows") {
[09:31:16.373]                 old_names <- names(...future.oldEnvVars)
[09:31:16.373]                 envs <- base::Sys.getenv()
[09:31:16.373]                 names <- names(envs)
[09:31:16.373]                 common <- intersect(names, old_names)
[09:31:16.373]                 added <- setdiff(names, old_names)
[09:31:16.373]                 removed <- setdiff(old_names, names)
[09:31:16.373]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.373]                   envs[common]]
[09:31:16.373]                 NAMES <- toupper(changed)
[09:31:16.373]                 args <- list()
[09:31:16.373]                 for (kk in seq_along(NAMES)) {
[09:31:16.373]                   name <- changed[[kk]]
[09:31:16.373]                   NAME <- NAMES[[kk]]
[09:31:16.373]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.373]                     next
[09:31:16.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.373]                 }
[09:31:16.373]                 NAMES <- toupper(added)
[09:31:16.373]                 for (kk in seq_along(NAMES)) {
[09:31:16.373]                   name <- added[[kk]]
[09:31:16.373]                   NAME <- NAMES[[kk]]
[09:31:16.373]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.373]                     next
[09:31:16.373]                   args[[name]] <- ""
[09:31:16.373]                 }
[09:31:16.373]                 NAMES <- toupper(removed)
[09:31:16.373]                 for (kk in seq_along(NAMES)) {
[09:31:16.373]                   name <- removed[[kk]]
[09:31:16.373]                   NAME <- NAMES[[kk]]
[09:31:16.373]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.373]                     next
[09:31:16.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.373]                 }
[09:31:16.373]                 if (length(args) > 0) 
[09:31:16.373]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.373]             }
[09:31:16.373]             else {
[09:31:16.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.373]             }
[09:31:16.373]             {
[09:31:16.373]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.373]                   0L) {
[09:31:16.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.373]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.373]                   base::options(opts)
[09:31:16.373]                 }
[09:31:16.373]                 {
[09:31:16.373]                   {
[09:31:16.373]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.373]                     NULL
[09:31:16.373]                   }
[09:31:16.373]                   options(future.plan = NULL)
[09:31:16.373]                   if (is.na(NA_character_)) 
[09:31:16.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.373]                     .init = FALSE)
[09:31:16.373]                 }
[09:31:16.373]             }
[09:31:16.373]         }
[09:31:16.373]     })
[09:31:16.373]     if (TRUE) {
[09:31:16.373]         base::sink(type = "output", split = FALSE)
[09:31:16.373]         if (TRUE) {
[09:31:16.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.373]         }
[09:31:16.373]         else {
[09:31:16.373]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.373]         }
[09:31:16.373]         base::close(...future.stdout)
[09:31:16.373]         ...future.stdout <- NULL
[09:31:16.373]     }
[09:31:16.373]     ...future.result$conditions <- ...future.conditions
[09:31:16.373]     ...future.result$finished <- base::Sys.time()
[09:31:16.373]     ...future.result
[09:31:16.373] }
[09:31:16.376] MultisessionFuture started
[09:31:16.376] - Launch lazy future ... done
[09:31:16.376] run() for ‘MultisessionFuture’ ... done
[09:31:16.376] getGlobalsAndPackages() ...
[09:31:16.376] Searching for globals...
[09:31:16.377] - globals found: [1] ‘{’
[09:31:16.377] Searching for globals ... DONE
[09:31:16.377] Resolving globals: FALSE
[09:31:16.377] 
[09:31:16.377] 
[09:31:16.377] getGlobalsAndPackages() ... DONE
[09:31:16.378] run() for ‘Future’ ...
[09:31:16.378] - state: ‘created’
[09:31:16.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.391] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.391]   - Field: ‘node’
[09:31:16.392]   - Field: ‘label’
[09:31:16.392]   - Field: ‘local’
[09:31:16.392]   - Field: ‘owner’
[09:31:16.392]   - Field: ‘envir’
[09:31:16.392]   - Field: ‘workers’
[09:31:16.392]   - Field: ‘packages’
[09:31:16.392]   - Field: ‘gc’
[09:31:16.392]   - Field: ‘conditions’
[09:31:16.392]   - Field: ‘persistent’
[09:31:16.392]   - Field: ‘expr’
[09:31:16.393]   - Field: ‘uuid’
[09:31:16.393]   - Field: ‘seed’
[09:31:16.393]   - Field: ‘version’
[09:31:16.393]   - Field: ‘result’
[09:31:16.393]   - Field: ‘asynchronous’
[09:31:16.393]   - Field: ‘calls’
[09:31:16.393]   - Field: ‘globals’
[09:31:16.393]   - Field: ‘stdout’
[09:31:16.393]   - Field: ‘earlySignal’
[09:31:16.393]   - Field: ‘lazy’
[09:31:16.393]   - Field: ‘state’
[09:31:16.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.394] - Launch lazy future ...
[09:31:16.394] Packages needed by the future expression (n = 0): <none>
[09:31:16.394] Packages needed by future strategies (n = 0): <none>
[09:31:16.394] {
[09:31:16.394]     {
[09:31:16.394]         {
[09:31:16.394]             ...future.startTime <- base::Sys.time()
[09:31:16.394]             {
[09:31:16.394]                 {
[09:31:16.394]                   {
[09:31:16.394]                     {
[09:31:16.394]                       base::local({
[09:31:16.394]                         has_future <- base::requireNamespace("future", 
[09:31:16.394]                           quietly = TRUE)
[09:31:16.394]                         if (has_future) {
[09:31:16.394]                           ns <- base::getNamespace("future")
[09:31:16.394]                           version <- ns[[".package"]][["version"]]
[09:31:16.394]                           if (is.null(version)) 
[09:31:16.394]                             version <- utils::packageVersion("future")
[09:31:16.394]                         }
[09:31:16.394]                         else {
[09:31:16.394]                           version <- NULL
[09:31:16.394]                         }
[09:31:16.394]                         if (!has_future || version < "1.8.0") {
[09:31:16.394]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.394]                             "", base::R.version$version.string), 
[09:31:16.394]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.394]                               "release", "version")], collapse = " "), 
[09:31:16.394]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.394]                             info)
[09:31:16.394]                           info <- base::paste(info, collapse = "; ")
[09:31:16.394]                           if (!has_future) {
[09:31:16.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.394]                               info)
[09:31:16.394]                           }
[09:31:16.394]                           else {
[09:31:16.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.394]                               info, version)
[09:31:16.394]                           }
[09:31:16.394]                           base::stop(msg)
[09:31:16.394]                         }
[09:31:16.394]                       })
[09:31:16.394]                     }
[09:31:16.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.394]                     base::options(mc.cores = 1L)
[09:31:16.394]                   }
[09:31:16.394]                   ...future.strategy.old <- future::plan("list")
[09:31:16.394]                   options(future.plan = NULL)
[09:31:16.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.394]                 }
[09:31:16.394]                 ...future.workdir <- getwd()
[09:31:16.394]             }
[09:31:16.394]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.394]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.394]         }
[09:31:16.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.394]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.394]             base::names(...future.oldOptions))
[09:31:16.394]     }
[09:31:16.394]     if (FALSE) {
[09:31:16.394]     }
[09:31:16.394]     else {
[09:31:16.394]         if (TRUE) {
[09:31:16.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.394]                 open = "w")
[09:31:16.394]         }
[09:31:16.394]         else {
[09:31:16.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.394]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.394]         }
[09:31:16.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.394]             base::sink(type = "output", split = FALSE)
[09:31:16.394]             base::close(...future.stdout)
[09:31:16.394]         }, add = TRUE)
[09:31:16.394]     }
[09:31:16.394]     ...future.frame <- base::sys.nframe()
[09:31:16.394]     ...future.conditions <- base::list()
[09:31:16.394]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.394]     if (FALSE) {
[09:31:16.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.394]     }
[09:31:16.394]     ...future.result <- base::tryCatch({
[09:31:16.394]         base::withCallingHandlers({
[09:31:16.394]             ...future.value <- base::withVisible(base::local({
[09:31:16.394]                 ...future.makeSendCondition <- base::local({
[09:31:16.394]                   sendCondition <- NULL
[09:31:16.394]                   function(frame = 1L) {
[09:31:16.394]                     if (is.function(sendCondition)) 
[09:31:16.394]                       return(sendCondition)
[09:31:16.394]                     ns <- getNamespace("parallel")
[09:31:16.394]                     if (exists("sendData", mode = "function", 
[09:31:16.394]                       envir = ns)) {
[09:31:16.394]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.394]                         envir = ns)
[09:31:16.394]                       envir <- sys.frame(frame)
[09:31:16.394]                       master <- NULL
[09:31:16.394]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.394]                         !identical(envir, emptyenv())) {
[09:31:16.394]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.394]                           inherits = FALSE)) {
[09:31:16.394]                           master <- get("master", mode = "list", 
[09:31:16.394]                             envir = envir, inherits = FALSE)
[09:31:16.394]                           if (inherits(master, c("SOCKnode", 
[09:31:16.394]                             "SOCK0node"))) {
[09:31:16.394]                             sendCondition <<- function(cond) {
[09:31:16.394]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.394]                                 success = TRUE)
[09:31:16.394]                               parallel_sendData(master, data)
[09:31:16.394]                             }
[09:31:16.394]                             return(sendCondition)
[09:31:16.394]                           }
[09:31:16.394]                         }
[09:31:16.394]                         frame <- frame + 1L
[09:31:16.394]                         envir <- sys.frame(frame)
[09:31:16.394]                       }
[09:31:16.394]                     }
[09:31:16.394]                     sendCondition <<- function(cond) NULL
[09:31:16.394]                   }
[09:31:16.394]                 })
[09:31:16.394]                 withCallingHandlers({
[09:31:16.394]                   {
[09:31:16.394]                     4
[09:31:16.394]                   }
[09:31:16.394]                 }, immediateCondition = function(cond) {
[09:31:16.394]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.394]                   sendCondition(cond)
[09:31:16.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.394]                   {
[09:31:16.394]                     inherits <- base::inherits
[09:31:16.394]                     invokeRestart <- base::invokeRestart
[09:31:16.394]                     is.null <- base::is.null
[09:31:16.394]                     muffled <- FALSE
[09:31:16.394]                     if (inherits(cond, "message")) {
[09:31:16.394]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.394]                       if (muffled) 
[09:31:16.394]                         invokeRestart("muffleMessage")
[09:31:16.394]                     }
[09:31:16.394]                     else if (inherits(cond, "warning")) {
[09:31:16.394]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.394]                       if (muffled) 
[09:31:16.394]                         invokeRestart("muffleWarning")
[09:31:16.394]                     }
[09:31:16.394]                     else if (inherits(cond, "condition")) {
[09:31:16.394]                       if (!is.null(pattern)) {
[09:31:16.394]                         computeRestarts <- base::computeRestarts
[09:31:16.394]                         grepl <- base::grepl
[09:31:16.394]                         restarts <- computeRestarts(cond)
[09:31:16.394]                         for (restart in restarts) {
[09:31:16.394]                           name <- restart$name
[09:31:16.394]                           if (is.null(name)) 
[09:31:16.394]                             next
[09:31:16.394]                           if (!grepl(pattern, name)) 
[09:31:16.394]                             next
[09:31:16.394]                           invokeRestart(restart)
[09:31:16.394]                           muffled <- TRUE
[09:31:16.394]                           break
[09:31:16.394]                         }
[09:31:16.394]                       }
[09:31:16.394]                     }
[09:31:16.394]                     invisible(muffled)
[09:31:16.394]                   }
[09:31:16.394]                   muffleCondition(cond)
[09:31:16.394]                 })
[09:31:16.394]             }))
[09:31:16.394]             future::FutureResult(value = ...future.value$value, 
[09:31:16.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.394]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.394]                     ...future.globalenv.names))
[09:31:16.394]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.394]         }, condition = base::local({
[09:31:16.394]             c <- base::c
[09:31:16.394]             inherits <- base::inherits
[09:31:16.394]             invokeRestart <- base::invokeRestart
[09:31:16.394]             length <- base::length
[09:31:16.394]             list <- base::list
[09:31:16.394]             seq.int <- base::seq.int
[09:31:16.394]             signalCondition <- base::signalCondition
[09:31:16.394]             sys.calls <- base::sys.calls
[09:31:16.394]             `[[` <- base::`[[`
[09:31:16.394]             `+` <- base::`+`
[09:31:16.394]             `<<-` <- base::`<<-`
[09:31:16.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.394]                   3L)]
[09:31:16.394]             }
[09:31:16.394]             function(cond) {
[09:31:16.394]                 is_error <- inherits(cond, "error")
[09:31:16.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.394]                   NULL)
[09:31:16.394]                 if (is_error) {
[09:31:16.394]                   sessionInformation <- function() {
[09:31:16.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.394]                       search = base::search(), system = base::Sys.info())
[09:31:16.394]                   }
[09:31:16.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.394]                     cond$call), session = sessionInformation(), 
[09:31:16.394]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.394]                   signalCondition(cond)
[09:31:16.394]                 }
[09:31:16.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.394]                 "immediateCondition"))) {
[09:31:16.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.394]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.394]                   if (TRUE && !signal) {
[09:31:16.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.394]                     {
[09:31:16.394]                       inherits <- base::inherits
[09:31:16.394]                       invokeRestart <- base::invokeRestart
[09:31:16.394]                       is.null <- base::is.null
[09:31:16.394]                       muffled <- FALSE
[09:31:16.394]                       if (inherits(cond, "message")) {
[09:31:16.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.394]                         if (muffled) 
[09:31:16.394]                           invokeRestart("muffleMessage")
[09:31:16.394]                       }
[09:31:16.394]                       else if (inherits(cond, "warning")) {
[09:31:16.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.394]                         if (muffled) 
[09:31:16.394]                           invokeRestart("muffleWarning")
[09:31:16.394]                       }
[09:31:16.394]                       else if (inherits(cond, "condition")) {
[09:31:16.394]                         if (!is.null(pattern)) {
[09:31:16.394]                           computeRestarts <- base::computeRestarts
[09:31:16.394]                           grepl <- base::grepl
[09:31:16.394]                           restarts <- computeRestarts(cond)
[09:31:16.394]                           for (restart in restarts) {
[09:31:16.394]                             name <- restart$name
[09:31:16.394]                             if (is.null(name)) 
[09:31:16.394]                               next
[09:31:16.394]                             if (!grepl(pattern, name)) 
[09:31:16.394]                               next
[09:31:16.394]                             invokeRestart(restart)
[09:31:16.394]                             muffled <- TRUE
[09:31:16.394]                             break
[09:31:16.394]                           }
[09:31:16.394]                         }
[09:31:16.394]                       }
[09:31:16.394]                       invisible(muffled)
[09:31:16.394]                     }
[09:31:16.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.394]                   }
[09:31:16.394]                 }
[09:31:16.394]                 else {
[09:31:16.394]                   if (TRUE) {
[09:31:16.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.394]                     {
[09:31:16.394]                       inherits <- base::inherits
[09:31:16.394]                       invokeRestart <- base::invokeRestart
[09:31:16.394]                       is.null <- base::is.null
[09:31:16.394]                       muffled <- FALSE
[09:31:16.394]                       if (inherits(cond, "message")) {
[09:31:16.394]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.394]                         if (muffled) 
[09:31:16.394]                           invokeRestart("muffleMessage")
[09:31:16.394]                       }
[09:31:16.394]                       else if (inherits(cond, "warning")) {
[09:31:16.394]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.394]                         if (muffled) 
[09:31:16.394]                           invokeRestart("muffleWarning")
[09:31:16.394]                       }
[09:31:16.394]                       else if (inherits(cond, "condition")) {
[09:31:16.394]                         if (!is.null(pattern)) {
[09:31:16.394]                           computeRestarts <- base::computeRestarts
[09:31:16.394]                           grepl <- base::grepl
[09:31:16.394]                           restarts <- computeRestarts(cond)
[09:31:16.394]                           for (restart in restarts) {
[09:31:16.394]                             name <- restart$name
[09:31:16.394]                             if (is.null(name)) 
[09:31:16.394]                               next
[09:31:16.394]                             if (!grepl(pattern, name)) 
[09:31:16.394]                               next
[09:31:16.394]                             invokeRestart(restart)
[09:31:16.394]                             muffled <- TRUE
[09:31:16.394]                             break
[09:31:16.394]                           }
[09:31:16.394]                         }
[09:31:16.394]                       }
[09:31:16.394]                       invisible(muffled)
[09:31:16.394]                     }
[09:31:16.394]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.394]                   }
[09:31:16.394]                 }
[09:31:16.394]             }
[09:31:16.394]         }))
[09:31:16.394]     }, error = function(ex) {
[09:31:16.394]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.394]                 ...future.rng), started = ...future.startTime, 
[09:31:16.394]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.394]             version = "1.8"), class = "FutureResult")
[09:31:16.394]     }, finally = {
[09:31:16.394]         if (!identical(...future.workdir, getwd())) 
[09:31:16.394]             setwd(...future.workdir)
[09:31:16.394]         {
[09:31:16.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.394]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.394]             }
[09:31:16.394]             base::options(...future.oldOptions)
[09:31:16.394]             if (.Platform$OS.type == "windows") {
[09:31:16.394]                 old_names <- names(...future.oldEnvVars)
[09:31:16.394]                 envs <- base::Sys.getenv()
[09:31:16.394]                 names <- names(envs)
[09:31:16.394]                 common <- intersect(names, old_names)
[09:31:16.394]                 added <- setdiff(names, old_names)
[09:31:16.394]                 removed <- setdiff(old_names, names)
[09:31:16.394]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.394]                   envs[common]]
[09:31:16.394]                 NAMES <- toupper(changed)
[09:31:16.394]                 args <- list()
[09:31:16.394]                 for (kk in seq_along(NAMES)) {
[09:31:16.394]                   name <- changed[[kk]]
[09:31:16.394]                   NAME <- NAMES[[kk]]
[09:31:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.394]                     next
[09:31:16.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.394]                 }
[09:31:16.394]                 NAMES <- toupper(added)
[09:31:16.394]                 for (kk in seq_along(NAMES)) {
[09:31:16.394]                   name <- added[[kk]]
[09:31:16.394]                   NAME <- NAMES[[kk]]
[09:31:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.394]                     next
[09:31:16.394]                   args[[name]] <- ""
[09:31:16.394]                 }
[09:31:16.394]                 NAMES <- toupper(removed)
[09:31:16.394]                 for (kk in seq_along(NAMES)) {
[09:31:16.394]                   name <- removed[[kk]]
[09:31:16.394]                   NAME <- NAMES[[kk]]
[09:31:16.394]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.394]                     next
[09:31:16.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.394]                 }
[09:31:16.394]                 if (length(args) > 0) 
[09:31:16.394]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.394]             }
[09:31:16.394]             else {
[09:31:16.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.394]             }
[09:31:16.394]             {
[09:31:16.394]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.394]                   0L) {
[09:31:16.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.394]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.394]                   base::options(opts)
[09:31:16.394]                 }
[09:31:16.394]                 {
[09:31:16.394]                   {
[09:31:16.394]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.394]                     NULL
[09:31:16.394]                   }
[09:31:16.394]                   options(future.plan = NULL)
[09:31:16.394]                   if (is.na(NA_character_)) 
[09:31:16.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.394]                     .init = FALSE)
[09:31:16.394]                 }
[09:31:16.394]             }
[09:31:16.394]         }
[09:31:16.394]     })
[09:31:16.394]     if (TRUE) {
[09:31:16.394]         base::sink(type = "output", split = FALSE)
[09:31:16.394]         if (TRUE) {
[09:31:16.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.394]         }
[09:31:16.394]         else {
[09:31:16.394]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.394]         }
[09:31:16.394]         base::close(...future.stdout)
[09:31:16.394]         ...future.stdout <- NULL
[09:31:16.394]     }
[09:31:16.394]     ...future.result$conditions <- ...future.conditions
[09:31:16.394]     ...future.result$finished <- base::Sys.time()
[09:31:16.394]     ...future.result
[09:31:16.394] }
[09:31:16.396] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:16.407] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.407] - Validating connection of MultisessionFuture
[09:31:16.408] - received message: FutureResult
[09:31:16.408] - Received FutureResult
[09:31:16.408] - Erased future from FutureRegistry
[09:31:16.408] result() for ClusterFuture ...
[09:31:16.408] - result already collected: FutureResult
[09:31:16.408] result() for ClusterFuture ... done
[09:31:16.408] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.408] result() for ClusterFuture ...
[09:31:16.408] - result already collected: FutureResult
[09:31:16.408] result() for ClusterFuture ... done
[09:31:16.409] result() for ClusterFuture ...
[09:31:16.409] - result already collected: FutureResult
[09:31:16.409] result() for ClusterFuture ... done
[09:31:16.410] MultisessionFuture started
[09:31:16.410] - Launch lazy future ... done
[09:31:16.410] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cab4a798> 
Classes 'listenv', 'environment' <environment: 0x55a3cc1e3ab8> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:16.414] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.414] - Validating connection of MultisessionFuture
[09:31:16.414] - received message: FutureResult
[09:31:16.414] - Received FutureResult
[09:31:16.414] - Erased future from FutureRegistry
[09:31:16.414] result() for ClusterFuture ...
[09:31:16.414] - result already collected: FutureResult
[09:31:16.415] result() for ClusterFuture ... done
[09:31:16.415] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.415] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.415] - Validating connection of MultisessionFuture
[09:31:16.415] - received message: FutureResult
[09:31:16.415] - Received FutureResult
[09:31:16.415] - Erased future from FutureRegistry
[09:31:16.416] result() for ClusterFuture ...
[09:31:16.416] - result already collected: FutureResult
[09:31:16.416] result() for ClusterFuture ... done
[09:31:16.416] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:16.418] resolve() on list environment ...
[09:31:16.418]  recursive: 0
[09:31:16.419]  length: 6
[09:31:16.419]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:16.420] signalConditionsASAP(numeric, pos=1) ...
[09:31:16.420] - nx: 6
[09:31:16.420] - relay: TRUE
[09:31:16.420] - stdout: TRUE
[09:31:16.420] - signal: TRUE
[09:31:16.420] - resignal: FALSE
[09:31:16.420] - force: TRUE
[09:31:16.420] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.420] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.420]  - until=2
[09:31:16.420]  - relaying element #2
[09:31:16.420] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.421] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.421] signalConditionsASAP(NULL, pos=1) ... done
[09:31:16.421]  length: 5 (resolved future 1)
[09:31:16.421] Future #2
[09:31:16.421] result() for ClusterFuture ...
[09:31:16.421] - result already collected: FutureResult
[09:31:16.421] result() for ClusterFuture ... done
[09:31:16.421] result() for ClusterFuture ...
[09:31:16.421] - result already collected: FutureResult
[09:31:16.421] result() for ClusterFuture ... done
[09:31:16.421] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:16.422] - nx: 6
[09:31:16.422] - relay: TRUE
[09:31:16.422] - stdout: TRUE
[09:31:16.422] - signal: TRUE
[09:31:16.422] - resignal: FALSE
[09:31:16.422] - force: TRUE
[09:31:16.422] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.422] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.422]  - until=2
[09:31:16.422]  - relaying element #2
[09:31:16.422] result() for ClusterFuture ...
[09:31:16.422] - result already collected: FutureResult
[09:31:16.423] result() for ClusterFuture ... done
[09:31:16.423] result() for ClusterFuture ...
[09:31:16.423] - result already collected: FutureResult
[09:31:16.423] result() for ClusterFuture ... done
[09:31:16.423] result() for ClusterFuture ...
[09:31:16.423] - result already collected: FutureResult
[09:31:16.423] result() for ClusterFuture ... done
[09:31:16.423] result() for ClusterFuture ...
[09:31:16.423] - result already collected: FutureResult
[09:31:16.423] result() for ClusterFuture ... done
[09:31:16.423] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.423] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.424] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:16.424]  length: 4 (resolved future 2)
[09:31:16.424] Future #3
[09:31:16.424] result() for ClusterFuture ...
[09:31:16.424] - result already collected: FutureResult
[09:31:16.424] result() for ClusterFuture ... done
[09:31:16.424] result() for ClusterFuture ...
[09:31:16.424] - result already collected: FutureResult
[09:31:16.424] result() for ClusterFuture ... done
[09:31:16.424] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:16.425] - nx: 6
[09:31:16.425] - relay: TRUE
[09:31:16.425] - stdout: TRUE
[09:31:16.425] - signal: TRUE
[09:31:16.425] - resignal: FALSE
[09:31:16.425] - force: TRUE
[09:31:16.425] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.425] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.425]  - until=3
[09:31:16.425]  - relaying element #3
[09:31:16.425] result() for ClusterFuture ...
[09:31:16.425] - result already collected: FutureResult
[09:31:16.426] result() for ClusterFuture ... done
[09:31:16.426] result() for ClusterFuture ...
[09:31:16.426] - result already collected: FutureResult
[09:31:16.426] result() for ClusterFuture ... done
[09:31:16.426] result() for ClusterFuture ...
[09:31:16.426] - result already collected: FutureResult
[09:31:16.426] result() for ClusterFuture ... done
[09:31:16.426] result() for ClusterFuture ...
[09:31:16.426] - result already collected: FutureResult
[09:31:16.426] result() for ClusterFuture ... done
[09:31:16.426] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.426] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.427] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:16.427]  length: 3 (resolved future 3)
[09:31:16.427] Future #4
[09:31:16.427] result() for ClusterFuture ...
[09:31:16.427] - result already collected: FutureResult
[09:31:16.427] result() for ClusterFuture ... done
[09:31:16.427] result() for ClusterFuture ...
[09:31:16.427] - result already collected: FutureResult
[09:31:16.427] result() for ClusterFuture ... done
[09:31:16.427] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:16.427] - nx: 6
[09:31:16.428] - relay: TRUE
[09:31:16.428] - stdout: TRUE
[09:31:16.428] - signal: TRUE
[09:31:16.428] - resignal: FALSE
[09:31:16.428] - force: TRUE
[09:31:16.428] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.428] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.428]  - until=4
[09:31:16.428]  - relaying element #4
[09:31:16.428] result() for ClusterFuture ...
[09:31:16.428] - result already collected: FutureResult
[09:31:16.428] result() for ClusterFuture ... done
[09:31:16.429] result() for ClusterFuture ...
[09:31:16.429] - result already collected: FutureResult
[09:31:16.429] result() for ClusterFuture ... done
[09:31:16.429] result() for ClusterFuture ...
[09:31:16.429] - result already collected: FutureResult
[09:31:16.429] result() for ClusterFuture ... done
[09:31:16.429] result() for ClusterFuture ...
[09:31:16.429] - result already collected: FutureResult
[09:31:16.429] result() for ClusterFuture ... done
[09:31:16.429] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.429] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.429] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:16.430]  length: 2 (resolved future 4)
[09:31:16.430] signalConditionsASAP(NULL, pos=5) ...
[09:31:16.430] - nx: 6
[09:31:16.430] - relay: TRUE
[09:31:16.430] - stdout: TRUE
[09:31:16.430] - signal: TRUE
[09:31:16.430] - resignal: FALSE
[09:31:16.430] - force: TRUE
[09:31:16.430] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.430] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.430]  - until=6
[09:31:16.430]  - relaying element #6
[09:31:16.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.431] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.431] signalConditionsASAP(NULL, pos=5) ... done
[09:31:16.431]  length: 1 (resolved future 5)
[09:31:16.431] signalConditionsASAP(numeric, pos=6) ...
[09:31:16.431] - nx: 6
[09:31:16.431] - relay: TRUE
[09:31:16.431] - stdout: TRUE
[09:31:16.431] - signal: TRUE
[09:31:16.431] - resignal: FALSE
[09:31:16.431] - force: TRUE
[09:31:16.431] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.432] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.434]  - until=6
[09:31:16.435] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.435] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.435] signalConditionsASAP(numeric, pos=6) ... done
[09:31:16.435]  length: 0 (resolved future 6)
[09:31:16.435] Relaying remaining futures
[09:31:16.435] signalConditionsASAP(NULL, pos=0) ...
[09:31:16.435] - nx: 6
[09:31:16.435] - relay: TRUE
[09:31:16.435] - stdout: TRUE
[09:31:16.435] - signal: TRUE
[09:31:16.435] - resignal: FALSE
[09:31:16.436] - force: TRUE
[09:31:16.436] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.436] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:16.436] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.436] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.436] signalConditionsASAP(NULL, pos=0) ... done
[09:31:16.436] resolve() on list environment ... DONE
[09:31:16.436] result() for ClusterFuture ...
[09:31:16.436] - result already collected: FutureResult
[09:31:16.436] result() for ClusterFuture ... done
[09:31:16.437] result() for ClusterFuture ...
[09:31:16.437] - result already collected: FutureResult
[09:31:16.437] result() for ClusterFuture ... done
[09:31:16.437] result() for ClusterFuture ...
[09:31:16.437] - result already collected: FutureResult
[09:31:16.437] result() for ClusterFuture ... done
[09:31:16.437] result() for ClusterFuture ...
[09:31:16.437] - result already collected: FutureResult
[09:31:16.437] result() for ClusterFuture ... done
[09:31:16.437] result() for ClusterFuture ...
[09:31:16.438] - result already collected: FutureResult
[09:31:16.438] result() for ClusterFuture ... done
[09:31:16.438] result() for ClusterFuture ...
[09:31:16.438] - result already collected: FutureResult
[09:31:16.438] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cc723790> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[09:31:16.440] getGlobalsAndPackages() ...
[09:31:16.440] Searching for globals...
[09:31:16.440] 
[09:31:16.440] Searching for globals ... DONE
[09:31:16.440] - globals: [0] <none>
[09:31:16.440] getGlobalsAndPackages() ... DONE
[09:31:16.441] run() for ‘Future’ ...
[09:31:16.441] - state: ‘created’
[09:31:16.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.455]   - Field: ‘node’
[09:31:16.455]   - Field: ‘label’
[09:31:16.455]   - Field: ‘local’
[09:31:16.455]   - Field: ‘owner’
[09:31:16.455]   - Field: ‘envir’
[09:31:16.455]   - Field: ‘workers’
[09:31:16.455]   - Field: ‘packages’
[09:31:16.455]   - Field: ‘gc’
[09:31:16.456]   - Field: ‘conditions’
[09:31:16.456]   - Field: ‘persistent’
[09:31:16.456]   - Field: ‘expr’
[09:31:16.456]   - Field: ‘uuid’
[09:31:16.456]   - Field: ‘seed’
[09:31:16.456]   - Field: ‘version’
[09:31:16.456]   - Field: ‘result’
[09:31:16.456]   - Field: ‘asynchronous’
[09:31:16.456]   - Field: ‘calls’
[09:31:16.456]   - Field: ‘globals’
[09:31:16.457]   - Field: ‘stdout’
[09:31:16.457]   - Field: ‘earlySignal’
[09:31:16.457]   - Field: ‘lazy’
[09:31:16.457]   - Field: ‘state’
[09:31:16.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.457] - Launch lazy future ...
[09:31:16.457] Packages needed by the future expression (n = 0): <none>
[09:31:16.457] Packages needed by future strategies (n = 0): <none>
[09:31:16.458] {
[09:31:16.458]     {
[09:31:16.458]         {
[09:31:16.458]             ...future.startTime <- base::Sys.time()
[09:31:16.458]             {
[09:31:16.458]                 {
[09:31:16.458]                   {
[09:31:16.458]                     {
[09:31:16.458]                       base::local({
[09:31:16.458]                         has_future <- base::requireNamespace("future", 
[09:31:16.458]                           quietly = TRUE)
[09:31:16.458]                         if (has_future) {
[09:31:16.458]                           ns <- base::getNamespace("future")
[09:31:16.458]                           version <- ns[[".package"]][["version"]]
[09:31:16.458]                           if (is.null(version)) 
[09:31:16.458]                             version <- utils::packageVersion("future")
[09:31:16.458]                         }
[09:31:16.458]                         else {
[09:31:16.458]                           version <- NULL
[09:31:16.458]                         }
[09:31:16.458]                         if (!has_future || version < "1.8.0") {
[09:31:16.458]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.458]                             "", base::R.version$version.string), 
[09:31:16.458]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.458]                               "release", "version")], collapse = " "), 
[09:31:16.458]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.458]                             info)
[09:31:16.458]                           info <- base::paste(info, collapse = "; ")
[09:31:16.458]                           if (!has_future) {
[09:31:16.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.458]                               info)
[09:31:16.458]                           }
[09:31:16.458]                           else {
[09:31:16.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.458]                               info, version)
[09:31:16.458]                           }
[09:31:16.458]                           base::stop(msg)
[09:31:16.458]                         }
[09:31:16.458]                       })
[09:31:16.458]                     }
[09:31:16.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.458]                     base::options(mc.cores = 1L)
[09:31:16.458]                   }
[09:31:16.458]                   ...future.strategy.old <- future::plan("list")
[09:31:16.458]                   options(future.plan = NULL)
[09:31:16.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.458]                 }
[09:31:16.458]                 ...future.workdir <- getwd()
[09:31:16.458]             }
[09:31:16.458]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.458]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.458]         }
[09:31:16.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.458]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.458]             base::names(...future.oldOptions))
[09:31:16.458]     }
[09:31:16.458]     if (FALSE) {
[09:31:16.458]     }
[09:31:16.458]     else {
[09:31:16.458]         if (TRUE) {
[09:31:16.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.458]                 open = "w")
[09:31:16.458]         }
[09:31:16.458]         else {
[09:31:16.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.458]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.458]         }
[09:31:16.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.458]             base::sink(type = "output", split = FALSE)
[09:31:16.458]             base::close(...future.stdout)
[09:31:16.458]         }, add = TRUE)
[09:31:16.458]     }
[09:31:16.458]     ...future.frame <- base::sys.nframe()
[09:31:16.458]     ...future.conditions <- base::list()
[09:31:16.458]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.458]     if (FALSE) {
[09:31:16.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.458]     }
[09:31:16.458]     ...future.result <- base::tryCatch({
[09:31:16.458]         base::withCallingHandlers({
[09:31:16.458]             ...future.value <- base::withVisible(base::local({
[09:31:16.458]                 ...future.makeSendCondition <- base::local({
[09:31:16.458]                   sendCondition <- NULL
[09:31:16.458]                   function(frame = 1L) {
[09:31:16.458]                     if (is.function(sendCondition)) 
[09:31:16.458]                       return(sendCondition)
[09:31:16.458]                     ns <- getNamespace("parallel")
[09:31:16.458]                     if (exists("sendData", mode = "function", 
[09:31:16.458]                       envir = ns)) {
[09:31:16.458]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.458]                         envir = ns)
[09:31:16.458]                       envir <- sys.frame(frame)
[09:31:16.458]                       master <- NULL
[09:31:16.458]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.458]                         !identical(envir, emptyenv())) {
[09:31:16.458]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.458]                           inherits = FALSE)) {
[09:31:16.458]                           master <- get("master", mode = "list", 
[09:31:16.458]                             envir = envir, inherits = FALSE)
[09:31:16.458]                           if (inherits(master, c("SOCKnode", 
[09:31:16.458]                             "SOCK0node"))) {
[09:31:16.458]                             sendCondition <<- function(cond) {
[09:31:16.458]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.458]                                 success = TRUE)
[09:31:16.458]                               parallel_sendData(master, data)
[09:31:16.458]                             }
[09:31:16.458]                             return(sendCondition)
[09:31:16.458]                           }
[09:31:16.458]                         }
[09:31:16.458]                         frame <- frame + 1L
[09:31:16.458]                         envir <- sys.frame(frame)
[09:31:16.458]                       }
[09:31:16.458]                     }
[09:31:16.458]                     sendCondition <<- function(cond) NULL
[09:31:16.458]                   }
[09:31:16.458]                 })
[09:31:16.458]                 withCallingHandlers({
[09:31:16.458]                   2
[09:31:16.458]                 }, immediateCondition = function(cond) {
[09:31:16.458]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.458]                   sendCondition(cond)
[09:31:16.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.458]                   {
[09:31:16.458]                     inherits <- base::inherits
[09:31:16.458]                     invokeRestart <- base::invokeRestart
[09:31:16.458]                     is.null <- base::is.null
[09:31:16.458]                     muffled <- FALSE
[09:31:16.458]                     if (inherits(cond, "message")) {
[09:31:16.458]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.458]                       if (muffled) 
[09:31:16.458]                         invokeRestart("muffleMessage")
[09:31:16.458]                     }
[09:31:16.458]                     else if (inherits(cond, "warning")) {
[09:31:16.458]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.458]                       if (muffled) 
[09:31:16.458]                         invokeRestart("muffleWarning")
[09:31:16.458]                     }
[09:31:16.458]                     else if (inherits(cond, "condition")) {
[09:31:16.458]                       if (!is.null(pattern)) {
[09:31:16.458]                         computeRestarts <- base::computeRestarts
[09:31:16.458]                         grepl <- base::grepl
[09:31:16.458]                         restarts <- computeRestarts(cond)
[09:31:16.458]                         for (restart in restarts) {
[09:31:16.458]                           name <- restart$name
[09:31:16.458]                           if (is.null(name)) 
[09:31:16.458]                             next
[09:31:16.458]                           if (!grepl(pattern, name)) 
[09:31:16.458]                             next
[09:31:16.458]                           invokeRestart(restart)
[09:31:16.458]                           muffled <- TRUE
[09:31:16.458]                           break
[09:31:16.458]                         }
[09:31:16.458]                       }
[09:31:16.458]                     }
[09:31:16.458]                     invisible(muffled)
[09:31:16.458]                   }
[09:31:16.458]                   muffleCondition(cond)
[09:31:16.458]                 })
[09:31:16.458]             }))
[09:31:16.458]             future::FutureResult(value = ...future.value$value, 
[09:31:16.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.458]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.458]                     ...future.globalenv.names))
[09:31:16.458]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.458]         }, condition = base::local({
[09:31:16.458]             c <- base::c
[09:31:16.458]             inherits <- base::inherits
[09:31:16.458]             invokeRestart <- base::invokeRestart
[09:31:16.458]             length <- base::length
[09:31:16.458]             list <- base::list
[09:31:16.458]             seq.int <- base::seq.int
[09:31:16.458]             signalCondition <- base::signalCondition
[09:31:16.458]             sys.calls <- base::sys.calls
[09:31:16.458]             `[[` <- base::`[[`
[09:31:16.458]             `+` <- base::`+`
[09:31:16.458]             `<<-` <- base::`<<-`
[09:31:16.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.458]                   3L)]
[09:31:16.458]             }
[09:31:16.458]             function(cond) {
[09:31:16.458]                 is_error <- inherits(cond, "error")
[09:31:16.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.458]                   NULL)
[09:31:16.458]                 if (is_error) {
[09:31:16.458]                   sessionInformation <- function() {
[09:31:16.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.458]                       search = base::search(), system = base::Sys.info())
[09:31:16.458]                   }
[09:31:16.458]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.458]                     cond$call), session = sessionInformation(), 
[09:31:16.458]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.458]                   signalCondition(cond)
[09:31:16.458]                 }
[09:31:16.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.458]                 "immediateCondition"))) {
[09:31:16.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.458]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.458]                   if (TRUE && !signal) {
[09:31:16.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.458]                     {
[09:31:16.458]                       inherits <- base::inherits
[09:31:16.458]                       invokeRestart <- base::invokeRestart
[09:31:16.458]                       is.null <- base::is.null
[09:31:16.458]                       muffled <- FALSE
[09:31:16.458]                       if (inherits(cond, "message")) {
[09:31:16.458]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.458]                         if (muffled) 
[09:31:16.458]                           invokeRestart("muffleMessage")
[09:31:16.458]                       }
[09:31:16.458]                       else if (inherits(cond, "warning")) {
[09:31:16.458]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.458]                         if (muffled) 
[09:31:16.458]                           invokeRestart("muffleWarning")
[09:31:16.458]                       }
[09:31:16.458]                       else if (inherits(cond, "condition")) {
[09:31:16.458]                         if (!is.null(pattern)) {
[09:31:16.458]                           computeRestarts <- base::computeRestarts
[09:31:16.458]                           grepl <- base::grepl
[09:31:16.458]                           restarts <- computeRestarts(cond)
[09:31:16.458]                           for (restart in restarts) {
[09:31:16.458]                             name <- restart$name
[09:31:16.458]                             if (is.null(name)) 
[09:31:16.458]                               next
[09:31:16.458]                             if (!grepl(pattern, name)) 
[09:31:16.458]                               next
[09:31:16.458]                             invokeRestart(restart)
[09:31:16.458]                             muffled <- TRUE
[09:31:16.458]                             break
[09:31:16.458]                           }
[09:31:16.458]                         }
[09:31:16.458]                       }
[09:31:16.458]                       invisible(muffled)
[09:31:16.458]                     }
[09:31:16.458]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.458]                   }
[09:31:16.458]                 }
[09:31:16.458]                 else {
[09:31:16.458]                   if (TRUE) {
[09:31:16.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.458]                     {
[09:31:16.458]                       inherits <- base::inherits
[09:31:16.458]                       invokeRestart <- base::invokeRestart
[09:31:16.458]                       is.null <- base::is.null
[09:31:16.458]                       muffled <- FALSE
[09:31:16.458]                       if (inherits(cond, "message")) {
[09:31:16.458]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.458]                         if (muffled) 
[09:31:16.458]                           invokeRestart("muffleMessage")
[09:31:16.458]                       }
[09:31:16.458]                       else if (inherits(cond, "warning")) {
[09:31:16.458]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.458]                         if (muffled) 
[09:31:16.458]                           invokeRestart("muffleWarning")
[09:31:16.458]                       }
[09:31:16.458]                       else if (inherits(cond, "condition")) {
[09:31:16.458]                         if (!is.null(pattern)) {
[09:31:16.458]                           computeRestarts <- base::computeRestarts
[09:31:16.458]                           grepl <- base::grepl
[09:31:16.458]                           restarts <- computeRestarts(cond)
[09:31:16.458]                           for (restart in restarts) {
[09:31:16.458]                             name <- restart$name
[09:31:16.458]                             if (is.null(name)) 
[09:31:16.458]                               next
[09:31:16.458]                             if (!grepl(pattern, name)) 
[09:31:16.458]                               next
[09:31:16.458]                             invokeRestart(restart)
[09:31:16.458]                             muffled <- TRUE
[09:31:16.458]                             break
[09:31:16.458]                           }
[09:31:16.458]                         }
[09:31:16.458]                       }
[09:31:16.458]                       invisible(muffled)
[09:31:16.458]                     }
[09:31:16.458]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.458]                   }
[09:31:16.458]                 }
[09:31:16.458]             }
[09:31:16.458]         }))
[09:31:16.458]     }, error = function(ex) {
[09:31:16.458]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.458]                 ...future.rng), started = ...future.startTime, 
[09:31:16.458]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.458]             version = "1.8"), class = "FutureResult")
[09:31:16.458]     }, finally = {
[09:31:16.458]         if (!identical(...future.workdir, getwd())) 
[09:31:16.458]             setwd(...future.workdir)
[09:31:16.458]         {
[09:31:16.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.458]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.458]             }
[09:31:16.458]             base::options(...future.oldOptions)
[09:31:16.458]             if (.Platform$OS.type == "windows") {
[09:31:16.458]                 old_names <- names(...future.oldEnvVars)
[09:31:16.458]                 envs <- base::Sys.getenv()
[09:31:16.458]                 names <- names(envs)
[09:31:16.458]                 common <- intersect(names, old_names)
[09:31:16.458]                 added <- setdiff(names, old_names)
[09:31:16.458]                 removed <- setdiff(old_names, names)
[09:31:16.458]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.458]                   envs[common]]
[09:31:16.458]                 NAMES <- toupper(changed)
[09:31:16.458]                 args <- list()
[09:31:16.458]                 for (kk in seq_along(NAMES)) {
[09:31:16.458]                   name <- changed[[kk]]
[09:31:16.458]                   NAME <- NAMES[[kk]]
[09:31:16.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.458]                     next
[09:31:16.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.458]                 }
[09:31:16.458]                 NAMES <- toupper(added)
[09:31:16.458]                 for (kk in seq_along(NAMES)) {
[09:31:16.458]                   name <- added[[kk]]
[09:31:16.458]                   NAME <- NAMES[[kk]]
[09:31:16.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.458]                     next
[09:31:16.458]                   args[[name]] <- ""
[09:31:16.458]                 }
[09:31:16.458]                 NAMES <- toupper(removed)
[09:31:16.458]                 for (kk in seq_along(NAMES)) {
[09:31:16.458]                   name <- removed[[kk]]
[09:31:16.458]                   NAME <- NAMES[[kk]]
[09:31:16.458]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.458]                     next
[09:31:16.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.458]                 }
[09:31:16.458]                 if (length(args) > 0) 
[09:31:16.458]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.458]             }
[09:31:16.458]             else {
[09:31:16.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.458]             }
[09:31:16.458]             {
[09:31:16.458]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.458]                   0L) {
[09:31:16.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.458]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.458]                   base::options(opts)
[09:31:16.458]                 }
[09:31:16.458]                 {
[09:31:16.458]                   {
[09:31:16.458]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.458]                     NULL
[09:31:16.458]                   }
[09:31:16.458]                   options(future.plan = NULL)
[09:31:16.458]                   if (is.na(NA_character_)) 
[09:31:16.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.458]                     .init = FALSE)
[09:31:16.458]                 }
[09:31:16.458]             }
[09:31:16.458]         }
[09:31:16.458]     })
[09:31:16.458]     if (TRUE) {
[09:31:16.458]         base::sink(type = "output", split = FALSE)
[09:31:16.458]         if (TRUE) {
[09:31:16.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.458]         }
[09:31:16.458]         else {
[09:31:16.458]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.458]         }
[09:31:16.458]         base::close(...future.stdout)
[09:31:16.458]         ...future.stdout <- NULL
[09:31:16.458]     }
[09:31:16.458]     ...future.result$conditions <- ...future.conditions
[09:31:16.458]     ...future.result$finished <- base::Sys.time()
[09:31:16.458]     ...future.result
[09:31:16.458] }
[09:31:16.461] MultisessionFuture started
[09:31:16.461] - Launch lazy future ... done
[09:31:16.461] run() for ‘MultisessionFuture’ ... done
[09:31:16.461] getGlobalsAndPackages() ...
[09:31:16.461] Searching for globals...
[09:31:16.461] 
[09:31:16.461] Searching for globals ... DONE
[09:31:16.462] - globals: [0] <none>
[09:31:16.462] getGlobalsAndPackages() ... DONE
[09:31:16.462] run() for ‘Future’ ...
[09:31:16.462] - state: ‘created’
[09:31:16.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.476]   - Field: ‘node’
[09:31:16.476]   - Field: ‘label’
[09:31:16.476]   - Field: ‘local’
[09:31:16.476]   - Field: ‘owner’
[09:31:16.476]   - Field: ‘envir’
[09:31:16.476]   - Field: ‘workers’
[09:31:16.476]   - Field: ‘packages’
[09:31:16.476]   - Field: ‘gc’
[09:31:16.476]   - Field: ‘conditions’
[09:31:16.476]   - Field: ‘persistent’
[09:31:16.476]   - Field: ‘expr’
[09:31:16.477]   - Field: ‘uuid’
[09:31:16.477]   - Field: ‘seed’
[09:31:16.477]   - Field: ‘version’
[09:31:16.477]   - Field: ‘result’
[09:31:16.477]   - Field: ‘asynchronous’
[09:31:16.477]   - Field: ‘calls’
[09:31:16.477]   - Field: ‘globals’
[09:31:16.477]   - Field: ‘stdout’
[09:31:16.477]   - Field: ‘earlySignal’
[09:31:16.477]   - Field: ‘lazy’
[09:31:16.477]   - Field: ‘state’
[09:31:16.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.478] - Launch lazy future ...
[09:31:16.478] Packages needed by the future expression (n = 0): <none>
[09:31:16.478] Packages needed by future strategies (n = 0): <none>
[09:31:16.478] {
[09:31:16.478]     {
[09:31:16.478]         {
[09:31:16.478]             ...future.startTime <- base::Sys.time()
[09:31:16.478]             {
[09:31:16.478]                 {
[09:31:16.478]                   {
[09:31:16.478]                     {
[09:31:16.478]                       base::local({
[09:31:16.478]                         has_future <- base::requireNamespace("future", 
[09:31:16.478]                           quietly = TRUE)
[09:31:16.478]                         if (has_future) {
[09:31:16.478]                           ns <- base::getNamespace("future")
[09:31:16.478]                           version <- ns[[".package"]][["version"]]
[09:31:16.478]                           if (is.null(version)) 
[09:31:16.478]                             version <- utils::packageVersion("future")
[09:31:16.478]                         }
[09:31:16.478]                         else {
[09:31:16.478]                           version <- NULL
[09:31:16.478]                         }
[09:31:16.478]                         if (!has_future || version < "1.8.0") {
[09:31:16.478]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.478]                             "", base::R.version$version.string), 
[09:31:16.478]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.478]                               "release", "version")], collapse = " "), 
[09:31:16.478]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.478]                             info)
[09:31:16.478]                           info <- base::paste(info, collapse = "; ")
[09:31:16.478]                           if (!has_future) {
[09:31:16.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.478]                               info)
[09:31:16.478]                           }
[09:31:16.478]                           else {
[09:31:16.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.478]                               info, version)
[09:31:16.478]                           }
[09:31:16.478]                           base::stop(msg)
[09:31:16.478]                         }
[09:31:16.478]                       })
[09:31:16.478]                     }
[09:31:16.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.478]                     base::options(mc.cores = 1L)
[09:31:16.478]                   }
[09:31:16.478]                   ...future.strategy.old <- future::plan("list")
[09:31:16.478]                   options(future.plan = NULL)
[09:31:16.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.478]                 }
[09:31:16.478]                 ...future.workdir <- getwd()
[09:31:16.478]             }
[09:31:16.478]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.478]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.478]         }
[09:31:16.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.478]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.478]             base::names(...future.oldOptions))
[09:31:16.478]     }
[09:31:16.478]     if (FALSE) {
[09:31:16.478]     }
[09:31:16.478]     else {
[09:31:16.478]         if (TRUE) {
[09:31:16.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.478]                 open = "w")
[09:31:16.478]         }
[09:31:16.478]         else {
[09:31:16.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.478]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.478]         }
[09:31:16.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.478]             base::sink(type = "output", split = FALSE)
[09:31:16.478]             base::close(...future.stdout)
[09:31:16.478]         }, add = TRUE)
[09:31:16.478]     }
[09:31:16.478]     ...future.frame <- base::sys.nframe()
[09:31:16.478]     ...future.conditions <- base::list()
[09:31:16.478]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.478]     if (FALSE) {
[09:31:16.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.478]     }
[09:31:16.478]     ...future.result <- base::tryCatch({
[09:31:16.478]         base::withCallingHandlers({
[09:31:16.478]             ...future.value <- base::withVisible(base::local({
[09:31:16.478]                 ...future.makeSendCondition <- base::local({
[09:31:16.478]                   sendCondition <- NULL
[09:31:16.478]                   function(frame = 1L) {
[09:31:16.478]                     if (is.function(sendCondition)) 
[09:31:16.478]                       return(sendCondition)
[09:31:16.478]                     ns <- getNamespace("parallel")
[09:31:16.478]                     if (exists("sendData", mode = "function", 
[09:31:16.478]                       envir = ns)) {
[09:31:16.478]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.478]                         envir = ns)
[09:31:16.478]                       envir <- sys.frame(frame)
[09:31:16.478]                       master <- NULL
[09:31:16.478]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.478]                         !identical(envir, emptyenv())) {
[09:31:16.478]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.478]                           inherits = FALSE)) {
[09:31:16.478]                           master <- get("master", mode = "list", 
[09:31:16.478]                             envir = envir, inherits = FALSE)
[09:31:16.478]                           if (inherits(master, c("SOCKnode", 
[09:31:16.478]                             "SOCK0node"))) {
[09:31:16.478]                             sendCondition <<- function(cond) {
[09:31:16.478]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.478]                                 success = TRUE)
[09:31:16.478]                               parallel_sendData(master, data)
[09:31:16.478]                             }
[09:31:16.478]                             return(sendCondition)
[09:31:16.478]                           }
[09:31:16.478]                         }
[09:31:16.478]                         frame <- frame + 1L
[09:31:16.478]                         envir <- sys.frame(frame)
[09:31:16.478]                       }
[09:31:16.478]                     }
[09:31:16.478]                     sendCondition <<- function(cond) NULL
[09:31:16.478]                   }
[09:31:16.478]                 })
[09:31:16.478]                 withCallingHandlers({
[09:31:16.478]                   NULL
[09:31:16.478]                 }, immediateCondition = function(cond) {
[09:31:16.478]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.478]                   sendCondition(cond)
[09:31:16.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.478]                   {
[09:31:16.478]                     inherits <- base::inherits
[09:31:16.478]                     invokeRestart <- base::invokeRestart
[09:31:16.478]                     is.null <- base::is.null
[09:31:16.478]                     muffled <- FALSE
[09:31:16.478]                     if (inherits(cond, "message")) {
[09:31:16.478]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.478]                       if (muffled) 
[09:31:16.478]                         invokeRestart("muffleMessage")
[09:31:16.478]                     }
[09:31:16.478]                     else if (inherits(cond, "warning")) {
[09:31:16.478]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.478]                       if (muffled) 
[09:31:16.478]                         invokeRestart("muffleWarning")
[09:31:16.478]                     }
[09:31:16.478]                     else if (inherits(cond, "condition")) {
[09:31:16.478]                       if (!is.null(pattern)) {
[09:31:16.478]                         computeRestarts <- base::computeRestarts
[09:31:16.478]                         grepl <- base::grepl
[09:31:16.478]                         restarts <- computeRestarts(cond)
[09:31:16.478]                         for (restart in restarts) {
[09:31:16.478]                           name <- restart$name
[09:31:16.478]                           if (is.null(name)) 
[09:31:16.478]                             next
[09:31:16.478]                           if (!grepl(pattern, name)) 
[09:31:16.478]                             next
[09:31:16.478]                           invokeRestart(restart)
[09:31:16.478]                           muffled <- TRUE
[09:31:16.478]                           break
[09:31:16.478]                         }
[09:31:16.478]                       }
[09:31:16.478]                     }
[09:31:16.478]                     invisible(muffled)
[09:31:16.478]                   }
[09:31:16.478]                   muffleCondition(cond)
[09:31:16.478]                 })
[09:31:16.478]             }))
[09:31:16.478]             future::FutureResult(value = ...future.value$value, 
[09:31:16.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.478]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.478]                     ...future.globalenv.names))
[09:31:16.478]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.478]         }, condition = base::local({
[09:31:16.478]             c <- base::c
[09:31:16.478]             inherits <- base::inherits
[09:31:16.478]             invokeRestart <- base::invokeRestart
[09:31:16.478]             length <- base::length
[09:31:16.478]             list <- base::list
[09:31:16.478]             seq.int <- base::seq.int
[09:31:16.478]             signalCondition <- base::signalCondition
[09:31:16.478]             sys.calls <- base::sys.calls
[09:31:16.478]             `[[` <- base::`[[`
[09:31:16.478]             `+` <- base::`+`
[09:31:16.478]             `<<-` <- base::`<<-`
[09:31:16.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.478]                   3L)]
[09:31:16.478]             }
[09:31:16.478]             function(cond) {
[09:31:16.478]                 is_error <- inherits(cond, "error")
[09:31:16.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.478]                   NULL)
[09:31:16.478]                 if (is_error) {
[09:31:16.478]                   sessionInformation <- function() {
[09:31:16.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.478]                       search = base::search(), system = base::Sys.info())
[09:31:16.478]                   }
[09:31:16.478]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.478]                     cond$call), session = sessionInformation(), 
[09:31:16.478]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.478]                   signalCondition(cond)
[09:31:16.478]                 }
[09:31:16.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.478]                 "immediateCondition"))) {
[09:31:16.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.478]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.478]                   if (TRUE && !signal) {
[09:31:16.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.478]                     {
[09:31:16.478]                       inherits <- base::inherits
[09:31:16.478]                       invokeRestart <- base::invokeRestart
[09:31:16.478]                       is.null <- base::is.null
[09:31:16.478]                       muffled <- FALSE
[09:31:16.478]                       if (inherits(cond, "message")) {
[09:31:16.478]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.478]                         if (muffled) 
[09:31:16.478]                           invokeRestart("muffleMessage")
[09:31:16.478]                       }
[09:31:16.478]                       else if (inherits(cond, "warning")) {
[09:31:16.478]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.478]                         if (muffled) 
[09:31:16.478]                           invokeRestart("muffleWarning")
[09:31:16.478]                       }
[09:31:16.478]                       else if (inherits(cond, "condition")) {
[09:31:16.478]                         if (!is.null(pattern)) {
[09:31:16.478]                           computeRestarts <- base::computeRestarts
[09:31:16.478]                           grepl <- base::grepl
[09:31:16.478]                           restarts <- computeRestarts(cond)
[09:31:16.478]                           for (restart in restarts) {
[09:31:16.478]                             name <- restart$name
[09:31:16.478]                             if (is.null(name)) 
[09:31:16.478]                               next
[09:31:16.478]                             if (!grepl(pattern, name)) 
[09:31:16.478]                               next
[09:31:16.478]                             invokeRestart(restart)
[09:31:16.478]                             muffled <- TRUE
[09:31:16.478]                             break
[09:31:16.478]                           }
[09:31:16.478]                         }
[09:31:16.478]                       }
[09:31:16.478]                       invisible(muffled)
[09:31:16.478]                     }
[09:31:16.478]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.478]                   }
[09:31:16.478]                 }
[09:31:16.478]                 else {
[09:31:16.478]                   if (TRUE) {
[09:31:16.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.478]                     {
[09:31:16.478]                       inherits <- base::inherits
[09:31:16.478]                       invokeRestart <- base::invokeRestart
[09:31:16.478]                       is.null <- base::is.null
[09:31:16.478]                       muffled <- FALSE
[09:31:16.478]                       if (inherits(cond, "message")) {
[09:31:16.478]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.478]                         if (muffled) 
[09:31:16.478]                           invokeRestart("muffleMessage")
[09:31:16.478]                       }
[09:31:16.478]                       else if (inherits(cond, "warning")) {
[09:31:16.478]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.478]                         if (muffled) 
[09:31:16.478]                           invokeRestart("muffleWarning")
[09:31:16.478]                       }
[09:31:16.478]                       else if (inherits(cond, "condition")) {
[09:31:16.478]                         if (!is.null(pattern)) {
[09:31:16.478]                           computeRestarts <- base::computeRestarts
[09:31:16.478]                           grepl <- base::grepl
[09:31:16.478]                           restarts <- computeRestarts(cond)
[09:31:16.478]                           for (restart in restarts) {
[09:31:16.478]                             name <- restart$name
[09:31:16.478]                             if (is.null(name)) 
[09:31:16.478]                               next
[09:31:16.478]                             if (!grepl(pattern, name)) 
[09:31:16.478]                               next
[09:31:16.478]                             invokeRestart(restart)
[09:31:16.478]                             muffled <- TRUE
[09:31:16.478]                             break
[09:31:16.478]                           }
[09:31:16.478]                         }
[09:31:16.478]                       }
[09:31:16.478]                       invisible(muffled)
[09:31:16.478]                     }
[09:31:16.478]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.478]                   }
[09:31:16.478]                 }
[09:31:16.478]             }
[09:31:16.478]         }))
[09:31:16.478]     }, error = function(ex) {
[09:31:16.478]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.478]                 ...future.rng), started = ...future.startTime, 
[09:31:16.478]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.478]             version = "1.8"), class = "FutureResult")
[09:31:16.478]     }, finally = {
[09:31:16.478]         if (!identical(...future.workdir, getwd())) 
[09:31:16.478]             setwd(...future.workdir)
[09:31:16.478]         {
[09:31:16.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.478]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.478]             }
[09:31:16.478]             base::options(...future.oldOptions)
[09:31:16.478]             if (.Platform$OS.type == "windows") {
[09:31:16.478]                 old_names <- names(...future.oldEnvVars)
[09:31:16.478]                 envs <- base::Sys.getenv()
[09:31:16.478]                 names <- names(envs)
[09:31:16.478]                 common <- intersect(names, old_names)
[09:31:16.478]                 added <- setdiff(names, old_names)
[09:31:16.478]                 removed <- setdiff(old_names, names)
[09:31:16.478]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.478]                   envs[common]]
[09:31:16.478]                 NAMES <- toupper(changed)
[09:31:16.478]                 args <- list()
[09:31:16.478]                 for (kk in seq_along(NAMES)) {
[09:31:16.478]                   name <- changed[[kk]]
[09:31:16.478]                   NAME <- NAMES[[kk]]
[09:31:16.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.478]                     next
[09:31:16.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.478]                 }
[09:31:16.478]                 NAMES <- toupper(added)
[09:31:16.478]                 for (kk in seq_along(NAMES)) {
[09:31:16.478]                   name <- added[[kk]]
[09:31:16.478]                   NAME <- NAMES[[kk]]
[09:31:16.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.478]                     next
[09:31:16.478]                   args[[name]] <- ""
[09:31:16.478]                 }
[09:31:16.478]                 NAMES <- toupper(removed)
[09:31:16.478]                 for (kk in seq_along(NAMES)) {
[09:31:16.478]                   name <- removed[[kk]]
[09:31:16.478]                   NAME <- NAMES[[kk]]
[09:31:16.478]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.478]                     next
[09:31:16.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.478]                 }
[09:31:16.478]                 if (length(args) > 0) 
[09:31:16.478]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.478]             }
[09:31:16.478]             else {
[09:31:16.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.478]             }
[09:31:16.478]             {
[09:31:16.478]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.478]                   0L) {
[09:31:16.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.478]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.478]                   base::options(opts)
[09:31:16.478]                 }
[09:31:16.478]                 {
[09:31:16.478]                   {
[09:31:16.478]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.478]                     NULL
[09:31:16.478]                   }
[09:31:16.478]                   options(future.plan = NULL)
[09:31:16.478]                   if (is.na(NA_character_)) 
[09:31:16.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.478]                     .init = FALSE)
[09:31:16.478]                 }
[09:31:16.478]             }
[09:31:16.478]         }
[09:31:16.478]     })
[09:31:16.478]     if (TRUE) {
[09:31:16.478]         base::sink(type = "output", split = FALSE)
[09:31:16.478]         if (TRUE) {
[09:31:16.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.478]         }
[09:31:16.478]         else {
[09:31:16.478]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.478]         }
[09:31:16.478]         base::close(...future.stdout)
[09:31:16.478]         ...future.stdout <- NULL
[09:31:16.478]     }
[09:31:16.478]     ...future.result$conditions <- ...future.conditions
[09:31:16.478]     ...future.result$finished <- base::Sys.time()
[09:31:16.478]     ...future.result
[09:31:16.478] }
[09:31:16.481] MultisessionFuture started
[09:31:16.481] - Launch lazy future ... done
[09:31:16.481] run() for ‘MultisessionFuture’ ... done
[09:31:16.482] getGlobalsAndPackages() ...
[09:31:16.482] Searching for globals...
[09:31:16.482] - globals found: [1] ‘{’
[09:31:16.483] Searching for globals ... DONE
[09:31:16.483] Resolving globals: FALSE
[09:31:16.483] 
[09:31:16.483] 
[09:31:16.483] getGlobalsAndPackages() ... DONE
[09:31:16.483] run() for ‘Future’ ...
[09:31:16.483] - state: ‘created’
[09:31:16.483] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:16.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:16.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:16.498]   - Field: ‘node’
[09:31:16.498]   - Field: ‘label’
[09:31:16.498]   - Field: ‘local’
[09:31:16.498]   - Field: ‘owner’
[09:31:16.499]   - Field: ‘envir’
[09:31:16.499]   - Field: ‘workers’
[09:31:16.499]   - Field: ‘packages’
[09:31:16.499]   - Field: ‘gc’
[09:31:16.499]   - Field: ‘conditions’
[09:31:16.499]   - Field: ‘persistent’
[09:31:16.499]   - Field: ‘expr’
[09:31:16.499]   - Field: ‘uuid’
[09:31:16.499]   - Field: ‘seed’
[09:31:16.499]   - Field: ‘version’
[09:31:16.499]   - Field: ‘result’
[09:31:16.500]   - Field: ‘asynchronous’
[09:31:16.500]   - Field: ‘calls’
[09:31:16.500]   - Field: ‘globals’
[09:31:16.500]   - Field: ‘stdout’
[09:31:16.500]   - Field: ‘earlySignal’
[09:31:16.500]   - Field: ‘lazy’
[09:31:16.500]   - Field: ‘state’
[09:31:16.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:16.500] - Launch lazy future ...
[09:31:16.501] Packages needed by the future expression (n = 0): <none>
[09:31:16.501] Packages needed by future strategies (n = 0): <none>
[09:31:16.501] {
[09:31:16.501]     {
[09:31:16.501]         {
[09:31:16.501]             ...future.startTime <- base::Sys.time()
[09:31:16.501]             {
[09:31:16.501]                 {
[09:31:16.501]                   {
[09:31:16.501]                     {
[09:31:16.501]                       base::local({
[09:31:16.501]                         has_future <- base::requireNamespace("future", 
[09:31:16.501]                           quietly = TRUE)
[09:31:16.501]                         if (has_future) {
[09:31:16.501]                           ns <- base::getNamespace("future")
[09:31:16.501]                           version <- ns[[".package"]][["version"]]
[09:31:16.501]                           if (is.null(version)) 
[09:31:16.501]                             version <- utils::packageVersion("future")
[09:31:16.501]                         }
[09:31:16.501]                         else {
[09:31:16.501]                           version <- NULL
[09:31:16.501]                         }
[09:31:16.501]                         if (!has_future || version < "1.8.0") {
[09:31:16.501]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:16.501]                             "", base::R.version$version.string), 
[09:31:16.501]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:16.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:16.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:16.501]                               "release", "version")], collapse = " "), 
[09:31:16.501]                             hostname = base::Sys.info()[["nodename"]])
[09:31:16.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:16.501]                             info)
[09:31:16.501]                           info <- base::paste(info, collapse = "; ")
[09:31:16.501]                           if (!has_future) {
[09:31:16.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:16.501]                               info)
[09:31:16.501]                           }
[09:31:16.501]                           else {
[09:31:16.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:16.501]                               info, version)
[09:31:16.501]                           }
[09:31:16.501]                           base::stop(msg)
[09:31:16.501]                         }
[09:31:16.501]                       })
[09:31:16.501]                     }
[09:31:16.501]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:16.501]                     base::options(mc.cores = 1L)
[09:31:16.501]                   }
[09:31:16.501]                   ...future.strategy.old <- future::plan("list")
[09:31:16.501]                   options(future.plan = NULL)
[09:31:16.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:16.501]                 }
[09:31:16.501]                 ...future.workdir <- getwd()
[09:31:16.501]             }
[09:31:16.501]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:16.501]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:16.501]         }
[09:31:16.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:16.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:16.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:16.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:16.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:16.501]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:16.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:16.501]             base::names(...future.oldOptions))
[09:31:16.501]     }
[09:31:16.501]     if (FALSE) {
[09:31:16.501]     }
[09:31:16.501]     else {
[09:31:16.501]         if (TRUE) {
[09:31:16.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:16.501]                 open = "w")
[09:31:16.501]         }
[09:31:16.501]         else {
[09:31:16.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:16.501]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:16.501]         }
[09:31:16.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:16.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:16.501]             base::sink(type = "output", split = FALSE)
[09:31:16.501]             base::close(...future.stdout)
[09:31:16.501]         }, add = TRUE)
[09:31:16.501]     }
[09:31:16.501]     ...future.frame <- base::sys.nframe()
[09:31:16.501]     ...future.conditions <- base::list()
[09:31:16.501]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:16.501]     if (FALSE) {
[09:31:16.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:16.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:16.501]     }
[09:31:16.501]     ...future.result <- base::tryCatch({
[09:31:16.501]         base::withCallingHandlers({
[09:31:16.501]             ...future.value <- base::withVisible(base::local({
[09:31:16.501]                 ...future.makeSendCondition <- base::local({
[09:31:16.501]                   sendCondition <- NULL
[09:31:16.501]                   function(frame = 1L) {
[09:31:16.501]                     if (is.function(sendCondition)) 
[09:31:16.501]                       return(sendCondition)
[09:31:16.501]                     ns <- getNamespace("parallel")
[09:31:16.501]                     if (exists("sendData", mode = "function", 
[09:31:16.501]                       envir = ns)) {
[09:31:16.501]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:16.501]                         envir = ns)
[09:31:16.501]                       envir <- sys.frame(frame)
[09:31:16.501]                       master <- NULL
[09:31:16.501]                       while (!identical(envir, .GlobalEnv) && 
[09:31:16.501]                         !identical(envir, emptyenv())) {
[09:31:16.501]                         if (exists("master", mode = "list", envir = envir, 
[09:31:16.501]                           inherits = FALSE)) {
[09:31:16.501]                           master <- get("master", mode = "list", 
[09:31:16.501]                             envir = envir, inherits = FALSE)
[09:31:16.501]                           if (inherits(master, c("SOCKnode", 
[09:31:16.501]                             "SOCK0node"))) {
[09:31:16.501]                             sendCondition <<- function(cond) {
[09:31:16.501]                               data <- list(type = "VALUE", value = cond, 
[09:31:16.501]                                 success = TRUE)
[09:31:16.501]                               parallel_sendData(master, data)
[09:31:16.501]                             }
[09:31:16.501]                             return(sendCondition)
[09:31:16.501]                           }
[09:31:16.501]                         }
[09:31:16.501]                         frame <- frame + 1L
[09:31:16.501]                         envir <- sys.frame(frame)
[09:31:16.501]                       }
[09:31:16.501]                     }
[09:31:16.501]                     sendCondition <<- function(cond) NULL
[09:31:16.501]                   }
[09:31:16.501]                 })
[09:31:16.501]                 withCallingHandlers({
[09:31:16.501]                   {
[09:31:16.501]                     4
[09:31:16.501]                   }
[09:31:16.501]                 }, immediateCondition = function(cond) {
[09:31:16.501]                   sendCondition <- ...future.makeSendCondition()
[09:31:16.501]                   sendCondition(cond)
[09:31:16.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.501]                   {
[09:31:16.501]                     inherits <- base::inherits
[09:31:16.501]                     invokeRestart <- base::invokeRestart
[09:31:16.501]                     is.null <- base::is.null
[09:31:16.501]                     muffled <- FALSE
[09:31:16.501]                     if (inherits(cond, "message")) {
[09:31:16.501]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:16.501]                       if (muffled) 
[09:31:16.501]                         invokeRestart("muffleMessage")
[09:31:16.501]                     }
[09:31:16.501]                     else if (inherits(cond, "warning")) {
[09:31:16.501]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:16.501]                       if (muffled) 
[09:31:16.501]                         invokeRestart("muffleWarning")
[09:31:16.501]                     }
[09:31:16.501]                     else if (inherits(cond, "condition")) {
[09:31:16.501]                       if (!is.null(pattern)) {
[09:31:16.501]                         computeRestarts <- base::computeRestarts
[09:31:16.501]                         grepl <- base::grepl
[09:31:16.501]                         restarts <- computeRestarts(cond)
[09:31:16.501]                         for (restart in restarts) {
[09:31:16.501]                           name <- restart$name
[09:31:16.501]                           if (is.null(name)) 
[09:31:16.501]                             next
[09:31:16.501]                           if (!grepl(pattern, name)) 
[09:31:16.501]                             next
[09:31:16.501]                           invokeRestart(restart)
[09:31:16.501]                           muffled <- TRUE
[09:31:16.501]                           break
[09:31:16.501]                         }
[09:31:16.501]                       }
[09:31:16.501]                     }
[09:31:16.501]                     invisible(muffled)
[09:31:16.501]                   }
[09:31:16.501]                   muffleCondition(cond)
[09:31:16.501]                 })
[09:31:16.501]             }))
[09:31:16.501]             future::FutureResult(value = ...future.value$value, 
[09:31:16.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.501]                   ...future.rng), globalenv = if (FALSE) 
[09:31:16.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:16.501]                     ...future.globalenv.names))
[09:31:16.501]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:16.501]         }, condition = base::local({
[09:31:16.501]             c <- base::c
[09:31:16.501]             inherits <- base::inherits
[09:31:16.501]             invokeRestart <- base::invokeRestart
[09:31:16.501]             length <- base::length
[09:31:16.501]             list <- base::list
[09:31:16.501]             seq.int <- base::seq.int
[09:31:16.501]             signalCondition <- base::signalCondition
[09:31:16.501]             sys.calls <- base::sys.calls
[09:31:16.501]             `[[` <- base::`[[`
[09:31:16.501]             `+` <- base::`+`
[09:31:16.501]             `<<-` <- base::`<<-`
[09:31:16.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:16.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:16.501]                   3L)]
[09:31:16.501]             }
[09:31:16.501]             function(cond) {
[09:31:16.501]                 is_error <- inherits(cond, "error")
[09:31:16.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:16.501]                   NULL)
[09:31:16.501]                 if (is_error) {
[09:31:16.501]                   sessionInformation <- function() {
[09:31:16.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:16.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:16.501]                       search = base::search(), system = base::Sys.info())
[09:31:16.501]                   }
[09:31:16.501]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:16.501]                     cond$call), session = sessionInformation(), 
[09:31:16.501]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:16.501]                   signalCondition(cond)
[09:31:16.501]                 }
[09:31:16.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:16.501]                 "immediateCondition"))) {
[09:31:16.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:16.501]                   ...future.conditions[[length(...future.conditions) + 
[09:31:16.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:16.501]                   if (TRUE && !signal) {
[09:31:16.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.501]                     {
[09:31:16.501]                       inherits <- base::inherits
[09:31:16.501]                       invokeRestart <- base::invokeRestart
[09:31:16.501]                       is.null <- base::is.null
[09:31:16.501]                       muffled <- FALSE
[09:31:16.501]                       if (inherits(cond, "message")) {
[09:31:16.501]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.501]                         if (muffled) 
[09:31:16.501]                           invokeRestart("muffleMessage")
[09:31:16.501]                       }
[09:31:16.501]                       else if (inherits(cond, "warning")) {
[09:31:16.501]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.501]                         if (muffled) 
[09:31:16.501]                           invokeRestart("muffleWarning")
[09:31:16.501]                       }
[09:31:16.501]                       else if (inherits(cond, "condition")) {
[09:31:16.501]                         if (!is.null(pattern)) {
[09:31:16.501]                           computeRestarts <- base::computeRestarts
[09:31:16.501]                           grepl <- base::grepl
[09:31:16.501]                           restarts <- computeRestarts(cond)
[09:31:16.501]                           for (restart in restarts) {
[09:31:16.501]                             name <- restart$name
[09:31:16.501]                             if (is.null(name)) 
[09:31:16.501]                               next
[09:31:16.501]                             if (!grepl(pattern, name)) 
[09:31:16.501]                               next
[09:31:16.501]                             invokeRestart(restart)
[09:31:16.501]                             muffled <- TRUE
[09:31:16.501]                             break
[09:31:16.501]                           }
[09:31:16.501]                         }
[09:31:16.501]                       }
[09:31:16.501]                       invisible(muffled)
[09:31:16.501]                     }
[09:31:16.501]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.501]                   }
[09:31:16.501]                 }
[09:31:16.501]                 else {
[09:31:16.501]                   if (TRUE) {
[09:31:16.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:16.501]                     {
[09:31:16.501]                       inherits <- base::inherits
[09:31:16.501]                       invokeRestart <- base::invokeRestart
[09:31:16.501]                       is.null <- base::is.null
[09:31:16.501]                       muffled <- FALSE
[09:31:16.501]                       if (inherits(cond, "message")) {
[09:31:16.501]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:16.501]                         if (muffled) 
[09:31:16.501]                           invokeRestart("muffleMessage")
[09:31:16.501]                       }
[09:31:16.501]                       else if (inherits(cond, "warning")) {
[09:31:16.501]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:16.501]                         if (muffled) 
[09:31:16.501]                           invokeRestart("muffleWarning")
[09:31:16.501]                       }
[09:31:16.501]                       else if (inherits(cond, "condition")) {
[09:31:16.501]                         if (!is.null(pattern)) {
[09:31:16.501]                           computeRestarts <- base::computeRestarts
[09:31:16.501]                           grepl <- base::grepl
[09:31:16.501]                           restarts <- computeRestarts(cond)
[09:31:16.501]                           for (restart in restarts) {
[09:31:16.501]                             name <- restart$name
[09:31:16.501]                             if (is.null(name)) 
[09:31:16.501]                               next
[09:31:16.501]                             if (!grepl(pattern, name)) 
[09:31:16.501]                               next
[09:31:16.501]                             invokeRestart(restart)
[09:31:16.501]                             muffled <- TRUE
[09:31:16.501]                             break
[09:31:16.501]                           }
[09:31:16.501]                         }
[09:31:16.501]                       }
[09:31:16.501]                       invisible(muffled)
[09:31:16.501]                     }
[09:31:16.501]                     muffleCondition(cond, pattern = "^muffle")
[09:31:16.501]                   }
[09:31:16.501]                 }
[09:31:16.501]             }
[09:31:16.501]         }))
[09:31:16.501]     }, error = function(ex) {
[09:31:16.501]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:16.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:16.501]                 ...future.rng), started = ...future.startTime, 
[09:31:16.501]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:16.501]             version = "1.8"), class = "FutureResult")
[09:31:16.501]     }, finally = {
[09:31:16.501]         if (!identical(...future.workdir, getwd())) 
[09:31:16.501]             setwd(...future.workdir)
[09:31:16.501]         {
[09:31:16.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:16.501]                 ...future.oldOptions$nwarnings <- NULL
[09:31:16.501]             }
[09:31:16.501]             base::options(...future.oldOptions)
[09:31:16.501]             if (.Platform$OS.type == "windows") {
[09:31:16.501]                 old_names <- names(...future.oldEnvVars)
[09:31:16.501]                 envs <- base::Sys.getenv()
[09:31:16.501]                 names <- names(envs)
[09:31:16.501]                 common <- intersect(names, old_names)
[09:31:16.501]                 added <- setdiff(names, old_names)
[09:31:16.501]                 removed <- setdiff(old_names, names)
[09:31:16.501]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:16.501]                   envs[common]]
[09:31:16.501]                 NAMES <- toupper(changed)
[09:31:16.501]                 args <- list()
[09:31:16.501]                 for (kk in seq_along(NAMES)) {
[09:31:16.501]                   name <- changed[[kk]]
[09:31:16.501]                   NAME <- NAMES[[kk]]
[09:31:16.501]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.501]                     next
[09:31:16.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.501]                 }
[09:31:16.501]                 NAMES <- toupper(added)
[09:31:16.501]                 for (kk in seq_along(NAMES)) {
[09:31:16.501]                   name <- added[[kk]]
[09:31:16.501]                   NAME <- NAMES[[kk]]
[09:31:16.501]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.501]                     next
[09:31:16.501]                   args[[name]] <- ""
[09:31:16.501]                 }
[09:31:16.501]                 NAMES <- toupper(removed)
[09:31:16.501]                 for (kk in seq_along(NAMES)) {
[09:31:16.501]                   name <- removed[[kk]]
[09:31:16.501]                   NAME <- NAMES[[kk]]
[09:31:16.501]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:16.501]                     next
[09:31:16.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:16.501]                 }
[09:31:16.501]                 if (length(args) > 0) 
[09:31:16.501]                   base::do.call(base::Sys.setenv, args = args)
[09:31:16.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:16.501]             }
[09:31:16.501]             else {
[09:31:16.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:16.501]             }
[09:31:16.501]             {
[09:31:16.501]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:16.501]                   0L) {
[09:31:16.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:16.501]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:16.501]                   base::options(opts)
[09:31:16.501]                 }
[09:31:16.501]                 {
[09:31:16.501]                   {
[09:31:16.501]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:16.501]                     NULL
[09:31:16.501]                   }
[09:31:16.501]                   options(future.plan = NULL)
[09:31:16.501]                   if (is.na(NA_character_)) 
[09:31:16.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:16.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:16.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:16.501]                     .init = FALSE)
[09:31:16.501]                 }
[09:31:16.501]             }
[09:31:16.501]         }
[09:31:16.501]     })
[09:31:16.501]     if (TRUE) {
[09:31:16.501]         base::sink(type = "output", split = FALSE)
[09:31:16.501]         if (TRUE) {
[09:31:16.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:16.501]         }
[09:31:16.501]         else {
[09:31:16.501]             ...future.result["stdout"] <- base::list(NULL)
[09:31:16.501]         }
[09:31:16.501]         base::close(...future.stdout)
[09:31:16.501]         ...future.stdout <- NULL
[09:31:16.501]     }
[09:31:16.501]     ...future.result$conditions <- ...future.conditions
[09:31:16.501]     ...future.result$finished <- base::Sys.time()
[09:31:16.501]     ...future.result
[09:31:16.501] }
[09:31:16.503] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:16.514] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.514] - Validating connection of MultisessionFuture
[09:31:16.514] - received message: FutureResult
[09:31:16.514] - Received FutureResult
[09:31:16.514] - Erased future from FutureRegistry
[09:31:16.514] result() for ClusterFuture ...
[09:31:16.514] - result already collected: FutureResult
[09:31:16.515] result() for ClusterFuture ... done
[09:31:16.515] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.515] result() for ClusterFuture ...
[09:31:16.515] - result already collected: FutureResult
[09:31:16.515] result() for ClusterFuture ... done
[09:31:16.515] result() for ClusterFuture ...
[09:31:16.515] - result already collected: FutureResult
[09:31:16.515] result() for ClusterFuture ... done
[09:31:16.516] MultisessionFuture started
[09:31:16.516] - Launch lazy future ... done
[09:31:16.516] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a3cb0da748> 
Classes 'listenv', 'environment' <environment: 0x55a3cbe3cc90> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[09:31:16.520] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.521] - Validating connection of MultisessionFuture
[09:31:16.521] - received message: FutureResult
[09:31:16.521] - Received FutureResult
[09:31:16.521] - Erased future from FutureRegistry
[09:31:16.521] result() for ClusterFuture ...
[09:31:16.521] - result already collected: FutureResult
[09:31:16.521] result() for ClusterFuture ... done
[09:31:16.521] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:16.522] receiveMessageFromWorker() for ClusterFuture ...
[09:31:16.522] - Validating connection of MultisessionFuture
[09:31:16.522] - received message: FutureResult
[09:31:16.522] - Received FutureResult
[09:31:16.522] - Erased future from FutureRegistry
[09:31:16.522] result() for ClusterFuture ...
[09:31:16.522] - result already collected: FutureResult
[09:31:16.522] result() for ClusterFuture ... done
[09:31:16.522] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[09:31:16.525] resolve() on list environment ...
[09:31:16.525]  recursive: 0
[09:31:16.526]  length: 6
[09:31:16.526]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[09:31:16.526] signalConditionsASAP(numeric, pos=1) ...
[09:31:16.526] - nx: 6
[09:31:16.527] - relay: TRUE
[09:31:16.527] - stdout: TRUE
[09:31:16.527] - signal: TRUE
[09:31:16.527] - resignal: FALSE
[09:31:16.527] - force: TRUE
[09:31:16.527] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.527] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.527]  - until=2
[09:31:16.527]  - relaying element #2
[09:31:16.527] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.527] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.527] signalConditionsASAP(NULL, pos=1) ... done
[09:31:16.528]  length: 5 (resolved future 1)
[09:31:16.528] Future #2
[09:31:16.528] result() for ClusterFuture ...
[09:31:16.528] - result already collected: FutureResult
[09:31:16.528] result() for ClusterFuture ... done
[09:31:16.528] result() for ClusterFuture ...
[09:31:16.528] - result already collected: FutureResult
[09:31:16.528] result() for ClusterFuture ... done
[09:31:16.528] signalConditionsASAP(MultisessionFuture, pos=2) ...
[09:31:16.528] - nx: 6
[09:31:16.528] - relay: TRUE
[09:31:16.529] - stdout: TRUE
[09:31:16.529] - signal: TRUE
[09:31:16.529] - resignal: FALSE
[09:31:16.529] - force: TRUE
[09:31:16.529] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.529] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[09:31:16.529]  - until=2
[09:31:16.529]  - relaying element #2
[09:31:16.529] result() for ClusterFuture ...
[09:31:16.529] - result already collected: FutureResult
[09:31:16.529] result() for ClusterFuture ... done
[09:31:16.529] result() for ClusterFuture ...
[09:31:16.530] - result already collected: FutureResult
[09:31:16.530] result() for ClusterFuture ... done
[09:31:16.530] result() for ClusterFuture ...
[09:31:16.530] - result already collected: FutureResult
[09:31:16.530] result() for ClusterFuture ... done
[09:31:16.530] result() for ClusterFuture ...
[09:31:16.530] - result already collected: FutureResult
[09:31:16.530] result() for ClusterFuture ... done
[09:31:16.530] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.530] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.530] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[09:31:16.530]  length: 4 (resolved future 2)
[09:31:16.531] Future #3
[09:31:16.531] result() for ClusterFuture ...
[09:31:16.531] - result already collected: FutureResult
[09:31:16.531] result() for ClusterFuture ... done
[09:31:16.531] result() for ClusterFuture ...
[09:31:16.531] - result already collected: FutureResult
[09:31:16.531] result() for ClusterFuture ... done
[09:31:16.531] signalConditionsASAP(MultisessionFuture, pos=3) ...
[09:31:16.531] - nx: 6
[09:31:16.531] - relay: TRUE
[09:31:16.531] - stdout: TRUE
[09:31:16.532] - signal: TRUE
[09:31:16.532] - resignal: FALSE
[09:31:16.532] - force: TRUE
[09:31:16.532] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.532] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[09:31:16.532]  - until=3
[09:31:16.532]  - relaying element #3
[09:31:16.532] result() for ClusterFuture ...
[09:31:16.532] - result already collected: FutureResult
[09:31:16.532] result() for ClusterFuture ... done
[09:31:16.532] result() for ClusterFuture ...
[09:31:16.533] - result already collected: FutureResult
[09:31:16.533] result() for ClusterFuture ... done
[09:31:16.533] result() for ClusterFuture ...
[09:31:16.533] - result already collected: FutureResult
[09:31:16.533] result() for ClusterFuture ... done
[09:31:16.533] result() for ClusterFuture ...
[09:31:16.533] - result already collected: FutureResult
[09:31:16.533] result() for ClusterFuture ... done
[09:31:16.533] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.533] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.533] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[09:31:16.533]  length: 3 (resolved future 3)
[09:31:16.534] Future #4
[09:31:16.534] result() for ClusterFuture ...
[09:31:16.534] - result already collected: FutureResult
[09:31:16.534] result() for ClusterFuture ... done
[09:31:16.534] result() for ClusterFuture ...
[09:31:16.534] - result already collected: FutureResult
[09:31:16.534] result() for ClusterFuture ... done
[09:31:16.534] signalConditionsASAP(MultisessionFuture, pos=4) ...
[09:31:16.534] - nx: 6
[09:31:16.534] - relay: TRUE
[09:31:16.534] - stdout: TRUE
[09:31:16.534] - signal: TRUE
[09:31:16.535] - resignal: FALSE
[09:31:16.535] - force: TRUE
[09:31:16.535] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.535] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[09:31:16.535]  - until=4
[09:31:16.535]  - relaying element #4
[09:31:16.535] result() for ClusterFuture ...
[09:31:16.535] - result already collected: FutureResult
[09:31:16.535] result() for ClusterFuture ... done
[09:31:16.535] result() for ClusterFuture ...
[09:31:16.535] - result already collected: FutureResult
[09:31:16.535] result() for ClusterFuture ... done
[09:31:16.536] result() for ClusterFuture ...
[09:31:16.536] - result already collected: FutureResult
[09:31:16.536] result() for ClusterFuture ... done
[09:31:16.536] result() for ClusterFuture ...
[09:31:16.536] - result already collected: FutureResult
[09:31:16.536] result() for ClusterFuture ... done
[09:31:16.536] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.536] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.536] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[09:31:16.536]  length: 2 (resolved future 4)
[09:31:16.537] signalConditionsASAP(NULL, pos=5) ...
[09:31:16.537] - nx: 6
[09:31:16.537] - relay: TRUE
[09:31:16.537] - stdout: TRUE
[09:31:16.537] - signal: TRUE
[09:31:16.537] - resignal: FALSE
[09:31:16.537] - force: TRUE
[09:31:16.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.537] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.537]  - until=6
[09:31:16.537]  - relaying element #6
[09:31:16.537] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.537] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.538] signalConditionsASAP(NULL, pos=5) ... done
[09:31:16.538]  length: 1 (resolved future 5)
[09:31:16.538] signalConditionsASAP(numeric, pos=6) ...
[09:31:16.538] - nx: 6
[09:31:16.538] - relay: TRUE
[09:31:16.538] - stdout: TRUE
[09:31:16.538] - signal: TRUE
[09:31:16.538] - resignal: FALSE
[09:31:16.538] - force: TRUE
[09:31:16.538] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[09:31:16.538] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.538]  - until=6
[09:31:16.539] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.539] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.539] signalConditionsASAP(numeric, pos=6) ... done
[09:31:16.539]  length: 0 (resolved future 6)
[09:31:16.539] Relaying remaining futures
[09:31:16.539] signalConditionsASAP(NULL, pos=0) ...
[09:31:16.539] - nx: 6
[09:31:16.539] - relay: TRUE
[09:31:16.539] - stdout: TRUE
[09:31:16.539] - signal: TRUE
[09:31:16.539] - resignal: FALSE
[09:31:16.539] - force: TRUE
[09:31:16.540] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.540] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[09:31:16.540] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[09:31:16.540] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[09:31:16.540] signalConditionsASAP(NULL, pos=0) ... done
[09:31:16.540] resolve() on list environment ... DONE
[09:31:16.540] result() for ClusterFuture ...
[09:31:16.540] - result already collected: FutureResult
[09:31:16.540] result() for ClusterFuture ... done
[09:31:16.540] result() for ClusterFuture ...
[09:31:16.541] - result already collected: FutureResult
[09:31:16.541] result() for ClusterFuture ... done
[09:31:16.541] result() for ClusterFuture ...
[09:31:16.541] - result already collected: FutureResult
[09:31:16.541] result() for ClusterFuture ... done
[09:31:16.541] result() for ClusterFuture ...
[09:31:16.541] - result already collected: FutureResult
[09:31:16.541] result() for ClusterFuture ... done
[09:31:16.541] result() for ClusterFuture ...
[09:31:16.541] - result already collected: FutureResult
[09:31:16.541] result() for ClusterFuture ... done
[09:31:16.542] result() for ClusterFuture ...
[09:31:16.542] - result already collected: FutureResult
[09:31:16.542] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a3cc30d5e0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[09:31:16.544] plan(): Setting new future strategy stack:
[09:31:16.544] List of future strategies:
[09:31:16.544] 1. FutureStrategy:
[09:31:16.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:16.544]    - tweaked: FALSE
[09:31:16.544]    - call: future::plan(oplan)
[09:31:16.548] plan(): nbrOfWorkers() = 1
> 
