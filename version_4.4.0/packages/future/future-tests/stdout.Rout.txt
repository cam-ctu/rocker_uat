
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:41:26.965] plan(): Setting new future strategy stack:
[17:41:26.966] List of future strategies:
[17:41:26.966] 1. sequential:
[17:41:26.966]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:26.966]    - tweaked: FALSE
[17:41:26.966]    - call: future::plan("sequential")
[17:41:26.977] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[17:41:27.024] plan(): Setting new future strategy stack:
[17:41:27.024] List of future strategies:
[17:41:27.024] 1. sequential:
[17:41:27.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.024]    - tweaked: FALSE
[17:41:27.024]    - call: plan(strategy)
[17:41:27.035] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[17:41:27.035] getGlobalsAndPackages() ...
[17:41:27.036] Searching for globals...
[17:41:27.044] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.045] Searching for globals ... DONE
[17:41:27.045] Resolving globals: FALSE
[17:41:27.045] 
[17:41:27.045] - packages: [1] ‘utils’
[17:41:27.046] getGlobalsAndPackages() ... DONE
[17:41:27.046] run() for ‘Future’ ...
[17:41:27.046] - state: ‘created’
[17:41:27.046] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.047] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.047]   - Field: ‘label’
[17:41:27.047]   - Field: ‘local’
[17:41:27.047]   - Field: ‘owner’
[17:41:27.047]   - Field: ‘envir’
[17:41:27.047]   - Field: ‘packages’
[17:41:27.047]   - Field: ‘gc’
[17:41:27.048]   - Field: ‘conditions’
[17:41:27.048]   - Field: ‘expr’
[17:41:27.048]   - Field: ‘uuid’
[17:41:27.048]   - Field: ‘seed’
[17:41:27.048]   - Field: ‘version’
[17:41:27.048]   - Field: ‘result’
[17:41:27.048]   - Field: ‘asynchronous’
[17:41:27.048]   - Field: ‘calls’
[17:41:27.048]   - Field: ‘globals’
[17:41:27.048]   - Field: ‘stdout’
[17:41:27.048]   - Field: ‘earlySignal’
[17:41:27.049]   - Field: ‘lazy’
[17:41:27.049]   - Field: ‘state’
[17:41:27.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.049] - Launch lazy future ...
[17:41:27.049] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.050] Packages needed by future strategies (n = 0): <none>
[17:41:27.050] {
[17:41:27.050]     {
[17:41:27.050]         {
[17:41:27.050]             ...future.startTime <- base::Sys.time()
[17:41:27.050]             {
[17:41:27.050]                 {
[17:41:27.050]                   {
[17:41:27.050]                     {
[17:41:27.050]                       base::local({
[17:41:27.050]                         has_future <- base::requireNamespace("future", 
[17:41:27.050]                           quietly = TRUE)
[17:41:27.050]                         if (has_future) {
[17:41:27.050]                           ns <- base::getNamespace("future")
[17:41:27.050]                           version <- ns[[".package"]][["version"]]
[17:41:27.050]                           if (is.null(version)) 
[17:41:27.050]                             version <- utils::packageVersion("future")
[17:41:27.050]                         }
[17:41:27.050]                         else {
[17:41:27.050]                           version <- NULL
[17:41:27.050]                         }
[17:41:27.050]                         if (!has_future || version < "1.8.0") {
[17:41:27.050]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.050]                             "", base::R.version$version.string), 
[17:41:27.050]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.050]                               "release", "version")], collapse = " "), 
[17:41:27.050]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.050]                             info)
[17:41:27.050]                           info <- base::paste(info, collapse = "; ")
[17:41:27.050]                           if (!has_future) {
[17:41:27.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.050]                               info)
[17:41:27.050]                           }
[17:41:27.050]                           else {
[17:41:27.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.050]                               info, version)
[17:41:27.050]                           }
[17:41:27.050]                           base::stop(msg)
[17:41:27.050]                         }
[17:41:27.050]                       })
[17:41:27.050]                     }
[17:41:27.050]                     base::local({
[17:41:27.050]                       for (pkg in "utils") {
[17:41:27.050]                         base::loadNamespace(pkg)
[17:41:27.050]                         base::library(pkg, character.only = TRUE)
[17:41:27.050]                       }
[17:41:27.050]                     })
[17:41:27.050]                   }
[17:41:27.050]                   ...future.strategy.old <- future::plan("list")
[17:41:27.050]                   options(future.plan = NULL)
[17:41:27.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.050]                 }
[17:41:27.050]                 ...future.workdir <- getwd()
[17:41:27.050]             }
[17:41:27.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.050]         }
[17:41:27.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.050]             base::names(...future.oldOptions))
[17:41:27.050]     }
[17:41:27.050]     if (FALSE) {
[17:41:27.050]     }
[17:41:27.050]     else {
[17:41:27.050]         if (TRUE) {
[17:41:27.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.050]                 open = "w")
[17:41:27.050]         }
[17:41:27.050]         else {
[17:41:27.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.050]         }
[17:41:27.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.050]             base::sink(type = "output", split = FALSE)
[17:41:27.050]             base::close(...future.stdout)
[17:41:27.050]         }, add = TRUE)
[17:41:27.050]     }
[17:41:27.050]     ...future.frame <- base::sys.nframe()
[17:41:27.050]     ...future.conditions <- base::list()
[17:41:27.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.050]     if (FALSE) {
[17:41:27.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.050]     }
[17:41:27.050]     ...future.result <- base::tryCatch({
[17:41:27.050]         base::withCallingHandlers({
[17:41:27.050]             ...future.value <- base::withVisible(base::local({
[17:41:27.050]                 print(1:50)
[17:41:27.050]                 str(1:50)
[17:41:27.050]                 cat(letters, sep = "-")
[17:41:27.050]                 cat(1:6, collapse = "\n")
[17:41:27.050]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.050]                 42L
[17:41:27.050]             }))
[17:41:27.050]             future::FutureResult(value = ...future.value$value, 
[17:41:27.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.050]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.050]                     ...future.globalenv.names))
[17:41:27.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.050]         }, condition = base::local({
[17:41:27.050]             c <- base::c
[17:41:27.050]             inherits <- base::inherits
[17:41:27.050]             invokeRestart <- base::invokeRestart
[17:41:27.050]             length <- base::length
[17:41:27.050]             list <- base::list
[17:41:27.050]             seq.int <- base::seq.int
[17:41:27.050]             signalCondition <- base::signalCondition
[17:41:27.050]             sys.calls <- base::sys.calls
[17:41:27.050]             `[[` <- base::`[[`
[17:41:27.050]             `+` <- base::`+`
[17:41:27.050]             `<<-` <- base::`<<-`
[17:41:27.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.050]                   3L)]
[17:41:27.050]             }
[17:41:27.050]             function(cond) {
[17:41:27.050]                 is_error <- inherits(cond, "error")
[17:41:27.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.050]                   NULL)
[17:41:27.050]                 if (is_error) {
[17:41:27.050]                   sessionInformation <- function() {
[17:41:27.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.050]                       search = base::search(), system = base::Sys.info())
[17:41:27.050]                   }
[17:41:27.050]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.050]                     cond$call), session = sessionInformation(), 
[17:41:27.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.050]                   signalCondition(cond)
[17:41:27.050]                 }
[17:41:27.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.050]                 "immediateCondition"))) {
[17:41:27.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.050]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.050]                   if (TRUE && !signal) {
[17:41:27.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.050]                     {
[17:41:27.050]                       inherits <- base::inherits
[17:41:27.050]                       invokeRestart <- base::invokeRestart
[17:41:27.050]                       is.null <- base::is.null
[17:41:27.050]                       muffled <- FALSE
[17:41:27.050]                       if (inherits(cond, "message")) {
[17:41:27.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.050]                         if (muffled) 
[17:41:27.050]                           invokeRestart("muffleMessage")
[17:41:27.050]                       }
[17:41:27.050]                       else if (inherits(cond, "warning")) {
[17:41:27.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.050]                         if (muffled) 
[17:41:27.050]                           invokeRestart("muffleWarning")
[17:41:27.050]                       }
[17:41:27.050]                       else if (inherits(cond, "condition")) {
[17:41:27.050]                         if (!is.null(pattern)) {
[17:41:27.050]                           computeRestarts <- base::computeRestarts
[17:41:27.050]                           grepl <- base::grepl
[17:41:27.050]                           restarts <- computeRestarts(cond)
[17:41:27.050]                           for (restart in restarts) {
[17:41:27.050]                             name <- restart$name
[17:41:27.050]                             if (is.null(name)) 
[17:41:27.050]                               next
[17:41:27.050]                             if (!grepl(pattern, name)) 
[17:41:27.050]                               next
[17:41:27.050]                             invokeRestart(restart)
[17:41:27.050]                             muffled <- TRUE
[17:41:27.050]                             break
[17:41:27.050]                           }
[17:41:27.050]                         }
[17:41:27.050]                       }
[17:41:27.050]                       invisible(muffled)
[17:41:27.050]                     }
[17:41:27.050]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.050]                   }
[17:41:27.050]                 }
[17:41:27.050]                 else {
[17:41:27.050]                   if (TRUE) {
[17:41:27.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.050]                     {
[17:41:27.050]                       inherits <- base::inherits
[17:41:27.050]                       invokeRestart <- base::invokeRestart
[17:41:27.050]                       is.null <- base::is.null
[17:41:27.050]                       muffled <- FALSE
[17:41:27.050]                       if (inherits(cond, "message")) {
[17:41:27.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.050]                         if (muffled) 
[17:41:27.050]                           invokeRestart("muffleMessage")
[17:41:27.050]                       }
[17:41:27.050]                       else if (inherits(cond, "warning")) {
[17:41:27.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.050]                         if (muffled) 
[17:41:27.050]                           invokeRestart("muffleWarning")
[17:41:27.050]                       }
[17:41:27.050]                       else if (inherits(cond, "condition")) {
[17:41:27.050]                         if (!is.null(pattern)) {
[17:41:27.050]                           computeRestarts <- base::computeRestarts
[17:41:27.050]                           grepl <- base::grepl
[17:41:27.050]                           restarts <- computeRestarts(cond)
[17:41:27.050]                           for (restart in restarts) {
[17:41:27.050]                             name <- restart$name
[17:41:27.050]                             if (is.null(name)) 
[17:41:27.050]                               next
[17:41:27.050]                             if (!grepl(pattern, name)) 
[17:41:27.050]                               next
[17:41:27.050]                             invokeRestart(restart)
[17:41:27.050]                             muffled <- TRUE
[17:41:27.050]                             break
[17:41:27.050]                           }
[17:41:27.050]                         }
[17:41:27.050]                       }
[17:41:27.050]                       invisible(muffled)
[17:41:27.050]                     }
[17:41:27.050]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.050]                   }
[17:41:27.050]                 }
[17:41:27.050]             }
[17:41:27.050]         }))
[17:41:27.050]     }, error = function(ex) {
[17:41:27.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.050]                 ...future.rng), started = ...future.startTime, 
[17:41:27.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.050]             version = "1.8"), class = "FutureResult")
[17:41:27.050]     }, finally = {
[17:41:27.050]         if (!identical(...future.workdir, getwd())) 
[17:41:27.050]             setwd(...future.workdir)
[17:41:27.050]         {
[17:41:27.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.050]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.050]             }
[17:41:27.050]             base::options(...future.oldOptions)
[17:41:27.050]             if (.Platform$OS.type == "windows") {
[17:41:27.050]                 old_names <- names(...future.oldEnvVars)
[17:41:27.050]                 envs <- base::Sys.getenv()
[17:41:27.050]                 names <- names(envs)
[17:41:27.050]                 common <- intersect(names, old_names)
[17:41:27.050]                 added <- setdiff(names, old_names)
[17:41:27.050]                 removed <- setdiff(old_names, names)
[17:41:27.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.050]                   envs[common]]
[17:41:27.050]                 NAMES <- toupper(changed)
[17:41:27.050]                 args <- list()
[17:41:27.050]                 for (kk in seq_along(NAMES)) {
[17:41:27.050]                   name <- changed[[kk]]
[17:41:27.050]                   NAME <- NAMES[[kk]]
[17:41:27.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.050]                     next
[17:41:27.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.050]                 }
[17:41:27.050]                 NAMES <- toupper(added)
[17:41:27.050]                 for (kk in seq_along(NAMES)) {
[17:41:27.050]                   name <- added[[kk]]
[17:41:27.050]                   NAME <- NAMES[[kk]]
[17:41:27.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.050]                     next
[17:41:27.050]                   args[[name]] <- ""
[17:41:27.050]                 }
[17:41:27.050]                 NAMES <- toupper(removed)
[17:41:27.050]                 for (kk in seq_along(NAMES)) {
[17:41:27.050]                   name <- removed[[kk]]
[17:41:27.050]                   NAME <- NAMES[[kk]]
[17:41:27.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.050]                     next
[17:41:27.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.050]                 }
[17:41:27.050]                 if (length(args) > 0) 
[17:41:27.050]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.050]             }
[17:41:27.050]             else {
[17:41:27.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.050]             }
[17:41:27.050]             {
[17:41:27.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.050]                   0L) {
[17:41:27.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.050]                   base::options(opts)
[17:41:27.050]                 }
[17:41:27.050]                 {
[17:41:27.050]                   {
[17:41:27.050]                     NULL
[17:41:27.050]                     RNGkind("Mersenne-Twister")
[17:41:27.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.050]                       inherits = FALSE)
[17:41:27.050]                   }
[17:41:27.050]                   options(future.plan = NULL)
[17:41:27.050]                   if (is.na(NA_character_)) 
[17:41:27.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.050]                     .init = FALSE)
[17:41:27.050]                 }
[17:41:27.050]             }
[17:41:27.050]         }
[17:41:27.050]     })
[17:41:27.050]     if (TRUE) {
[17:41:27.050]         base::sink(type = "output", split = FALSE)
[17:41:27.050]         if (TRUE) {
[17:41:27.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.050]         }
[17:41:27.050]         else {
[17:41:27.050]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.050]         }
[17:41:27.050]         base::close(...future.stdout)
[17:41:27.050]         ...future.stdout <- NULL
[17:41:27.050]     }
[17:41:27.050]     ...future.result$conditions <- ...future.conditions
[17:41:27.050]     ...future.result$finished <- base::Sys.time()
[17:41:27.050]     ...future.result
[17:41:27.050] }
[17:41:27.052] plan(): Setting new future strategy stack:
[17:41:27.052] List of future strategies:
[17:41:27.052] 1. sequential:
[17:41:27.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.052]    - tweaked: FALSE
[17:41:27.052]    - call: NULL
[17:41:27.053] plan(): nbrOfWorkers() = 1
[17:41:27.055] plan(): Setting new future strategy stack:
[17:41:27.055] List of future strategies:
[17:41:27.055] 1. sequential:
[17:41:27.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.055]    - tweaked: FALSE
[17:41:27.055]    - call: plan(strategy)
[17:41:27.055] plan(): nbrOfWorkers() = 1
[17:41:27.055] SequentialFuture started (and completed)
[17:41:27.056] - Launch lazy future ... done
[17:41:27.056] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "46be20ea-7c28-8dd8-7073-e7fc1f24590d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50430
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:26"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003240585 secs (started 2024-12-19 17:41:27.052511)
version: 1.8
[17:41:27.065] getGlobalsAndPackages() ...
[17:41:27.065] Searching for globals...
[17:41:27.068] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.068] Searching for globals ... DONE
[17:41:27.068] Resolving globals: FALSE
[17:41:27.069] 
[17:41:27.069] - packages: [1] ‘utils’
[17:41:27.069] getGlobalsAndPackages() ... DONE
[17:41:27.069] run() for ‘Future’ ...
[17:41:27.069] - state: ‘created’
[17:41:27.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.069] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.070]   - Field: ‘label’
[17:41:27.070]   - Field: ‘local’
[17:41:27.070]   - Field: ‘owner’
[17:41:27.070]   - Field: ‘envir’
[17:41:27.070]   - Field: ‘packages’
[17:41:27.070]   - Field: ‘gc’
[17:41:27.070]   - Field: ‘conditions’
[17:41:27.070]   - Field: ‘expr’
[17:41:27.070]   - Field: ‘uuid’
[17:41:27.070]   - Field: ‘seed’
[17:41:27.071]   - Field: ‘version’
[17:41:27.071]   - Field: ‘result’
[17:41:27.071]   - Field: ‘asynchronous’
[17:41:27.071]   - Field: ‘calls’
[17:41:27.071]   - Field: ‘globals’
[17:41:27.071]   - Field: ‘stdout’
[17:41:27.071]   - Field: ‘earlySignal’
[17:41:27.071]   - Field: ‘lazy’
[17:41:27.071]   - Field: ‘state’
[17:41:27.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.071] - Launch lazy future ...
[17:41:27.072] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.073] Packages needed by future strategies (n = 0): <none>
[17:41:27.074] {
[17:41:27.074]     {
[17:41:27.074]         {
[17:41:27.074]             ...future.startTime <- base::Sys.time()
[17:41:27.074]             {
[17:41:27.074]                 {
[17:41:27.074]                   {
[17:41:27.074]                     {
[17:41:27.074]                       base::local({
[17:41:27.074]                         has_future <- base::requireNamespace("future", 
[17:41:27.074]                           quietly = TRUE)
[17:41:27.074]                         if (has_future) {
[17:41:27.074]                           ns <- base::getNamespace("future")
[17:41:27.074]                           version <- ns[[".package"]][["version"]]
[17:41:27.074]                           if (is.null(version)) 
[17:41:27.074]                             version <- utils::packageVersion("future")
[17:41:27.074]                         }
[17:41:27.074]                         else {
[17:41:27.074]                           version <- NULL
[17:41:27.074]                         }
[17:41:27.074]                         if (!has_future || version < "1.8.0") {
[17:41:27.074]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.074]                             "", base::R.version$version.string), 
[17:41:27.074]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.074]                               "release", "version")], collapse = " "), 
[17:41:27.074]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.074]                             info)
[17:41:27.074]                           info <- base::paste(info, collapse = "; ")
[17:41:27.074]                           if (!has_future) {
[17:41:27.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.074]                               info)
[17:41:27.074]                           }
[17:41:27.074]                           else {
[17:41:27.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.074]                               info, version)
[17:41:27.074]                           }
[17:41:27.074]                           base::stop(msg)
[17:41:27.074]                         }
[17:41:27.074]                       })
[17:41:27.074]                     }
[17:41:27.074]                     base::local({
[17:41:27.074]                       for (pkg in "utils") {
[17:41:27.074]                         base::loadNamespace(pkg)
[17:41:27.074]                         base::library(pkg, character.only = TRUE)
[17:41:27.074]                       }
[17:41:27.074]                     })
[17:41:27.074]                   }
[17:41:27.074]                   ...future.strategy.old <- future::plan("list")
[17:41:27.074]                   options(future.plan = NULL)
[17:41:27.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.074]                 }
[17:41:27.074]                 ...future.workdir <- getwd()
[17:41:27.074]             }
[17:41:27.074]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.074]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.074]         }
[17:41:27.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.074]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.074]             base::names(...future.oldOptions))
[17:41:27.074]     }
[17:41:27.074]     if (FALSE) {
[17:41:27.074]     }
[17:41:27.074]     else {
[17:41:27.074]         if (TRUE) {
[17:41:27.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.074]                 open = "w")
[17:41:27.074]         }
[17:41:27.074]         else {
[17:41:27.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.074]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.074]         }
[17:41:27.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.074]             base::sink(type = "output", split = FALSE)
[17:41:27.074]             base::close(...future.stdout)
[17:41:27.074]         }, add = TRUE)
[17:41:27.074]     }
[17:41:27.074]     ...future.frame <- base::sys.nframe()
[17:41:27.074]     ...future.conditions <- base::list()
[17:41:27.074]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.074]     if (FALSE) {
[17:41:27.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.074]     }
[17:41:27.074]     ...future.result <- base::tryCatch({
[17:41:27.074]         base::withCallingHandlers({
[17:41:27.074]             ...future.value <- base::withVisible(base::local({
[17:41:27.074]                 print(1:50)
[17:41:27.074]                 str(1:50)
[17:41:27.074]                 cat(letters, sep = "-")
[17:41:27.074]                 cat(1:6, collapse = "\n")
[17:41:27.074]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.074]                 42L
[17:41:27.074]             }))
[17:41:27.074]             future::FutureResult(value = ...future.value$value, 
[17:41:27.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.074]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.074]                     ...future.globalenv.names))
[17:41:27.074]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.074]         }, condition = base::local({
[17:41:27.074]             c <- base::c
[17:41:27.074]             inherits <- base::inherits
[17:41:27.074]             invokeRestart <- base::invokeRestart
[17:41:27.074]             length <- base::length
[17:41:27.074]             list <- base::list
[17:41:27.074]             seq.int <- base::seq.int
[17:41:27.074]             signalCondition <- base::signalCondition
[17:41:27.074]             sys.calls <- base::sys.calls
[17:41:27.074]             `[[` <- base::`[[`
[17:41:27.074]             `+` <- base::`+`
[17:41:27.074]             `<<-` <- base::`<<-`
[17:41:27.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.074]                   3L)]
[17:41:27.074]             }
[17:41:27.074]             function(cond) {
[17:41:27.074]                 is_error <- inherits(cond, "error")
[17:41:27.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.074]                   NULL)
[17:41:27.074]                 if (is_error) {
[17:41:27.074]                   sessionInformation <- function() {
[17:41:27.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.074]                       search = base::search(), system = base::Sys.info())
[17:41:27.074]                   }
[17:41:27.074]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.074]                     cond$call), session = sessionInformation(), 
[17:41:27.074]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.074]                   signalCondition(cond)
[17:41:27.074]                 }
[17:41:27.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.074]                 "immediateCondition"))) {
[17:41:27.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.074]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.074]                   if (TRUE && !signal) {
[17:41:27.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.074]                     {
[17:41:27.074]                       inherits <- base::inherits
[17:41:27.074]                       invokeRestart <- base::invokeRestart
[17:41:27.074]                       is.null <- base::is.null
[17:41:27.074]                       muffled <- FALSE
[17:41:27.074]                       if (inherits(cond, "message")) {
[17:41:27.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.074]                         if (muffled) 
[17:41:27.074]                           invokeRestart("muffleMessage")
[17:41:27.074]                       }
[17:41:27.074]                       else if (inherits(cond, "warning")) {
[17:41:27.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.074]                         if (muffled) 
[17:41:27.074]                           invokeRestart("muffleWarning")
[17:41:27.074]                       }
[17:41:27.074]                       else if (inherits(cond, "condition")) {
[17:41:27.074]                         if (!is.null(pattern)) {
[17:41:27.074]                           computeRestarts <- base::computeRestarts
[17:41:27.074]                           grepl <- base::grepl
[17:41:27.074]                           restarts <- computeRestarts(cond)
[17:41:27.074]                           for (restart in restarts) {
[17:41:27.074]                             name <- restart$name
[17:41:27.074]                             if (is.null(name)) 
[17:41:27.074]                               next
[17:41:27.074]                             if (!grepl(pattern, name)) 
[17:41:27.074]                               next
[17:41:27.074]                             invokeRestart(restart)
[17:41:27.074]                             muffled <- TRUE
[17:41:27.074]                             break
[17:41:27.074]                           }
[17:41:27.074]                         }
[17:41:27.074]                       }
[17:41:27.074]                       invisible(muffled)
[17:41:27.074]                     }
[17:41:27.074]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.074]                   }
[17:41:27.074]                 }
[17:41:27.074]                 else {
[17:41:27.074]                   if (TRUE) {
[17:41:27.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.074]                     {
[17:41:27.074]                       inherits <- base::inherits
[17:41:27.074]                       invokeRestart <- base::invokeRestart
[17:41:27.074]                       is.null <- base::is.null
[17:41:27.074]                       muffled <- FALSE
[17:41:27.074]                       if (inherits(cond, "message")) {
[17:41:27.074]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.074]                         if (muffled) 
[17:41:27.074]                           invokeRestart("muffleMessage")
[17:41:27.074]                       }
[17:41:27.074]                       else if (inherits(cond, "warning")) {
[17:41:27.074]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.074]                         if (muffled) 
[17:41:27.074]                           invokeRestart("muffleWarning")
[17:41:27.074]                       }
[17:41:27.074]                       else if (inherits(cond, "condition")) {
[17:41:27.074]                         if (!is.null(pattern)) {
[17:41:27.074]                           computeRestarts <- base::computeRestarts
[17:41:27.074]                           grepl <- base::grepl
[17:41:27.074]                           restarts <- computeRestarts(cond)
[17:41:27.074]                           for (restart in restarts) {
[17:41:27.074]                             name <- restart$name
[17:41:27.074]                             if (is.null(name)) 
[17:41:27.074]                               next
[17:41:27.074]                             if (!grepl(pattern, name)) 
[17:41:27.074]                               next
[17:41:27.074]                             invokeRestart(restart)
[17:41:27.074]                             muffled <- TRUE
[17:41:27.074]                             break
[17:41:27.074]                           }
[17:41:27.074]                         }
[17:41:27.074]                       }
[17:41:27.074]                       invisible(muffled)
[17:41:27.074]                     }
[17:41:27.074]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.074]                   }
[17:41:27.074]                 }
[17:41:27.074]             }
[17:41:27.074]         }))
[17:41:27.074]     }, error = function(ex) {
[17:41:27.074]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.074]                 ...future.rng), started = ...future.startTime, 
[17:41:27.074]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.074]             version = "1.8"), class = "FutureResult")
[17:41:27.074]     }, finally = {
[17:41:27.074]         if (!identical(...future.workdir, getwd())) 
[17:41:27.074]             setwd(...future.workdir)
[17:41:27.074]         {
[17:41:27.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.074]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.074]             }
[17:41:27.074]             base::options(...future.oldOptions)
[17:41:27.074]             if (.Platform$OS.type == "windows") {
[17:41:27.074]                 old_names <- names(...future.oldEnvVars)
[17:41:27.074]                 envs <- base::Sys.getenv()
[17:41:27.074]                 names <- names(envs)
[17:41:27.074]                 common <- intersect(names, old_names)
[17:41:27.074]                 added <- setdiff(names, old_names)
[17:41:27.074]                 removed <- setdiff(old_names, names)
[17:41:27.074]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.074]                   envs[common]]
[17:41:27.074]                 NAMES <- toupper(changed)
[17:41:27.074]                 args <- list()
[17:41:27.074]                 for (kk in seq_along(NAMES)) {
[17:41:27.074]                   name <- changed[[kk]]
[17:41:27.074]                   NAME <- NAMES[[kk]]
[17:41:27.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.074]                     next
[17:41:27.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.074]                 }
[17:41:27.074]                 NAMES <- toupper(added)
[17:41:27.074]                 for (kk in seq_along(NAMES)) {
[17:41:27.074]                   name <- added[[kk]]
[17:41:27.074]                   NAME <- NAMES[[kk]]
[17:41:27.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.074]                     next
[17:41:27.074]                   args[[name]] <- ""
[17:41:27.074]                 }
[17:41:27.074]                 NAMES <- toupper(removed)
[17:41:27.074]                 for (kk in seq_along(NAMES)) {
[17:41:27.074]                   name <- removed[[kk]]
[17:41:27.074]                   NAME <- NAMES[[kk]]
[17:41:27.074]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.074]                     next
[17:41:27.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.074]                 }
[17:41:27.074]                 if (length(args) > 0) 
[17:41:27.074]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.074]             }
[17:41:27.074]             else {
[17:41:27.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.074]             }
[17:41:27.074]             {
[17:41:27.074]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.074]                   0L) {
[17:41:27.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.074]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.074]                   base::options(opts)
[17:41:27.074]                 }
[17:41:27.074]                 {
[17:41:27.074]                   {
[17:41:27.074]                     NULL
[17:41:27.074]                     RNGkind("Mersenne-Twister")
[17:41:27.074]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.074]                       inherits = FALSE)
[17:41:27.074]                   }
[17:41:27.074]                   options(future.plan = NULL)
[17:41:27.074]                   if (is.na(NA_character_)) 
[17:41:27.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.074]                     .init = FALSE)
[17:41:27.074]                 }
[17:41:27.074]             }
[17:41:27.074]         }
[17:41:27.074]     })
[17:41:27.074]     if (TRUE) {
[17:41:27.074]         base::sink(type = "output", split = FALSE)
[17:41:27.074]         if (TRUE) {
[17:41:27.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.074]         }
[17:41:27.074]         else {
[17:41:27.074]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.074]         }
[17:41:27.074]         base::close(...future.stdout)
[17:41:27.074]         ...future.stdout <- NULL
[17:41:27.074]     }
[17:41:27.074]     ...future.result$conditions <- ...future.conditions
[17:41:27.074]     ...future.result$finished <- base::Sys.time()
[17:41:27.074]     ...future.result
[17:41:27.074] }
[17:41:27.075] plan(): Setting new future strategy stack:
[17:41:27.075] List of future strategies:
[17:41:27.075] 1. sequential:
[17:41:27.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.075]    - tweaked: FALSE
[17:41:27.075]    - call: NULL
[17:41:27.076] plan(): nbrOfWorkers() = 1
[17:41:27.077] plan(): Setting new future strategy stack:
[17:41:27.077] List of future strategies:
[17:41:27.077] 1. sequential:
[17:41:27.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.077]    - tweaked: FALSE
[17:41:27.077]    - call: plan(strategy)
[17:41:27.078] plan(): nbrOfWorkers() = 1
[17:41:27.078] SequentialFuture started (and completed)
[17:41:27.078] - Launch lazy future ... done
[17:41:27.078] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.079] getGlobalsAndPackages() ...
[17:41:27.079] Searching for globals...
[17:41:27.079] - globals found: [1] ‘print’
[17:41:27.079] Searching for globals ... DONE
[17:41:27.079] Resolving globals: FALSE
[17:41:27.080] 
[17:41:27.080] 
[17:41:27.080] getGlobalsAndPackages() ... DONE
[17:41:27.080] run() for ‘Future’ ...
[17:41:27.080] - state: ‘created’
[17:41:27.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.081]   - Field: ‘label’
[17:41:27.081]   - Field: ‘local’
[17:41:27.081]   - Field: ‘owner’
[17:41:27.081]   - Field: ‘envir’
[17:41:27.081]   - Field: ‘packages’
[17:41:27.081]   - Field: ‘gc’
[17:41:27.081]   - Field: ‘conditions’
[17:41:27.081]   - Field: ‘expr’
[17:41:27.081]   - Field: ‘uuid’
[17:41:27.081]   - Field: ‘seed’
[17:41:27.082]   - Field: ‘version’
[17:41:27.082]   - Field: ‘result’
[17:41:27.082]   - Field: ‘asynchronous’
[17:41:27.082]   - Field: ‘calls’
[17:41:27.082]   - Field: ‘globals’
[17:41:27.082]   - Field: ‘stdout’
[17:41:27.082]   - Field: ‘earlySignal’
[17:41:27.082]   - Field: ‘lazy’
[17:41:27.082]   - Field: ‘state’
[17:41:27.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.082] - Launch lazy future ...
[17:41:27.083] Packages needed by the future expression (n = 0): <none>
[17:41:27.083] Packages needed by future strategies (n = 0): <none>
[17:41:27.083] {
[17:41:27.083]     {
[17:41:27.083]         {
[17:41:27.083]             ...future.startTime <- base::Sys.time()
[17:41:27.083]             {
[17:41:27.083]                 {
[17:41:27.083]                   {
[17:41:27.083]                     base::local({
[17:41:27.083]                       has_future <- base::requireNamespace("future", 
[17:41:27.083]                         quietly = TRUE)
[17:41:27.083]                       if (has_future) {
[17:41:27.083]                         ns <- base::getNamespace("future")
[17:41:27.083]                         version <- ns[[".package"]][["version"]]
[17:41:27.083]                         if (is.null(version)) 
[17:41:27.083]                           version <- utils::packageVersion("future")
[17:41:27.083]                       }
[17:41:27.083]                       else {
[17:41:27.083]                         version <- NULL
[17:41:27.083]                       }
[17:41:27.083]                       if (!has_future || version < "1.8.0") {
[17:41:27.083]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.083]                           "", base::R.version$version.string), 
[17:41:27.083]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:27.083]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.083]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.083]                             "release", "version")], collapse = " "), 
[17:41:27.083]                           hostname = base::Sys.info()[["nodename"]])
[17:41:27.083]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.083]                           info)
[17:41:27.083]                         info <- base::paste(info, collapse = "; ")
[17:41:27.083]                         if (!has_future) {
[17:41:27.083]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.083]                             info)
[17:41:27.083]                         }
[17:41:27.083]                         else {
[17:41:27.083]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.083]                             info, version)
[17:41:27.083]                         }
[17:41:27.083]                         base::stop(msg)
[17:41:27.083]                       }
[17:41:27.083]                     })
[17:41:27.083]                   }
[17:41:27.083]                   ...future.strategy.old <- future::plan("list")
[17:41:27.083]                   options(future.plan = NULL)
[17:41:27.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.083]                 }
[17:41:27.083]                 ...future.workdir <- getwd()
[17:41:27.083]             }
[17:41:27.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.083]         }
[17:41:27.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.083]             base::names(...future.oldOptions))
[17:41:27.083]     }
[17:41:27.083]     if (FALSE) {
[17:41:27.083]     }
[17:41:27.083]     else {
[17:41:27.083]         if (TRUE) {
[17:41:27.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.083]                 open = "w")
[17:41:27.083]         }
[17:41:27.083]         else {
[17:41:27.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.083]         }
[17:41:27.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.083]             base::sink(type = "output", split = FALSE)
[17:41:27.083]             base::close(...future.stdout)
[17:41:27.083]         }, add = TRUE)
[17:41:27.083]     }
[17:41:27.083]     ...future.frame <- base::sys.nframe()
[17:41:27.083]     ...future.conditions <- base::list()
[17:41:27.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.083]     if (FALSE) {
[17:41:27.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.083]     }
[17:41:27.083]     ...future.result <- base::tryCatch({
[17:41:27.083]         base::withCallingHandlers({
[17:41:27.083]             ...future.value <- base::withVisible(base::local(print(42)))
[17:41:27.083]             future::FutureResult(value = ...future.value$value, 
[17:41:27.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.083]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.083]                     ...future.globalenv.names))
[17:41:27.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.083]         }, condition = base::local({
[17:41:27.083]             c <- base::c
[17:41:27.083]             inherits <- base::inherits
[17:41:27.083]             invokeRestart <- base::invokeRestart
[17:41:27.083]             length <- base::length
[17:41:27.083]             list <- base::list
[17:41:27.083]             seq.int <- base::seq.int
[17:41:27.083]             signalCondition <- base::signalCondition
[17:41:27.083]             sys.calls <- base::sys.calls
[17:41:27.083]             `[[` <- base::`[[`
[17:41:27.083]             `+` <- base::`+`
[17:41:27.083]             `<<-` <- base::`<<-`
[17:41:27.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.083]                   3L)]
[17:41:27.083]             }
[17:41:27.083]             function(cond) {
[17:41:27.083]                 is_error <- inherits(cond, "error")
[17:41:27.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.083]                   NULL)
[17:41:27.083]                 if (is_error) {
[17:41:27.083]                   sessionInformation <- function() {
[17:41:27.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.083]                       search = base::search(), system = base::Sys.info())
[17:41:27.083]                   }
[17:41:27.083]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.083]                     cond$call), session = sessionInformation(), 
[17:41:27.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.083]                   signalCondition(cond)
[17:41:27.083]                 }
[17:41:27.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.083]                 "immediateCondition"))) {
[17:41:27.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.083]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.083]                   if (TRUE && !signal) {
[17:41:27.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.083]                     {
[17:41:27.083]                       inherits <- base::inherits
[17:41:27.083]                       invokeRestart <- base::invokeRestart
[17:41:27.083]                       is.null <- base::is.null
[17:41:27.083]                       muffled <- FALSE
[17:41:27.083]                       if (inherits(cond, "message")) {
[17:41:27.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.083]                         if (muffled) 
[17:41:27.083]                           invokeRestart("muffleMessage")
[17:41:27.083]                       }
[17:41:27.083]                       else if (inherits(cond, "warning")) {
[17:41:27.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.083]                         if (muffled) 
[17:41:27.083]                           invokeRestart("muffleWarning")
[17:41:27.083]                       }
[17:41:27.083]                       else if (inherits(cond, "condition")) {
[17:41:27.083]                         if (!is.null(pattern)) {
[17:41:27.083]                           computeRestarts <- base::computeRestarts
[17:41:27.083]                           grepl <- base::grepl
[17:41:27.083]                           restarts <- computeRestarts(cond)
[17:41:27.083]                           for (restart in restarts) {
[17:41:27.083]                             name <- restart$name
[17:41:27.083]                             if (is.null(name)) 
[17:41:27.083]                               next
[17:41:27.083]                             if (!grepl(pattern, name)) 
[17:41:27.083]                               next
[17:41:27.083]                             invokeRestart(restart)
[17:41:27.083]                             muffled <- TRUE
[17:41:27.083]                             break
[17:41:27.083]                           }
[17:41:27.083]                         }
[17:41:27.083]                       }
[17:41:27.083]                       invisible(muffled)
[17:41:27.083]                     }
[17:41:27.083]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.083]                   }
[17:41:27.083]                 }
[17:41:27.083]                 else {
[17:41:27.083]                   if (TRUE) {
[17:41:27.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.083]                     {
[17:41:27.083]                       inherits <- base::inherits
[17:41:27.083]                       invokeRestart <- base::invokeRestart
[17:41:27.083]                       is.null <- base::is.null
[17:41:27.083]                       muffled <- FALSE
[17:41:27.083]                       if (inherits(cond, "message")) {
[17:41:27.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.083]                         if (muffled) 
[17:41:27.083]                           invokeRestart("muffleMessage")
[17:41:27.083]                       }
[17:41:27.083]                       else if (inherits(cond, "warning")) {
[17:41:27.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.083]                         if (muffled) 
[17:41:27.083]                           invokeRestart("muffleWarning")
[17:41:27.083]                       }
[17:41:27.083]                       else if (inherits(cond, "condition")) {
[17:41:27.083]                         if (!is.null(pattern)) {
[17:41:27.083]                           computeRestarts <- base::computeRestarts
[17:41:27.083]                           grepl <- base::grepl
[17:41:27.083]                           restarts <- computeRestarts(cond)
[17:41:27.083]                           for (restart in restarts) {
[17:41:27.083]                             name <- restart$name
[17:41:27.083]                             if (is.null(name)) 
[17:41:27.083]                               next
[17:41:27.083]                             if (!grepl(pattern, name)) 
[17:41:27.083]                               next
[17:41:27.083]                             invokeRestart(restart)
[17:41:27.083]                             muffled <- TRUE
[17:41:27.083]                             break
[17:41:27.083]                           }
[17:41:27.083]                         }
[17:41:27.083]                       }
[17:41:27.083]                       invisible(muffled)
[17:41:27.083]                     }
[17:41:27.083]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.083]                   }
[17:41:27.083]                 }
[17:41:27.083]             }
[17:41:27.083]         }))
[17:41:27.083]     }, error = function(ex) {
[17:41:27.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.083]                 ...future.rng), started = ...future.startTime, 
[17:41:27.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.083]             version = "1.8"), class = "FutureResult")
[17:41:27.083]     }, finally = {
[17:41:27.083]         if (!identical(...future.workdir, getwd())) 
[17:41:27.083]             setwd(...future.workdir)
[17:41:27.083]         {
[17:41:27.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.083]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.083]             }
[17:41:27.083]             base::options(...future.oldOptions)
[17:41:27.083]             if (.Platform$OS.type == "windows") {
[17:41:27.083]                 old_names <- names(...future.oldEnvVars)
[17:41:27.083]                 envs <- base::Sys.getenv()
[17:41:27.083]                 names <- names(envs)
[17:41:27.083]                 common <- intersect(names, old_names)
[17:41:27.083]                 added <- setdiff(names, old_names)
[17:41:27.083]                 removed <- setdiff(old_names, names)
[17:41:27.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.083]                   envs[common]]
[17:41:27.083]                 NAMES <- toupper(changed)
[17:41:27.083]                 args <- list()
[17:41:27.083]                 for (kk in seq_along(NAMES)) {
[17:41:27.083]                   name <- changed[[kk]]
[17:41:27.083]                   NAME <- NAMES[[kk]]
[17:41:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.083]                     next
[17:41:27.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.083]                 }
[17:41:27.083]                 NAMES <- toupper(added)
[17:41:27.083]                 for (kk in seq_along(NAMES)) {
[17:41:27.083]                   name <- added[[kk]]
[17:41:27.083]                   NAME <- NAMES[[kk]]
[17:41:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.083]                     next
[17:41:27.083]                   args[[name]] <- ""
[17:41:27.083]                 }
[17:41:27.083]                 NAMES <- toupper(removed)
[17:41:27.083]                 for (kk in seq_along(NAMES)) {
[17:41:27.083]                   name <- removed[[kk]]
[17:41:27.083]                   NAME <- NAMES[[kk]]
[17:41:27.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.083]                     next
[17:41:27.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.083]                 }
[17:41:27.083]                 if (length(args) > 0) 
[17:41:27.083]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.083]             }
[17:41:27.083]             else {
[17:41:27.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.083]             }
[17:41:27.083]             {
[17:41:27.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.083]                   0L) {
[17:41:27.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.083]                   base::options(opts)
[17:41:27.083]                 }
[17:41:27.083]                 {
[17:41:27.083]                   {
[17:41:27.083]                     NULL
[17:41:27.083]                     RNGkind("Mersenne-Twister")
[17:41:27.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.083]                       inherits = FALSE)
[17:41:27.083]                   }
[17:41:27.083]                   options(future.plan = NULL)
[17:41:27.083]                   if (is.na(NA_character_)) 
[17:41:27.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.083]                     .init = FALSE)
[17:41:27.083]                 }
[17:41:27.083]             }
[17:41:27.083]         }
[17:41:27.083]     })
[17:41:27.083]     if (TRUE) {
[17:41:27.083]         base::sink(type = "output", split = FALSE)
[17:41:27.083]         if (TRUE) {
[17:41:27.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.083]         }
[17:41:27.083]         else {
[17:41:27.083]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.083]         }
[17:41:27.083]         base::close(...future.stdout)
[17:41:27.083]         ...future.stdout <- NULL
[17:41:27.083]     }
[17:41:27.083]     ...future.result$conditions <- ...future.conditions
[17:41:27.083]     ...future.result$finished <- base::Sys.time()
[17:41:27.083]     ...future.result
[17:41:27.083] }
[17:41:27.085] plan(): Setting new future strategy stack:
[17:41:27.085] List of future strategies:
[17:41:27.085] 1. sequential:
[17:41:27.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.085]    - tweaked: FALSE
[17:41:27.085]    - call: NULL
[17:41:27.085] plan(): nbrOfWorkers() = 1
[17:41:27.086] plan(): Setting new future strategy stack:
[17:41:27.086] List of future strategies:
[17:41:27.086] 1. sequential:
[17:41:27.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.086]    - tweaked: FALSE
[17:41:27.086]    - call: plan(strategy)
[17:41:27.086] plan(): nbrOfWorkers() = 1
[17:41:27.086] SequentialFuture started (and completed)
[17:41:27.087] - Launch lazy future ... done
[17:41:27.087] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[17:41:27.087] getGlobalsAndPackages() ...
[17:41:27.087] Searching for globals...
[17:41:27.090] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.090] Searching for globals ... DONE
[17:41:27.090] Resolving globals: FALSE
[17:41:27.090] 
[17:41:27.090] - packages: [1] ‘utils’
[17:41:27.090] getGlobalsAndPackages() ... DONE
[17:41:27.091] run() for ‘Future’ ...
[17:41:27.091] - state: ‘created’
[17:41:27.091] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.091] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.091]   - Field: ‘label’
[17:41:27.091]   - Field: ‘local’
[17:41:27.091]   - Field: ‘owner’
[17:41:27.092]   - Field: ‘envir’
[17:41:27.092]   - Field: ‘packages’
[17:41:27.092]   - Field: ‘gc’
[17:41:27.092]   - Field: ‘conditions’
[17:41:27.092]   - Field: ‘expr’
[17:41:27.092]   - Field: ‘uuid’
[17:41:27.092]   - Field: ‘seed’
[17:41:27.092]   - Field: ‘version’
[17:41:27.092]   - Field: ‘result’
[17:41:27.092]   - Field: ‘asynchronous’
[17:41:27.092]   - Field: ‘calls’
[17:41:27.093]   - Field: ‘globals’
[17:41:27.093]   - Field: ‘stdout’
[17:41:27.093]   - Field: ‘earlySignal’
[17:41:27.093]   - Field: ‘lazy’
[17:41:27.093]   - Field: ‘state’
[17:41:27.093] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.093] - Launch lazy future ...
[17:41:27.093] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.093] Packages needed by future strategies (n = 0): <none>
[17:41:27.094] {
[17:41:27.094]     {
[17:41:27.094]         {
[17:41:27.094]             ...future.startTime <- base::Sys.time()
[17:41:27.094]             {
[17:41:27.094]                 {
[17:41:27.094]                   {
[17:41:27.094]                     {
[17:41:27.094]                       base::local({
[17:41:27.094]                         has_future <- base::requireNamespace("future", 
[17:41:27.094]                           quietly = TRUE)
[17:41:27.094]                         if (has_future) {
[17:41:27.094]                           ns <- base::getNamespace("future")
[17:41:27.094]                           version <- ns[[".package"]][["version"]]
[17:41:27.094]                           if (is.null(version)) 
[17:41:27.094]                             version <- utils::packageVersion("future")
[17:41:27.094]                         }
[17:41:27.094]                         else {
[17:41:27.094]                           version <- NULL
[17:41:27.094]                         }
[17:41:27.094]                         if (!has_future || version < "1.8.0") {
[17:41:27.094]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.094]                             "", base::R.version$version.string), 
[17:41:27.094]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.094]                               "release", "version")], collapse = " "), 
[17:41:27.094]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.094]                             info)
[17:41:27.094]                           info <- base::paste(info, collapse = "; ")
[17:41:27.094]                           if (!has_future) {
[17:41:27.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.094]                               info)
[17:41:27.094]                           }
[17:41:27.094]                           else {
[17:41:27.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.094]                               info, version)
[17:41:27.094]                           }
[17:41:27.094]                           base::stop(msg)
[17:41:27.094]                         }
[17:41:27.094]                       })
[17:41:27.094]                     }
[17:41:27.094]                     base::local({
[17:41:27.094]                       for (pkg in "utils") {
[17:41:27.094]                         base::loadNamespace(pkg)
[17:41:27.094]                         base::library(pkg, character.only = TRUE)
[17:41:27.094]                       }
[17:41:27.094]                     })
[17:41:27.094]                   }
[17:41:27.094]                   ...future.strategy.old <- future::plan("list")
[17:41:27.094]                   options(future.plan = NULL)
[17:41:27.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.094]                 }
[17:41:27.094]                 ...future.workdir <- getwd()
[17:41:27.094]             }
[17:41:27.094]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.094]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.094]         }
[17:41:27.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.094]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.094]             base::names(...future.oldOptions))
[17:41:27.094]     }
[17:41:27.094]     if (FALSE) {
[17:41:27.094]     }
[17:41:27.094]     else {
[17:41:27.094]         if (FALSE) {
[17:41:27.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.094]                 open = "w")
[17:41:27.094]         }
[17:41:27.094]         else {
[17:41:27.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.094]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.094]         }
[17:41:27.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.094]             base::sink(type = "output", split = FALSE)
[17:41:27.094]             base::close(...future.stdout)
[17:41:27.094]         }, add = TRUE)
[17:41:27.094]     }
[17:41:27.094]     ...future.frame <- base::sys.nframe()
[17:41:27.094]     ...future.conditions <- base::list()
[17:41:27.094]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.094]     if (FALSE) {
[17:41:27.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.094]     }
[17:41:27.094]     ...future.result <- base::tryCatch({
[17:41:27.094]         base::withCallingHandlers({
[17:41:27.094]             ...future.value <- base::withVisible(base::local({
[17:41:27.094]                 print(1:50)
[17:41:27.094]                 str(1:50)
[17:41:27.094]                 cat(letters, sep = "-")
[17:41:27.094]                 cat(1:6, collapse = "\n")
[17:41:27.094]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.094]                 42L
[17:41:27.094]             }))
[17:41:27.094]             future::FutureResult(value = ...future.value$value, 
[17:41:27.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.094]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.094]                     ...future.globalenv.names))
[17:41:27.094]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.094]         }, condition = base::local({
[17:41:27.094]             c <- base::c
[17:41:27.094]             inherits <- base::inherits
[17:41:27.094]             invokeRestart <- base::invokeRestart
[17:41:27.094]             length <- base::length
[17:41:27.094]             list <- base::list
[17:41:27.094]             seq.int <- base::seq.int
[17:41:27.094]             signalCondition <- base::signalCondition
[17:41:27.094]             sys.calls <- base::sys.calls
[17:41:27.094]             `[[` <- base::`[[`
[17:41:27.094]             `+` <- base::`+`
[17:41:27.094]             `<<-` <- base::`<<-`
[17:41:27.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.094]                   3L)]
[17:41:27.094]             }
[17:41:27.094]             function(cond) {
[17:41:27.094]                 is_error <- inherits(cond, "error")
[17:41:27.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.094]                   NULL)
[17:41:27.094]                 if (is_error) {
[17:41:27.094]                   sessionInformation <- function() {
[17:41:27.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.094]                       search = base::search(), system = base::Sys.info())
[17:41:27.094]                   }
[17:41:27.094]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.094]                     cond$call), session = sessionInformation(), 
[17:41:27.094]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.094]                   signalCondition(cond)
[17:41:27.094]                 }
[17:41:27.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.094]                 "immediateCondition"))) {
[17:41:27.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.094]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.094]                   if (TRUE && !signal) {
[17:41:27.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.094]                     {
[17:41:27.094]                       inherits <- base::inherits
[17:41:27.094]                       invokeRestart <- base::invokeRestart
[17:41:27.094]                       is.null <- base::is.null
[17:41:27.094]                       muffled <- FALSE
[17:41:27.094]                       if (inherits(cond, "message")) {
[17:41:27.094]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.094]                         if (muffled) 
[17:41:27.094]                           invokeRestart("muffleMessage")
[17:41:27.094]                       }
[17:41:27.094]                       else if (inherits(cond, "warning")) {
[17:41:27.094]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.094]                         if (muffled) 
[17:41:27.094]                           invokeRestart("muffleWarning")
[17:41:27.094]                       }
[17:41:27.094]                       else if (inherits(cond, "condition")) {
[17:41:27.094]                         if (!is.null(pattern)) {
[17:41:27.094]                           computeRestarts <- base::computeRestarts
[17:41:27.094]                           grepl <- base::grepl
[17:41:27.094]                           restarts <- computeRestarts(cond)
[17:41:27.094]                           for (restart in restarts) {
[17:41:27.094]                             name <- restart$name
[17:41:27.094]                             if (is.null(name)) 
[17:41:27.094]                               next
[17:41:27.094]                             if (!grepl(pattern, name)) 
[17:41:27.094]                               next
[17:41:27.094]                             invokeRestart(restart)
[17:41:27.094]                             muffled <- TRUE
[17:41:27.094]                             break
[17:41:27.094]                           }
[17:41:27.094]                         }
[17:41:27.094]                       }
[17:41:27.094]                       invisible(muffled)
[17:41:27.094]                     }
[17:41:27.094]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.094]                   }
[17:41:27.094]                 }
[17:41:27.094]                 else {
[17:41:27.094]                   if (TRUE) {
[17:41:27.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.094]                     {
[17:41:27.094]                       inherits <- base::inherits
[17:41:27.094]                       invokeRestart <- base::invokeRestart
[17:41:27.094]                       is.null <- base::is.null
[17:41:27.094]                       muffled <- FALSE
[17:41:27.094]                       if (inherits(cond, "message")) {
[17:41:27.094]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.094]                         if (muffled) 
[17:41:27.094]                           invokeRestart("muffleMessage")
[17:41:27.094]                       }
[17:41:27.094]                       else if (inherits(cond, "warning")) {
[17:41:27.094]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.094]                         if (muffled) 
[17:41:27.094]                           invokeRestart("muffleWarning")
[17:41:27.094]                       }
[17:41:27.094]                       else if (inherits(cond, "condition")) {
[17:41:27.094]                         if (!is.null(pattern)) {
[17:41:27.094]                           computeRestarts <- base::computeRestarts
[17:41:27.094]                           grepl <- base::grepl
[17:41:27.094]                           restarts <- computeRestarts(cond)
[17:41:27.094]                           for (restart in restarts) {
[17:41:27.094]                             name <- restart$name
[17:41:27.094]                             if (is.null(name)) 
[17:41:27.094]                               next
[17:41:27.094]                             if (!grepl(pattern, name)) 
[17:41:27.094]                               next
[17:41:27.094]                             invokeRestart(restart)
[17:41:27.094]                             muffled <- TRUE
[17:41:27.094]                             break
[17:41:27.094]                           }
[17:41:27.094]                         }
[17:41:27.094]                       }
[17:41:27.094]                       invisible(muffled)
[17:41:27.094]                     }
[17:41:27.094]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.094]                   }
[17:41:27.094]                 }
[17:41:27.094]             }
[17:41:27.094]         }))
[17:41:27.094]     }, error = function(ex) {
[17:41:27.094]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.094]                 ...future.rng), started = ...future.startTime, 
[17:41:27.094]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.094]             version = "1.8"), class = "FutureResult")
[17:41:27.094]     }, finally = {
[17:41:27.094]         if (!identical(...future.workdir, getwd())) 
[17:41:27.094]             setwd(...future.workdir)
[17:41:27.094]         {
[17:41:27.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.094]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.094]             }
[17:41:27.094]             base::options(...future.oldOptions)
[17:41:27.094]             if (.Platform$OS.type == "windows") {
[17:41:27.094]                 old_names <- names(...future.oldEnvVars)
[17:41:27.094]                 envs <- base::Sys.getenv()
[17:41:27.094]                 names <- names(envs)
[17:41:27.094]                 common <- intersect(names, old_names)
[17:41:27.094]                 added <- setdiff(names, old_names)
[17:41:27.094]                 removed <- setdiff(old_names, names)
[17:41:27.094]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.094]                   envs[common]]
[17:41:27.094]                 NAMES <- toupper(changed)
[17:41:27.094]                 args <- list()
[17:41:27.094]                 for (kk in seq_along(NAMES)) {
[17:41:27.094]                   name <- changed[[kk]]
[17:41:27.094]                   NAME <- NAMES[[kk]]
[17:41:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.094]                     next
[17:41:27.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.094]                 }
[17:41:27.094]                 NAMES <- toupper(added)
[17:41:27.094]                 for (kk in seq_along(NAMES)) {
[17:41:27.094]                   name <- added[[kk]]
[17:41:27.094]                   NAME <- NAMES[[kk]]
[17:41:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.094]                     next
[17:41:27.094]                   args[[name]] <- ""
[17:41:27.094]                 }
[17:41:27.094]                 NAMES <- toupper(removed)
[17:41:27.094]                 for (kk in seq_along(NAMES)) {
[17:41:27.094]                   name <- removed[[kk]]
[17:41:27.094]                   NAME <- NAMES[[kk]]
[17:41:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.094]                     next
[17:41:27.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.094]                 }
[17:41:27.094]                 if (length(args) > 0) 
[17:41:27.094]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.094]             }
[17:41:27.094]             else {
[17:41:27.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.094]             }
[17:41:27.094]             {
[17:41:27.094]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.094]                   0L) {
[17:41:27.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.094]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.094]                   base::options(opts)
[17:41:27.094]                 }
[17:41:27.094]                 {
[17:41:27.094]                   {
[17:41:27.094]                     NULL
[17:41:27.094]                     RNGkind("Mersenne-Twister")
[17:41:27.094]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.094]                       inherits = FALSE)
[17:41:27.094]                   }
[17:41:27.094]                   options(future.plan = NULL)
[17:41:27.094]                   if (is.na(NA_character_)) 
[17:41:27.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.094]                     .init = FALSE)
[17:41:27.094]                 }
[17:41:27.094]             }
[17:41:27.094]         }
[17:41:27.094]     })
[17:41:27.094]     if (TRUE) {
[17:41:27.094]         base::sink(type = "output", split = FALSE)
[17:41:27.094]         if (FALSE) {
[17:41:27.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.094]         }
[17:41:27.094]         else {
[17:41:27.094]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.094]         }
[17:41:27.094]         base::close(...future.stdout)
[17:41:27.094]         ...future.stdout <- NULL
[17:41:27.094]     }
[17:41:27.094]     ...future.result$conditions <- ...future.conditions
[17:41:27.094]     ...future.result$finished <- base::Sys.time()
[17:41:27.094]     ...future.result
[17:41:27.094] }
[17:41:27.096] plan(): Setting new future strategy stack:
[17:41:27.096] List of future strategies:
[17:41:27.096] 1. sequential:
[17:41:27.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.096]    - tweaked: FALSE
[17:41:27.096]    - call: NULL
[17:41:27.096] plan(): nbrOfWorkers() = 1
[17:41:27.097] plan(): Setting new future strategy stack:
[17:41:27.097] List of future strategies:
[17:41:27.097] 1. sequential:
[17:41:27.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.097]    - tweaked: FALSE
[17:41:27.097]    - call: plan(strategy)
[17:41:27.098] plan(): nbrOfWorkers() = 1
[17:41:27.098] SequentialFuture started (and completed)
[17:41:27.098] - Launch lazy future ... done
[17:41:27.098] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "46be20ea-7c28-8dd8-7073-e7fc1f24590d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50430
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:26"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:27.106] getGlobalsAndPackages() ...
[17:41:27.107] Searching for globals...
[17:41:27.109] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.109] Searching for globals ... DONE
[17:41:27.110] Resolving globals: FALSE
[17:41:27.110] 
[17:41:27.110] - packages: [1] ‘utils’
[17:41:27.110] getGlobalsAndPackages() ... DONE
[17:41:27.111] run() for ‘Future’ ...
[17:41:27.111] - state: ‘created’
[17:41:27.111] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.112]   - Field: ‘label’
[17:41:27.112]   - Field: ‘local’
[17:41:27.112]   - Field: ‘owner’
[17:41:27.112]   - Field: ‘envir’
[17:41:27.112]   - Field: ‘packages’
[17:41:27.112]   - Field: ‘gc’
[17:41:27.112]   - Field: ‘conditions’
[17:41:27.112]   - Field: ‘expr’
[17:41:27.112]   - Field: ‘uuid’
[17:41:27.112]   - Field: ‘seed’
[17:41:27.112]   - Field: ‘version’
[17:41:27.113]   - Field: ‘result’
[17:41:27.113]   - Field: ‘asynchronous’
[17:41:27.113]   - Field: ‘calls’
[17:41:27.113]   - Field: ‘globals’
[17:41:27.113]   - Field: ‘stdout’
[17:41:27.113]   - Field: ‘earlySignal’
[17:41:27.113]   - Field: ‘lazy’
[17:41:27.113]   - Field: ‘state’
[17:41:27.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.113] - Launch lazy future ...
[17:41:27.114] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.114] Packages needed by future strategies (n = 0): <none>
[17:41:27.114] {
[17:41:27.114]     {
[17:41:27.114]         {
[17:41:27.114]             ...future.startTime <- base::Sys.time()
[17:41:27.114]             {
[17:41:27.114]                 {
[17:41:27.114]                   {
[17:41:27.114]                     {
[17:41:27.114]                       base::local({
[17:41:27.114]                         has_future <- base::requireNamespace("future", 
[17:41:27.114]                           quietly = TRUE)
[17:41:27.114]                         if (has_future) {
[17:41:27.114]                           ns <- base::getNamespace("future")
[17:41:27.114]                           version <- ns[[".package"]][["version"]]
[17:41:27.114]                           if (is.null(version)) 
[17:41:27.114]                             version <- utils::packageVersion("future")
[17:41:27.114]                         }
[17:41:27.114]                         else {
[17:41:27.114]                           version <- NULL
[17:41:27.114]                         }
[17:41:27.114]                         if (!has_future || version < "1.8.0") {
[17:41:27.114]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.114]                             "", base::R.version$version.string), 
[17:41:27.114]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.114]                               "release", "version")], collapse = " "), 
[17:41:27.114]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.114]                             info)
[17:41:27.114]                           info <- base::paste(info, collapse = "; ")
[17:41:27.114]                           if (!has_future) {
[17:41:27.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.114]                               info)
[17:41:27.114]                           }
[17:41:27.114]                           else {
[17:41:27.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.114]                               info, version)
[17:41:27.114]                           }
[17:41:27.114]                           base::stop(msg)
[17:41:27.114]                         }
[17:41:27.114]                       })
[17:41:27.114]                     }
[17:41:27.114]                     base::local({
[17:41:27.114]                       for (pkg in "utils") {
[17:41:27.114]                         base::loadNamespace(pkg)
[17:41:27.114]                         base::library(pkg, character.only = TRUE)
[17:41:27.114]                       }
[17:41:27.114]                     })
[17:41:27.114]                   }
[17:41:27.114]                   ...future.strategy.old <- future::plan("list")
[17:41:27.114]                   options(future.plan = NULL)
[17:41:27.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.114]                 }
[17:41:27.114]                 ...future.workdir <- getwd()
[17:41:27.114]             }
[17:41:27.114]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.114]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.114]         }
[17:41:27.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.114]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.114]             base::names(...future.oldOptions))
[17:41:27.114]     }
[17:41:27.114]     if (FALSE) {
[17:41:27.114]     }
[17:41:27.114]     else {
[17:41:27.114]         if (FALSE) {
[17:41:27.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.114]                 open = "w")
[17:41:27.114]         }
[17:41:27.114]         else {
[17:41:27.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.114]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.114]         }
[17:41:27.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.114]             base::sink(type = "output", split = FALSE)
[17:41:27.114]             base::close(...future.stdout)
[17:41:27.114]         }, add = TRUE)
[17:41:27.114]     }
[17:41:27.114]     ...future.frame <- base::sys.nframe()
[17:41:27.114]     ...future.conditions <- base::list()
[17:41:27.114]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.114]     if (FALSE) {
[17:41:27.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.114]     }
[17:41:27.114]     ...future.result <- base::tryCatch({
[17:41:27.114]         base::withCallingHandlers({
[17:41:27.114]             ...future.value <- base::withVisible(base::local({
[17:41:27.114]                 print(1:50)
[17:41:27.114]                 str(1:50)
[17:41:27.114]                 cat(letters, sep = "-")
[17:41:27.114]                 cat(1:6, collapse = "\n")
[17:41:27.114]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.114]                 42L
[17:41:27.114]             }))
[17:41:27.114]             future::FutureResult(value = ...future.value$value, 
[17:41:27.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.114]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.114]                     ...future.globalenv.names))
[17:41:27.114]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.114]         }, condition = base::local({
[17:41:27.114]             c <- base::c
[17:41:27.114]             inherits <- base::inherits
[17:41:27.114]             invokeRestart <- base::invokeRestart
[17:41:27.114]             length <- base::length
[17:41:27.114]             list <- base::list
[17:41:27.114]             seq.int <- base::seq.int
[17:41:27.114]             signalCondition <- base::signalCondition
[17:41:27.114]             sys.calls <- base::sys.calls
[17:41:27.114]             `[[` <- base::`[[`
[17:41:27.114]             `+` <- base::`+`
[17:41:27.114]             `<<-` <- base::`<<-`
[17:41:27.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.114]                   3L)]
[17:41:27.114]             }
[17:41:27.114]             function(cond) {
[17:41:27.114]                 is_error <- inherits(cond, "error")
[17:41:27.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.114]                   NULL)
[17:41:27.114]                 if (is_error) {
[17:41:27.114]                   sessionInformation <- function() {
[17:41:27.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.114]                       search = base::search(), system = base::Sys.info())
[17:41:27.114]                   }
[17:41:27.114]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.114]                     cond$call), session = sessionInformation(), 
[17:41:27.114]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.114]                   signalCondition(cond)
[17:41:27.114]                 }
[17:41:27.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.114]                 "immediateCondition"))) {
[17:41:27.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.114]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.114]                   if (TRUE && !signal) {
[17:41:27.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.114]                     {
[17:41:27.114]                       inherits <- base::inherits
[17:41:27.114]                       invokeRestart <- base::invokeRestart
[17:41:27.114]                       is.null <- base::is.null
[17:41:27.114]                       muffled <- FALSE
[17:41:27.114]                       if (inherits(cond, "message")) {
[17:41:27.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.114]                         if (muffled) 
[17:41:27.114]                           invokeRestart("muffleMessage")
[17:41:27.114]                       }
[17:41:27.114]                       else if (inherits(cond, "warning")) {
[17:41:27.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.114]                         if (muffled) 
[17:41:27.114]                           invokeRestart("muffleWarning")
[17:41:27.114]                       }
[17:41:27.114]                       else if (inherits(cond, "condition")) {
[17:41:27.114]                         if (!is.null(pattern)) {
[17:41:27.114]                           computeRestarts <- base::computeRestarts
[17:41:27.114]                           grepl <- base::grepl
[17:41:27.114]                           restarts <- computeRestarts(cond)
[17:41:27.114]                           for (restart in restarts) {
[17:41:27.114]                             name <- restart$name
[17:41:27.114]                             if (is.null(name)) 
[17:41:27.114]                               next
[17:41:27.114]                             if (!grepl(pattern, name)) 
[17:41:27.114]                               next
[17:41:27.114]                             invokeRestart(restart)
[17:41:27.114]                             muffled <- TRUE
[17:41:27.114]                             break
[17:41:27.114]                           }
[17:41:27.114]                         }
[17:41:27.114]                       }
[17:41:27.114]                       invisible(muffled)
[17:41:27.114]                     }
[17:41:27.114]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.114]                   }
[17:41:27.114]                 }
[17:41:27.114]                 else {
[17:41:27.114]                   if (TRUE) {
[17:41:27.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.114]                     {
[17:41:27.114]                       inherits <- base::inherits
[17:41:27.114]                       invokeRestart <- base::invokeRestart
[17:41:27.114]                       is.null <- base::is.null
[17:41:27.114]                       muffled <- FALSE
[17:41:27.114]                       if (inherits(cond, "message")) {
[17:41:27.114]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.114]                         if (muffled) 
[17:41:27.114]                           invokeRestart("muffleMessage")
[17:41:27.114]                       }
[17:41:27.114]                       else if (inherits(cond, "warning")) {
[17:41:27.114]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.114]                         if (muffled) 
[17:41:27.114]                           invokeRestart("muffleWarning")
[17:41:27.114]                       }
[17:41:27.114]                       else if (inherits(cond, "condition")) {
[17:41:27.114]                         if (!is.null(pattern)) {
[17:41:27.114]                           computeRestarts <- base::computeRestarts
[17:41:27.114]                           grepl <- base::grepl
[17:41:27.114]                           restarts <- computeRestarts(cond)
[17:41:27.114]                           for (restart in restarts) {
[17:41:27.114]                             name <- restart$name
[17:41:27.114]                             if (is.null(name)) 
[17:41:27.114]                               next
[17:41:27.114]                             if (!grepl(pattern, name)) 
[17:41:27.114]                               next
[17:41:27.114]                             invokeRestart(restart)
[17:41:27.114]                             muffled <- TRUE
[17:41:27.114]                             break
[17:41:27.114]                           }
[17:41:27.114]                         }
[17:41:27.114]                       }
[17:41:27.114]                       invisible(muffled)
[17:41:27.114]                     }
[17:41:27.114]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.114]                   }
[17:41:27.114]                 }
[17:41:27.114]             }
[17:41:27.114]         }))
[17:41:27.114]     }, error = function(ex) {
[17:41:27.114]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.114]                 ...future.rng), started = ...future.startTime, 
[17:41:27.114]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.114]             version = "1.8"), class = "FutureResult")
[17:41:27.114]     }, finally = {
[17:41:27.114]         if (!identical(...future.workdir, getwd())) 
[17:41:27.114]             setwd(...future.workdir)
[17:41:27.114]         {
[17:41:27.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.114]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.114]             }
[17:41:27.114]             base::options(...future.oldOptions)
[17:41:27.114]             if (.Platform$OS.type == "windows") {
[17:41:27.114]                 old_names <- names(...future.oldEnvVars)
[17:41:27.114]                 envs <- base::Sys.getenv()
[17:41:27.114]                 names <- names(envs)
[17:41:27.114]                 common <- intersect(names, old_names)
[17:41:27.114]                 added <- setdiff(names, old_names)
[17:41:27.114]                 removed <- setdiff(old_names, names)
[17:41:27.114]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.114]                   envs[common]]
[17:41:27.114]                 NAMES <- toupper(changed)
[17:41:27.114]                 args <- list()
[17:41:27.114]                 for (kk in seq_along(NAMES)) {
[17:41:27.114]                   name <- changed[[kk]]
[17:41:27.114]                   NAME <- NAMES[[kk]]
[17:41:27.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.114]                     next
[17:41:27.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.114]                 }
[17:41:27.114]                 NAMES <- toupper(added)
[17:41:27.114]                 for (kk in seq_along(NAMES)) {
[17:41:27.114]                   name <- added[[kk]]
[17:41:27.114]                   NAME <- NAMES[[kk]]
[17:41:27.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.114]                     next
[17:41:27.114]                   args[[name]] <- ""
[17:41:27.114]                 }
[17:41:27.114]                 NAMES <- toupper(removed)
[17:41:27.114]                 for (kk in seq_along(NAMES)) {
[17:41:27.114]                   name <- removed[[kk]]
[17:41:27.114]                   NAME <- NAMES[[kk]]
[17:41:27.114]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.114]                     next
[17:41:27.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.114]                 }
[17:41:27.114]                 if (length(args) > 0) 
[17:41:27.114]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.114]             }
[17:41:27.114]             else {
[17:41:27.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.114]             }
[17:41:27.114]             {
[17:41:27.114]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.114]                   0L) {
[17:41:27.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.114]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.114]                   base::options(opts)
[17:41:27.114]                 }
[17:41:27.114]                 {
[17:41:27.114]                   {
[17:41:27.114]                     NULL
[17:41:27.114]                     RNGkind("Mersenne-Twister")
[17:41:27.114]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.114]                       inherits = FALSE)
[17:41:27.114]                   }
[17:41:27.114]                   options(future.plan = NULL)
[17:41:27.114]                   if (is.na(NA_character_)) 
[17:41:27.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.114]                     .init = FALSE)
[17:41:27.114]                 }
[17:41:27.114]             }
[17:41:27.114]         }
[17:41:27.114]     })
[17:41:27.114]     if (TRUE) {
[17:41:27.114]         base::sink(type = "output", split = FALSE)
[17:41:27.114]         if (FALSE) {
[17:41:27.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.114]         }
[17:41:27.114]         else {
[17:41:27.114]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.114]         }
[17:41:27.114]         base::close(...future.stdout)
[17:41:27.114]         ...future.stdout <- NULL
[17:41:27.114]     }
[17:41:27.114]     ...future.result$conditions <- ...future.conditions
[17:41:27.114]     ...future.result$finished <- base::Sys.time()
[17:41:27.114]     ...future.result
[17:41:27.114] }
[17:41:27.116] plan(): Setting new future strategy stack:
[17:41:27.116] List of future strategies:
[17:41:27.116] 1. sequential:
[17:41:27.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.116]    - tweaked: FALSE
[17:41:27.116]    - call: NULL
[17:41:27.117] plan(): nbrOfWorkers() = 1
[17:41:27.118] plan(): Setting new future strategy stack:
[17:41:27.118] List of future strategies:
[17:41:27.118] 1. sequential:
[17:41:27.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.118]    - tweaked: FALSE
[17:41:27.118]    - call: plan(strategy)
[17:41:27.118] plan(): nbrOfWorkers() = 1
[17:41:27.119] SequentialFuture started (and completed)
[17:41:27.119] - Launch lazy future ... done
[17:41:27.119] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.119] getGlobalsAndPackages() ...
[17:41:27.119] Searching for globals...
[17:41:27.120] - globals found: [1] ‘print’
[17:41:27.120] Searching for globals ... DONE
[17:41:27.120] Resolving globals: FALSE
[17:41:27.120] 
[17:41:27.120] 
[17:41:27.120] getGlobalsAndPackages() ... DONE
[17:41:27.121] run() for ‘Future’ ...
[17:41:27.121] - state: ‘created’
[17:41:27.121] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.121] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.121]   - Field: ‘label’
[17:41:27.121]   - Field: ‘local’
[17:41:27.121]   - Field: ‘owner’
[17:41:27.121]   - Field: ‘envir’
[17:41:27.122]   - Field: ‘packages’
[17:41:27.122]   - Field: ‘gc’
[17:41:27.122]   - Field: ‘conditions’
[17:41:27.122]   - Field: ‘expr’
[17:41:27.122]   - Field: ‘uuid’
[17:41:27.122]   - Field: ‘seed’
[17:41:27.122]   - Field: ‘version’
[17:41:27.122]   - Field: ‘result’
[17:41:27.122]   - Field: ‘asynchronous’
[17:41:27.122]   - Field: ‘calls’
[17:41:27.122]   - Field: ‘globals’
[17:41:27.123]   - Field: ‘stdout’
[17:41:27.123]   - Field: ‘earlySignal’
[17:41:27.123]   - Field: ‘lazy’
[17:41:27.123]   - Field: ‘state’
[17:41:27.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.123] - Launch lazy future ...
[17:41:27.123] Packages needed by the future expression (n = 0): <none>
[17:41:27.123] Packages needed by future strategies (n = 0): <none>
[17:41:27.124] {
[17:41:27.124]     {
[17:41:27.124]         {
[17:41:27.124]             ...future.startTime <- base::Sys.time()
[17:41:27.124]             {
[17:41:27.124]                 {
[17:41:27.124]                   {
[17:41:27.124]                     base::local({
[17:41:27.124]                       has_future <- base::requireNamespace("future", 
[17:41:27.124]                         quietly = TRUE)
[17:41:27.124]                       if (has_future) {
[17:41:27.124]                         ns <- base::getNamespace("future")
[17:41:27.124]                         version <- ns[[".package"]][["version"]]
[17:41:27.124]                         if (is.null(version)) 
[17:41:27.124]                           version <- utils::packageVersion("future")
[17:41:27.124]                       }
[17:41:27.124]                       else {
[17:41:27.124]                         version <- NULL
[17:41:27.124]                       }
[17:41:27.124]                       if (!has_future || version < "1.8.0") {
[17:41:27.124]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.124]                           "", base::R.version$version.string), 
[17:41:27.124]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:27.124]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.124]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.124]                             "release", "version")], collapse = " "), 
[17:41:27.124]                           hostname = base::Sys.info()[["nodename"]])
[17:41:27.124]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.124]                           info)
[17:41:27.124]                         info <- base::paste(info, collapse = "; ")
[17:41:27.124]                         if (!has_future) {
[17:41:27.124]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.124]                             info)
[17:41:27.124]                         }
[17:41:27.124]                         else {
[17:41:27.124]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.124]                             info, version)
[17:41:27.124]                         }
[17:41:27.124]                         base::stop(msg)
[17:41:27.124]                       }
[17:41:27.124]                     })
[17:41:27.124]                   }
[17:41:27.124]                   ...future.strategy.old <- future::plan("list")
[17:41:27.124]                   options(future.plan = NULL)
[17:41:27.124]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.124]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.124]                 }
[17:41:27.124]                 ...future.workdir <- getwd()
[17:41:27.124]             }
[17:41:27.124]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.124]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.124]         }
[17:41:27.124]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.124]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.124]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.124]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.124]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.124]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.124]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.124]             base::names(...future.oldOptions))
[17:41:27.124]     }
[17:41:27.124]     if (FALSE) {
[17:41:27.124]     }
[17:41:27.124]     else {
[17:41:27.124]         if (TRUE) {
[17:41:27.124]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.124]                 open = "w")
[17:41:27.124]         }
[17:41:27.124]         else {
[17:41:27.124]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.124]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.124]         }
[17:41:27.124]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.124]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.124]             base::sink(type = "output", split = FALSE)
[17:41:27.124]             base::close(...future.stdout)
[17:41:27.124]         }, add = TRUE)
[17:41:27.124]     }
[17:41:27.124]     ...future.frame <- base::sys.nframe()
[17:41:27.124]     ...future.conditions <- base::list()
[17:41:27.124]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.124]     if (FALSE) {
[17:41:27.124]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.124]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.124]     }
[17:41:27.124]     ...future.result <- base::tryCatch({
[17:41:27.124]         base::withCallingHandlers({
[17:41:27.124]             ...future.value <- base::withVisible(base::local(print(42)))
[17:41:27.124]             future::FutureResult(value = ...future.value$value, 
[17:41:27.124]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.124]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.124]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.124]                     ...future.globalenv.names))
[17:41:27.124]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.124]         }, condition = base::local({
[17:41:27.124]             c <- base::c
[17:41:27.124]             inherits <- base::inherits
[17:41:27.124]             invokeRestart <- base::invokeRestart
[17:41:27.124]             length <- base::length
[17:41:27.124]             list <- base::list
[17:41:27.124]             seq.int <- base::seq.int
[17:41:27.124]             signalCondition <- base::signalCondition
[17:41:27.124]             sys.calls <- base::sys.calls
[17:41:27.124]             `[[` <- base::`[[`
[17:41:27.124]             `+` <- base::`+`
[17:41:27.124]             `<<-` <- base::`<<-`
[17:41:27.124]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.124]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.124]                   3L)]
[17:41:27.124]             }
[17:41:27.124]             function(cond) {
[17:41:27.124]                 is_error <- inherits(cond, "error")
[17:41:27.124]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.124]                   NULL)
[17:41:27.124]                 if (is_error) {
[17:41:27.124]                   sessionInformation <- function() {
[17:41:27.124]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.124]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.124]                       search = base::search(), system = base::Sys.info())
[17:41:27.124]                   }
[17:41:27.124]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.124]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.124]                     cond$call), session = sessionInformation(), 
[17:41:27.124]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.124]                   signalCondition(cond)
[17:41:27.124]                 }
[17:41:27.124]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.124]                 "immediateCondition"))) {
[17:41:27.124]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.124]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.124]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.124]                   if (TRUE && !signal) {
[17:41:27.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.124]                     {
[17:41:27.124]                       inherits <- base::inherits
[17:41:27.124]                       invokeRestart <- base::invokeRestart
[17:41:27.124]                       is.null <- base::is.null
[17:41:27.124]                       muffled <- FALSE
[17:41:27.124]                       if (inherits(cond, "message")) {
[17:41:27.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.124]                         if (muffled) 
[17:41:27.124]                           invokeRestart("muffleMessage")
[17:41:27.124]                       }
[17:41:27.124]                       else if (inherits(cond, "warning")) {
[17:41:27.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.124]                         if (muffled) 
[17:41:27.124]                           invokeRestart("muffleWarning")
[17:41:27.124]                       }
[17:41:27.124]                       else if (inherits(cond, "condition")) {
[17:41:27.124]                         if (!is.null(pattern)) {
[17:41:27.124]                           computeRestarts <- base::computeRestarts
[17:41:27.124]                           grepl <- base::grepl
[17:41:27.124]                           restarts <- computeRestarts(cond)
[17:41:27.124]                           for (restart in restarts) {
[17:41:27.124]                             name <- restart$name
[17:41:27.124]                             if (is.null(name)) 
[17:41:27.124]                               next
[17:41:27.124]                             if (!grepl(pattern, name)) 
[17:41:27.124]                               next
[17:41:27.124]                             invokeRestart(restart)
[17:41:27.124]                             muffled <- TRUE
[17:41:27.124]                             break
[17:41:27.124]                           }
[17:41:27.124]                         }
[17:41:27.124]                       }
[17:41:27.124]                       invisible(muffled)
[17:41:27.124]                     }
[17:41:27.124]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.124]                   }
[17:41:27.124]                 }
[17:41:27.124]                 else {
[17:41:27.124]                   if (TRUE) {
[17:41:27.124]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.124]                     {
[17:41:27.124]                       inherits <- base::inherits
[17:41:27.124]                       invokeRestart <- base::invokeRestart
[17:41:27.124]                       is.null <- base::is.null
[17:41:27.124]                       muffled <- FALSE
[17:41:27.124]                       if (inherits(cond, "message")) {
[17:41:27.124]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.124]                         if (muffled) 
[17:41:27.124]                           invokeRestart("muffleMessage")
[17:41:27.124]                       }
[17:41:27.124]                       else if (inherits(cond, "warning")) {
[17:41:27.124]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.124]                         if (muffled) 
[17:41:27.124]                           invokeRestart("muffleWarning")
[17:41:27.124]                       }
[17:41:27.124]                       else if (inherits(cond, "condition")) {
[17:41:27.124]                         if (!is.null(pattern)) {
[17:41:27.124]                           computeRestarts <- base::computeRestarts
[17:41:27.124]                           grepl <- base::grepl
[17:41:27.124]                           restarts <- computeRestarts(cond)
[17:41:27.124]                           for (restart in restarts) {
[17:41:27.124]                             name <- restart$name
[17:41:27.124]                             if (is.null(name)) 
[17:41:27.124]                               next
[17:41:27.124]                             if (!grepl(pattern, name)) 
[17:41:27.124]                               next
[17:41:27.124]                             invokeRestart(restart)
[17:41:27.124]                             muffled <- TRUE
[17:41:27.124]                             break
[17:41:27.124]                           }
[17:41:27.124]                         }
[17:41:27.124]                       }
[17:41:27.124]                       invisible(muffled)
[17:41:27.124]                     }
[17:41:27.124]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.124]                   }
[17:41:27.124]                 }
[17:41:27.124]             }
[17:41:27.124]         }))
[17:41:27.124]     }, error = function(ex) {
[17:41:27.124]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.124]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.124]                 ...future.rng), started = ...future.startTime, 
[17:41:27.124]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.124]             version = "1.8"), class = "FutureResult")
[17:41:27.124]     }, finally = {
[17:41:27.124]         if (!identical(...future.workdir, getwd())) 
[17:41:27.124]             setwd(...future.workdir)
[17:41:27.124]         {
[17:41:27.124]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.124]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.124]             }
[17:41:27.124]             base::options(...future.oldOptions)
[17:41:27.124]             if (.Platform$OS.type == "windows") {
[17:41:27.124]                 old_names <- names(...future.oldEnvVars)
[17:41:27.124]                 envs <- base::Sys.getenv()
[17:41:27.124]                 names <- names(envs)
[17:41:27.124]                 common <- intersect(names, old_names)
[17:41:27.124]                 added <- setdiff(names, old_names)
[17:41:27.124]                 removed <- setdiff(old_names, names)
[17:41:27.124]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.124]                   envs[common]]
[17:41:27.124]                 NAMES <- toupper(changed)
[17:41:27.124]                 args <- list()
[17:41:27.124]                 for (kk in seq_along(NAMES)) {
[17:41:27.124]                   name <- changed[[kk]]
[17:41:27.124]                   NAME <- NAMES[[kk]]
[17:41:27.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.124]                     next
[17:41:27.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.124]                 }
[17:41:27.124]                 NAMES <- toupper(added)
[17:41:27.124]                 for (kk in seq_along(NAMES)) {
[17:41:27.124]                   name <- added[[kk]]
[17:41:27.124]                   NAME <- NAMES[[kk]]
[17:41:27.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.124]                     next
[17:41:27.124]                   args[[name]] <- ""
[17:41:27.124]                 }
[17:41:27.124]                 NAMES <- toupper(removed)
[17:41:27.124]                 for (kk in seq_along(NAMES)) {
[17:41:27.124]                   name <- removed[[kk]]
[17:41:27.124]                   NAME <- NAMES[[kk]]
[17:41:27.124]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.124]                     next
[17:41:27.124]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.124]                 }
[17:41:27.124]                 if (length(args) > 0) 
[17:41:27.124]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.124]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.124]             }
[17:41:27.124]             else {
[17:41:27.124]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.124]             }
[17:41:27.124]             {
[17:41:27.124]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.124]                   0L) {
[17:41:27.124]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.124]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.124]                   base::options(opts)
[17:41:27.124]                 }
[17:41:27.124]                 {
[17:41:27.124]                   {
[17:41:27.124]                     NULL
[17:41:27.124]                     RNGkind("Mersenne-Twister")
[17:41:27.124]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.124]                       inherits = FALSE)
[17:41:27.124]                   }
[17:41:27.124]                   options(future.plan = NULL)
[17:41:27.124]                   if (is.na(NA_character_)) 
[17:41:27.124]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.124]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.124]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.124]                     .init = FALSE)
[17:41:27.124]                 }
[17:41:27.124]             }
[17:41:27.124]         }
[17:41:27.124]     })
[17:41:27.124]     if (TRUE) {
[17:41:27.124]         base::sink(type = "output", split = FALSE)
[17:41:27.124]         if (TRUE) {
[17:41:27.124]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.124]         }
[17:41:27.124]         else {
[17:41:27.124]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.124]         }
[17:41:27.124]         base::close(...future.stdout)
[17:41:27.124]         ...future.stdout <- NULL
[17:41:27.124]     }
[17:41:27.124]     ...future.result$conditions <- ...future.conditions
[17:41:27.124]     ...future.result$finished <- base::Sys.time()
[17:41:27.124]     ...future.result
[17:41:27.124] }
[17:41:27.125] plan(): Setting new future strategy stack:
[17:41:27.125] List of future strategies:
[17:41:27.125] 1. sequential:
[17:41:27.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.125]    - tweaked: FALSE
[17:41:27.125]    - call: NULL
[17:41:27.126] plan(): nbrOfWorkers() = 1
[17:41:27.127] plan(): Setting new future strategy stack:
[17:41:27.127] List of future strategies:
[17:41:27.127] 1. sequential:
[17:41:27.127]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.127]    - tweaked: FALSE
[17:41:27.127]    - call: plan(strategy)
[17:41:27.127] plan(): nbrOfWorkers() = 1
[17:41:27.127] SequentialFuture started (and completed)
[17:41:27.127] - Launch lazy future ... done
[17:41:27.127] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[17:41:27.128] getGlobalsAndPackages() ...
[17:41:27.128] Searching for globals...
[17:41:27.132] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.132] Searching for globals ... DONE
[17:41:27.132] Resolving globals: FALSE
[17:41:27.132] 
[17:41:27.132] - packages: [1] ‘utils’
[17:41:27.133] getGlobalsAndPackages() ... DONE
[17:41:27.133] run() for ‘Future’ ...
[17:41:27.133] - state: ‘created’
[17:41:27.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.133]   - Field: ‘label’
[17:41:27.134]   - Field: ‘local’
[17:41:27.134]   - Field: ‘owner’
[17:41:27.134]   - Field: ‘envir’
[17:41:27.134]   - Field: ‘packages’
[17:41:27.134]   - Field: ‘gc’
[17:41:27.134]   - Field: ‘conditions’
[17:41:27.134]   - Field: ‘expr’
[17:41:27.134]   - Field: ‘uuid’
[17:41:27.134]   - Field: ‘seed’
[17:41:27.134]   - Field: ‘version’
[17:41:27.134]   - Field: ‘result’
[17:41:27.135]   - Field: ‘asynchronous’
[17:41:27.135]   - Field: ‘calls’
[17:41:27.135]   - Field: ‘globals’
[17:41:27.135]   - Field: ‘stdout’
[17:41:27.135]   - Field: ‘earlySignal’
[17:41:27.135]   - Field: ‘lazy’
[17:41:27.135]   - Field: ‘state’
[17:41:27.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.135] - Launch lazy future ...
[17:41:27.135] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.136] Packages needed by future strategies (n = 0): <none>
[17:41:27.136] {
[17:41:27.136]     {
[17:41:27.136]         {
[17:41:27.136]             ...future.startTime <- base::Sys.time()
[17:41:27.136]             {
[17:41:27.136]                 {
[17:41:27.136]                   {
[17:41:27.136]                     {
[17:41:27.136]                       base::local({
[17:41:27.136]                         has_future <- base::requireNamespace("future", 
[17:41:27.136]                           quietly = TRUE)
[17:41:27.136]                         if (has_future) {
[17:41:27.136]                           ns <- base::getNamespace("future")
[17:41:27.136]                           version <- ns[[".package"]][["version"]]
[17:41:27.136]                           if (is.null(version)) 
[17:41:27.136]                             version <- utils::packageVersion("future")
[17:41:27.136]                         }
[17:41:27.136]                         else {
[17:41:27.136]                           version <- NULL
[17:41:27.136]                         }
[17:41:27.136]                         if (!has_future || version < "1.8.0") {
[17:41:27.136]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.136]                             "", base::R.version$version.string), 
[17:41:27.136]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.136]                               "release", "version")], collapse = " "), 
[17:41:27.136]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.136]                             info)
[17:41:27.136]                           info <- base::paste(info, collapse = "; ")
[17:41:27.136]                           if (!has_future) {
[17:41:27.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.136]                               info)
[17:41:27.136]                           }
[17:41:27.136]                           else {
[17:41:27.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.136]                               info, version)
[17:41:27.136]                           }
[17:41:27.136]                           base::stop(msg)
[17:41:27.136]                         }
[17:41:27.136]                       })
[17:41:27.136]                     }
[17:41:27.136]                     base::local({
[17:41:27.136]                       for (pkg in "utils") {
[17:41:27.136]                         base::loadNamespace(pkg)
[17:41:27.136]                         base::library(pkg, character.only = TRUE)
[17:41:27.136]                       }
[17:41:27.136]                     })
[17:41:27.136]                   }
[17:41:27.136]                   ...future.strategy.old <- future::plan("list")
[17:41:27.136]                   options(future.plan = NULL)
[17:41:27.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.136]                 }
[17:41:27.136]                 ...future.workdir <- getwd()
[17:41:27.136]             }
[17:41:27.136]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.136]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.136]         }
[17:41:27.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.136]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.136]             base::names(...future.oldOptions))
[17:41:27.136]     }
[17:41:27.136]     if (TRUE) {
[17:41:27.136]     }
[17:41:27.136]     else {
[17:41:27.136]         if (NA) {
[17:41:27.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.136]                 open = "w")
[17:41:27.136]         }
[17:41:27.136]         else {
[17:41:27.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.136]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.136]         }
[17:41:27.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.136]             base::sink(type = "output", split = FALSE)
[17:41:27.136]             base::close(...future.stdout)
[17:41:27.136]         }, add = TRUE)
[17:41:27.136]     }
[17:41:27.136]     ...future.frame <- base::sys.nframe()
[17:41:27.136]     ...future.conditions <- base::list()
[17:41:27.136]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.136]     if (FALSE) {
[17:41:27.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.136]     }
[17:41:27.136]     ...future.result <- base::tryCatch({
[17:41:27.136]         base::withCallingHandlers({
[17:41:27.136]             ...future.value <- base::withVisible(base::local({
[17:41:27.136]                 print(1:50)
[17:41:27.136]                 str(1:50)
[17:41:27.136]                 cat(letters, sep = "-")
[17:41:27.136]                 cat(1:6, collapse = "\n")
[17:41:27.136]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.136]                 42L
[17:41:27.136]             }))
[17:41:27.136]             future::FutureResult(value = ...future.value$value, 
[17:41:27.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.136]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.136]                     ...future.globalenv.names))
[17:41:27.136]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.136]         }, condition = base::local({
[17:41:27.136]             c <- base::c
[17:41:27.136]             inherits <- base::inherits
[17:41:27.136]             invokeRestart <- base::invokeRestart
[17:41:27.136]             length <- base::length
[17:41:27.136]             list <- base::list
[17:41:27.136]             seq.int <- base::seq.int
[17:41:27.136]             signalCondition <- base::signalCondition
[17:41:27.136]             sys.calls <- base::sys.calls
[17:41:27.136]             `[[` <- base::`[[`
[17:41:27.136]             `+` <- base::`+`
[17:41:27.136]             `<<-` <- base::`<<-`
[17:41:27.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.136]                   3L)]
[17:41:27.136]             }
[17:41:27.136]             function(cond) {
[17:41:27.136]                 is_error <- inherits(cond, "error")
[17:41:27.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.136]                   NULL)
[17:41:27.136]                 if (is_error) {
[17:41:27.136]                   sessionInformation <- function() {
[17:41:27.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.136]                       search = base::search(), system = base::Sys.info())
[17:41:27.136]                   }
[17:41:27.136]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.136]                     cond$call), session = sessionInformation(), 
[17:41:27.136]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.136]                   signalCondition(cond)
[17:41:27.136]                 }
[17:41:27.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.136]                 "immediateCondition"))) {
[17:41:27.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.136]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.136]                   if (TRUE && !signal) {
[17:41:27.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.136]                     {
[17:41:27.136]                       inherits <- base::inherits
[17:41:27.136]                       invokeRestart <- base::invokeRestart
[17:41:27.136]                       is.null <- base::is.null
[17:41:27.136]                       muffled <- FALSE
[17:41:27.136]                       if (inherits(cond, "message")) {
[17:41:27.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.136]                         if (muffled) 
[17:41:27.136]                           invokeRestart("muffleMessage")
[17:41:27.136]                       }
[17:41:27.136]                       else if (inherits(cond, "warning")) {
[17:41:27.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.136]                         if (muffled) 
[17:41:27.136]                           invokeRestart("muffleWarning")
[17:41:27.136]                       }
[17:41:27.136]                       else if (inherits(cond, "condition")) {
[17:41:27.136]                         if (!is.null(pattern)) {
[17:41:27.136]                           computeRestarts <- base::computeRestarts
[17:41:27.136]                           grepl <- base::grepl
[17:41:27.136]                           restarts <- computeRestarts(cond)
[17:41:27.136]                           for (restart in restarts) {
[17:41:27.136]                             name <- restart$name
[17:41:27.136]                             if (is.null(name)) 
[17:41:27.136]                               next
[17:41:27.136]                             if (!grepl(pattern, name)) 
[17:41:27.136]                               next
[17:41:27.136]                             invokeRestart(restart)
[17:41:27.136]                             muffled <- TRUE
[17:41:27.136]                             break
[17:41:27.136]                           }
[17:41:27.136]                         }
[17:41:27.136]                       }
[17:41:27.136]                       invisible(muffled)
[17:41:27.136]                     }
[17:41:27.136]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.136]                   }
[17:41:27.136]                 }
[17:41:27.136]                 else {
[17:41:27.136]                   if (TRUE) {
[17:41:27.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.136]                     {
[17:41:27.136]                       inherits <- base::inherits
[17:41:27.136]                       invokeRestart <- base::invokeRestart
[17:41:27.136]                       is.null <- base::is.null
[17:41:27.136]                       muffled <- FALSE
[17:41:27.136]                       if (inherits(cond, "message")) {
[17:41:27.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.136]                         if (muffled) 
[17:41:27.136]                           invokeRestart("muffleMessage")
[17:41:27.136]                       }
[17:41:27.136]                       else if (inherits(cond, "warning")) {
[17:41:27.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.136]                         if (muffled) 
[17:41:27.136]                           invokeRestart("muffleWarning")
[17:41:27.136]                       }
[17:41:27.136]                       else if (inherits(cond, "condition")) {
[17:41:27.136]                         if (!is.null(pattern)) {
[17:41:27.136]                           computeRestarts <- base::computeRestarts
[17:41:27.136]                           grepl <- base::grepl
[17:41:27.136]                           restarts <- computeRestarts(cond)
[17:41:27.136]                           for (restart in restarts) {
[17:41:27.136]                             name <- restart$name
[17:41:27.136]                             if (is.null(name)) 
[17:41:27.136]                               next
[17:41:27.136]                             if (!grepl(pattern, name)) 
[17:41:27.136]                               next
[17:41:27.136]                             invokeRestart(restart)
[17:41:27.136]                             muffled <- TRUE
[17:41:27.136]                             break
[17:41:27.136]                           }
[17:41:27.136]                         }
[17:41:27.136]                       }
[17:41:27.136]                       invisible(muffled)
[17:41:27.136]                     }
[17:41:27.136]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.136]                   }
[17:41:27.136]                 }
[17:41:27.136]             }
[17:41:27.136]         }))
[17:41:27.136]     }, error = function(ex) {
[17:41:27.136]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.136]                 ...future.rng), started = ...future.startTime, 
[17:41:27.136]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.136]             version = "1.8"), class = "FutureResult")
[17:41:27.136]     }, finally = {
[17:41:27.136]         if (!identical(...future.workdir, getwd())) 
[17:41:27.136]             setwd(...future.workdir)
[17:41:27.136]         {
[17:41:27.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.136]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.136]             }
[17:41:27.136]             base::options(...future.oldOptions)
[17:41:27.136]             if (.Platform$OS.type == "windows") {
[17:41:27.136]                 old_names <- names(...future.oldEnvVars)
[17:41:27.136]                 envs <- base::Sys.getenv()
[17:41:27.136]                 names <- names(envs)
[17:41:27.136]                 common <- intersect(names, old_names)
[17:41:27.136]                 added <- setdiff(names, old_names)
[17:41:27.136]                 removed <- setdiff(old_names, names)
[17:41:27.136]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.136]                   envs[common]]
[17:41:27.136]                 NAMES <- toupper(changed)
[17:41:27.136]                 args <- list()
[17:41:27.136]                 for (kk in seq_along(NAMES)) {
[17:41:27.136]                   name <- changed[[kk]]
[17:41:27.136]                   NAME <- NAMES[[kk]]
[17:41:27.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.136]                     next
[17:41:27.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.136]                 }
[17:41:27.136]                 NAMES <- toupper(added)
[17:41:27.136]                 for (kk in seq_along(NAMES)) {
[17:41:27.136]                   name <- added[[kk]]
[17:41:27.136]                   NAME <- NAMES[[kk]]
[17:41:27.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.136]                     next
[17:41:27.136]                   args[[name]] <- ""
[17:41:27.136]                 }
[17:41:27.136]                 NAMES <- toupper(removed)
[17:41:27.136]                 for (kk in seq_along(NAMES)) {
[17:41:27.136]                   name <- removed[[kk]]
[17:41:27.136]                   NAME <- NAMES[[kk]]
[17:41:27.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.136]                     next
[17:41:27.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.136]                 }
[17:41:27.136]                 if (length(args) > 0) 
[17:41:27.136]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.136]             }
[17:41:27.136]             else {
[17:41:27.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.136]             }
[17:41:27.136]             {
[17:41:27.136]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.136]                   0L) {
[17:41:27.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.136]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.136]                   base::options(opts)
[17:41:27.136]                 }
[17:41:27.136]                 {
[17:41:27.136]                   {
[17:41:27.136]                     NULL
[17:41:27.136]                     RNGkind("Mersenne-Twister")
[17:41:27.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.136]                       inherits = FALSE)
[17:41:27.136]                   }
[17:41:27.136]                   options(future.plan = NULL)
[17:41:27.136]                   if (is.na(NA_character_)) 
[17:41:27.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.136]                     .init = FALSE)
[17:41:27.136]                 }
[17:41:27.136]             }
[17:41:27.136]         }
[17:41:27.136]     })
[17:41:27.136]     if (FALSE) {
[17:41:27.136]         base::sink(type = "output", split = FALSE)
[17:41:27.136]         if (NA) {
[17:41:27.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.136]         }
[17:41:27.136]         else {
[17:41:27.136]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.136]         }
[17:41:27.136]         base::close(...future.stdout)
[17:41:27.136]         ...future.stdout <- NULL
[17:41:27.136]     }
[17:41:27.136]     ...future.result$conditions <- ...future.conditions
[17:41:27.136]     ...future.result$finished <- base::Sys.time()
[17:41:27.136]     ...future.result
[17:41:27.136] }
[17:41:27.138] plan(): Setting new future strategy stack:
[17:41:27.138] List of future strategies:
[17:41:27.138] 1. sequential:
[17:41:27.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.138]    - tweaked: FALSE
[17:41:27.138]    - call: NULL
[17:41:27.138] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:41:27.140] plan(): Setting new future strategy stack:
[17:41:27.140] List of future strategies:
[17:41:27.140] 1. sequential:
[17:41:27.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.140]    - tweaked: FALSE
[17:41:27.140]    - call: plan(strategy)
[17:41:27.140] plan(): nbrOfWorkers() = 1
[17:41:27.140] SequentialFuture started (and completed)
[17:41:27.141] - Launch lazy future ... done
[17:41:27.141] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "46be20ea-7c28-8dd8-7073-e7fc1f24590d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50430
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:26"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:27.148] getGlobalsAndPackages() ...
[17:41:27.148] Searching for globals...
[17:41:27.151] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.151] Searching for globals ... DONE
[17:41:27.151] Resolving globals: FALSE
[17:41:27.151] 
[17:41:27.151] - packages: [1] ‘utils’
[17:41:27.151] getGlobalsAndPackages() ... DONE
[17:41:27.152] run() for ‘Future’ ...
[17:41:27.152] - state: ‘created’
[17:41:27.152] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.152] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.152] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.152]   - Field: ‘label’
[17:41:27.152]   - Field: ‘local’
[17:41:27.153]   - Field: ‘owner’
[17:41:27.153]   - Field: ‘envir’
[17:41:27.153]   - Field: ‘packages’
[17:41:27.153]   - Field: ‘gc’
[17:41:27.153]   - Field: ‘conditions’
[17:41:27.153]   - Field: ‘expr’
[17:41:27.153]   - Field: ‘uuid’
[17:41:27.153]   - Field: ‘seed’
[17:41:27.153]   - Field: ‘version’
[17:41:27.153]   - Field: ‘result’
[17:41:27.153]   - Field: ‘asynchronous’
[17:41:27.153]   - Field: ‘calls’
[17:41:27.154]   - Field: ‘globals’
[17:41:27.154]   - Field: ‘stdout’
[17:41:27.154]   - Field: ‘earlySignal’
[17:41:27.154]   - Field: ‘lazy’
[17:41:27.155]   - Field: ‘state’
[17:41:27.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.155] - Launch lazy future ...
[17:41:27.155] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.155] Packages needed by future strategies (n = 0): <none>
[17:41:27.156] {
[17:41:27.156]     {
[17:41:27.156]         {
[17:41:27.156]             ...future.startTime <- base::Sys.time()
[17:41:27.156]             {
[17:41:27.156]                 {
[17:41:27.156]                   {
[17:41:27.156]                     {
[17:41:27.156]                       base::local({
[17:41:27.156]                         has_future <- base::requireNamespace("future", 
[17:41:27.156]                           quietly = TRUE)
[17:41:27.156]                         if (has_future) {
[17:41:27.156]                           ns <- base::getNamespace("future")
[17:41:27.156]                           version <- ns[[".package"]][["version"]]
[17:41:27.156]                           if (is.null(version)) 
[17:41:27.156]                             version <- utils::packageVersion("future")
[17:41:27.156]                         }
[17:41:27.156]                         else {
[17:41:27.156]                           version <- NULL
[17:41:27.156]                         }
[17:41:27.156]                         if (!has_future || version < "1.8.0") {
[17:41:27.156]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.156]                             "", base::R.version$version.string), 
[17:41:27.156]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.156]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.156]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.156]                               "release", "version")], collapse = " "), 
[17:41:27.156]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.156]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.156]                             info)
[17:41:27.156]                           info <- base::paste(info, collapse = "; ")
[17:41:27.156]                           if (!has_future) {
[17:41:27.156]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.156]                               info)
[17:41:27.156]                           }
[17:41:27.156]                           else {
[17:41:27.156]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.156]                               info, version)
[17:41:27.156]                           }
[17:41:27.156]                           base::stop(msg)
[17:41:27.156]                         }
[17:41:27.156]                       })
[17:41:27.156]                     }
[17:41:27.156]                     base::local({
[17:41:27.156]                       for (pkg in "utils") {
[17:41:27.156]                         base::loadNamespace(pkg)
[17:41:27.156]                         base::library(pkg, character.only = TRUE)
[17:41:27.156]                       }
[17:41:27.156]                     })
[17:41:27.156]                   }
[17:41:27.156]                   ...future.strategy.old <- future::plan("list")
[17:41:27.156]                   options(future.plan = NULL)
[17:41:27.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.156]                 }
[17:41:27.156]                 ...future.workdir <- getwd()
[17:41:27.156]             }
[17:41:27.156]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.156]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.156]         }
[17:41:27.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.156]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.156]             base::names(...future.oldOptions))
[17:41:27.156]     }
[17:41:27.156]     if (TRUE) {
[17:41:27.156]     }
[17:41:27.156]     else {
[17:41:27.156]         if (NA) {
[17:41:27.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.156]                 open = "w")
[17:41:27.156]         }
[17:41:27.156]         else {
[17:41:27.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.156]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.156]         }
[17:41:27.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.156]             base::sink(type = "output", split = FALSE)
[17:41:27.156]             base::close(...future.stdout)
[17:41:27.156]         }, add = TRUE)
[17:41:27.156]     }
[17:41:27.156]     ...future.frame <- base::sys.nframe()
[17:41:27.156]     ...future.conditions <- base::list()
[17:41:27.156]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.156]     if (FALSE) {
[17:41:27.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.156]     }
[17:41:27.156]     ...future.result <- base::tryCatch({
[17:41:27.156]         base::withCallingHandlers({
[17:41:27.156]             ...future.value <- base::withVisible(base::local({
[17:41:27.156]                 print(1:50)
[17:41:27.156]                 str(1:50)
[17:41:27.156]                 cat(letters, sep = "-")
[17:41:27.156]                 cat(1:6, collapse = "\n")
[17:41:27.156]                 write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.156]                 42L
[17:41:27.156]             }))
[17:41:27.156]             future::FutureResult(value = ...future.value$value, 
[17:41:27.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.156]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.156]                     ...future.globalenv.names))
[17:41:27.156]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.156]         }, condition = base::local({
[17:41:27.156]             c <- base::c
[17:41:27.156]             inherits <- base::inherits
[17:41:27.156]             invokeRestart <- base::invokeRestart
[17:41:27.156]             length <- base::length
[17:41:27.156]             list <- base::list
[17:41:27.156]             seq.int <- base::seq.int
[17:41:27.156]             signalCondition <- base::signalCondition
[17:41:27.156]             sys.calls <- base::sys.calls
[17:41:27.156]             `[[` <- base::`[[`
[17:41:27.156]             `+` <- base::`+`
[17:41:27.156]             `<<-` <- base::`<<-`
[17:41:27.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.156]                   3L)]
[17:41:27.156]             }
[17:41:27.156]             function(cond) {
[17:41:27.156]                 is_error <- inherits(cond, "error")
[17:41:27.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.156]                   NULL)
[17:41:27.156]                 if (is_error) {
[17:41:27.156]                   sessionInformation <- function() {
[17:41:27.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.156]                       search = base::search(), system = base::Sys.info())
[17:41:27.156]                   }
[17:41:27.156]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.156]                     cond$call), session = sessionInformation(), 
[17:41:27.156]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.156]                   signalCondition(cond)
[17:41:27.156]                 }
[17:41:27.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.156]                 "immediateCondition"))) {
[17:41:27.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.156]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.156]                   if (TRUE && !signal) {
[17:41:27.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.156]                     {
[17:41:27.156]                       inherits <- base::inherits
[17:41:27.156]                       invokeRestart <- base::invokeRestart
[17:41:27.156]                       is.null <- base::is.null
[17:41:27.156]                       muffled <- FALSE
[17:41:27.156]                       if (inherits(cond, "message")) {
[17:41:27.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.156]                         if (muffled) 
[17:41:27.156]                           invokeRestart("muffleMessage")
[17:41:27.156]                       }
[17:41:27.156]                       else if (inherits(cond, "warning")) {
[17:41:27.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.156]                         if (muffled) 
[17:41:27.156]                           invokeRestart("muffleWarning")
[17:41:27.156]                       }
[17:41:27.156]                       else if (inherits(cond, "condition")) {
[17:41:27.156]                         if (!is.null(pattern)) {
[17:41:27.156]                           computeRestarts <- base::computeRestarts
[17:41:27.156]                           grepl <- base::grepl
[17:41:27.156]                           restarts <- computeRestarts(cond)
[17:41:27.156]                           for (restart in restarts) {
[17:41:27.156]                             name <- restart$name
[17:41:27.156]                             if (is.null(name)) 
[17:41:27.156]                               next
[17:41:27.156]                             if (!grepl(pattern, name)) 
[17:41:27.156]                               next
[17:41:27.156]                             invokeRestart(restart)
[17:41:27.156]                             muffled <- TRUE
[17:41:27.156]                             break
[17:41:27.156]                           }
[17:41:27.156]                         }
[17:41:27.156]                       }
[17:41:27.156]                       invisible(muffled)
[17:41:27.156]                     }
[17:41:27.156]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.156]                   }
[17:41:27.156]                 }
[17:41:27.156]                 else {
[17:41:27.156]                   if (TRUE) {
[17:41:27.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.156]                     {
[17:41:27.156]                       inherits <- base::inherits
[17:41:27.156]                       invokeRestart <- base::invokeRestart
[17:41:27.156]                       is.null <- base::is.null
[17:41:27.156]                       muffled <- FALSE
[17:41:27.156]                       if (inherits(cond, "message")) {
[17:41:27.156]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.156]                         if (muffled) 
[17:41:27.156]                           invokeRestart("muffleMessage")
[17:41:27.156]                       }
[17:41:27.156]                       else if (inherits(cond, "warning")) {
[17:41:27.156]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.156]                         if (muffled) 
[17:41:27.156]                           invokeRestart("muffleWarning")
[17:41:27.156]                       }
[17:41:27.156]                       else if (inherits(cond, "condition")) {
[17:41:27.156]                         if (!is.null(pattern)) {
[17:41:27.156]                           computeRestarts <- base::computeRestarts
[17:41:27.156]                           grepl <- base::grepl
[17:41:27.156]                           restarts <- computeRestarts(cond)
[17:41:27.156]                           for (restart in restarts) {
[17:41:27.156]                             name <- restart$name
[17:41:27.156]                             if (is.null(name)) 
[17:41:27.156]                               next
[17:41:27.156]                             if (!grepl(pattern, name)) 
[17:41:27.156]                               next
[17:41:27.156]                             invokeRestart(restart)
[17:41:27.156]                             muffled <- TRUE
[17:41:27.156]                             break
[17:41:27.156]                           }
[17:41:27.156]                         }
[17:41:27.156]                       }
[17:41:27.156]                       invisible(muffled)
[17:41:27.156]                     }
[17:41:27.156]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.156]                   }
[17:41:27.156]                 }
[17:41:27.156]             }
[17:41:27.156]         }))
[17:41:27.156]     }, error = function(ex) {
[17:41:27.156]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.156]                 ...future.rng), started = ...future.startTime, 
[17:41:27.156]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.156]             version = "1.8"), class = "FutureResult")
[17:41:27.156]     }, finally = {
[17:41:27.156]         if (!identical(...future.workdir, getwd())) 
[17:41:27.156]             setwd(...future.workdir)
[17:41:27.156]         {
[17:41:27.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.156]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.156]             }
[17:41:27.156]             base::options(...future.oldOptions)
[17:41:27.156]             if (.Platform$OS.type == "windows") {
[17:41:27.156]                 old_names <- names(...future.oldEnvVars)
[17:41:27.156]                 envs <- base::Sys.getenv()
[17:41:27.156]                 names <- names(envs)
[17:41:27.156]                 common <- intersect(names, old_names)
[17:41:27.156]                 added <- setdiff(names, old_names)
[17:41:27.156]                 removed <- setdiff(old_names, names)
[17:41:27.156]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.156]                   envs[common]]
[17:41:27.156]                 NAMES <- toupper(changed)
[17:41:27.156]                 args <- list()
[17:41:27.156]                 for (kk in seq_along(NAMES)) {
[17:41:27.156]                   name <- changed[[kk]]
[17:41:27.156]                   NAME <- NAMES[[kk]]
[17:41:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.156]                     next
[17:41:27.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.156]                 }
[17:41:27.156]                 NAMES <- toupper(added)
[17:41:27.156]                 for (kk in seq_along(NAMES)) {
[17:41:27.156]                   name <- added[[kk]]
[17:41:27.156]                   NAME <- NAMES[[kk]]
[17:41:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.156]                     next
[17:41:27.156]                   args[[name]] <- ""
[17:41:27.156]                 }
[17:41:27.156]                 NAMES <- toupper(removed)
[17:41:27.156]                 for (kk in seq_along(NAMES)) {
[17:41:27.156]                   name <- removed[[kk]]
[17:41:27.156]                   NAME <- NAMES[[kk]]
[17:41:27.156]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.156]                     next
[17:41:27.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.156]                 }
[17:41:27.156]                 if (length(args) > 0) 
[17:41:27.156]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.156]             }
[17:41:27.156]             else {
[17:41:27.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.156]             }
[17:41:27.156]             {
[17:41:27.156]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.156]                   0L) {
[17:41:27.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.156]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.156]                   base::options(opts)
[17:41:27.156]                 }
[17:41:27.156]                 {
[17:41:27.156]                   {
[17:41:27.156]                     NULL
[17:41:27.156]                     RNGkind("Mersenne-Twister")
[17:41:27.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.156]                       inherits = FALSE)
[17:41:27.156]                   }
[17:41:27.156]                   options(future.plan = NULL)
[17:41:27.156]                   if (is.na(NA_character_)) 
[17:41:27.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.156]                     .init = FALSE)
[17:41:27.156]                 }
[17:41:27.156]             }
[17:41:27.156]         }
[17:41:27.156]     })
[17:41:27.156]     if (FALSE) {
[17:41:27.156]         base::sink(type = "output", split = FALSE)
[17:41:27.156]         if (NA) {
[17:41:27.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.156]         }
[17:41:27.156]         else {
[17:41:27.156]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.156]         }
[17:41:27.156]         base::close(...future.stdout)
[17:41:27.156]         ...future.stdout <- NULL
[17:41:27.156]     }
[17:41:27.156]     ...future.result$conditions <- ...future.conditions
[17:41:27.156]     ...future.result$finished <- base::Sys.time()
[17:41:27.156]     ...future.result
[17:41:27.156] }
[17:41:27.158] plan(): Setting new future strategy stack:
[17:41:27.158] List of future strategies:
[17:41:27.158] 1. sequential:
[17:41:27.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.158]    - tweaked: FALSE
[17:41:27.158]    - call: NULL
[17:41:27.158] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:41:27.160] plan(): Setting new future strategy stack:
[17:41:27.160] List of future strategies:
[17:41:27.160] 1. sequential:
[17:41:27.160]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.160]    - tweaked: FALSE
[17:41:27.160]    - call: plan(strategy)
[17:41:27.160] plan(): nbrOfWorkers() = 1
[17:41:27.160] SequentialFuture started (and completed)
[17:41:27.161] - Launch lazy future ... done
[17:41:27.161] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.161] getGlobalsAndPackages() ...
[17:41:27.161] Searching for globals...
[17:41:27.161] - globals found: [1] ‘print’
[17:41:27.162] Searching for globals ... DONE
[17:41:27.162] Resolving globals: FALSE
[17:41:27.162] 
[17:41:27.162] 
[17:41:27.162] getGlobalsAndPackages() ... DONE
[17:41:27.162] run() for ‘Future’ ...
[17:41:27.162] - state: ‘created’
[17:41:27.163] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:41:27.163] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:41:27.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:41:27.163]   - Field: ‘label’
[17:41:27.163]   - Field: ‘local’
[17:41:27.163]   - Field: ‘owner’
[17:41:27.163]   - Field: ‘envir’
[17:41:27.163]   - Field: ‘packages’
[17:41:27.163]   - Field: ‘gc’
[17:41:27.163]   - Field: ‘conditions’
[17:41:27.164]   - Field: ‘expr’
[17:41:27.164]   - Field: ‘uuid’
[17:41:27.164]   - Field: ‘seed’
[17:41:27.164]   - Field: ‘version’
[17:41:27.164]   - Field: ‘result’
[17:41:27.164]   - Field: ‘asynchronous’
[17:41:27.164]   - Field: ‘calls’
[17:41:27.164]   - Field: ‘globals’
[17:41:27.164]   - Field: ‘stdout’
[17:41:27.164]   - Field: ‘earlySignal’
[17:41:27.164]   - Field: ‘lazy’
[17:41:27.165]   - Field: ‘state’
[17:41:27.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:41:27.165] - Launch lazy future ...
[17:41:27.165] Packages needed by the future expression (n = 0): <none>
[17:41:27.165] Packages needed by future strategies (n = 0): <none>
[17:41:27.165] {
[17:41:27.165]     {
[17:41:27.165]         {
[17:41:27.165]             ...future.startTime <- base::Sys.time()
[17:41:27.165]             {
[17:41:27.165]                 {
[17:41:27.165]                   {
[17:41:27.165]                     base::local({
[17:41:27.165]                       has_future <- base::requireNamespace("future", 
[17:41:27.165]                         quietly = TRUE)
[17:41:27.165]                       if (has_future) {
[17:41:27.165]                         ns <- base::getNamespace("future")
[17:41:27.165]                         version <- ns[[".package"]][["version"]]
[17:41:27.165]                         if (is.null(version)) 
[17:41:27.165]                           version <- utils::packageVersion("future")
[17:41:27.165]                       }
[17:41:27.165]                       else {
[17:41:27.165]                         version <- NULL
[17:41:27.165]                       }
[17:41:27.165]                       if (!has_future || version < "1.8.0") {
[17:41:27.165]                         info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.165]                           "", base::R.version$version.string), 
[17:41:27.165]                           platform = base::sprintf("%s (%s-bit)", 
[17:41:27.165]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.165]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.165]                             "release", "version")], collapse = " "), 
[17:41:27.165]                           hostname = base::Sys.info()[["nodename"]])
[17:41:27.165]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.165]                           info)
[17:41:27.165]                         info <- base::paste(info, collapse = "; ")
[17:41:27.165]                         if (!has_future) {
[17:41:27.165]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.165]                             info)
[17:41:27.165]                         }
[17:41:27.165]                         else {
[17:41:27.165]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.165]                             info, version)
[17:41:27.165]                         }
[17:41:27.165]                         base::stop(msg)
[17:41:27.165]                       }
[17:41:27.165]                     })
[17:41:27.165]                   }
[17:41:27.165]                   ...future.strategy.old <- future::plan("list")
[17:41:27.165]                   options(future.plan = NULL)
[17:41:27.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.165]                 }
[17:41:27.165]                 ...future.workdir <- getwd()
[17:41:27.165]             }
[17:41:27.165]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.165]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.165]         }
[17:41:27.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.165]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.165]             base::names(...future.oldOptions))
[17:41:27.165]     }
[17:41:27.165]     if (FALSE) {
[17:41:27.165]     }
[17:41:27.165]     else {
[17:41:27.165]         if (TRUE) {
[17:41:27.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.165]                 open = "w")
[17:41:27.165]         }
[17:41:27.165]         else {
[17:41:27.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.165]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.165]         }
[17:41:27.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.165]             base::sink(type = "output", split = FALSE)
[17:41:27.165]             base::close(...future.stdout)
[17:41:27.165]         }, add = TRUE)
[17:41:27.165]     }
[17:41:27.165]     ...future.frame <- base::sys.nframe()
[17:41:27.165]     ...future.conditions <- base::list()
[17:41:27.165]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.165]     if (FALSE) {
[17:41:27.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.165]     }
[17:41:27.165]     ...future.result <- base::tryCatch({
[17:41:27.165]         base::withCallingHandlers({
[17:41:27.165]             ...future.value <- base::withVisible(base::local(print(42)))
[17:41:27.165]             future::FutureResult(value = ...future.value$value, 
[17:41:27.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.165]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.165]                     ...future.globalenv.names))
[17:41:27.165]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.165]         }, condition = base::local({
[17:41:27.165]             c <- base::c
[17:41:27.165]             inherits <- base::inherits
[17:41:27.165]             invokeRestart <- base::invokeRestart
[17:41:27.165]             length <- base::length
[17:41:27.165]             list <- base::list
[17:41:27.165]             seq.int <- base::seq.int
[17:41:27.165]             signalCondition <- base::signalCondition
[17:41:27.165]             sys.calls <- base::sys.calls
[17:41:27.165]             `[[` <- base::`[[`
[17:41:27.165]             `+` <- base::`+`
[17:41:27.165]             `<<-` <- base::`<<-`
[17:41:27.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.165]                   3L)]
[17:41:27.165]             }
[17:41:27.165]             function(cond) {
[17:41:27.165]                 is_error <- inherits(cond, "error")
[17:41:27.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.165]                   NULL)
[17:41:27.165]                 if (is_error) {
[17:41:27.165]                   sessionInformation <- function() {
[17:41:27.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.165]                       search = base::search(), system = base::Sys.info())
[17:41:27.165]                   }
[17:41:27.165]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.165]                     cond$call), session = sessionInformation(), 
[17:41:27.165]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.165]                   signalCondition(cond)
[17:41:27.165]                 }
[17:41:27.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.165]                 "immediateCondition"))) {
[17:41:27.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.165]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.165]                   if (TRUE && !signal) {
[17:41:27.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.165]                     {
[17:41:27.165]                       inherits <- base::inherits
[17:41:27.165]                       invokeRestart <- base::invokeRestart
[17:41:27.165]                       is.null <- base::is.null
[17:41:27.165]                       muffled <- FALSE
[17:41:27.165]                       if (inherits(cond, "message")) {
[17:41:27.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.165]                         if (muffled) 
[17:41:27.165]                           invokeRestart("muffleMessage")
[17:41:27.165]                       }
[17:41:27.165]                       else if (inherits(cond, "warning")) {
[17:41:27.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.165]                         if (muffled) 
[17:41:27.165]                           invokeRestart("muffleWarning")
[17:41:27.165]                       }
[17:41:27.165]                       else if (inherits(cond, "condition")) {
[17:41:27.165]                         if (!is.null(pattern)) {
[17:41:27.165]                           computeRestarts <- base::computeRestarts
[17:41:27.165]                           grepl <- base::grepl
[17:41:27.165]                           restarts <- computeRestarts(cond)
[17:41:27.165]                           for (restart in restarts) {
[17:41:27.165]                             name <- restart$name
[17:41:27.165]                             if (is.null(name)) 
[17:41:27.165]                               next
[17:41:27.165]                             if (!grepl(pattern, name)) 
[17:41:27.165]                               next
[17:41:27.165]                             invokeRestart(restart)
[17:41:27.165]                             muffled <- TRUE
[17:41:27.165]                             break
[17:41:27.165]                           }
[17:41:27.165]                         }
[17:41:27.165]                       }
[17:41:27.165]                       invisible(muffled)
[17:41:27.165]                     }
[17:41:27.165]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.165]                   }
[17:41:27.165]                 }
[17:41:27.165]                 else {
[17:41:27.165]                   if (TRUE) {
[17:41:27.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.165]                     {
[17:41:27.165]                       inherits <- base::inherits
[17:41:27.165]                       invokeRestart <- base::invokeRestart
[17:41:27.165]                       is.null <- base::is.null
[17:41:27.165]                       muffled <- FALSE
[17:41:27.165]                       if (inherits(cond, "message")) {
[17:41:27.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.165]                         if (muffled) 
[17:41:27.165]                           invokeRestart("muffleMessage")
[17:41:27.165]                       }
[17:41:27.165]                       else if (inherits(cond, "warning")) {
[17:41:27.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.165]                         if (muffled) 
[17:41:27.165]                           invokeRestart("muffleWarning")
[17:41:27.165]                       }
[17:41:27.165]                       else if (inherits(cond, "condition")) {
[17:41:27.165]                         if (!is.null(pattern)) {
[17:41:27.165]                           computeRestarts <- base::computeRestarts
[17:41:27.165]                           grepl <- base::grepl
[17:41:27.165]                           restarts <- computeRestarts(cond)
[17:41:27.165]                           for (restart in restarts) {
[17:41:27.165]                             name <- restart$name
[17:41:27.165]                             if (is.null(name)) 
[17:41:27.165]                               next
[17:41:27.165]                             if (!grepl(pattern, name)) 
[17:41:27.165]                               next
[17:41:27.165]                             invokeRestart(restart)
[17:41:27.165]                             muffled <- TRUE
[17:41:27.165]                             break
[17:41:27.165]                           }
[17:41:27.165]                         }
[17:41:27.165]                       }
[17:41:27.165]                       invisible(muffled)
[17:41:27.165]                     }
[17:41:27.165]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.165]                   }
[17:41:27.165]                 }
[17:41:27.165]             }
[17:41:27.165]         }))
[17:41:27.165]     }, error = function(ex) {
[17:41:27.165]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.165]                 ...future.rng), started = ...future.startTime, 
[17:41:27.165]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.165]             version = "1.8"), class = "FutureResult")
[17:41:27.165]     }, finally = {
[17:41:27.165]         if (!identical(...future.workdir, getwd())) 
[17:41:27.165]             setwd(...future.workdir)
[17:41:27.165]         {
[17:41:27.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.165]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.165]             }
[17:41:27.165]             base::options(...future.oldOptions)
[17:41:27.165]             if (.Platform$OS.type == "windows") {
[17:41:27.165]                 old_names <- names(...future.oldEnvVars)
[17:41:27.165]                 envs <- base::Sys.getenv()
[17:41:27.165]                 names <- names(envs)
[17:41:27.165]                 common <- intersect(names, old_names)
[17:41:27.165]                 added <- setdiff(names, old_names)
[17:41:27.165]                 removed <- setdiff(old_names, names)
[17:41:27.165]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.165]                   envs[common]]
[17:41:27.165]                 NAMES <- toupper(changed)
[17:41:27.165]                 args <- list()
[17:41:27.165]                 for (kk in seq_along(NAMES)) {
[17:41:27.165]                   name <- changed[[kk]]
[17:41:27.165]                   NAME <- NAMES[[kk]]
[17:41:27.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.165]                     next
[17:41:27.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.165]                 }
[17:41:27.165]                 NAMES <- toupper(added)
[17:41:27.165]                 for (kk in seq_along(NAMES)) {
[17:41:27.165]                   name <- added[[kk]]
[17:41:27.165]                   NAME <- NAMES[[kk]]
[17:41:27.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.165]                     next
[17:41:27.165]                   args[[name]] <- ""
[17:41:27.165]                 }
[17:41:27.165]                 NAMES <- toupper(removed)
[17:41:27.165]                 for (kk in seq_along(NAMES)) {
[17:41:27.165]                   name <- removed[[kk]]
[17:41:27.165]                   NAME <- NAMES[[kk]]
[17:41:27.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.165]                     next
[17:41:27.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.165]                 }
[17:41:27.165]                 if (length(args) > 0) 
[17:41:27.165]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.165]             }
[17:41:27.165]             else {
[17:41:27.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.165]             }
[17:41:27.165]             {
[17:41:27.165]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.165]                   0L) {
[17:41:27.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.165]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.165]                   base::options(opts)
[17:41:27.165]                 }
[17:41:27.165]                 {
[17:41:27.165]                   {
[17:41:27.165]                     NULL
[17:41:27.165]                     RNGkind("Mersenne-Twister")
[17:41:27.165]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:41:27.165]                       inherits = FALSE)
[17:41:27.165]                   }
[17:41:27.165]                   options(future.plan = NULL)
[17:41:27.165]                   if (is.na(NA_character_)) 
[17:41:27.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.165]                     .init = FALSE)
[17:41:27.165]                 }
[17:41:27.165]             }
[17:41:27.165]         }
[17:41:27.165]     })
[17:41:27.165]     if (TRUE) {
[17:41:27.165]         base::sink(type = "output", split = FALSE)
[17:41:27.165]         if (TRUE) {
[17:41:27.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.165]         }
[17:41:27.165]         else {
[17:41:27.165]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.165]         }
[17:41:27.165]         base::close(...future.stdout)
[17:41:27.165]         ...future.stdout <- NULL
[17:41:27.165]     }
[17:41:27.165]     ...future.result$conditions <- ...future.conditions
[17:41:27.165]     ...future.result$finished <- base::Sys.time()
[17:41:27.165]     ...future.result
[17:41:27.165] }
[17:41:27.167] plan(): Setting new future strategy stack:
[17:41:27.167] List of future strategies:
[17:41:27.167] 1. sequential:
[17:41:27.167]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.167]    - tweaked: FALSE
[17:41:27.167]    - call: NULL
[17:41:27.168] plan(): nbrOfWorkers() = 1
[17:41:27.168] plan(): Setting new future strategy stack:
[17:41:27.168] List of future strategies:
[17:41:27.168] 1. sequential:
[17:41:27.168]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.168]    - tweaked: FALSE
[17:41:27.168]    - call: plan(strategy)
[17:41:27.169] plan(): nbrOfWorkers() = 1
[17:41:27.169] SequentialFuture started (and completed)
[17:41:27.169] - Launch lazy future ... done
[17:41:27.169] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[17:41:27.174] plan(): Setting new future strategy stack:
[17:41:27.174] List of future strategies:
[17:41:27.174] 1. multicore:
[17:41:27.174]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.174]    - tweaked: FALSE
[17:41:27.174]    - call: plan(strategy)
[17:41:27.178] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:41:27.178] getGlobalsAndPackages() ...
[17:41:27.178] Searching for globals...
[17:41:27.181] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.181] Searching for globals ... DONE
[17:41:27.181] Resolving globals: FALSE
[17:41:27.181] 
[17:41:27.182] - packages: [1] ‘utils’
[17:41:27.182] getGlobalsAndPackages() ... DONE
[17:41:27.182] run() for ‘Future’ ...
[17:41:27.182] - state: ‘created’
[17:41:27.182] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.187]   - Field: ‘label’
[17:41:27.187]   - Field: ‘local’
[17:41:27.187]   - Field: ‘owner’
[17:41:27.187]   - Field: ‘envir’
[17:41:27.187]   - Field: ‘workers’
[17:41:27.187]   - Field: ‘packages’
[17:41:27.187]   - Field: ‘gc’
[17:41:27.188]   - Field: ‘job’
[17:41:27.188]   - Field: ‘conditions’
[17:41:27.188]   - Field: ‘expr’
[17:41:27.188]   - Field: ‘uuid’
[17:41:27.188]   - Field: ‘seed’
[17:41:27.188]   - Field: ‘version’
[17:41:27.188]   - Field: ‘result’
[17:41:27.188]   - Field: ‘asynchronous’
[17:41:27.188]   - Field: ‘calls’
[17:41:27.188]   - Field: ‘globals’
[17:41:27.188]   - Field: ‘stdout’
[17:41:27.189]   - Field: ‘earlySignal’
[17:41:27.189]   - Field: ‘lazy’
[17:41:27.189]   - Field: ‘state’
[17:41:27.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.189] - Launch lazy future ...
[17:41:27.190] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.190] Packages needed by future strategies (n = 0): <none>
[17:41:27.190] {
[17:41:27.190]     {
[17:41:27.190]         {
[17:41:27.190]             ...future.startTime <- base::Sys.time()
[17:41:27.190]             {
[17:41:27.190]                 {
[17:41:27.190]                   {
[17:41:27.190]                     {
[17:41:27.190]                       {
[17:41:27.190]                         base::local({
[17:41:27.190]                           has_future <- base::requireNamespace("future", 
[17:41:27.190]                             quietly = TRUE)
[17:41:27.190]                           if (has_future) {
[17:41:27.190]                             ns <- base::getNamespace("future")
[17:41:27.190]                             version <- ns[[".package"]][["version"]]
[17:41:27.190]                             if (is.null(version)) 
[17:41:27.190]                               version <- utils::packageVersion("future")
[17:41:27.190]                           }
[17:41:27.190]                           else {
[17:41:27.190]                             version <- NULL
[17:41:27.190]                           }
[17:41:27.190]                           if (!has_future || version < "1.8.0") {
[17:41:27.190]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.190]                               "", base::R.version$version.string), 
[17:41:27.190]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.190]                                 base::R.version$platform, 8 * 
[17:41:27.190]                                   base::.Machine$sizeof.pointer), 
[17:41:27.190]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.190]                                 "release", "version")], collapse = " "), 
[17:41:27.190]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.190]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.190]                               info)
[17:41:27.190]                             info <- base::paste(info, collapse = "; ")
[17:41:27.190]                             if (!has_future) {
[17:41:27.190]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.190]                                 info)
[17:41:27.190]                             }
[17:41:27.190]                             else {
[17:41:27.190]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.190]                                 info, version)
[17:41:27.190]                             }
[17:41:27.190]                             base::stop(msg)
[17:41:27.190]                           }
[17:41:27.190]                         })
[17:41:27.190]                       }
[17:41:27.190]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.190]                       base::options(mc.cores = 1L)
[17:41:27.190]                     }
[17:41:27.190]                     base::local({
[17:41:27.190]                       for (pkg in "utils") {
[17:41:27.190]                         base::loadNamespace(pkg)
[17:41:27.190]                         base::library(pkg, character.only = TRUE)
[17:41:27.190]                       }
[17:41:27.190]                     })
[17:41:27.190]                   }
[17:41:27.190]                   ...future.strategy.old <- future::plan("list")
[17:41:27.190]                   options(future.plan = NULL)
[17:41:27.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.190]                 }
[17:41:27.190]                 ...future.workdir <- getwd()
[17:41:27.190]             }
[17:41:27.190]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.190]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.190]         }
[17:41:27.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.190]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.190]             base::names(...future.oldOptions))
[17:41:27.190]     }
[17:41:27.190]     if (FALSE) {
[17:41:27.190]     }
[17:41:27.190]     else {
[17:41:27.190]         if (TRUE) {
[17:41:27.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.190]                 open = "w")
[17:41:27.190]         }
[17:41:27.190]         else {
[17:41:27.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.190]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.190]         }
[17:41:27.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.190]             base::sink(type = "output", split = FALSE)
[17:41:27.190]             base::close(...future.stdout)
[17:41:27.190]         }, add = TRUE)
[17:41:27.190]     }
[17:41:27.190]     ...future.frame <- base::sys.nframe()
[17:41:27.190]     ...future.conditions <- base::list()
[17:41:27.190]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.190]     if (FALSE) {
[17:41:27.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.190]     }
[17:41:27.190]     ...future.result <- base::tryCatch({
[17:41:27.190]         base::withCallingHandlers({
[17:41:27.190]             ...future.value <- base::withVisible(base::local({
[17:41:27.190]                 withCallingHandlers({
[17:41:27.190]                   {
[17:41:27.190]                     print(1:50)
[17:41:27.190]                     str(1:50)
[17:41:27.190]                     cat(letters, sep = "-")
[17:41:27.190]                     cat(1:6, collapse = "\n")
[17:41:27.190]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.190]                     42L
[17:41:27.190]                   }
[17:41:27.190]                 }, immediateCondition = function(cond) {
[17:41:27.190]                   save_rds <- function (object, pathname, ...) 
[17:41:27.190]                   {
[17:41:27.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.190]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.190]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.190]                         fi_tmp[["mtime"]])
[17:41:27.190]                     }
[17:41:27.190]                     tryCatch({
[17:41:27.190]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.190]                     }, error = function(ex) {
[17:41:27.190]                       msg <- conditionMessage(ex)
[17:41:27.190]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.190]                         fi_tmp[["mtime"]], msg)
[17:41:27.190]                       ex$message <- msg
[17:41:27.190]                       stop(ex)
[17:41:27.190]                     })
[17:41:27.190]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.190]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.190]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.190]                       fi <- file.info(pathname)
[17:41:27.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.190]                         fi[["size"]], fi[["mtime"]])
[17:41:27.190]                       stop(msg)
[17:41:27.190]                     }
[17:41:27.190]                     invisible(pathname)
[17:41:27.190]                   }
[17:41:27.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.190]                     rootPath = tempdir()) 
[17:41:27.190]                   {
[17:41:27.190]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.190]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.190]                       tmpdir = path, fileext = ".rds")
[17:41:27.190]                     save_rds(obj, file)
[17:41:27.190]                   }
[17:41:27.190]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.190]                   {
[17:41:27.190]                     inherits <- base::inherits
[17:41:27.190]                     invokeRestart <- base::invokeRestart
[17:41:27.190]                     is.null <- base::is.null
[17:41:27.190]                     muffled <- FALSE
[17:41:27.190]                     if (inherits(cond, "message")) {
[17:41:27.190]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.190]                       if (muffled) 
[17:41:27.190]                         invokeRestart("muffleMessage")
[17:41:27.190]                     }
[17:41:27.190]                     else if (inherits(cond, "warning")) {
[17:41:27.190]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.190]                       if (muffled) 
[17:41:27.190]                         invokeRestart("muffleWarning")
[17:41:27.190]                     }
[17:41:27.190]                     else if (inherits(cond, "condition")) {
[17:41:27.190]                       if (!is.null(pattern)) {
[17:41:27.190]                         computeRestarts <- base::computeRestarts
[17:41:27.190]                         grepl <- base::grepl
[17:41:27.190]                         restarts <- computeRestarts(cond)
[17:41:27.190]                         for (restart in restarts) {
[17:41:27.190]                           name <- restart$name
[17:41:27.190]                           if (is.null(name)) 
[17:41:27.190]                             next
[17:41:27.190]                           if (!grepl(pattern, name)) 
[17:41:27.190]                             next
[17:41:27.190]                           invokeRestart(restart)
[17:41:27.190]                           muffled <- TRUE
[17:41:27.190]                           break
[17:41:27.190]                         }
[17:41:27.190]                       }
[17:41:27.190]                     }
[17:41:27.190]                     invisible(muffled)
[17:41:27.190]                   }
[17:41:27.190]                   muffleCondition(cond)
[17:41:27.190]                 })
[17:41:27.190]             }))
[17:41:27.190]             future::FutureResult(value = ...future.value$value, 
[17:41:27.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.190]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.190]                     ...future.globalenv.names))
[17:41:27.190]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.190]         }, condition = base::local({
[17:41:27.190]             c <- base::c
[17:41:27.190]             inherits <- base::inherits
[17:41:27.190]             invokeRestart <- base::invokeRestart
[17:41:27.190]             length <- base::length
[17:41:27.190]             list <- base::list
[17:41:27.190]             seq.int <- base::seq.int
[17:41:27.190]             signalCondition <- base::signalCondition
[17:41:27.190]             sys.calls <- base::sys.calls
[17:41:27.190]             `[[` <- base::`[[`
[17:41:27.190]             `+` <- base::`+`
[17:41:27.190]             `<<-` <- base::`<<-`
[17:41:27.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.190]                   3L)]
[17:41:27.190]             }
[17:41:27.190]             function(cond) {
[17:41:27.190]                 is_error <- inherits(cond, "error")
[17:41:27.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.190]                   NULL)
[17:41:27.190]                 if (is_error) {
[17:41:27.190]                   sessionInformation <- function() {
[17:41:27.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.190]                       search = base::search(), system = base::Sys.info())
[17:41:27.190]                   }
[17:41:27.190]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.190]                     cond$call), session = sessionInformation(), 
[17:41:27.190]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.190]                   signalCondition(cond)
[17:41:27.190]                 }
[17:41:27.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.190]                 "immediateCondition"))) {
[17:41:27.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.190]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.190]                   if (TRUE && !signal) {
[17:41:27.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.190]                     {
[17:41:27.190]                       inherits <- base::inherits
[17:41:27.190]                       invokeRestart <- base::invokeRestart
[17:41:27.190]                       is.null <- base::is.null
[17:41:27.190]                       muffled <- FALSE
[17:41:27.190]                       if (inherits(cond, "message")) {
[17:41:27.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.190]                         if (muffled) 
[17:41:27.190]                           invokeRestart("muffleMessage")
[17:41:27.190]                       }
[17:41:27.190]                       else if (inherits(cond, "warning")) {
[17:41:27.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.190]                         if (muffled) 
[17:41:27.190]                           invokeRestart("muffleWarning")
[17:41:27.190]                       }
[17:41:27.190]                       else if (inherits(cond, "condition")) {
[17:41:27.190]                         if (!is.null(pattern)) {
[17:41:27.190]                           computeRestarts <- base::computeRestarts
[17:41:27.190]                           grepl <- base::grepl
[17:41:27.190]                           restarts <- computeRestarts(cond)
[17:41:27.190]                           for (restart in restarts) {
[17:41:27.190]                             name <- restart$name
[17:41:27.190]                             if (is.null(name)) 
[17:41:27.190]                               next
[17:41:27.190]                             if (!grepl(pattern, name)) 
[17:41:27.190]                               next
[17:41:27.190]                             invokeRestart(restart)
[17:41:27.190]                             muffled <- TRUE
[17:41:27.190]                             break
[17:41:27.190]                           }
[17:41:27.190]                         }
[17:41:27.190]                       }
[17:41:27.190]                       invisible(muffled)
[17:41:27.190]                     }
[17:41:27.190]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.190]                   }
[17:41:27.190]                 }
[17:41:27.190]                 else {
[17:41:27.190]                   if (TRUE) {
[17:41:27.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.190]                     {
[17:41:27.190]                       inherits <- base::inherits
[17:41:27.190]                       invokeRestart <- base::invokeRestart
[17:41:27.190]                       is.null <- base::is.null
[17:41:27.190]                       muffled <- FALSE
[17:41:27.190]                       if (inherits(cond, "message")) {
[17:41:27.190]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.190]                         if (muffled) 
[17:41:27.190]                           invokeRestart("muffleMessage")
[17:41:27.190]                       }
[17:41:27.190]                       else if (inherits(cond, "warning")) {
[17:41:27.190]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.190]                         if (muffled) 
[17:41:27.190]                           invokeRestart("muffleWarning")
[17:41:27.190]                       }
[17:41:27.190]                       else if (inherits(cond, "condition")) {
[17:41:27.190]                         if (!is.null(pattern)) {
[17:41:27.190]                           computeRestarts <- base::computeRestarts
[17:41:27.190]                           grepl <- base::grepl
[17:41:27.190]                           restarts <- computeRestarts(cond)
[17:41:27.190]                           for (restart in restarts) {
[17:41:27.190]                             name <- restart$name
[17:41:27.190]                             if (is.null(name)) 
[17:41:27.190]                               next
[17:41:27.190]                             if (!grepl(pattern, name)) 
[17:41:27.190]                               next
[17:41:27.190]                             invokeRestart(restart)
[17:41:27.190]                             muffled <- TRUE
[17:41:27.190]                             break
[17:41:27.190]                           }
[17:41:27.190]                         }
[17:41:27.190]                       }
[17:41:27.190]                       invisible(muffled)
[17:41:27.190]                     }
[17:41:27.190]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.190]                   }
[17:41:27.190]                 }
[17:41:27.190]             }
[17:41:27.190]         }))
[17:41:27.190]     }, error = function(ex) {
[17:41:27.190]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.190]                 ...future.rng), started = ...future.startTime, 
[17:41:27.190]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.190]             version = "1.8"), class = "FutureResult")
[17:41:27.190]     }, finally = {
[17:41:27.190]         if (!identical(...future.workdir, getwd())) 
[17:41:27.190]             setwd(...future.workdir)
[17:41:27.190]         {
[17:41:27.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.190]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.190]             }
[17:41:27.190]             base::options(...future.oldOptions)
[17:41:27.190]             if (.Platform$OS.type == "windows") {
[17:41:27.190]                 old_names <- names(...future.oldEnvVars)
[17:41:27.190]                 envs <- base::Sys.getenv()
[17:41:27.190]                 names <- names(envs)
[17:41:27.190]                 common <- intersect(names, old_names)
[17:41:27.190]                 added <- setdiff(names, old_names)
[17:41:27.190]                 removed <- setdiff(old_names, names)
[17:41:27.190]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.190]                   envs[common]]
[17:41:27.190]                 NAMES <- toupper(changed)
[17:41:27.190]                 args <- list()
[17:41:27.190]                 for (kk in seq_along(NAMES)) {
[17:41:27.190]                   name <- changed[[kk]]
[17:41:27.190]                   NAME <- NAMES[[kk]]
[17:41:27.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.190]                     next
[17:41:27.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.190]                 }
[17:41:27.190]                 NAMES <- toupper(added)
[17:41:27.190]                 for (kk in seq_along(NAMES)) {
[17:41:27.190]                   name <- added[[kk]]
[17:41:27.190]                   NAME <- NAMES[[kk]]
[17:41:27.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.190]                     next
[17:41:27.190]                   args[[name]] <- ""
[17:41:27.190]                 }
[17:41:27.190]                 NAMES <- toupper(removed)
[17:41:27.190]                 for (kk in seq_along(NAMES)) {
[17:41:27.190]                   name <- removed[[kk]]
[17:41:27.190]                   NAME <- NAMES[[kk]]
[17:41:27.190]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.190]                     next
[17:41:27.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.190]                 }
[17:41:27.190]                 if (length(args) > 0) 
[17:41:27.190]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.190]             }
[17:41:27.190]             else {
[17:41:27.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.190]             }
[17:41:27.190]             {
[17:41:27.190]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.190]                   0L) {
[17:41:27.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.190]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.190]                   base::options(opts)
[17:41:27.190]                 }
[17:41:27.190]                 {
[17:41:27.190]                   {
[17:41:27.190]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.190]                     NULL
[17:41:27.190]                   }
[17:41:27.190]                   options(future.plan = NULL)
[17:41:27.190]                   if (is.na(NA_character_)) 
[17:41:27.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.190]                     .init = FALSE)
[17:41:27.190]                 }
[17:41:27.190]             }
[17:41:27.190]         }
[17:41:27.190]     })
[17:41:27.190]     if (TRUE) {
[17:41:27.190]         base::sink(type = "output", split = FALSE)
[17:41:27.190]         if (TRUE) {
[17:41:27.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.190]         }
[17:41:27.190]         else {
[17:41:27.190]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.190]         }
[17:41:27.190]         base::close(...future.stdout)
[17:41:27.190]         ...future.stdout <- NULL
[17:41:27.190]     }
[17:41:27.190]     ...future.result$conditions <- ...future.conditions
[17:41:27.190]     ...future.result$finished <- base::Sys.time()
[17:41:27.190]     ...future.result
[17:41:27.190] }
[17:41:27.193] requestCore(): workers = 2
[17:41:27.195] MulticoreFuture started
[17:41:27.196] - Launch lazy future ... done
[17:41:27.196] run() for ‘MulticoreFuture’ ... done
[17:41:27.197] plan(): Setting new future strategy stack:
[17:41:27.197] result() for MulticoreFuture ...
[17:41:27.197] List of future strategies:
[17:41:27.197] 1. sequential:
[17:41:27.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.197]    - tweaked: FALSE
[17:41:27.197]    - call: NULL
[17:41:27.198] plan(): nbrOfWorkers() = 1
[17:41:27.201] plan(): Setting new future strategy stack:
[17:41:27.201] List of future strategies:
[17:41:27.201] 1. multicore:
[17:41:27.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.201]    - tweaked: FALSE
[17:41:27.201]    - call: plan(strategy)
[17:41:27.206] plan(): nbrOfWorkers() = 2
[17:41:27.210] result() for MulticoreFuture ...
[17:41:27.211] result() for MulticoreFuture ... done
[17:41:27.211] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "db7dbb77-dc28-2b16-eaea-30e52b7573af"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50454
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:27"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:27.220] result() for MulticoreFuture ...
[17:41:27.220] result() for MulticoreFuture ... done
[17:41:27.220] result() for MulticoreFuture ...
[17:41:27.220] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.01092935 secs (started 2024-12-19 17:41:27.196005)
version: 1.8
[17:41:27.221] getGlobalsAndPackages() ...
[17:41:27.221] Searching for globals...
[17:41:27.225] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.225] Searching for globals ... DONE
[17:41:27.225] Resolving globals: FALSE
[17:41:27.226] 
[17:41:27.226] - packages: [1] ‘utils’
[17:41:27.226] getGlobalsAndPackages() ... DONE
[17:41:27.226] run() for ‘Future’ ...
[17:41:27.226] - state: ‘created’
[17:41:27.226] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.230] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.230] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.231]   - Field: ‘label’
[17:41:27.231]   - Field: ‘local’
[17:41:27.231]   - Field: ‘owner’
[17:41:27.231]   - Field: ‘envir’
[17:41:27.231]   - Field: ‘workers’
[17:41:27.231]   - Field: ‘packages’
[17:41:27.231]   - Field: ‘gc’
[17:41:27.234]   - Field: ‘job’
[17:41:27.234]   - Field: ‘conditions’
[17:41:27.234]   - Field: ‘expr’
[17:41:27.234]   - Field: ‘uuid’
[17:41:27.234]   - Field: ‘seed’
[17:41:27.234]   - Field: ‘version’
[17:41:27.234]   - Field: ‘result’
[17:41:27.234]   - Field: ‘asynchronous’
[17:41:27.235]   - Field: ‘calls’
[17:41:27.235]   - Field: ‘globals’
[17:41:27.235]   - Field: ‘stdout’
[17:41:27.235]   - Field: ‘earlySignal’
[17:41:27.235]   - Field: ‘lazy’
[17:41:27.235]   - Field: ‘state’
[17:41:27.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.235] - Launch lazy future ...
[17:41:27.236] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.236] Packages needed by future strategies (n = 0): <none>
[17:41:27.236] {
[17:41:27.236]     {
[17:41:27.236]         {
[17:41:27.236]             ...future.startTime <- base::Sys.time()
[17:41:27.236]             {
[17:41:27.236]                 {
[17:41:27.236]                   {
[17:41:27.236]                     {
[17:41:27.236]                       {
[17:41:27.236]                         base::local({
[17:41:27.236]                           has_future <- base::requireNamespace("future", 
[17:41:27.236]                             quietly = TRUE)
[17:41:27.236]                           if (has_future) {
[17:41:27.236]                             ns <- base::getNamespace("future")
[17:41:27.236]                             version <- ns[[".package"]][["version"]]
[17:41:27.236]                             if (is.null(version)) 
[17:41:27.236]                               version <- utils::packageVersion("future")
[17:41:27.236]                           }
[17:41:27.236]                           else {
[17:41:27.236]                             version <- NULL
[17:41:27.236]                           }
[17:41:27.236]                           if (!has_future || version < "1.8.0") {
[17:41:27.236]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.236]                               "", base::R.version$version.string), 
[17:41:27.236]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.236]                                 base::R.version$platform, 8 * 
[17:41:27.236]                                   base::.Machine$sizeof.pointer), 
[17:41:27.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.236]                                 "release", "version")], collapse = " "), 
[17:41:27.236]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.236]                               info)
[17:41:27.236]                             info <- base::paste(info, collapse = "; ")
[17:41:27.236]                             if (!has_future) {
[17:41:27.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.236]                                 info)
[17:41:27.236]                             }
[17:41:27.236]                             else {
[17:41:27.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.236]                                 info, version)
[17:41:27.236]                             }
[17:41:27.236]                             base::stop(msg)
[17:41:27.236]                           }
[17:41:27.236]                         })
[17:41:27.236]                       }
[17:41:27.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.236]                       base::options(mc.cores = 1L)
[17:41:27.236]                     }
[17:41:27.236]                     base::local({
[17:41:27.236]                       for (pkg in "utils") {
[17:41:27.236]                         base::loadNamespace(pkg)
[17:41:27.236]                         base::library(pkg, character.only = TRUE)
[17:41:27.236]                       }
[17:41:27.236]                     })
[17:41:27.236]                   }
[17:41:27.236]                   ...future.strategy.old <- future::plan("list")
[17:41:27.236]                   options(future.plan = NULL)
[17:41:27.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.236]                 }
[17:41:27.236]                 ...future.workdir <- getwd()
[17:41:27.236]             }
[17:41:27.236]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.236]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.236]         }
[17:41:27.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.236]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.236]             base::names(...future.oldOptions))
[17:41:27.236]     }
[17:41:27.236]     if (FALSE) {
[17:41:27.236]     }
[17:41:27.236]     else {
[17:41:27.236]         if (TRUE) {
[17:41:27.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.236]                 open = "w")
[17:41:27.236]         }
[17:41:27.236]         else {
[17:41:27.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.236]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.236]         }
[17:41:27.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.236]             base::sink(type = "output", split = FALSE)
[17:41:27.236]             base::close(...future.stdout)
[17:41:27.236]         }, add = TRUE)
[17:41:27.236]     }
[17:41:27.236]     ...future.frame <- base::sys.nframe()
[17:41:27.236]     ...future.conditions <- base::list()
[17:41:27.236]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.236]     if (FALSE) {
[17:41:27.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.236]     }
[17:41:27.236]     ...future.result <- base::tryCatch({
[17:41:27.236]         base::withCallingHandlers({
[17:41:27.236]             ...future.value <- base::withVisible(base::local({
[17:41:27.236]                 withCallingHandlers({
[17:41:27.236]                   {
[17:41:27.236]                     print(1:50)
[17:41:27.236]                     str(1:50)
[17:41:27.236]                     cat(letters, sep = "-")
[17:41:27.236]                     cat(1:6, collapse = "\n")
[17:41:27.236]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.236]                     42L
[17:41:27.236]                   }
[17:41:27.236]                 }, immediateCondition = function(cond) {
[17:41:27.236]                   save_rds <- function (object, pathname, ...) 
[17:41:27.236]                   {
[17:41:27.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.236]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.236]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.236]                         fi_tmp[["mtime"]])
[17:41:27.236]                     }
[17:41:27.236]                     tryCatch({
[17:41:27.236]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.236]                     }, error = function(ex) {
[17:41:27.236]                       msg <- conditionMessage(ex)
[17:41:27.236]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.236]                         fi_tmp[["mtime"]], msg)
[17:41:27.236]                       ex$message <- msg
[17:41:27.236]                       stop(ex)
[17:41:27.236]                     })
[17:41:27.236]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.236]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.236]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.236]                       fi <- file.info(pathname)
[17:41:27.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.236]                         fi[["size"]], fi[["mtime"]])
[17:41:27.236]                       stop(msg)
[17:41:27.236]                     }
[17:41:27.236]                     invisible(pathname)
[17:41:27.236]                   }
[17:41:27.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.236]                     rootPath = tempdir()) 
[17:41:27.236]                   {
[17:41:27.236]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.236]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.236]                       tmpdir = path, fileext = ".rds")
[17:41:27.236]                     save_rds(obj, file)
[17:41:27.236]                   }
[17:41:27.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.236]                   {
[17:41:27.236]                     inherits <- base::inherits
[17:41:27.236]                     invokeRestart <- base::invokeRestart
[17:41:27.236]                     is.null <- base::is.null
[17:41:27.236]                     muffled <- FALSE
[17:41:27.236]                     if (inherits(cond, "message")) {
[17:41:27.236]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.236]                       if (muffled) 
[17:41:27.236]                         invokeRestart("muffleMessage")
[17:41:27.236]                     }
[17:41:27.236]                     else if (inherits(cond, "warning")) {
[17:41:27.236]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.236]                       if (muffled) 
[17:41:27.236]                         invokeRestart("muffleWarning")
[17:41:27.236]                     }
[17:41:27.236]                     else if (inherits(cond, "condition")) {
[17:41:27.236]                       if (!is.null(pattern)) {
[17:41:27.236]                         computeRestarts <- base::computeRestarts
[17:41:27.236]                         grepl <- base::grepl
[17:41:27.236]                         restarts <- computeRestarts(cond)
[17:41:27.236]                         for (restart in restarts) {
[17:41:27.236]                           name <- restart$name
[17:41:27.236]                           if (is.null(name)) 
[17:41:27.236]                             next
[17:41:27.236]                           if (!grepl(pattern, name)) 
[17:41:27.236]                             next
[17:41:27.236]                           invokeRestart(restart)
[17:41:27.236]                           muffled <- TRUE
[17:41:27.236]                           break
[17:41:27.236]                         }
[17:41:27.236]                       }
[17:41:27.236]                     }
[17:41:27.236]                     invisible(muffled)
[17:41:27.236]                   }
[17:41:27.236]                   muffleCondition(cond)
[17:41:27.236]                 })
[17:41:27.236]             }))
[17:41:27.236]             future::FutureResult(value = ...future.value$value, 
[17:41:27.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.236]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.236]                     ...future.globalenv.names))
[17:41:27.236]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.236]         }, condition = base::local({
[17:41:27.236]             c <- base::c
[17:41:27.236]             inherits <- base::inherits
[17:41:27.236]             invokeRestart <- base::invokeRestart
[17:41:27.236]             length <- base::length
[17:41:27.236]             list <- base::list
[17:41:27.236]             seq.int <- base::seq.int
[17:41:27.236]             signalCondition <- base::signalCondition
[17:41:27.236]             sys.calls <- base::sys.calls
[17:41:27.236]             `[[` <- base::`[[`
[17:41:27.236]             `+` <- base::`+`
[17:41:27.236]             `<<-` <- base::`<<-`
[17:41:27.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.236]                   3L)]
[17:41:27.236]             }
[17:41:27.236]             function(cond) {
[17:41:27.236]                 is_error <- inherits(cond, "error")
[17:41:27.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.236]                   NULL)
[17:41:27.236]                 if (is_error) {
[17:41:27.236]                   sessionInformation <- function() {
[17:41:27.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.236]                       search = base::search(), system = base::Sys.info())
[17:41:27.236]                   }
[17:41:27.236]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.236]                     cond$call), session = sessionInformation(), 
[17:41:27.236]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.236]                   signalCondition(cond)
[17:41:27.236]                 }
[17:41:27.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.236]                 "immediateCondition"))) {
[17:41:27.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.236]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.236]                   if (TRUE && !signal) {
[17:41:27.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.236]                     {
[17:41:27.236]                       inherits <- base::inherits
[17:41:27.236]                       invokeRestart <- base::invokeRestart
[17:41:27.236]                       is.null <- base::is.null
[17:41:27.236]                       muffled <- FALSE
[17:41:27.236]                       if (inherits(cond, "message")) {
[17:41:27.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.236]                         if (muffled) 
[17:41:27.236]                           invokeRestart("muffleMessage")
[17:41:27.236]                       }
[17:41:27.236]                       else if (inherits(cond, "warning")) {
[17:41:27.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.236]                         if (muffled) 
[17:41:27.236]                           invokeRestart("muffleWarning")
[17:41:27.236]                       }
[17:41:27.236]                       else if (inherits(cond, "condition")) {
[17:41:27.236]                         if (!is.null(pattern)) {
[17:41:27.236]                           computeRestarts <- base::computeRestarts
[17:41:27.236]                           grepl <- base::grepl
[17:41:27.236]                           restarts <- computeRestarts(cond)
[17:41:27.236]                           for (restart in restarts) {
[17:41:27.236]                             name <- restart$name
[17:41:27.236]                             if (is.null(name)) 
[17:41:27.236]                               next
[17:41:27.236]                             if (!grepl(pattern, name)) 
[17:41:27.236]                               next
[17:41:27.236]                             invokeRestart(restart)
[17:41:27.236]                             muffled <- TRUE
[17:41:27.236]                             break
[17:41:27.236]                           }
[17:41:27.236]                         }
[17:41:27.236]                       }
[17:41:27.236]                       invisible(muffled)
[17:41:27.236]                     }
[17:41:27.236]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.236]                   }
[17:41:27.236]                 }
[17:41:27.236]                 else {
[17:41:27.236]                   if (TRUE) {
[17:41:27.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.236]                     {
[17:41:27.236]                       inherits <- base::inherits
[17:41:27.236]                       invokeRestart <- base::invokeRestart
[17:41:27.236]                       is.null <- base::is.null
[17:41:27.236]                       muffled <- FALSE
[17:41:27.236]                       if (inherits(cond, "message")) {
[17:41:27.236]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.236]                         if (muffled) 
[17:41:27.236]                           invokeRestart("muffleMessage")
[17:41:27.236]                       }
[17:41:27.236]                       else if (inherits(cond, "warning")) {
[17:41:27.236]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.236]                         if (muffled) 
[17:41:27.236]                           invokeRestart("muffleWarning")
[17:41:27.236]                       }
[17:41:27.236]                       else if (inherits(cond, "condition")) {
[17:41:27.236]                         if (!is.null(pattern)) {
[17:41:27.236]                           computeRestarts <- base::computeRestarts
[17:41:27.236]                           grepl <- base::grepl
[17:41:27.236]                           restarts <- computeRestarts(cond)
[17:41:27.236]                           for (restart in restarts) {
[17:41:27.236]                             name <- restart$name
[17:41:27.236]                             if (is.null(name)) 
[17:41:27.236]                               next
[17:41:27.236]                             if (!grepl(pattern, name)) 
[17:41:27.236]                               next
[17:41:27.236]                             invokeRestart(restart)
[17:41:27.236]                             muffled <- TRUE
[17:41:27.236]                             break
[17:41:27.236]                           }
[17:41:27.236]                         }
[17:41:27.236]                       }
[17:41:27.236]                       invisible(muffled)
[17:41:27.236]                     }
[17:41:27.236]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.236]                   }
[17:41:27.236]                 }
[17:41:27.236]             }
[17:41:27.236]         }))
[17:41:27.236]     }, error = function(ex) {
[17:41:27.236]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.236]                 ...future.rng), started = ...future.startTime, 
[17:41:27.236]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.236]             version = "1.8"), class = "FutureResult")
[17:41:27.236]     }, finally = {
[17:41:27.236]         if (!identical(...future.workdir, getwd())) 
[17:41:27.236]             setwd(...future.workdir)
[17:41:27.236]         {
[17:41:27.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.236]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.236]             }
[17:41:27.236]             base::options(...future.oldOptions)
[17:41:27.236]             if (.Platform$OS.type == "windows") {
[17:41:27.236]                 old_names <- names(...future.oldEnvVars)
[17:41:27.236]                 envs <- base::Sys.getenv()
[17:41:27.236]                 names <- names(envs)
[17:41:27.236]                 common <- intersect(names, old_names)
[17:41:27.236]                 added <- setdiff(names, old_names)
[17:41:27.236]                 removed <- setdiff(old_names, names)
[17:41:27.236]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.236]                   envs[common]]
[17:41:27.236]                 NAMES <- toupper(changed)
[17:41:27.236]                 args <- list()
[17:41:27.236]                 for (kk in seq_along(NAMES)) {
[17:41:27.236]                   name <- changed[[kk]]
[17:41:27.236]                   NAME <- NAMES[[kk]]
[17:41:27.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.236]                     next
[17:41:27.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.236]                 }
[17:41:27.236]                 NAMES <- toupper(added)
[17:41:27.236]                 for (kk in seq_along(NAMES)) {
[17:41:27.236]                   name <- added[[kk]]
[17:41:27.236]                   NAME <- NAMES[[kk]]
[17:41:27.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.236]                     next
[17:41:27.236]                   args[[name]] <- ""
[17:41:27.236]                 }
[17:41:27.236]                 NAMES <- toupper(removed)
[17:41:27.236]                 for (kk in seq_along(NAMES)) {
[17:41:27.236]                   name <- removed[[kk]]
[17:41:27.236]                   NAME <- NAMES[[kk]]
[17:41:27.236]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.236]                     next
[17:41:27.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.236]                 }
[17:41:27.236]                 if (length(args) > 0) 
[17:41:27.236]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.236]             }
[17:41:27.236]             else {
[17:41:27.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.236]             }
[17:41:27.236]             {
[17:41:27.236]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.236]                   0L) {
[17:41:27.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.236]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.236]                   base::options(opts)
[17:41:27.236]                 }
[17:41:27.236]                 {
[17:41:27.236]                   {
[17:41:27.236]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.236]                     NULL
[17:41:27.236]                   }
[17:41:27.236]                   options(future.plan = NULL)
[17:41:27.236]                   if (is.na(NA_character_)) 
[17:41:27.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.236]                     .init = FALSE)
[17:41:27.236]                 }
[17:41:27.236]             }
[17:41:27.236]         }
[17:41:27.236]     })
[17:41:27.236]     if (TRUE) {
[17:41:27.236]         base::sink(type = "output", split = FALSE)
[17:41:27.236]         if (TRUE) {
[17:41:27.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.236]         }
[17:41:27.236]         else {
[17:41:27.236]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.236]         }
[17:41:27.236]         base::close(...future.stdout)
[17:41:27.236]         ...future.stdout <- NULL
[17:41:27.236]     }
[17:41:27.236]     ...future.result$conditions <- ...future.conditions
[17:41:27.236]     ...future.result$finished <- base::Sys.time()
[17:41:27.236]     ...future.result
[17:41:27.236] }
[17:41:27.239] requestCore(): workers = 2
[17:41:27.241] MulticoreFuture started
[17:41:27.241] - Launch lazy future ... done
[17:41:27.241] run() for ‘MulticoreFuture’ ... done
[17:41:27.242] result() for MulticoreFuture ...
[17:41:27.242] plan(): Setting new future strategy stack:
[17:41:27.242] List of future strategies:
[17:41:27.242] 1. sequential:
[17:41:27.242]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.242]    - tweaked: FALSE
[17:41:27.242]    - call: NULL
[17:41:27.243] plan(): nbrOfWorkers() = 1
[17:41:27.247] plan(): Setting new future strategy stack:
[17:41:27.247] List of future strategies:
[17:41:27.247] 1. multicore:
[17:41:27.247]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.247]    - tweaked: FALSE
[17:41:27.247]    - call: plan(strategy)
[17:41:27.252] plan(): nbrOfWorkers() = 2
[17:41:27.253] result() for MulticoreFuture ...
[17:41:27.253] result() for MulticoreFuture ... done
[17:41:27.253] result() for MulticoreFuture ... done
[17:41:27.253] result() for MulticoreFuture ...
[17:41:27.253] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.254] getGlobalsAndPackages() ...
[17:41:27.254] Searching for globals...
[17:41:27.255] - globals found: [1] ‘print’
[17:41:27.255] Searching for globals ... DONE
[17:41:27.255] Resolving globals: FALSE
[17:41:27.255] 
[17:41:27.255] 
[17:41:27.256] getGlobalsAndPackages() ... DONE
[17:41:27.256] run() for ‘Future’ ...
[17:41:27.256] - state: ‘created’
[17:41:27.256] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.260] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.260]   - Field: ‘label’
[17:41:27.260]   - Field: ‘local’
[17:41:27.261]   - Field: ‘owner’
[17:41:27.261]   - Field: ‘envir’
[17:41:27.261]   - Field: ‘workers’
[17:41:27.261]   - Field: ‘packages’
[17:41:27.261]   - Field: ‘gc’
[17:41:27.261]   - Field: ‘job’
[17:41:27.261]   - Field: ‘conditions’
[17:41:27.261]   - Field: ‘expr’
[17:41:27.262]   - Field: ‘uuid’
[17:41:27.262]   - Field: ‘seed’
[17:41:27.262]   - Field: ‘version’
[17:41:27.262]   - Field: ‘result’
[17:41:27.262]   - Field: ‘asynchronous’
[17:41:27.262]   - Field: ‘calls’
[17:41:27.262]   - Field: ‘globals’
[17:41:27.262]   - Field: ‘stdout’
[17:41:27.262]   - Field: ‘earlySignal’
[17:41:27.262]   - Field: ‘lazy’
[17:41:27.263]   - Field: ‘state’
[17:41:27.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.263] - Launch lazy future ...
[17:41:27.263] Packages needed by the future expression (n = 0): <none>
[17:41:27.263] Packages needed by future strategies (n = 0): <none>
[17:41:27.264] {
[17:41:27.264]     {
[17:41:27.264]         {
[17:41:27.264]             ...future.startTime <- base::Sys.time()
[17:41:27.264]             {
[17:41:27.264]                 {
[17:41:27.264]                   {
[17:41:27.264]                     {
[17:41:27.264]                       base::local({
[17:41:27.264]                         has_future <- base::requireNamespace("future", 
[17:41:27.264]                           quietly = TRUE)
[17:41:27.264]                         if (has_future) {
[17:41:27.264]                           ns <- base::getNamespace("future")
[17:41:27.264]                           version <- ns[[".package"]][["version"]]
[17:41:27.264]                           if (is.null(version)) 
[17:41:27.264]                             version <- utils::packageVersion("future")
[17:41:27.264]                         }
[17:41:27.264]                         else {
[17:41:27.264]                           version <- NULL
[17:41:27.264]                         }
[17:41:27.264]                         if (!has_future || version < "1.8.0") {
[17:41:27.264]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.264]                             "", base::R.version$version.string), 
[17:41:27.264]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.264]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.264]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.264]                               "release", "version")], collapse = " "), 
[17:41:27.264]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.264]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.264]                             info)
[17:41:27.264]                           info <- base::paste(info, collapse = "; ")
[17:41:27.264]                           if (!has_future) {
[17:41:27.264]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.264]                               info)
[17:41:27.264]                           }
[17:41:27.264]                           else {
[17:41:27.264]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.264]                               info, version)
[17:41:27.264]                           }
[17:41:27.264]                           base::stop(msg)
[17:41:27.264]                         }
[17:41:27.264]                       })
[17:41:27.264]                     }
[17:41:27.264]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.264]                     base::options(mc.cores = 1L)
[17:41:27.264]                   }
[17:41:27.264]                   ...future.strategy.old <- future::plan("list")
[17:41:27.264]                   options(future.plan = NULL)
[17:41:27.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.264]                 }
[17:41:27.264]                 ...future.workdir <- getwd()
[17:41:27.264]             }
[17:41:27.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.264]         }
[17:41:27.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.264]             base::names(...future.oldOptions))
[17:41:27.264]     }
[17:41:27.264]     if (FALSE) {
[17:41:27.264]     }
[17:41:27.264]     else {
[17:41:27.264]         if (TRUE) {
[17:41:27.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.264]                 open = "w")
[17:41:27.264]         }
[17:41:27.264]         else {
[17:41:27.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.264]         }
[17:41:27.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.264]             base::sink(type = "output", split = FALSE)
[17:41:27.264]             base::close(...future.stdout)
[17:41:27.264]         }, add = TRUE)
[17:41:27.264]     }
[17:41:27.264]     ...future.frame <- base::sys.nframe()
[17:41:27.264]     ...future.conditions <- base::list()
[17:41:27.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.264]     if (FALSE) {
[17:41:27.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.264]     }
[17:41:27.264]     ...future.result <- base::tryCatch({
[17:41:27.264]         base::withCallingHandlers({
[17:41:27.264]             ...future.value <- base::withVisible(base::local({
[17:41:27.264]                 withCallingHandlers({
[17:41:27.264]                   print(42)
[17:41:27.264]                 }, immediateCondition = function(cond) {
[17:41:27.264]                   save_rds <- function (object, pathname, ...) 
[17:41:27.264]                   {
[17:41:27.264]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.264]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.264]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.264]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.264]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.264]                         fi_tmp[["mtime"]])
[17:41:27.264]                     }
[17:41:27.264]                     tryCatch({
[17:41:27.264]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.264]                     }, error = function(ex) {
[17:41:27.264]                       msg <- conditionMessage(ex)
[17:41:27.264]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.264]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.264]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.264]                         fi_tmp[["mtime"]], msg)
[17:41:27.264]                       ex$message <- msg
[17:41:27.264]                       stop(ex)
[17:41:27.264]                     })
[17:41:27.264]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.264]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.264]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.264]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.264]                       fi <- file.info(pathname)
[17:41:27.264]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.264]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.264]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.264]                         fi[["size"]], fi[["mtime"]])
[17:41:27.264]                       stop(msg)
[17:41:27.264]                     }
[17:41:27.264]                     invisible(pathname)
[17:41:27.264]                   }
[17:41:27.264]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.264]                     rootPath = tempdir()) 
[17:41:27.264]                   {
[17:41:27.264]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.264]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.264]                       tmpdir = path, fileext = ".rds")
[17:41:27.264]                     save_rds(obj, file)
[17:41:27.264]                   }
[17:41:27.264]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.264]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.264]                   {
[17:41:27.264]                     inherits <- base::inherits
[17:41:27.264]                     invokeRestart <- base::invokeRestart
[17:41:27.264]                     is.null <- base::is.null
[17:41:27.264]                     muffled <- FALSE
[17:41:27.264]                     if (inherits(cond, "message")) {
[17:41:27.264]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.264]                       if (muffled) 
[17:41:27.264]                         invokeRestart("muffleMessage")
[17:41:27.264]                     }
[17:41:27.264]                     else if (inherits(cond, "warning")) {
[17:41:27.264]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.264]                       if (muffled) 
[17:41:27.264]                         invokeRestart("muffleWarning")
[17:41:27.264]                     }
[17:41:27.264]                     else if (inherits(cond, "condition")) {
[17:41:27.264]                       if (!is.null(pattern)) {
[17:41:27.264]                         computeRestarts <- base::computeRestarts
[17:41:27.264]                         grepl <- base::grepl
[17:41:27.264]                         restarts <- computeRestarts(cond)
[17:41:27.264]                         for (restart in restarts) {
[17:41:27.264]                           name <- restart$name
[17:41:27.264]                           if (is.null(name)) 
[17:41:27.264]                             next
[17:41:27.264]                           if (!grepl(pattern, name)) 
[17:41:27.264]                             next
[17:41:27.264]                           invokeRestart(restart)
[17:41:27.264]                           muffled <- TRUE
[17:41:27.264]                           break
[17:41:27.264]                         }
[17:41:27.264]                       }
[17:41:27.264]                     }
[17:41:27.264]                     invisible(muffled)
[17:41:27.264]                   }
[17:41:27.264]                   muffleCondition(cond)
[17:41:27.264]                 })
[17:41:27.264]             }))
[17:41:27.264]             future::FutureResult(value = ...future.value$value, 
[17:41:27.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.264]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.264]                     ...future.globalenv.names))
[17:41:27.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.264]         }, condition = base::local({
[17:41:27.264]             c <- base::c
[17:41:27.264]             inherits <- base::inherits
[17:41:27.264]             invokeRestart <- base::invokeRestart
[17:41:27.264]             length <- base::length
[17:41:27.264]             list <- base::list
[17:41:27.264]             seq.int <- base::seq.int
[17:41:27.264]             signalCondition <- base::signalCondition
[17:41:27.264]             sys.calls <- base::sys.calls
[17:41:27.264]             `[[` <- base::`[[`
[17:41:27.264]             `+` <- base::`+`
[17:41:27.264]             `<<-` <- base::`<<-`
[17:41:27.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.264]                   3L)]
[17:41:27.264]             }
[17:41:27.264]             function(cond) {
[17:41:27.264]                 is_error <- inherits(cond, "error")
[17:41:27.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.264]                   NULL)
[17:41:27.264]                 if (is_error) {
[17:41:27.264]                   sessionInformation <- function() {
[17:41:27.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.264]                       search = base::search(), system = base::Sys.info())
[17:41:27.264]                   }
[17:41:27.264]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.264]                     cond$call), session = sessionInformation(), 
[17:41:27.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.264]                   signalCondition(cond)
[17:41:27.264]                 }
[17:41:27.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.264]                 "immediateCondition"))) {
[17:41:27.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.264]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.264]                   if (TRUE && !signal) {
[17:41:27.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.264]                     {
[17:41:27.264]                       inherits <- base::inherits
[17:41:27.264]                       invokeRestart <- base::invokeRestart
[17:41:27.264]                       is.null <- base::is.null
[17:41:27.264]                       muffled <- FALSE
[17:41:27.264]                       if (inherits(cond, "message")) {
[17:41:27.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.264]                         if (muffled) 
[17:41:27.264]                           invokeRestart("muffleMessage")
[17:41:27.264]                       }
[17:41:27.264]                       else if (inherits(cond, "warning")) {
[17:41:27.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.264]                         if (muffled) 
[17:41:27.264]                           invokeRestart("muffleWarning")
[17:41:27.264]                       }
[17:41:27.264]                       else if (inherits(cond, "condition")) {
[17:41:27.264]                         if (!is.null(pattern)) {
[17:41:27.264]                           computeRestarts <- base::computeRestarts
[17:41:27.264]                           grepl <- base::grepl
[17:41:27.264]                           restarts <- computeRestarts(cond)
[17:41:27.264]                           for (restart in restarts) {
[17:41:27.264]                             name <- restart$name
[17:41:27.264]                             if (is.null(name)) 
[17:41:27.264]                               next
[17:41:27.264]                             if (!grepl(pattern, name)) 
[17:41:27.264]                               next
[17:41:27.264]                             invokeRestart(restart)
[17:41:27.264]                             muffled <- TRUE
[17:41:27.264]                             break
[17:41:27.264]                           }
[17:41:27.264]                         }
[17:41:27.264]                       }
[17:41:27.264]                       invisible(muffled)
[17:41:27.264]                     }
[17:41:27.264]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.264]                   }
[17:41:27.264]                 }
[17:41:27.264]                 else {
[17:41:27.264]                   if (TRUE) {
[17:41:27.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.264]                     {
[17:41:27.264]                       inherits <- base::inherits
[17:41:27.264]                       invokeRestart <- base::invokeRestart
[17:41:27.264]                       is.null <- base::is.null
[17:41:27.264]                       muffled <- FALSE
[17:41:27.264]                       if (inherits(cond, "message")) {
[17:41:27.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.264]                         if (muffled) 
[17:41:27.264]                           invokeRestart("muffleMessage")
[17:41:27.264]                       }
[17:41:27.264]                       else if (inherits(cond, "warning")) {
[17:41:27.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.264]                         if (muffled) 
[17:41:27.264]                           invokeRestart("muffleWarning")
[17:41:27.264]                       }
[17:41:27.264]                       else if (inherits(cond, "condition")) {
[17:41:27.264]                         if (!is.null(pattern)) {
[17:41:27.264]                           computeRestarts <- base::computeRestarts
[17:41:27.264]                           grepl <- base::grepl
[17:41:27.264]                           restarts <- computeRestarts(cond)
[17:41:27.264]                           for (restart in restarts) {
[17:41:27.264]                             name <- restart$name
[17:41:27.264]                             if (is.null(name)) 
[17:41:27.264]                               next
[17:41:27.264]                             if (!grepl(pattern, name)) 
[17:41:27.264]                               next
[17:41:27.264]                             invokeRestart(restart)
[17:41:27.264]                             muffled <- TRUE
[17:41:27.264]                             break
[17:41:27.264]                           }
[17:41:27.264]                         }
[17:41:27.264]                       }
[17:41:27.264]                       invisible(muffled)
[17:41:27.264]                     }
[17:41:27.264]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.264]                   }
[17:41:27.264]                 }
[17:41:27.264]             }
[17:41:27.264]         }))
[17:41:27.264]     }, error = function(ex) {
[17:41:27.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.264]                 ...future.rng), started = ...future.startTime, 
[17:41:27.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.264]             version = "1.8"), class = "FutureResult")
[17:41:27.264]     }, finally = {
[17:41:27.264]         if (!identical(...future.workdir, getwd())) 
[17:41:27.264]             setwd(...future.workdir)
[17:41:27.264]         {
[17:41:27.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.264]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.264]             }
[17:41:27.264]             base::options(...future.oldOptions)
[17:41:27.264]             if (.Platform$OS.type == "windows") {
[17:41:27.264]                 old_names <- names(...future.oldEnvVars)
[17:41:27.264]                 envs <- base::Sys.getenv()
[17:41:27.264]                 names <- names(envs)
[17:41:27.264]                 common <- intersect(names, old_names)
[17:41:27.264]                 added <- setdiff(names, old_names)
[17:41:27.264]                 removed <- setdiff(old_names, names)
[17:41:27.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.264]                   envs[common]]
[17:41:27.264]                 NAMES <- toupper(changed)
[17:41:27.264]                 args <- list()
[17:41:27.264]                 for (kk in seq_along(NAMES)) {
[17:41:27.264]                   name <- changed[[kk]]
[17:41:27.264]                   NAME <- NAMES[[kk]]
[17:41:27.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.264]                     next
[17:41:27.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.264]                 }
[17:41:27.264]                 NAMES <- toupper(added)
[17:41:27.264]                 for (kk in seq_along(NAMES)) {
[17:41:27.264]                   name <- added[[kk]]
[17:41:27.264]                   NAME <- NAMES[[kk]]
[17:41:27.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.264]                     next
[17:41:27.264]                   args[[name]] <- ""
[17:41:27.264]                 }
[17:41:27.264]                 NAMES <- toupper(removed)
[17:41:27.264]                 for (kk in seq_along(NAMES)) {
[17:41:27.264]                   name <- removed[[kk]]
[17:41:27.264]                   NAME <- NAMES[[kk]]
[17:41:27.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.264]                     next
[17:41:27.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.264]                 }
[17:41:27.264]                 if (length(args) > 0) 
[17:41:27.264]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.264]             }
[17:41:27.264]             else {
[17:41:27.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.264]             }
[17:41:27.264]             {
[17:41:27.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.264]                   0L) {
[17:41:27.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.264]                   base::options(opts)
[17:41:27.264]                 }
[17:41:27.264]                 {
[17:41:27.264]                   {
[17:41:27.264]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.264]                     NULL
[17:41:27.264]                   }
[17:41:27.264]                   options(future.plan = NULL)
[17:41:27.264]                   if (is.na(NA_character_)) 
[17:41:27.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.264]                     .init = FALSE)
[17:41:27.264]                 }
[17:41:27.264]             }
[17:41:27.264]         }
[17:41:27.264]     })
[17:41:27.264]     if (TRUE) {
[17:41:27.264]         base::sink(type = "output", split = FALSE)
[17:41:27.264]         if (TRUE) {
[17:41:27.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.264]         }
[17:41:27.264]         else {
[17:41:27.264]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.264]         }
[17:41:27.264]         base::close(...future.stdout)
[17:41:27.264]         ...future.stdout <- NULL
[17:41:27.264]     }
[17:41:27.264]     ...future.result$conditions <- ...future.conditions
[17:41:27.264]     ...future.result$finished <- base::Sys.time()
[17:41:27.264]     ...future.result
[17:41:27.264] }
[17:41:27.266] requestCore(): workers = 2
[17:41:27.268] MulticoreFuture started
[17:41:27.268] - Launch lazy future ... done
[17:41:27.269] run() for ‘MulticoreFuture’ ... done
[17:41:27.269] result() for MulticoreFuture ...
[17:41:27.269] plan(): Setting new future strategy stack:
[17:41:27.269] List of future strategies:
[17:41:27.269] 1. sequential:
[17:41:27.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.269]    - tweaked: FALSE
[17:41:27.269]    - call: NULL
[17:41:27.270] plan(): nbrOfWorkers() = 1
[17:41:27.272] plan(): Setting new future strategy stack:
[17:41:27.273] List of future strategies:
[17:41:27.273] 1. multicore:
[17:41:27.273]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.273]    - tweaked: FALSE
[17:41:27.273]    - call: plan(strategy)
[17:41:27.277] plan(): nbrOfWorkers() = 2
[17:41:27.278] result() for MulticoreFuture ...
[17:41:27.278] result() for MulticoreFuture ... done
[17:41:27.278] result() for MulticoreFuture ... done
[17:41:27.279] result() for MulticoreFuture ...
[17:41:27.279] result() for MulticoreFuture ... done
[17:41:27.279] result() for MulticoreFuture ...
[17:41:27.279] result() for MulticoreFuture ... done
[1] 42
[17:41:27.279] result() for MulticoreFuture ...
[17:41:27.279] result() for MulticoreFuture ... done
- stdout = FALSE
[17:41:27.280] getGlobalsAndPackages() ...
[17:41:27.280] Searching for globals...
[17:41:27.283] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.284] Searching for globals ... DONE
[17:41:27.284] Resolving globals: FALSE
[17:41:27.284] 
[17:41:27.284] - packages: [1] ‘utils’
[17:41:27.285] getGlobalsAndPackages() ... DONE
[17:41:27.285] run() for ‘Future’ ...
[17:41:27.285] - state: ‘created’
[17:41:27.285] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.289] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.290]   - Field: ‘label’
[17:41:27.290]   - Field: ‘local’
[17:41:27.290]   - Field: ‘owner’
[17:41:27.290]   - Field: ‘envir’
[17:41:27.290]   - Field: ‘workers’
[17:41:27.290]   - Field: ‘packages’
[17:41:27.290]   - Field: ‘gc’
[17:41:27.290]   - Field: ‘job’
[17:41:27.290]   - Field: ‘conditions’
[17:41:27.291]   - Field: ‘expr’
[17:41:27.291]   - Field: ‘uuid’
[17:41:27.291]   - Field: ‘seed’
[17:41:27.291]   - Field: ‘version’
[17:41:27.291]   - Field: ‘result’
[17:41:27.291]   - Field: ‘asynchronous’
[17:41:27.291]   - Field: ‘calls’
[17:41:27.291]   - Field: ‘globals’
[17:41:27.291]   - Field: ‘stdout’
[17:41:27.291]   - Field: ‘earlySignal’
[17:41:27.292]   - Field: ‘lazy’
[17:41:27.292]   - Field: ‘state’
[17:41:27.292] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.292] - Launch lazy future ...
[17:41:27.292] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.292] Packages needed by future strategies (n = 0): <none>
[17:41:27.293] {
[17:41:27.293]     {
[17:41:27.293]         {
[17:41:27.293]             ...future.startTime <- base::Sys.time()
[17:41:27.293]             {
[17:41:27.293]                 {
[17:41:27.293]                   {
[17:41:27.293]                     {
[17:41:27.293]                       {
[17:41:27.293]                         base::local({
[17:41:27.293]                           has_future <- base::requireNamespace("future", 
[17:41:27.293]                             quietly = TRUE)
[17:41:27.293]                           if (has_future) {
[17:41:27.293]                             ns <- base::getNamespace("future")
[17:41:27.293]                             version <- ns[[".package"]][["version"]]
[17:41:27.293]                             if (is.null(version)) 
[17:41:27.293]                               version <- utils::packageVersion("future")
[17:41:27.293]                           }
[17:41:27.293]                           else {
[17:41:27.293]                             version <- NULL
[17:41:27.293]                           }
[17:41:27.293]                           if (!has_future || version < "1.8.0") {
[17:41:27.293]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.293]                               "", base::R.version$version.string), 
[17:41:27.293]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.293]                                 base::R.version$platform, 8 * 
[17:41:27.293]                                   base::.Machine$sizeof.pointer), 
[17:41:27.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.293]                                 "release", "version")], collapse = " "), 
[17:41:27.293]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.293]                               info)
[17:41:27.293]                             info <- base::paste(info, collapse = "; ")
[17:41:27.293]                             if (!has_future) {
[17:41:27.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.293]                                 info)
[17:41:27.293]                             }
[17:41:27.293]                             else {
[17:41:27.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.293]                                 info, version)
[17:41:27.293]                             }
[17:41:27.293]                             base::stop(msg)
[17:41:27.293]                           }
[17:41:27.293]                         })
[17:41:27.293]                       }
[17:41:27.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.293]                       base::options(mc.cores = 1L)
[17:41:27.293]                     }
[17:41:27.293]                     base::local({
[17:41:27.293]                       for (pkg in "utils") {
[17:41:27.293]                         base::loadNamespace(pkg)
[17:41:27.293]                         base::library(pkg, character.only = TRUE)
[17:41:27.293]                       }
[17:41:27.293]                     })
[17:41:27.293]                   }
[17:41:27.293]                   ...future.strategy.old <- future::plan("list")
[17:41:27.293]                   options(future.plan = NULL)
[17:41:27.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.293]                 }
[17:41:27.293]                 ...future.workdir <- getwd()
[17:41:27.293]             }
[17:41:27.293]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.293]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.293]         }
[17:41:27.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.293]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.293]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.293]             base::names(...future.oldOptions))
[17:41:27.293]     }
[17:41:27.293]     if (FALSE) {
[17:41:27.293]     }
[17:41:27.293]     else {
[17:41:27.293]         if (FALSE) {
[17:41:27.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.293]                 open = "w")
[17:41:27.293]         }
[17:41:27.293]         else {
[17:41:27.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.293]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.293]         }
[17:41:27.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.293]             base::sink(type = "output", split = FALSE)
[17:41:27.293]             base::close(...future.stdout)
[17:41:27.293]         }, add = TRUE)
[17:41:27.293]     }
[17:41:27.293]     ...future.frame <- base::sys.nframe()
[17:41:27.293]     ...future.conditions <- base::list()
[17:41:27.293]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.293]     if (FALSE) {
[17:41:27.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.293]     }
[17:41:27.293]     ...future.result <- base::tryCatch({
[17:41:27.293]         base::withCallingHandlers({
[17:41:27.293]             ...future.value <- base::withVisible(base::local({
[17:41:27.293]                 withCallingHandlers({
[17:41:27.293]                   {
[17:41:27.293]                     print(1:50)
[17:41:27.293]                     str(1:50)
[17:41:27.293]                     cat(letters, sep = "-")
[17:41:27.293]                     cat(1:6, collapse = "\n")
[17:41:27.293]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.293]                     42L
[17:41:27.293]                   }
[17:41:27.293]                 }, immediateCondition = function(cond) {
[17:41:27.293]                   save_rds <- function (object, pathname, ...) 
[17:41:27.293]                   {
[17:41:27.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.293]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.293]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.293]                         fi_tmp[["mtime"]])
[17:41:27.293]                     }
[17:41:27.293]                     tryCatch({
[17:41:27.293]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.293]                     }, error = function(ex) {
[17:41:27.293]                       msg <- conditionMessage(ex)
[17:41:27.293]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.293]                         fi_tmp[["mtime"]], msg)
[17:41:27.293]                       ex$message <- msg
[17:41:27.293]                       stop(ex)
[17:41:27.293]                     })
[17:41:27.293]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.293]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.293]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.293]                       fi <- file.info(pathname)
[17:41:27.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.293]                         fi[["size"]], fi[["mtime"]])
[17:41:27.293]                       stop(msg)
[17:41:27.293]                     }
[17:41:27.293]                     invisible(pathname)
[17:41:27.293]                   }
[17:41:27.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.293]                     rootPath = tempdir()) 
[17:41:27.293]                   {
[17:41:27.293]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.293]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.293]                       tmpdir = path, fileext = ".rds")
[17:41:27.293]                     save_rds(obj, file)
[17:41:27.293]                   }
[17:41:27.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.293]                   {
[17:41:27.293]                     inherits <- base::inherits
[17:41:27.293]                     invokeRestart <- base::invokeRestart
[17:41:27.293]                     is.null <- base::is.null
[17:41:27.293]                     muffled <- FALSE
[17:41:27.293]                     if (inherits(cond, "message")) {
[17:41:27.293]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.293]                       if (muffled) 
[17:41:27.293]                         invokeRestart("muffleMessage")
[17:41:27.293]                     }
[17:41:27.293]                     else if (inherits(cond, "warning")) {
[17:41:27.293]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.293]                       if (muffled) 
[17:41:27.293]                         invokeRestart("muffleWarning")
[17:41:27.293]                     }
[17:41:27.293]                     else if (inherits(cond, "condition")) {
[17:41:27.293]                       if (!is.null(pattern)) {
[17:41:27.293]                         computeRestarts <- base::computeRestarts
[17:41:27.293]                         grepl <- base::grepl
[17:41:27.293]                         restarts <- computeRestarts(cond)
[17:41:27.293]                         for (restart in restarts) {
[17:41:27.293]                           name <- restart$name
[17:41:27.293]                           if (is.null(name)) 
[17:41:27.293]                             next
[17:41:27.293]                           if (!grepl(pattern, name)) 
[17:41:27.293]                             next
[17:41:27.293]                           invokeRestart(restart)
[17:41:27.293]                           muffled <- TRUE
[17:41:27.293]                           break
[17:41:27.293]                         }
[17:41:27.293]                       }
[17:41:27.293]                     }
[17:41:27.293]                     invisible(muffled)
[17:41:27.293]                   }
[17:41:27.293]                   muffleCondition(cond)
[17:41:27.293]                 })
[17:41:27.293]             }))
[17:41:27.293]             future::FutureResult(value = ...future.value$value, 
[17:41:27.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.293]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.293]                     ...future.globalenv.names))
[17:41:27.293]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.293]         }, condition = base::local({
[17:41:27.293]             c <- base::c
[17:41:27.293]             inherits <- base::inherits
[17:41:27.293]             invokeRestart <- base::invokeRestart
[17:41:27.293]             length <- base::length
[17:41:27.293]             list <- base::list
[17:41:27.293]             seq.int <- base::seq.int
[17:41:27.293]             signalCondition <- base::signalCondition
[17:41:27.293]             sys.calls <- base::sys.calls
[17:41:27.293]             `[[` <- base::`[[`
[17:41:27.293]             `+` <- base::`+`
[17:41:27.293]             `<<-` <- base::`<<-`
[17:41:27.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.293]                   3L)]
[17:41:27.293]             }
[17:41:27.293]             function(cond) {
[17:41:27.293]                 is_error <- inherits(cond, "error")
[17:41:27.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.293]                   NULL)
[17:41:27.293]                 if (is_error) {
[17:41:27.293]                   sessionInformation <- function() {
[17:41:27.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.293]                       search = base::search(), system = base::Sys.info())
[17:41:27.293]                   }
[17:41:27.293]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.293]                     cond$call), session = sessionInformation(), 
[17:41:27.293]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.293]                   signalCondition(cond)
[17:41:27.293]                 }
[17:41:27.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.293]                 "immediateCondition"))) {
[17:41:27.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.293]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.293]                   if (TRUE && !signal) {
[17:41:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.293]                     {
[17:41:27.293]                       inherits <- base::inherits
[17:41:27.293]                       invokeRestart <- base::invokeRestart
[17:41:27.293]                       is.null <- base::is.null
[17:41:27.293]                       muffled <- FALSE
[17:41:27.293]                       if (inherits(cond, "message")) {
[17:41:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.293]                         if (muffled) 
[17:41:27.293]                           invokeRestart("muffleMessage")
[17:41:27.293]                       }
[17:41:27.293]                       else if (inherits(cond, "warning")) {
[17:41:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.293]                         if (muffled) 
[17:41:27.293]                           invokeRestart("muffleWarning")
[17:41:27.293]                       }
[17:41:27.293]                       else if (inherits(cond, "condition")) {
[17:41:27.293]                         if (!is.null(pattern)) {
[17:41:27.293]                           computeRestarts <- base::computeRestarts
[17:41:27.293]                           grepl <- base::grepl
[17:41:27.293]                           restarts <- computeRestarts(cond)
[17:41:27.293]                           for (restart in restarts) {
[17:41:27.293]                             name <- restart$name
[17:41:27.293]                             if (is.null(name)) 
[17:41:27.293]                               next
[17:41:27.293]                             if (!grepl(pattern, name)) 
[17:41:27.293]                               next
[17:41:27.293]                             invokeRestart(restart)
[17:41:27.293]                             muffled <- TRUE
[17:41:27.293]                             break
[17:41:27.293]                           }
[17:41:27.293]                         }
[17:41:27.293]                       }
[17:41:27.293]                       invisible(muffled)
[17:41:27.293]                     }
[17:41:27.293]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.293]                   }
[17:41:27.293]                 }
[17:41:27.293]                 else {
[17:41:27.293]                   if (TRUE) {
[17:41:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.293]                     {
[17:41:27.293]                       inherits <- base::inherits
[17:41:27.293]                       invokeRestart <- base::invokeRestart
[17:41:27.293]                       is.null <- base::is.null
[17:41:27.293]                       muffled <- FALSE
[17:41:27.293]                       if (inherits(cond, "message")) {
[17:41:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.293]                         if (muffled) 
[17:41:27.293]                           invokeRestart("muffleMessage")
[17:41:27.293]                       }
[17:41:27.293]                       else if (inherits(cond, "warning")) {
[17:41:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.293]                         if (muffled) 
[17:41:27.293]                           invokeRestart("muffleWarning")
[17:41:27.293]                       }
[17:41:27.293]                       else if (inherits(cond, "condition")) {
[17:41:27.293]                         if (!is.null(pattern)) {
[17:41:27.293]                           computeRestarts <- base::computeRestarts
[17:41:27.293]                           grepl <- base::grepl
[17:41:27.293]                           restarts <- computeRestarts(cond)
[17:41:27.293]                           for (restart in restarts) {
[17:41:27.293]                             name <- restart$name
[17:41:27.293]                             if (is.null(name)) 
[17:41:27.293]                               next
[17:41:27.293]                             if (!grepl(pattern, name)) 
[17:41:27.293]                               next
[17:41:27.293]                             invokeRestart(restart)
[17:41:27.293]                             muffled <- TRUE
[17:41:27.293]                             break
[17:41:27.293]                           }
[17:41:27.293]                         }
[17:41:27.293]                       }
[17:41:27.293]                       invisible(muffled)
[17:41:27.293]                     }
[17:41:27.293]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.293]                   }
[17:41:27.293]                 }
[17:41:27.293]             }
[17:41:27.293]         }))
[17:41:27.293]     }, error = function(ex) {
[17:41:27.293]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.293]                 ...future.rng), started = ...future.startTime, 
[17:41:27.293]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.293]             version = "1.8"), class = "FutureResult")
[17:41:27.293]     }, finally = {
[17:41:27.293]         if (!identical(...future.workdir, getwd())) 
[17:41:27.293]             setwd(...future.workdir)
[17:41:27.293]         {
[17:41:27.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.293]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.293]             }
[17:41:27.293]             base::options(...future.oldOptions)
[17:41:27.293]             if (.Platform$OS.type == "windows") {
[17:41:27.293]                 old_names <- names(...future.oldEnvVars)
[17:41:27.293]                 envs <- base::Sys.getenv()
[17:41:27.293]                 names <- names(envs)
[17:41:27.293]                 common <- intersect(names, old_names)
[17:41:27.293]                 added <- setdiff(names, old_names)
[17:41:27.293]                 removed <- setdiff(old_names, names)
[17:41:27.293]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.293]                   envs[common]]
[17:41:27.293]                 NAMES <- toupper(changed)
[17:41:27.293]                 args <- list()
[17:41:27.293]                 for (kk in seq_along(NAMES)) {
[17:41:27.293]                   name <- changed[[kk]]
[17:41:27.293]                   NAME <- NAMES[[kk]]
[17:41:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.293]                     next
[17:41:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.293]                 }
[17:41:27.293]                 NAMES <- toupper(added)
[17:41:27.293]                 for (kk in seq_along(NAMES)) {
[17:41:27.293]                   name <- added[[kk]]
[17:41:27.293]                   NAME <- NAMES[[kk]]
[17:41:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.293]                     next
[17:41:27.293]                   args[[name]] <- ""
[17:41:27.293]                 }
[17:41:27.293]                 NAMES <- toupper(removed)
[17:41:27.293]                 for (kk in seq_along(NAMES)) {
[17:41:27.293]                   name <- removed[[kk]]
[17:41:27.293]                   NAME <- NAMES[[kk]]
[17:41:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.293]                     next
[17:41:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.293]                 }
[17:41:27.293]                 if (length(args) > 0) 
[17:41:27.293]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.293]             }
[17:41:27.293]             else {
[17:41:27.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.293]             }
[17:41:27.293]             {
[17:41:27.293]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.293]                   0L) {
[17:41:27.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.293]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.293]                   base::options(opts)
[17:41:27.293]                 }
[17:41:27.293]                 {
[17:41:27.293]                   {
[17:41:27.293]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.293]                     NULL
[17:41:27.293]                   }
[17:41:27.293]                   options(future.plan = NULL)
[17:41:27.293]                   if (is.na(NA_character_)) 
[17:41:27.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.293]                     .init = FALSE)
[17:41:27.293]                 }
[17:41:27.293]             }
[17:41:27.293]         }
[17:41:27.293]     })
[17:41:27.293]     if (TRUE) {
[17:41:27.293]         base::sink(type = "output", split = FALSE)
[17:41:27.293]         if (FALSE) {
[17:41:27.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.293]         }
[17:41:27.293]         else {
[17:41:27.293]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.293]         }
[17:41:27.293]         base::close(...future.stdout)
[17:41:27.293]         ...future.stdout <- NULL
[17:41:27.293]     }
[17:41:27.293]     ...future.result$conditions <- ...future.conditions
[17:41:27.293]     ...future.result$finished <- base::Sys.time()
[17:41:27.293]     ...future.result
[17:41:27.293] }
[17:41:27.296] requestCore(): workers = 2
[17:41:27.297] MulticoreFuture started
[17:41:27.298] - Launch lazy future ... done
[17:41:27.298] run() for ‘MulticoreFuture’ ... done
[17:41:27.298] result() for MulticoreFuture ...
[17:41:27.298] plan(): Setting new future strategy stack:
[17:41:27.299] List of future strategies:
[17:41:27.299] 1. sequential:
[17:41:27.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.299]    - tweaked: FALSE
[17:41:27.299]    - call: NULL
[17:41:27.300] plan(): nbrOfWorkers() = 1
[17:41:27.308] plan(): Setting new future strategy stack:
[17:41:27.308] List of future strategies:
[17:41:27.308] 1. multicore:
[17:41:27.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.308]    - tweaked: FALSE
[17:41:27.308]    - call: plan(strategy)
[17:41:27.313] plan(): nbrOfWorkers() = 2
[17:41:27.314] result() for MulticoreFuture ...
[17:41:27.314] result() for MulticoreFuture ... done
[17:41:27.314] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "4c282a84-040b-a5b2-7b1f-da80b40b14a8"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50469
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:27"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:27.326] result() for MulticoreFuture ...
[17:41:27.327] result() for MulticoreFuture ... done
[17:41:27.327] result() for MulticoreFuture ...
[17:41:27.327] result() for MulticoreFuture ... done
[17:41:27.327] getGlobalsAndPackages() ...
[17:41:27.327] Searching for globals...
[17:41:27.331] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.331] Searching for globals ... DONE
[17:41:27.331] Resolving globals: FALSE
[17:41:27.332] 
[17:41:27.332] - packages: [1] ‘utils’
[17:41:27.332] getGlobalsAndPackages() ... DONE
[17:41:27.332] run() for ‘Future’ ...
[17:41:27.332] - state: ‘created’
[17:41:27.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.336]   - Field: ‘label’
[17:41:27.337]   - Field: ‘local’
[17:41:27.337]   - Field: ‘owner’
[17:41:27.337]   - Field: ‘envir’
[17:41:27.337]   - Field: ‘workers’
[17:41:27.337]   - Field: ‘packages’
[17:41:27.337]   - Field: ‘gc’
[17:41:27.337]   - Field: ‘job’
[17:41:27.337]   - Field: ‘conditions’
[17:41:27.337]   - Field: ‘expr’
[17:41:27.338]   - Field: ‘uuid’
[17:41:27.338]   - Field: ‘seed’
[17:41:27.338]   - Field: ‘version’
[17:41:27.338]   - Field: ‘result’
[17:41:27.338]   - Field: ‘asynchronous’
[17:41:27.338]   - Field: ‘calls’
[17:41:27.338]   - Field: ‘globals’
[17:41:27.338]   - Field: ‘stdout’
[17:41:27.338]   - Field: ‘earlySignal’
[17:41:27.339]   - Field: ‘lazy’
[17:41:27.339]   - Field: ‘state’
[17:41:27.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.339] - Launch lazy future ...
[17:41:27.339] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.339] Packages needed by future strategies (n = 0): <none>
[17:41:27.340] {
[17:41:27.340]     {
[17:41:27.340]         {
[17:41:27.340]             ...future.startTime <- base::Sys.time()
[17:41:27.340]             {
[17:41:27.340]                 {
[17:41:27.340]                   {
[17:41:27.340]                     {
[17:41:27.340]                       {
[17:41:27.340]                         base::local({
[17:41:27.340]                           has_future <- base::requireNamespace("future", 
[17:41:27.340]                             quietly = TRUE)
[17:41:27.340]                           if (has_future) {
[17:41:27.340]                             ns <- base::getNamespace("future")
[17:41:27.340]                             version <- ns[[".package"]][["version"]]
[17:41:27.340]                             if (is.null(version)) 
[17:41:27.340]                               version <- utils::packageVersion("future")
[17:41:27.340]                           }
[17:41:27.340]                           else {
[17:41:27.340]                             version <- NULL
[17:41:27.340]                           }
[17:41:27.340]                           if (!has_future || version < "1.8.0") {
[17:41:27.340]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.340]                               "", base::R.version$version.string), 
[17:41:27.340]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.340]                                 base::R.version$platform, 8 * 
[17:41:27.340]                                   base::.Machine$sizeof.pointer), 
[17:41:27.340]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.340]                                 "release", "version")], collapse = " "), 
[17:41:27.340]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.340]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.340]                               info)
[17:41:27.340]                             info <- base::paste(info, collapse = "; ")
[17:41:27.340]                             if (!has_future) {
[17:41:27.340]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.340]                                 info)
[17:41:27.340]                             }
[17:41:27.340]                             else {
[17:41:27.340]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.340]                                 info, version)
[17:41:27.340]                             }
[17:41:27.340]                             base::stop(msg)
[17:41:27.340]                           }
[17:41:27.340]                         })
[17:41:27.340]                       }
[17:41:27.340]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.340]                       base::options(mc.cores = 1L)
[17:41:27.340]                     }
[17:41:27.340]                     base::local({
[17:41:27.340]                       for (pkg in "utils") {
[17:41:27.340]                         base::loadNamespace(pkg)
[17:41:27.340]                         base::library(pkg, character.only = TRUE)
[17:41:27.340]                       }
[17:41:27.340]                     })
[17:41:27.340]                   }
[17:41:27.340]                   ...future.strategy.old <- future::plan("list")
[17:41:27.340]                   options(future.plan = NULL)
[17:41:27.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.340]                 }
[17:41:27.340]                 ...future.workdir <- getwd()
[17:41:27.340]             }
[17:41:27.340]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.340]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.340]         }
[17:41:27.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.340]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.340]             base::names(...future.oldOptions))
[17:41:27.340]     }
[17:41:27.340]     if (FALSE) {
[17:41:27.340]     }
[17:41:27.340]     else {
[17:41:27.340]         if (FALSE) {
[17:41:27.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.340]                 open = "w")
[17:41:27.340]         }
[17:41:27.340]         else {
[17:41:27.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.340]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.340]         }
[17:41:27.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.340]             base::sink(type = "output", split = FALSE)
[17:41:27.340]             base::close(...future.stdout)
[17:41:27.340]         }, add = TRUE)
[17:41:27.340]     }
[17:41:27.340]     ...future.frame <- base::sys.nframe()
[17:41:27.340]     ...future.conditions <- base::list()
[17:41:27.340]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.340]     if (FALSE) {
[17:41:27.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.340]     }
[17:41:27.340]     ...future.result <- base::tryCatch({
[17:41:27.340]         base::withCallingHandlers({
[17:41:27.340]             ...future.value <- base::withVisible(base::local({
[17:41:27.340]                 withCallingHandlers({
[17:41:27.340]                   {
[17:41:27.340]                     print(1:50)
[17:41:27.340]                     str(1:50)
[17:41:27.340]                     cat(letters, sep = "-")
[17:41:27.340]                     cat(1:6, collapse = "\n")
[17:41:27.340]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.340]                     42L
[17:41:27.340]                   }
[17:41:27.340]                 }, immediateCondition = function(cond) {
[17:41:27.340]                   save_rds <- function (object, pathname, ...) 
[17:41:27.340]                   {
[17:41:27.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.340]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.340]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.340]                         fi_tmp[["mtime"]])
[17:41:27.340]                     }
[17:41:27.340]                     tryCatch({
[17:41:27.340]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.340]                     }, error = function(ex) {
[17:41:27.340]                       msg <- conditionMessage(ex)
[17:41:27.340]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.340]                         fi_tmp[["mtime"]], msg)
[17:41:27.340]                       ex$message <- msg
[17:41:27.340]                       stop(ex)
[17:41:27.340]                     })
[17:41:27.340]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.340]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.340]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.340]                       fi <- file.info(pathname)
[17:41:27.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.340]                         fi[["size"]], fi[["mtime"]])
[17:41:27.340]                       stop(msg)
[17:41:27.340]                     }
[17:41:27.340]                     invisible(pathname)
[17:41:27.340]                   }
[17:41:27.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.340]                     rootPath = tempdir()) 
[17:41:27.340]                   {
[17:41:27.340]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.340]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.340]                       tmpdir = path, fileext = ".rds")
[17:41:27.340]                     save_rds(obj, file)
[17:41:27.340]                   }
[17:41:27.340]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.340]                   {
[17:41:27.340]                     inherits <- base::inherits
[17:41:27.340]                     invokeRestart <- base::invokeRestart
[17:41:27.340]                     is.null <- base::is.null
[17:41:27.340]                     muffled <- FALSE
[17:41:27.340]                     if (inherits(cond, "message")) {
[17:41:27.340]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.340]                       if (muffled) 
[17:41:27.340]                         invokeRestart("muffleMessage")
[17:41:27.340]                     }
[17:41:27.340]                     else if (inherits(cond, "warning")) {
[17:41:27.340]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.340]                       if (muffled) 
[17:41:27.340]                         invokeRestart("muffleWarning")
[17:41:27.340]                     }
[17:41:27.340]                     else if (inherits(cond, "condition")) {
[17:41:27.340]                       if (!is.null(pattern)) {
[17:41:27.340]                         computeRestarts <- base::computeRestarts
[17:41:27.340]                         grepl <- base::grepl
[17:41:27.340]                         restarts <- computeRestarts(cond)
[17:41:27.340]                         for (restart in restarts) {
[17:41:27.340]                           name <- restart$name
[17:41:27.340]                           if (is.null(name)) 
[17:41:27.340]                             next
[17:41:27.340]                           if (!grepl(pattern, name)) 
[17:41:27.340]                             next
[17:41:27.340]                           invokeRestart(restart)
[17:41:27.340]                           muffled <- TRUE
[17:41:27.340]                           break
[17:41:27.340]                         }
[17:41:27.340]                       }
[17:41:27.340]                     }
[17:41:27.340]                     invisible(muffled)
[17:41:27.340]                   }
[17:41:27.340]                   muffleCondition(cond)
[17:41:27.340]                 })
[17:41:27.340]             }))
[17:41:27.340]             future::FutureResult(value = ...future.value$value, 
[17:41:27.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.340]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.340]                     ...future.globalenv.names))
[17:41:27.340]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.340]         }, condition = base::local({
[17:41:27.340]             c <- base::c
[17:41:27.340]             inherits <- base::inherits
[17:41:27.340]             invokeRestart <- base::invokeRestart
[17:41:27.340]             length <- base::length
[17:41:27.340]             list <- base::list
[17:41:27.340]             seq.int <- base::seq.int
[17:41:27.340]             signalCondition <- base::signalCondition
[17:41:27.340]             sys.calls <- base::sys.calls
[17:41:27.340]             `[[` <- base::`[[`
[17:41:27.340]             `+` <- base::`+`
[17:41:27.340]             `<<-` <- base::`<<-`
[17:41:27.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.340]                   3L)]
[17:41:27.340]             }
[17:41:27.340]             function(cond) {
[17:41:27.340]                 is_error <- inherits(cond, "error")
[17:41:27.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.340]                   NULL)
[17:41:27.340]                 if (is_error) {
[17:41:27.340]                   sessionInformation <- function() {
[17:41:27.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.340]                       search = base::search(), system = base::Sys.info())
[17:41:27.340]                   }
[17:41:27.340]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.340]                     cond$call), session = sessionInformation(), 
[17:41:27.340]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.340]                   signalCondition(cond)
[17:41:27.340]                 }
[17:41:27.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.340]                 "immediateCondition"))) {
[17:41:27.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.340]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.340]                   if (TRUE && !signal) {
[17:41:27.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.340]                     {
[17:41:27.340]                       inherits <- base::inherits
[17:41:27.340]                       invokeRestart <- base::invokeRestart
[17:41:27.340]                       is.null <- base::is.null
[17:41:27.340]                       muffled <- FALSE
[17:41:27.340]                       if (inherits(cond, "message")) {
[17:41:27.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.340]                         if (muffled) 
[17:41:27.340]                           invokeRestart("muffleMessage")
[17:41:27.340]                       }
[17:41:27.340]                       else if (inherits(cond, "warning")) {
[17:41:27.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.340]                         if (muffled) 
[17:41:27.340]                           invokeRestart("muffleWarning")
[17:41:27.340]                       }
[17:41:27.340]                       else if (inherits(cond, "condition")) {
[17:41:27.340]                         if (!is.null(pattern)) {
[17:41:27.340]                           computeRestarts <- base::computeRestarts
[17:41:27.340]                           grepl <- base::grepl
[17:41:27.340]                           restarts <- computeRestarts(cond)
[17:41:27.340]                           for (restart in restarts) {
[17:41:27.340]                             name <- restart$name
[17:41:27.340]                             if (is.null(name)) 
[17:41:27.340]                               next
[17:41:27.340]                             if (!grepl(pattern, name)) 
[17:41:27.340]                               next
[17:41:27.340]                             invokeRestart(restart)
[17:41:27.340]                             muffled <- TRUE
[17:41:27.340]                             break
[17:41:27.340]                           }
[17:41:27.340]                         }
[17:41:27.340]                       }
[17:41:27.340]                       invisible(muffled)
[17:41:27.340]                     }
[17:41:27.340]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.340]                   }
[17:41:27.340]                 }
[17:41:27.340]                 else {
[17:41:27.340]                   if (TRUE) {
[17:41:27.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.340]                     {
[17:41:27.340]                       inherits <- base::inherits
[17:41:27.340]                       invokeRestart <- base::invokeRestart
[17:41:27.340]                       is.null <- base::is.null
[17:41:27.340]                       muffled <- FALSE
[17:41:27.340]                       if (inherits(cond, "message")) {
[17:41:27.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.340]                         if (muffled) 
[17:41:27.340]                           invokeRestart("muffleMessage")
[17:41:27.340]                       }
[17:41:27.340]                       else if (inherits(cond, "warning")) {
[17:41:27.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.340]                         if (muffled) 
[17:41:27.340]                           invokeRestart("muffleWarning")
[17:41:27.340]                       }
[17:41:27.340]                       else if (inherits(cond, "condition")) {
[17:41:27.340]                         if (!is.null(pattern)) {
[17:41:27.340]                           computeRestarts <- base::computeRestarts
[17:41:27.340]                           grepl <- base::grepl
[17:41:27.340]                           restarts <- computeRestarts(cond)
[17:41:27.340]                           for (restart in restarts) {
[17:41:27.340]                             name <- restart$name
[17:41:27.340]                             if (is.null(name)) 
[17:41:27.340]                               next
[17:41:27.340]                             if (!grepl(pattern, name)) 
[17:41:27.340]                               next
[17:41:27.340]                             invokeRestart(restart)
[17:41:27.340]                             muffled <- TRUE
[17:41:27.340]                             break
[17:41:27.340]                           }
[17:41:27.340]                         }
[17:41:27.340]                       }
[17:41:27.340]                       invisible(muffled)
[17:41:27.340]                     }
[17:41:27.340]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.340]                   }
[17:41:27.340]                 }
[17:41:27.340]             }
[17:41:27.340]         }))
[17:41:27.340]     }, error = function(ex) {
[17:41:27.340]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.340]                 ...future.rng), started = ...future.startTime, 
[17:41:27.340]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.340]             version = "1.8"), class = "FutureResult")
[17:41:27.340]     }, finally = {
[17:41:27.340]         if (!identical(...future.workdir, getwd())) 
[17:41:27.340]             setwd(...future.workdir)
[17:41:27.340]         {
[17:41:27.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.340]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.340]             }
[17:41:27.340]             base::options(...future.oldOptions)
[17:41:27.340]             if (.Platform$OS.type == "windows") {
[17:41:27.340]                 old_names <- names(...future.oldEnvVars)
[17:41:27.340]                 envs <- base::Sys.getenv()
[17:41:27.340]                 names <- names(envs)
[17:41:27.340]                 common <- intersect(names, old_names)
[17:41:27.340]                 added <- setdiff(names, old_names)
[17:41:27.340]                 removed <- setdiff(old_names, names)
[17:41:27.340]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.340]                   envs[common]]
[17:41:27.340]                 NAMES <- toupper(changed)
[17:41:27.340]                 args <- list()
[17:41:27.340]                 for (kk in seq_along(NAMES)) {
[17:41:27.340]                   name <- changed[[kk]]
[17:41:27.340]                   NAME <- NAMES[[kk]]
[17:41:27.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.340]                     next
[17:41:27.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.340]                 }
[17:41:27.340]                 NAMES <- toupper(added)
[17:41:27.340]                 for (kk in seq_along(NAMES)) {
[17:41:27.340]                   name <- added[[kk]]
[17:41:27.340]                   NAME <- NAMES[[kk]]
[17:41:27.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.340]                     next
[17:41:27.340]                   args[[name]] <- ""
[17:41:27.340]                 }
[17:41:27.340]                 NAMES <- toupper(removed)
[17:41:27.340]                 for (kk in seq_along(NAMES)) {
[17:41:27.340]                   name <- removed[[kk]]
[17:41:27.340]                   NAME <- NAMES[[kk]]
[17:41:27.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.340]                     next
[17:41:27.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.340]                 }
[17:41:27.340]                 if (length(args) > 0) 
[17:41:27.340]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.340]             }
[17:41:27.340]             else {
[17:41:27.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.340]             }
[17:41:27.340]             {
[17:41:27.340]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.340]                   0L) {
[17:41:27.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.340]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.340]                   base::options(opts)
[17:41:27.340]                 }
[17:41:27.340]                 {
[17:41:27.340]                   {
[17:41:27.340]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.340]                     NULL
[17:41:27.340]                   }
[17:41:27.340]                   options(future.plan = NULL)
[17:41:27.340]                   if (is.na(NA_character_)) 
[17:41:27.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.340]                     .init = FALSE)
[17:41:27.340]                 }
[17:41:27.340]             }
[17:41:27.340]         }
[17:41:27.340]     })
[17:41:27.340]     if (TRUE) {
[17:41:27.340]         base::sink(type = "output", split = FALSE)
[17:41:27.340]         if (FALSE) {
[17:41:27.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.340]         }
[17:41:27.340]         else {
[17:41:27.340]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.340]         }
[17:41:27.340]         base::close(...future.stdout)
[17:41:27.340]         ...future.stdout <- NULL
[17:41:27.340]     }
[17:41:27.340]     ...future.result$conditions <- ...future.conditions
[17:41:27.340]     ...future.result$finished <- base::Sys.time()
[17:41:27.340]     ...future.result
[17:41:27.340] }
[17:41:27.342] requestCore(): workers = 2
[17:41:27.344] MulticoreFuture started
[17:41:27.344] - Launch lazy future ... done
[17:41:27.344] run() for ‘MulticoreFuture’ ... done
[17:41:27.345] result() for MulticoreFuture ...
[17:41:27.345] plan(): Setting new future strategy stack:
[17:41:27.345] List of future strategies:
[17:41:27.345] 1. sequential:
[17:41:27.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.345]    - tweaked: FALSE
[17:41:27.345]    - call: NULL
[17:41:27.346] plan(): nbrOfWorkers() = 1
[17:41:27.350] plan(): Setting new future strategy stack:
[17:41:27.350] List of future strategies:
[17:41:27.350] 1. multicore:
[17:41:27.350]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.350]    - tweaked: FALSE
[17:41:27.350]    - call: plan(strategy)
[17:41:27.355] plan(): nbrOfWorkers() = 2
[17:41:27.356] result() for MulticoreFuture ...
[17:41:27.356] result() for MulticoreFuture ... done
[17:41:27.356] result() for MulticoreFuture ... done
[17:41:27.356] result() for MulticoreFuture ...
[17:41:27.356] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.357] getGlobalsAndPackages() ...
[17:41:27.357] Searching for globals...
[17:41:27.357] - globals found: [1] ‘print’
[17:41:27.358] Searching for globals ... DONE
[17:41:27.358] Resolving globals: FALSE
[17:41:27.358] 
[17:41:27.358] 
[17:41:27.358] getGlobalsAndPackages() ... DONE
[17:41:27.359] run() for ‘Future’ ...
[17:41:27.359] - state: ‘created’
[17:41:27.359] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.364]   - Field: ‘label’
[17:41:27.364]   - Field: ‘local’
[17:41:27.364]   - Field: ‘owner’
[17:41:27.364]   - Field: ‘envir’
[17:41:27.364]   - Field: ‘workers’
[17:41:27.364]   - Field: ‘packages’
[17:41:27.364]   - Field: ‘gc’
[17:41:27.364]   - Field: ‘job’
[17:41:27.365]   - Field: ‘conditions’
[17:41:27.365]   - Field: ‘expr’
[17:41:27.365]   - Field: ‘uuid’
[17:41:27.365]   - Field: ‘seed’
[17:41:27.365]   - Field: ‘version’
[17:41:27.365]   - Field: ‘result’
[17:41:27.365]   - Field: ‘asynchronous’
[17:41:27.367]   - Field: ‘calls’
[17:41:27.367]   - Field: ‘globals’
[17:41:27.368]   - Field: ‘stdout’
[17:41:27.368]   - Field: ‘earlySignal’
[17:41:27.368]   - Field: ‘lazy’
[17:41:27.368]   - Field: ‘state’
[17:41:27.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.368] - Launch lazy future ...
[17:41:27.369] Packages needed by the future expression (n = 0): <none>
[17:41:27.369] Packages needed by future strategies (n = 0): <none>
[17:41:27.369] {
[17:41:27.369]     {
[17:41:27.369]         {
[17:41:27.369]             ...future.startTime <- base::Sys.time()
[17:41:27.369]             {
[17:41:27.369]                 {
[17:41:27.369]                   {
[17:41:27.369]                     {
[17:41:27.369]                       base::local({
[17:41:27.369]                         has_future <- base::requireNamespace("future", 
[17:41:27.369]                           quietly = TRUE)
[17:41:27.369]                         if (has_future) {
[17:41:27.369]                           ns <- base::getNamespace("future")
[17:41:27.369]                           version <- ns[[".package"]][["version"]]
[17:41:27.369]                           if (is.null(version)) 
[17:41:27.369]                             version <- utils::packageVersion("future")
[17:41:27.369]                         }
[17:41:27.369]                         else {
[17:41:27.369]                           version <- NULL
[17:41:27.369]                         }
[17:41:27.369]                         if (!has_future || version < "1.8.0") {
[17:41:27.369]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.369]                             "", base::R.version$version.string), 
[17:41:27.369]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.369]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.369]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.369]                               "release", "version")], collapse = " "), 
[17:41:27.369]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.369]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.369]                             info)
[17:41:27.369]                           info <- base::paste(info, collapse = "; ")
[17:41:27.369]                           if (!has_future) {
[17:41:27.369]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.369]                               info)
[17:41:27.369]                           }
[17:41:27.369]                           else {
[17:41:27.369]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.369]                               info, version)
[17:41:27.369]                           }
[17:41:27.369]                           base::stop(msg)
[17:41:27.369]                         }
[17:41:27.369]                       })
[17:41:27.369]                     }
[17:41:27.369]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.369]                     base::options(mc.cores = 1L)
[17:41:27.369]                   }
[17:41:27.369]                   ...future.strategy.old <- future::plan("list")
[17:41:27.369]                   options(future.plan = NULL)
[17:41:27.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.369]                 }
[17:41:27.369]                 ...future.workdir <- getwd()
[17:41:27.369]             }
[17:41:27.369]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.369]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.369]         }
[17:41:27.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.369]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.369]             base::names(...future.oldOptions))
[17:41:27.369]     }
[17:41:27.369]     if (FALSE) {
[17:41:27.369]     }
[17:41:27.369]     else {
[17:41:27.369]         if (TRUE) {
[17:41:27.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.369]                 open = "w")
[17:41:27.369]         }
[17:41:27.369]         else {
[17:41:27.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.369]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.369]         }
[17:41:27.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.369]             base::sink(type = "output", split = FALSE)
[17:41:27.369]             base::close(...future.stdout)
[17:41:27.369]         }, add = TRUE)
[17:41:27.369]     }
[17:41:27.369]     ...future.frame <- base::sys.nframe()
[17:41:27.369]     ...future.conditions <- base::list()
[17:41:27.369]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.369]     if (FALSE) {
[17:41:27.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.369]     }
[17:41:27.369]     ...future.result <- base::tryCatch({
[17:41:27.369]         base::withCallingHandlers({
[17:41:27.369]             ...future.value <- base::withVisible(base::local({
[17:41:27.369]                 withCallingHandlers({
[17:41:27.369]                   print(42)
[17:41:27.369]                 }, immediateCondition = function(cond) {
[17:41:27.369]                   save_rds <- function (object, pathname, ...) 
[17:41:27.369]                   {
[17:41:27.369]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.369]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.369]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.369]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.369]                         fi_tmp[["mtime"]])
[17:41:27.369]                     }
[17:41:27.369]                     tryCatch({
[17:41:27.369]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.369]                     }, error = function(ex) {
[17:41:27.369]                       msg <- conditionMessage(ex)
[17:41:27.369]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.369]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.369]                         fi_tmp[["mtime"]], msg)
[17:41:27.369]                       ex$message <- msg
[17:41:27.369]                       stop(ex)
[17:41:27.369]                     })
[17:41:27.369]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.369]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.369]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.369]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.369]                       fi <- file.info(pathname)
[17:41:27.369]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.369]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.369]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.369]                         fi[["size"]], fi[["mtime"]])
[17:41:27.369]                       stop(msg)
[17:41:27.369]                     }
[17:41:27.369]                     invisible(pathname)
[17:41:27.369]                   }
[17:41:27.369]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.369]                     rootPath = tempdir()) 
[17:41:27.369]                   {
[17:41:27.369]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.369]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.369]                       tmpdir = path, fileext = ".rds")
[17:41:27.369]                     save_rds(obj, file)
[17:41:27.369]                   }
[17:41:27.369]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.369]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.369]                   {
[17:41:27.369]                     inherits <- base::inherits
[17:41:27.369]                     invokeRestart <- base::invokeRestart
[17:41:27.369]                     is.null <- base::is.null
[17:41:27.369]                     muffled <- FALSE
[17:41:27.369]                     if (inherits(cond, "message")) {
[17:41:27.369]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.369]                       if (muffled) 
[17:41:27.369]                         invokeRestart("muffleMessage")
[17:41:27.369]                     }
[17:41:27.369]                     else if (inherits(cond, "warning")) {
[17:41:27.369]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.369]                       if (muffled) 
[17:41:27.369]                         invokeRestart("muffleWarning")
[17:41:27.369]                     }
[17:41:27.369]                     else if (inherits(cond, "condition")) {
[17:41:27.369]                       if (!is.null(pattern)) {
[17:41:27.369]                         computeRestarts <- base::computeRestarts
[17:41:27.369]                         grepl <- base::grepl
[17:41:27.369]                         restarts <- computeRestarts(cond)
[17:41:27.369]                         for (restart in restarts) {
[17:41:27.369]                           name <- restart$name
[17:41:27.369]                           if (is.null(name)) 
[17:41:27.369]                             next
[17:41:27.369]                           if (!grepl(pattern, name)) 
[17:41:27.369]                             next
[17:41:27.369]                           invokeRestart(restart)
[17:41:27.369]                           muffled <- TRUE
[17:41:27.369]                           break
[17:41:27.369]                         }
[17:41:27.369]                       }
[17:41:27.369]                     }
[17:41:27.369]                     invisible(muffled)
[17:41:27.369]                   }
[17:41:27.369]                   muffleCondition(cond)
[17:41:27.369]                 })
[17:41:27.369]             }))
[17:41:27.369]             future::FutureResult(value = ...future.value$value, 
[17:41:27.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.369]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.369]                     ...future.globalenv.names))
[17:41:27.369]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.369]         }, condition = base::local({
[17:41:27.369]             c <- base::c
[17:41:27.369]             inherits <- base::inherits
[17:41:27.369]             invokeRestart <- base::invokeRestart
[17:41:27.369]             length <- base::length
[17:41:27.369]             list <- base::list
[17:41:27.369]             seq.int <- base::seq.int
[17:41:27.369]             signalCondition <- base::signalCondition
[17:41:27.369]             sys.calls <- base::sys.calls
[17:41:27.369]             `[[` <- base::`[[`
[17:41:27.369]             `+` <- base::`+`
[17:41:27.369]             `<<-` <- base::`<<-`
[17:41:27.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.369]                   3L)]
[17:41:27.369]             }
[17:41:27.369]             function(cond) {
[17:41:27.369]                 is_error <- inherits(cond, "error")
[17:41:27.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.369]                   NULL)
[17:41:27.369]                 if (is_error) {
[17:41:27.369]                   sessionInformation <- function() {
[17:41:27.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.369]                       search = base::search(), system = base::Sys.info())
[17:41:27.369]                   }
[17:41:27.369]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.369]                     cond$call), session = sessionInformation(), 
[17:41:27.369]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.369]                   signalCondition(cond)
[17:41:27.369]                 }
[17:41:27.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.369]                 "immediateCondition"))) {
[17:41:27.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.369]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.369]                   if (TRUE && !signal) {
[17:41:27.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.369]                     {
[17:41:27.369]                       inherits <- base::inherits
[17:41:27.369]                       invokeRestart <- base::invokeRestart
[17:41:27.369]                       is.null <- base::is.null
[17:41:27.369]                       muffled <- FALSE
[17:41:27.369]                       if (inherits(cond, "message")) {
[17:41:27.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.369]                         if (muffled) 
[17:41:27.369]                           invokeRestart("muffleMessage")
[17:41:27.369]                       }
[17:41:27.369]                       else if (inherits(cond, "warning")) {
[17:41:27.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.369]                         if (muffled) 
[17:41:27.369]                           invokeRestart("muffleWarning")
[17:41:27.369]                       }
[17:41:27.369]                       else if (inherits(cond, "condition")) {
[17:41:27.369]                         if (!is.null(pattern)) {
[17:41:27.369]                           computeRestarts <- base::computeRestarts
[17:41:27.369]                           grepl <- base::grepl
[17:41:27.369]                           restarts <- computeRestarts(cond)
[17:41:27.369]                           for (restart in restarts) {
[17:41:27.369]                             name <- restart$name
[17:41:27.369]                             if (is.null(name)) 
[17:41:27.369]                               next
[17:41:27.369]                             if (!grepl(pattern, name)) 
[17:41:27.369]                               next
[17:41:27.369]                             invokeRestart(restart)
[17:41:27.369]                             muffled <- TRUE
[17:41:27.369]                             break
[17:41:27.369]                           }
[17:41:27.369]                         }
[17:41:27.369]                       }
[17:41:27.369]                       invisible(muffled)
[17:41:27.369]                     }
[17:41:27.369]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.369]                   }
[17:41:27.369]                 }
[17:41:27.369]                 else {
[17:41:27.369]                   if (TRUE) {
[17:41:27.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.369]                     {
[17:41:27.369]                       inherits <- base::inherits
[17:41:27.369]                       invokeRestart <- base::invokeRestart
[17:41:27.369]                       is.null <- base::is.null
[17:41:27.369]                       muffled <- FALSE
[17:41:27.369]                       if (inherits(cond, "message")) {
[17:41:27.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.369]                         if (muffled) 
[17:41:27.369]                           invokeRestart("muffleMessage")
[17:41:27.369]                       }
[17:41:27.369]                       else if (inherits(cond, "warning")) {
[17:41:27.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.369]                         if (muffled) 
[17:41:27.369]                           invokeRestart("muffleWarning")
[17:41:27.369]                       }
[17:41:27.369]                       else if (inherits(cond, "condition")) {
[17:41:27.369]                         if (!is.null(pattern)) {
[17:41:27.369]                           computeRestarts <- base::computeRestarts
[17:41:27.369]                           grepl <- base::grepl
[17:41:27.369]                           restarts <- computeRestarts(cond)
[17:41:27.369]                           for (restart in restarts) {
[17:41:27.369]                             name <- restart$name
[17:41:27.369]                             if (is.null(name)) 
[17:41:27.369]                               next
[17:41:27.369]                             if (!grepl(pattern, name)) 
[17:41:27.369]                               next
[17:41:27.369]                             invokeRestart(restart)
[17:41:27.369]                             muffled <- TRUE
[17:41:27.369]                             break
[17:41:27.369]                           }
[17:41:27.369]                         }
[17:41:27.369]                       }
[17:41:27.369]                       invisible(muffled)
[17:41:27.369]                     }
[17:41:27.369]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.369]                   }
[17:41:27.369]                 }
[17:41:27.369]             }
[17:41:27.369]         }))
[17:41:27.369]     }, error = function(ex) {
[17:41:27.369]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.369]                 ...future.rng), started = ...future.startTime, 
[17:41:27.369]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.369]             version = "1.8"), class = "FutureResult")
[17:41:27.369]     }, finally = {
[17:41:27.369]         if (!identical(...future.workdir, getwd())) 
[17:41:27.369]             setwd(...future.workdir)
[17:41:27.369]         {
[17:41:27.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.369]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.369]             }
[17:41:27.369]             base::options(...future.oldOptions)
[17:41:27.369]             if (.Platform$OS.type == "windows") {
[17:41:27.369]                 old_names <- names(...future.oldEnvVars)
[17:41:27.369]                 envs <- base::Sys.getenv()
[17:41:27.369]                 names <- names(envs)
[17:41:27.369]                 common <- intersect(names, old_names)
[17:41:27.369]                 added <- setdiff(names, old_names)
[17:41:27.369]                 removed <- setdiff(old_names, names)
[17:41:27.369]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.369]                   envs[common]]
[17:41:27.369]                 NAMES <- toupper(changed)
[17:41:27.369]                 args <- list()
[17:41:27.369]                 for (kk in seq_along(NAMES)) {
[17:41:27.369]                   name <- changed[[kk]]
[17:41:27.369]                   NAME <- NAMES[[kk]]
[17:41:27.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.369]                     next
[17:41:27.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.369]                 }
[17:41:27.369]                 NAMES <- toupper(added)
[17:41:27.369]                 for (kk in seq_along(NAMES)) {
[17:41:27.369]                   name <- added[[kk]]
[17:41:27.369]                   NAME <- NAMES[[kk]]
[17:41:27.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.369]                     next
[17:41:27.369]                   args[[name]] <- ""
[17:41:27.369]                 }
[17:41:27.369]                 NAMES <- toupper(removed)
[17:41:27.369]                 for (kk in seq_along(NAMES)) {
[17:41:27.369]                   name <- removed[[kk]]
[17:41:27.369]                   NAME <- NAMES[[kk]]
[17:41:27.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.369]                     next
[17:41:27.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.369]                 }
[17:41:27.369]                 if (length(args) > 0) 
[17:41:27.369]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.369]             }
[17:41:27.369]             else {
[17:41:27.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.369]             }
[17:41:27.369]             {
[17:41:27.369]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.369]                   0L) {
[17:41:27.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.369]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.369]                   base::options(opts)
[17:41:27.369]                 }
[17:41:27.369]                 {
[17:41:27.369]                   {
[17:41:27.369]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.369]                     NULL
[17:41:27.369]                   }
[17:41:27.369]                   options(future.plan = NULL)
[17:41:27.369]                   if (is.na(NA_character_)) 
[17:41:27.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.369]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.369]                     .init = FALSE)
[17:41:27.369]                 }
[17:41:27.369]             }
[17:41:27.369]         }
[17:41:27.369]     })
[17:41:27.369]     if (TRUE) {
[17:41:27.369]         base::sink(type = "output", split = FALSE)
[17:41:27.369]         if (TRUE) {
[17:41:27.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.369]         }
[17:41:27.369]         else {
[17:41:27.369]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.369]         }
[17:41:27.369]         base::close(...future.stdout)
[17:41:27.369]         ...future.stdout <- NULL
[17:41:27.369]     }
[17:41:27.369]     ...future.result$conditions <- ...future.conditions
[17:41:27.369]     ...future.result$finished <- base::Sys.time()
[17:41:27.369]     ...future.result
[17:41:27.369] }
[17:41:27.372] requestCore(): workers = 2
[17:41:27.373] MulticoreFuture started
[17:41:27.374] - Launch lazy future ... done
[17:41:27.374] run() for ‘MulticoreFuture’ ... done
[17:41:27.374] result() for MulticoreFuture ...
[17:41:27.374] plan(): Setting new future strategy stack:
[17:41:27.375] List of future strategies:
[17:41:27.375] 1. sequential:
[17:41:27.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.375]    - tweaked: FALSE
[17:41:27.375]    - call: NULL
[17:41:27.376] plan(): nbrOfWorkers() = 1
[17:41:27.378] plan(): Setting new future strategy stack:
[17:41:27.378] List of future strategies:
[17:41:27.378] 1. multicore:
[17:41:27.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.378]    - tweaked: FALSE
[17:41:27.378]    - call: plan(strategy)
[17:41:27.383] plan(): nbrOfWorkers() = 2
[17:41:27.384] result() for MulticoreFuture ...
[17:41:27.384] result() for MulticoreFuture ... done
[17:41:27.384] result() for MulticoreFuture ... done
[17:41:27.384] result() for MulticoreFuture ...
[17:41:27.385] result() for MulticoreFuture ... done
[17:41:27.385] result() for MulticoreFuture ...
[17:41:27.385] result() for MulticoreFuture ... done
[1] 42
[17:41:27.385] result() for MulticoreFuture ...
[17:41:27.385] result() for MulticoreFuture ... done
- stdout = NA
[17:41:27.385] getGlobalsAndPackages() ...
[17:41:27.386] Searching for globals...
[17:41:27.389] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.390] Searching for globals ... DONE
[17:41:27.390] Resolving globals: FALSE
[17:41:27.390] 
[17:41:27.391] - packages: [1] ‘utils’
[17:41:27.391] getGlobalsAndPackages() ... DONE
[17:41:27.391] run() for ‘Future’ ...
[17:41:27.391] - state: ‘created’
[17:41:27.391] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.396]   - Field: ‘label’
[17:41:27.396]   - Field: ‘local’
[17:41:27.396]   - Field: ‘owner’
[17:41:27.396]   - Field: ‘envir’
[17:41:27.396]   - Field: ‘workers’
[17:41:27.396]   - Field: ‘packages’
[17:41:27.396]   - Field: ‘gc’
[17:41:27.397]   - Field: ‘job’
[17:41:27.397]   - Field: ‘conditions’
[17:41:27.397]   - Field: ‘expr’
[17:41:27.397]   - Field: ‘uuid’
[17:41:27.397]   - Field: ‘seed’
[17:41:27.397]   - Field: ‘version’
[17:41:27.397]   - Field: ‘result’
[17:41:27.397]   - Field: ‘asynchronous’
[17:41:27.397]   - Field: ‘calls’
[17:41:27.398]   - Field: ‘globals’
[17:41:27.398]   - Field: ‘stdout’
[17:41:27.398]   - Field: ‘earlySignal’
[17:41:27.398]   - Field: ‘lazy’
[17:41:27.398]   - Field: ‘state’
[17:41:27.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.398] - Launch lazy future ...
[17:41:27.398] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.399] Packages needed by future strategies (n = 0): <none>
[17:41:27.399] {
[17:41:27.399]     {
[17:41:27.399]         {
[17:41:27.399]             ...future.startTime <- base::Sys.time()
[17:41:27.399]             {
[17:41:27.399]                 {
[17:41:27.399]                   {
[17:41:27.399]                     {
[17:41:27.399]                       {
[17:41:27.399]                         base::local({
[17:41:27.399]                           has_future <- base::requireNamespace("future", 
[17:41:27.399]                             quietly = TRUE)
[17:41:27.399]                           if (has_future) {
[17:41:27.399]                             ns <- base::getNamespace("future")
[17:41:27.399]                             version <- ns[[".package"]][["version"]]
[17:41:27.399]                             if (is.null(version)) 
[17:41:27.399]                               version <- utils::packageVersion("future")
[17:41:27.399]                           }
[17:41:27.399]                           else {
[17:41:27.399]                             version <- NULL
[17:41:27.399]                           }
[17:41:27.399]                           if (!has_future || version < "1.8.0") {
[17:41:27.399]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.399]                               "", base::R.version$version.string), 
[17:41:27.399]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.399]                                 base::R.version$platform, 8 * 
[17:41:27.399]                                   base::.Machine$sizeof.pointer), 
[17:41:27.399]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.399]                                 "release", "version")], collapse = " "), 
[17:41:27.399]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.399]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.399]                               info)
[17:41:27.399]                             info <- base::paste(info, collapse = "; ")
[17:41:27.399]                             if (!has_future) {
[17:41:27.399]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.399]                                 info)
[17:41:27.399]                             }
[17:41:27.399]                             else {
[17:41:27.399]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.399]                                 info, version)
[17:41:27.399]                             }
[17:41:27.399]                             base::stop(msg)
[17:41:27.399]                           }
[17:41:27.399]                         })
[17:41:27.399]                       }
[17:41:27.399]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.399]                       base::options(mc.cores = 1L)
[17:41:27.399]                     }
[17:41:27.399]                     base::local({
[17:41:27.399]                       for (pkg in "utils") {
[17:41:27.399]                         base::loadNamespace(pkg)
[17:41:27.399]                         base::library(pkg, character.only = TRUE)
[17:41:27.399]                       }
[17:41:27.399]                     })
[17:41:27.399]                   }
[17:41:27.399]                   ...future.strategy.old <- future::plan("list")
[17:41:27.399]                   options(future.plan = NULL)
[17:41:27.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.399]                 }
[17:41:27.399]                 ...future.workdir <- getwd()
[17:41:27.399]             }
[17:41:27.399]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.399]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.399]         }
[17:41:27.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.399]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.399]             base::names(...future.oldOptions))
[17:41:27.399]     }
[17:41:27.399]     if (TRUE) {
[17:41:27.399]     }
[17:41:27.399]     else {
[17:41:27.399]         if (NA) {
[17:41:27.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.399]                 open = "w")
[17:41:27.399]         }
[17:41:27.399]         else {
[17:41:27.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.399]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.399]         }
[17:41:27.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.399]             base::sink(type = "output", split = FALSE)
[17:41:27.399]             base::close(...future.stdout)
[17:41:27.399]         }, add = TRUE)
[17:41:27.399]     }
[17:41:27.399]     ...future.frame <- base::sys.nframe()
[17:41:27.399]     ...future.conditions <- base::list()
[17:41:27.399]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.399]     if (FALSE) {
[17:41:27.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.399]     }
[17:41:27.399]     ...future.result <- base::tryCatch({
[17:41:27.399]         base::withCallingHandlers({
[17:41:27.399]             ...future.value <- base::withVisible(base::local({
[17:41:27.399]                 withCallingHandlers({
[17:41:27.399]                   {
[17:41:27.399]                     print(1:50)
[17:41:27.399]                     str(1:50)
[17:41:27.399]                     cat(letters, sep = "-")
[17:41:27.399]                     cat(1:6, collapse = "\n")
[17:41:27.399]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.399]                     42L
[17:41:27.399]                   }
[17:41:27.399]                 }, immediateCondition = function(cond) {
[17:41:27.399]                   save_rds <- function (object, pathname, ...) 
[17:41:27.399]                   {
[17:41:27.399]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.399]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.399]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.399]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.399]                         fi_tmp[["mtime"]])
[17:41:27.399]                     }
[17:41:27.399]                     tryCatch({
[17:41:27.399]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.399]                     }, error = function(ex) {
[17:41:27.399]                       msg <- conditionMessage(ex)
[17:41:27.399]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.399]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.399]                         fi_tmp[["mtime"]], msg)
[17:41:27.399]                       ex$message <- msg
[17:41:27.399]                       stop(ex)
[17:41:27.399]                     })
[17:41:27.399]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.399]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.399]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.399]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.399]                       fi <- file.info(pathname)
[17:41:27.399]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.399]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.399]                         fi[["size"]], fi[["mtime"]])
[17:41:27.399]                       stop(msg)
[17:41:27.399]                     }
[17:41:27.399]                     invisible(pathname)
[17:41:27.399]                   }
[17:41:27.399]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.399]                     rootPath = tempdir()) 
[17:41:27.399]                   {
[17:41:27.399]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.399]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.399]                       tmpdir = path, fileext = ".rds")
[17:41:27.399]                     save_rds(obj, file)
[17:41:27.399]                   }
[17:41:27.399]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.399]                   {
[17:41:27.399]                     inherits <- base::inherits
[17:41:27.399]                     invokeRestart <- base::invokeRestart
[17:41:27.399]                     is.null <- base::is.null
[17:41:27.399]                     muffled <- FALSE
[17:41:27.399]                     if (inherits(cond, "message")) {
[17:41:27.399]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.399]                       if (muffled) 
[17:41:27.399]                         invokeRestart("muffleMessage")
[17:41:27.399]                     }
[17:41:27.399]                     else if (inherits(cond, "warning")) {
[17:41:27.399]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.399]                       if (muffled) 
[17:41:27.399]                         invokeRestart("muffleWarning")
[17:41:27.399]                     }
[17:41:27.399]                     else if (inherits(cond, "condition")) {
[17:41:27.399]                       if (!is.null(pattern)) {
[17:41:27.399]                         computeRestarts <- base::computeRestarts
[17:41:27.399]                         grepl <- base::grepl
[17:41:27.399]                         restarts <- computeRestarts(cond)
[17:41:27.399]                         for (restart in restarts) {
[17:41:27.399]                           name <- restart$name
[17:41:27.399]                           if (is.null(name)) 
[17:41:27.399]                             next
[17:41:27.399]                           if (!grepl(pattern, name)) 
[17:41:27.399]                             next
[17:41:27.399]                           invokeRestart(restart)
[17:41:27.399]                           muffled <- TRUE
[17:41:27.399]                           break
[17:41:27.399]                         }
[17:41:27.399]                       }
[17:41:27.399]                     }
[17:41:27.399]                     invisible(muffled)
[17:41:27.399]                   }
[17:41:27.399]                   muffleCondition(cond)
[17:41:27.399]                 })
[17:41:27.399]             }))
[17:41:27.399]             future::FutureResult(value = ...future.value$value, 
[17:41:27.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.399]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.399]                     ...future.globalenv.names))
[17:41:27.399]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.399]         }, condition = base::local({
[17:41:27.399]             c <- base::c
[17:41:27.399]             inherits <- base::inherits
[17:41:27.399]             invokeRestart <- base::invokeRestart
[17:41:27.399]             length <- base::length
[17:41:27.399]             list <- base::list
[17:41:27.399]             seq.int <- base::seq.int
[17:41:27.399]             signalCondition <- base::signalCondition
[17:41:27.399]             sys.calls <- base::sys.calls
[17:41:27.399]             `[[` <- base::`[[`
[17:41:27.399]             `+` <- base::`+`
[17:41:27.399]             `<<-` <- base::`<<-`
[17:41:27.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.399]                   3L)]
[17:41:27.399]             }
[17:41:27.399]             function(cond) {
[17:41:27.399]                 is_error <- inherits(cond, "error")
[17:41:27.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.399]                   NULL)
[17:41:27.399]                 if (is_error) {
[17:41:27.399]                   sessionInformation <- function() {
[17:41:27.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.399]                       search = base::search(), system = base::Sys.info())
[17:41:27.399]                   }
[17:41:27.399]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.399]                     cond$call), session = sessionInformation(), 
[17:41:27.399]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.399]                   signalCondition(cond)
[17:41:27.399]                 }
[17:41:27.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.399]                 "immediateCondition"))) {
[17:41:27.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.399]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.399]                   if (TRUE && !signal) {
[17:41:27.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.399]                     {
[17:41:27.399]                       inherits <- base::inherits
[17:41:27.399]                       invokeRestart <- base::invokeRestart
[17:41:27.399]                       is.null <- base::is.null
[17:41:27.399]                       muffled <- FALSE
[17:41:27.399]                       if (inherits(cond, "message")) {
[17:41:27.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.399]                         if (muffled) 
[17:41:27.399]                           invokeRestart("muffleMessage")
[17:41:27.399]                       }
[17:41:27.399]                       else if (inherits(cond, "warning")) {
[17:41:27.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.399]                         if (muffled) 
[17:41:27.399]                           invokeRestart("muffleWarning")
[17:41:27.399]                       }
[17:41:27.399]                       else if (inherits(cond, "condition")) {
[17:41:27.399]                         if (!is.null(pattern)) {
[17:41:27.399]                           computeRestarts <- base::computeRestarts
[17:41:27.399]                           grepl <- base::grepl
[17:41:27.399]                           restarts <- computeRestarts(cond)
[17:41:27.399]                           for (restart in restarts) {
[17:41:27.399]                             name <- restart$name
[17:41:27.399]                             if (is.null(name)) 
[17:41:27.399]                               next
[17:41:27.399]                             if (!grepl(pattern, name)) 
[17:41:27.399]                               next
[17:41:27.399]                             invokeRestart(restart)
[17:41:27.399]                             muffled <- TRUE
[17:41:27.399]                             break
[17:41:27.399]                           }
[17:41:27.399]                         }
[17:41:27.399]                       }
[17:41:27.399]                       invisible(muffled)
[17:41:27.399]                     }
[17:41:27.399]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.399]                   }
[17:41:27.399]                 }
[17:41:27.399]                 else {
[17:41:27.399]                   if (TRUE) {
[17:41:27.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.399]                     {
[17:41:27.399]                       inherits <- base::inherits
[17:41:27.399]                       invokeRestart <- base::invokeRestart
[17:41:27.399]                       is.null <- base::is.null
[17:41:27.399]                       muffled <- FALSE
[17:41:27.399]                       if (inherits(cond, "message")) {
[17:41:27.399]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.399]                         if (muffled) 
[17:41:27.399]                           invokeRestart("muffleMessage")
[17:41:27.399]                       }
[17:41:27.399]                       else if (inherits(cond, "warning")) {
[17:41:27.399]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.399]                         if (muffled) 
[17:41:27.399]                           invokeRestart("muffleWarning")
[17:41:27.399]                       }
[17:41:27.399]                       else if (inherits(cond, "condition")) {
[17:41:27.399]                         if (!is.null(pattern)) {
[17:41:27.399]                           computeRestarts <- base::computeRestarts
[17:41:27.399]                           grepl <- base::grepl
[17:41:27.399]                           restarts <- computeRestarts(cond)
[17:41:27.399]                           for (restart in restarts) {
[17:41:27.399]                             name <- restart$name
[17:41:27.399]                             if (is.null(name)) 
[17:41:27.399]                               next
[17:41:27.399]                             if (!grepl(pattern, name)) 
[17:41:27.399]                               next
[17:41:27.399]                             invokeRestart(restart)
[17:41:27.399]                             muffled <- TRUE
[17:41:27.399]                             break
[17:41:27.399]                           }
[17:41:27.399]                         }
[17:41:27.399]                       }
[17:41:27.399]                       invisible(muffled)
[17:41:27.399]                     }
[17:41:27.399]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.399]                   }
[17:41:27.399]                 }
[17:41:27.399]             }
[17:41:27.399]         }))
[17:41:27.399]     }, error = function(ex) {
[17:41:27.399]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.399]                 ...future.rng), started = ...future.startTime, 
[17:41:27.399]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.399]             version = "1.8"), class = "FutureResult")
[17:41:27.399]     }, finally = {
[17:41:27.399]         if (!identical(...future.workdir, getwd())) 
[17:41:27.399]             setwd(...future.workdir)
[17:41:27.399]         {
[17:41:27.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.399]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.399]             }
[17:41:27.399]             base::options(...future.oldOptions)
[17:41:27.399]             if (.Platform$OS.type == "windows") {
[17:41:27.399]                 old_names <- names(...future.oldEnvVars)
[17:41:27.399]                 envs <- base::Sys.getenv()
[17:41:27.399]                 names <- names(envs)
[17:41:27.399]                 common <- intersect(names, old_names)
[17:41:27.399]                 added <- setdiff(names, old_names)
[17:41:27.399]                 removed <- setdiff(old_names, names)
[17:41:27.399]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.399]                   envs[common]]
[17:41:27.399]                 NAMES <- toupper(changed)
[17:41:27.399]                 args <- list()
[17:41:27.399]                 for (kk in seq_along(NAMES)) {
[17:41:27.399]                   name <- changed[[kk]]
[17:41:27.399]                   NAME <- NAMES[[kk]]
[17:41:27.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.399]                     next
[17:41:27.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.399]                 }
[17:41:27.399]                 NAMES <- toupper(added)
[17:41:27.399]                 for (kk in seq_along(NAMES)) {
[17:41:27.399]                   name <- added[[kk]]
[17:41:27.399]                   NAME <- NAMES[[kk]]
[17:41:27.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.399]                     next
[17:41:27.399]                   args[[name]] <- ""
[17:41:27.399]                 }
[17:41:27.399]                 NAMES <- toupper(removed)
[17:41:27.399]                 for (kk in seq_along(NAMES)) {
[17:41:27.399]                   name <- removed[[kk]]
[17:41:27.399]                   NAME <- NAMES[[kk]]
[17:41:27.399]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.399]                     next
[17:41:27.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.399]                 }
[17:41:27.399]                 if (length(args) > 0) 
[17:41:27.399]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.399]             }
[17:41:27.399]             else {
[17:41:27.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.399]             }
[17:41:27.399]             {
[17:41:27.399]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.399]                   0L) {
[17:41:27.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.399]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.399]                   base::options(opts)
[17:41:27.399]                 }
[17:41:27.399]                 {
[17:41:27.399]                   {
[17:41:27.399]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.399]                     NULL
[17:41:27.399]                   }
[17:41:27.399]                   options(future.plan = NULL)
[17:41:27.399]                   if (is.na(NA_character_)) 
[17:41:27.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.399]                     .init = FALSE)
[17:41:27.399]                 }
[17:41:27.399]             }
[17:41:27.399]         }
[17:41:27.399]     })
[17:41:27.399]     if (FALSE) {
[17:41:27.399]         base::sink(type = "output", split = FALSE)
[17:41:27.399]         if (NA) {
[17:41:27.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.399]         }
[17:41:27.399]         else {
[17:41:27.399]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.399]         }
[17:41:27.399]         base::close(...future.stdout)
[17:41:27.399]         ...future.stdout <- NULL
[17:41:27.399]     }
[17:41:27.399]     ...future.result$conditions <- ...future.conditions
[17:41:27.399]     ...future.result$finished <- base::Sys.time()
[17:41:27.399]     ...future.result
[17:41:27.399] }
[17:41:27.402] requestCore(): workers = 2
[17:41:27.404] MulticoreFuture started
[17:41:27.404] - Launch lazy future ... done
[17:41:27.404] run() for ‘MulticoreFuture’ ... done
[17:41:27.405] result() for MulticoreFuture ...
[17:41:27.405] plan(): Setting new future strategy stack:
[17:41:27.405] List of future strategies:
[17:41:27.405] 1. sequential:
[17:41:27.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.405]    - tweaked: FALSE
[17:41:27.405]    - call: NULL
[17:41:27.406] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:41:27.410] plan(): Setting new future strategy stack:
[17:41:27.410] List of future strategies:
[17:41:27.410] 1. multicore:
[17:41:27.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.410]    - tweaked: FALSE
[17:41:27.410]    - call: plan(strategy)
[17:41:27.415] plan(): nbrOfWorkers() = 2
[17:41:27.416] result() for MulticoreFuture ...
[17:41:27.416] result() for MulticoreFuture ... done
[17:41:27.416] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:27"
 $ session_uuid: chr "fb9784c4-5c4c-d983-3bd8-6c65fcae8b56"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50484
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:27"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:27.426] result() for MulticoreFuture ...
[17:41:27.426] result() for MulticoreFuture ... done
[17:41:27.426] result() for MulticoreFuture ...
[17:41:27.426] result() for MulticoreFuture ... done
[17:41:27.426] getGlobalsAndPackages() ...
[17:41:27.427] Searching for globals...
[17:41:27.433] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:27.433] Searching for globals ... DONE
[17:41:27.434] Resolving globals: FALSE
[17:41:27.434] 
[17:41:27.434] - packages: [1] ‘utils’
[17:41:27.434] getGlobalsAndPackages() ... DONE
[17:41:27.435] run() for ‘Future’ ...
[17:41:27.435] - state: ‘created’
[17:41:27.435] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.439] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.439]   - Field: ‘label’
[17:41:27.439]   - Field: ‘local’
[17:41:27.440]   - Field: ‘owner’
[17:41:27.440]   - Field: ‘envir’
[17:41:27.440]   - Field: ‘workers’
[17:41:27.440]   - Field: ‘packages’
[17:41:27.440]   - Field: ‘gc’
[17:41:27.440]   - Field: ‘job’
[17:41:27.440]   - Field: ‘conditions’
[17:41:27.440]   - Field: ‘expr’
[17:41:27.440]   - Field: ‘uuid’
[17:41:27.441]   - Field: ‘seed’
[17:41:27.441]   - Field: ‘version’
[17:41:27.441]   - Field: ‘result’
[17:41:27.441]   - Field: ‘asynchronous’
[17:41:27.441]   - Field: ‘calls’
[17:41:27.441]   - Field: ‘globals’
[17:41:27.441]   - Field: ‘stdout’
[17:41:27.441]   - Field: ‘earlySignal’
[17:41:27.441]   - Field: ‘lazy’
[17:41:27.442]   - Field: ‘state’
[17:41:27.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.442] - Launch lazy future ...
[17:41:27.442] Packages needed by the future expression (n = 1): ‘utils’
[17:41:27.442] Packages needed by future strategies (n = 0): <none>
[17:41:27.443] {
[17:41:27.443]     {
[17:41:27.443]         {
[17:41:27.443]             ...future.startTime <- base::Sys.time()
[17:41:27.443]             {
[17:41:27.443]                 {
[17:41:27.443]                   {
[17:41:27.443]                     {
[17:41:27.443]                       {
[17:41:27.443]                         base::local({
[17:41:27.443]                           has_future <- base::requireNamespace("future", 
[17:41:27.443]                             quietly = TRUE)
[17:41:27.443]                           if (has_future) {
[17:41:27.443]                             ns <- base::getNamespace("future")
[17:41:27.443]                             version <- ns[[".package"]][["version"]]
[17:41:27.443]                             if (is.null(version)) 
[17:41:27.443]                               version <- utils::packageVersion("future")
[17:41:27.443]                           }
[17:41:27.443]                           else {
[17:41:27.443]                             version <- NULL
[17:41:27.443]                           }
[17:41:27.443]                           if (!has_future || version < "1.8.0") {
[17:41:27.443]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.443]                               "", base::R.version$version.string), 
[17:41:27.443]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:27.443]                                 base::R.version$platform, 8 * 
[17:41:27.443]                                   base::.Machine$sizeof.pointer), 
[17:41:27.443]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.443]                                 "release", "version")], collapse = " "), 
[17:41:27.443]                               hostname = base::Sys.info()[["nodename"]])
[17:41:27.443]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.443]                               info)
[17:41:27.443]                             info <- base::paste(info, collapse = "; ")
[17:41:27.443]                             if (!has_future) {
[17:41:27.443]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.443]                                 info)
[17:41:27.443]                             }
[17:41:27.443]                             else {
[17:41:27.443]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.443]                                 info, version)
[17:41:27.443]                             }
[17:41:27.443]                             base::stop(msg)
[17:41:27.443]                           }
[17:41:27.443]                         })
[17:41:27.443]                       }
[17:41:27.443]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.443]                       base::options(mc.cores = 1L)
[17:41:27.443]                     }
[17:41:27.443]                     base::local({
[17:41:27.443]                       for (pkg in "utils") {
[17:41:27.443]                         base::loadNamespace(pkg)
[17:41:27.443]                         base::library(pkg, character.only = TRUE)
[17:41:27.443]                       }
[17:41:27.443]                     })
[17:41:27.443]                   }
[17:41:27.443]                   ...future.strategy.old <- future::plan("list")
[17:41:27.443]                   options(future.plan = NULL)
[17:41:27.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.443]                 }
[17:41:27.443]                 ...future.workdir <- getwd()
[17:41:27.443]             }
[17:41:27.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.443]         }
[17:41:27.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.443]             base::names(...future.oldOptions))
[17:41:27.443]     }
[17:41:27.443]     if (TRUE) {
[17:41:27.443]     }
[17:41:27.443]     else {
[17:41:27.443]         if (NA) {
[17:41:27.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.443]                 open = "w")
[17:41:27.443]         }
[17:41:27.443]         else {
[17:41:27.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.443]         }
[17:41:27.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.443]             base::sink(type = "output", split = FALSE)
[17:41:27.443]             base::close(...future.stdout)
[17:41:27.443]         }, add = TRUE)
[17:41:27.443]     }
[17:41:27.443]     ...future.frame <- base::sys.nframe()
[17:41:27.443]     ...future.conditions <- base::list()
[17:41:27.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.443]     if (FALSE) {
[17:41:27.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.443]     }
[17:41:27.443]     ...future.result <- base::tryCatch({
[17:41:27.443]         base::withCallingHandlers({
[17:41:27.443]             ...future.value <- base::withVisible(base::local({
[17:41:27.443]                 withCallingHandlers({
[17:41:27.443]                   {
[17:41:27.443]                     print(1:50)
[17:41:27.443]                     str(1:50)
[17:41:27.443]                     cat(letters, sep = "-")
[17:41:27.443]                     cat(1:6, collapse = "\n")
[17:41:27.443]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:27.443]                     42L
[17:41:27.443]                   }
[17:41:27.443]                 }, immediateCondition = function(cond) {
[17:41:27.443]                   save_rds <- function (object, pathname, ...) 
[17:41:27.443]                   {
[17:41:27.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.443]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.443]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.443]                         fi_tmp[["mtime"]])
[17:41:27.443]                     }
[17:41:27.443]                     tryCatch({
[17:41:27.443]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.443]                     }, error = function(ex) {
[17:41:27.443]                       msg <- conditionMessage(ex)
[17:41:27.443]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.443]                         fi_tmp[["mtime"]], msg)
[17:41:27.443]                       ex$message <- msg
[17:41:27.443]                       stop(ex)
[17:41:27.443]                     })
[17:41:27.443]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.443]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.443]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.443]                       fi <- file.info(pathname)
[17:41:27.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.443]                         fi[["size"]], fi[["mtime"]])
[17:41:27.443]                       stop(msg)
[17:41:27.443]                     }
[17:41:27.443]                     invisible(pathname)
[17:41:27.443]                   }
[17:41:27.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.443]                     rootPath = tempdir()) 
[17:41:27.443]                   {
[17:41:27.443]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.443]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.443]                       tmpdir = path, fileext = ".rds")
[17:41:27.443]                     save_rds(obj, file)
[17:41:27.443]                   }
[17:41:27.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.443]                   {
[17:41:27.443]                     inherits <- base::inherits
[17:41:27.443]                     invokeRestart <- base::invokeRestart
[17:41:27.443]                     is.null <- base::is.null
[17:41:27.443]                     muffled <- FALSE
[17:41:27.443]                     if (inherits(cond, "message")) {
[17:41:27.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.443]                       if (muffled) 
[17:41:27.443]                         invokeRestart("muffleMessage")
[17:41:27.443]                     }
[17:41:27.443]                     else if (inherits(cond, "warning")) {
[17:41:27.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.443]                       if (muffled) 
[17:41:27.443]                         invokeRestart("muffleWarning")
[17:41:27.443]                     }
[17:41:27.443]                     else if (inherits(cond, "condition")) {
[17:41:27.443]                       if (!is.null(pattern)) {
[17:41:27.443]                         computeRestarts <- base::computeRestarts
[17:41:27.443]                         grepl <- base::grepl
[17:41:27.443]                         restarts <- computeRestarts(cond)
[17:41:27.443]                         for (restart in restarts) {
[17:41:27.443]                           name <- restart$name
[17:41:27.443]                           if (is.null(name)) 
[17:41:27.443]                             next
[17:41:27.443]                           if (!grepl(pattern, name)) 
[17:41:27.443]                             next
[17:41:27.443]                           invokeRestart(restart)
[17:41:27.443]                           muffled <- TRUE
[17:41:27.443]                           break
[17:41:27.443]                         }
[17:41:27.443]                       }
[17:41:27.443]                     }
[17:41:27.443]                     invisible(muffled)
[17:41:27.443]                   }
[17:41:27.443]                   muffleCondition(cond)
[17:41:27.443]                 })
[17:41:27.443]             }))
[17:41:27.443]             future::FutureResult(value = ...future.value$value, 
[17:41:27.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.443]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.443]                     ...future.globalenv.names))
[17:41:27.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.443]         }, condition = base::local({
[17:41:27.443]             c <- base::c
[17:41:27.443]             inherits <- base::inherits
[17:41:27.443]             invokeRestart <- base::invokeRestart
[17:41:27.443]             length <- base::length
[17:41:27.443]             list <- base::list
[17:41:27.443]             seq.int <- base::seq.int
[17:41:27.443]             signalCondition <- base::signalCondition
[17:41:27.443]             sys.calls <- base::sys.calls
[17:41:27.443]             `[[` <- base::`[[`
[17:41:27.443]             `+` <- base::`+`
[17:41:27.443]             `<<-` <- base::`<<-`
[17:41:27.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.443]                   3L)]
[17:41:27.443]             }
[17:41:27.443]             function(cond) {
[17:41:27.443]                 is_error <- inherits(cond, "error")
[17:41:27.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.443]                   NULL)
[17:41:27.443]                 if (is_error) {
[17:41:27.443]                   sessionInformation <- function() {
[17:41:27.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.443]                       search = base::search(), system = base::Sys.info())
[17:41:27.443]                   }
[17:41:27.443]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.443]                     cond$call), session = sessionInformation(), 
[17:41:27.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.443]                   signalCondition(cond)
[17:41:27.443]                 }
[17:41:27.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.443]                 "immediateCondition"))) {
[17:41:27.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.443]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.443]                   if (TRUE && !signal) {
[17:41:27.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.443]                     {
[17:41:27.443]                       inherits <- base::inherits
[17:41:27.443]                       invokeRestart <- base::invokeRestart
[17:41:27.443]                       is.null <- base::is.null
[17:41:27.443]                       muffled <- FALSE
[17:41:27.443]                       if (inherits(cond, "message")) {
[17:41:27.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.443]                         if (muffled) 
[17:41:27.443]                           invokeRestart("muffleMessage")
[17:41:27.443]                       }
[17:41:27.443]                       else if (inherits(cond, "warning")) {
[17:41:27.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.443]                         if (muffled) 
[17:41:27.443]                           invokeRestart("muffleWarning")
[17:41:27.443]                       }
[17:41:27.443]                       else if (inherits(cond, "condition")) {
[17:41:27.443]                         if (!is.null(pattern)) {
[17:41:27.443]                           computeRestarts <- base::computeRestarts
[17:41:27.443]                           grepl <- base::grepl
[17:41:27.443]                           restarts <- computeRestarts(cond)
[17:41:27.443]                           for (restart in restarts) {
[17:41:27.443]                             name <- restart$name
[17:41:27.443]                             if (is.null(name)) 
[17:41:27.443]                               next
[17:41:27.443]                             if (!grepl(pattern, name)) 
[17:41:27.443]                               next
[17:41:27.443]                             invokeRestart(restart)
[17:41:27.443]                             muffled <- TRUE
[17:41:27.443]                             break
[17:41:27.443]                           }
[17:41:27.443]                         }
[17:41:27.443]                       }
[17:41:27.443]                       invisible(muffled)
[17:41:27.443]                     }
[17:41:27.443]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.443]                   }
[17:41:27.443]                 }
[17:41:27.443]                 else {
[17:41:27.443]                   if (TRUE) {
[17:41:27.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.443]                     {
[17:41:27.443]                       inherits <- base::inherits
[17:41:27.443]                       invokeRestart <- base::invokeRestart
[17:41:27.443]                       is.null <- base::is.null
[17:41:27.443]                       muffled <- FALSE
[17:41:27.443]                       if (inherits(cond, "message")) {
[17:41:27.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.443]                         if (muffled) 
[17:41:27.443]                           invokeRestart("muffleMessage")
[17:41:27.443]                       }
[17:41:27.443]                       else if (inherits(cond, "warning")) {
[17:41:27.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.443]                         if (muffled) 
[17:41:27.443]                           invokeRestart("muffleWarning")
[17:41:27.443]                       }
[17:41:27.443]                       else if (inherits(cond, "condition")) {
[17:41:27.443]                         if (!is.null(pattern)) {
[17:41:27.443]                           computeRestarts <- base::computeRestarts
[17:41:27.443]                           grepl <- base::grepl
[17:41:27.443]                           restarts <- computeRestarts(cond)
[17:41:27.443]                           for (restart in restarts) {
[17:41:27.443]                             name <- restart$name
[17:41:27.443]                             if (is.null(name)) 
[17:41:27.443]                               next
[17:41:27.443]                             if (!grepl(pattern, name)) 
[17:41:27.443]                               next
[17:41:27.443]                             invokeRestart(restart)
[17:41:27.443]                             muffled <- TRUE
[17:41:27.443]                             break
[17:41:27.443]                           }
[17:41:27.443]                         }
[17:41:27.443]                       }
[17:41:27.443]                       invisible(muffled)
[17:41:27.443]                     }
[17:41:27.443]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.443]                   }
[17:41:27.443]                 }
[17:41:27.443]             }
[17:41:27.443]         }))
[17:41:27.443]     }, error = function(ex) {
[17:41:27.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.443]                 ...future.rng), started = ...future.startTime, 
[17:41:27.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.443]             version = "1.8"), class = "FutureResult")
[17:41:27.443]     }, finally = {
[17:41:27.443]         if (!identical(...future.workdir, getwd())) 
[17:41:27.443]             setwd(...future.workdir)
[17:41:27.443]         {
[17:41:27.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.443]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.443]             }
[17:41:27.443]             base::options(...future.oldOptions)
[17:41:27.443]             if (.Platform$OS.type == "windows") {
[17:41:27.443]                 old_names <- names(...future.oldEnvVars)
[17:41:27.443]                 envs <- base::Sys.getenv()
[17:41:27.443]                 names <- names(envs)
[17:41:27.443]                 common <- intersect(names, old_names)
[17:41:27.443]                 added <- setdiff(names, old_names)
[17:41:27.443]                 removed <- setdiff(old_names, names)
[17:41:27.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.443]                   envs[common]]
[17:41:27.443]                 NAMES <- toupper(changed)
[17:41:27.443]                 args <- list()
[17:41:27.443]                 for (kk in seq_along(NAMES)) {
[17:41:27.443]                   name <- changed[[kk]]
[17:41:27.443]                   NAME <- NAMES[[kk]]
[17:41:27.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.443]                     next
[17:41:27.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.443]                 }
[17:41:27.443]                 NAMES <- toupper(added)
[17:41:27.443]                 for (kk in seq_along(NAMES)) {
[17:41:27.443]                   name <- added[[kk]]
[17:41:27.443]                   NAME <- NAMES[[kk]]
[17:41:27.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.443]                     next
[17:41:27.443]                   args[[name]] <- ""
[17:41:27.443]                 }
[17:41:27.443]                 NAMES <- toupper(removed)
[17:41:27.443]                 for (kk in seq_along(NAMES)) {
[17:41:27.443]                   name <- removed[[kk]]
[17:41:27.443]                   NAME <- NAMES[[kk]]
[17:41:27.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.443]                     next
[17:41:27.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.443]                 }
[17:41:27.443]                 if (length(args) > 0) 
[17:41:27.443]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.443]             }
[17:41:27.443]             else {
[17:41:27.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.443]             }
[17:41:27.443]             {
[17:41:27.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.443]                   0L) {
[17:41:27.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.443]                   base::options(opts)
[17:41:27.443]                 }
[17:41:27.443]                 {
[17:41:27.443]                   {
[17:41:27.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.443]                     NULL
[17:41:27.443]                   }
[17:41:27.443]                   options(future.plan = NULL)
[17:41:27.443]                   if (is.na(NA_character_)) 
[17:41:27.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.443]                     .init = FALSE)
[17:41:27.443]                 }
[17:41:27.443]             }
[17:41:27.443]         }
[17:41:27.443]     })
[17:41:27.443]     if (FALSE) {
[17:41:27.443]         base::sink(type = "output", split = FALSE)
[17:41:27.443]         if (NA) {
[17:41:27.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.443]         }
[17:41:27.443]         else {
[17:41:27.443]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.443]         }
[17:41:27.443]         base::close(...future.stdout)
[17:41:27.443]         ...future.stdout <- NULL
[17:41:27.443]     }
[17:41:27.443]     ...future.result$conditions <- ...future.conditions
[17:41:27.443]     ...future.result$finished <- base::Sys.time()
[17:41:27.443]     ...future.result
[17:41:27.443] }
[17:41:27.445] requestCore(): workers = 2
[17:41:27.447] MulticoreFuture started
[17:41:27.447] - Launch lazy future ... done
[17:41:27.448] run() for ‘MulticoreFuture’ ... done
[17:41:27.448] result() for MulticoreFuture ...
[17:41:27.449] plan(): Setting new future strategy stack:
[17:41:27.449] List of future strategies:
[17:41:27.449] 1. sequential:
[17:41:27.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.449]    - tweaked: FALSE
[17:41:27.449]    - call: NULL
[17:41:27.450] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[17:41:27.453] plan(): Setting new future strategy stack:
[17:41:27.454] List of future strategies:
[17:41:27.454] 1. multicore:
[17:41:27.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.454]    - tweaked: FALSE
[17:41:27.454]    - call: plan(strategy)
[17:41:27.458] plan(): nbrOfWorkers() = 2
[17:41:27.459] result() for MulticoreFuture ...
[17:41:27.459] result() for MulticoreFuture ... done
[17:41:27.459] result() for MulticoreFuture ... done
[17:41:27.459] result() for MulticoreFuture ...
[17:41:27.460] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:27.460] getGlobalsAndPackages() ...
[17:41:27.460] Searching for globals...
[17:41:27.461] - globals found: [1] ‘print’
[17:41:27.461] Searching for globals ... DONE
[17:41:27.461] Resolving globals: FALSE
[17:41:27.462] 
[17:41:27.462] 
[17:41:27.462] getGlobalsAndPackages() ... DONE
[17:41:27.462] run() for ‘Future’ ...
[17:41:27.462] - state: ‘created’
[17:41:27.462] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:41:27.466] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:27.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:41:27.467]   - Field: ‘label’
[17:41:27.467]   - Field: ‘local’
[17:41:27.467]   - Field: ‘owner’
[17:41:27.467]   - Field: ‘envir’
[17:41:27.467]   - Field: ‘workers’
[17:41:27.467]   - Field: ‘packages’
[17:41:27.467]   - Field: ‘gc’
[17:41:27.468]   - Field: ‘job’
[17:41:27.468]   - Field: ‘conditions’
[17:41:27.468]   - Field: ‘expr’
[17:41:27.468]   - Field: ‘uuid’
[17:41:27.468]   - Field: ‘seed’
[17:41:27.468]   - Field: ‘version’
[17:41:27.468]   - Field: ‘result’
[17:41:27.468]   - Field: ‘asynchronous’
[17:41:27.469]   - Field: ‘calls’
[17:41:27.469]   - Field: ‘globals’
[17:41:27.469]   - Field: ‘stdout’
[17:41:27.469]   - Field: ‘earlySignal’
[17:41:27.469]   - Field: ‘lazy’
[17:41:27.469]   - Field: ‘state’
[17:41:27.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:41:27.469] - Launch lazy future ...
[17:41:27.470] Packages needed by the future expression (n = 0): <none>
[17:41:27.470] Packages needed by future strategies (n = 0): <none>
[17:41:27.470] {
[17:41:27.470]     {
[17:41:27.470]         {
[17:41:27.470]             ...future.startTime <- base::Sys.time()
[17:41:27.470]             {
[17:41:27.470]                 {
[17:41:27.470]                   {
[17:41:27.470]                     {
[17:41:27.470]                       base::local({
[17:41:27.470]                         has_future <- base::requireNamespace("future", 
[17:41:27.470]                           quietly = TRUE)
[17:41:27.470]                         if (has_future) {
[17:41:27.470]                           ns <- base::getNamespace("future")
[17:41:27.470]                           version <- ns[[".package"]][["version"]]
[17:41:27.470]                           if (is.null(version)) 
[17:41:27.470]                             version <- utils::packageVersion("future")
[17:41:27.470]                         }
[17:41:27.470]                         else {
[17:41:27.470]                           version <- NULL
[17:41:27.470]                         }
[17:41:27.470]                         if (!has_future || version < "1.8.0") {
[17:41:27.470]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:27.470]                             "", base::R.version$version.string), 
[17:41:27.470]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:27.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:27.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:27.470]                               "release", "version")], collapse = " "), 
[17:41:27.470]                             hostname = base::Sys.info()[["nodename"]])
[17:41:27.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:27.470]                             info)
[17:41:27.470]                           info <- base::paste(info, collapse = "; ")
[17:41:27.470]                           if (!has_future) {
[17:41:27.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:27.470]                               info)
[17:41:27.470]                           }
[17:41:27.470]                           else {
[17:41:27.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:27.470]                               info, version)
[17:41:27.470]                           }
[17:41:27.470]                           base::stop(msg)
[17:41:27.470]                         }
[17:41:27.470]                       })
[17:41:27.470]                     }
[17:41:27.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:27.470]                     base::options(mc.cores = 1L)
[17:41:27.470]                   }
[17:41:27.470]                   ...future.strategy.old <- future::plan("list")
[17:41:27.470]                   options(future.plan = NULL)
[17:41:27.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:27.470]                 }
[17:41:27.470]                 ...future.workdir <- getwd()
[17:41:27.470]             }
[17:41:27.470]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:27.470]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:27.470]         }
[17:41:27.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:27.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:27.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:27.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:27.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:27.470]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:27.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:27.470]             base::names(...future.oldOptions))
[17:41:27.470]     }
[17:41:27.470]     if (FALSE) {
[17:41:27.470]     }
[17:41:27.470]     else {
[17:41:27.470]         if (TRUE) {
[17:41:27.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:27.470]                 open = "w")
[17:41:27.470]         }
[17:41:27.470]         else {
[17:41:27.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:27.470]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:27.470]         }
[17:41:27.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:27.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:27.470]             base::sink(type = "output", split = FALSE)
[17:41:27.470]             base::close(...future.stdout)
[17:41:27.470]         }, add = TRUE)
[17:41:27.470]     }
[17:41:27.470]     ...future.frame <- base::sys.nframe()
[17:41:27.470]     ...future.conditions <- base::list()
[17:41:27.470]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:27.470]     if (FALSE) {
[17:41:27.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:27.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:27.470]     }
[17:41:27.470]     ...future.result <- base::tryCatch({
[17:41:27.470]         base::withCallingHandlers({
[17:41:27.470]             ...future.value <- base::withVisible(base::local({
[17:41:27.470]                 withCallingHandlers({
[17:41:27.470]                   print(42)
[17:41:27.470]                 }, immediateCondition = function(cond) {
[17:41:27.470]                   save_rds <- function (object, pathname, ...) 
[17:41:27.470]                   {
[17:41:27.470]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:41:27.470]                     if (file_test("-f", pathname_tmp)) {
[17:41:27.470]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.470]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:41:27.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.470]                         fi_tmp[["mtime"]])
[17:41:27.470]                     }
[17:41:27.470]                     tryCatch({
[17:41:27.470]                       saveRDS(object, file = pathname_tmp, ...)
[17:41:27.470]                     }, error = function(ex) {
[17:41:27.470]                       msg <- conditionMessage(ex)
[17:41:27.470]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.470]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:41:27.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.470]                         fi_tmp[["mtime"]], msg)
[17:41:27.470]                       ex$message <- msg
[17:41:27.470]                       stop(ex)
[17:41:27.470]                     })
[17:41:27.470]                     stopifnot(file_test("-f", pathname_tmp))
[17:41:27.470]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:41:27.470]                     if (!res || file_test("-f", pathname_tmp)) {
[17:41:27.470]                       fi_tmp <- file.info(pathname_tmp)
[17:41:27.470]                       fi <- file.info(pathname)
[17:41:27.470]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:41:27.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:41:27.470]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:41:27.470]                         fi[["size"]], fi[["mtime"]])
[17:41:27.470]                       stop(msg)
[17:41:27.470]                     }
[17:41:27.470]                     invisible(pathname)
[17:41:27.470]                   }
[17:41:27.470]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:41:27.470]                     rootPath = tempdir()) 
[17:41:27.470]                   {
[17:41:27.470]                     obj <- list(time = Sys.time(), condition = cond)
[17:41:27.470]                     file <- tempfile(pattern = class(cond)[1], 
[17:41:27.470]                       tmpdir = path, fileext = ".rds")
[17:41:27.470]                     save_rds(obj, file)
[17:41:27.470]                   }
[17:41:27.470]                   saveImmediateCondition(cond, path = "/tmp/RtmpH9wy3t/.future/immediateConditions")
[17:41:27.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.470]                   {
[17:41:27.470]                     inherits <- base::inherits
[17:41:27.470]                     invokeRestart <- base::invokeRestart
[17:41:27.470]                     is.null <- base::is.null
[17:41:27.470]                     muffled <- FALSE
[17:41:27.470]                     if (inherits(cond, "message")) {
[17:41:27.470]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:27.470]                       if (muffled) 
[17:41:27.470]                         invokeRestart("muffleMessage")
[17:41:27.470]                     }
[17:41:27.470]                     else if (inherits(cond, "warning")) {
[17:41:27.470]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:27.470]                       if (muffled) 
[17:41:27.470]                         invokeRestart("muffleWarning")
[17:41:27.470]                     }
[17:41:27.470]                     else if (inherits(cond, "condition")) {
[17:41:27.470]                       if (!is.null(pattern)) {
[17:41:27.470]                         computeRestarts <- base::computeRestarts
[17:41:27.470]                         grepl <- base::grepl
[17:41:27.470]                         restarts <- computeRestarts(cond)
[17:41:27.470]                         for (restart in restarts) {
[17:41:27.470]                           name <- restart$name
[17:41:27.470]                           if (is.null(name)) 
[17:41:27.470]                             next
[17:41:27.470]                           if (!grepl(pattern, name)) 
[17:41:27.470]                             next
[17:41:27.470]                           invokeRestart(restart)
[17:41:27.470]                           muffled <- TRUE
[17:41:27.470]                           break
[17:41:27.470]                         }
[17:41:27.470]                       }
[17:41:27.470]                     }
[17:41:27.470]                     invisible(muffled)
[17:41:27.470]                   }
[17:41:27.470]                   muffleCondition(cond)
[17:41:27.470]                 })
[17:41:27.470]             }))
[17:41:27.470]             future::FutureResult(value = ...future.value$value, 
[17:41:27.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.470]                   ...future.rng), globalenv = if (FALSE) 
[17:41:27.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:27.470]                     ...future.globalenv.names))
[17:41:27.470]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:27.470]         }, condition = base::local({
[17:41:27.470]             c <- base::c
[17:41:27.470]             inherits <- base::inherits
[17:41:27.470]             invokeRestart <- base::invokeRestart
[17:41:27.470]             length <- base::length
[17:41:27.470]             list <- base::list
[17:41:27.470]             seq.int <- base::seq.int
[17:41:27.470]             signalCondition <- base::signalCondition
[17:41:27.470]             sys.calls <- base::sys.calls
[17:41:27.470]             `[[` <- base::`[[`
[17:41:27.470]             `+` <- base::`+`
[17:41:27.470]             `<<-` <- base::`<<-`
[17:41:27.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:27.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:27.470]                   3L)]
[17:41:27.470]             }
[17:41:27.470]             function(cond) {
[17:41:27.470]                 is_error <- inherits(cond, "error")
[17:41:27.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:27.470]                   NULL)
[17:41:27.470]                 if (is_error) {
[17:41:27.470]                   sessionInformation <- function() {
[17:41:27.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:27.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:27.470]                       search = base::search(), system = base::Sys.info())
[17:41:27.470]                   }
[17:41:27.470]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:27.470]                     cond$call), session = sessionInformation(), 
[17:41:27.470]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:27.470]                   signalCondition(cond)
[17:41:27.470]                 }
[17:41:27.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:27.470]                 "immediateCondition"))) {
[17:41:27.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:27.470]                   ...future.conditions[[length(...future.conditions) + 
[17:41:27.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:27.470]                   if (TRUE && !signal) {
[17:41:27.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.470]                     {
[17:41:27.470]                       inherits <- base::inherits
[17:41:27.470]                       invokeRestart <- base::invokeRestart
[17:41:27.470]                       is.null <- base::is.null
[17:41:27.470]                       muffled <- FALSE
[17:41:27.470]                       if (inherits(cond, "message")) {
[17:41:27.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.470]                         if (muffled) 
[17:41:27.470]                           invokeRestart("muffleMessage")
[17:41:27.470]                       }
[17:41:27.470]                       else if (inherits(cond, "warning")) {
[17:41:27.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.470]                         if (muffled) 
[17:41:27.470]                           invokeRestart("muffleWarning")
[17:41:27.470]                       }
[17:41:27.470]                       else if (inherits(cond, "condition")) {
[17:41:27.470]                         if (!is.null(pattern)) {
[17:41:27.470]                           computeRestarts <- base::computeRestarts
[17:41:27.470]                           grepl <- base::grepl
[17:41:27.470]                           restarts <- computeRestarts(cond)
[17:41:27.470]                           for (restart in restarts) {
[17:41:27.470]                             name <- restart$name
[17:41:27.470]                             if (is.null(name)) 
[17:41:27.470]                               next
[17:41:27.470]                             if (!grepl(pattern, name)) 
[17:41:27.470]                               next
[17:41:27.470]                             invokeRestart(restart)
[17:41:27.470]                             muffled <- TRUE
[17:41:27.470]                             break
[17:41:27.470]                           }
[17:41:27.470]                         }
[17:41:27.470]                       }
[17:41:27.470]                       invisible(muffled)
[17:41:27.470]                     }
[17:41:27.470]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.470]                   }
[17:41:27.470]                 }
[17:41:27.470]                 else {
[17:41:27.470]                   if (TRUE) {
[17:41:27.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:27.470]                     {
[17:41:27.470]                       inherits <- base::inherits
[17:41:27.470]                       invokeRestart <- base::invokeRestart
[17:41:27.470]                       is.null <- base::is.null
[17:41:27.470]                       muffled <- FALSE
[17:41:27.470]                       if (inherits(cond, "message")) {
[17:41:27.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:27.470]                         if (muffled) 
[17:41:27.470]                           invokeRestart("muffleMessage")
[17:41:27.470]                       }
[17:41:27.470]                       else if (inherits(cond, "warning")) {
[17:41:27.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:27.470]                         if (muffled) 
[17:41:27.470]                           invokeRestart("muffleWarning")
[17:41:27.470]                       }
[17:41:27.470]                       else if (inherits(cond, "condition")) {
[17:41:27.470]                         if (!is.null(pattern)) {
[17:41:27.470]                           computeRestarts <- base::computeRestarts
[17:41:27.470]                           grepl <- base::grepl
[17:41:27.470]                           restarts <- computeRestarts(cond)
[17:41:27.470]                           for (restart in restarts) {
[17:41:27.470]                             name <- restart$name
[17:41:27.470]                             if (is.null(name)) 
[17:41:27.470]                               next
[17:41:27.470]                             if (!grepl(pattern, name)) 
[17:41:27.470]                               next
[17:41:27.470]                             invokeRestart(restart)
[17:41:27.470]                             muffled <- TRUE
[17:41:27.470]                             break
[17:41:27.470]                           }
[17:41:27.470]                         }
[17:41:27.470]                       }
[17:41:27.470]                       invisible(muffled)
[17:41:27.470]                     }
[17:41:27.470]                     muffleCondition(cond, pattern = "^muffle")
[17:41:27.470]                   }
[17:41:27.470]                 }
[17:41:27.470]             }
[17:41:27.470]         }))
[17:41:27.470]     }, error = function(ex) {
[17:41:27.470]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:27.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:27.470]                 ...future.rng), started = ...future.startTime, 
[17:41:27.470]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:27.470]             version = "1.8"), class = "FutureResult")
[17:41:27.470]     }, finally = {
[17:41:27.470]         if (!identical(...future.workdir, getwd())) 
[17:41:27.470]             setwd(...future.workdir)
[17:41:27.470]         {
[17:41:27.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:27.470]                 ...future.oldOptions$nwarnings <- NULL
[17:41:27.470]             }
[17:41:27.470]             base::options(...future.oldOptions)
[17:41:27.470]             if (.Platform$OS.type == "windows") {
[17:41:27.470]                 old_names <- names(...future.oldEnvVars)
[17:41:27.470]                 envs <- base::Sys.getenv()
[17:41:27.470]                 names <- names(envs)
[17:41:27.470]                 common <- intersect(names, old_names)
[17:41:27.470]                 added <- setdiff(names, old_names)
[17:41:27.470]                 removed <- setdiff(old_names, names)
[17:41:27.470]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:27.470]                   envs[common]]
[17:41:27.470]                 NAMES <- toupper(changed)
[17:41:27.470]                 args <- list()
[17:41:27.470]                 for (kk in seq_along(NAMES)) {
[17:41:27.470]                   name <- changed[[kk]]
[17:41:27.470]                   NAME <- NAMES[[kk]]
[17:41:27.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.470]                     next
[17:41:27.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.470]                 }
[17:41:27.470]                 NAMES <- toupper(added)
[17:41:27.470]                 for (kk in seq_along(NAMES)) {
[17:41:27.470]                   name <- added[[kk]]
[17:41:27.470]                   NAME <- NAMES[[kk]]
[17:41:27.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.470]                     next
[17:41:27.470]                   args[[name]] <- ""
[17:41:27.470]                 }
[17:41:27.470]                 NAMES <- toupper(removed)
[17:41:27.470]                 for (kk in seq_along(NAMES)) {
[17:41:27.470]                   name <- removed[[kk]]
[17:41:27.470]                   NAME <- NAMES[[kk]]
[17:41:27.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:27.470]                     next
[17:41:27.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:27.470]                 }
[17:41:27.470]                 if (length(args) > 0) 
[17:41:27.470]                   base::do.call(base::Sys.setenv, args = args)
[17:41:27.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:27.470]             }
[17:41:27.470]             else {
[17:41:27.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:27.470]             }
[17:41:27.470]             {
[17:41:27.470]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:27.470]                   0L) {
[17:41:27.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:27.470]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:27.470]                   base::options(opts)
[17:41:27.470]                 }
[17:41:27.470]                 {
[17:41:27.470]                   {
[17:41:27.470]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:27.470]                     NULL
[17:41:27.470]                   }
[17:41:27.470]                   options(future.plan = NULL)
[17:41:27.470]                   if (is.na(NA_character_)) 
[17:41:27.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:27.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:27.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:27.470]                     .init = FALSE)
[17:41:27.470]                 }
[17:41:27.470]             }
[17:41:27.470]         }
[17:41:27.470]     })
[17:41:27.470]     if (TRUE) {
[17:41:27.470]         base::sink(type = "output", split = FALSE)
[17:41:27.470]         if (TRUE) {
[17:41:27.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:27.470]         }
[17:41:27.470]         else {
[17:41:27.470]             ...future.result["stdout"] <- base::list(NULL)
[17:41:27.470]         }
[17:41:27.470]         base::close(...future.stdout)
[17:41:27.470]         ...future.stdout <- NULL
[17:41:27.470]     }
[17:41:27.470]     ...future.result$conditions <- ...future.conditions
[17:41:27.470]     ...future.result$finished <- base::Sys.time()
[17:41:27.470]     ...future.result
[17:41:27.470] }
[17:41:27.473] requestCore(): workers = 2
[17:41:27.475] MulticoreFuture started
[17:41:27.475] - Launch lazy future ... done
[17:41:27.475] run() for ‘MulticoreFuture’ ... done
[17:41:27.475] result() for MulticoreFuture ...
[17:41:27.476] plan(): Setting new future strategy stack:
[17:41:27.476] List of future strategies:
[17:41:27.476] 1. sequential:
[17:41:27.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:27.476]    - tweaked: FALSE
[17:41:27.476]    - call: NULL
[17:41:27.477] plan(): nbrOfWorkers() = 1
[17:41:27.479] plan(): Setting new future strategy stack:
[17:41:27.479] List of future strategies:
[17:41:27.479] 1. multicore:
[17:41:27.479]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:41:27.479]    - tweaked: FALSE
[17:41:27.479]    - call: plan(strategy)
[17:41:27.484] plan(): nbrOfWorkers() = 2
[17:41:27.485] result() for MulticoreFuture ...
[17:41:27.485] result() for MulticoreFuture ... done
[17:41:27.485] result() for MulticoreFuture ... done
[17:41:27.485] result() for MulticoreFuture ...
[17:41:27.485] result() for MulticoreFuture ... done
[17:41:27.485] result() for MulticoreFuture ...
[17:41:27.486] result() for MulticoreFuture ... done
[1] 42
[17:41:27.486] result() for MulticoreFuture ...
[17:41:27.486] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[17:41:27.486] plan(): Setting new future strategy stack:
[17:41:27.487] List of future strategies:
[17:41:27.487] 1. multisession:
[17:41:27.487]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:27.487]    - tweaked: FALSE
[17:41:27.487]    - call: plan(strategy)
[17:41:27.487] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:41:27.487] multisession:
[17:41:27.487] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:41:27.487] - tweaked: FALSE
[17:41:27.487] - call: plan(strategy)
[17:41:27.494] getGlobalsAndPackages() ...
[17:41:27.494] Not searching for globals
[17:41:27.494] - globals: [0] <none>
[17:41:27.494] getGlobalsAndPackages() ... DONE
[17:41:27.495] [local output] makeClusterPSOCK() ...
[17:41:27.540] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:41:27.541] [local output] Base port: 11775
[17:41:27.541] [local output] Getting setup options for 2 cluster nodes ...
[17:41:27.541] [local output]  - Node 1 of 2 ...
[17:41:27.541] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:27.542] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpH9wy3t/worker.rank=1.parallelly.parent=50430.c4fe240cb301.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpH9wy3t/worker.rank=1.parallelly.parent=50430.c4fe240cb301.pid")'’
[17:41:27.729] - Possible to infer worker's PID: TRUE
[17:41:27.729] [local output] Rscript port: 11775

[17:41:27.729] [local output]  - Node 2 of 2 ...
[17:41:27.730] [local output] localMachine=TRUE => revtunnel=FALSE

[17:41:27.730] [local output] Rscript port: 11775

[17:41:27.731] [local output] Getting setup options for 2 cluster nodes ... done
[17:41:27.731] [local output]  - Parallel setup requested for some PSOCK nodes
[17:41:27.731] [local output] Setting up PSOCK nodes in parallel
[17:41:27.731] List of 36
[17:41:27.731]  $ worker          : chr "localhost"
[17:41:27.731]   ..- attr(*, "localhost")= logi TRUE
[17:41:27.731]  $ master          : chr "localhost"
[17:41:27.731]  $ port            : int 11775
[17:41:27.731]  $ connectTimeout  : num 120
[17:41:27.731]  $ timeout         : num 2592000
[17:41:27.731]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:41:27.731]  $ homogeneous     : logi TRUE
[17:41:27.731]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:41:27.731]  $ rscript_envs    : NULL
[17:41:27.731]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:27.731]  $ rscript_startup : NULL
[17:41:27.731]  $ rscript_sh      : chr "sh"
[17:41:27.731]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:27.731]  $ methods         : logi TRUE
[17:41:27.731]  $ socketOptions   : chr "no-delay"
[17:41:27.731]  $ useXDR          : logi FALSE
[17:41:27.731]  $ outfile         : chr "/dev/null"
[17:41:27.731]  $ renice          : int NA
[17:41:27.731]  $ rshcmd          : NULL
[17:41:27.731]  $ user            : chr(0) 
[17:41:27.731]  $ revtunnel       : logi FALSE
[17:41:27.731]  $ rshlogfile      : NULL
[17:41:27.731]  $ rshopts         : chr(0) 
[17:41:27.731]  $ rank            : int 1
[17:41:27.731]  $ manual          : logi FALSE
[17:41:27.731]  $ dryrun          : logi FALSE
[17:41:27.731]  $ quiet           : logi FALSE
[17:41:27.731]  $ setup_strategy  : chr "parallel"
[17:41:27.731]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:27.731]  $ pidfile         : chr "/tmp/RtmpH9wy3t/worker.rank=1.parallelly.parent=50430.c4fe240cb301.pid"
[17:41:27.731]  $ rshcmd_label    : NULL
[17:41:27.731]  $ rsh_call        : NULL
[17:41:27.731]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:41:27.731]  $ localMachine    : logi TRUE
[17:41:27.731]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:41:27.731]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:41:27.731]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:41:27.731]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:41:27.731]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:41:27.731]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:41:27.731]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:41:27.731]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:41:27.731]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:41:27.731]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:41:27.731]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:41:27.731]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:41:27.731]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:41:27.731]  $ arguments       :List of 28
[17:41:27.731]   ..$ worker          : chr "localhost"
[17:41:27.731]   ..$ master          : NULL
[17:41:27.731]   ..$ port            : int 11775
[17:41:27.731]   ..$ connectTimeout  : num 120
[17:41:27.731]   ..$ timeout         : num 2592000
[17:41:27.731]   ..$ rscript         : NULL
[17:41:27.731]   ..$ homogeneous     : NULL
[17:41:27.731]   ..$ rscript_args    : NULL
[17:41:27.731]   ..$ rscript_envs    : NULL
[17:41:27.731]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:41:27.731]   ..$ rscript_startup : NULL
[17:41:27.731]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:41:27.731]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:41:27.731]   ..$ methods         : logi TRUE
[17:41:27.731]   ..$ socketOptions   : chr "no-delay"
[17:41:27.731]   ..$ useXDR          : logi FALSE
[17:41:27.731]   ..$ outfile         : chr "/dev/null"
[17:41:27.731]   ..$ renice          : int NA
[17:41:27.731]   ..$ rshcmd          : NULL
[17:41:27.731]   ..$ user            : NULL
[17:41:27.731]   ..$ revtunnel       : logi NA
[17:41:27.731]   ..$ rshlogfile      : NULL
[17:41:27.731]   ..$ rshopts         : NULL
[17:41:27.731]   ..$ rank            : int 1
[17:41:27.731]   ..$ manual          : logi FALSE
[17:41:27.731]   ..$ dryrun          : logi FALSE
[17:41:27.731]   ..$ quiet           : logi FALSE
[17:41:27.731]   ..$ setup_strategy  : chr "parallel"
[17:41:27.731]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:41:27.748] [local output] System call to launch all workers:
[17:41:27.748] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpH9wy3t/worker.rank=1.parallelly.parent=50430.c4fe240cb301.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11775 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:41:27.748] [local output] Starting PSOCK main server
[17:41:27.755] [local output] Workers launched
[17:41:27.755] [local output] Waiting for workers to connect back
[17:41:27.755]  - [local output] 0 workers out of 2 ready
[17:41:27.989]  - [local output] 0 workers out of 2 ready
[17:41:27.990]  - [local output] 1 workers out of 2 ready
[17:41:28.002]  - [local output] 1 workers out of 2 ready
[17:41:28.003]  - [local output] 2 workers out of 2 ready
[17:41:28.003] [local output] Launching of workers completed
[17:41:28.003] [local output] Collecting session information from workers
[17:41:28.004] [local output]  - Worker #1 of 2
[17:41:28.004] [local output]  - Worker #2 of 2
[17:41:28.005] [local output] makeClusterPSOCK() ... done
[17:41:28.017] Packages needed by the future expression (n = 0): <none>
[17:41:28.017] Packages needed by future strategies (n = 0): <none>
[17:41:28.017] {
[17:41:28.017]     {
[17:41:28.017]         {
[17:41:28.017]             ...future.startTime <- base::Sys.time()
[17:41:28.017]             {
[17:41:28.017]                 {
[17:41:28.017]                   {
[17:41:28.017]                     {
[17:41:28.017]                       base::local({
[17:41:28.017]                         has_future <- base::requireNamespace("future", 
[17:41:28.017]                           quietly = TRUE)
[17:41:28.017]                         if (has_future) {
[17:41:28.017]                           ns <- base::getNamespace("future")
[17:41:28.017]                           version <- ns[[".package"]][["version"]]
[17:41:28.017]                           if (is.null(version)) 
[17:41:28.017]                             version <- utils::packageVersion("future")
[17:41:28.017]                         }
[17:41:28.017]                         else {
[17:41:28.017]                           version <- NULL
[17:41:28.017]                         }
[17:41:28.017]                         if (!has_future || version < "1.8.0") {
[17:41:28.017]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.017]                             "", base::R.version$version.string), 
[17:41:28.017]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:28.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:28.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.017]                               "release", "version")], collapse = " "), 
[17:41:28.017]                             hostname = base::Sys.info()[["nodename"]])
[17:41:28.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.017]                             info)
[17:41:28.017]                           info <- base::paste(info, collapse = "; ")
[17:41:28.017]                           if (!has_future) {
[17:41:28.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.017]                               info)
[17:41:28.017]                           }
[17:41:28.017]                           else {
[17:41:28.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.017]                               info, version)
[17:41:28.017]                           }
[17:41:28.017]                           base::stop(msg)
[17:41:28.017]                         }
[17:41:28.017]                       })
[17:41:28.017]                     }
[17:41:28.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.017]                     base::options(mc.cores = 1L)
[17:41:28.017]                   }
[17:41:28.017]                   ...future.strategy.old <- future::plan("list")
[17:41:28.017]                   options(future.plan = NULL)
[17:41:28.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.017]                 }
[17:41:28.017]                 ...future.workdir <- getwd()
[17:41:28.017]             }
[17:41:28.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.017]         }
[17:41:28.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.017]             base::names(...future.oldOptions))
[17:41:28.017]     }
[17:41:28.017]     if (FALSE) {
[17:41:28.017]     }
[17:41:28.017]     else {
[17:41:28.017]         if (TRUE) {
[17:41:28.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.017]                 open = "w")
[17:41:28.017]         }
[17:41:28.017]         else {
[17:41:28.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.017]         }
[17:41:28.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.017]             base::sink(type = "output", split = FALSE)
[17:41:28.017]             base::close(...future.stdout)
[17:41:28.017]         }, add = TRUE)
[17:41:28.017]     }
[17:41:28.017]     ...future.frame <- base::sys.nframe()
[17:41:28.017]     ...future.conditions <- base::list()
[17:41:28.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.017]     if (FALSE) {
[17:41:28.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.017]     }
[17:41:28.017]     ...future.result <- base::tryCatch({
[17:41:28.017]         base::withCallingHandlers({
[17:41:28.017]             ...future.value <- base::withVisible(base::local({
[17:41:28.017]                 ...future.makeSendCondition <- base::local({
[17:41:28.017]                   sendCondition <- NULL
[17:41:28.017]                   function(frame = 1L) {
[17:41:28.017]                     if (is.function(sendCondition)) 
[17:41:28.017]                       return(sendCondition)
[17:41:28.017]                     ns <- getNamespace("parallel")
[17:41:28.017]                     if (exists("sendData", mode = "function", 
[17:41:28.017]                       envir = ns)) {
[17:41:28.017]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.017]                         envir = ns)
[17:41:28.017]                       envir <- sys.frame(frame)
[17:41:28.017]                       master <- NULL
[17:41:28.017]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.017]                         !identical(envir, emptyenv())) {
[17:41:28.017]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.017]                           inherits = FALSE)) {
[17:41:28.017]                           master <- get("master", mode = "list", 
[17:41:28.017]                             envir = envir, inherits = FALSE)
[17:41:28.017]                           if (inherits(master, c("SOCKnode", 
[17:41:28.017]                             "SOCK0node"))) {
[17:41:28.017]                             sendCondition <<- function(cond) {
[17:41:28.017]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.017]                                 success = TRUE)
[17:41:28.017]                               parallel_sendData(master, data)
[17:41:28.017]                             }
[17:41:28.017]                             return(sendCondition)
[17:41:28.017]                           }
[17:41:28.017]                         }
[17:41:28.017]                         frame <- frame + 1L
[17:41:28.017]                         envir <- sys.frame(frame)
[17:41:28.017]                       }
[17:41:28.017]                     }
[17:41:28.017]                     sendCondition <<- function(cond) NULL
[17:41:28.017]                   }
[17:41:28.017]                 })
[17:41:28.017]                 withCallingHandlers({
[17:41:28.017]                   NA
[17:41:28.017]                 }, immediateCondition = function(cond) {
[17:41:28.017]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.017]                   sendCondition(cond)
[17:41:28.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.017]                   {
[17:41:28.017]                     inherits <- base::inherits
[17:41:28.017]                     invokeRestart <- base::invokeRestart
[17:41:28.017]                     is.null <- base::is.null
[17:41:28.017]                     muffled <- FALSE
[17:41:28.017]                     if (inherits(cond, "message")) {
[17:41:28.017]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.017]                       if (muffled) 
[17:41:28.017]                         invokeRestart("muffleMessage")
[17:41:28.017]                     }
[17:41:28.017]                     else if (inherits(cond, "warning")) {
[17:41:28.017]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.017]                       if (muffled) 
[17:41:28.017]                         invokeRestart("muffleWarning")
[17:41:28.017]                     }
[17:41:28.017]                     else if (inherits(cond, "condition")) {
[17:41:28.017]                       if (!is.null(pattern)) {
[17:41:28.017]                         computeRestarts <- base::computeRestarts
[17:41:28.017]                         grepl <- base::grepl
[17:41:28.017]                         restarts <- computeRestarts(cond)
[17:41:28.017]                         for (restart in restarts) {
[17:41:28.017]                           name <- restart$name
[17:41:28.017]                           if (is.null(name)) 
[17:41:28.017]                             next
[17:41:28.017]                           if (!grepl(pattern, name)) 
[17:41:28.017]                             next
[17:41:28.017]                           invokeRestart(restart)
[17:41:28.017]                           muffled <- TRUE
[17:41:28.017]                           break
[17:41:28.017]                         }
[17:41:28.017]                       }
[17:41:28.017]                     }
[17:41:28.017]                     invisible(muffled)
[17:41:28.017]                   }
[17:41:28.017]                   muffleCondition(cond)
[17:41:28.017]                 })
[17:41:28.017]             }))
[17:41:28.017]             future::FutureResult(value = ...future.value$value, 
[17:41:28.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.017]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.017]                     ...future.globalenv.names))
[17:41:28.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.017]         }, condition = base::local({
[17:41:28.017]             c <- base::c
[17:41:28.017]             inherits <- base::inherits
[17:41:28.017]             invokeRestart <- base::invokeRestart
[17:41:28.017]             length <- base::length
[17:41:28.017]             list <- base::list
[17:41:28.017]             seq.int <- base::seq.int
[17:41:28.017]             signalCondition <- base::signalCondition
[17:41:28.017]             sys.calls <- base::sys.calls
[17:41:28.017]             `[[` <- base::`[[`
[17:41:28.017]             `+` <- base::`+`
[17:41:28.017]             `<<-` <- base::`<<-`
[17:41:28.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.017]                   3L)]
[17:41:28.017]             }
[17:41:28.017]             function(cond) {
[17:41:28.017]                 is_error <- inherits(cond, "error")
[17:41:28.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.017]                   NULL)
[17:41:28.017]                 if (is_error) {
[17:41:28.017]                   sessionInformation <- function() {
[17:41:28.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.017]                       search = base::search(), system = base::Sys.info())
[17:41:28.017]                   }
[17:41:28.017]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.017]                     cond$call), session = sessionInformation(), 
[17:41:28.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.017]                   signalCondition(cond)
[17:41:28.017]                 }
[17:41:28.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.017]                 "immediateCondition"))) {
[17:41:28.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.017]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.017]                   if (TRUE && !signal) {
[17:41:28.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.017]                     {
[17:41:28.017]                       inherits <- base::inherits
[17:41:28.017]                       invokeRestart <- base::invokeRestart
[17:41:28.017]                       is.null <- base::is.null
[17:41:28.017]                       muffled <- FALSE
[17:41:28.017]                       if (inherits(cond, "message")) {
[17:41:28.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.017]                         if (muffled) 
[17:41:28.017]                           invokeRestart("muffleMessage")
[17:41:28.017]                       }
[17:41:28.017]                       else if (inherits(cond, "warning")) {
[17:41:28.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.017]                         if (muffled) 
[17:41:28.017]                           invokeRestart("muffleWarning")
[17:41:28.017]                       }
[17:41:28.017]                       else if (inherits(cond, "condition")) {
[17:41:28.017]                         if (!is.null(pattern)) {
[17:41:28.017]                           computeRestarts <- base::computeRestarts
[17:41:28.017]                           grepl <- base::grepl
[17:41:28.017]                           restarts <- computeRestarts(cond)
[17:41:28.017]                           for (restart in restarts) {
[17:41:28.017]                             name <- restart$name
[17:41:28.017]                             if (is.null(name)) 
[17:41:28.017]                               next
[17:41:28.017]                             if (!grepl(pattern, name)) 
[17:41:28.017]                               next
[17:41:28.017]                             invokeRestart(restart)
[17:41:28.017]                             muffled <- TRUE
[17:41:28.017]                             break
[17:41:28.017]                           }
[17:41:28.017]                         }
[17:41:28.017]                       }
[17:41:28.017]                       invisible(muffled)
[17:41:28.017]                     }
[17:41:28.017]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.017]                   }
[17:41:28.017]                 }
[17:41:28.017]                 else {
[17:41:28.017]                   if (TRUE) {
[17:41:28.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.017]                     {
[17:41:28.017]                       inherits <- base::inherits
[17:41:28.017]                       invokeRestart <- base::invokeRestart
[17:41:28.017]                       is.null <- base::is.null
[17:41:28.017]                       muffled <- FALSE
[17:41:28.017]                       if (inherits(cond, "message")) {
[17:41:28.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.017]                         if (muffled) 
[17:41:28.017]                           invokeRestart("muffleMessage")
[17:41:28.017]                       }
[17:41:28.017]                       else if (inherits(cond, "warning")) {
[17:41:28.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.017]                         if (muffled) 
[17:41:28.017]                           invokeRestart("muffleWarning")
[17:41:28.017]                       }
[17:41:28.017]                       else if (inherits(cond, "condition")) {
[17:41:28.017]                         if (!is.null(pattern)) {
[17:41:28.017]                           computeRestarts <- base::computeRestarts
[17:41:28.017]                           grepl <- base::grepl
[17:41:28.017]                           restarts <- computeRestarts(cond)
[17:41:28.017]                           for (restart in restarts) {
[17:41:28.017]                             name <- restart$name
[17:41:28.017]                             if (is.null(name)) 
[17:41:28.017]                               next
[17:41:28.017]                             if (!grepl(pattern, name)) 
[17:41:28.017]                               next
[17:41:28.017]                             invokeRestart(restart)
[17:41:28.017]                             muffled <- TRUE
[17:41:28.017]                             break
[17:41:28.017]                           }
[17:41:28.017]                         }
[17:41:28.017]                       }
[17:41:28.017]                       invisible(muffled)
[17:41:28.017]                     }
[17:41:28.017]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.017]                   }
[17:41:28.017]                 }
[17:41:28.017]             }
[17:41:28.017]         }))
[17:41:28.017]     }, error = function(ex) {
[17:41:28.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.017]                 ...future.rng), started = ...future.startTime, 
[17:41:28.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.017]             version = "1.8"), class = "FutureResult")
[17:41:28.017]     }, finally = {
[17:41:28.017]         if (!identical(...future.workdir, getwd())) 
[17:41:28.017]             setwd(...future.workdir)
[17:41:28.017]         {
[17:41:28.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.017]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.017]             }
[17:41:28.017]             base::options(...future.oldOptions)
[17:41:28.017]             if (.Platform$OS.type == "windows") {
[17:41:28.017]                 old_names <- names(...future.oldEnvVars)
[17:41:28.017]                 envs <- base::Sys.getenv()
[17:41:28.017]                 names <- names(envs)
[17:41:28.017]                 common <- intersect(names, old_names)
[17:41:28.017]                 added <- setdiff(names, old_names)
[17:41:28.017]                 removed <- setdiff(old_names, names)
[17:41:28.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.017]                   envs[common]]
[17:41:28.017]                 NAMES <- toupper(changed)
[17:41:28.017]                 args <- list()
[17:41:28.017]                 for (kk in seq_along(NAMES)) {
[17:41:28.017]                   name <- changed[[kk]]
[17:41:28.017]                   NAME <- NAMES[[kk]]
[17:41:28.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.017]                     next
[17:41:28.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.017]                 }
[17:41:28.017]                 NAMES <- toupper(added)
[17:41:28.017]                 for (kk in seq_along(NAMES)) {
[17:41:28.017]                   name <- added[[kk]]
[17:41:28.017]                   NAME <- NAMES[[kk]]
[17:41:28.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.017]                     next
[17:41:28.017]                   args[[name]] <- ""
[17:41:28.017]                 }
[17:41:28.017]                 NAMES <- toupper(removed)
[17:41:28.017]                 for (kk in seq_along(NAMES)) {
[17:41:28.017]                   name <- removed[[kk]]
[17:41:28.017]                   NAME <- NAMES[[kk]]
[17:41:28.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.017]                     next
[17:41:28.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.017]                 }
[17:41:28.017]                 if (length(args) > 0) 
[17:41:28.017]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.017]             }
[17:41:28.017]             else {
[17:41:28.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.017]             }
[17:41:28.017]             {
[17:41:28.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.017]                   0L) {
[17:41:28.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.017]                   base::options(opts)
[17:41:28.017]                 }
[17:41:28.017]                 {
[17:41:28.017]                   {
[17:41:28.017]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.017]                     NULL
[17:41:28.017]                   }
[17:41:28.017]                   options(future.plan = NULL)
[17:41:28.017]                   if (is.na(NA_character_)) 
[17:41:28.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.017]                     .init = FALSE)
[17:41:28.017]                 }
[17:41:28.017]             }
[17:41:28.017]         }
[17:41:28.017]     })
[17:41:28.017]     if (TRUE) {
[17:41:28.017]         base::sink(type = "output", split = FALSE)
[17:41:28.017]         if (TRUE) {
[17:41:28.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.017]         }
[17:41:28.017]         else {
[17:41:28.017]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.017]         }
[17:41:28.017]         base::close(...future.stdout)
[17:41:28.017]         ...future.stdout <- NULL
[17:41:28.017]     }
[17:41:28.017]     ...future.result$conditions <- ...future.conditions
[17:41:28.017]     ...future.result$finished <- base::Sys.time()
[17:41:28.017]     ...future.result
[17:41:28.017] }
[17:41:28.069] MultisessionFuture started
[17:41:28.069] result() for ClusterFuture ...
[17:41:28.069] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.069] - Validating connection of MultisessionFuture
[17:41:28.100] - received message: FutureResult
[17:41:28.100] - Received FutureResult
[17:41:28.101] - Erased future from FutureRegistry
[17:41:28.101] result() for ClusterFuture ...
[17:41:28.101] - result already collected: FutureResult
[17:41:28.101] result() for ClusterFuture ... done
[17:41:28.101] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.101] result() for ClusterFuture ... done
[17:41:28.101] result() for ClusterFuture ...
[17:41:28.101] - result already collected: FutureResult
[17:41:28.101] result() for ClusterFuture ... done
[17:41:28.102] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:41:28.105] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[17:41:28.106] getGlobalsAndPackages() ...
[17:41:28.106] Searching for globals...
[17:41:28.110] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.110] Searching for globals ... DONE
[17:41:28.110] Resolving globals: FALSE
[17:41:28.110] 
[17:41:28.111] - packages: [1] ‘utils’
[17:41:28.111] getGlobalsAndPackages() ... DONE
[17:41:28.111] run() for ‘Future’ ...
[17:41:28.111] - state: ‘created’
[17:41:28.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.126]   - Field: ‘node’
[17:41:28.126]   - Field: ‘label’
[17:41:28.127]   - Field: ‘local’
[17:41:28.127]   - Field: ‘owner’
[17:41:28.127]   - Field: ‘envir’
[17:41:28.127]   - Field: ‘workers’
[17:41:28.127]   - Field: ‘packages’
[17:41:28.127]   - Field: ‘gc’
[17:41:28.127]   - Field: ‘conditions’
[17:41:28.127]   - Field: ‘persistent’
[17:41:28.127]   - Field: ‘expr’
[17:41:28.127]   - Field: ‘uuid’
[17:41:28.128]   - Field: ‘seed’
[17:41:28.128]   - Field: ‘version’
[17:41:28.128]   - Field: ‘result’
[17:41:28.128]   - Field: ‘asynchronous’
[17:41:28.128]   - Field: ‘calls’
[17:41:28.128]   - Field: ‘globals’
[17:41:28.128]   - Field: ‘stdout’
[17:41:28.128]   - Field: ‘earlySignal’
[17:41:28.128]   - Field: ‘lazy’
[17:41:28.129]   - Field: ‘state’
[17:41:28.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.129] - Launch lazy future ...
[17:41:28.129] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.129] Packages needed by future strategies (n = 0): <none>
[17:41:28.130] {
[17:41:28.130]     {
[17:41:28.130]         {
[17:41:28.130]             ...future.startTime <- base::Sys.time()
[17:41:28.130]             {
[17:41:28.130]                 {
[17:41:28.130]                   {
[17:41:28.130]                     {
[17:41:28.130]                       {
[17:41:28.130]                         base::local({
[17:41:28.130]                           has_future <- base::requireNamespace("future", 
[17:41:28.130]                             quietly = TRUE)
[17:41:28.130]                           if (has_future) {
[17:41:28.130]                             ns <- base::getNamespace("future")
[17:41:28.130]                             version <- ns[[".package"]][["version"]]
[17:41:28.130]                             if (is.null(version)) 
[17:41:28.130]                               version <- utils::packageVersion("future")
[17:41:28.130]                           }
[17:41:28.130]                           else {
[17:41:28.130]                             version <- NULL
[17:41:28.130]                           }
[17:41:28.130]                           if (!has_future || version < "1.8.0") {
[17:41:28.130]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.130]                               "", base::R.version$version.string), 
[17:41:28.130]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.130]                                 base::R.version$platform, 8 * 
[17:41:28.130]                                   base::.Machine$sizeof.pointer), 
[17:41:28.130]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.130]                                 "release", "version")], collapse = " "), 
[17:41:28.130]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.130]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.130]                               info)
[17:41:28.130]                             info <- base::paste(info, collapse = "; ")
[17:41:28.130]                             if (!has_future) {
[17:41:28.130]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.130]                                 info)
[17:41:28.130]                             }
[17:41:28.130]                             else {
[17:41:28.130]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.130]                                 info, version)
[17:41:28.130]                             }
[17:41:28.130]                             base::stop(msg)
[17:41:28.130]                           }
[17:41:28.130]                         })
[17:41:28.130]                       }
[17:41:28.130]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.130]                       base::options(mc.cores = 1L)
[17:41:28.130]                     }
[17:41:28.130]                     base::local({
[17:41:28.130]                       for (pkg in "utils") {
[17:41:28.130]                         base::loadNamespace(pkg)
[17:41:28.130]                         base::library(pkg, character.only = TRUE)
[17:41:28.130]                       }
[17:41:28.130]                     })
[17:41:28.130]                   }
[17:41:28.130]                   ...future.strategy.old <- future::plan("list")
[17:41:28.130]                   options(future.plan = NULL)
[17:41:28.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.130]                 }
[17:41:28.130]                 ...future.workdir <- getwd()
[17:41:28.130]             }
[17:41:28.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.130]         }
[17:41:28.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.130]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.130]             base::names(...future.oldOptions))
[17:41:28.130]     }
[17:41:28.130]     if (FALSE) {
[17:41:28.130]     }
[17:41:28.130]     else {
[17:41:28.130]         if (TRUE) {
[17:41:28.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.130]                 open = "w")
[17:41:28.130]         }
[17:41:28.130]         else {
[17:41:28.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.130]         }
[17:41:28.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.130]             base::sink(type = "output", split = FALSE)
[17:41:28.130]             base::close(...future.stdout)
[17:41:28.130]         }, add = TRUE)
[17:41:28.130]     }
[17:41:28.130]     ...future.frame <- base::sys.nframe()
[17:41:28.130]     ...future.conditions <- base::list()
[17:41:28.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.130]     if (FALSE) {
[17:41:28.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.130]     }
[17:41:28.130]     ...future.result <- base::tryCatch({
[17:41:28.130]         base::withCallingHandlers({
[17:41:28.130]             ...future.value <- base::withVisible(base::local({
[17:41:28.130]                 ...future.makeSendCondition <- base::local({
[17:41:28.130]                   sendCondition <- NULL
[17:41:28.130]                   function(frame = 1L) {
[17:41:28.130]                     if (is.function(sendCondition)) 
[17:41:28.130]                       return(sendCondition)
[17:41:28.130]                     ns <- getNamespace("parallel")
[17:41:28.130]                     if (exists("sendData", mode = "function", 
[17:41:28.130]                       envir = ns)) {
[17:41:28.130]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.130]                         envir = ns)
[17:41:28.130]                       envir <- sys.frame(frame)
[17:41:28.130]                       master <- NULL
[17:41:28.130]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.130]                         !identical(envir, emptyenv())) {
[17:41:28.130]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.130]                           inherits = FALSE)) {
[17:41:28.130]                           master <- get("master", mode = "list", 
[17:41:28.130]                             envir = envir, inherits = FALSE)
[17:41:28.130]                           if (inherits(master, c("SOCKnode", 
[17:41:28.130]                             "SOCK0node"))) {
[17:41:28.130]                             sendCondition <<- function(cond) {
[17:41:28.130]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.130]                                 success = TRUE)
[17:41:28.130]                               parallel_sendData(master, data)
[17:41:28.130]                             }
[17:41:28.130]                             return(sendCondition)
[17:41:28.130]                           }
[17:41:28.130]                         }
[17:41:28.130]                         frame <- frame + 1L
[17:41:28.130]                         envir <- sys.frame(frame)
[17:41:28.130]                       }
[17:41:28.130]                     }
[17:41:28.130]                     sendCondition <<- function(cond) NULL
[17:41:28.130]                   }
[17:41:28.130]                 })
[17:41:28.130]                 withCallingHandlers({
[17:41:28.130]                   {
[17:41:28.130]                     print(1:50)
[17:41:28.130]                     str(1:50)
[17:41:28.130]                     cat(letters, sep = "-")
[17:41:28.130]                     cat(1:6, collapse = "\n")
[17:41:28.130]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.130]                     42L
[17:41:28.130]                   }
[17:41:28.130]                 }, immediateCondition = function(cond) {
[17:41:28.130]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.130]                   sendCondition(cond)
[17:41:28.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.130]                   {
[17:41:28.130]                     inherits <- base::inherits
[17:41:28.130]                     invokeRestart <- base::invokeRestart
[17:41:28.130]                     is.null <- base::is.null
[17:41:28.130]                     muffled <- FALSE
[17:41:28.130]                     if (inherits(cond, "message")) {
[17:41:28.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.130]                       if (muffled) 
[17:41:28.130]                         invokeRestart("muffleMessage")
[17:41:28.130]                     }
[17:41:28.130]                     else if (inherits(cond, "warning")) {
[17:41:28.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.130]                       if (muffled) 
[17:41:28.130]                         invokeRestart("muffleWarning")
[17:41:28.130]                     }
[17:41:28.130]                     else if (inherits(cond, "condition")) {
[17:41:28.130]                       if (!is.null(pattern)) {
[17:41:28.130]                         computeRestarts <- base::computeRestarts
[17:41:28.130]                         grepl <- base::grepl
[17:41:28.130]                         restarts <- computeRestarts(cond)
[17:41:28.130]                         for (restart in restarts) {
[17:41:28.130]                           name <- restart$name
[17:41:28.130]                           if (is.null(name)) 
[17:41:28.130]                             next
[17:41:28.130]                           if (!grepl(pattern, name)) 
[17:41:28.130]                             next
[17:41:28.130]                           invokeRestart(restart)
[17:41:28.130]                           muffled <- TRUE
[17:41:28.130]                           break
[17:41:28.130]                         }
[17:41:28.130]                       }
[17:41:28.130]                     }
[17:41:28.130]                     invisible(muffled)
[17:41:28.130]                   }
[17:41:28.130]                   muffleCondition(cond)
[17:41:28.130]                 })
[17:41:28.130]             }))
[17:41:28.130]             future::FutureResult(value = ...future.value$value, 
[17:41:28.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.130]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.130]                     ...future.globalenv.names))
[17:41:28.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.130]         }, condition = base::local({
[17:41:28.130]             c <- base::c
[17:41:28.130]             inherits <- base::inherits
[17:41:28.130]             invokeRestart <- base::invokeRestart
[17:41:28.130]             length <- base::length
[17:41:28.130]             list <- base::list
[17:41:28.130]             seq.int <- base::seq.int
[17:41:28.130]             signalCondition <- base::signalCondition
[17:41:28.130]             sys.calls <- base::sys.calls
[17:41:28.130]             `[[` <- base::`[[`
[17:41:28.130]             `+` <- base::`+`
[17:41:28.130]             `<<-` <- base::`<<-`
[17:41:28.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.130]                   3L)]
[17:41:28.130]             }
[17:41:28.130]             function(cond) {
[17:41:28.130]                 is_error <- inherits(cond, "error")
[17:41:28.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.130]                   NULL)
[17:41:28.130]                 if (is_error) {
[17:41:28.130]                   sessionInformation <- function() {
[17:41:28.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.130]                       search = base::search(), system = base::Sys.info())
[17:41:28.130]                   }
[17:41:28.130]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.130]                     cond$call), session = sessionInformation(), 
[17:41:28.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.130]                   signalCondition(cond)
[17:41:28.130]                 }
[17:41:28.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.130]                 "immediateCondition"))) {
[17:41:28.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.130]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.130]                   if (TRUE && !signal) {
[17:41:28.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.130]                     {
[17:41:28.130]                       inherits <- base::inherits
[17:41:28.130]                       invokeRestart <- base::invokeRestart
[17:41:28.130]                       is.null <- base::is.null
[17:41:28.130]                       muffled <- FALSE
[17:41:28.130]                       if (inherits(cond, "message")) {
[17:41:28.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.130]                         if (muffled) 
[17:41:28.130]                           invokeRestart("muffleMessage")
[17:41:28.130]                       }
[17:41:28.130]                       else if (inherits(cond, "warning")) {
[17:41:28.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.130]                         if (muffled) 
[17:41:28.130]                           invokeRestart("muffleWarning")
[17:41:28.130]                       }
[17:41:28.130]                       else if (inherits(cond, "condition")) {
[17:41:28.130]                         if (!is.null(pattern)) {
[17:41:28.130]                           computeRestarts <- base::computeRestarts
[17:41:28.130]                           grepl <- base::grepl
[17:41:28.130]                           restarts <- computeRestarts(cond)
[17:41:28.130]                           for (restart in restarts) {
[17:41:28.130]                             name <- restart$name
[17:41:28.130]                             if (is.null(name)) 
[17:41:28.130]                               next
[17:41:28.130]                             if (!grepl(pattern, name)) 
[17:41:28.130]                               next
[17:41:28.130]                             invokeRestart(restart)
[17:41:28.130]                             muffled <- TRUE
[17:41:28.130]                             break
[17:41:28.130]                           }
[17:41:28.130]                         }
[17:41:28.130]                       }
[17:41:28.130]                       invisible(muffled)
[17:41:28.130]                     }
[17:41:28.130]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.130]                   }
[17:41:28.130]                 }
[17:41:28.130]                 else {
[17:41:28.130]                   if (TRUE) {
[17:41:28.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.130]                     {
[17:41:28.130]                       inherits <- base::inherits
[17:41:28.130]                       invokeRestart <- base::invokeRestart
[17:41:28.130]                       is.null <- base::is.null
[17:41:28.130]                       muffled <- FALSE
[17:41:28.130]                       if (inherits(cond, "message")) {
[17:41:28.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.130]                         if (muffled) 
[17:41:28.130]                           invokeRestart("muffleMessage")
[17:41:28.130]                       }
[17:41:28.130]                       else if (inherits(cond, "warning")) {
[17:41:28.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.130]                         if (muffled) 
[17:41:28.130]                           invokeRestart("muffleWarning")
[17:41:28.130]                       }
[17:41:28.130]                       else if (inherits(cond, "condition")) {
[17:41:28.130]                         if (!is.null(pattern)) {
[17:41:28.130]                           computeRestarts <- base::computeRestarts
[17:41:28.130]                           grepl <- base::grepl
[17:41:28.130]                           restarts <- computeRestarts(cond)
[17:41:28.130]                           for (restart in restarts) {
[17:41:28.130]                             name <- restart$name
[17:41:28.130]                             if (is.null(name)) 
[17:41:28.130]                               next
[17:41:28.130]                             if (!grepl(pattern, name)) 
[17:41:28.130]                               next
[17:41:28.130]                             invokeRestart(restart)
[17:41:28.130]                             muffled <- TRUE
[17:41:28.130]                             break
[17:41:28.130]                           }
[17:41:28.130]                         }
[17:41:28.130]                       }
[17:41:28.130]                       invisible(muffled)
[17:41:28.130]                     }
[17:41:28.130]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.130]                   }
[17:41:28.130]                 }
[17:41:28.130]             }
[17:41:28.130]         }))
[17:41:28.130]     }, error = function(ex) {
[17:41:28.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.130]                 ...future.rng), started = ...future.startTime, 
[17:41:28.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.130]             version = "1.8"), class = "FutureResult")
[17:41:28.130]     }, finally = {
[17:41:28.130]         if (!identical(...future.workdir, getwd())) 
[17:41:28.130]             setwd(...future.workdir)
[17:41:28.130]         {
[17:41:28.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.130]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.130]             }
[17:41:28.130]             base::options(...future.oldOptions)
[17:41:28.130]             if (.Platform$OS.type == "windows") {
[17:41:28.130]                 old_names <- names(...future.oldEnvVars)
[17:41:28.130]                 envs <- base::Sys.getenv()
[17:41:28.130]                 names <- names(envs)
[17:41:28.130]                 common <- intersect(names, old_names)
[17:41:28.130]                 added <- setdiff(names, old_names)
[17:41:28.130]                 removed <- setdiff(old_names, names)
[17:41:28.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.130]                   envs[common]]
[17:41:28.130]                 NAMES <- toupper(changed)
[17:41:28.130]                 args <- list()
[17:41:28.130]                 for (kk in seq_along(NAMES)) {
[17:41:28.130]                   name <- changed[[kk]]
[17:41:28.130]                   NAME <- NAMES[[kk]]
[17:41:28.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.130]                     next
[17:41:28.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.130]                 }
[17:41:28.130]                 NAMES <- toupper(added)
[17:41:28.130]                 for (kk in seq_along(NAMES)) {
[17:41:28.130]                   name <- added[[kk]]
[17:41:28.130]                   NAME <- NAMES[[kk]]
[17:41:28.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.130]                     next
[17:41:28.130]                   args[[name]] <- ""
[17:41:28.130]                 }
[17:41:28.130]                 NAMES <- toupper(removed)
[17:41:28.130]                 for (kk in seq_along(NAMES)) {
[17:41:28.130]                   name <- removed[[kk]]
[17:41:28.130]                   NAME <- NAMES[[kk]]
[17:41:28.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.130]                     next
[17:41:28.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.130]                 }
[17:41:28.130]                 if (length(args) > 0) 
[17:41:28.130]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.130]             }
[17:41:28.130]             else {
[17:41:28.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.130]             }
[17:41:28.130]             {
[17:41:28.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.130]                   0L) {
[17:41:28.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.130]                   base::options(opts)
[17:41:28.130]                 }
[17:41:28.130]                 {
[17:41:28.130]                   {
[17:41:28.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.130]                     NULL
[17:41:28.130]                   }
[17:41:28.130]                   options(future.plan = NULL)
[17:41:28.130]                   if (is.na(NA_character_)) 
[17:41:28.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.130]                     .init = FALSE)
[17:41:28.130]                 }
[17:41:28.130]             }
[17:41:28.130]         }
[17:41:28.130]     })
[17:41:28.130]     if (TRUE) {
[17:41:28.130]         base::sink(type = "output", split = FALSE)
[17:41:28.130]         if (TRUE) {
[17:41:28.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.130]         }
[17:41:28.130]         else {
[17:41:28.130]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.130]         }
[17:41:28.130]         base::close(...future.stdout)
[17:41:28.130]         ...future.stdout <- NULL
[17:41:28.130]     }
[17:41:28.130]     ...future.result$conditions <- ...future.conditions
[17:41:28.130]     ...future.result$finished <- base::Sys.time()
[17:41:28.130]     ...future.result
[17:41:28.130] }
[17:41:28.133] MultisessionFuture started
[17:41:28.134] - Launch lazy future ... done
[17:41:28.134] run() for ‘MultisessionFuture’ ... done
[17:41:28.134] result() for ClusterFuture ...
[17:41:28.134] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.134] - Validating connection of MultisessionFuture
[17:41:28.185] - received message: FutureResult
[17:41:28.185] - Received FutureResult
[17:41:28.185] - Erased future from FutureRegistry
[17:41:28.185] result() for ClusterFuture ...
[17:41:28.185] - result already collected: FutureResult
[17:41:28.186] result() for ClusterFuture ... done
[17:41:28.186] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.186] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ session_uuid: chr "4bd769f8-55a2-fda7-a5cb-25f0d1d11ef5"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50533
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:28.195] result() for ClusterFuture ...
[17:41:28.195] - result already collected: FutureResult
[17:41:28.195] result() for ClusterFuture ... done
[17:41:28.196] result() for ClusterFuture ...
[17:41:28.196] - result already collected: FutureResult
[17:41:28.196] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008292437 secs (started 2024-12-19 17:41:28.176932)
version: 1.8
[17:41:28.197] getGlobalsAndPackages() ...
[17:41:28.197] Searching for globals...
[17:41:28.200] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.201] Searching for globals ... DONE
[17:41:28.201] Resolving globals: FALSE
[17:41:28.201] 
[17:41:28.201] - packages: [1] ‘utils’
[17:41:28.201] getGlobalsAndPackages() ... DONE
[17:41:28.202] run() for ‘Future’ ...
[17:41:28.202] - state: ‘created’
[17:41:28.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.217]   - Field: ‘node’
[17:41:28.217]   - Field: ‘label’
[17:41:28.217]   - Field: ‘local’
[17:41:28.217]   - Field: ‘owner’
[17:41:28.217]   - Field: ‘envir’
[17:41:28.217]   - Field: ‘workers’
[17:41:28.217]   - Field: ‘packages’
[17:41:28.217]   - Field: ‘gc’
[17:41:28.218]   - Field: ‘conditions’
[17:41:28.218]   - Field: ‘persistent’
[17:41:28.218]   - Field: ‘expr’
[17:41:28.218]   - Field: ‘uuid’
[17:41:28.218]   - Field: ‘seed’
[17:41:28.218]   - Field: ‘version’
[17:41:28.218]   - Field: ‘result’
[17:41:28.218]   - Field: ‘asynchronous’
[17:41:28.218]   - Field: ‘calls’
[17:41:28.219]   - Field: ‘globals’
[17:41:28.219]   - Field: ‘stdout’
[17:41:28.219]   - Field: ‘earlySignal’
[17:41:28.219]   - Field: ‘lazy’
[17:41:28.219]   - Field: ‘state’
[17:41:28.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.219] - Launch lazy future ...
[17:41:28.220] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.220] Packages needed by future strategies (n = 0): <none>
[17:41:28.220] {
[17:41:28.220]     {
[17:41:28.220]         {
[17:41:28.220]             ...future.startTime <- base::Sys.time()
[17:41:28.220]             {
[17:41:28.220]                 {
[17:41:28.220]                   {
[17:41:28.220]                     {
[17:41:28.220]                       {
[17:41:28.220]                         base::local({
[17:41:28.220]                           has_future <- base::requireNamespace("future", 
[17:41:28.220]                             quietly = TRUE)
[17:41:28.220]                           if (has_future) {
[17:41:28.220]                             ns <- base::getNamespace("future")
[17:41:28.220]                             version <- ns[[".package"]][["version"]]
[17:41:28.220]                             if (is.null(version)) 
[17:41:28.220]                               version <- utils::packageVersion("future")
[17:41:28.220]                           }
[17:41:28.220]                           else {
[17:41:28.220]                             version <- NULL
[17:41:28.220]                           }
[17:41:28.220]                           if (!has_future || version < "1.8.0") {
[17:41:28.220]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.220]                               "", base::R.version$version.string), 
[17:41:28.220]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.220]                                 base::R.version$platform, 8 * 
[17:41:28.220]                                   base::.Machine$sizeof.pointer), 
[17:41:28.220]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.220]                                 "release", "version")], collapse = " "), 
[17:41:28.220]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.220]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.220]                               info)
[17:41:28.220]                             info <- base::paste(info, collapse = "; ")
[17:41:28.220]                             if (!has_future) {
[17:41:28.220]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.220]                                 info)
[17:41:28.220]                             }
[17:41:28.220]                             else {
[17:41:28.220]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.220]                                 info, version)
[17:41:28.220]                             }
[17:41:28.220]                             base::stop(msg)
[17:41:28.220]                           }
[17:41:28.220]                         })
[17:41:28.220]                       }
[17:41:28.220]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.220]                       base::options(mc.cores = 1L)
[17:41:28.220]                     }
[17:41:28.220]                     base::local({
[17:41:28.220]                       for (pkg in "utils") {
[17:41:28.220]                         base::loadNamespace(pkg)
[17:41:28.220]                         base::library(pkg, character.only = TRUE)
[17:41:28.220]                       }
[17:41:28.220]                     })
[17:41:28.220]                   }
[17:41:28.220]                   ...future.strategy.old <- future::plan("list")
[17:41:28.220]                   options(future.plan = NULL)
[17:41:28.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.220]                 }
[17:41:28.220]                 ...future.workdir <- getwd()
[17:41:28.220]             }
[17:41:28.220]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.220]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.220]         }
[17:41:28.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.220]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.220]             base::names(...future.oldOptions))
[17:41:28.220]     }
[17:41:28.220]     if (FALSE) {
[17:41:28.220]     }
[17:41:28.220]     else {
[17:41:28.220]         if (TRUE) {
[17:41:28.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.220]                 open = "w")
[17:41:28.220]         }
[17:41:28.220]         else {
[17:41:28.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.220]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.220]         }
[17:41:28.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.220]             base::sink(type = "output", split = FALSE)
[17:41:28.220]             base::close(...future.stdout)
[17:41:28.220]         }, add = TRUE)
[17:41:28.220]     }
[17:41:28.220]     ...future.frame <- base::sys.nframe()
[17:41:28.220]     ...future.conditions <- base::list()
[17:41:28.220]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.220]     if (FALSE) {
[17:41:28.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.220]     }
[17:41:28.220]     ...future.result <- base::tryCatch({
[17:41:28.220]         base::withCallingHandlers({
[17:41:28.220]             ...future.value <- base::withVisible(base::local({
[17:41:28.220]                 ...future.makeSendCondition <- base::local({
[17:41:28.220]                   sendCondition <- NULL
[17:41:28.220]                   function(frame = 1L) {
[17:41:28.220]                     if (is.function(sendCondition)) 
[17:41:28.220]                       return(sendCondition)
[17:41:28.220]                     ns <- getNamespace("parallel")
[17:41:28.220]                     if (exists("sendData", mode = "function", 
[17:41:28.220]                       envir = ns)) {
[17:41:28.220]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.220]                         envir = ns)
[17:41:28.220]                       envir <- sys.frame(frame)
[17:41:28.220]                       master <- NULL
[17:41:28.220]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.220]                         !identical(envir, emptyenv())) {
[17:41:28.220]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.220]                           inherits = FALSE)) {
[17:41:28.220]                           master <- get("master", mode = "list", 
[17:41:28.220]                             envir = envir, inherits = FALSE)
[17:41:28.220]                           if (inherits(master, c("SOCKnode", 
[17:41:28.220]                             "SOCK0node"))) {
[17:41:28.220]                             sendCondition <<- function(cond) {
[17:41:28.220]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.220]                                 success = TRUE)
[17:41:28.220]                               parallel_sendData(master, data)
[17:41:28.220]                             }
[17:41:28.220]                             return(sendCondition)
[17:41:28.220]                           }
[17:41:28.220]                         }
[17:41:28.220]                         frame <- frame + 1L
[17:41:28.220]                         envir <- sys.frame(frame)
[17:41:28.220]                       }
[17:41:28.220]                     }
[17:41:28.220]                     sendCondition <<- function(cond) NULL
[17:41:28.220]                   }
[17:41:28.220]                 })
[17:41:28.220]                 withCallingHandlers({
[17:41:28.220]                   {
[17:41:28.220]                     print(1:50)
[17:41:28.220]                     str(1:50)
[17:41:28.220]                     cat(letters, sep = "-")
[17:41:28.220]                     cat(1:6, collapse = "\n")
[17:41:28.220]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.220]                     42L
[17:41:28.220]                   }
[17:41:28.220]                 }, immediateCondition = function(cond) {
[17:41:28.220]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.220]                   sendCondition(cond)
[17:41:28.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.220]                   {
[17:41:28.220]                     inherits <- base::inherits
[17:41:28.220]                     invokeRestart <- base::invokeRestart
[17:41:28.220]                     is.null <- base::is.null
[17:41:28.220]                     muffled <- FALSE
[17:41:28.220]                     if (inherits(cond, "message")) {
[17:41:28.220]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.220]                       if (muffled) 
[17:41:28.220]                         invokeRestart("muffleMessage")
[17:41:28.220]                     }
[17:41:28.220]                     else if (inherits(cond, "warning")) {
[17:41:28.220]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.220]                       if (muffled) 
[17:41:28.220]                         invokeRestart("muffleWarning")
[17:41:28.220]                     }
[17:41:28.220]                     else if (inherits(cond, "condition")) {
[17:41:28.220]                       if (!is.null(pattern)) {
[17:41:28.220]                         computeRestarts <- base::computeRestarts
[17:41:28.220]                         grepl <- base::grepl
[17:41:28.220]                         restarts <- computeRestarts(cond)
[17:41:28.220]                         for (restart in restarts) {
[17:41:28.220]                           name <- restart$name
[17:41:28.220]                           if (is.null(name)) 
[17:41:28.220]                             next
[17:41:28.220]                           if (!grepl(pattern, name)) 
[17:41:28.220]                             next
[17:41:28.220]                           invokeRestart(restart)
[17:41:28.220]                           muffled <- TRUE
[17:41:28.220]                           break
[17:41:28.220]                         }
[17:41:28.220]                       }
[17:41:28.220]                     }
[17:41:28.220]                     invisible(muffled)
[17:41:28.220]                   }
[17:41:28.220]                   muffleCondition(cond)
[17:41:28.220]                 })
[17:41:28.220]             }))
[17:41:28.220]             future::FutureResult(value = ...future.value$value, 
[17:41:28.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.220]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.220]                     ...future.globalenv.names))
[17:41:28.220]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.220]         }, condition = base::local({
[17:41:28.220]             c <- base::c
[17:41:28.220]             inherits <- base::inherits
[17:41:28.220]             invokeRestart <- base::invokeRestart
[17:41:28.220]             length <- base::length
[17:41:28.220]             list <- base::list
[17:41:28.220]             seq.int <- base::seq.int
[17:41:28.220]             signalCondition <- base::signalCondition
[17:41:28.220]             sys.calls <- base::sys.calls
[17:41:28.220]             `[[` <- base::`[[`
[17:41:28.220]             `+` <- base::`+`
[17:41:28.220]             `<<-` <- base::`<<-`
[17:41:28.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.220]                   3L)]
[17:41:28.220]             }
[17:41:28.220]             function(cond) {
[17:41:28.220]                 is_error <- inherits(cond, "error")
[17:41:28.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.220]                   NULL)
[17:41:28.220]                 if (is_error) {
[17:41:28.220]                   sessionInformation <- function() {
[17:41:28.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.220]                       search = base::search(), system = base::Sys.info())
[17:41:28.220]                   }
[17:41:28.220]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.220]                     cond$call), session = sessionInformation(), 
[17:41:28.220]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.220]                   signalCondition(cond)
[17:41:28.220]                 }
[17:41:28.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.220]                 "immediateCondition"))) {
[17:41:28.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.220]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.220]                   if (TRUE && !signal) {
[17:41:28.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.220]                     {
[17:41:28.220]                       inherits <- base::inherits
[17:41:28.220]                       invokeRestart <- base::invokeRestart
[17:41:28.220]                       is.null <- base::is.null
[17:41:28.220]                       muffled <- FALSE
[17:41:28.220]                       if (inherits(cond, "message")) {
[17:41:28.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.220]                         if (muffled) 
[17:41:28.220]                           invokeRestart("muffleMessage")
[17:41:28.220]                       }
[17:41:28.220]                       else if (inherits(cond, "warning")) {
[17:41:28.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.220]                         if (muffled) 
[17:41:28.220]                           invokeRestart("muffleWarning")
[17:41:28.220]                       }
[17:41:28.220]                       else if (inherits(cond, "condition")) {
[17:41:28.220]                         if (!is.null(pattern)) {
[17:41:28.220]                           computeRestarts <- base::computeRestarts
[17:41:28.220]                           grepl <- base::grepl
[17:41:28.220]                           restarts <- computeRestarts(cond)
[17:41:28.220]                           for (restart in restarts) {
[17:41:28.220]                             name <- restart$name
[17:41:28.220]                             if (is.null(name)) 
[17:41:28.220]                               next
[17:41:28.220]                             if (!grepl(pattern, name)) 
[17:41:28.220]                               next
[17:41:28.220]                             invokeRestart(restart)
[17:41:28.220]                             muffled <- TRUE
[17:41:28.220]                             break
[17:41:28.220]                           }
[17:41:28.220]                         }
[17:41:28.220]                       }
[17:41:28.220]                       invisible(muffled)
[17:41:28.220]                     }
[17:41:28.220]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.220]                   }
[17:41:28.220]                 }
[17:41:28.220]                 else {
[17:41:28.220]                   if (TRUE) {
[17:41:28.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.220]                     {
[17:41:28.220]                       inherits <- base::inherits
[17:41:28.220]                       invokeRestart <- base::invokeRestart
[17:41:28.220]                       is.null <- base::is.null
[17:41:28.220]                       muffled <- FALSE
[17:41:28.220]                       if (inherits(cond, "message")) {
[17:41:28.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.220]                         if (muffled) 
[17:41:28.220]                           invokeRestart("muffleMessage")
[17:41:28.220]                       }
[17:41:28.220]                       else if (inherits(cond, "warning")) {
[17:41:28.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.220]                         if (muffled) 
[17:41:28.220]                           invokeRestart("muffleWarning")
[17:41:28.220]                       }
[17:41:28.220]                       else if (inherits(cond, "condition")) {
[17:41:28.220]                         if (!is.null(pattern)) {
[17:41:28.220]                           computeRestarts <- base::computeRestarts
[17:41:28.220]                           grepl <- base::grepl
[17:41:28.220]                           restarts <- computeRestarts(cond)
[17:41:28.220]                           for (restart in restarts) {
[17:41:28.220]                             name <- restart$name
[17:41:28.220]                             if (is.null(name)) 
[17:41:28.220]                               next
[17:41:28.220]                             if (!grepl(pattern, name)) 
[17:41:28.220]                               next
[17:41:28.220]                             invokeRestart(restart)
[17:41:28.220]                             muffled <- TRUE
[17:41:28.220]                             break
[17:41:28.220]                           }
[17:41:28.220]                         }
[17:41:28.220]                       }
[17:41:28.220]                       invisible(muffled)
[17:41:28.220]                     }
[17:41:28.220]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.220]                   }
[17:41:28.220]                 }
[17:41:28.220]             }
[17:41:28.220]         }))
[17:41:28.220]     }, error = function(ex) {
[17:41:28.220]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.220]                 ...future.rng), started = ...future.startTime, 
[17:41:28.220]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.220]             version = "1.8"), class = "FutureResult")
[17:41:28.220]     }, finally = {
[17:41:28.220]         if (!identical(...future.workdir, getwd())) 
[17:41:28.220]             setwd(...future.workdir)
[17:41:28.220]         {
[17:41:28.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.220]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.220]             }
[17:41:28.220]             base::options(...future.oldOptions)
[17:41:28.220]             if (.Platform$OS.type == "windows") {
[17:41:28.220]                 old_names <- names(...future.oldEnvVars)
[17:41:28.220]                 envs <- base::Sys.getenv()
[17:41:28.220]                 names <- names(envs)
[17:41:28.220]                 common <- intersect(names, old_names)
[17:41:28.220]                 added <- setdiff(names, old_names)
[17:41:28.220]                 removed <- setdiff(old_names, names)
[17:41:28.220]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.220]                   envs[common]]
[17:41:28.220]                 NAMES <- toupper(changed)
[17:41:28.220]                 args <- list()
[17:41:28.220]                 for (kk in seq_along(NAMES)) {
[17:41:28.220]                   name <- changed[[kk]]
[17:41:28.220]                   NAME <- NAMES[[kk]]
[17:41:28.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.220]                     next
[17:41:28.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.220]                 }
[17:41:28.220]                 NAMES <- toupper(added)
[17:41:28.220]                 for (kk in seq_along(NAMES)) {
[17:41:28.220]                   name <- added[[kk]]
[17:41:28.220]                   NAME <- NAMES[[kk]]
[17:41:28.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.220]                     next
[17:41:28.220]                   args[[name]] <- ""
[17:41:28.220]                 }
[17:41:28.220]                 NAMES <- toupper(removed)
[17:41:28.220]                 for (kk in seq_along(NAMES)) {
[17:41:28.220]                   name <- removed[[kk]]
[17:41:28.220]                   NAME <- NAMES[[kk]]
[17:41:28.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.220]                     next
[17:41:28.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.220]                 }
[17:41:28.220]                 if (length(args) > 0) 
[17:41:28.220]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.220]             }
[17:41:28.220]             else {
[17:41:28.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.220]             }
[17:41:28.220]             {
[17:41:28.220]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.220]                   0L) {
[17:41:28.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.220]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.220]                   base::options(opts)
[17:41:28.220]                 }
[17:41:28.220]                 {
[17:41:28.220]                   {
[17:41:28.220]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.220]                     NULL
[17:41:28.220]                   }
[17:41:28.220]                   options(future.plan = NULL)
[17:41:28.220]                   if (is.na(NA_character_)) 
[17:41:28.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.220]                     .init = FALSE)
[17:41:28.220]                 }
[17:41:28.220]             }
[17:41:28.220]         }
[17:41:28.220]     })
[17:41:28.220]     if (TRUE) {
[17:41:28.220]         base::sink(type = "output", split = FALSE)
[17:41:28.220]         if (TRUE) {
[17:41:28.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.220]         }
[17:41:28.220]         else {
[17:41:28.220]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.220]         }
[17:41:28.220]         base::close(...future.stdout)
[17:41:28.220]         ...future.stdout <- NULL
[17:41:28.220]     }
[17:41:28.220]     ...future.result$conditions <- ...future.conditions
[17:41:28.220]     ...future.result$finished <- base::Sys.time()
[17:41:28.220]     ...future.result
[17:41:28.220] }
[17:41:28.224] MultisessionFuture started
[17:41:28.224] - Launch lazy future ... done
[17:41:28.224] run() for ‘MultisessionFuture’ ... done
[17:41:28.224] result() for ClusterFuture ...
[17:41:28.225] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.225] - Validating connection of MultisessionFuture
[17:41:28.266] - received message: FutureResult
[17:41:28.267] - Received FutureResult
[17:41:28.267] - Erased future from FutureRegistry
[17:41:28.267] result() for ClusterFuture ...
[17:41:28.267] - result already collected: FutureResult
[17:41:28.267] result() for ClusterFuture ... done
[17:41:28.267] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.267] result() for ClusterFuture ... done
[17:41:28.267] result() for ClusterFuture ...
[17:41:28.268] - result already collected: FutureResult
[17:41:28.268] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[17:41:28.270] getGlobalsAndPackages() ...
[17:41:28.270] Searching for globals...
[17:41:28.271] - globals found: [1] ‘print’
[17:41:28.271] Searching for globals ... DONE
[17:41:28.271] Resolving globals: FALSE
[17:41:28.271] 
[17:41:28.271] 
[17:41:28.272] getGlobalsAndPackages() ... DONE
[17:41:28.272] run() for ‘Future’ ...
[17:41:28.272] - state: ‘created’
[17:41:28.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.286]   - Field: ‘node’
[17:41:28.286]   - Field: ‘label’
[17:41:28.286]   - Field: ‘local’
[17:41:28.286]   - Field: ‘owner’
[17:41:28.286]   - Field: ‘envir’
[17:41:28.286]   - Field: ‘workers’
[17:41:28.286]   - Field: ‘packages’
[17:41:28.286]   - Field: ‘gc’
[17:41:28.286]   - Field: ‘conditions’
[17:41:28.287]   - Field: ‘persistent’
[17:41:28.287]   - Field: ‘expr’
[17:41:28.287]   - Field: ‘uuid’
[17:41:28.287]   - Field: ‘seed’
[17:41:28.287]   - Field: ‘version’
[17:41:28.287]   - Field: ‘result’
[17:41:28.287]   - Field: ‘asynchronous’
[17:41:28.287]   - Field: ‘calls’
[17:41:28.287]   - Field: ‘globals’
[17:41:28.287]   - Field: ‘stdout’
[17:41:28.287]   - Field: ‘earlySignal’
[17:41:28.287]   - Field: ‘lazy’
[17:41:28.288]   - Field: ‘state’
[17:41:28.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.288] - Launch lazy future ...
[17:41:28.288] Packages needed by the future expression (n = 0): <none>
[17:41:28.288] Packages needed by future strategies (n = 0): <none>
[17:41:28.289] {
[17:41:28.289]     {
[17:41:28.289]         {
[17:41:28.289]             ...future.startTime <- base::Sys.time()
[17:41:28.289]             {
[17:41:28.289]                 {
[17:41:28.289]                   {
[17:41:28.289]                     {
[17:41:28.289]                       base::local({
[17:41:28.289]                         has_future <- base::requireNamespace("future", 
[17:41:28.289]                           quietly = TRUE)
[17:41:28.289]                         if (has_future) {
[17:41:28.289]                           ns <- base::getNamespace("future")
[17:41:28.289]                           version <- ns[[".package"]][["version"]]
[17:41:28.289]                           if (is.null(version)) 
[17:41:28.289]                             version <- utils::packageVersion("future")
[17:41:28.289]                         }
[17:41:28.289]                         else {
[17:41:28.289]                           version <- NULL
[17:41:28.289]                         }
[17:41:28.289]                         if (!has_future || version < "1.8.0") {
[17:41:28.289]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.289]                             "", base::R.version$version.string), 
[17:41:28.289]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:28.289]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:28.289]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.289]                               "release", "version")], collapse = " "), 
[17:41:28.289]                             hostname = base::Sys.info()[["nodename"]])
[17:41:28.289]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.289]                             info)
[17:41:28.289]                           info <- base::paste(info, collapse = "; ")
[17:41:28.289]                           if (!has_future) {
[17:41:28.289]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.289]                               info)
[17:41:28.289]                           }
[17:41:28.289]                           else {
[17:41:28.289]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.289]                               info, version)
[17:41:28.289]                           }
[17:41:28.289]                           base::stop(msg)
[17:41:28.289]                         }
[17:41:28.289]                       })
[17:41:28.289]                     }
[17:41:28.289]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.289]                     base::options(mc.cores = 1L)
[17:41:28.289]                   }
[17:41:28.289]                   ...future.strategy.old <- future::plan("list")
[17:41:28.289]                   options(future.plan = NULL)
[17:41:28.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.289]                 }
[17:41:28.289]                 ...future.workdir <- getwd()
[17:41:28.289]             }
[17:41:28.289]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.289]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.289]         }
[17:41:28.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.289]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.289]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.289]             base::names(...future.oldOptions))
[17:41:28.289]     }
[17:41:28.289]     if (FALSE) {
[17:41:28.289]     }
[17:41:28.289]     else {
[17:41:28.289]         if (TRUE) {
[17:41:28.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.289]                 open = "w")
[17:41:28.289]         }
[17:41:28.289]         else {
[17:41:28.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.289]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.289]         }
[17:41:28.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.289]             base::sink(type = "output", split = FALSE)
[17:41:28.289]             base::close(...future.stdout)
[17:41:28.289]         }, add = TRUE)
[17:41:28.289]     }
[17:41:28.289]     ...future.frame <- base::sys.nframe()
[17:41:28.289]     ...future.conditions <- base::list()
[17:41:28.289]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.289]     if (FALSE) {
[17:41:28.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.289]     }
[17:41:28.289]     ...future.result <- base::tryCatch({
[17:41:28.289]         base::withCallingHandlers({
[17:41:28.289]             ...future.value <- base::withVisible(base::local({
[17:41:28.289]                 ...future.makeSendCondition <- base::local({
[17:41:28.289]                   sendCondition <- NULL
[17:41:28.289]                   function(frame = 1L) {
[17:41:28.289]                     if (is.function(sendCondition)) 
[17:41:28.289]                       return(sendCondition)
[17:41:28.289]                     ns <- getNamespace("parallel")
[17:41:28.289]                     if (exists("sendData", mode = "function", 
[17:41:28.289]                       envir = ns)) {
[17:41:28.289]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.289]                         envir = ns)
[17:41:28.289]                       envir <- sys.frame(frame)
[17:41:28.289]                       master <- NULL
[17:41:28.289]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.289]                         !identical(envir, emptyenv())) {
[17:41:28.289]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.289]                           inherits = FALSE)) {
[17:41:28.289]                           master <- get("master", mode = "list", 
[17:41:28.289]                             envir = envir, inherits = FALSE)
[17:41:28.289]                           if (inherits(master, c("SOCKnode", 
[17:41:28.289]                             "SOCK0node"))) {
[17:41:28.289]                             sendCondition <<- function(cond) {
[17:41:28.289]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.289]                                 success = TRUE)
[17:41:28.289]                               parallel_sendData(master, data)
[17:41:28.289]                             }
[17:41:28.289]                             return(sendCondition)
[17:41:28.289]                           }
[17:41:28.289]                         }
[17:41:28.289]                         frame <- frame + 1L
[17:41:28.289]                         envir <- sys.frame(frame)
[17:41:28.289]                       }
[17:41:28.289]                     }
[17:41:28.289]                     sendCondition <<- function(cond) NULL
[17:41:28.289]                   }
[17:41:28.289]                 })
[17:41:28.289]                 withCallingHandlers({
[17:41:28.289]                   print(42)
[17:41:28.289]                 }, immediateCondition = function(cond) {
[17:41:28.289]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.289]                   sendCondition(cond)
[17:41:28.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.289]                   {
[17:41:28.289]                     inherits <- base::inherits
[17:41:28.289]                     invokeRestart <- base::invokeRestart
[17:41:28.289]                     is.null <- base::is.null
[17:41:28.289]                     muffled <- FALSE
[17:41:28.289]                     if (inherits(cond, "message")) {
[17:41:28.289]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.289]                       if (muffled) 
[17:41:28.289]                         invokeRestart("muffleMessage")
[17:41:28.289]                     }
[17:41:28.289]                     else if (inherits(cond, "warning")) {
[17:41:28.289]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.289]                       if (muffled) 
[17:41:28.289]                         invokeRestart("muffleWarning")
[17:41:28.289]                     }
[17:41:28.289]                     else if (inherits(cond, "condition")) {
[17:41:28.289]                       if (!is.null(pattern)) {
[17:41:28.289]                         computeRestarts <- base::computeRestarts
[17:41:28.289]                         grepl <- base::grepl
[17:41:28.289]                         restarts <- computeRestarts(cond)
[17:41:28.289]                         for (restart in restarts) {
[17:41:28.289]                           name <- restart$name
[17:41:28.289]                           if (is.null(name)) 
[17:41:28.289]                             next
[17:41:28.289]                           if (!grepl(pattern, name)) 
[17:41:28.289]                             next
[17:41:28.289]                           invokeRestart(restart)
[17:41:28.289]                           muffled <- TRUE
[17:41:28.289]                           break
[17:41:28.289]                         }
[17:41:28.289]                       }
[17:41:28.289]                     }
[17:41:28.289]                     invisible(muffled)
[17:41:28.289]                   }
[17:41:28.289]                   muffleCondition(cond)
[17:41:28.289]                 })
[17:41:28.289]             }))
[17:41:28.289]             future::FutureResult(value = ...future.value$value, 
[17:41:28.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.289]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.289]                     ...future.globalenv.names))
[17:41:28.289]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.289]         }, condition = base::local({
[17:41:28.289]             c <- base::c
[17:41:28.289]             inherits <- base::inherits
[17:41:28.289]             invokeRestart <- base::invokeRestart
[17:41:28.289]             length <- base::length
[17:41:28.289]             list <- base::list
[17:41:28.289]             seq.int <- base::seq.int
[17:41:28.289]             signalCondition <- base::signalCondition
[17:41:28.289]             sys.calls <- base::sys.calls
[17:41:28.289]             `[[` <- base::`[[`
[17:41:28.289]             `+` <- base::`+`
[17:41:28.289]             `<<-` <- base::`<<-`
[17:41:28.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.289]                   3L)]
[17:41:28.289]             }
[17:41:28.289]             function(cond) {
[17:41:28.289]                 is_error <- inherits(cond, "error")
[17:41:28.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.289]                   NULL)
[17:41:28.289]                 if (is_error) {
[17:41:28.289]                   sessionInformation <- function() {
[17:41:28.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.289]                       search = base::search(), system = base::Sys.info())
[17:41:28.289]                   }
[17:41:28.289]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.289]                     cond$call), session = sessionInformation(), 
[17:41:28.289]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.289]                   signalCondition(cond)
[17:41:28.289]                 }
[17:41:28.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.289]                 "immediateCondition"))) {
[17:41:28.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.289]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.289]                   if (TRUE && !signal) {
[17:41:28.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.289]                     {
[17:41:28.289]                       inherits <- base::inherits
[17:41:28.289]                       invokeRestart <- base::invokeRestart
[17:41:28.289]                       is.null <- base::is.null
[17:41:28.289]                       muffled <- FALSE
[17:41:28.289]                       if (inherits(cond, "message")) {
[17:41:28.289]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.289]                         if (muffled) 
[17:41:28.289]                           invokeRestart("muffleMessage")
[17:41:28.289]                       }
[17:41:28.289]                       else if (inherits(cond, "warning")) {
[17:41:28.289]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.289]                         if (muffled) 
[17:41:28.289]                           invokeRestart("muffleWarning")
[17:41:28.289]                       }
[17:41:28.289]                       else if (inherits(cond, "condition")) {
[17:41:28.289]                         if (!is.null(pattern)) {
[17:41:28.289]                           computeRestarts <- base::computeRestarts
[17:41:28.289]                           grepl <- base::grepl
[17:41:28.289]                           restarts <- computeRestarts(cond)
[17:41:28.289]                           for (restart in restarts) {
[17:41:28.289]                             name <- restart$name
[17:41:28.289]                             if (is.null(name)) 
[17:41:28.289]                               next
[17:41:28.289]                             if (!grepl(pattern, name)) 
[17:41:28.289]                               next
[17:41:28.289]                             invokeRestart(restart)
[17:41:28.289]                             muffled <- TRUE
[17:41:28.289]                             break
[17:41:28.289]                           }
[17:41:28.289]                         }
[17:41:28.289]                       }
[17:41:28.289]                       invisible(muffled)
[17:41:28.289]                     }
[17:41:28.289]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.289]                   }
[17:41:28.289]                 }
[17:41:28.289]                 else {
[17:41:28.289]                   if (TRUE) {
[17:41:28.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.289]                     {
[17:41:28.289]                       inherits <- base::inherits
[17:41:28.289]                       invokeRestart <- base::invokeRestart
[17:41:28.289]                       is.null <- base::is.null
[17:41:28.289]                       muffled <- FALSE
[17:41:28.289]                       if (inherits(cond, "message")) {
[17:41:28.289]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.289]                         if (muffled) 
[17:41:28.289]                           invokeRestart("muffleMessage")
[17:41:28.289]                       }
[17:41:28.289]                       else if (inherits(cond, "warning")) {
[17:41:28.289]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.289]                         if (muffled) 
[17:41:28.289]                           invokeRestart("muffleWarning")
[17:41:28.289]                       }
[17:41:28.289]                       else if (inherits(cond, "condition")) {
[17:41:28.289]                         if (!is.null(pattern)) {
[17:41:28.289]                           computeRestarts <- base::computeRestarts
[17:41:28.289]                           grepl <- base::grepl
[17:41:28.289]                           restarts <- computeRestarts(cond)
[17:41:28.289]                           for (restart in restarts) {
[17:41:28.289]                             name <- restart$name
[17:41:28.289]                             if (is.null(name)) 
[17:41:28.289]                               next
[17:41:28.289]                             if (!grepl(pattern, name)) 
[17:41:28.289]                               next
[17:41:28.289]                             invokeRestart(restart)
[17:41:28.289]                             muffled <- TRUE
[17:41:28.289]                             break
[17:41:28.289]                           }
[17:41:28.289]                         }
[17:41:28.289]                       }
[17:41:28.289]                       invisible(muffled)
[17:41:28.289]                     }
[17:41:28.289]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.289]                   }
[17:41:28.289]                 }
[17:41:28.289]             }
[17:41:28.289]         }))
[17:41:28.289]     }, error = function(ex) {
[17:41:28.289]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.289]                 ...future.rng), started = ...future.startTime, 
[17:41:28.289]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.289]             version = "1.8"), class = "FutureResult")
[17:41:28.289]     }, finally = {
[17:41:28.289]         if (!identical(...future.workdir, getwd())) 
[17:41:28.289]             setwd(...future.workdir)
[17:41:28.289]         {
[17:41:28.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.289]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.289]             }
[17:41:28.289]             base::options(...future.oldOptions)
[17:41:28.289]             if (.Platform$OS.type == "windows") {
[17:41:28.289]                 old_names <- names(...future.oldEnvVars)
[17:41:28.289]                 envs <- base::Sys.getenv()
[17:41:28.289]                 names <- names(envs)
[17:41:28.289]                 common <- intersect(names, old_names)
[17:41:28.289]                 added <- setdiff(names, old_names)
[17:41:28.289]                 removed <- setdiff(old_names, names)
[17:41:28.289]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.289]                   envs[common]]
[17:41:28.289]                 NAMES <- toupper(changed)
[17:41:28.289]                 args <- list()
[17:41:28.289]                 for (kk in seq_along(NAMES)) {
[17:41:28.289]                   name <- changed[[kk]]
[17:41:28.289]                   NAME <- NAMES[[kk]]
[17:41:28.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.289]                     next
[17:41:28.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.289]                 }
[17:41:28.289]                 NAMES <- toupper(added)
[17:41:28.289]                 for (kk in seq_along(NAMES)) {
[17:41:28.289]                   name <- added[[kk]]
[17:41:28.289]                   NAME <- NAMES[[kk]]
[17:41:28.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.289]                     next
[17:41:28.289]                   args[[name]] <- ""
[17:41:28.289]                 }
[17:41:28.289]                 NAMES <- toupper(removed)
[17:41:28.289]                 for (kk in seq_along(NAMES)) {
[17:41:28.289]                   name <- removed[[kk]]
[17:41:28.289]                   NAME <- NAMES[[kk]]
[17:41:28.289]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.289]                     next
[17:41:28.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.289]                 }
[17:41:28.289]                 if (length(args) > 0) 
[17:41:28.289]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.289]             }
[17:41:28.289]             else {
[17:41:28.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.289]             }
[17:41:28.289]             {
[17:41:28.289]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.289]                   0L) {
[17:41:28.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.289]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.289]                   base::options(opts)
[17:41:28.289]                 }
[17:41:28.289]                 {
[17:41:28.289]                   {
[17:41:28.289]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.289]                     NULL
[17:41:28.289]                   }
[17:41:28.289]                   options(future.plan = NULL)
[17:41:28.289]                   if (is.na(NA_character_)) 
[17:41:28.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.289]                     .init = FALSE)
[17:41:28.289]                 }
[17:41:28.289]             }
[17:41:28.289]         }
[17:41:28.289]     })
[17:41:28.289]     if (TRUE) {
[17:41:28.289]         base::sink(type = "output", split = FALSE)
[17:41:28.289]         if (TRUE) {
[17:41:28.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.289]         }
[17:41:28.289]         else {
[17:41:28.289]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.289]         }
[17:41:28.289]         base::close(...future.stdout)
[17:41:28.289]         ...future.stdout <- NULL
[17:41:28.289]     }
[17:41:28.289]     ...future.result$conditions <- ...future.conditions
[17:41:28.289]     ...future.result$finished <- base::Sys.time()
[17:41:28.289]     ...future.result
[17:41:28.289] }
[17:41:28.291] MultisessionFuture started
[17:41:28.291] - Launch lazy future ... done
[17:41:28.292] run() for ‘MultisessionFuture’ ... done
[17:41:28.292] result() for ClusterFuture ...
[17:41:28.292] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.292] - Validating connection of MultisessionFuture
[17:41:28.293] - received message: FutureResult
[17:41:28.293] - Received FutureResult
[17:41:28.293] - Erased future from FutureRegistry
[17:41:28.293] result() for ClusterFuture ...
[17:41:28.294] - result already collected: FutureResult
[17:41:28.294] result() for ClusterFuture ... done
[17:41:28.294] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.294] result() for ClusterFuture ... done
[17:41:28.294] result() for ClusterFuture ...
[17:41:28.294] - result already collected: FutureResult
[17:41:28.294] result() for ClusterFuture ... done
[17:41:28.294] result() for ClusterFuture ...
[17:41:28.294] - result already collected: FutureResult
[17:41:28.294] result() for ClusterFuture ... done
[1] 42
[17:41:28.294] result() for ClusterFuture ...
[17:41:28.295] - result already collected: FutureResult
[17:41:28.295] result() for ClusterFuture ... done
- stdout = FALSE
[17:41:28.295] getGlobalsAndPackages() ...
[17:41:28.295] Searching for globals...
[17:41:28.297] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.298] Searching for globals ... DONE
[17:41:28.298] Resolving globals: FALSE
[17:41:28.298] 
[17:41:28.298] - packages: [1] ‘utils’
[17:41:28.298] getGlobalsAndPackages() ... DONE
[17:41:28.299] run() for ‘Future’ ...
[17:41:28.299] - state: ‘created’
[17:41:28.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.312] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.312]   - Field: ‘node’
[17:41:28.312]   - Field: ‘label’
[17:41:28.312]   - Field: ‘local’
[17:41:28.313]   - Field: ‘owner’
[17:41:28.313]   - Field: ‘envir’
[17:41:28.313]   - Field: ‘workers’
[17:41:28.313]   - Field: ‘packages’
[17:41:28.313]   - Field: ‘gc’
[17:41:28.313]   - Field: ‘conditions’
[17:41:28.313]   - Field: ‘persistent’
[17:41:28.313]   - Field: ‘expr’
[17:41:28.313]   - Field: ‘uuid’
[17:41:28.313]   - Field: ‘seed’
[17:41:28.313]   - Field: ‘version’
[17:41:28.314]   - Field: ‘result’
[17:41:28.314]   - Field: ‘asynchronous’
[17:41:28.314]   - Field: ‘calls’
[17:41:28.314]   - Field: ‘globals’
[17:41:28.314]   - Field: ‘stdout’
[17:41:28.314]   - Field: ‘earlySignal’
[17:41:28.314]   - Field: ‘lazy’
[17:41:28.314]   - Field: ‘state’
[17:41:28.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.314] - Launch lazy future ...
[17:41:28.315] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.315] Packages needed by future strategies (n = 0): <none>
[17:41:28.315] {
[17:41:28.315]     {
[17:41:28.315]         {
[17:41:28.315]             ...future.startTime <- base::Sys.time()
[17:41:28.315]             {
[17:41:28.315]                 {
[17:41:28.315]                   {
[17:41:28.315]                     {
[17:41:28.315]                       {
[17:41:28.315]                         base::local({
[17:41:28.315]                           has_future <- base::requireNamespace("future", 
[17:41:28.315]                             quietly = TRUE)
[17:41:28.315]                           if (has_future) {
[17:41:28.315]                             ns <- base::getNamespace("future")
[17:41:28.315]                             version <- ns[[".package"]][["version"]]
[17:41:28.315]                             if (is.null(version)) 
[17:41:28.315]                               version <- utils::packageVersion("future")
[17:41:28.315]                           }
[17:41:28.315]                           else {
[17:41:28.315]                             version <- NULL
[17:41:28.315]                           }
[17:41:28.315]                           if (!has_future || version < "1.8.0") {
[17:41:28.315]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.315]                               "", base::R.version$version.string), 
[17:41:28.315]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.315]                                 base::R.version$platform, 8 * 
[17:41:28.315]                                   base::.Machine$sizeof.pointer), 
[17:41:28.315]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.315]                                 "release", "version")], collapse = " "), 
[17:41:28.315]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.315]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.315]                               info)
[17:41:28.315]                             info <- base::paste(info, collapse = "; ")
[17:41:28.315]                             if (!has_future) {
[17:41:28.315]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.315]                                 info)
[17:41:28.315]                             }
[17:41:28.315]                             else {
[17:41:28.315]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.315]                                 info, version)
[17:41:28.315]                             }
[17:41:28.315]                             base::stop(msg)
[17:41:28.315]                           }
[17:41:28.315]                         })
[17:41:28.315]                       }
[17:41:28.315]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.315]                       base::options(mc.cores = 1L)
[17:41:28.315]                     }
[17:41:28.315]                     base::local({
[17:41:28.315]                       for (pkg in "utils") {
[17:41:28.315]                         base::loadNamespace(pkg)
[17:41:28.315]                         base::library(pkg, character.only = TRUE)
[17:41:28.315]                       }
[17:41:28.315]                     })
[17:41:28.315]                   }
[17:41:28.315]                   ...future.strategy.old <- future::plan("list")
[17:41:28.315]                   options(future.plan = NULL)
[17:41:28.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.315]                 }
[17:41:28.315]                 ...future.workdir <- getwd()
[17:41:28.315]             }
[17:41:28.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.315]         }
[17:41:28.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.315]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.315]             base::names(...future.oldOptions))
[17:41:28.315]     }
[17:41:28.315]     if (FALSE) {
[17:41:28.315]     }
[17:41:28.315]     else {
[17:41:28.315]         if (FALSE) {
[17:41:28.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.315]                 open = "w")
[17:41:28.315]         }
[17:41:28.315]         else {
[17:41:28.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.315]         }
[17:41:28.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.315]             base::sink(type = "output", split = FALSE)
[17:41:28.315]             base::close(...future.stdout)
[17:41:28.315]         }, add = TRUE)
[17:41:28.315]     }
[17:41:28.315]     ...future.frame <- base::sys.nframe()
[17:41:28.315]     ...future.conditions <- base::list()
[17:41:28.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.315]     if (FALSE) {
[17:41:28.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.315]     }
[17:41:28.315]     ...future.result <- base::tryCatch({
[17:41:28.315]         base::withCallingHandlers({
[17:41:28.315]             ...future.value <- base::withVisible(base::local({
[17:41:28.315]                 ...future.makeSendCondition <- base::local({
[17:41:28.315]                   sendCondition <- NULL
[17:41:28.315]                   function(frame = 1L) {
[17:41:28.315]                     if (is.function(sendCondition)) 
[17:41:28.315]                       return(sendCondition)
[17:41:28.315]                     ns <- getNamespace("parallel")
[17:41:28.315]                     if (exists("sendData", mode = "function", 
[17:41:28.315]                       envir = ns)) {
[17:41:28.315]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.315]                         envir = ns)
[17:41:28.315]                       envir <- sys.frame(frame)
[17:41:28.315]                       master <- NULL
[17:41:28.315]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.315]                         !identical(envir, emptyenv())) {
[17:41:28.315]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.315]                           inherits = FALSE)) {
[17:41:28.315]                           master <- get("master", mode = "list", 
[17:41:28.315]                             envir = envir, inherits = FALSE)
[17:41:28.315]                           if (inherits(master, c("SOCKnode", 
[17:41:28.315]                             "SOCK0node"))) {
[17:41:28.315]                             sendCondition <<- function(cond) {
[17:41:28.315]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.315]                                 success = TRUE)
[17:41:28.315]                               parallel_sendData(master, data)
[17:41:28.315]                             }
[17:41:28.315]                             return(sendCondition)
[17:41:28.315]                           }
[17:41:28.315]                         }
[17:41:28.315]                         frame <- frame + 1L
[17:41:28.315]                         envir <- sys.frame(frame)
[17:41:28.315]                       }
[17:41:28.315]                     }
[17:41:28.315]                     sendCondition <<- function(cond) NULL
[17:41:28.315]                   }
[17:41:28.315]                 })
[17:41:28.315]                 withCallingHandlers({
[17:41:28.315]                   {
[17:41:28.315]                     print(1:50)
[17:41:28.315]                     str(1:50)
[17:41:28.315]                     cat(letters, sep = "-")
[17:41:28.315]                     cat(1:6, collapse = "\n")
[17:41:28.315]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.315]                     42L
[17:41:28.315]                   }
[17:41:28.315]                 }, immediateCondition = function(cond) {
[17:41:28.315]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.315]                   sendCondition(cond)
[17:41:28.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.315]                   {
[17:41:28.315]                     inherits <- base::inherits
[17:41:28.315]                     invokeRestart <- base::invokeRestart
[17:41:28.315]                     is.null <- base::is.null
[17:41:28.315]                     muffled <- FALSE
[17:41:28.315]                     if (inherits(cond, "message")) {
[17:41:28.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.315]                       if (muffled) 
[17:41:28.315]                         invokeRestart("muffleMessage")
[17:41:28.315]                     }
[17:41:28.315]                     else if (inherits(cond, "warning")) {
[17:41:28.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.315]                       if (muffled) 
[17:41:28.315]                         invokeRestart("muffleWarning")
[17:41:28.315]                     }
[17:41:28.315]                     else if (inherits(cond, "condition")) {
[17:41:28.315]                       if (!is.null(pattern)) {
[17:41:28.315]                         computeRestarts <- base::computeRestarts
[17:41:28.315]                         grepl <- base::grepl
[17:41:28.315]                         restarts <- computeRestarts(cond)
[17:41:28.315]                         for (restart in restarts) {
[17:41:28.315]                           name <- restart$name
[17:41:28.315]                           if (is.null(name)) 
[17:41:28.315]                             next
[17:41:28.315]                           if (!grepl(pattern, name)) 
[17:41:28.315]                             next
[17:41:28.315]                           invokeRestart(restart)
[17:41:28.315]                           muffled <- TRUE
[17:41:28.315]                           break
[17:41:28.315]                         }
[17:41:28.315]                       }
[17:41:28.315]                     }
[17:41:28.315]                     invisible(muffled)
[17:41:28.315]                   }
[17:41:28.315]                   muffleCondition(cond)
[17:41:28.315]                 })
[17:41:28.315]             }))
[17:41:28.315]             future::FutureResult(value = ...future.value$value, 
[17:41:28.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.315]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.315]                     ...future.globalenv.names))
[17:41:28.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.315]         }, condition = base::local({
[17:41:28.315]             c <- base::c
[17:41:28.315]             inherits <- base::inherits
[17:41:28.315]             invokeRestart <- base::invokeRestart
[17:41:28.315]             length <- base::length
[17:41:28.315]             list <- base::list
[17:41:28.315]             seq.int <- base::seq.int
[17:41:28.315]             signalCondition <- base::signalCondition
[17:41:28.315]             sys.calls <- base::sys.calls
[17:41:28.315]             `[[` <- base::`[[`
[17:41:28.315]             `+` <- base::`+`
[17:41:28.315]             `<<-` <- base::`<<-`
[17:41:28.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.315]                   3L)]
[17:41:28.315]             }
[17:41:28.315]             function(cond) {
[17:41:28.315]                 is_error <- inherits(cond, "error")
[17:41:28.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.315]                   NULL)
[17:41:28.315]                 if (is_error) {
[17:41:28.315]                   sessionInformation <- function() {
[17:41:28.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.315]                       search = base::search(), system = base::Sys.info())
[17:41:28.315]                   }
[17:41:28.315]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.315]                     cond$call), session = sessionInformation(), 
[17:41:28.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.315]                   signalCondition(cond)
[17:41:28.315]                 }
[17:41:28.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.315]                 "immediateCondition"))) {
[17:41:28.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.315]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.315]                   if (TRUE && !signal) {
[17:41:28.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.315]                     {
[17:41:28.315]                       inherits <- base::inherits
[17:41:28.315]                       invokeRestart <- base::invokeRestart
[17:41:28.315]                       is.null <- base::is.null
[17:41:28.315]                       muffled <- FALSE
[17:41:28.315]                       if (inherits(cond, "message")) {
[17:41:28.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.315]                         if (muffled) 
[17:41:28.315]                           invokeRestart("muffleMessage")
[17:41:28.315]                       }
[17:41:28.315]                       else if (inherits(cond, "warning")) {
[17:41:28.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.315]                         if (muffled) 
[17:41:28.315]                           invokeRestart("muffleWarning")
[17:41:28.315]                       }
[17:41:28.315]                       else if (inherits(cond, "condition")) {
[17:41:28.315]                         if (!is.null(pattern)) {
[17:41:28.315]                           computeRestarts <- base::computeRestarts
[17:41:28.315]                           grepl <- base::grepl
[17:41:28.315]                           restarts <- computeRestarts(cond)
[17:41:28.315]                           for (restart in restarts) {
[17:41:28.315]                             name <- restart$name
[17:41:28.315]                             if (is.null(name)) 
[17:41:28.315]                               next
[17:41:28.315]                             if (!grepl(pattern, name)) 
[17:41:28.315]                               next
[17:41:28.315]                             invokeRestart(restart)
[17:41:28.315]                             muffled <- TRUE
[17:41:28.315]                             break
[17:41:28.315]                           }
[17:41:28.315]                         }
[17:41:28.315]                       }
[17:41:28.315]                       invisible(muffled)
[17:41:28.315]                     }
[17:41:28.315]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.315]                   }
[17:41:28.315]                 }
[17:41:28.315]                 else {
[17:41:28.315]                   if (TRUE) {
[17:41:28.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.315]                     {
[17:41:28.315]                       inherits <- base::inherits
[17:41:28.315]                       invokeRestart <- base::invokeRestart
[17:41:28.315]                       is.null <- base::is.null
[17:41:28.315]                       muffled <- FALSE
[17:41:28.315]                       if (inherits(cond, "message")) {
[17:41:28.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.315]                         if (muffled) 
[17:41:28.315]                           invokeRestart("muffleMessage")
[17:41:28.315]                       }
[17:41:28.315]                       else if (inherits(cond, "warning")) {
[17:41:28.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.315]                         if (muffled) 
[17:41:28.315]                           invokeRestart("muffleWarning")
[17:41:28.315]                       }
[17:41:28.315]                       else if (inherits(cond, "condition")) {
[17:41:28.315]                         if (!is.null(pattern)) {
[17:41:28.315]                           computeRestarts <- base::computeRestarts
[17:41:28.315]                           grepl <- base::grepl
[17:41:28.315]                           restarts <- computeRestarts(cond)
[17:41:28.315]                           for (restart in restarts) {
[17:41:28.315]                             name <- restart$name
[17:41:28.315]                             if (is.null(name)) 
[17:41:28.315]                               next
[17:41:28.315]                             if (!grepl(pattern, name)) 
[17:41:28.315]                               next
[17:41:28.315]                             invokeRestart(restart)
[17:41:28.315]                             muffled <- TRUE
[17:41:28.315]                             break
[17:41:28.315]                           }
[17:41:28.315]                         }
[17:41:28.315]                       }
[17:41:28.315]                       invisible(muffled)
[17:41:28.315]                     }
[17:41:28.315]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.315]                   }
[17:41:28.315]                 }
[17:41:28.315]             }
[17:41:28.315]         }))
[17:41:28.315]     }, error = function(ex) {
[17:41:28.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.315]                 ...future.rng), started = ...future.startTime, 
[17:41:28.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.315]             version = "1.8"), class = "FutureResult")
[17:41:28.315]     }, finally = {
[17:41:28.315]         if (!identical(...future.workdir, getwd())) 
[17:41:28.315]             setwd(...future.workdir)
[17:41:28.315]         {
[17:41:28.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.315]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.315]             }
[17:41:28.315]             base::options(...future.oldOptions)
[17:41:28.315]             if (.Platform$OS.type == "windows") {
[17:41:28.315]                 old_names <- names(...future.oldEnvVars)
[17:41:28.315]                 envs <- base::Sys.getenv()
[17:41:28.315]                 names <- names(envs)
[17:41:28.315]                 common <- intersect(names, old_names)
[17:41:28.315]                 added <- setdiff(names, old_names)
[17:41:28.315]                 removed <- setdiff(old_names, names)
[17:41:28.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.315]                   envs[common]]
[17:41:28.315]                 NAMES <- toupper(changed)
[17:41:28.315]                 args <- list()
[17:41:28.315]                 for (kk in seq_along(NAMES)) {
[17:41:28.315]                   name <- changed[[kk]]
[17:41:28.315]                   NAME <- NAMES[[kk]]
[17:41:28.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.315]                     next
[17:41:28.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.315]                 }
[17:41:28.315]                 NAMES <- toupper(added)
[17:41:28.315]                 for (kk in seq_along(NAMES)) {
[17:41:28.315]                   name <- added[[kk]]
[17:41:28.315]                   NAME <- NAMES[[kk]]
[17:41:28.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.315]                     next
[17:41:28.315]                   args[[name]] <- ""
[17:41:28.315]                 }
[17:41:28.315]                 NAMES <- toupper(removed)
[17:41:28.315]                 for (kk in seq_along(NAMES)) {
[17:41:28.315]                   name <- removed[[kk]]
[17:41:28.315]                   NAME <- NAMES[[kk]]
[17:41:28.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.315]                     next
[17:41:28.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.315]                 }
[17:41:28.315]                 if (length(args) > 0) 
[17:41:28.315]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.315]             }
[17:41:28.315]             else {
[17:41:28.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.315]             }
[17:41:28.315]             {
[17:41:28.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.315]                   0L) {
[17:41:28.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.315]                   base::options(opts)
[17:41:28.315]                 }
[17:41:28.315]                 {
[17:41:28.315]                   {
[17:41:28.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.315]                     NULL
[17:41:28.315]                   }
[17:41:28.315]                   options(future.plan = NULL)
[17:41:28.315]                   if (is.na(NA_character_)) 
[17:41:28.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.315]                     .init = FALSE)
[17:41:28.315]                 }
[17:41:28.315]             }
[17:41:28.315]         }
[17:41:28.315]     })
[17:41:28.315]     if (TRUE) {
[17:41:28.315]         base::sink(type = "output", split = FALSE)
[17:41:28.315]         if (FALSE) {
[17:41:28.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.315]         }
[17:41:28.315]         else {
[17:41:28.315]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.315]         }
[17:41:28.315]         base::close(...future.stdout)
[17:41:28.315]         ...future.stdout <- NULL
[17:41:28.315]     }
[17:41:28.315]     ...future.result$conditions <- ...future.conditions
[17:41:28.315]     ...future.result$finished <- base::Sys.time()
[17:41:28.315]     ...future.result
[17:41:28.315] }
[17:41:28.318] MultisessionFuture started
[17:41:28.318] - Launch lazy future ... done
[17:41:28.318] run() for ‘MultisessionFuture’ ... done
[17:41:28.318] result() for ClusterFuture ...
[17:41:28.318] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.318] - Validating connection of MultisessionFuture
[17:41:28.362] - received message: FutureResult
[17:41:28.363] - Received FutureResult
[17:41:28.363] - Erased future from FutureRegistry
[17:41:28.363] result() for ClusterFuture ...
[17:41:28.363] - result already collected: FutureResult
[17:41:28.363] result() for ClusterFuture ... done
[17:41:28.363] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.363] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ session_uuid: chr "4bd769f8-55a2-fda7-a5cb-25f0d1d11ef5"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50533
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:28.371] result() for ClusterFuture ...
[17:41:28.371] - result already collected: FutureResult
[17:41:28.371] result() for ClusterFuture ... done
[17:41:28.371] result() for ClusterFuture ...
[17:41:28.371] - result already collected: FutureResult
[17:41:28.371] result() for ClusterFuture ... done
[17:41:28.371] getGlobalsAndPackages() ...
[17:41:28.371] Searching for globals...
[17:41:28.374] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.374] Searching for globals ... DONE
[17:41:28.374] Resolving globals: FALSE
[17:41:28.375] 
[17:41:28.375] - packages: [1] ‘utils’
[17:41:28.375] getGlobalsAndPackages() ... DONE
[17:41:28.375] run() for ‘Future’ ...
[17:41:28.375] - state: ‘created’
[17:41:28.376] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.389] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.389]   - Field: ‘node’
[17:41:28.389]   - Field: ‘label’
[17:41:28.389]   - Field: ‘local’
[17:41:28.389]   - Field: ‘owner’
[17:41:28.390]   - Field: ‘envir’
[17:41:28.390]   - Field: ‘workers’
[17:41:28.390]   - Field: ‘packages’
[17:41:28.390]   - Field: ‘gc’
[17:41:28.390]   - Field: ‘conditions’
[17:41:28.390]   - Field: ‘persistent’
[17:41:28.390]   - Field: ‘expr’
[17:41:28.390]   - Field: ‘uuid’
[17:41:28.390]   - Field: ‘seed’
[17:41:28.390]   - Field: ‘version’
[17:41:28.390]   - Field: ‘result’
[17:41:28.390]   - Field: ‘asynchronous’
[17:41:28.391]   - Field: ‘calls’
[17:41:28.391]   - Field: ‘globals’
[17:41:28.391]   - Field: ‘stdout’
[17:41:28.391]   - Field: ‘earlySignal’
[17:41:28.391]   - Field: ‘lazy’
[17:41:28.391]   - Field: ‘state’
[17:41:28.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.391] - Launch lazy future ...
[17:41:28.391] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.392] Packages needed by future strategies (n = 0): <none>
[17:41:28.392] {
[17:41:28.392]     {
[17:41:28.392]         {
[17:41:28.392]             ...future.startTime <- base::Sys.time()
[17:41:28.392]             {
[17:41:28.392]                 {
[17:41:28.392]                   {
[17:41:28.392]                     {
[17:41:28.392]                       {
[17:41:28.392]                         base::local({
[17:41:28.392]                           has_future <- base::requireNamespace("future", 
[17:41:28.392]                             quietly = TRUE)
[17:41:28.392]                           if (has_future) {
[17:41:28.392]                             ns <- base::getNamespace("future")
[17:41:28.392]                             version <- ns[[".package"]][["version"]]
[17:41:28.392]                             if (is.null(version)) 
[17:41:28.392]                               version <- utils::packageVersion("future")
[17:41:28.392]                           }
[17:41:28.392]                           else {
[17:41:28.392]                             version <- NULL
[17:41:28.392]                           }
[17:41:28.392]                           if (!has_future || version < "1.8.0") {
[17:41:28.392]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.392]                               "", base::R.version$version.string), 
[17:41:28.392]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.392]                                 base::R.version$platform, 8 * 
[17:41:28.392]                                   base::.Machine$sizeof.pointer), 
[17:41:28.392]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.392]                                 "release", "version")], collapse = " "), 
[17:41:28.392]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.392]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.392]                               info)
[17:41:28.392]                             info <- base::paste(info, collapse = "; ")
[17:41:28.392]                             if (!has_future) {
[17:41:28.392]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.392]                                 info)
[17:41:28.392]                             }
[17:41:28.392]                             else {
[17:41:28.392]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.392]                                 info, version)
[17:41:28.392]                             }
[17:41:28.392]                             base::stop(msg)
[17:41:28.392]                           }
[17:41:28.392]                         })
[17:41:28.392]                       }
[17:41:28.392]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.392]                       base::options(mc.cores = 1L)
[17:41:28.392]                     }
[17:41:28.392]                     base::local({
[17:41:28.392]                       for (pkg in "utils") {
[17:41:28.392]                         base::loadNamespace(pkg)
[17:41:28.392]                         base::library(pkg, character.only = TRUE)
[17:41:28.392]                       }
[17:41:28.392]                     })
[17:41:28.392]                   }
[17:41:28.392]                   ...future.strategy.old <- future::plan("list")
[17:41:28.392]                   options(future.plan = NULL)
[17:41:28.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.392]                 }
[17:41:28.392]                 ...future.workdir <- getwd()
[17:41:28.392]             }
[17:41:28.392]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.392]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.392]         }
[17:41:28.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.392]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.392]             base::names(...future.oldOptions))
[17:41:28.392]     }
[17:41:28.392]     if (FALSE) {
[17:41:28.392]     }
[17:41:28.392]     else {
[17:41:28.392]         if (FALSE) {
[17:41:28.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.392]                 open = "w")
[17:41:28.392]         }
[17:41:28.392]         else {
[17:41:28.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.392]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.392]         }
[17:41:28.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.392]             base::sink(type = "output", split = FALSE)
[17:41:28.392]             base::close(...future.stdout)
[17:41:28.392]         }, add = TRUE)
[17:41:28.392]     }
[17:41:28.392]     ...future.frame <- base::sys.nframe()
[17:41:28.392]     ...future.conditions <- base::list()
[17:41:28.392]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.392]     if (FALSE) {
[17:41:28.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.392]     }
[17:41:28.392]     ...future.result <- base::tryCatch({
[17:41:28.392]         base::withCallingHandlers({
[17:41:28.392]             ...future.value <- base::withVisible(base::local({
[17:41:28.392]                 ...future.makeSendCondition <- base::local({
[17:41:28.392]                   sendCondition <- NULL
[17:41:28.392]                   function(frame = 1L) {
[17:41:28.392]                     if (is.function(sendCondition)) 
[17:41:28.392]                       return(sendCondition)
[17:41:28.392]                     ns <- getNamespace("parallel")
[17:41:28.392]                     if (exists("sendData", mode = "function", 
[17:41:28.392]                       envir = ns)) {
[17:41:28.392]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.392]                         envir = ns)
[17:41:28.392]                       envir <- sys.frame(frame)
[17:41:28.392]                       master <- NULL
[17:41:28.392]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.392]                         !identical(envir, emptyenv())) {
[17:41:28.392]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.392]                           inherits = FALSE)) {
[17:41:28.392]                           master <- get("master", mode = "list", 
[17:41:28.392]                             envir = envir, inherits = FALSE)
[17:41:28.392]                           if (inherits(master, c("SOCKnode", 
[17:41:28.392]                             "SOCK0node"))) {
[17:41:28.392]                             sendCondition <<- function(cond) {
[17:41:28.392]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.392]                                 success = TRUE)
[17:41:28.392]                               parallel_sendData(master, data)
[17:41:28.392]                             }
[17:41:28.392]                             return(sendCondition)
[17:41:28.392]                           }
[17:41:28.392]                         }
[17:41:28.392]                         frame <- frame + 1L
[17:41:28.392]                         envir <- sys.frame(frame)
[17:41:28.392]                       }
[17:41:28.392]                     }
[17:41:28.392]                     sendCondition <<- function(cond) NULL
[17:41:28.392]                   }
[17:41:28.392]                 })
[17:41:28.392]                 withCallingHandlers({
[17:41:28.392]                   {
[17:41:28.392]                     print(1:50)
[17:41:28.392]                     str(1:50)
[17:41:28.392]                     cat(letters, sep = "-")
[17:41:28.392]                     cat(1:6, collapse = "\n")
[17:41:28.392]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.392]                     42L
[17:41:28.392]                   }
[17:41:28.392]                 }, immediateCondition = function(cond) {
[17:41:28.392]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.392]                   sendCondition(cond)
[17:41:28.392]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.392]                   {
[17:41:28.392]                     inherits <- base::inherits
[17:41:28.392]                     invokeRestart <- base::invokeRestart
[17:41:28.392]                     is.null <- base::is.null
[17:41:28.392]                     muffled <- FALSE
[17:41:28.392]                     if (inherits(cond, "message")) {
[17:41:28.392]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.392]                       if (muffled) 
[17:41:28.392]                         invokeRestart("muffleMessage")
[17:41:28.392]                     }
[17:41:28.392]                     else if (inherits(cond, "warning")) {
[17:41:28.392]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.392]                       if (muffled) 
[17:41:28.392]                         invokeRestart("muffleWarning")
[17:41:28.392]                     }
[17:41:28.392]                     else if (inherits(cond, "condition")) {
[17:41:28.392]                       if (!is.null(pattern)) {
[17:41:28.392]                         computeRestarts <- base::computeRestarts
[17:41:28.392]                         grepl <- base::grepl
[17:41:28.392]                         restarts <- computeRestarts(cond)
[17:41:28.392]                         for (restart in restarts) {
[17:41:28.392]                           name <- restart$name
[17:41:28.392]                           if (is.null(name)) 
[17:41:28.392]                             next
[17:41:28.392]                           if (!grepl(pattern, name)) 
[17:41:28.392]                             next
[17:41:28.392]                           invokeRestart(restart)
[17:41:28.392]                           muffled <- TRUE
[17:41:28.392]                           break
[17:41:28.392]                         }
[17:41:28.392]                       }
[17:41:28.392]                     }
[17:41:28.392]                     invisible(muffled)
[17:41:28.392]                   }
[17:41:28.392]                   muffleCondition(cond)
[17:41:28.392]                 })
[17:41:28.392]             }))
[17:41:28.392]             future::FutureResult(value = ...future.value$value, 
[17:41:28.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.392]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.392]                     ...future.globalenv.names))
[17:41:28.392]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.392]         }, condition = base::local({
[17:41:28.392]             c <- base::c
[17:41:28.392]             inherits <- base::inherits
[17:41:28.392]             invokeRestart <- base::invokeRestart
[17:41:28.392]             length <- base::length
[17:41:28.392]             list <- base::list
[17:41:28.392]             seq.int <- base::seq.int
[17:41:28.392]             signalCondition <- base::signalCondition
[17:41:28.392]             sys.calls <- base::sys.calls
[17:41:28.392]             `[[` <- base::`[[`
[17:41:28.392]             `+` <- base::`+`
[17:41:28.392]             `<<-` <- base::`<<-`
[17:41:28.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.392]                   3L)]
[17:41:28.392]             }
[17:41:28.392]             function(cond) {
[17:41:28.392]                 is_error <- inherits(cond, "error")
[17:41:28.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.392]                   NULL)
[17:41:28.392]                 if (is_error) {
[17:41:28.392]                   sessionInformation <- function() {
[17:41:28.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.392]                       search = base::search(), system = base::Sys.info())
[17:41:28.392]                   }
[17:41:28.392]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.392]                     cond$call), session = sessionInformation(), 
[17:41:28.392]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.392]                   signalCondition(cond)
[17:41:28.392]                 }
[17:41:28.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.392]                 "immediateCondition"))) {
[17:41:28.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.392]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.392]                   if (TRUE && !signal) {
[17:41:28.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.392]                     {
[17:41:28.392]                       inherits <- base::inherits
[17:41:28.392]                       invokeRestart <- base::invokeRestart
[17:41:28.392]                       is.null <- base::is.null
[17:41:28.392]                       muffled <- FALSE
[17:41:28.392]                       if (inherits(cond, "message")) {
[17:41:28.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.392]                         if (muffled) 
[17:41:28.392]                           invokeRestart("muffleMessage")
[17:41:28.392]                       }
[17:41:28.392]                       else if (inherits(cond, "warning")) {
[17:41:28.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.392]                         if (muffled) 
[17:41:28.392]                           invokeRestart("muffleWarning")
[17:41:28.392]                       }
[17:41:28.392]                       else if (inherits(cond, "condition")) {
[17:41:28.392]                         if (!is.null(pattern)) {
[17:41:28.392]                           computeRestarts <- base::computeRestarts
[17:41:28.392]                           grepl <- base::grepl
[17:41:28.392]                           restarts <- computeRestarts(cond)
[17:41:28.392]                           for (restart in restarts) {
[17:41:28.392]                             name <- restart$name
[17:41:28.392]                             if (is.null(name)) 
[17:41:28.392]                               next
[17:41:28.392]                             if (!grepl(pattern, name)) 
[17:41:28.392]                               next
[17:41:28.392]                             invokeRestart(restart)
[17:41:28.392]                             muffled <- TRUE
[17:41:28.392]                             break
[17:41:28.392]                           }
[17:41:28.392]                         }
[17:41:28.392]                       }
[17:41:28.392]                       invisible(muffled)
[17:41:28.392]                     }
[17:41:28.392]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.392]                   }
[17:41:28.392]                 }
[17:41:28.392]                 else {
[17:41:28.392]                   if (TRUE) {
[17:41:28.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.392]                     {
[17:41:28.392]                       inherits <- base::inherits
[17:41:28.392]                       invokeRestart <- base::invokeRestart
[17:41:28.392]                       is.null <- base::is.null
[17:41:28.392]                       muffled <- FALSE
[17:41:28.392]                       if (inherits(cond, "message")) {
[17:41:28.392]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.392]                         if (muffled) 
[17:41:28.392]                           invokeRestart("muffleMessage")
[17:41:28.392]                       }
[17:41:28.392]                       else if (inherits(cond, "warning")) {
[17:41:28.392]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.392]                         if (muffled) 
[17:41:28.392]                           invokeRestart("muffleWarning")
[17:41:28.392]                       }
[17:41:28.392]                       else if (inherits(cond, "condition")) {
[17:41:28.392]                         if (!is.null(pattern)) {
[17:41:28.392]                           computeRestarts <- base::computeRestarts
[17:41:28.392]                           grepl <- base::grepl
[17:41:28.392]                           restarts <- computeRestarts(cond)
[17:41:28.392]                           for (restart in restarts) {
[17:41:28.392]                             name <- restart$name
[17:41:28.392]                             if (is.null(name)) 
[17:41:28.392]                               next
[17:41:28.392]                             if (!grepl(pattern, name)) 
[17:41:28.392]                               next
[17:41:28.392]                             invokeRestart(restart)
[17:41:28.392]                             muffled <- TRUE
[17:41:28.392]                             break
[17:41:28.392]                           }
[17:41:28.392]                         }
[17:41:28.392]                       }
[17:41:28.392]                       invisible(muffled)
[17:41:28.392]                     }
[17:41:28.392]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.392]                   }
[17:41:28.392]                 }
[17:41:28.392]             }
[17:41:28.392]         }))
[17:41:28.392]     }, error = function(ex) {
[17:41:28.392]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.392]                 ...future.rng), started = ...future.startTime, 
[17:41:28.392]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.392]             version = "1.8"), class = "FutureResult")
[17:41:28.392]     }, finally = {
[17:41:28.392]         if (!identical(...future.workdir, getwd())) 
[17:41:28.392]             setwd(...future.workdir)
[17:41:28.392]         {
[17:41:28.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.392]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.392]             }
[17:41:28.392]             base::options(...future.oldOptions)
[17:41:28.392]             if (.Platform$OS.type == "windows") {
[17:41:28.392]                 old_names <- names(...future.oldEnvVars)
[17:41:28.392]                 envs <- base::Sys.getenv()
[17:41:28.392]                 names <- names(envs)
[17:41:28.392]                 common <- intersect(names, old_names)
[17:41:28.392]                 added <- setdiff(names, old_names)
[17:41:28.392]                 removed <- setdiff(old_names, names)
[17:41:28.392]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.392]                   envs[common]]
[17:41:28.392]                 NAMES <- toupper(changed)
[17:41:28.392]                 args <- list()
[17:41:28.392]                 for (kk in seq_along(NAMES)) {
[17:41:28.392]                   name <- changed[[kk]]
[17:41:28.392]                   NAME <- NAMES[[kk]]
[17:41:28.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.392]                     next
[17:41:28.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.392]                 }
[17:41:28.392]                 NAMES <- toupper(added)
[17:41:28.392]                 for (kk in seq_along(NAMES)) {
[17:41:28.392]                   name <- added[[kk]]
[17:41:28.392]                   NAME <- NAMES[[kk]]
[17:41:28.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.392]                     next
[17:41:28.392]                   args[[name]] <- ""
[17:41:28.392]                 }
[17:41:28.392]                 NAMES <- toupper(removed)
[17:41:28.392]                 for (kk in seq_along(NAMES)) {
[17:41:28.392]                   name <- removed[[kk]]
[17:41:28.392]                   NAME <- NAMES[[kk]]
[17:41:28.392]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.392]                     next
[17:41:28.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.392]                 }
[17:41:28.392]                 if (length(args) > 0) 
[17:41:28.392]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.392]             }
[17:41:28.392]             else {
[17:41:28.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.392]             }
[17:41:28.392]             {
[17:41:28.392]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.392]                   0L) {
[17:41:28.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.392]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.392]                   base::options(opts)
[17:41:28.392]                 }
[17:41:28.392]                 {
[17:41:28.392]                   {
[17:41:28.392]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.392]                     NULL
[17:41:28.392]                   }
[17:41:28.392]                   options(future.plan = NULL)
[17:41:28.392]                   if (is.na(NA_character_)) 
[17:41:28.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.392]                     .init = FALSE)
[17:41:28.392]                 }
[17:41:28.392]             }
[17:41:28.392]         }
[17:41:28.392]     })
[17:41:28.392]     if (TRUE) {
[17:41:28.392]         base::sink(type = "output", split = FALSE)
[17:41:28.392]         if (FALSE) {
[17:41:28.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.392]         }
[17:41:28.392]         else {
[17:41:28.392]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.392]         }
[17:41:28.392]         base::close(...future.stdout)
[17:41:28.392]         ...future.stdout <- NULL
[17:41:28.392]     }
[17:41:28.392]     ...future.result$conditions <- ...future.conditions
[17:41:28.392]     ...future.result$finished <- base::Sys.time()
[17:41:28.392]     ...future.result
[17:41:28.392] }
[17:41:28.395] MultisessionFuture started
[17:41:28.395] - Launch lazy future ... done
[17:41:28.395] run() for ‘MultisessionFuture’ ... done
[17:41:28.396] result() for ClusterFuture ...
[17:41:28.396] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.396] - Validating connection of MultisessionFuture
[17:41:28.439] - received message: FutureResult
[17:41:28.439] - Received FutureResult
[17:41:28.439] - Erased future from FutureRegistry
[17:41:28.439] result() for ClusterFuture ...
[17:41:28.439] - result already collected: FutureResult
[17:41:28.439] result() for ClusterFuture ... done
[17:41:28.440] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.440] result() for ClusterFuture ... done
[17:41:28.440] result() for ClusterFuture ...
[17:41:28.440] - result already collected: FutureResult
[17:41:28.440] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:28.440] getGlobalsAndPackages() ...
[17:41:28.440] Searching for globals...
[17:41:28.441] - globals found: [1] ‘print’
[17:41:28.441] Searching for globals ... DONE
[17:41:28.441] Resolving globals: FALSE
[17:41:28.441] 
[17:41:28.441] 
[17:41:28.441] getGlobalsAndPackages() ... DONE
[17:41:28.442] run() for ‘Future’ ...
[17:41:28.442] - state: ‘created’
[17:41:28.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.456] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.456]   - Field: ‘node’
[17:41:28.456]   - Field: ‘label’
[17:41:28.456]   - Field: ‘local’
[17:41:28.456]   - Field: ‘owner’
[17:41:28.456]   - Field: ‘envir’
[17:41:28.457]   - Field: ‘workers’
[17:41:28.457]   - Field: ‘packages’
[17:41:28.457]   - Field: ‘gc’
[17:41:28.457]   - Field: ‘conditions’
[17:41:28.457]   - Field: ‘persistent’
[17:41:28.457]   - Field: ‘expr’
[17:41:28.457]   - Field: ‘uuid’
[17:41:28.457]   - Field: ‘seed’
[17:41:28.457]   - Field: ‘version’
[17:41:28.457]   - Field: ‘result’
[17:41:28.457]   - Field: ‘asynchronous’
[17:41:28.457]   - Field: ‘calls’
[17:41:28.458]   - Field: ‘globals’
[17:41:28.458]   - Field: ‘stdout’
[17:41:28.458]   - Field: ‘earlySignal’
[17:41:28.458]   - Field: ‘lazy’
[17:41:28.458]   - Field: ‘state’
[17:41:28.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.458] - Launch lazy future ...
[17:41:28.458] Packages needed by the future expression (n = 0): <none>
[17:41:28.458] Packages needed by future strategies (n = 0): <none>
[17:41:28.459] {
[17:41:28.459]     {
[17:41:28.459]         {
[17:41:28.459]             ...future.startTime <- base::Sys.time()
[17:41:28.459]             {
[17:41:28.459]                 {
[17:41:28.459]                   {
[17:41:28.459]                     {
[17:41:28.459]                       base::local({
[17:41:28.459]                         has_future <- base::requireNamespace("future", 
[17:41:28.459]                           quietly = TRUE)
[17:41:28.459]                         if (has_future) {
[17:41:28.459]                           ns <- base::getNamespace("future")
[17:41:28.459]                           version <- ns[[".package"]][["version"]]
[17:41:28.459]                           if (is.null(version)) 
[17:41:28.459]                             version <- utils::packageVersion("future")
[17:41:28.459]                         }
[17:41:28.459]                         else {
[17:41:28.459]                           version <- NULL
[17:41:28.459]                         }
[17:41:28.459]                         if (!has_future || version < "1.8.0") {
[17:41:28.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.459]                             "", base::R.version$version.string), 
[17:41:28.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:28.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:28.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.459]                               "release", "version")], collapse = " "), 
[17:41:28.459]                             hostname = base::Sys.info()[["nodename"]])
[17:41:28.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.459]                             info)
[17:41:28.459]                           info <- base::paste(info, collapse = "; ")
[17:41:28.459]                           if (!has_future) {
[17:41:28.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.459]                               info)
[17:41:28.459]                           }
[17:41:28.459]                           else {
[17:41:28.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.459]                               info, version)
[17:41:28.459]                           }
[17:41:28.459]                           base::stop(msg)
[17:41:28.459]                         }
[17:41:28.459]                       })
[17:41:28.459]                     }
[17:41:28.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.459]                     base::options(mc.cores = 1L)
[17:41:28.459]                   }
[17:41:28.459]                   ...future.strategy.old <- future::plan("list")
[17:41:28.459]                   options(future.plan = NULL)
[17:41:28.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.459]                 }
[17:41:28.459]                 ...future.workdir <- getwd()
[17:41:28.459]             }
[17:41:28.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.459]         }
[17:41:28.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.459]             base::names(...future.oldOptions))
[17:41:28.459]     }
[17:41:28.459]     if (FALSE) {
[17:41:28.459]     }
[17:41:28.459]     else {
[17:41:28.459]         if (TRUE) {
[17:41:28.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.459]                 open = "w")
[17:41:28.459]         }
[17:41:28.459]         else {
[17:41:28.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.459]         }
[17:41:28.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.459]             base::sink(type = "output", split = FALSE)
[17:41:28.459]             base::close(...future.stdout)
[17:41:28.459]         }, add = TRUE)
[17:41:28.459]     }
[17:41:28.459]     ...future.frame <- base::sys.nframe()
[17:41:28.459]     ...future.conditions <- base::list()
[17:41:28.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.459]     if (FALSE) {
[17:41:28.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.459]     }
[17:41:28.459]     ...future.result <- base::tryCatch({
[17:41:28.459]         base::withCallingHandlers({
[17:41:28.459]             ...future.value <- base::withVisible(base::local({
[17:41:28.459]                 ...future.makeSendCondition <- base::local({
[17:41:28.459]                   sendCondition <- NULL
[17:41:28.459]                   function(frame = 1L) {
[17:41:28.459]                     if (is.function(sendCondition)) 
[17:41:28.459]                       return(sendCondition)
[17:41:28.459]                     ns <- getNamespace("parallel")
[17:41:28.459]                     if (exists("sendData", mode = "function", 
[17:41:28.459]                       envir = ns)) {
[17:41:28.459]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.459]                         envir = ns)
[17:41:28.459]                       envir <- sys.frame(frame)
[17:41:28.459]                       master <- NULL
[17:41:28.459]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.459]                         !identical(envir, emptyenv())) {
[17:41:28.459]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.459]                           inherits = FALSE)) {
[17:41:28.459]                           master <- get("master", mode = "list", 
[17:41:28.459]                             envir = envir, inherits = FALSE)
[17:41:28.459]                           if (inherits(master, c("SOCKnode", 
[17:41:28.459]                             "SOCK0node"))) {
[17:41:28.459]                             sendCondition <<- function(cond) {
[17:41:28.459]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.459]                                 success = TRUE)
[17:41:28.459]                               parallel_sendData(master, data)
[17:41:28.459]                             }
[17:41:28.459]                             return(sendCondition)
[17:41:28.459]                           }
[17:41:28.459]                         }
[17:41:28.459]                         frame <- frame + 1L
[17:41:28.459]                         envir <- sys.frame(frame)
[17:41:28.459]                       }
[17:41:28.459]                     }
[17:41:28.459]                     sendCondition <<- function(cond) NULL
[17:41:28.459]                   }
[17:41:28.459]                 })
[17:41:28.459]                 withCallingHandlers({
[17:41:28.459]                   print(42)
[17:41:28.459]                 }, immediateCondition = function(cond) {
[17:41:28.459]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.459]                   sendCondition(cond)
[17:41:28.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.459]                   {
[17:41:28.459]                     inherits <- base::inherits
[17:41:28.459]                     invokeRestart <- base::invokeRestart
[17:41:28.459]                     is.null <- base::is.null
[17:41:28.459]                     muffled <- FALSE
[17:41:28.459]                     if (inherits(cond, "message")) {
[17:41:28.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.459]                       if (muffled) 
[17:41:28.459]                         invokeRestart("muffleMessage")
[17:41:28.459]                     }
[17:41:28.459]                     else if (inherits(cond, "warning")) {
[17:41:28.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.459]                       if (muffled) 
[17:41:28.459]                         invokeRestart("muffleWarning")
[17:41:28.459]                     }
[17:41:28.459]                     else if (inherits(cond, "condition")) {
[17:41:28.459]                       if (!is.null(pattern)) {
[17:41:28.459]                         computeRestarts <- base::computeRestarts
[17:41:28.459]                         grepl <- base::grepl
[17:41:28.459]                         restarts <- computeRestarts(cond)
[17:41:28.459]                         for (restart in restarts) {
[17:41:28.459]                           name <- restart$name
[17:41:28.459]                           if (is.null(name)) 
[17:41:28.459]                             next
[17:41:28.459]                           if (!grepl(pattern, name)) 
[17:41:28.459]                             next
[17:41:28.459]                           invokeRestart(restart)
[17:41:28.459]                           muffled <- TRUE
[17:41:28.459]                           break
[17:41:28.459]                         }
[17:41:28.459]                       }
[17:41:28.459]                     }
[17:41:28.459]                     invisible(muffled)
[17:41:28.459]                   }
[17:41:28.459]                   muffleCondition(cond)
[17:41:28.459]                 })
[17:41:28.459]             }))
[17:41:28.459]             future::FutureResult(value = ...future.value$value, 
[17:41:28.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.459]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.459]                     ...future.globalenv.names))
[17:41:28.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.459]         }, condition = base::local({
[17:41:28.459]             c <- base::c
[17:41:28.459]             inherits <- base::inherits
[17:41:28.459]             invokeRestart <- base::invokeRestart
[17:41:28.459]             length <- base::length
[17:41:28.459]             list <- base::list
[17:41:28.459]             seq.int <- base::seq.int
[17:41:28.459]             signalCondition <- base::signalCondition
[17:41:28.459]             sys.calls <- base::sys.calls
[17:41:28.459]             `[[` <- base::`[[`
[17:41:28.459]             `+` <- base::`+`
[17:41:28.459]             `<<-` <- base::`<<-`
[17:41:28.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.459]                   3L)]
[17:41:28.459]             }
[17:41:28.459]             function(cond) {
[17:41:28.459]                 is_error <- inherits(cond, "error")
[17:41:28.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.459]                   NULL)
[17:41:28.459]                 if (is_error) {
[17:41:28.459]                   sessionInformation <- function() {
[17:41:28.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.459]                       search = base::search(), system = base::Sys.info())
[17:41:28.459]                   }
[17:41:28.459]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.459]                     cond$call), session = sessionInformation(), 
[17:41:28.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.459]                   signalCondition(cond)
[17:41:28.459]                 }
[17:41:28.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.459]                 "immediateCondition"))) {
[17:41:28.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.459]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.459]                   if (TRUE && !signal) {
[17:41:28.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.459]                     {
[17:41:28.459]                       inherits <- base::inherits
[17:41:28.459]                       invokeRestart <- base::invokeRestart
[17:41:28.459]                       is.null <- base::is.null
[17:41:28.459]                       muffled <- FALSE
[17:41:28.459]                       if (inherits(cond, "message")) {
[17:41:28.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.459]                         if (muffled) 
[17:41:28.459]                           invokeRestart("muffleMessage")
[17:41:28.459]                       }
[17:41:28.459]                       else if (inherits(cond, "warning")) {
[17:41:28.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.459]                         if (muffled) 
[17:41:28.459]                           invokeRestart("muffleWarning")
[17:41:28.459]                       }
[17:41:28.459]                       else if (inherits(cond, "condition")) {
[17:41:28.459]                         if (!is.null(pattern)) {
[17:41:28.459]                           computeRestarts <- base::computeRestarts
[17:41:28.459]                           grepl <- base::grepl
[17:41:28.459]                           restarts <- computeRestarts(cond)
[17:41:28.459]                           for (restart in restarts) {
[17:41:28.459]                             name <- restart$name
[17:41:28.459]                             if (is.null(name)) 
[17:41:28.459]                               next
[17:41:28.459]                             if (!grepl(pattern, name)) 
[17:41:28.459]                               next
[17:41:28.459]                             invokeRestart(restart)
[17:41:28.459]                             muffled <- TRUE
[17:41:28.459]                             break
[17:41:28.459]                           }
[17:41:28.459]                         }
[17:41:28.459]                       }
[17:41:28.459]                       invisible(muffled)
[17:41:28.459]                     }
[17:41:28.459]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.459]                   }
[17:41:28.459]                 }
[17:41:28.459]                 else {
[17:41:28.459]                   if (TRUE) {
[17:41:28.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.459]                     {
[17:41:28.459]                       inherits <- base::inherits
[17:41:28.459]                       invokeRestart <- base::invokeRestart
[17:41:28.459]                       is.null <- base::is.null
[17:41:28.459]                       muffled <- FALSE
[17:41:28.459]                       if (inherits(cond, "message")) {
[17:41:28.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.459]                         if (muffled) 
[17:41:28.459]                           invokeRestart("muffleMessage")
[17:41:28.459]                       }
[17:41:28.459]                       else if (inherits(cond, "warning")) {
[17:41:28.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.459]                         if (muffled) 
[17:41:28.459]                           invokeRestart("muffleWarning")
[17:41:28.459]                       }
[17:41:28.459]                       else if (inherits(cond, "condition")) {
[17:41:28.459]                         if (!is.null(pattern)) {
[17:41:28.459]                           computeRestarts <- base::computeRestarts
[17:41:28.459]                           grepl <- base::grepl
[17:41:28.459]                           restarts <- computeRestarts(cond)
[17:41:28.459]                           for (restart in restarts) {
[17:41:28.459]                             name <- restart$name
[17:41:28.459]                             if (is.null(name)) 
[17:41:28.459]                               next
[17:41:28.459]                             if (!grepl(pattern, name)) 
[17:41:28.459]                               next
[17:41:28.459]                             invokeRestart(restart)
[17:41:28.459]                             muffled <- TRUE
[17:41:28.459]                             break
[17:41:28.459]                           }
[17:41:28.459]                         }
[17:41:28.459]                       }
[17:41:28.459]                       invisible(muffled)
[17:41:28.459]                     }
[17:41:28.459]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.459]                   }
[17:41:28.459]                 }
[17:41:28.459]             }
[17:41:28.459]         }))
[17:41:28.459]     }, error = function(ex) {
[17:41:28.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.459]                 ...future.rng), started = ...future.startTime, 
[17:41:28.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.459]             version = "1.8"), class = "FutureResult")
[17:41:28.459]     }, finally = {
[17:41:28.459]         if (!identical(...future.workdir, getwd())) 
[17:41:28.459]             setwd(...future.workdir)
[17:41:28.459]         {
[17:41:28.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.459]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.459]             }
[17:41:28.459]             base::options(...future.oldOptions)
[17:41:28.459]             if (.Platform$OS.type == "windows") {
[17:41:28.459]                 old_names <- names(...future.oldEnvVars)
[17:41:28.459]                 envs <- base::Sys.getenv()
[17:41:28.459]                 names <- names(envs)
[17:41:28.459]                 common <- intersect(names, old_names)
[17:41:28.459]                 added <- setdiff(names, old_names)
[17:41:28.459]                 removed <- setdiff(old_names, names)
[17:41:28.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.459]                   envs[common]]
[17:41:28.459]                 NAMES <- toupper(changed)
[17:41:28.459]                 args <- list()
[17:41:28.459]                 for (kk in seq_along(NAMES)) {
[17:41:28.459]                   name <- changed[[kk]]
[17:41:28.459]                   NAME <- NAMES[[kk]]
[17:41:28.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.459]                     next
[17:41:28.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.459]                 }
[17:41:28.459]                 NAMES <- toupper(added)
[17:41:28.459]                 for (kk in seq_along(NAMES)) {
[17:41:28.459]                   name <- added[[kk]]
[17:41:28.459]                   NAME <- NAMES[[kk]]
[17:41:28.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.459]                     next
[17:41:28.459]                   args[[name]] <- ""
[17:41:28.459]                 }
[17:41:28.459]                 NAMES <- toupper(removed)
[17:41:28.459]                 for (kk in seq_along(NAMES)) {
[17:41:28.459]                   name <- removed[[kk]]
[17:41:28.459]                   NAME <- NAMES[[kk]]
[17:41:28.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.459]                     next
[17:41:28.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.459]                 }
[17:41:28.459]                 if (length(args) > 0) 
[17:41:28.459]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.459]             }
[17:41:28.459]             else {
[17:41:28.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.459]             }
[17:41:28.459]             {
[17:41:28.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.459]                   0L) {
[17:41:28.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.459]                   base::options(opts)
[17:41:28.459]                 }
[17:41:28.459]                 {
[17:41:28.459]                   {
[17:41:28.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.459]                     NULL
[17:41:28.459]                   }
[17:41:28.459]                   options(future.plan = NULL)
[17:41:28.459]                   if (is.na(NA_character_)) 
[17:41:28.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.459]                     .init = FALSE)
[17:41:28.459]                 }
[17:41:28.459]             }
[17:41:28.459]         }
[17:41:28.459]     })
[17:41:28.459]     if (TRUE) {
[17:41:28.459]         base::sink(type = "output", split = FALSE)
[17:41:28.459]         if (TRUE) {
[17:41:28.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.459]         }
[17:41:28.459]         else {
[17:41:28.459]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.459]         }
[17:41:28.459]         base::close(...future.stdout)
[17:41:28.459]         ...future.stdout <- NULL
[17:41:28.459]     }
[17:41:28.459]     ...future.result$conditions <- ...future.conditions
[17:41:28.459]     ...future.result$finished <- base::Sys.time()
[17:41:28.459]     ...future.result
[17:41:28.459] }
[17:41:28.462] MultisessionFuture started
[17:41:28.462] - Launch lazy future ... done
[17:41:28.462] run() for ‘MultisessionFuture’ ... done
[17:41:28.462] result() for ClusterFuture ...
[17:41:28.462] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.462] - Validating connection of MultisessionFuture
[17:41:28.463] - received message: FutureResult
[17:41:28.463] - Received FutureResult
[17:41:28.464] - Erased future from FutureRegistry
[17:41:28.464] result() for ClusterFuture ...
[17:41:28.464] - result already collected: FutureResult
[17:41:28.464] result() for ClusterFuture ... done
[17:41:28.464] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.464] result() for ClusterFuture ... done
[17:41:28.464] result() for ClusterFuture ...
[17:41:28.464] - result already collected: FutureResult
[17:41:28.464] result() for ClusterFuture ... done
[17:41:28.464] result() for ClusterFuture ...
[17:41:28.464] - result already collected: FutureResult
[17:41:28.464] result() for ClusterFuture ... done
[1] 42
[17:41:28.465] result() for ClusterFuture ...
[17:41:28.465] - result already collected: FutureResult
[17:41:28.465] result() for ClusterFuture ... done
- stdout = NA
[17:41:28.465] getGlobalsAndPackages() ...
[17:41:28.465] Searching for globals...
[17:41:28.468] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.468] Searching for globals ... DONE
[17:41:28.468] Resolving globals: FALSE
[17:41:28.469] 
[17:41:28.469] - packages: [1] ‘utils’
[17:41:28.469] getGlobalsAndPackages() ... DONE
[17:41:28.469] run() for ‘Future’ ...
[17:41:28.469] - state: ‘created’
[17:41:28.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.483] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.483]   - Field: ‘node’
[17:41:28.483]   - Field: ‘label’
[17:41:28.484]   - Field: ‘local’
[17:41:28.484]   - Field: ‘owner’
[17:41:28.484]   - Field: ‘envir’
[17:41:28.484]   - Field: ‘workers’
[17:41:28.484]   - Field: ‘packages’
[17:41:28.484]   - Field: ‘gc’
[17:41:28.484]   - Field: ‘conditions’
[17:41:28.484]   - Field: ‘persistent’
[17:41:28.484]   - Field: ‘expr’
[17:41:28.484]   - Field: ‘uuid’
[17:41:28.484]   - Field: ‘seed’
[17:41:28.485]   - Field: ‘version’
[17:41:28.485]   - Field: ‘result’
[17:41:28.485]   - Field: ‘asynchronous’
[17:41:28.485]   - Field: ‘calls’
[17:41:28.485]   - Field: ‘globals’
[17:41:28.485]   - Field: ‘stdout’
[17:41:28.485]   - Field: ‘earlySignal’
[17:41:28.485]   - Field: ‘lazy’
[17:41:28.485]   - Field: ‘state’
[17:41:28.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.485] - Launch lazy future ...
[17:41:28.488] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.488] Packages needed by future strategies (n = 0): <none>
[17:41:28.488] {
[17:41:28.488]     {
[17:41:28.488]         {
[17:41:28.488]             ...future.startTime <- base::Sys.time()
[17:41:28.488]             {
[17:41:28.488]                 {
[17:41:28.488]                   {
[17:41:28.488]                     {
[17:41:28.488]                       {
[17:41:28.488]                         base::local({
[17:41:28.488]                           has_future <- base::requireNamespace("future", 
[17:41:28.488]                             quietly = TRUE)
[17:41:28.488]                           if (has_future) {
[17:41:28.488]                             ns <- base::getNamespace("future")
[17:41:28.488]                             version <- ns[[".package"]][["version"]]
[17:41:28.488]                             if (is.null(version)) 
[17:41:28.488]                               version <- utils::packageVersion("future")
[17:41:28.488]                           }
[17:41:28.488]                           else {
[17:41:28.488]                             version <- NULL
[17:41:28.488]                           }
[17:41:28.488]                           if (!has_future || version < "1.8.0") {
[17:41:28.488]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.488]                               "", base::R.version$version.string), 
[17:41:28.488]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.488]                                 base::R.version$platform, 8 * 
[17:41:28.488]                                   base::.Machine$sizeof.pointer), 
[17:41:28.488]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.488]                                 "release", "version")], collapse = " "), 
[17:41:28.488]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.488]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.488]                               info)
[17:41:28.488]                             info <- base::paste(info, collapse = "; ")
[17:41:28.488]                             if (!has_future) {
[17:41:28.488]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.488]                                 info)
[17:41:28.488]                             }
[17:41:28.488]                             else {
[17:41:28.488]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.488]                                 info, version)
[17:41:28.488]                             }
[17:41:28.488]                             base::stop(msg)
[17:41:28.488]                           }
[17:41:28.488]                         })
[17:41:28.488]                       }
[17:41:28.488]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.488]                       base::options(mc.cores = 1L)
[17:41:28.488]                     }
[17:41:28.488]                     base::local({
[17:41:28.488]                       for (pkg in "utils") {
[17:41:28.488]                         base::loadNamespace(pkg)
[17:41:28.488]                         base::library(pkg, character.only = TRUE)
[17:41:28.488]                       }
[17:41:28.488]                     })
[17:41:28.488]                   }
[17:41:28.488]                   ...future.strategy.old <- future::plan("list")
[17:41:28.488]                   options(future.plan = NULL)
[17:41:28.488]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.488]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.488]                 }
[17:41:28.488]                 ...future.workdir <- getwd()
[17:41:28.488]             }
[17:41:28.488]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.488]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.488]         }
[17:41:28.488]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.488]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.488]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.488]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.488]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.488]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.488]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.488]             base::names(...future.oldOptions))
[17:41:28.488]     }
[17:41:28.488]     if (TRUE) {
[17:41:28.488]     }
[17:41:28.488]     else {
[17:41:28.488]         if (NA) {
[17:41:28.488]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.488]                 open = "w")
[17:41:28.488]         }
[17:41:28.488]         else {
[17:41:28.488]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.488]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.488]         }
[17:41:28.488]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.488]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.488]             base::sink(type = "output", split = FALSE)
[17:41:28.488]             base::close(...future.stdout)
[17:41:28.488]         }, add = TRUE)
[17:41:28.488]     }
[17:41:28.488]     ...future.frame <- base::sys.nframe()
[17:41:28.488]     ...future.conditions <- base::list()
[17:41:28.488]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.488]     if (FALSE) {
[17:41:28.488]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.488]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.488]     }
[17:41:28.488]     ...future.result <- base::tryCatch({
[17:41:28.488]         base::withCallingHandlers({
[17:41:28.488]             ...future.value <- base::withVisible(base::local({
[17:41:28.488]                 ...future.makeSendCondition <- base::local({
[17:41:28.488]                   sendCondition <- NULL
[17:41:28.488]                   function(frame = 1L) {
[17:41:28.488]                     if (is.function(sendCondition)) 
[17:41:28.488]                       return(sendCondition)
[17:41:28.488]                     ns <- getNamespace("parallel")
[17:41:28.488]                     if (exists("sendData", mode = "function", 
[17:41:28.488]                       envir = ns)) {
[17:41:28.488]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.488]                         envir = ns)
[17:41:28.488]                       envir <- sys.frame(frame)
[17:41:28.488]                       master <- NULL
[17:41:28.488]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.488]                         !identical(envir, emptyenv())) {
[17:41:28.488]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.488]                           inherits = FALSE)) {
[17:41:28.488]                           master <- get("master", mode = "list", 
[17:41:28.488]                             envir = envir, inherits = FALSE)
[17:41:28.488]                           if (inherits(master, c("SOCKnode", 
[17:41:28.488]                             "SOCK0node"))) {
[17:41:28.488]                             sendCondition <<- function(cond) {
[17:41:28.488]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.488]                                 success = TRUE)
[17:41:28.488]                               parallel_sendData(master, data)
[17:41:28.488]                             }
[17:41:28.488]                             return(sendCondition)
[17:41:28.488]                           }
[17:41:28.488]                         }
[17:41:28.488]                         frame <- frame + 1L
[17:41:28.488]                         envir <- sys.frame(frame)
[17:41:28.488]                       }
[17:41:28.488]                     }
[17:41:28.488]                     sendCondition <<- function(cond) NULL
[17:41:28.488]                   }
[17:41:28.488]                 })
[17:41:28.488]                 withCallingHandlers({
[17:41:28.488]                   {
[17:41:28.488]                     print(1:50)
[17:41:28.488]                     str(1:50)
[17:41:28.488]                     cat(letters, sep = "-")
[17:41:28.488]                     cat(1:6, collapse = "\n")
[17:41:28.488]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.488]                     42L
[17:41:28.488]                   }
[17:41:28.488]                 }, immediateCondition = function(cond) {
[17:41:28.488]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.488]                   sendCondition(cond)
[17:41:28.488]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.488]                   {
[17:41:28.488]                     inherits <- base::inherits
[17:41:28.488]                     invokeRestart <- base::invokeRestart
[17:41:28.488]                     is.null <- base::is.null
[17:41:28.488]                     muffled <- FALSE
[17:41:28.488]                     if (inherits(cond, "message")) {
[17:41:28.488]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.488]                       if (muffled) 
[17:41:28.488]                         invokeRestart("muffleMessage")
[17:41:28.488]                     }
[17:41:28.488]                     else if (inherits(cond, "warning")) {
[17:41:28.488]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.488]                       if (muffled) 
[17:41:28.488]                         invokeRestart("muffleWarning")
[17:41:28.488]                     }
[17:41:28.488]                     else if (inherits(cond, "condition")) {
[17:41:28.488]                       if (!is.null(pattern)) {
[17:41:28.488]                         computeRestarts <- base::computeRestarts
[17:41:28.488]                         grepl <- base::grepl
[17:41:28.488]                         restarts <- computeRestarts(cond)
[17:41:28.488]                         for (restart in restarts) {
[17:41:28.488]                           name <- restart$name
[17:41:28.488]                           if (is.null(name)) 
[17:41:28.488]                             next
[17:41:28.488]                           if (!grepl(pattern, name)) 
[17:41:28.488]                             next
[17:41:28.488]                           invokeRestart(restart)
[17:41:28.488]                           muffled <- TRUE
[17:41:28.488]                           break
[17:41:28.488]                         }
[17:41:28.488]                       }
[17:41:28.488]                     }
[17:41:28.488]                     invisible(muffled)
[17:41:28.488]                   }
[17:41:28.488]                   muffleCondition(cond)
[17:41:28.488]                 })
[17:41:28.488]             }))
[17:41:28.488]             future::FutureResult(value = ...future.value$value, 
[17:41:28.488]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.488]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.488]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.488]                     ...future.globalenv.names))
[17:41:28.488]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.488]         }, condition = base::local({
[17:41:28.488]             c <- base::c
[17:41:28.488]             inherits <- base::inherits
[17:41:28.488]             invokeRestart <- base::invokeRestart
[17:41:28.488]             length <- base::length
[17:41:28.488]             list <- base::list
[17:41:28.488]             seq.int <- base::seq.int
[17:41:28.488]             signalCondition <- base::signalCondition
[17:41:28.488]             sys.calls <- base::sys.calls
[17:41:28.488]             `[[` <- base::`[[`
[17:41:28.488]             `+` <- base::`+`
[17:41:28.488]             `<<-` <- base::`<<-`
[17:41:28.488]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.488]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.488]                   3L)]
[17:41:28.488]             }
[17:41:28.488]             function(cond) {
[17:41:28.488]                 is_error <- inherits(cond, "error")
[17:41:28.488]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.488]                   NULL)
[17:41:28.488]                 if (is_error) {
[17:41:28.488]                   sessionInformation <- function() {
[17:41:28.488]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.488]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.488]                       search = base::search(), system = base::Sys.info())
[17:41:28.488]                   }
[17:41:28.488]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.488]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.488]                     cond$call), session = sessionInformation(), 
[17:41:28.488]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.488]                   signalCondition(cond)
[17:41:28.488]                 }
[17:41:28.488]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.488]                 "immediateCondition"))) {
[17:41:28.488]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.488]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.488]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.488]                   if (TRUE && !signal) {
[17:41:28.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.488]                     {
[17:41:28.488]                       inherits <- base::inherits
[17:41:28.488]                       invokeRestart <- base::invokeRestart
[17:41:28.488]                       is.null <- base::is.null
[17:41:28.488]                       muffled <- FALSE
[17:41:28.488]                       if (inherits(cond, "message")) {
[17:41:28.488]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.488]                         if (muffled) 
[17:41:28.488]                           invokeRestart("muffleMessage")
[17:41:28.488]                       }
[17:41:28.488]                       else if (inherits(cond, "warning")) {
[17:41:28.488]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.488]                         if (muffled) 
[17:41:28.488]                           invokeRestart("muffleWarning")
[17:41:28.488]                       }
[17:41:28.488]                       else if (inherits(cond, "condition")) {
[17:41:28.488]                         if (!is.null(pattern)) {
[17:41:28.488]                           computeRestarts <- base::computeRestarts
[17:41:28.488]                           grepl <- base::grepl
[17:41:28.488]                           restarts <- computeRestarts(cond)
[17:41:28.488]                           for (restart in restarts) {
[17:41:28.488]                             name <- restart$name
[17:41:28.488]                             if (is.null(name)) 
[17:41:28.488]                               next
[17:41:28.488]                             if (!grepl(pattern, name)) 
[17:41:28.488]                               next
[17:41:28.488]                             invokeRestart(restart)
[17:41:28.488]                             muffled <- TRUE
[17:41:28.488]                             break
[17:41:28.488]                           }
[17:41:28.488]                         }
[17:41:28.488]                       }
[17:41:28.488]                       invisible(muffled)
[17:41:28.488]                     }
[17:41:28.488]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.488]                   }
[17:41:28.488]                 }
[17:41:28.488]                 else {
[17:41:28.488]                   if (TRUE) {
[17:41:28.488]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.488]                     {
[17:41:28.488]                       inherits <- base::inherits
[17:41:28.488]                       invokeRestart <- base::invokeRestart
[17:41:28.488]                       is.null <- base::is.null
[17:41:28.488]                       muffled <- FALSE
[17:41:28.488]                       if (inherits(cond, "message")) {
[17:41:28.488]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.488]                         if (muffled) 
[17:41:28.488]                           invokeRestart("muffleMessage")
[17:41:28.488]                       }
[17:41:28.488]                       else if (inherits(cond, "warning")) {
[17:41:28.488]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.488]                         if (muffled) 
[17:41:28.488]                           invokeRestart("muffleWarning")
[17:41:28.488]                       }
[17:41:28.488]                       else if (inherits(cond, "condition")) {
[17:41:28.488]                         if (!is.null(pattern)) {
[17:41:28.488]                           computeRestarts <- base::computeRestarts
[17:41:28.488]                           grepl <- base::grepl
[17:41:28.488]                           restarts <- computeRestarts(cond)
[17:41:28.488]                           for (restart in restarts) {
[17:41:28.488]                             name <- restart$name
[17:41:28.488]                             if (is.null(name)) 
[17:41:28.488]                               next
[17:41:28.488]                             if (!grepl(pattern, name)) 
[17:41:28.488]                               next
[17:41:28.488]                             invokeRestart(restart)
[17:41:28.488]                             muffled <- TRUE
[17:41:28.488]                             break
[17:41:28.488]                           }
[17:41:28.488]                         }
[17:41:28.488]                       }
[17:41:28.488]                       invisible(muffled)
[17:41:28.488]                     }
[17:41:28.488]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.488]                   }
[17:41:28.488]                 }
[17:41:28.488]             }
[17:41:28.488]         }))
[17:41:28.488]     }, error = function(ex) {
[17:41:28.488]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.488]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.488]                 ...future.rng), started = ...future.startTime, 
[17:41:28.488]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.488]             version = "1.8"), class = "FutureResult")
[17:41:28.488]     }, finally = {
[17:41:28.488]         if (!identical(...future.workdir, getwd())) 
[17:41:28.488]             setwd(...future.workdir)
[17:41:28.488]         {
[17:41:28.488]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.488]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.488]             }
[17:41:28.488]             base::options(...future.oldOptions)
[17:41:28.488]             if (.Platform$OS.type == "windows") {
[17:41:28.488]                 old_names <- names(...future.oldEnvVars)
[17:41:28.488]                 envs <- base::Sys.getenv()
[17:41:28.488]                 names <- names(envs)
[17:41:28.488]                 common <- intersect(names, old_names)
[17:41:28.488]                 added <- setdiff(names, old_names)
[17:41:28.488]                 removed <- setdiff(old_names, names)
[17:41:28.488]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.488]                   envs[common]]
[17:41:28.488]                 NAMES <- toupper(changed)
[17:41:28.488]                 args <- list()
[17:41:28.488]                 for (kk in seq_along(NAMES)) {
[17:41:28.488]                   name <- changed[[kk]]
[17:41:28.488]                   NAME <- NAMES[[kk]]
[17:41:28.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.488]                     next
[17:41:28.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.488]                 }
[17:41:28.488]                 NAMES <- toupper(added)
[17:41:28.488]                 for (kk in seq_along(NAMES)) {
[17:41:28.488]                   name <- added[[kk]]
[17:41:28.488]                   NAME <- NAMES[[kk]]
[17:41:28.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.488]                     next
[17:41:28.488]                   args[[name]] <- ""
[17:41:28.488]                 }
[17:41:28.488]                 NAMES <- toupper(removed)
[17:41:28.488]                 for (kk in seq_along(NAMES)) {
[17:41:28.488]                   name <- removed[[kk]]
[17:41:28.488]                   NAME <- NAMES[[kk]]
[17:41:28.488]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.488]                     next
[17:41:28.488]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.488]                 }
[17:41:28.488]                 if (length(args) > 0) 
[17:41:28.488]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.488]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.488]             }
[17:41:28.488]             else {
[17:41:28.488]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.488]             }
[17:41:28.488]             {
[17:41:28.488]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.488]                   0L) {
[17:41:28.488]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.488]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.488]                   base::options(opts)
[17:41:28.488]                 }
[17:41:28.488]                 {
[17:41:28.488]                   {
[17:41:28.488]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.488]                     NULL
[17:41:28.488]                   }
[17:41:28.488]                   options(future.plan = NULL)
[17:41:28.488]                   if (is.na(NA_character_)) 
[17:41:28.488]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.488]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.488]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.488]                     .init = FALSE)
[17:41:28.488]                 }
[17:41:28.488]             }
[17:41:28.488]         }
[17:41:28.488]     })
[17:41:28.488]     if (FALSE) {
[17:41:28.488]         base::sink(type = "output", split = FALSE)
[17:41:28.488]         if (NA) {
[17:41:28.488]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.488]         }
[17:41:28.488]         else {
[17:41:28.488]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.488]         }
[17:41:28.488]         base::close(...future.stdout)
[17:41:28.488]         ...future.stdout <- NULL
[17:41:28.488]     }
[17:41:28.488]     ...future.result$conditions <- ...future.conditions
[17:41:28.488]     ...future.result$finished <- base::Sys.time()
[17:41:28.488]     ...future.result
[17:41:28.488] }
[17:41:28.491] MultisessionFuture started
[17:41:28.491] - Launch lazy future ... done
[17:41:28.492] run() for ‘MultisessionFuture’ ... done
[17:41:28.492] result() for ClusterFuture ...
[17:41:28.492] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.492] - Validating connection of MultisessionFuture
[17:41:28.535] - received message: FutureResult
[17:41:28.535] - Received FutureResult
[17:41:28.535] - Erased future from FutureRegistry
[17:41:28.535] result() for ClusterFuture ...
[17:41:28.535] - result already collected: FutureResult
[17:41:28.535] result() for ClusterFuture ... done
[17:41:28.535] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.535] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ finished    : POSIXct[1:1], format: "2024-12-19 17:41:28"
 $ session_uuid: chr "4bd769f8-55a2-fda7-a5cb-25f0d1d11ef5"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "3fe59e189152"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "3fe59e189152" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 50533
  .. ..$ time  : POSIXct[1:1], format: "2024-12-19 17:41:28"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 0
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[17:41:28.543] result() for ClusterFuture ...
[17:41:28.543] - result already collected: FutureResult
[17:41:28.543] result() for ClusterFuture ... done
[17:41:28.543] result() for ClusterFuture ...
[17:41:28.543] - result already collected: FutureResult
[17:41:28.543] result() for ClusterFuture ... done
[17:41:28.543] getGlobalsAndPackages() ...
[17:41:28.544] Searching for globals...
[17:41:28.546] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[17:41:28.546] Searching for globals ... DONE
[17:41:28.547] Resolving globals: FALSE
[17:41:28.547] 
[17:41:28.547] - packages: [1] ‘utils’
[17:41:28.547] getGlobalsAndPackages() ... DONE
[17:41:28.547] run() for ‘Future’ ...
[17:41:28.548] - state: ‘created’
[17:41:28.548] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.561] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.562]   - Field: ‘node’
[17:41:28.562]   - Field: ‘label’
[17:41:28.562]   - Field: ‘local’
[17:41:28.562]   - Field: ‘owner’
[17:41:28.562]   - Field: ‘envir’
[17:41:28.562]   - Field: ‘workers’
[17:41:28.562]   - Field: ‘packages’
[17:41:28.562]   - Field: ‘gc’
[17:41:28.562]   - Field: ‘conditions’
[17:41:28.562]   - Field: ‘persistent’
[17:41:28.563]   - Field: ‘expr’
[17:41:28.563]   - Field: ‘uuid’
[17:41:28.563]   - Field: ‘seed’
[17:41:28.563]   - Field: ‘version’
[17:41:28.563]   - Field: ‘result’
[17:41:28.563]   - Field: ‘asynchronous’
[17:41:28.563]   - Field: ‘calls’
[17:41:28.563]   - Field: ‘globals’
[17:41:28.563]   - Field: ‘stdout’
[17:41:28.563]   - Field: ‘earlySignal’
[17:41:28.563]   - Field: ‘lazy’
[17:41:28.564]   - Field: ‘state’
[17:41:28.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.564] - Launch lazy future ...
[17:41:28.564] Packages needed by the future expression (n = 1): ‘utils’
[17:41:28.564] Packages needed by future strategies (n = 0): <none>
[17:41:28.565] {
[17:41:28.565]     {
[17:41:28.565]         {
[17:41:28.565]             ...future.startTime <- base::Sys.time()
[17:41:28.565]             {
[17:41:28.565]                 {
[17:41:28.565]                   {
[17:41:28.565]                     {
[17:41:28.565]                       {
[17:41:28.565]                         base::local({
[17:41:28.565]                           has_future <- base::requireNamespace("future", 
[17:41:28.565]                             quietly = TRUE)
[17:41:28.565]                           if (has_future) {
[17:41:28.565]                             ns <- base::getNamespace("future")
[17:41:28.565]                             version <- ns[[".package"]][["version"]]
[17:41:28.565]                             if (is.null(version)) 
[17:41:28.565]                               version <- utils::packageVersion("future")
[17:41:28.565]                           }
[17:41:28.565]                           else {
[17:41:28.565]                             version <- NULL
[17:41:28.565]                           }
[17:41:28.565]                           if (!has_future || version < "1.8.0") {
[17:41:28.565]                             info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.565]                               "", base::R.version$version.string), 
[17:41:28.565]                               platform = base::sprintf("%s (%s-bit)", 
[17:41:28.565]                                 base::R.version$platform, 8 * 
[17:41:28.565]                                   base::.Machine$sizeof.pointer), 
[17:41:28.565]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.565]                                 "release", "version")], collapse = " "), 
[17:41:28.565]                               hostname = base::Sys.info()[["nodename"]])
[17:41:28.565]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.565]                               info)
[17:41:28.565]                             info <- base::paste(info, collapse = "; ")
[17:41:28.565]                             if (!has_future) {
[17:41:28.565]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.565]                                 info)
[17:41:28.565]                             }
[17:41:28.565]                             else {
[17:41:28.565]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.565]                                 info, version)
[17:41:28.565]                             }
[17:41:28.565]                             base::stop(msg)
[17:41:28.565]                           }
[17:41:28.565]                         })
[17:41:28.565]                       }
[17:41:28.565]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.565]                       base::options(mc.cores = 1L)
[17:41:28.565]                     }
[17:41:28.565]                     base::local({
[17:41:28.565]                       for (pkg in "utils") {
[17:41:28.565]                         base::loadNamespace(pkg)
[17:41:28.565]                         base::library(pkg, character.only = TRUE)
[17:41:28.565]                       }
[17:41:28.565]                     })
[17:41:28.565]                   }
[17:41:28.565]                   ...future.strategy.old <- future::plan("list")
[17:41:28.565]                   options(future.plan = NULL)
[17:41:28.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.565]                 }
[17:41:28.565]                 ...future.workdir <- getwd()
[17:41:28.565]             }
[17:41:28.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.565]         }
[17:41:28.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.565]             base::names(...future.oldOptions))
[17:41:28.565]     }
[17:41:28.565]     if (TRUE) {
[17:41:28.565]     }
[17:41:28.565]     else {
[17:41:28.565]         if (NA) {
[17:41:28.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.565]                 open = "w")
[17:41:28.565]         }
[17:41:28.565]         else {
[17:41:28.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.565]         }
[17:41:28.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.565]             base::sink(type = "output", split = FALSE)
[17:41:28.565]             base::close(...future.stdout)
[17:41:28.565]         }, add = TRUE)
[17:41:28.565]     }
[17:41:28.565]     ...future.frame <- base::sys.nframe()
[17:41:28.565]     ...future.conditions <- base::list()
[17:41:28.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.565]     if (FALSE) {
[17:41:28.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.565]     }
[17:41:28.565]     ...future.result <- base::tryCatch({
[17:41:28.565]         base::withCallingHandlers({
[17:41:28.565]             ...future.value <- base::withVisible(base::local({
[17:41:28.565]                 ...future.makeSendCondition <- base::local({
[17:41:28.565]                   sendCondition <- NULL
[17:41:28.565]                   function(frame = 1L) {
[17:41:28.565]                     if (is.function(sendCondition)) 
[17:41:28.565]                       return(sendCondition)
[17:41:28.565]                     ns <- getNamespace("parallel")
[17:41:28.565]                     if (exists("sendData", mode = "function", 
[17:41:28.565]                       envir = ns)) {
[17:41:28.565]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.565]                         envir = ns)
[17:41:28.565]                       envir <- sys.frame(frame)
[17:41:28.565]                       master <- NULL
[17:41:28.565]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.565]                         !identical(envir, emptyenv())) {
[17:41:28.565]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.565]                           inherits = FALSE)) {
[17:41:28.565]                           master <- get("master", mode = "list", 
[17:41:28.565]                             envir = envir, inherits = FALSE)
[17:41:28.565]                           if (inherits(master, c("SOCKnode", 
[17:41:28.565]                             "SOCK0node"))) {
[17:41:28.565]                             sendCondition <<- function(cond) {
[17:41:28.565]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.565]                                 success = TRUE)
[17:41:28.565]                               parallel_sendData(master, data)
[17:41:28.565]                             }
[17:41:28.565]                             return(sendCondition)
[17:41:28.565]                           }
[17:41:28.565]                         }
[17:41:28.565]                         frame <- frame + 1L
[17:41:28.565]                         envir <- sys.frame(frame)
[17:41:28.565]                       }
[17:41:28.565]                     }
[17:41:28.565]                     sendCondition <<- function(cond) NULL
[17:41:28.565]                   }
[17:41:28.565]                 })
[17:41:28.565]                 withCallingHandlers({
[17:41:28.565]                   {
[17:41:28.565]                     print(1:50)
[17:41:28.565]                     str(1:50)
[17:41:28.565]                     cat(letters, sep = "-")
[17:41:28.565]                     cat(1:6, collapse = "\n")
[17:41:28.565]                     write.table(datasets::iris[1:10, ], sep = "\t")
[17:41:28.565]                     42L
[17:41:28.565]                   }
[17:41:28.565]                 }, immediateCondition = function(cond) {
[17:41:28.565]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.565]                   sendCondition(cond)
[17:41:28.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.565]                   {
[17:41:28.565]                     inherits <- base::inherits
[17:41:28.565]                     invokeRestart <- base::invokeRestart
[17:41:28.565]                     is.null <- base::is.null
[17:41:28.565]                     muffled <- FALSE
[17:41:28.565]                     if (inherits(cond, "message")) {
[17:41:28.565]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.565]                       if (muffled) 
[17:41:28.565]                         invokeRestart("muffleMessage")
[17:41:28.565]                     }
[17:41:28.565]                     else if (inherits(cond, "warning")) {
[17:41:28.565]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.565]                       if (muffled) 
[17:41:28.565]                         invokeRestart("muffleWarning")
[17:41:28.565]                     }
[17:41:28.565]                     else if (inherits(cond, "condition")) {
[17:41:28.565]                       if (!is.null(pattern)) {
[17:41:28.565]                         computeRestarts <- base::computeRestarts
[17:41:28.565]                         grepl <- base::grepl
[17:41:28.565]                         restarts <- computeRestarts(cond)
[17:41:28.565]                         for (restart in restarts) {
[17:41:28.565]                           name <- restart$name
[17:41:28.565]                           if (is.null(name)) 
[17:41:28.565]                             next
[17:41:28.565]                           if (!grepl(pattern, name)) 
[17:41:28.565]                             next
[17:41:28.565]                           invokeRestart(restart)
[17:41:28.565]                           muffled <- TRUE
[17:41:28.565]                           break
[17:41:28.565]                         }
[17:41:28.565]                       }
[17:41:28.565]                     }
[17:41:28.565]                     invisible(muffled)
[17:41:28.565]                   }
[17:41:28.565]                   muffleCondition(cond)
[17:41:28.565]                 })
[17:41:28.565]             }))
[17:41:28.565]             future::FutureResult(value = ...future.value$value, 
[17:41:28.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.565]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.565]                     ...future.globalenv.names))
[17:41:28.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.565]         }, condition = base::local({
[17:41:28.565]             c <- base::c
[17:41:28.565]             inherits <- base::inherits
[17:41:28.565]             invokeRestart <- base::invokeRestart
[17:41:28.565]             length <- base::length
[17:41:28.565]             list <- base::list
[17:41:28.565]             seq.int <- base::seq.int
[17:41:28.565]             signalCondition <- base::signalCondition
[17:41:28.565]             sys.calls <- base::sys.calls
[17:41:28.565]             `[[` <- base::`[[`
[17:41:28.565]             `+` <- base::`+`
[17:41:28.565]             `<<-` <- base::`<<-`
[17:41:28.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.565]                   3L)]
[17:41:28.565]             }
[17:41:28.565]             function(cond) {
[17:41:28.565]                 is_error <- inherits(cond, "error")
[17:41:28.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.565]                   NULL)
[17:41:28.565]                 if (is_error) {
[17:41:28.565]                   sessionInformation <- function() {
[17:41:28.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.565]                       search = base::search(), system = base::Sys.info())
[17:41:28.565]                   }
[17:41:28.565]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.565]                     cond$call), session = sessionInformation(), 
[17:41:28.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.565]                   signalCondition(cond)
[17:41:28.565]                 }
[17:41:28.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.565]                 "immediateCondition"))) {
[17:41:28.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.565]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.565]                   if (TRUE && !signal) {
[17:41:28.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.565]                     {
[17:41:28.565]                       inherits <- base::inherits
[17:41:28.565]                       invokeRestart <- base::invokeRestart
[17:41:28.565]                       is.null <- base::is.null
[17:41:28.565]                       muffled <- FALSE
[17:41:28.565]                       if (inherits(cond, "message")) {
[17:41:28.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.565]                         if (muffled) 
[17:41:28.565]                           invokeRestart("muffleMessage")
[17:41:28.565]                       }
[17:41:28.565]                       else if (inherits(cond, "warning")) {
[17:41:28.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.565]                         if (muffled) 
[17:41:28.565]                           invokeRestart("muffleWarning")
[17:41:28.565]                       }
[17:41:28.565]                       else if (inherits(cond, "condition")) {
[17:41:28.565]                         if (!is.null(pattern)) {
[17:41:28.565]                           computeRestarts <- base::computeRestarts
[17:41:28.565]                           grepl <- base::grepl
[17:41:28.565]                           restarts <- computeRestarts(cond)
[17:41:28.565]                           for (restart in restarts) {
[17:41:28.565]                             name <- restart$name
[17:41:28.565]                             if (is.null(name)) 
[17:41:28.565]                               next
[17:41:28.565]                             if (!grepl(pattern, name)) 
[17:41:28.565]                               next
[17:41:28.565]                             invokeRestart(restart)
[17:41:28.565]                             muffled <- TRUE
[17:41:28.565]                             break
[17:41:28.565]                           }
[17:41:28.565]                         }
[17:41:28.565]                       }
[17:41:28.565]                       invisible(muffled)
[17:41:28.565]                     }
[17:41:28.565]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.565]                   }
[17:41:28.565]                 }
[17:41:28.565]                 else {
[17:41:28.565]                   if (TRUE) {
[17:41:28.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.565]                     {
[17:41:28.565]                       inherits <- base::inherits
[17:41:28.565]                       invokeRestart <- base::invokeRestart
[17:41:28.565]                       is.null <- base::is.null
[17:41:28.565]                       muffled <- FALSE
[17:41:28.565]                       if (inherits(cond, "message")) {
[17:41:28.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.565]                         if (muffled) 
[17:41:28.565]                           invokeRestart("muffleMessage")
[17:41:28.565]                       }
[17:41:28.565]                       else if (inherits(cond, "warning")) {
[17:41:28.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.565]                         if (muffled) 
[17:41:28.565]                           invokeRestart("muffleWarning")
[17:41:28.565]                       }
[17:41:28.565]                       else if (inherits(cond, "condition")) {
[17:41:28.565]                         if (!is.null(pattern)) {
[17:41:28.565]                           computeRestarts <- base::computeRestarts
[17:41:28.565]                           grepl <- base::grepl
[17:41:28.565]                           restarts <- computeRestarts(cond)
[17:41:28.565]                           for (restart in restarts) {
[17:41:28.565]                             name <- restart$name
[17:41:28.565]                             if (is.null(name)) 
[17:41:28.565]                               next
[17:41:28.565]                             if (!grepl(pattern, name)) 
[17:41:28.565]                               next
[17:41:28.565]                             invokeRestart(restart)
[17:41:28.565]                             muffled <- TRUE
[17:41:28.565]                             break
[17:41:28.565]                           }
[17:41:28.565]                         }
[17:41:28.565]                       }
[17:41:28.565]                       invisible(muffled)
[17:41:28.565]                     }
[17:41:28.565]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.565]                   }
[17:41:28.565]                 }
[17:41:28.565]             }
[17:41:28.565]         }))
[17:41:28.565]     }, error = function(ex) {
[17:41:28.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.565]                 ...future.rng), started = ...future.startTime, 
[17:41:28.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.565]             version = "1.8"), class = "FutureResult")
[17:41:28.565]     }, finally = {
[17:41:28.565]         if (!identical(...future.workdir, getwd())) 
[17:41:28.565]             setwd(...future.workdir)
[17:41:28.565]         {
[17:41:28.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.565]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.565]             }
[17:41:28.565]             base::options(...future.oldOptions)
[17:41:28.565]             if (.Platform$OS.type == "windows") {
[17:41:28.565]                 old_names <- names(...future.oldEnvVars)
[17:41:28.565]                 envs <- base::Sys.getenv()
[17:41:28.565]                 names <- names(envs)
[17:41:28.565]                 common <- intersect(names, old_names)
[17:41:28.565]                 added <- setdiff(names, old_names)
[17:41:28.565]                 removed <- setdiff(old_names, names)
[17:41:28.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.565]                   envs[common]]
[17:41:28.565]                 NAMES <- toupper(changed)
[17:41:28.565]                 args <- list()
[17:41:28.565]                 for (kk in seq_along(NAMES)) {
[17:41:28.565]                   name <- changed[[kk]]
[17:41:28.565]                   NAME <- NAMES[[kk]]
[17:41:28.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.565]                     next
[17:41:28.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.565]                 }
[17:41:28.565]                 NAMES <- toupper(added)
[17:41:28.565]                 for (kk in seq_along(NAMES)) {
[17:41:28.565]                   name <- added[[kk]]
[17:41:28.565]                   NAME <- NAMES[[kk]]
[17:41:28.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.565]                     next
[17:41:28.565]                   args[[name]] <- ""
[17:41:28.565]                 }
[17:41:28.565]                 NAMES <- toupper(removed)
[17:41:28.565]                 for (kk in seq_along(NAMES)) {
[17:41:28.565]                   name <- removed[[kk]]
[17:41:28.565]                   NAME <- NAMES[[kk]]
[17:41:28.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.565]                     next
[17:41:28.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.565]                 }
[17:41:28.565]                 if (length(args) > 0) 
[17:41:28.565]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.565]             }
[17:41:28.565]             else {
[17:41:28.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.565]             }
[17:41:28.565]             {
[17:41:28.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.565]                   0L) {
[17:41:28.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.565]                   base::options(opts)
[17:41:28.565]                 }
[17:41:28.565]                 {
[17:41:28.565]                   {
[17:41:28.565]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.565]                     NULL
[17:41:28.565]                   }
[17:41:28.565]                   options(future.plan = NULL)
[17:41:28.565]                   if (is.na(NA_character_)) 
[17:41:28.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.565]                     .init = FALSE)
[17:41:28.565]                 }
[17:41:28.565]             }
[17:41:28.565]         }
[17:41:28.565]     })
[17:41:28.565]     if (FALSE) {
[17:41:28.565]         base::sink(type = "output", split = FALSE)
[17:41:28.565]         if (NA) {
[17:41:28.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.565]         }
[17:41:28.565]         else {
[17:41:28.565]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.565]         }
[17:41:28.565]         base::close(...future.stdout)
[17:41:28.565]         ...future.stdout <- NULL
[17:41:28.565]     }
[17:41:28.565]     ...future.result$conditions <- ...future.conditions
[17:41:28.565]     ...future.result$finished <- base::Sys.time()
[17:41:28.565]     ...future.result
[17:41:28.565] }
[17:41:28.568] MultisessionFuture started
[17:41:28.568] - Launch lazy future ... done
[17:41:28.568] run() for ‘MultisessionFuture’ ... done
[17:41:28.568] result() for ClusterFuture ...
[17:41:28.568] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.568] - Validating connection of MultisessionFuture
[17:41:28.611] - received message: FutureResult
[17:41:28.611] - Received FutureResult
[17:41:28.611] - Erased future from FutureRegistry
[17:41:28.611] result() for ClusterFuture ...
[17:41:28.611] - result already collected: FutureResult
[17:41:28.611] result() for ClusterFuture ... done
[17:41:28.611] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.611] result() for ClusterFuture ... done
[17:41:28.612] result() for ClusterFuture ...
[17:41:28.612] - result already collected: FutureResult
[17:41:28.612] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[17:41:28.612] getGlobalsAndPackages() ...
[17:41:28.612] Searching for globals...
[17:41:28.613] - globals found: [1] ‘print’
[17:41:28.613] Searching for globals ... DONE
[17:41:28.613] Resolving globals: FALSE
[17:41:28.613] 
[17:41:28.613] 
[17:41:28.613] getGlobalsAndPackages() ... DONE
[17:41:28.613] run() for ‘Future’ ...
[17:41:28.613] - state: ‘created’
[17:41:28.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:28.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:28.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:28.629]   - Field: ‘node’
[17:41:28.629]   - Field: ‘label’
[17:41:28.629]   - Field: ‘local’
[17:41:28.629]   - Field: ‘owner’
[17:41:28.629]   - Field: ‘envir’
[17:41:28.629]   - Field: ‘workers’
[17:41:28.629]   - Field: ‘packages’
[17:41:28.629]   - Field: ‘gc’
[17:41:28.630]   - Field: ‘conditions’
[17:41:28.630]   - Field: ‘persistent’
[17:41:28.630]   - Field: ‘expr’
[17:41:28.630]   - Field: ‘uuid’
[17:41:28.630]   - Field: ‘seed’
[17:41:28.630]   - Field: ‘version’
[17:41:28.630]   - Field: ‘result’
[17:41:28.630]   - Field: ‘asynchronous’
[17:41:28.630]   - Field: ‘calls’
[17:41:28.630]   - Field: ‘globals’
[17:41:28.630]   - Field: ‘stdout’
[17:41:28.631]   - Field: ‘earlySignal’
[17:41:28.631]   - Field: ‘lazy’
[17:41:28.631]   - Field: ‘state’
[17:41:28.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:28.631] - Launch lazy future ...
[17:41:28.631] Packages needed by the future expression (n = 0): <none>
[17:41:28.631] Packages needed by future strategies (n = 0): <none>
[17:41:28.632] {
[17:41:28.632]     {
[17:41:28.632]         {
[17:41:28.632]             ...future.startTime <- base::Sys.time()
[17:41:28.632]             {
[17:41:28.632]                 {
[17:41:28.632]                   {
[17:41:28.632]                     {
[17:41:28.632]                       base::local({
[17:41:28.632]                         has_future <- base::requireNamespace("future", 
[17:41:28.632]                           quietly = TRUE)
[17:41:28.632]                         if (has_future) {
[17:41:28.632]                           ns <- base::getNamespace("future")
[17:41:28.632]                           version <- ns[[".package"]][["version"]]
[17:41:28.632]                           if (is.null(version)) 
[17:41:28.632]                             version <- utils::packageVersion("future")
[17:41:28.632]                         }
[17:41:28.632]                         else {
[17:41:28.632]                           version <- NULL
[17:41:28.632]                         }
[17:41:28.632]                         if (!has_future || version < "1.8.0") {
[17:41:28.632]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:28.632]                             "", base::R.version$version.string), 
[17:41:28.632]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:28.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:28.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:28.632]                               "release", "version")], collapse = " "), 
[17:41:28.632]                             hostname = base::Sys.info()[["nodename"]])
[17:41:28.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:28.632]                             info)
[17:41:28.632]                           info <- base::paste(info, collapse = "; ")
[17:41:28.632]                           if (!has_future) {
[17:41:28.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:28.632]                               info)
[17:41:28.632]                           }
[17:41:28.632]                           else {
[17:41:28.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:28.632]                               info, version)
[17:41:28.632]                           }
[17:41:28.632]                           base::stop(msg)
[17:41:28.632]                         }
[17:41:28.632]                       })
[17:41:28.632]                     }
[17:41:28.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:28.632]                     base::options(mc.cores = 1L)
[17:41:28.632]                   }
[17:41:28.632]                   ...future.strategy.old <- future::plan("list")
[17:41:28.632]                   options(future.plan = NULL)
[17:41:28.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:28.632]                 }
[17:41:28.632]                 ...future.workdir <- getwd()
[17:41:28.632]             }
[17:41:28.632]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:28.632]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:28.632]         }
[17:41:28.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:28.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:28.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:28.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:28.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:28.632]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:28.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:28.632]             base::names(...future.oldOptions))
[17:41:28.632]     }
[17:41:28.632]     if (FALSE) {
[17:41:28.632]     }
[17:41:28.632]     else {
[17:41:28.632]         if (TRUE) {
[17:41:28.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:28.632]                 open = "w")
[17:41:28.632]         }
[17:41:28.632]         else {
[17:41:28.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:28.632]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:28.632]         }
[17:41:28.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:28.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:28.632]             base::sink(type = "output", split = FALSE)
[17:41:28.632]             base::close(...future.stdout)
[17:41:28.632]         }, add = TRUE)
[17:41:28.632]     }
[17:41:28.632]     ...future.frame <- base::sys.nframe()
[17:41:28.632]     ...future.conditions <- base::list()
[17:41:28.632]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:28.632]     if (FALSE) {
[17:41:28.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:28.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:28.632]     }
[17:41:28.632]     ...future.result <- base::tryCatch({
[17:41:28.632]         base::withCallingHandlers({
[17:41:28.632]             ...future.value <- base::withVisible(base::local({
[17:41:28.632]                 ...future.makeSendCondition <- base::local({
[17:41:28.632]                   sendCondition <- NULL
[17:41:28.632]                   function(frame = 1L) {
[17:41:28.632]                     if (is.function(sendCondition)) 
[17:41:28.632]                       return(sendCondition)
[17:41:28.632]                     ns <- getNamespace("parallel")
[17:41:28.632]                     if (exists("sendData", mode = "function", 
[17:41:28.632]                       envir = ns)) {
[17:41:28.632]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:28.632]                         envir = ns)
[17:41:28.632]                       envir <- sys.frame(frame)
[17:41:28.632]                       master <- NULL
[17:41:28.632]                       while (!identical(envir, .GlobalEnv) && 
[17:41:28.632]                         !identical(envir, emptyenv())) {
[17:41:28.632]                         if (exists("master", mode = "list", envir = envir, 
[17:41:28.632]                           inherits = FALSE)) {
[17:41:28.632]                           master <- get("master", mode = "list", 
[17:41:28.632]                             envir = envir, inherits = FALSE)
[17:41:28.632]                           if (inherits(master, c("SOCKnode", 
[17:41:28.632]                             "SOCK0node"))) {
[17:41:28.632]                             sendCondition <<- function(cond) {
[17:41:28.632]                               data <- list(type = "VALUE", value = cond, 
[17:41:28.632]                                 success = TRUE)
[17:41:28.632]                               parallel_sendData(master, data)
[17:41:28.632]                             }
[17:41:28.632]                             return(sendCondition)
[17:41:28.632]                           }
[17:41:28.632]                         }
[17:41:28.632]                         frame <- frame + 1L
[17:41:28.632]                         envir <- sys.frame(frame)
[17:41:28.632]                       }
[17:41:28.632]                     }
[17:41:28.632]                     sendCondition <<- function(cond) NULL
[17:41:28.632]                   }
[17:41:28.632]                 })
[17:41:28.632]                 withCallingHandlers({
[17:41:28.632]                   print(42)
[17:41:28.632]                 }, immediateCondition = function(cond) {
[17:41:28.632]                   sendCondition <- ...future.makeSendCondition()
[17:41:28.632]                   sendCondition(cond)
[17:41:28.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.632]                   {
[17:41:28.632]                     inherits <- base::inherits
[17:41:28.632]                     invokeRestart <- base::invokeRestart
[17:41:28.632]                     is.null <- base::is.null
[17:41:28.632]                     muffled <- FALSE
[17:41:28.632]                     if (inherits(cond, "message")) {
[17:41:28.632]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:28.632]                       if (muffled) 
[17:41:28.632]                         invokeRestart("muffleMessage")
[17:41:28.632]                     }
[17:41:28.632]                     else if (inherits(cond, "warning")) {
[17:41:28.632]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:28.632]                       if (muffled) 
[17:41:28.632]                         invokeRestart("muffleWarning")
[17:41:28.632]                     }
[17:41:28.632]                     else if (inherits(cond, "condition")) {
[17:41:28.632]                       if (!is.null(pattern)) {
[17:41:28.632]                         computeRestarts <- base::computeRestarts
[17:41:28.632]                         grepl <- base::grepl
[17:41:28.632]                         restarts <- computeRestarts(cond)
[17:41:28.632]                         for (restart in restarts) {
[17:41:28.632]                           name <- restart$name
[17:41:28.632]                           if (is.null(name)) 
[17:41:28.632]                             next
[17:41:28.632]                           if (!grepl(pattern, name)) 
[17:41:28.632]                             next
[17:41:28.632]                           invokeRestart(restart)
[17:41:28.632]                           muffled <- TRUE
[17:41:28.632]                           break
[17:41:28.632]                         }
[17:41:28.632]                       }
[17:41:28.632]                     }
[17:41:28.632]                     invisible(muffled)
[17:41:28.632]                   }
[17:41:28.632]                   muffleCondition(cond)
[17:41:28.632]                 })
[17:41:28.632]             }))
[17:41:28.632]             future::FutureResult(value = ...future.value$value, 
[17:41:28.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.632]                   ...future.rng), globalenv = if (FALSE) 
[17:41:28.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:28.632]                     ...future.globalenv.names))
[17:41:28.632]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:28.632]         }, condition = base::local({
[17:41:28.632]             c <- base::c
[17:41:28.632]             inherits <- base::inherits
[17:41:28.632]             invokeRestart <- base::invokeRestart
[17:41:28.632]             length <- base::length
[17:41:28.632]             list <- base::list
[17:41:28.632]             seq.int <- base::seq.int
[17:41:28.632]             signalCondition <- base::signalCondition
[17:41:28.632]             sys.calls <- base::sys.calls
[17:41:28.632]             `[[` <- base::`[[`
[17:41:28.632]             `+` <- base::`+`
[17:41:28.632]             `<<-` <- base::`<<-`
[17:41:28.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:28.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:28.632]                   3L)]
[17:41:28.632]             }
[17:41:28.632]             function(cond) {
[17:41:28.632]                 is_error <- inherits(cond, "error")
[17:41:28.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:28.632]                   NULL)
[17:41:28.632]                 if (is_error) {
[17:41:28.632]                   sessionInformation <- function() {
[17:41:28.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:28.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:28.632]                       search = base::search(), system = base::Sys.info())
[17:41:28.632]                   }
[17:41:28.632]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:28.632]                     cond$call), session = sessionInformation(), 
[17:41:28.632]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:28.632]                   signalCondition(cond)
[17:41:28.632]                 }
[17:41:28.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:28.632]                 "immediateCondition"))) {
[17:41:28.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:28.632]                   ...future.conditions[[length(...future.conditions) + 
[17:41:28.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:28.632]                   if (TRUE && !signal) {
[17:41:28.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.632]                     {
[17:41:28.632]                       inherits <- base::inherits
[17:41:28.632]                       invokeRestart <- base::invokeRestart
[17:41:28.632]                       is.null <- base::is.null
[17:41:28.632]                       muffled <- FALSE
[17:41:28.632]                       if (inherits(cond, "message")) {
[17:41:28.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.632]                         if (muffled) 
[17:41:28.632]                           invokeRestart("muffleMessage")
[17:41:28.632]                       }
[17:41:28.632]                       else if (inherits(cond, "warning")) {
[17:41:28.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.632]                         if (muffled) 
[17:41:28.632]                           invokeRestart("muffleWarning")
[17:41:28.632]                       }
[17:41:28.632]                       else if (inherits(cond, "condition")) {
[17:41:28.632]                         if (!is.null(pattern)) {
[17:41:28.632]                           computeRestarts <- base::computeRestarts
[17:41:28.632]                           grepl <- base::grepl
[17:41:28.632]                           restarts <- computeRestarts(cond)
[17:41:28.632]                           for (restart in restarts) {
[17:41:28.632]                             name <- restart$name
[17:41:28.632]                             if (is.null(name)) 
[17:41:28.632]                               next
[17:41:28.632]                             if (!grepl(pattern, name)) 
[17:41:28.632]                               next
[17:41:28.632]                             invokeRestart(restart)
[17:41:28.632]                             muffled <- TRUE
[17:41:28.632]                             break
[17:41:28.632]                           }
[17:41:28.632]                         }
[17:41:28.632]                       }
[17:41:28.632]                       invisible(muffled)
[17:41:28.632]                     }
[17:41:28.632]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.632]                   }
[17:41:28.632]                 }
[17:41:28.632]                 else {
[17:41:28.632]                   if (TRUE) {
[17:41:28.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:28.632]                     {
[17:41:28.632]                       inherits <- base::inherits
[17:41:28.632]                       invokeRestart <- base::invokeRestart
[17:41:28.632]                       is.null <- base::is.null
[17:41:28.632]                       muffled <- FALSE
[17:41:28.632]                       if (inherits(cond, "message")) {
[17:41:28.632]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:28.632]                         if (muffled) 
[17:41:28.632]                           invokeRestart("muffleMessage")
[17:41:28.632]                       }
[17:41:28.632]                       else if (inherits(cond, "warning")) {
[17:41:28.632]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:28.632]                         if (muffled) 
[17:41:28.632]                           invokeRestart("muffleWarning")
[17:41:28.632]                       }
[17:41:28.632]                       else if (inherits(cond, "condition")) {
[17:41:28.632]                         if (!is.null(pattern)) {
[17:41:28.632]                           computeRestarts <- base::computeRestarts
[17:41:28.632]                           grepl <- base::grepl
[17:41:28.632]                           restarts <- computeRestarts(cond)
[17:41:28.632]                           for (restart in restarts) {
[17:41:28.632]                             name <- restart$name
[17:41:28.632]                             if (is.null(name)) 
[17:41:28.632]                               next
[17:41:28.632]                             if (!grepl(pattern, name)) 
[17:41:28.632]                               next
[17:41:28.632]                             invokeRestart(restart)
[17:41:28.632]                             muffled <- TRUE
[17:41:28.632]                             break
[17:41:28.632]                           }
[17:41:28.632]                         }
[17:41:28.632]                       }
[17:41:28.632]                       invisible(muffled)
[17:41:28.632]                     }
[17:41:28.632]                     muffleCondition(cond, pattern = "^muffle")
[17:41:28.632]                   }
[17:41:28.632]                 }
[17:41:28.632]             }
[17:41:28.632]         }))
[17:41:28.632]     }, error = function(ex) {
[17:41:28.632]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:28.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:28.632]                 ...future.rng), started = ...future.startTime, 
[17:41:28.632]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:28.632]             version = "1.8"), class = "FutureResult")
[17:41:28.632]     }, finally = {
[17:41:28.632]         if (!identical(...future.workdir, getwd())) 
[17:41:28.632]             setwd(...future.workdir)
[17:41:28.632]         {
[17:41:28.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:28.632]                 ...future.oldOptions$nwarnings <- NULL
[17:41:28.632]             }
[17:41:28.632]             base::options(...future.oldOptions)
[17:41:28.632]             if (.Platform$OS.type == "windows") {
[17:41:28.632]                 old_names <- names(...future.oldEnvVars)
[17:41:28.632]                 envs <- base::Sys.getenv()
[17:41:28.632]                 names <- names(envs)
[17:41:28.632]                 common <- intersect(names, old_names)
[17:41:28.632]                 added <- setdiff(names, old_names)
[17:41:28.632]                 removed <- setdiff(old_names, names)
[17:41:28.632]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:28.632]                   envs[common]]
[17:41:28.632]                 NAMES <- toupper(changed)
[17:41:28.632]                 args <- list()
[17:41:28.632]                 for (kk in seq_along(NAMES)) {
[17:41:28.632]                   name <- changed[[kk]]
[17:41:28.632]                   NAME <- NAMES[[kk]]
[17:41:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.632]                     next
[17:41:28.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.632]                 }
[17:41:28.632]                 NAMES <- toupper(added)
[17:41:28.632]                 for (kk in seq_along(NAMES)) {
[17:41:28.632]                   name <- added[[kk]]
[17:41:28.632]                   NAME <- NAMES[[kk]]
[17:41:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.632]                     next
[17:41:28.632]                   args[[name]] <- ""
[17:41:28.632]                 }
[17:41:28.632]                 NAMES <- toupper(removed)
[17:41:28.632]                 for (kk in seq_along(NAMES)) {
[17:41:28.632]                   name <- removed[[kk]]
[17:41:28.632]                   NAME <- NAMES[[kk]]
[17:41:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:28.632]                     next
[17:41:28.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:28.632]                 }
[17:41:28.632]                 if (length(args) > 0) 
[17:41:28.632]                   base::do.call(base::Sys.setenv, args = args)
[17:41:28.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:28.632]             }
[17:41:28.632]             else {
[17:41:28.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:28.632]             }
[17:41:28.632]             {
[17:41:28.632]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:28.632]                   0L) {
[17:41:28.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:28.632]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:28.632]                   base::options(opts)
[17:41:28.632]                 }
[17:41:28.632]                 {
[17:41:28.632]                   {
[17:41:28.632]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:28.632]                     NULL
[17:41:28.632]                   }
[17:41:28.632]                   options(future.plan = NULL)
[17:41:28.632]                   if (is.na(NA_character_)) 
[17:41:28.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:28.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:28.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:28.632]                     .init = FALSE)
[17:41:28.632]                 }
[17:41:28.632]             }
[17:41:28.632]         }
[17:41:28.632]     })
[17:41:28.632]     if (TRUE) {
[17:41:28.632]         base::sink(type = "output", split = FALSE)
[17:41:28.632]         if (TRUE) {
[17:41:28.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:28.632]         }
[17:41:28.632]         else {
[17:41:28.632]             ...future.result["stdout"] <- base::list(NULL)
[17:41:28.632]         }
[17:41:28.632]         base::close(...future.stdout)
[17:41:28.632]         ...future.stdout <- NULL
[17:41:28.632]     }
[17:41:28.632]     ...future.result$conditions <- ...future.conditions
[17:41:28.632]     ...future.result$finished <- base::Sys.time()
[17:41:28.632]     ...future.result
[17:41:28.632] }
[17:41:28.634] MultisessionFuture started
[17:41:28.635] - Launch lazy future ... done
[17:41:28.635] run() for ‘MultisessionFuture’ ... done
[17:41:28.635] result() for ClusterFuture ...
[17:41:28.635] receiveMessageFromWorker() for ClusterFuture ...
[17:41:28.635] - Validating connection of MultisessionFuture
[17:41:28.636] - received message: FutureResult
[17:41:28.636] - Received FutureResult
[17:41:28.637] - Erased future from FutureRegistry
[17:41:28.637] result() for ClusterFuture ...
[17:41:28.637] - result already collected: FutureResult
[17:41:28.637] result() for ClusterFuture ... done
[17:41:28.637] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:28.637] result() for ClusterFuture ... done
[17:41:28.637] result() for ClusterFuture ...
[17:41:28.637] - result already collected: FutureResult
[17:41:28.637] result() for ClusterFuture ... done
[17:41:28.637] result() for ClusterFuture ...
[17:41:28.637] - result already collected: FutureResult
[17:41:28.638] result() for ClusterFuture ... done
[1] 42
[17:41:28.638] result() for ClusterFuture ...
[17:41:28.638] - result already collected: FutureResult
[17:41:28.638] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[17:41:28.639] plan(): Setting new future strategy stack:
[17:41:28.639] List of future strategies:
[17:41:28.639] 1. FutureStrategy:
[17:41:28.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:28.639]    - tweaked: FALSE
[17:41:28.639]    - call: future::plan(oplan)
[17:41:28.639] plan(): nbrOfWorkers() = 1
> 
