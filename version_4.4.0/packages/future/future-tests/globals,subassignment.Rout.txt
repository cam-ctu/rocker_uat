
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:28.739] plan(): Setting new future strategy stack:
[09:31:28.740] List of future strategies:
[09:31:28.740] 1. sequential:
[09:31:28.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.740]    - tweaked: FALSE
[09:31:28.740]    - call: future::plan("sequential")
[09:31:28.751] plan(): nbrOfWorkers() = 1
> 
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Globals - subassignments ...")
*** Globals - subassignments ...
> 
> message("*** Globals - subassignments w/ x$a <- value ...")
*** Globals - subassignments w/ x$a <- value ...
> 
> ## Truth:
> x <- x0 <- list()
> y0 <- list(a = 1)
> str(list(x = x, y0 = y0))
List of 2
 $ x : list()
 $ y0:List of 1
  ..$ a: num 1
> 
> y <- local({
+   x$a <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x[["a"]] <- 1
+   x
+ })
> stopifnot(identical(y, y0))
> 
> y <- local({
+   x["a"] <- list(1)
+   x
+ })
> stopifnot(identical(y, y0))
> 
> stopifnot(identical(x, list()))
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x$a <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Same with forced lazy evaluation
+     x <- list()
+     y %<-% {
+       x$a <- 1
+       x
+     } %lazy% TRUE
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## 'x' is _not_ a global variable here
+     x <- list()
+     y %<-% {
+       x <- list(b = 2)
+       x$a <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, list(b = 2, a = 1)))
+ 
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x[["a"]] <- 1
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x[["a"]] <- 1
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+     
+     ## Explicit future
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     })
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Explicit future (lazy)
+     x <- list()
+     f <- future({
+       x["a"] <- list(1)
+       x
+     }, lazy = TRUE)
+     rm(list = "x")
+     y <- value(f)
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     y %<-% {
+       x["a"] <- list(1)
+       x
+     }
+     rm(list = "x")
+     print(y)
+     stopifnot(identical(y, y0))
+ 
+     ## Future assignment
+     x <- list()
+     name <- "a"
+     y %<-% {
+       x[name] <- list(1)
+       x
+     }
+     rm(list = c("x", "name"))
+     print(y)
+     stopifnot(identical(y, y0))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- plan('sequential') ...
[09:31:28.817] plan(): Setting new future strategy stack:
[09:31:28.817] List of future strategies:
[09:31:28.817] 1. sequential:
[09:31:28.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.817]    - tweaked: FALSE
[09:31:28.817]    - call: plan(strategy)
[09:31:28.829] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.830] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.830] Searching for globals...
[09:31:28.838] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.838] Searching for globals ... DONE
[09:31:28.838] Resolving globals: TRUE
[09:31:28.838] Resolving any globals that are futures ...
[09:31:28.838] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.838] Resolving any globals that are futures ... DONE
[09:31:28.839] Resolving futures part of globals (recursively) ...
[09:31:28.839] resolve() on list ...
[09:31:28.839]  recursive: 99
[09:31:28.840]  length: 1
[09:31:28.840]  elements: ‘x’
[09:31:28.840]  length: 0 (resolved future 1)
[09:31:28.840] resolve() on list ... DONE
[09:31:28.840] - globals: [1] ‘x’
[09:31:28.840] Resolving futures part of globals (recursively) ... DONE
[09:31:28.841] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.841] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.841] - globals: [1] ‘x’
[09:31:28.841] 
[09:31:28.841] getGlobalsAndPackages() ... DONE
[09:31:28.842] run() for ‘Future’ ...
[09:31:28.842] - state: ‘created’
[09:31:28.842] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.843] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.843]   - Field: ‘label’
[09:31:28.843]   - Field: ‘local’
[09:31:28.843]   - Field: ‘owner’
[09:31:28.843]   - Field: ‘envir’
[09:31:28.843]   - Field: ‘packages’
[09:31:28.843]   - Field: ‘gc’
[09:31:28.843]   - Field: ‘conditions’
[09:31:28.843]   - Field: ‘expr’
[09:31:28.844]   - Field: ‘uuid’
[09:31:28.844]   - Field: ‘seed’
[09:31:28.844]   - Field: ‘version’
[09:31:28.844]   - Field: ‘result’
[09:31:28.844]   - Field: ‘asynchronous’
[09:31:28.844]   - Field: ‘calls’
[09:31:28.844]   - Field: ‘globals’
[09:31:28.844]   - Field: ‘stdout’
[09:31:28.844]   - Field: ‘earlySignal’
[09:31:28.844]   - Field: ‘lazy’
[09:31:28.844]   - Field: ‘state’
[09:31:28.845] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.845] - Launch lazy future ...
[09:31:28.845] Packages needed by the future expression (n = 0): <none>
[09:31:28.845] Packages needed by future strategies (n = 0): <none>
[09:31:28.846] {
[09:31:28.846]     {
[09:31:28.846]         {
[09:31:28.846]             ...future.startTime <- base::Sys.time()
[09:31:28.846]             {
[09:31:28.846]                 {
[09:31:28.846]                   {
[09:31:28.846]                     base::local({
[09:31:28.846]                       has_future <- base::requireNamespace("future", 
[09:31:28.846]                         quietly = TRUE)
[09:31:28.846]                       if (has_future) {
[09:31:28.846]                         ns <- base::getNamespace("future")
[09:31:28.846]                         version <- ns[[".package"]][["version"]]
[09:31:28.846]                         if (is.null(version)) 
[09:31:28.846]                           version <- utils::packageVersion("future")
[09:31:28.846]                       }
[09:31:28.846]                       else {
[09:31:28.846]                         version <- NULL
[09:31:28.846]                       }
[09:31:28.846]                       if (!has_future || version < "1.8.0") {
[09:31:28.846]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.846]                           "", base::R.version$version.string), 
[09:31:28.846]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.846]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.846]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.846]                             "release", "version")], collapse = " "), 
[09:31:28.846]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.846]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.846]                           info)
[09:31:28.846]                         info <- base::paste(info, collapse = "; ")
[09:31:28.846]                         if (!has_future) {
[09:31:28.846]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.846]                             info)
[09:31:28.846]                         }
[09:31:28.846]                         else {
[09:31:28.846]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.846]                             info, version)
[09:31:28.846]                         }
[09:31:28.846]                         base::stop(msg)
[09:31:28.846]                       }
[09:31:28.846]                     })
[09:31:28.846]                   }
[09:31:28.846]                   ...future.strategy.old <- future::plan("list")
[09:31:28.846]                   options(future.plan = NULL)
[09:31:28.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.846]                 }
[09:31:28.846]                 ...future.workdir <- getwd()
[09:31:28.846]             }
[09:31:28.846]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.846]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.846]         }
[09:31:28.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.846]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.846]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.846]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.846]             base::names(...future.oldOptions))
[09:31:28.846]     }
[09:31:28.846]     if (FALSE) {
[09:31:28.846]     }
[09:31:28.846]     else {
[09:31:28.846]         if (TRUE) {
[09:31:28.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.846]                 open = "w")
[09:31:28.846]         }
[09:31:28.846]         else {
[09:31:28.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.846]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.846]         }
[09:31:28.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.846]             base::sink(type = "output", split = FALSE)
[09:31:28.846]             base::close(...future.stdout)
[09:31:28.846]         }, add = TRUE)
[09:31:28.846]     }
[09:31:28.846]     ...future.frame <- base::sys.nframe()
[09:31:28.846]     ...future.conditions <- base::list()
[09:31:28.846]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.846]     if (FALSE) {
[09:31:28.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.846]     }
[09:31:28.846]     ...future.result <- base::tryCatch({
[09:31:28.846]         base::withCallingHandlers({
[09:31:28.846]             ...future.value <- base::withVisible(base::local({
[09:31:28.846]                 x$a <- 1
[09:31:28.846]                 x
[09:31:28.846]             }))
[09:31:28.846]             future::FutureResult(value = ...future.value$value, 
[09:31:28.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.846]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.846]                     ...future.globalenv.names))
[09:31:28.846]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.846]         }, condition = base::local({
[09:31:28.846]             c <- base::c
[09:31:28.846]             inherits <- base::inherits
[09:31:28.846]             invokeRestart <- base::invokeRestart
[09:31:28.846]             length <- base::length
[09:31:28.846]             list <- base::list
[09:31:28.846]             seq.int <- base::seq.int
[09:31:28.846]             signalCondition <- base::signalCondition
[09:31:28.846]             sys.calls <- base::sys.calls
[09:31:28.846]             `[[` <- base::`[[`
[09:31:28.846]             `+` <- base::`+`
[09:31:28.846]             `<<-` <- base::`<<-`
[09:31:28.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.846]                   3L)]
[09:31:28.846]             }
[09:31:28.846]             function(cond) {
[09:31:28.846]                 is_error <- inherits(cond, "error")
[09:31:28.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.846]                   NULL)
[09:31:28.846]                 if (is_error) {
[09:31:28.846]                   sessionInformation <- function() {
[09:31:28.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.846]                       search = base::search(), system = base::Sys.info())
[09:31:28.846]                   }
[09:31:28.846]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.846]                     cond$call), session = sessionInformation(), 
[09:31:28.846]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.846]                   signalCondition(cond)
[09:31:28.846]                 }
[09:31:28.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.846]                 "immediateCondition"))) {
[09:31:28.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.846]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.846]                   if (TRUE && !signal) {
[09:31:28.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.846]                     {
[09:31:28.846]                       inherits <- base::inherits
[09:31:28.846]                       invokeRestart <- base::invokeRestart
[09:31:28.846]                       is.null <- base::is.null
[09:31:28.846]                       muffled <- FALSE
[09:31:28.846]                       if (inherits(cond, "message")) {
[09:31:28.846]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.846]                         if (muffled) 
[09:31:28.846]                           invokeRestart("muffleMessage")
[09:31:28.846]                       }
[09:31:28.846]                       else if (inherits(cond, "warning")) {
[09:31:28.846]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.846]                         if (muffled) 
[09:31:28.846]                           invokeRestart("muffleWarning")
[09:31:28.846]                       }
[09:31:28.846]                       else if (inherits(cond, "condition")) {
[09:31:28.846]                         if (!is.null(pattern)) {
[09:31:28.846]                           computeRestarts <- base::computeRestarts
[09:31:28.846]                           grepl <- base::grepl
[09:31:28.846]                           restarts <- computeRestarts(cond)
[09:31:28.846]                           for (restart in restarts) {
[09:31:28.846]                             name <- restart$name
[09:31:28.846]                             if (is.null(name)) 
[09:31:28.846]                               next
[09:31:28.846]                             if (!grepl(pattern, name)) 
[09:31:28.846]                               next
[09:31:28.846]                             invokeRestart(restart)
[09:31:28.846]                             muffled <- TRUE
[09:31:28.846]                             break
[09:31:28.846]                           }
[09:31:28.846]                         }
[09:31:28.846]                       }
[09:31:28.846]                       invisible(muffled)
[09:31:28.846]                     }
[09:31:28.846]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.846]                   }
[09:31:28.846]                 }
[09:31:28.846]                 else {
[09:31:28.846]                   if (TRUE) {
[09:31:28.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.846]                     {
[09:31:28.846]                       inherits <- base::inherits
[09:31:28.846]                       invokeRestart <- base::invokeRestart
[09:31:28.846]                       is.null <- base::is.null
[09:31:28.846]                       muffled <- FALSE
[09:31:28.846]                       if (inherits(cond, "message")) {
[09:31:28.846]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.846]                         if (muffled) 
[09:31:28.846]                           invokeRestart("muffleMessage")
[09:31:28.846]                       }
[09:31:28.846]                       else if (inherits(cond, "warning")) {
[09:31:28.846]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.846]                         if (muffled) 
[09:31:28.846]                           invokeRestart("muffleWarning")
[09:31:28.846]                       }
[09:31:28.846]                       else if (inherits(cond, "condition")) {
[09:31:28.846]                         if (!is.null(pattern)) {
[09:31:28.846]                           computeRestarts <- base::computeRestarts
[09:31:28.846]                           grepl <- base::grepl
[09:31:28.846]                           restarts <- computeRestarts(cond)
[09:31:28.846]                           for (restart in restarts) {
[09:31:28.846]                             name <- restart$name
[09:31:28.846]                             if (is.null(name)) 
[09:31:28.846]                               next
[09:31:28.846]                             if (!grepl(pattern, name)) 
[09:31:28.846]                               next
[09:31:28.846]                             invokeRestart(restart)
[09:31:28.846]                             muffled <- TRUE
[09:31:28.846]                             break
[09:31:28.846]                           }
[09:31:28.846]                         }
[09:31:28.846]                       }
[09:31:28.846]                       invisible(muffled)
[09:31:28.846]                     }
[09:31:28.846]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.846]                   }
[09:31:28.846]                 }
[09:31:28.846]             }
[09:31:28.846]         }))
[09:31:28.846]     }, error = function(ex) {
[09:31:28.846]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.846]                 ...future.rng), started = ...future.startTime, 
[09:31:28.846]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.846]             version = "1.8"), class = "FutureResult")
[09:31:28.846]     }, finally = {
[09:31:28.846]         if (!identical(...future.workdir, getwd())) 
[09:31:28.846]             setwd(...future.workdir)
[09:31:28.846]         {
[09:31:28.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.846]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.846]             }
[09:31:28.846]             base::options(...future.oldOptions)
[09:31:28.846]             if (.Platform$OS.type == "windows") {
[09:31:28.846]                 old_names <- names(...future.oldEnvVars)
[09:31:28.846]                 envs <- base::Sys.getenv()
[09:31:28.846]                 names <- names(envs)
[09:31:28.846]                 common <- intersect(names, old_names)
[09:31:28.846]                 added <- setdiff(names, old_names)
[09:31:28.846]                 removed <- setdiff(old_names, names)
[09:31:28.846]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.846]                   envs[common]]
[09:31:28.846]                 NAMES <- toupper(changed)
[09:31:28.846]                 args <- list()
[09:31:28.846]                 for (kk in seq_along(NAMES)) {
[09:31:28.846]                   name <- changed[[kk]]
[09:31:28.846]                   NAME <- NAMES[[kk]]
[09:31:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.846]                     next
[09:31:28.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.846]                 }
[09:31:28.846]                 NAMES <- toupper(added)
[09:31:28.846]                 for (kk in seq_along(NAMES)) {
[09:31:28.846]                   name <- added[[kk]]
[09:31:28.846]                   NAME <- NAMES[[kk]]
[09:31:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.846]                     next
[09:31:28.846]                   args[[name]] <- ""
[09:31:28.846]                 }
[09:31:28.846]                 NAMES <- toupper(removed)
[09:31:28.846]                 for (kk in seq_along(NAMES)) {
[09:31:28.846]                   name <- removed[[kk]]
[09:31:28.846]                   NAME <- NAMES[[kk]]
[09:31:28.846]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.846]                     next
[09:31:28.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.846]                 }
[09:31:28.846]                 if (length(args) > 0) 
[09:31:28.846]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.846]             }
[09:31:28.846]             else {
[09:31:28.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.846]             }
[09:31:28.846]             {
[09:31:28.846]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.846]                   0L) {
[09:31:28.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.846]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.846]                   base::options(opts)
[09:31:28.846]                 }
[09:31:28.846]                 {
[09:31:28.846]                   {
[09:31:28.846]                     NULL
[09:31:28.846]                     RNGkind("Mersenne-Twister")
[09:31:28.846]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.846]                       inherits = FALSE)
[09:31:28.846]                   }
[09:31:28.846]                   options(future.plan = NULL)
[09:31:28.846]                   if (is.na(NA_character_)) 
[09:31:28.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.846]                     .init = FALSE)
[09:31:28.846]                 }
[09:31:28.846]             }
[09:31:28.846]         }
[09:31:28.846]     })
[09:31:28.846]     if (TRUE) {
[09:31:28.846]         base::sink(type = "output", split = FALSE)
[09:31:28.846]         if (TRUE) {
[09:31:28.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.846]         }
[09:31:28.846]         else {
[09:31:28.846]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.846]         }
[09:31:28.846]         base::close(...future.stdout)
[09:31:28.846]         ...future.stdout <- NULL
[09:31:28.846]     }
[09:31:28.846]     ...future.result$conditions <- ...future.conditions
[09:31:28.846]     ...future.result$finished <- base::Sys.time()
[09:31:28.846]     ...future.result
[09:31:28.846] }
[09:31:28.848] assign_globals() ...
[09:31:28.848] List of 1
[09:31:28.848]  $ x: list()
[09:31:28.848]  - attr(*, "where")=List of 1
[09:31:28.848]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.848]  - attr(*, "resolved")= logi TRUE
[09:31:28.848]  - attr(*, "total_size")= num 0
[09:31:28.848]  - attr(*, "already-done")= logi TRUE
[09:31:28.850] - copied ‘x’ to environment
[09:31:28.850] assign_globals() ... done
[09:31:28.851] plan(): Setting new future strategy stack:
[09:31:28.851] List of future strategies:
[09:31:28.851] 1. sequential:
[09:31:28.851]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.851]    - tweaked: FALSE
[09:31:28.851]    - call: NULL
[09:31:28.851] plan(): nbrOfWorkers() = 1
[09:31:28.852] plan(): Setting new future strategy stack:
[09:31:28.852] List of future strategies:
[09:31:28.852] 1. sequential:
[09:31:28.852]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.852]    - tweaked: FALSE
[09:31:28.852]    - call: plan(strategy)
[09:31:28.855] plan(): nbrOfWorkers() = 1
[09:31:28.855] SequentialFuture started (and completed)
[09:31:28.855] - Launch lazy future ... done
[09:31:28.855] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.856] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.856] Searching for globals...
[09:31:28.858] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.858] Searching for globals ... DONE
[09:31:28.858] Resolving globals: TRUE
[09:31:28.858] Resolving any globals that are futures ...
[09:31:28.858] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.858] Resolving any globals that are futures ... DONE
[09:31:28.859] Resolving futures part of globals (recursively) ...
[09:31:28.859] resolve() on list ...
[09:31:28.859]  recursive: 99
[09:31:28.859]  length: 1
[09:31:28.859]  elements: ‘x’
[09:31:28.859]  length: 0 (resolved future 1)
[09:31:28.859] resolve() on list ... DONE
[09:31:28.859] - globals: [1] ‘x’
[09:31:28.859] Resolving futures part of globals (recursively) ... DONE
[09:31:28.860] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.860] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.860] - globals: [1] ‘x’
[09:31:28.860] 
[09:31:28.860] getGlobalsAndPackages() ... DONE
[09:31:28.860] run() for ‘Future’ ...
[09:31:28.861] - state: ‘created’
[09:31:28.861] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.861] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.861]   - Field: ‘label’
[09:31:28.861]   - Field: ‘local’
[09:31:28.861]   - Field: ‘owner’
[09:31:28.861]   - Field: ‘envir’
[09:31:28.862]   - Field: ‘packages’
[09:31:28.862]   - Field: ‘gc’
[09:31:28.862]   - Field: ‘conditions’
[09:31:28.862]   - Field: ‘expr’
[09:31:28.862]   - Field: ‘uuid’
[09:31:28.862]   - Field: ‘seed’
[09:31:28.862]   - Field: ‘version’
[09:31:28.862]   - Field: ‘result’
[09:31:28.862]   - Field: ‘asynchronous’
[09:31:28.862]   - Field: ‘calls’
[09:31:28.862]   - Field: ‘globals’
[09:31:28.862]   - Field: ‘stdout’
[09:31:28.863]   - Field: ‘earlySignal’
[09:31:28.863]   - Field: ‘lazy’
[09:31:28.863]   - Field: ‘state’
[09:31:28.863] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.863] - Launch lazy future ...
[09:31:28.863] Packages needed by the future expression (n = 0): <none>
[09:31:28.863] Packages needed by future strategies (n = 0): <none>
[09:31:28.864] {
[09:31:28.864]     {
[09:31:28.864]         {
[09:31:28.864]             ...future.startTime <- base::Sys.time()
[09:31:28.864]             {
[09:31:28.864]                 {
[09:31:28.864]                   {
[09:31:28.864]                     base::local({
[09:31:28.864]                       has_future <- base::requireNamespace("future", 
[09:31:28.864]                         quietly = TRUE)
[09:31:28.864]                       if (has_future) {
[09:31:28.864]                         ns <- base::getNamespace("future")
[09:31:28.864]                         version <- ns[[".package"]][["version"]]
[09:31:28.864]                         if (is.null(version)) 
[09:31:28.864]                           version <- utils::packageVersion("future")
[09:31:28.864]                       }
[09:31:28.864]                       else {
[09:31:28.864]                         version <- NULL
[09:31:28.864]                       }
[09:31:28.864]                       if (!has_future || version < "1.8.0") {
[09:31:28.864]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.864]                           "", base::R.version$version.string), 
[09:31:28.864]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.864]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.864]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.864]                             "release", "version")], collapse = " "), 
[09:31:28.864]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.864]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.864]                           info)
[09:31:28.864]                         info <- base::paste(info, collapse = "; ")
[09:31:28.864]                         if (!has_future) {
[09:31:28.864]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.864]                             info)
[09:31:28.864]                         }
[09:31:28.864]                         else {
[09:31:28.864]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.864]                             info, version)
[09:31:28.864]                         }
[09:31:28.864]                         base::stop(msg)
[09:31:28.864]                       }
[09:31:28.864]                     })
[09:31:28.864]                   }
[09:31:28.864]                   ...future.strategy.old <- future::plan("list")
[09:31:28.864]                   options(future.plan = NULL)
[09:31:28.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.864]                 }
[09:31:28.864]                 ...future.workdir <- getwd()
[09:31:28.864]             }
[09:31:28.864]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.864]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.864]         }
[09:31:28.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.864]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.864]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.864]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.864]             base::names(...future.oldOptions))
[09:31:28.864]     }
[09:31:28.864]     if (FALSE) {
[09:31:28.864]     }
[09:31:28.864]     else {
[09:31:28.864]         if (TRUE) {
[09:31:28.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.864]                 open = "w")
[09:31:28.864]         }
[09:31:28.864]         else {
[09:31:28.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.864]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.864]         }
[09:31:28.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.864]             base::sink(type = "output", split = FALSE)
[09:31:28.864]             base::close(...future.stdout)
[09:31:28.864]         }, add = TRUE)
[09:31:28.864]     }
[09:31:28.864]     ...future.frame <- base::sys.nframe()
[09:31:28.864]     ...future.conditions <- base::list()
[09:31:28.864]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.864]     if (FALSE) {
[09:31:28.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.864]     }
[09:31:28.864]     ...future.result <- base::tryCatch({
[09:31:28.864]         base::withCallingHandlers({
[09:31:28.864]             ...future.value <- base::withVisible(base::local({
[09:31:28.864]                 x$a <- 1
[09:31:28.864]                 x
[09:31:28.864]             }))
[09:31:28.864]             future::FutureResult(value = ...future.value$value, 
[09:31:28.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.864]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.864]                     ...future.globalenv.names))
[09:31:28.864]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.864]         }, condition = base::local({
[09:31:28.864]             c <- base::c
[09:31:28.864]             inherits <- base::inherits
[09:31:28.864]             invokeRestart <- base::invokeRestart
[09:31:28.864]             length <- base::length
[09:31:28.864]             list <- base::list
[09:31:28.864]             seq.int <- base::seq.int
[09:31:28.864]             signalCondition <- base::signalCondition
[09:31:28.864]             sys.calls <- base::sys.calls
[09:31:28.864]             `[[` <- base::`[[`
[09:31:28.864]             `+` <- base::`+`
[09:31:28.864]             `<<-` <- base::`<<-`
[09:31:28.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.864]                   3L)]
[09:31:28.864]             }
[09:31:28.864]             function(cond) {
[09:31:28.864]                 is_error <- inherits(cond, "error")
[09:31:28.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.864]                   NULL)
[09:31:28.864]                 if (is_error) {
[09:31:28.864]                   sessionInformation <- function() {
[09:31:28.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.864]                       search = base::search(), system = base::Sys.info())
[09:31:28.864]                   }
[09:31:28.864]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.864]                     cond$call), session = sessionInformation(), 
[09:31:28.864]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.864]                   signalCondition(cond)
[09:31:28.864]                 }
[09:31:28.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.864]                 "immediateCondition"))) {
[09:31:28.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.864]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.864]                   if (TRUE && !signal) {
[09:31:28.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.864]                     {
[09:31:28.864]                       inherits <- base::inherits
[09:31:28.864]                       invokeRestart <- base::invokeRestart
[09:31:28.864]                       is.null <- base::is.null
[09:31:28.864]                       muffled <- FALSE
[09:31:28.864]                       if (inherits(cond, "message")) {
[09:31:28.864]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.864]                         if (muffled) 
[09:31:28.864]                           invokeRestart("muffleMessage")
[09:31:28.864]                       }
[09:31:28.864]                       else if (inherits(cond, "warning")) {
[09:31:28.864]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.864]                         if (muffled) 
[09:31:28.864]                           invokeRestart("muffleWarning")
[09:31:28.864]                       }
[09:31:28.864]                       else if (inherits(cond, "condition")) {
[09:31:28.864]                         if (!is.null(pattern)) {
[09:31:28.864]                           computeRestarts <- base::computeRestarts
[09:31:28.864]                           grepl <- base::grepl
[09:31:28.864]                           restarts <- computeRestarts(cond)
[09:31:28.864]                           for (restart in restarts) {
[09:31:28.864]                             name <- restart$name
[09:31:28.864]                             if (is.null(name)) 
[09:31:28.864]                               next
[09:31:28.864]                             if (!grepl(pattern, name)) 
[09:31:28.864]                               next
[09:31:28.864]                             invokeRestart(restart)
[09:31:28.864]                             muffled <- TRUE
[09:31:28.864]                             break
[09:31:28.864]                           }
[09:31:28.864]                         }
[09:31:28.864]                       }
[09:31:28.864]                       invisible(muffled)
[09:31:28.864]                     }
[09:31:28.864]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.864]                   }
[09:31:28.864]                 }
[09:31:28.864]                 else {
[09:31:28.864]                   if (TRUE) {
[09:31:28.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.864]                     {
[09:31:28.864]                       inherits <- base::inherits
[09:31:28.864]                       invokeRestart <- base::invokeRestart
[09:31:28.864]                       is.null <- base::is.null
[09:31:28.864]                       muffled <- FALSE
[09:31:28.864]                       if (inherits(cond, "message")) {
[09:31:28.864]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.864]                         if (muffled) 
[09:31:28.864]                           invokeRestart("muffleMessage")
[09:31:28.864]                       }
[09:31:28.864]                       else if (inherits(cond, "warning")) {
[09:31:28.864]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.864]                         if (muffled) 
[09:31:28.864]                           invokeRestart("muffleWarning")
[09:31:28.864]                       }
[09:31:28.864]                       else if (inherits(cond, "condition")) {
[09:31:28.864]                         if (!is.null(pattern)) {
[09:31:28.864]                           computeRestarts <- base::computeRestarts
[09:31:28.864]                           grepl <- base::grepl
[09:31:28.864]                           restarts <- computeRestarts(cond)
[09:31:28.864]                           for (restart in restarts) {
[09:31:28.864]                             name <- restart$name
[09:31:28.864]                             if (is.null(name)) 
[09:31:28.864]                               next
[09:31:28.864]                             if (!grepl(pattern, name)) 
[09:31:28.864]                               next
[09:31:28.864]                             invokeRestart(restart)
[09:31:28.864]                             muffled <- TRUE
[09:31:28.864]                             break
[09:31:28.864]                           }
[09:31:28.864]                         }
[09:31:28.864]                       }
[09:31:28.864]                       invisible(muffled)
[09:31:28.864]                     }
[09:31:28.864]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.864]                   }
[09:31:28.864]                 }
[09:31:28.864]             }
[09:31:28.864]         }))
[09:31:28.864]     }, error = function(ex) {
[09:31:28.864]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.864]                 ...future.rng), started = ...future.startTime, 
[09:31:28.864]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.864]             version = "1.8"), class = "FutureResult")
[09:31:28.864]     }, finally = {
[09:31:28.864]         if (!identical(...future.workdir, getwd())) 
[09:31:28.864]             setwd(...future.workdir)
[09:31:28.864]         {
[09:31:28.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.864]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.864]             }
[09:31:28.864]             base::options(...future.oldOptions)
[09:31:28.864]             if (.Platform$OS.type == "windows") {
[09:31:28.864]                 old_names <- names(...future.oldEnvVars)
[09:31:28.864]                 envs <- base::Sys.getenv()
[09:31:28.864]                 names <- names(envs)
[09:31:28.864]                 common <- intersect(names, old_names)
[09:31:28.864]                 added <- setdiff(names, old_names)
[09:31:28.864]                 removed <- setdiff(old_names, names)
[09:31:28.864]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.864]                   envs[common]]
[09:31:28.864]                 NAMES <- toupper(changed)
[09:31:28.864]                 args <- list()
[09:31:28.864]                 for (kk in seq_along(NAMES)) {
[09:31:28.864]                   name <- changed[[kk]]
[09:31:28.864]                   NAME <- NAMES[[kk]]
[09:31:28.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.864]                     next
[09:31:28.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.864]                 }
[09:31:28.864]                 NAMES <- toupper(added)
[09:31:28.864]                 for (kk in seq_along(NAMES)) {
[09:31:28.864]                   name <- added[[kk]]
[09:31:28.864]                   NAME <- NAMES[[kk]]
[09:31:28.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.864]                     next
[09:31:28.864]                   args[[name]] <- ""
[09:31:28.864]                 }
[09:31:28.864]                 NAMES <- toupper(removed)
[09:31:28.864]                 for (kk in seq_along(NAMES)) {
[09:31:28.864]                   name <- removed[[kk]]
[09:31:28.864]                   NAME <- NAMES[[kk]]
[09:31:28.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.864]                     next
[09:31:28.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.864]                 }
[09:31:28.864]                 if (length(args) > 0) 
[09:31:28.864]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.864]             }
[09:31:28.864]             else {
[09:31:28.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.864]             }
[09:31:28.864]             {
[09:31:28.864]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.864]                   0L) {
[09:31:28.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.864]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.864]                   base::options(opts)
[09:31:28.864]                 }
[09:31:28.864]                 {
[09:31:28.864]                   {
[09:31:28.864]                     NULL
[09:31:28.864]                     RNGkind("Mersenne-Twister")
[09:31:28.864]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.864]                       inherits = FALSE)
[09:31:28.864]                   }
[09:31:28.864]                   options(future.plan = NULL)
[09:31:28.864]                   if (is.na(NA_character_)) 
[09:31:28.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.864]                     .init = FALSE)
[09:31:28.864]                 }
[09:31:28.864]             }
[09:31:28.864]         }
[09:31:28.864]     })
[09:31:28.864]     if (TRUE) {
[09:31:28.864]         base::sink(type = "output", split = FALSE)
[09:31:28.864]         if (TRUE) {
[09:31:28.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.864]         }
[09:31:28.864]         else {
[09:31:28.864]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.864]         }
[09:31:28.864]         base::close(...future.stdout)
[09:31:28.864]         ...future.stdout <- NULL
[09:31:28.864]     }
[09:31:28.864]     ...future.result$conditions <- ...future.conditions
[09:31:28.864]     ...future.result$finished <- base::Sys.time()
[09:31:28.864]     ...future.result
[09:31:28.864] }
[09:31:28.865] assign_globals() ...
[09:31:28.865] List of 1
[09:31:28.865]  $ x: list()
[09:31:28.865]  - attr(*, "where")=List of 1
[09:31:28.865]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.865]  - attr(*, "resolved")= logi TRUE
[09:31:28.865]  - attr(*, "total_size")= num 0
[09:31:28.865]  - attr(*, "already-done")= logi TRUE
[09:31:28.867] - copied ‘x’ to environment
[09:31:28.867] assign_globals() ... done
[09:31:28.868] plan(): Setting new future strategy stack:
[09:31:28.868] List of future strategies:
[09:31:28.868] 1. sequential:
[09:31:28.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.868]    - tweaked: FALSE
[09:31:28.868]    - call: NULL
[09:31:28.868] plan(): nbrOfWorkers() = 1
[09:31:28.869] plan(): Setting new future strategy stack:
[09:31:28.869] List of future strategies:
[09:31:28.869] 1. sequential:
[09:31:28.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.869]    - tweaked: FALSE
[09:31:28.869]    - call: plan(strategy)
[09:31:28.869] plan(): nbrOfWorkers() = 1
[09:31:28.870] SequentialFuture started (and completed)
[09:31:28.870] - Launch lazy future ... done
[09:31:28.870] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.871] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.871] Searching for globals...
[09:31:28.873] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.873] Searching for globals ... DONE
[09:31:28.873] Resolving globals: TRUE
[09:31:28.873] Resolving any globals that are futures ...
[09:31:28.873] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.873] Resolving any globals that are futures ... DONE
[09:31:28.874] Resolving futures part of globals (recursively) ...
[09:31:28.874] resolve() on list ...
[09:31:28.874]  recursive: 99
[09:31:28.874]  length: 1
[09:31:28.874]  elements: ‘x’
[09:31:28.874]  length: 0 (resolved future 1)
[09:31:28.874] resolve() on list ... DONE
[09:31:28.874] - globals: [1] ‘x’
[09:31:28.874] Resolving futures part of globals (recursively) ... DONE
[09:31:28.875] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.875] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.875] - globals: [1] ‘x’
[09:31:28.875] 
[09:31:28.875] getGlobalsAndPackages() ... DONE
[09:31:28.875] run() for ‘Future’ ...
[09:31:28.875] - state: ‘created’
[09:31:28.876] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.876] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.876] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.876]   - Field: ‘label’
[09:31:28.876]   - Field: ‘local’
[09:31:28.876]   - Field: ‘owner’
[09:31:28.876]   - Field: ‘envir’
[09:31:28.876]   - Field: ‘packages’
[09:31:28.876]   - Field: ‘gc’
[09:31:28.877]   - Field: ‘conditions’
[09:31:28.877]   - Field: ‘expr’
[09:31:28.877]   - Field: ‘uuid’
[09:31:28.877]   - Field: ‘seed’
[09:31:28.877]   - Field: ‘version’
[09:31:28.877]   - Field: ‘result’
[09:31:28.877]   - Field: ‘asynchronous’
[09:31:28.877]   - Field: ‘calls’
[09:31:28.877]   - Field: ‘globals’
[09:31:28.877]   - Field: ‘stdout’
[09:31:28.877]   - Field: ‘earlySignal’
[09:31:28.877]   - Field: ‘lazy’
[09:31:28.878]   - Field: ‘state’
[09:31:28.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.878] - Launch lazy future ...
[09:31:28.878] Packages needed by the future expression (n = 0): <none>
[09:31:28.878] Packages needed by future strategies (n = 0): <none>
[09:31:28.878] {
[09:31:28.878]     {
[09:31:28.878]         {
[09:31:28.878]             ...future.startTime <- base::Sys.time()
[09:31:28.878]             {
[09:31:28.878]                 {
[09:31:28.878]                   {
[09:31:28.878]                     base::local({
[09:31:28.878]                       has_future <- base::requireNamespace("future", 
[09:31:28.878]                         quietly = TRUE)
[09:31:28.878]                       if (has_future) {
[09:31:28.878]                         ns <- base::getNamespace("future")
[09:31:28.878]                         version <- ns[[".package"]][["version"]]
[09:31:28.878]                         if (is.null(version)) 
[09:31:28.878]                           version <- utils::packageVersion("future")
[09:31:28.878]                       }
[09:31:28.878]                       else {
[09:31:28.878]                         version <- NULL
[09:31:28.878]                       }
[09:31:28.878]                       if (!has_future || version < "1.8.0") {
[09:31:28.878]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.878]                           "", base::R.version$version.string), 
[09:31:28.878]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.878]                             "release", "version")], collapse = " "), 
[09:31:28.878]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.878]                           info)
[09:31:28.878]                         info <- base::paste(info, collapse = "; ")
[09:31:28.878]                         if (!has_future) {
[09:31:28.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.878]                             info)
[09:31:28.878]                         }
[09:31:28.878]                         else {
[09:31:28.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.878]                             info, version)
[09:31:28.878]                         }
[09:31:28.878]                         base::stop(msg)
[09:31:28.878]                       }
[09:31:28.878]                     })
[09:31:28.878]                   }
[09:31:28.878]                   ...future.strategy.old <- future::plan("list")
[09:31:28.878]                   options(future.plan = NULL)
[09:31:28.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.878]                 }
[09:31:28.878]                 ...future.workdir <- getwd()
[09:31:28.878]             }
[09:31:28.878]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.878]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.878]         }
[09:31:28.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.878]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.878]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.878]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.878]             base::names(...future.oldOptions))
[09:31:28.878]     }
[09:31:28.878]     if (FALSE) {
[09:31:28.878]     }
[09:31:28.878]     else {
[09:31:28.878]         if (TRUE) {
[09:31:28.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.878]                 open = "w")
[09:31:28.878]         }
[09:31:28.878]         else {
[09:31:28.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.878]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.878]         }
[09:31:28.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.878]             base::sink(type = "output", split = FALSE)
[09:31:28.878]             base::close(...future.stdout)
[09:31:28.878]         }, add = TRUE)
[09:31:28.878]     }
[09:31:28.878]     ...future.frame <- base::sys.nframe()
[09:31:28.878]     ...future.conditions <- base::list()
[09:31:28.878]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.878]     if (FALSE) {
[09:31:28.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.878]     }
[09:31:28.878]     ...future.result <- base::tryCatch({
[09:31:28.878]         base::withCallingHandlers({
[09:31:28.878]             ...future.value <- base::withVisible(base::local({
[09:31:28.878]                 x$a <- 1
[09:31:28.878]                 x
[09:31:28.878]             }))
[09:31:28.878]             future::FutureResult(value = ...future.value$value, 
[09:31:28.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.878]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.878]                     ...future.globalenv.names))
[09:31:28.878]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.878]         }, condition = base::local({
[09:31:28.878]             c <- base::c
[09:31:28.878]             inherits <- base::inherits
[09:31:28.878]             invokeRestart <- base::invokeRestart
[09:31:28.878]             length <- base::length
[09:31:28.878]             list <- base::list
[09:31:28.878]             seq.int <- base::seq.int
[09:31:28.878]             signalCondition <- base::signalCondition
[09:31:28.878]             sys.calls <- base::sys.calls
[09:31:28.878]             `[[` <- base::`[[`
[09:31:28.878]             `+` <- base::`+`
[09:31:28.878]             `<<-` <- base::`<<-`
[09:31:28.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.878]                   3L)]
[09:31:28.878]             }
[09:31:28.878]             function(cond) {
[09:31:28.878]                 is_error <- inherits(cond, "error")
[09:31:28.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.878]                   NULL)
[09:31:28.878]                 if (is_error) {
[09:31:28.878]                   sessionInformation <- function() {
[09:31:28.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.878]                       search = base::search(), system = base::Sys.info())
[09:31:28.878]                   }
[09:31:28.878]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.878]                     cond$call), session = sessionInformation(), 
[09:31:28.878]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.878]                   signalCondition(cond)
[09:31:28.878]                 }
[09:31:28.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.878]                 "immediateCondition"))) {
[09:31:28.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.878]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.878]                   if (TRUE && !signal) {
[09:31:28.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.878]                     {
[09:31:28.878]                       inherits <- base::inherits
[09:31:28.878]                       invokeRestart <- base::invokeRestart
[09:31:28.878]                       is.null <- base::is.null
[09:31:28.878]                       muffled <- FALSE
[09:31:28.878]                       if (inherits(cond, "message")) {
[09:31:28.878]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.878]                         if (muffled) 
[09:31:28.878]                           invokeRestart("muffleMessage")
[09:31:28.878]                       }
[09:31:28.878]                       else if (inherits(cond, "warning")) {
[09:31:28.878]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.878]                         if (muffled) 
[09:31:28.878]                           invokeRestart("muffleWarning")
[09:31:28.878]                       }
[09:31:28.878]                       else if (inherits(cond, "condition")) {
[09:31:28.878]                         if (!is.null(pattern)) {
[09:31:28.878]                           computeRestarts <- base::computeRestarts
[09:31:28.878]                           grepl <- base::grepl
[09:31:28.878]                           restarts <- computeRestarts(cond)
[09:31:28.878]                           for (restart in restarts) {
[09:31:28.878]                             name <- restart$name
[09:31:28.878]                             if (is.null(name)) 
[09:31:28.878]                               next
[09:31:28.878]                             if (!grepl(pattern, name)) 
[09:31:28.878]                               next
[09:31:28.878]                             invokeRestart(restart)
[09:31:28.878]                             muffled <- TRUE
[09:31:28.878]                             break
[09:31:28.878]                           }
[09:31:28.878]                         }
[09:31:28.878]                       }
[09:31:28.878]                       invisible(muffled)
[09:31:28.878]                     }
[09:31:28.878]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.878]                   }
[09:31:28.878]                 }
[09:31:28.878]                 else {
[09:31:28.878]                   if (TRUE) {
[09:31:28.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.878]                     {
[09:31:28.878]                       inherits <- base::inherits
[09:31:28.878]                       invokeRestart <- base::invokeRestart
[09:31:28.878]                       is.null <- base::is.null
[09:31:28.878]                       muffled <- FALSE
[09:31:28.878]                       if (inherits(cond, "message")) {
[09:31:28.878]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.878]                         if (muffled) 
[09:31:28.878]                           invokeRestart("muffleMessage")
[09:31:28.878]                       }
[09:31:28.878]                       else if (inherits(cond, "warning")) {
[09:31:28.878]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.878]                         if (muffled) 
[09:31:28.878]                           invokeRestart("muffleWarning")
[09:31:28.878]                       }
[09:31:28.878]                       else if (inherits(cond, "condition")) {
[09:31:28.878]                         if (!is.null(pattern)) {
[09:31:28.878]                           computeRestarts <- base::computeRestarts
[09:31:28.878]                           grepl <- base::grepl
[09:31:28.878]                           restarts <- computeRestarts(cond)
[09:31:28.878]                           for (restart in restarts) {
[09:31:28.878]                             name <- restart$name
[09:31:28.878]                             if (is.null(name)) 
[09:31:28.878]                               next
[09:31:28.878]                             if (!grepl(pattern, name)) 
[09:31:28.878]                               next
[09:31:28.878]                             invokeRestart(restart)
[09:31:28.878]                             muffled <- TRUE
[09:31:28.878]                             break
[09:31:28.878]                           }
[09:31:28.878]                         }
[09:31:28.878]                       }
[09:31:28.878]                       invisible(muffled)
[09:31:28.878]                     }
[09:31:28.878]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.878]                   }
[09:31:28.878]                 }
[09:31:28.878]             }
[09:31:28.878]         }))
[09:31:28.878]     }, error = function(ex) {
[09:31:28.878]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.878]                 ...future.rng), started = ...future.startTime, 
[09:31:28.878]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.878]             version = "1.8"), class = "FutureResult")
[09:31:28.878]     }, finally = {
[09:31:28.878]         if (!identical(...future.workdir, getwd())) 
[09:31:28.878]             setwd(...future.workdir)
[09:31:28.878]         {
[09:31:28.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.878]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.878]             }
[09:31:28.878]             base::options(...future.oldOptions)
[09:31:28.878]             if (.Platform$OS.type == "windows") {
[09:31:28.878]                 old_names <- names(...future.oldEnvVars)
[09:31:28.878]                 envs <- base::Sys.getenv()
[09:31:28.878]                 names <- names(envs)
[09:31:28.878]                 common <- intersect(names, old_names)
[09:31:28.878]                 added <- setdiff(names, old_names)
[09:31:28.878]                 removed <- setdiff(old_names, names)
[09:31:28.878]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.878]                   envs[common]]
[09:31:28.878]                 NAMES <- toupper(changed)
[09:31:28.878]                 args <- list()
[09:31:28.878]                 for (kk in seq_along(NAMES)) {
[09:31:28.878]                   name <- changed[[kk]]
[09:31:28.878]                   NAME <- NAMES[[kk]]
[09:31:28.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.878]                     next
[09:31:28.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.878]                 }
[09:31:28.878]                 NAMES <- toupper(added)
[09:31:28.878]                 for (kk in seq_along(NAMES)) {
[09:31:28.878]                   name <- added[[kk]]
[09:31:28.878]                   NAME <- NAMES[[kk]]
[09:31:28.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.878]                     next
[09:31:28.878]                   args[[name]] <- ""
[09:31:28.878]                 }
[09:31:28.878]                 NAMES <- toupper(removed)
[09:31:28.878]                 for (kk in seq_along(NAMES)) {
[09:31:28.878]                   name <- removed[[kk]]
[09:31:28.878]                   NAME <- NAMES[[kk]]
[09:31:28.878]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.878]                     next
[09:31:28.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.878]                 }
[09:31:28.878]                 if (length(args) > 0) 
[09:31:28.878]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.878]             }
[09:31:28.878]             else {
[09:31:28.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.878]             }
[09:31:28.878]             {
[09:31:28.878]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.878]                   0L) {
[09:31:28.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.878]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.878]                   base::options(opts)
[09:31:28.878]                 }
[09:31:28.878]                 {
[09:31:28.878]                   {
[09:31:28.878]                     NULL
[09:31:28.878]                     RNGkind("Mersenne-Twister")
[09:31:28.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.878]                       inherits = FALSE)
[09:31:28.878]                   }
[09:31:28.878]                   options(future.plan = NULL)
[09:31:28.878]                   if (is.na(NA_character_)) 
[09:31:28.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.878]                     .init = FALSE)
[09:31:28.878]                 }
[09:31:28.878]             }
[09:31:28.878]         }
[09:31:28.878]     })
[09:31:28.878]     if (TRUE) {
[09:31:28.878]         base::sink(type = "output", split = FALSE)
[09:31:28.878]         if (TRUE) {
[09:31:28.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.878]         }
[09:31:28.878]         else {
[09:31:28.878]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.878]         }
[09:31:28.878]         base::close(...future.stdout)
[09:31:28.878]         ...future.stdout <- NULL
[09:31:28.878]     }
[09:31:28.878]     ...future.result$conditions <- ...future.conditions
[09:31:28.878]     ...future.result$finished <- base::Sys.time()
[09:31:28.878]     ...future.result
[09:31:28.878] }
[09:31:28.880] assign_globals() ...
[09:31:28.880] List of 1
[09:31:28.880]  $ x: list()
[09:31:28.880]  - attr(*, "where")=List of 1
[09:31:28.880]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.880]  - attr(*, "resolved")= logi TRUE
[09:31:28.880]  - attr(*, "total_size")= num 0
[09:31:28.880]  - attr(*, "already-done")= logi TRUE
[09:31:28.883] - copied ‘x’ to environment
[09:31:28.883] assign_globals() ... done
[09:31:28.884] plan(): Setting new future strategy stack:
[09:31:28.884] List of future strategies:
[09:31:28.884] 1. sequential:
[09:31:28.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.884]    - tweaked: FALSE
[09:31:28.884]    - call: NULL
[09:31:28.884] plan(): nbrOfWorkers() = 1
[09:31:28.885] plan(): Setting new future strategy stack:
[09:31:28.885] List of future strategies:
[09:31:28.885] 1. sequential:
[09:31:28.885]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.885]    - tweaked: FALSE
[09:31:28.885]    - call: plan(strategy)
[09:31:28.885] plan(): nbrOfWorkers() = 1
[09:31:28.886] SequentialFuture started (and completed)
[09:31:28.886] - Launch lazy future ... done
[09:31:28.886] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.886] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.886] Searching for globals...
[09:31:28.888] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.888] Searching for globals ... DONE
[09:31:28.888] Resolving globals: TRUE
[09:31:28.888] Resolving any globals that are futures ...
[09:31:28.889] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:28.889] Resolving any globals that are futures ... DONE
[09:31:28.889] Resolving futures part of globals (recursively) ...
[09:31:28.889] resolve() on list ...
[09:31:28.889]  recursive: 99
[09:31:28.889]  length: 1
[09:31:28.889]  elements: ‘x’
[09:31:28.890]  length: 0 (resolved future 1)
[09:31:28.890] resolve() on list ... DONE
[09:31:28.890] - globals: [1] ‘x’
[09:31:28.890] Resolving futures part of globals (recursively) ... DONE
[09:31:28.890] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.890] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.890] - globals: [1] ‘x’
[09:31:28.890] 
[09:31:28.891] getGlobalsAndPackages() ... DONE
[09:31:28.891] run() for ‘Future’ ...
[09:31:28.891] - state: ‘created’
[09:31:28.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.891]   - Field: ‘label’
[09:31:28.892]   - Field: ‘local’
[09:31:28.892]   - Field: ‘owner’
[09:31:28.892]   - Field: ‘envir’
[09:31:28.892]   - Field: ‘packages’
[09:31:28.892]   - Field: ‘gc’
[09:31:28.892]   - Field: ‘conditions’
[09:31:28.892]   - Field: ‘expr’
[09:31:28.892]   - Field: ‘uuid’
[09:31:28.892]   - Field: ‘seed’
[09:31:28.892]   - Field: ‘version’
[09:31:28.892]   - Field: ‘result’
[09:31:28.893]   - Field: ‘asynchronous’
[09:31:28.893]   - Field: ‘calls’
[09:31:28.893]   - Field: ‘globals’
[09:31:28.893]   - Field: ‘stdout’
[09:31:28.893]   - Field: ‘earlySignal’
[09:31:28.893]   - Field: ‘lazy’
[09:31:28.893]   - Field: ‘state’
[09:31:28.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.893] - Launch lazy future ...
[09:31:28.893] Packages needed by the future expression (n = 0): <none>
[09:31:28.893] Packages needed by future strategies (n = 0): <none>
[09:31:28.894] {
[09:31:28.894]     {
[09:31:28.894]         {
[09:31:28.894]             ...future.startTime <- base::Sys.time()
[09:31:28.894]             {
[09:31:28.894]                 {
[09:31:28.894]                   {
[09:31:28.894]                     base::local({
[09:31:28.894]                       has_future <- base::requireNamespace("future", 
[09:31:28.894]                         quietly = TRUE)
[09:31:28.894]                       if (has_future) {
[09:31:28.894]                         ns <- base::getNamespace("future")
[09:31:28.894]                         version <- ns[[".package"]][["version"]]
[09:31:28.894]                         if (is.null(version)) 
[09:31:28.894]                           version <- utils::packageVersion("future")
[09:31:28.894]                       }
[09:31:28.894]                       else {
[09:31:28.894]                         version <- NULL
[09:31:28.894]                       }
[09:31:28.894]                       if (!has_future || version < "1.8.0") {
[09:31:28.894]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.894]                           "", base::R.version$version.string), 
[09:31:28.894]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.894]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.894]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.894]                             "release", "version")], collapse = " "), 
[09:31:28.894]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.894]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.894]                           info)
[09:31:28.894]                         info <- base::paste(info, collapse = "; ")
[09:31:28.894]                         if (!has_future) {
[09:31:28.894]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.894]                             info)
[09:31:28.894]                         }
[09:31:28.894]                         else {
[09:31:28.894]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.894]                             info, version)
[09:31:28.894]                         }
[09:31:28.894]                         base::stop(msg)
[09:31:28.894]                       }
[09:31:28.894]                     })
[09:31:28.894]                   }
[09:31:28.894]                   ...future.strategy.old <- future::plan("list")
[09:31:28.894]                   options(future.plan = NULL)
[09:31:28.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.894]                 }
[09:31:28.894]                 ...future.workdir <- getwd()
[09:31:28.894]             }
[09:31:28.894]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.894]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.894]         }
[09:31:28.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.894]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.894]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.894]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.894]             base::names(...future.oldOptions))
[09:31:28.894]     }
[09:31:28.894]     if (FALSE) {
[09:31:28.894]     }
[09:31:28.894]     else {
[09:31:28.894]         if (TRUE) {
[09:31:28.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.894]                 open = "w")
[09:31:28.894]         }
[09:31:28.894]         else {
[09:31:28.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.894]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.894]         }
[09:31:28.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.894]             base::sink(type = "output", split = FALSE)
[09:31:28.894]             base::close(...future.stdout)
[09:31:28.894]         }, add = TRUE)
[09:31:28.894]     }
[09:31:28.894]     ...future.frame <- base::sys.nframe()
[09:31:28.894]     ...future.conditions <- base::list()
[09:31:28.894]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.894]     if (FALSE) {
[09:31:28.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.894]     }
[09:31:28.894]     ...future.result <- base::tryCatch({
[09:31:28.894]         base::withCallingHandlers({
[09:31:28.894]             ...future.value <- base::withVisible(base::local({
[09:31:28.894]                 x$a <- 1
[09:31:28.894]                 x
[09:31:28.894]             }))
[09:31:28.894]             future::FutureResult(value = ...future.value$value, 
[09:31:28.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.894]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.894]                     ...future.globalenv.names))
[09:31:28.894]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.894]         }, condition = base::local({
[09:31:28.894]             c <- base::c
[09:31:28.894]             inherits <- base::inherits
[09:31:28.894]             invokeRestart <- base::invokeRestart
[09:31:28.894]             length <- base::length
[09:31:28.894]             list <- base::list
[09:31:28.894]             seq.int <- base::seq.int
[09:31:28.894]             signalCondition <- base::signalCondition
[09:31:28.894]             sys.calls <- base::sys.calls
[09:31:28.894]             `[[` <- base::`[[`
[09:31:28.894]             `+` <- base::`+`
[09:31:28.894]             `<<-` <- base::`<<-`
[09:31:28.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.894]                   3L)]
[09:31:28.894]             }
[09:31:28.894]             function(cond) {
[09:31:28.894]                 is_error <- inherits(cond, "error")
[09:31:28.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.894]                   NULL)
[09:31:28.894]                 if (is_error) {
[09:31:28.894]                   sessionInformation <- function() {
[09:31:28.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.894]                       search = base::search(), system = base::Sys.info())
[09:31:28.894]                   }
[09:31:28.894]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.894]                     cond$call), session = sessionInformation(), 
[09:31:28.894]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.894]                   signalCondition(cond)
[09:31:28.894]                 }
[09:31:28.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.894]                 "immediateCondition"))) {
[09:31:28.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.894]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.894]                   if (TRUE && !signal) {
[09:31:28.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.894]                     {
[09:31:28.894]                       inherits <- base::inherits
[09:31:28.894]                       invokeRestart <- base::invokeRestart
[09:31:28.894]                       is.null <- base::is.null
[09:31:28.894]                       muffled <- FALSE
[09:31:28.894]                       if (inherits(cond, "message")) {
[09:31:28.894]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.894]                         if (muffled) 
[09:31:28.894]                           invokeRestart("muffleMessage")
[09:31:28.894]                       }
[09:31:28.894]                       else if (inherits(cond, "warning")) {
[09:31:28.894]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.894]                         if (muffled) 
[09:31:28.894]                           invokeRestart("muffleWarning")
[09:31:28.894]                       }
[09:31:28.894]                       else if (inherits(cond, "condition")) {
[09:31:28.894]                         if (!is.null(pattern)) {
[09:31:28.894]                           computeRestarts <- base::computeRestarts
[09:31:28.894]                           grepl <- base::grepl
[09:31:28.894]                           restarts <- computeRestarts(cond)
[09:31:28.894]                           for (restart in restarts) {
[09:31:28.894]                             name <- restart$name
[09:31:28.894]                             if (is.null(name)) 
[09:31:28.894]                               next
[09:31:28.894]                             if (!grepl(pattern, name)) 
[09:31:28.894]                               next
[09:31:28.894]                             invokeRestart(restart)
[09:31:28.894]                             muffled <- TRUE
[09:31:28.894]                             break
[09:31:28.894]                           }
[09:31:28.894]                         }
[09:31:28.894]                       }
[09:31:28.894]                       invisible(muffled)
[09:31:28.894]                     }
[09:31:28.894]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.894]                   }
[09:31:28.894]                 }
[09:31:28.894]                 else {
[09:31:28.894]                   if (TRUE) {
[09:31:28.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.894]                     {
[09:31:28.894]                       inherits <- base::inherits
[09:31:28.894]                       invokeRestart <- base::invokeRestart
[09:31:28.894]                       is.null <- base::is.null
[09:31:28.894]                       muffled <- FALSE
[09:31:28.894]                       if (inherits(cond, "message")) {
[09:31:28.894]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.894]                         if (muffled) 
[09:31:28.894]                           invokeRestart("muffleMessage")
[09:31:28.894]                       }
[09:31:28.894]                       else if (inherits(cond, "warning")) {
[09:31:28.894]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.894]                         if (muffled) 
[09:31:28.894]                           invokeRestart("muffleWarning")
[09:31:28.894]                       }
[09:31:28.894]                       else if (inherits(cond, "condition")) {
[09:31:28.894]                         if (!is.null(pattern)) {
[09:31:28.894]                           computeRestarts <- base::computeRestarts
[09:31:28.894]                           grepl <- base::grepl
[09:31:28.894]                           restarts <- computeRestarts(cond)
[09:31:28.894]                           for (restart in restarts) {
[09:31:28.894]                             name <- restart$name
[09:31:28.894]                             if (is.null(name)) 
[09:31:28.894]                               next
[09:31:28.894]                             if (!grepl(pattern, name)) 
[09:31:28.894]                               next
[09:31:28.894]                             invokeRestart(restart)
[09:31:28.894]                             muffled <- TRUE
[09:31:28.894]                             break
[09:31:28.894]                           }
[09:31:28.894]                         }
[09:31:28.894]                       }
[09:31:28.894]                       invisible(muffled)
[09:31:28.894]                     }
[09:31:28.894]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.894]                   }
[09:31:28.894]                 }
[09:31:28.894]             }
[09:31:28.894]         }))
[09:31:28.894]     }, error = function(ex) {
[09:31:28.894]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.894]                 ...future.rng), started = ...future.startTime, 
[09:31:28.894]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.894]             version = "1.8"), class = "FutureResult")
[09:31:28.894]     }, finally = {
[09:31:28.894]         if (!identical(...future.workdir, getwd())) 
[09:31:28.894]             setwd(...future.workdir)
[09:31:28.894]         {
[09:31:28.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.894]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.894]             }
[09:31:28.894]             base::options(...future.oldOptions)
[09:31:28.894]             if (.Platform$OS.type == "windows") {
[09:31:28.894]                 old_names <- names(...future.oldEnvVars)
[09:31:28.894]                 envs <- base::Sys.getenv()
[09:31:28.894]                 names <- names(envs)
[09:31:28.894]                 common <- intersect(names, old_names)
[09:31:28.894]                 added <- setdiff(names, old_names)
[09:31:28.894]                 removed <- setdiff(old_names, names)
[09:31:28.894]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.894]                   envs[common]]
[09:31:28.894]                 NAMES <- toupper(changed)
[09:31:28.894]                 args <- list()
[09:31:28.894]                 for (kk in seq_along(NAMES)) {
[09:31:28.894]                   name <- changed[[kk]]
[09:31:28.894]                   NAME <- NAMES[[kk]]
[09:31:28.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.894]                     next
[09:31:28.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.894]                 }
[09:31:28.894]                 NAMES <- toupper(added)
[09:31:28.894]                 for (kk in seq_along(NAMES)) {
[09:31:28.894]                   name <- added[[kk]]
[09:31:28.894]                   NAME <- NAMES[[kk]]
[09:31:28.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.894]                     next
[09:31:28.894]                   args[[name]] <- ""
[09:31:28.894]                 }
[09:31:28.894]                 NAMES <- toupper(removed)
[09:31:28.894]                 for (kk in seq_along(NAMES)) {
[09:31:28.894]                   name <- removed[[kk]]
[09:31:28.894]                   NAME <- NAMES[[kk]]
[09:31:28.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.894]                     next
[09:31:28.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.894]                 }
[09:31:28.894]                 if (length(args) > 0) 
[09:31:28.894]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.894]             }
[09:31:28.894]             else {
[09:31:28.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.894]             }
[09:31:28.894]             {
[09:31:28.894]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.894]                   0L) {
[09:31:28.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.894]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.894]                   base::options(opts)
[09:31:28.894]                 }
[09:31:28.894]                 {
[09:31:28.894]                   {
[09:31:28.894]                     NULL
[09:31:28.894]                     RNGkind("Mersenne-Twister")
[09:31:28.894]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.894]                       inherits = FALSE)
[09:31:28.894]                   }
[09:31:28.894]                   options(future.plan = NULL)
[09:31:28.894]                   if (is.na(NA_character_)) 
[09:31:28.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.894]                     .init = FALSE)
[09:31:28.894]                 }
[09:31:28.894]             }
[09:31:28.894]         }
[09:31:28.894]     })
[09:31:28.894]     if (TRUE) {
[09:31:28.894]         base::sink(type = "output", split = FALSE)
[09:31:28.894]         if (TRUE) {
[09:31:28.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.894]         }
[09:31:28.894]         else {
[09:31:28.894]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.894]         }
[09:31:28.894]         base::close(...future.stdout)
[09:31:28.894]         ...future.stdout <- NULL
[09:31:28.894]     }
[09:31:28.894]     ...future.result$conditions <- ...future.conditions
[09:31:28.894]     ...future.result$finished <- base::Sys.time()
[09:31:28.894]     ...future.result
[09:31:28.894] }
[09:31:28.895] assign_globals() ...
[09:31:28.895] List of 1
[09:31:28.895]  $ x: list()
[09:31:28.895]  - attr(*, "where")=List of 1
[09:31:28.895]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.895]  - attr(*, "resolved")= logi TRUE
[09:31:28.895]  - attr(*, "total_size")= num 0
[09:31:28.895]  - attr(*, "already-done")= logi TRUE
[09:31:28.898] - copied ‘x’ to environment
[09:31:28.898] assign_globals() ... done
[09:31:28.898] plan(): Setting new future strategy stack:
[09:31:28.898] List of future strategies:
[09:31:28.898] 1. sequential:
[09:31:28.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.898]    - tweaked: FALSE
[09:31:28.898]    - call: NULL
[09:31:28.898] plan(): nbrOfWorkers() = 1
[09:31:28.899] plan(): Setting new future strategy stack:
[09:31:28.899] List of future strategies:
[09:31:28.899] 1. sequential:
[09:31:28.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.899]    - tweaked: FALSE
[09:31:28.899]    - call: plan(strategy)
[09:31:28.900] plan(): nbrOfWorkers() = 1
[09:31:28.900] SequentialFuture started (and completed)
[09:31:28.900] - Launch lazy future ... done
[09:31:28.900] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.900] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.901] Searching for globals...
[09:31:28.903] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:28.903] Searching for globals ... DONE
[09:31:28.903] Resolving globals: TRUE
[09:31:28.903] Resolving any globals that are futures ...
[09:31:28.903] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:28.903] Resolving any globals that are futures ... DONE
[09:31:28.904] 
[09:31:28.904] 
[09:31:28.904] getGlobalsAndPackages() ... DONE
[09:31:28.904] run() for ‘Future’ ...
[09:31:28.904] - state: ‘created’
[09:31:28.904] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.904] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.905]   - Field: ‘label’
[09:31:28.905]   - Field: ‘local’
[09:31:28.905]   - Field: ‘owner’
[09:31:28.905]   - Field: ‘envir’
[09:31:28.905]   - Field: ‘packages’
[09:31:28.905]   - Field: ‘gc’
[09:31:28.905]   - Field: ‘conditions’
[09:31:28.905]   - Field: ‘expr’
[09:31:28.905]   - Field: ‘uuid’
[09:31:28.905]   - Field: ‘seed’
[09:31:28.906]   - Field: ‘version’
[09:31:28.906]   - Field: ‘result’
[09:31:28.906]   - Field: ‘asynchronous’
[09:31:28.906]   - Field: ‘calls’
[09:31:28.906]   - Field: ‘globals’
[09:31:28.906]   - Field: ‘stdout’
[09:31:28.906]   - Field: ‘earlySignal’
[09:31:28.906]   - Field: ‘lazy’
[09:31:28.906]   - Field: ‘state’
[09:31:28.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.906] - Launch lazy future ...
[09:31:28.907] Packages needed by the future expression (n = 0): <none>
[09:31:28.907] Packages needed by future strategies (n = 0): <none>
[09:31:28.907] {
[09:31:28.907]     {
[09:31:28.907]         {
[09:31:28.907]             ...future.startTime <- base::Sys.time()
[09:31:28.907]             {
[09:31:28.907]                 {
[09:31:28.907]                   {
[09:31:28.907]                     base::local({
[09:31:28.907]                       has_future <- base::requireNamespace("future", 
[09:31:28.907]                         quietly = TRUE)
[09:31:28.907]                       if (has_future) {
[09:31:28.907]                         ns <- base::getNamespace("future")
[09:31:28.907]                         version <- ns[[".package"]][["version"]]
[09:31:28.907]                         if (is.null(version)) 
[09:31:28.907]                           version <- utils::packageVersion("future")
[09:31:28.907]                       }
[09:31:28.907]                       else {
[09:31:28.907]                         version <- NULL
[09:31:28.907]                       }
[09:31:28.907]                       if (!has_future || version < "1.8.0") {
[09:31:28.907]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.907]                           "", base::R.version$version.string), 
[09:31:28.907]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.907]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.907]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.907]                             "release", "version")], collapse = " "), 
[09:31:28.907]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.907]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.907]                           info)
[09:31:28.907]                         info <- base::paste(info, collapse = "; ")
[09:31:28.907]                         if (!has_future) {
[09:31:28.907]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.907]                             info)
[09:31:28.907]                         }
[09:31:28.907]                         else {
[09:31:28.907]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.907]                             info, version)
[09:31:28.907]                         }
[09:31:28.907]                         base::stop(msg)
[09:31:28.907]                       }
[09:31:28.907]                     })
[09:31:28.907]                   }
[09:31:28.907]                   ...future.strategy.old <- future::plan("list")
[09:31:28.907]                   options(future.plan = NULL)
[09:31:28.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.907]                 }
[09:31:28.907]                 ...future.workdir <- getwd()
[09:31:28.907]             }
[09:31:28.907]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.907]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.907]         }
[09:31:28.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.907]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.907]             base::names(...future.oldOptions))
[09:31:28.907]     }
[09:31:28.907]     if (FALSE) {
[09:31:28.907]     }
[09:31:28.907]     else {
[09:31:28.907]         if (TRUE) {
[09:31:28.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.907]                 open = "w")
[09:31:28.907]         }
[09:31:28.907]         else {
[09:31:28.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.907]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.907]         }
[09:31:28.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.907]             base::sink(type = "output", split = FALSE)
[09:31:28.907]             base::close(...future.stdout)
[09:31:28.907]         }, add = TRUE)
[09:31:28.907]     }
[09:31:28.907]     ...future.frame <- base::sys.nframe()
[09:31:28.907]     ...future.conditions <- base::list()
[09:31:28.907]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.907]     if (FALSE) {
[09:31:28.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.907]     }
[09:31:28.907]     ...future.result <- base::tryCatch({
[09:31:28.907]         base::withCallingHandlers({
[09:31:28.907]             ...future.value <- base::withVisible(base::local({
[09:31:28.907]                 x <- list(b = 2)
[09:31:28.907]                 x$a <- 1
[09:31:28.907]                 x
[09:31:28.907]             }))
[09:31:28.907]             future::FutureResult(value = ...future.value$value, 
[09:31:28.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.907]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.907]                     ...future.globalenv.names))
[09:31:28.907]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.907]         }, condition = base::local({
[09:31:28.907]             c <- base::c
[09:31:28.907]             inherits <- base::inherits
[09:31:28.907]             invokeRestart <- base::invokeRestart
[09:31:28.907]             length <- base::length
[09:31:28.907]             list <- base::list
[09:31:28.907]             seq.int <- base::seq.int
[09:31:28.907]             signalCondition <- base::signalCondition
[09:31:28.907]             sys.calls <- base::sys.calls
[09:31:28.907]             `[[` <- base::`[[`
[09:31:28.907]             `+` <- base::`+`
[09:31:28.907]             `<<-` <- base::`<<-`
[09:31:28.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.907]                   3L)]
[09:31:28.907]             }
[09:31:28.907]             function(cond) {
[09:31:28.907]                 is_error <- inherits(cond, "error")
[09:31:28.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.907]                   NULL)
[09:31:28.907]                 if (is_error) {
[09:31:28.907]                   sessionInformation <- function() {
[09:31:28.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.907]                       search = base::search(), system = base::Sys.info())
[09:31:28.907]                   }
[09:31:28.907]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.907]                     cond$call), session = sessionInformation(), 
[09:31:28.907]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.907]                   signalCondition(cond)
[09:31:28.907]                 }
[09:31:28.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.907]                 "immediateCondition"))) {
[09:31:28.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.907]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.907]                   if (TRUE && !signal) {
[09:31:28.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.907]                     {
[09:31:28.907]                       inherits <- base::inherits
[09:31:28.907]                       invokeRestart <- base::invokeRestart
[09:31:28.907]                       is.null <- base::is.null
[09:31:28.907]                       muffled <- FALSE
[09:31:28.907]                       if (inherits(cond, "message")) {
[09:31:28.907]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.907]                         if (muffled) 
[09:31:28.907]                           invokeRestart("muffleMessage")
[09:31:28.907]                       }
[09:31:28.907]                       else if (inherits(cond, "warning")) {
[09:31:28.907]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.907]                         if (muffled) 
[09:31:28.907]                           invokeRestart("muffleWarning")
[09:31:28.907]                       }
[09:31:28.907]                       else if (inherits(cond, "condition")) {
[09:31:28.907]                         if (!is.null(pattern)) {
[09:31:28.907]                           computeRestarts <- base::computeRestarts
[09:31:28.907]                           grepl <- base::grepl
[09:31:28.907]                           restarts <- computeRestarts(cond)
[09:31:28.907]                           for (restart in restarts) {
[09:31:28.907]                             name <- restart$name
[09:31:28.907]                             if (is.null(name)) 
[09:31:28.907]                               next
[09:31:28.907]                             if (!grepl(pattern, name)) 
[09:31:28.907]                               next
[09:31:28.907]                             invokeRestart(restart)
[09:31:28.907]                             muffled <- TRUE
[09:31:28.907]                             break
[09:31:28.907]                           }
[09:31:28.907]                         }
[09:31:28.907]                       }
[09:31:28.907]                       invisible(muffled)
[09:31:28.907]                     }
[09:31:28.907]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.907]                   }
[09:31:28.907]                 }
[09:31:28.907]                 else {
[09:31:28.907]                   if (TRUE) {
[09:31:28.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.907]                     {
[09:31:28.907]                       inherits <- base::inherits
[09:31:28.907]                       invokeRestart <- base::invokeRestart
[09:31:28.907]                       is.null <- base::is.null
[09:31:28.907]                       muffled <- FALSE
[09:31:28.907]                       if (inherits(cond, "message")) {
[09:31:28.907]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.907]                         if (muffled) 
[09:31:28.907]                           invokeRestart("muffleMessage")
[09:31:28.907]                       }
[09:31:28.907]                       else if (inherits(cond, "warning")) {
[09:31:28.907]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.907]                         if (muffled) 
[09:31:28.907]                           invokeRestart("muffleWarning")
[09:31:28.907]                       }
[09:31:28.907]                       else if (inherits(cond, "condition")) {
[09:31:28.907]                         if (!is.null(pattern)) {
[09:31:28.907]                           computeRestarts <- base::computeRestarts
[09:31:28.907]                           grepl <- base::grepl
[09:31:28.907]                           restarts <- computeRestarts(cond)
[09:31:28.907]                           for (restart in restarts) {
[09:31:28.907]                             name <- restart$name
[09:31:28.907]                             if (is.null(name)) 
[09:31:28.907]                               next
[09:31:28.907]                             if (!grepl(pattern, name)) 
[09:31:28.907]                               next
[09:31:28.907]                             invokeRestart(restart)
[09:31:28.907]                             muffled <- TRUE
[09:31:28.907]                             break
[09:31:28.907]                           }
[09:31:28.907]                         }
[09:31:28.907]                       }
[09:31:28.907]                       invisible(muffled)
[09:31:28.907]                     }
[09:31:28.907]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.907]                   }
[09:31:28.907]                 }
[09:31:28.907]             }
[09:31:28.907]         }))
[09:31:28.907]     }, error = function(ex) {
[09:31:28.907]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.907]                 ...future.rng), started = ...future.startTime, 
[09:31:28.907]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.907]             version = "1.8"), class = "FutureResult")
[09:31:28.907]     }, finally = {
[09:31:28.907]         if (!identical(...future.workdir, getwd())) 
[09:31:28.907]             setwd(...future.workdir)
[09:31:28.907]         {
[09:31:28.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.907]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.907]             }
[09:31:28.907]             base::options(...future.oldOptions)
[09:31:28.907]             if (.Platform$OS.type == "windows") {
[09:31:28.907]                 old_names <- names(...future.oldEnvVars)
[09:31:28.907]                 envs <- base::Sys.getenv()
[09:31:28.907]                 names <- names(envs)
[09:31:28.907]                 common <- intersect(names, old_names)
[09:31:28.907]                 added <- setdiff(names, old_names)
[09:31:28.907]                 removed <- setdiff(old_names, names)
[09:31:28.907]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.907]                   envs[common]]
[09:31:28.907]                 NAMES <- toupper(changed)
[09:31:28.907]                 args <- list()
[09:31:28.907]                 for (kk in seq_along(NAMES)) {
[09:31:28.907]                   name <- changed[[kk]]
[09:31:28.907]                   NAME <- NAMES[[kk]]
[09:31:28.907]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.907]                     next
[09:31:28.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.907]                 }
[09:31:28.907]                 NAMES <- toupper(added)
[09:31:28.907]                 for (kk in seq_along(NAMES)) {
[09:31:28.907]                   name <- added[[kk]]
[09:31:28.907]                   NAME <- NAMES[[kk]]
[09:31:28.907]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.907]                     next
[09:31:28.907]                   args[[name]] <- ""
[09:31:28.907]                 }
[09:31:28.907]                 NAMES <- toupper(removed)
[09:31:28.907]                 for (kk in seq_along(NAMES)) {
[09:31:28.907]                   name <- removed[[kk]]
[09:31:28.907]                   NAME <- NAMES[[kk]]
[09:31:28.907]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.907]                     next
[09:31:28.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.907]                 }
[09:31:28.907]                 if (length(args) > 0) 
[09:31:28.907]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.907]             }
[09:31:28.907]             else {
[09:31:28.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.907]             }
[09:31:28.907]             {
[09:31:28.907]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.907]                   0L) {
[09:31:28.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.907]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.907]                   base::options(opts)
[09:31:28.907]                 }
[09:31:28.907]                 {
[09:31:28.907]                   {
[09:31:28.907]                     NULL
[09:31:28.907]                     RNGkind("Mersenne-Twister")
[09:31:28.907]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.907]                       inherits = FALSE)
[09:31:28.907]                   }
[09:31:28.907]                   options(future.plan = NULL)
[09:31:28.907]                   if (is.na(NA_character_)) 
[09:31:28.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.907]                     .init = FALSE)
[09:31:28.907]                 }
[09:31:28.907]             }
[09:31:28.907]         }
[09:31:28.907]     })
[09:31:28.907]     if (TRUE) {
[09:31:28.907]         base::sink(type = "output", split = FALSE)
[09:31:28.907]         if (TRUE) {
[09:31:28.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.907]         }
[09:31:28.907]         else {
[09:31:28.907]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.907]         }
[09:31:28.907]         base::close(...future.stdout)
[09:31:28.907]         ...future.stdout <- NULL
[09:31:28.907]     }
[09:31:28.907]     ...future.result$conditions <- ...future.conditions
[09:31:28.907]     ...future.result$finished <- base::Sys.time()
[09:31:28.907]     ...future.result
[09:31:28.907] }
[09:31:28.909] plan(): Setting new future strategy stack:
[09:31:28.909] List of future strategies:
[09:31:28.909] 1. sequential:
[09:31:28.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.909]    - tweaked: FALSE
[09:31:28.909]    - call: NULL
[09:31:28.910] plan(): nbrOfWorkers() = 1
[09:31:28.911] plan(): Setting new future strategy stack:
[09:31:28.911] List of future strategies:
[09:31:28.911] 1. sequential:
[09:31:28.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.911]    - tweaked: FALSE
[09:31:28.911]    - call: plan(strategy)
[09:31:28.911] plan(): nbrOfWorkers() = 1
[09:31:28.911] SequentialFuture started (and completed)
[09:31:28.912] - Launch lazy future ... done
[09:31:28.912] run() for ‘SequentialFuture’ ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.912] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.912] Searching for globals...
[09:31:28.914] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.914] Searching for globals ... DONE
[09:31:28.914] Resolving globals: TRUE
[09:31:28.914] Resolving any globals that are futures ...
[09:31:28.914] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.914] Resolving any globals that are futures ... DONE
[09:31:28.915] Resolving futures part of globals (recursively) ...
[09:31:28.915] resolve() on list ...
[09:31:28.915]  recursive: 99
[09:31:28.915]  length: 1
[09:31:28.915]  elements: ‘x’
[09:31:28.915]  length: 0 (resolved future 1)
[09:31:28.915] resolve() on list ... DONE
[09:31:28.916] - globals: [1] ‘x’
[09:31:28.916] Resolving futures part of globals (recursively) ... DONE
[09:31:28.916] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.916] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.916] - globals: [1] ‘x’
[09:31:28.916] 
[09:31:28.916] getGlobalsAndPackages() ... DONE
[09:31:28.917] run() for ‘Future’ ...
[09:31:28.917] - state: ‘created’
[09:31:28.917] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.917] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.917]   - Field: ‘label’
[09:31:28.917]   - Field: ‘local’
[09:31:28.917]   - Field: ‘owner’
[09:31:28.917]   - Field: ‘envir’
[09:31:28.918]   - Field: ‘packages’
[09:31:28.918]   - Field: ‘gc’
[09:31:28.918]   - Field: ‘conditions’
[09:31:28.918]   - Field: ‘expr’
[09:31:28.918]   - Field: ‘uuid’
[09:31:28.918]   - Field: ‘seed’
[09:31:28.918]   - Field: ‘version’
[09:31:28.918]   - Field: ‘result’
[09:31:28.918]   - Field: ‘asynchronous’
[09:31:28.918]   - Field: ‘calls’
[09:31:28.918]   - Field: ‘globals’
[09:31:28.918]   - Field: ‘stdout’
[09:31:28.919]   - Field: ‘earlySignal’
[09:31:28.919]   - Field: ‘lazy’
[09:31:28.919]   - Field: ‘state’
[09:31:28.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.919] - Launch lazy future ...
[09:31:28.919] Packages needed by the future expression (n = 0): <none>
[09:31:28.919] Packages needed by future strategies (n = 0): <none>
[09:31:28.919] {
[09:31:28.919]     {
[09:31:28.919]         {
[09:31:28.919]             ...future.startTime <- base::Sys.time()
[09:31:28.919]             {
[09:31:28.919]                 {
[09:31:28.919]                   {
[09:31:28.919]                     base::local({
[09:31:28.919]                       has_future <- base::requireNamespace("future", 
[09:31:28.919]                         quietly = TRUE)
[09:31:28.919]                       if (has_future) {
[09:31:28.919]                         ns <- base::getNamespace("future")
[09:31:28.919]                         version <- ns[[".package"]][["version"]]
[09:31:28.919]                         if (is.null(version)) 
[09:31:28.919]                           version <- utils::packageVersion("future")
[09:31:28.919]                       }
[09:31:28.919]                       else {
[09:31:28.919]                         version <- NULL
[09:31:28.919]                       }
[09:31:28.919]                       if (!has_future || version < "1.8.0") {
[09:31:28.919]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.919]                           "", base::R.version$version.string), 
[09:31:28.919]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.919]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.919]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.919]                             "release", "version")], collapse = " "), 
[09:31:28.919]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.919]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.919]                           info)
[09:31:28.919]                         info <- base::paste(info, collapse = "; ")
[09:31:28.919]                         if (!has_future) {
[09:31:28.919]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.919]                             info)
[09:31:28.919]                         }
[09:31:28.919]                         else {
[09:31:28.919]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.919]                             info, version)
[09:31:28.919]                         }
[09:31:28.919]                         base::stop(msg)
[09:31:28.919]                       }
[09:31:28.919]                     })
[09:31:28.919]                   }
[09:31:28.919]                   ...future.strategy.old <- future::plan("list")
[09:31:28.919]                   options(future.plan = NULL)
[09:31:28.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.919]                 }
[09:31:28.919]                 ...future.workdir <- getwd()
[09:31:28.919]             }
[09:31:28.919]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.919]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.919]         }
[09:31:28.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.919]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.919]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.919]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.919]             base::names(...future.oldOptions))
[09:31:28.919]     }
[09:31:28.919]     if (FALSE) {
[09:31:28.919]     }
[09:31:28.919]     else {
[09:31:28.919]         if (TRUE) {
[09:31:28.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.919]                 open = "w")
[09:31:28.919]         }
[09:31:28.919]         else {
[09:31:28.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.919]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.919]         }
[09:31:28.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.919]             base::sink(type = "output", split = FALSE)
[09:31:28.919]             base::close(...future.stdout)
[09:31:28.919]         }, add = TRUE)
[09:31:28.919]     }
[09:31:28.919]     ...future.frame <- base::sys.nframe()
[09:31:28.919]     ...future.conditions <- base::list()
[09:31:28.919]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.919]     if (FALSE) {
[09:31:28.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.919]     }
[09:31:28.919]     ...future.result <- base::tryCatch({
[09:31:28.919]         base::withCallingHandlers({
[09:31:28.919]             ...future.value <- base::withVisible(base::local({
[09:31:28.919]                 x[["a"]] <- 1
[09:31:28.919]                 x
[09:31:28.919]             }))
[09:31:28.919]             future::FutureResult(value = ...future.value$value, 
[09:31:28.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.919]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.919]                     ...future.globalenv.names))
[09:31:28.919]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.919]         }, condition = base::local({
[09:31:28.919]             c <- base::c
[09:31:28.919]             inherits <- base::inherits
[09:31:28.919]             invokeRestart <- base::invokeRestart
[09:31:28.919]             length <- base::length
[09:31:28.919]             list <- base::list
[09:31:28.919]             seq.int <- base::seq.int
[09:31:28.919]             signalCondition <- base::signalCondition
[09:31:28.919]             sys.calls <- base::sys.calls
[09:31:28.919]             `[[` <- base::`[[`
[09:31:28.919]             `+` <- base::`+`
[09:31:28.919]             `<<-` <- base::`<<-`
[09:31:28.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.919]                   3L)]
[09:31:28.919]             }
[09:31:28.919]             function(cond) {
[09:31:28.919]                 is_error <- inherits(cond, "error")
[09:31:28.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.919]                   NULL)
[09:31:28.919]                 if (is_error) {
[09:31:28.919]                   sessionInformation <- function() {
[09:31:28.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.919]                       search = base::search(), system = base::Sys.info())
[09:31:28.919]                   }
[09:31:28.919]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.919]                     cond$call), session = sessionInformation(), 
[09:31:28.919]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.919]                   signalCondition(cond)
[09:31:28.919]                 }
[09:31:28.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.919]                 "immediateCondition"))) {
[09:31:28.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.919]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.919]                   if (TRUE && !signal) {
[09:31:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.919]                     {
[09:31:28.919]                       inherits <- base::inherits
[09:31:28.919]                       invokeRestart <- base::invokeRestart
[09:31:28.919]                       is.null <- base::is.null
[09:31:28.919]                       muffled <- FALSE
[09:31:28.919]                       if (inherits(cond, "message")) {
[09:31:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.919]                         if (muffled) 
[09:31:28.919]                           invokeRestart("muffleMessage")
[09:31:28.919]                       }
[09:31:28.919]                       else if (inherits(cond, "warning")) {
[09:31:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.919]                         if (muffled) 
[09:31:28.919]                           invokeRestart("muffleWarning")
[09:31:28.919]                       }
[09:31:28.919]                       else if (inherits(cond, "condition")) {
[09:31:28.919]                         if (!is.null(pattern)) {
[09:31:28.919]                           computeRestarts <- base::computeRestarts
[09:31:28.919]                           grepl <- base::grepl
[09:31:28.919]                           restarts <- computeRestarts(cond)
[09:31:28.919]                           for (restart in restarts) {
[09:31:28.919]                             name <- restart$name
[09:31:28.919]                             if (is.null(name)) 
[09:31:28.919]                               next
[09:31:28.919]                             if (!grepl(pattern, name)) 
[09:31:28.919]                               next
[09:31:28.919]                             invokeRestart(restart)
[09:31:28.919]                             muffled <- TRUE
[09:31:28.919]                             break
[09:31:28.919]                           }
[09:31:28.919]                         }
[09:31:28.919]                       }
[09:31:28.919]                       invisible(muffled)
[09:31:28.919]                     }
[09:31:28.919]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.919]                   }
[09:31:28.919]                 }
[09:31:28.919]                 else {
[09:31:28.919]                   if (TRUE) {
[09:31:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.919]                     {
[09:31:28.919]                       inherits <- base::inherits
[09:31:28.919]                       invokeRestart <- base::invokeRestart
[09:31:28.919]                       is.null <- base::is.null
[09:31:28.919]                       muffled <- FALSE
[09:31:28.919]                       if (inherits(cond, "message")) {
[09:31:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.919]                         if (muffled) 
[09:31:28.919]                           invokeRestart("muffleMessage")
[09:31:28.919]                       }
[09:31:28.919]                       else if (inherits(cond, "warning")) {
[09:31:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.919]                         if (muffled) 
[09:31:28.919]                           invokeRestart("muffleWarning")
[09:31:28.919]                       }
[09:31:28.919]                       else if (inherits(cond, "condition")) {
[09:31:28.919]                         if (!is.null(pattern)) {
[09:31:28.919]                           computeRestarts <- base::computeRestarts
[09:31:28.919]                           grepl <- base::grepl
[09:31:28.919]                           restarts <- computeRestarts(cond)
[09:31:28.919]                           for (restart in restarts) {
[09:31:28.919]                             name <- restart$name
[09:31:28.919]                             if (is.null(name)) 
[09:31:28.919]                               next
[09:31:28.919]                             if (!grepl(pattern, name)) 
[09:31:28.919]                               next
[09:31:28.919]                             invokeRestart(restart)
[09:31:28.919]                             muffled <- TRUE
[09:31:28.919]                             break
[09:31:28.919]                           }
[09:31:28.919]                         }
[09:31:28.919]                       }
[09:31:28.919]                       invisible(muffled)
[09:31:28.919]                     }
[09:31:28.919]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.919]                   }
[09:31:28.919]                 }
[09:31:28.919]             }
[09:31:28.919]         }))
[09:31:28.919]     }, error = function(ex) {
[09:31:28.919]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.919]                 ...future.rng), started = ...future.startTime, 
[09:31:28.919]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.919]             version = "1.8"), class = "FutureResult")
[09:31:28.919]     }, finally = {
[09:31:28.919]         if (!identical(...future.workdir, getwd())) 
[09:31:28.919]             setwd(...future.workdir)
[09:31:28.919]         {
[09:31:28.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.919]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.919]             }
[09:31:28.919]             base::options(...future.oldOptions)
[09:31:28.919]             if (.Platform$OS.type == "windows") {
[09:31:28.919]                 old_names <- names(...future.oldEnvVars)
[09:31:28.919]                 envs <- base::Sys.getenv()
[09:31:28.919]                 names <- names(envs)
[09:31:28.919]                 common <- intersect(names, old_names)
[09:31:28.919]                 added <- setdiff(names, old_names)
[09:31:28.919]                 removed <- setdiff(old_names, names)
[09:31:28.919]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.919]                   envs[common]]
[09:31:28.919]                 NAMES <- toupper(changed)
[09:31:28.919]                 args <- list()
[09:31:28.919]                 for (kk in seq_along(NAMES)) {
[09:31:28.919]                   name <- changed[[kk]]
[09:31:28.919]                   NAME <- NAMES[[kk]]
[09:31:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.919]                     next
[09:31:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.919]                 }
[09:31:28.919]                 NAMES <- toupper(added)
[09:31:28.919]                 for (kk in seq_along(NAMES)) {
[09:31:28.919]                   name <- added[[kk]]
[09:31:28.919]                   NAME <- NAMES[[kk]]
[09:31:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.919]                     next
[09:31:28.919]                   args[[name]] <- ""
[09:31:28.919]                 }
[09:31:28.919]                 NAMES <- toupper(removed)
[09:31:28.919]                 for (kk in seq_along(NAMES)) {
[09:31:28.919]                   name <- removed[[kk]]
[09:31:28.919]                   NAME <- NAMES[[kk]]
[09:31:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.919]                     next
[09:31:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.919]                 }
[09:31:28.919]                 if (length(args) > 0) 
[09:31:28.919]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.919]             }
[09:31:28.919]             else {
[09:31:28.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.919]             }
[09:31:28.919]             {
[09:31:28.919]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.919]                   0L) {
[09:31:28.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.919]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.919]                   base::options(opts)
[09:31:28.919]                 }
[09:31:28.919]                 {
[09:31:28.919]                   {
[09:31:28.919]                     NULL
[09:31:28.919]                     RNGkind("Mersenne-Twister")
[09:31:28.919]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.919]                       inherits = FALSE)
[09:31:28.919]                   }
[09:31:28.919]                   options(future.plan = NULL)
[09:31:28.919]                   if (is.na(NA_character_)) 
[09:31:28.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.919]                     .init = FALSE)
[09:31:28.919]                 }
[09:31:28.919]             }
[09:31:28.919]         }
[09:31:28.919]     })
[09:31:28.919]     if (TRUE) {
[09:31:28.919]         base::sink(type = "output", split = FALSE)
[09:31:28.919]         if (TRUE) {
[09:31:28.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.919]         }
[09:31:28.919]         else {
[09:31:28.919]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.919]         }
[09:31:28.919]         base::close(...future.stdout)
[09:31:28.919]         ...future.stdout <- NULL
[09:31:28.919]     }
[09:31:28.919]     ...future.result$conditions <- ...future.conditions
[09:31:28.919]     ...future.result$finished <- base::Sys.time()
[09:31:28.919]     ...future.result
[09:31:28.919] }
[09:31:28.921] assign_globals() ...
[09:31:28.921] List of 1
[09:31:28.921]  $ x: list()
[09:31:28.921]  - attr(*, "where")=List of 1
[09:31:28.921]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.921]  - attr(*, "resolved")= logi TRUE
[09:31:28.921]  - attr(*, "total_size")= num 0
[09:31:28.921]  - attr(*, "already-done")= logi TRUE
[09:31:28.923] - copied ‘x’ to environment
[09:31:28.923] assign_globals() ... done
[09:31:28.923] plan(): Setting new future strategy stack:
[09:31:28.924] List of future strategies:
[09:31:28.924] 1. sequential:
[09:31:28.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.924]    - tweaked: FALSE
[09:31:28.924]    - call: NULL
[09:31:28.924] plan(): nbrOfWorkers() = 1
[09:31:28.925] plan(): Setting new future strategy stack:
[09:31:28.925] List of future strategies:
[09:31:28.925] 1. sequential:
[09:31:28.925]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.925]    - tweaked: FALSE
[09:31:28.925]    - call: plan(strategy)
[09:31:28.925] plan(): nbrOfWorkers() = 1
[09:31:28.925] SequentialFuture started (and completed)
[09:31:28.925] - Launch lazy future ... done
[09:31:28.926] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.926] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.926] Searching for globals...
[09:31:28.928] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.928] Searching for globals ... DONE
[09:31:28.928] Resolving globals: TRUE
[09:31:28.928] Resolving any globals that are futures ...
[09:31:28.928] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.928] Resolving any globals that are futures ... DONE
[09:31:28.929] Resolving futures part of globals (recursively) ...
[09:31:28.929] resolve() on list ...
[09:31:28.929]  recursive: 99
[09:31:28.929]  length: 1
[09:31:28.929]  elements: ‘x’
[09:31:28.929]  length: 0 (resolved future 1)
[09:31:28.929] resolve() on list ... DONE
[09:31:28.929] - globals: [1] ‘x’
[09:31:28.929] Resolving futures part of globals (recursively) ... DONE
[09:31:28.930] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.930] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.930] - globals: [1] ‘x’
[09:31:28.930] 
[09:31:28.930] getGlobalsAndPackages() ... DONE
[09:31:28.930] run() for ‘Future’ ...
[09:31:28.930] - state: ‘created’
[09:31:28.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.931] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.931] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.931]   - Field: ‘label’
[09:31:28.931]   - Field: ‘local’
[09:31:28.931]   - Field: ‘owner’
[09:31:28.931]   - Field: ‘envir’
[09:31:28.931]   - Field: ‘packages’
[09:31:28.931]   - Field: ‘gc’
[09:31:28.931]   - Field: ‘conditions’
[09:31:28.932]   - Field: ‘expr’
[09:31:28.932]   - Field: ‘uuid’
[09:31:28.932]   - Field: ‘seed’
[09:31:28.932]   - Field: ‘version’
[09:31:28.932]   - Field: ‘result’
[09:31:28.932]   - Field: ‘asynchronous’
[09:31:28.932]   - Field: ‘calls’
[09:31:28.932]   - Field: ‘globals’
[09:31:28.932]   - Field: ‘stdout’
[09:31:28.932]   - Field: ‘earlySignal’
[09:31:28.932]   - Field: ‘lazy’
[09:31:28.933]   - Field: ‘state’
[09:31:28.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.933] - Launch lazy future ...
[09:31:28.933] Packages needed by the future expression (n = 0): <none>
[09:31:28.933] Packages needed by future strategies (n = 0): <none>
[09:31:28.933] {
[09:31:28.933]     {
[09:31:28.933]         {
[09:31:28.933]             ...future.startTime <- base::Sys.time()
[09:31:28.933]             {
[09:31:28.933]                 {
[09:31:28.933]                   {
[09:31:28.933]                     base::local({
[09:31:28.933]                       has_future <- base::requireNamespace("future", 
[09:31:28.933]                         quietly = TRUE)
[09:31:28.933]                       if (has_future) {
[09:31:28.933]                         ns <- base::getNamespace("future")
[09:31:28.933]                         version <- ns[[".package"]][["version"]]
[09:31:28.933]                         if (is.null(version)) 
[09:31:28.933]                           version <- utils::packageVersion("future")
[09:31:28.933]                       }
[09:31:28.933]                       else {
[09:31:28.933]                         version <- NULL
[09:31:28.933]                       }
[09:31:28.933]                       if (!has_future || version < "1.8.0") {
[09:31:28.933]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.933]                           "", base::R.version$version.string), 
[09:31:28.933]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.933]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.933]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.933]                             "release", "version")], collapse = " "), 
[09:31:28.933]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.933]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.933]                           info)
[09:31:28.933]                         info <- base::paste(info, collapse = "; ")
[09:31:28.933]                         if (!has_future) {
[09:31:28.933]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.933]                             info)
[09:31:28.933]                         }
[09:31:28.933]                         else {
[09:31:28.933]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.933]                             info, version)
[09:31:28.933]                         }
[09:31:28.933]                         base::stop(msg)
[09:31:28.933]                       }
[09:31:28.933]                     })
[09:31:28.933]                   }
[09:31:28.933]                   ...future.strategy.old <- future::plan("list")
[09:31:28.933]                   options(future.plan = NULL)
[09:31:28.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.933]                 }
[09:31:28.933]                 ...future.workdir <- getwd()
[09:31:28.933]             }
[09:31:28.933]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.933]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.933]         }
[09:31:28.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.933]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.933]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.933]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.933]             base::names(...future.oldOptions))
[09:31:28.933]     }
[09:31:28.933]     if (FALSE) {
[09:31:28.933]     }
[09:31:28.933]     else {
[09:31:28.933]         if (TRUE) {
[09:31:28.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.933]                 open = "w")
[09:31:28.933]         }
[09:31:28.933]         else {
[09:31:28.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.933]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.933]         }
[09:31:28.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.933]             base::sink(type = "output", split = FALSE)
[09:31:28.933]             base::close(...future.stdout)
[09:31:28.933]         }, add = TRUE)
[09:31:28.933]     }
[09:31:28.933]     ...future.frame <- base::sys.nframe()
[09:31:28.933]     ...future.conditions <- base::list()
[09:31:28.933]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.933]     if (FALSE) {
[09:31:28.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.933]     }
[09:31:28.933]     ...future.result <- base::tryCatch({
[09:31:28.933]         base::withCallingHandlers({
[09:31:28.933]             ...future.value <- base::withVisible(base::local({
[09:31:28.933]                 x[["a"]] <- 1
[09:31:28.933]                 x
[09:31:28.933]             }))
[09:31:28.933]             future::FutureResult(value = ...future.value$value, 
[09:31:28.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.933]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.933]                     ...future.globalenv.names))
[09:31:28.933]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.933]         }, condition = base::local({
[09:31:28.933]             c <- base::c
[09:31:28.933]             inherits <- base::inherits
[09:31:28.933]             invokeRestart <- base::invokeRestart
[09:31:28.933]             length <- base::length
[09:31:28.933]             list <- base::list
[09:31:28.933]             seq.int <- base::seq.int
[09:31:28.933]             signalCondition <- base::signalCondition
[09:31:28.933]             sys.calls <- base::sys.calls
[09:31:28.933]             `[[` <- base::`[[`
[09:31:28.933]             `+` <- base::`+`
[09:31:28.933]             `<<-` <- base::`<<-`
[09:31:28.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.933]                   3L)]
[09:31:28.933]             }
[09:31:28.933]             function(cond) {
[09:31:28.933]                 is_error <- inherits(cond, "error")
[09:31:28.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.933]                   NULL)
[09:31:28.933]                 if (is_error) {
[09:31:28.933]                   sessionInformation <- function() {
[09:31:28.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.933]                       search = base::search(), system = base::Sys.info())
[09:31:28.933]                   }
[09:31:28.933]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.933]                     cond$call), session = sessionInformation(), 
[09:31:28.933]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.933]                   signalCondition(cond)
[09:31:28.933]                 }
[09:31:28.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.933]                 "immediateCondition"))) {
[09:31:28.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.933]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.933]                   if (TRUE && !signal) {
[09:31:28.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.933]                     {
[09:31:28.933]                       inherits <- base::inherits
[09:31:28.933]                       invokeRestart <- base::invokeRestart
[09:31:28.933]                       is.null <- base::is.null
[09:31:28.933]                       muffled <- FALSE
[09:31:28.933]                       if (inherits(cond, "message")) {
[09:31:28.933]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.933]                         if (muffled) 
[09:31:28.933]                           invokeRestart("muffleMessage")
[09:31:28.933]                       }
[09:31:28.933]                       else if (inherits(cond, "warning")) {
[09:31:28.933]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.933]                         if (muffled) 
[09:31:28.933]                           invokeRestart("muffleWarning")
[09:31:28.933]                       }
[09:31:28.933]                       else if (inherits(cond, "condition")) {
[09:31:28.933]                         if (!is.null(pattern)) {
[09:31:28.933]                           computeRestarts <- base::computeRestarts
[09:31:28.933]                           grepl <- base::grepl
[09:31:28.933]                           restarts <- computeRestarts(cond)
[09:31:28.933]                           for (restart in restarts) {
[09:31:28.933]                             name <- restart$name
[09:31:28.933]                             if (is.null(name)) 
[09:31:28.933]                               next
[09:31:28.933]                             if (!grepl(pattern, name)) 
[09:31:28.933]                               next
[09:31:28.933]                             invokeRestart(restart)
[09:31:28.933]                             muffled <- TRUE
[09:31:28.933]                             break
[09:31:28.933]                           }
[09:31:28.933]                         }
[09:31:28.933]                       }
[09:31:28.933]                       invisible(muffled)
[09:31:28.933]                     }
[09:31:28.933]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.933]                   }
[09:31:28.933]                 }
[09:31:28.933]                 else {
[09:31:28.933]                   if (TRUE) {
[09:31:28.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.933]                     {
[09:31:28.933]                       inherits <- base::inherits
[09:31:28.933]                       invokeRestart <- base::invokeRestart
[09:31:28.933]                       is.null <- base::is.null
[09:31:28.933]                       muffled <- FALSE
[09:31:28.933]                       if (inherits(cond, "message")) {
[09:31:28.933]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.933]                         if (muffled) 
[09:31:28.933]                           invokeRestart("muffleMessage")
[09:31:28.933]                       }
[09:31:28.933]                       else if (inherits(cond, "warning")) {
[09:31:28.933]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.933]                         if (muffled) 
[09:31:28.933]                           invokeRestart("muffleWarning")
[09:31:28.933]                       }
[09:31:28.933]                       else if (inherits(cond, "condition")) {
[09:31:28.933]                         if (!is.null(pattern)) {
[09:31:28.933]                           computeRestarts <- base::computeRestarts
[09:31:28.933]                           grepl <- base::grepl
[09:31:28.933]                           restarts <- computeRestarts(cond)
[09:31:28.933]                           for (restart in restarts) {
[09:31:28.933]                             name <- restart$name
[09:31:28.933]                             if (is.null(name)) 
[09:31:28.933]                               next
[09:31:28.933]                             if (!grepl(pattern, name)) 
[09:31:28.933]                               next
[09:31:28.933]                             invokeRestart(restart)
[09:31:28.933]                             muffled <- TRUE
[09:31:28.933]                             break
[09:31:28.933]                           }
[09:31:28.933]                         }
[09:31:28.933]                       }
[09:31:28.933]                       invisible(muffled)
[09:31:28.933]                     }
[09:31:28.933]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.933]                   }
[09:31:28.933]                 }
[09:31:28.933]             }
[09:31:28.933]         }))
[09:31:28.933]     }, error = function(ex) {
[09:31:28.933]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.933]                 ...future.rng), started = ...future.startTime, 
[09:31:28.933]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.933]             version = "1.8"), class = "FutureResult")
[09:31:28.933]     }, finally = {
[09:31:28.933]         if (!identical(...future.workdir, getwd())) 
[09:31:28.933]             setwd(...future.workdir)
[09:31:28.933]         {
[09:31:28.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.933]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.933]             }
[09:31:28.933]             base::options(...future.oldOptions)
[09:31:28.933]             if (.Platform$OS.type == "windows") {
[09:31:28.933]                 old_names <- names(...future.oldEnvVars)
[09:31:28.933]                 envs <- base::Sys.getenv()
[09:31:28.933]                 names <- names(envs)
[09:31:28.933]                 common <- intersect(names, old_names)
[09:31:28.933]                 added <- setdiff(names, old_names)
[09:31:28.933]                 removed <- setdiff(old_names, names)
[09:31:28.933]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.933]                   envs[common]]
[09:31:28.933]                 NAMES <- toupper(changed)
[09:31:28.933]                 args <- list()
[09:31:28.933]                 for (kk in seq_along(NAMES)) {
[09:31:28.933]                   name <- changed[[kk]]
[09:31:28.933]                   NAME <- NAMES[[kk]]
[09:31:28.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.933]                     next
[09:31:28.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.933]                 }
[09:31:28.933]                 NAMES <- toupper(added)
[09:31:28.933]                 for (kk in seq_along(NAMES)) {
[09:31:28.933]                   name <- added[[kk]]
[09:31:28.933]                   NAME <- NAMES[[kk]]
[09:31:28.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.933]                     next
[09:31:28.933]                   args[[name]] <- ""
[09:31:28.933]                 }
[09:31:28.933]                 NAMES <- toupper(removed)
[09:31:28.933]                 for (kk in seq_along(NAMES)) {
[09:31:28.933]                   name <- removed[[kk]]
[09:31:28.933]                   NAME <- NAMES[[kk]]
[09:31:28.933]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.933]                     next
[09:31:28.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.933]                 }
[09:31:28.933]                 if (length(args) > 0) 
[09:31:28.933]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.933]             }
[09:31:28.933]             else {
[09:31:28.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.933]             }
[09:31:28.933]             {
[09:31:28.933]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.933]                   0L) {
[09:31:28.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.933]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.933]                   base::options(opts)
[09:31:28.933]                 }
[09:31:28.933]                 {
[09:31:28.933]                   {
[09:31:28.933]                     NULL
[09:31:28.933]                     RNGkind("Mersenne-Twister")
[09:31:28.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.933]                       inherits = FALSE)
[09:31:28.933]                   }
[09:31:28.933]                   options(future.plan = NULL)
[09:31:28.933]                   if (is.na(NA_character_)) 
[09:31:28.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.933]                     .init = FALSE)
[09:31:28.933]                 }
[09:31:28.933]             }
[09:31:28.933]         }
[09:31:28.933]     })
[09:31:28.933]     if (TRUE) {
[09:31:28.933]         base::sink(type = "output", split = FALSE)
[09:31:28.933]         if (TRUE) {
[09:31:28.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.933]         }
[09:31:28.933]         else {
[09:31:28.933]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.933]         }
[09:31:28.933]         base::close(...future.stdout)
[09:31:28.933]         ...future.stdout <- NULL
[09:31:28.933]     }
[09:31:28.933]     ...future.result$conditions <- ...future.conditions
[09:31:28.933]     ...future.result$finished <- base::Sys.time()
[09:31:28.933]     ...future.result
[09:31:28.933] }
[09:31:28.935] assign_globals() ...
[09:31:28.935] List of 1
[09:31:28.935]  $ x: list()
[09:31:28.935]  - attr(*, "where")=List of 1
[09:31:28.935]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.935]  - attr(*, "resolved")= logi TRUE
[09:31:28.935]  - attr(*, "total_size")= num 0
[09:31:28.935]  - attr(*, "already-done")= logi TRUE
[09:31:28.938] - copied ‘x’ to environment
[09:31:28.938] assign_globals() ... done
[09:31:28.938] plan(): Setting new future strategy stack:
[09:31:28.938] List of future strategies:
[09:31:28.938] 1. sequential:
[09:31:28.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.938]    - tweaked: FALSE
[09:31:28.938]    - call: NULL
[09:31:28.939] plan(): nbrOfWorkers() = 1
[09:31:28.940] plan(): Setting new future strategy stack:
[09:31:28.940] List of future strategies:
[09:31:28.940] 1. sequential:
[09:31:28.940]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.940]    - tweaked: FALSE
[09:31:28.940]    - call: plan(strategy)
[09:31:28.940] plan(): nbrOfWorkers() = 1
[09:31:28.940] SequentialFuture started (and completed)
[09:31:28.940] - Launch lazy future ... done
[09:31:28.940] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.941] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.941] Searching for globals...
[09:31:28.943] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.943] Searching for globals ... DONE
[09:31:28.943] Resolving globals: TRUE
[09:31:28.943] Resolving any globals that are futures ...
[09:31:28.943] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:28.943] Resolving any globals that are futures ... DONE
[09:31:28.944] Resolving futures part of globals (recursively) ...
[09:31:28.944] resolve() on list ...
[09:31:28.944]  recursive: 99
[09:31:28.944]  length: 1
[09:31:28.944]  elements: ‘x’
[09:31:28.944]  length: 0 (resolved future 1)
[09:31:28.944] resolve() on list ... DONE
[09:31:28.944] - globals: [1] ‘x’
[09:31:28.944] Resolving futures part of globals (recursively) ... DONE
[09:31:28.945] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.945] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.945] - globals: [1] ‘x’
[09:31:28.945] 
[09:31:28.945] getGlobalsAndPackages() ... DONE
[09:31:28.945] run() for ‘Future’ ...
[09:31:28.945] - state: ‘created’
[09:31:28.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.946]   - Field: ‘label’
[09:31:28.946]   - Field: ‘local’
[09:31:28.946]   - Field: ‘owner’
[09:31:28.946]   - Field: ‘envir’
[09:31:28.946]   - Field: ‘packages’
[09:31:28.946]   - Field: ‘gc’
[09:31:28.946]   - Field: ‘conditions’
[09:31:28.947]   - Field: ‘expr’
[09:31:28.947]   - Field: ‘uuid’
[09:31:28.947]   - Field: ‘seed’
[09:31:28.947]   - Field: ‘version’
[09:31:28.947]   - Field: ‘result’
[09:31:28.947]   - Field: ‘asynchronous’
[09:31:28.947]   - Field: ‘calls’
[09:31:28.947]   - Field: ‘globals’
[09:31:28.947]   - Field: ‘stdout’
[09:31:28.947]   - Field: ‘earlySignal’
[09:31:28.947]   - Field: ‘lazy’
[09:31:28.947]   - Field: ‘state’
[09:31:28.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.948] - Launch lazy future ...
[09:31:28.948] Packages needed by the future expression (n = 0): <none>
[09:31:28.948] Packages needed by future strategies (n = 0): <none>
[09:31:28.948] {
[09:31:28.948]     {
[09:31:28.948]         {
[09:31:28.948]             ...future.startTime <- base::Sys.time()
[09:31:28.948]             {
[09:31:28.948]                 {
[09:31:28.948]                   {
[09:31:28.948]                     base::local({
[09:31:28.948]                       has_future <- base::requireNamespace("future", 
[09:31:28.948]                         quietly = TRUE)
[09:31:28.948]                       if (has_future) {
[09:31:28.948]                         ns <- base::getNamespace("future")
[09:31:28.948]                         version <- ns[[".package"]][["version"]]
[09:31:28.948]                         if (is.null(version)) 
[09:31:28.948]                           version <- utils::packageVersion("future")
[09:31:28.948]                       }
[09:31:28.948]                       else {
[09:31:28.948]                         version <- NULL
[09:31:28.948]                       }
[09:31:28.948]                       if (!has_future || version < "1.8.0") {
[09:31:28.948]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.948]                           "", base::R.version$version.string), 
[09:31:28.948]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.948]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.948]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.948]                             "release", "version")], collapse = " "), 
[09:31:28.948]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.948]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.948]                           info)
[09:31:28.948]                         info <- base::paste(info, collapse = "; ")
[09:31:28.948]                         if (!has_future) {
[09:31:28.948]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.948]                             info)
[09:31:28.948]                         }
[09:31:28.948]                         else {
[09:31:28.948]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.948]                             info, version)
[09:31:28.948]                         }
[09:31:28.948]                         base::stop(msg)
[09:31:28.948]                       }
[09:31:28.948]                     })
[09:31:28.948]                   }
[09:31:28.948]                   ...future.strategy.old <- future::plan("list")
[09:31:28.948]                   options(future.plan = NULL)
[09:31:28.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.948]                 }
[09:31:28.948]                 ...future.workdir <- getwd()
[09:31:28.948]             }
[09:31:28.948]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.948]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.948]         }
[09:31:28.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.948]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.948]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.948]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.948]             base::names(...future.oldOptions))
[09:31:28.948]     }
[09:31:28.948]     if (FALSE) {
[09:31:28.948]     }
[09:31:28.948]     else {
[09:31:28.948]         if (TRUE) {
[09:31:28.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.948]                 open = "w")
[09:31:28.948]         }
[09:31:28.948]         else {
[09:31:28.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.948]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.948]         }
[09:31:28.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.948]             base::sink(type = "output", split = FALSE)
[09:31:28.948]             base::close(...future.stdout)
[09:31:28.948]         }, add = TRUE)
[09:31:28.948]     }
[09:31:28.948]     ...future.frame <- base::sys.nframe()
[09:31:28.948]     ...future.conditions <- base::list()
[09:31:28.948]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.948]     if (FALSE) {
[09:31:28.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.948]     }
[09:31:28.948]     ...future.result <- base::tryCatch({
[09:31:28.948]         base::withCallingHandlers({
[09:31:28.948]             ...future.value <- base::withVisible(base::local({
[09:31:28.948]                 x[["a"]] <- 1
[09:31:28.948]                 x
[09:31:28.948]             }))
[09:31:28.948]             future::FutureResult(value = ...future.value$value, 
[09:31:28.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.948]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.948]                     ...future.globalenv.names))
[09:31:28.948]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.948]         }, condition = base::local({
[09:31:28.948]             c <- base::c
[09:31:28.948]             inherits <- base::inherits
[09:31:28.948]             invokeRestart <- base::invokeRestart
[09:31:28.948]             length <- base::length
[09:31:28.948]             list <- base::list
[09:31:28.948]             seq.int <- base::seq.int
[09:31:28.948]             signalCondition <- base::signalCondition
[09:31:28.948]             sys.calls <- base::sys.calls
[09:31:28.948]             `[[` <- base::`[[`
[09:31:28.948]             `+` <- base::`+`
[09:31:28.948]             `<<-` <- base::`<<-`
[09:31:28.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.948]                   3L)]
[09:31:28.948]             }
[09:31:28.948]             function(cond) {
[09:31:28.948]                 is_error <- inherits(cond, "error")
[09:31:28.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.948]                   NULL)
[09:31:28.948]                 if (is_error) {
[09:31:28.948]                   sessionInformation <- function() {
[09:31:28.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.948]                       search = base::search(), system = base::Sys.info())
[09:31:28.948]                   }
[09:31:28.948]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.948]                     cond$call), session = sessionInformation(), 
[09:31:28.948]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.948]                   signalCondition(cond)
[09:31:28.948]                 }
[09:31:28.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.948]                 "immediateCondition"))) {
[09:31:28.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.948]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.948]                   if (TRUE && !signal) {
[09:31:28.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.948]                     {
[09:31:28.948]                       inherits <- base::inherits
[09:31:28.948]                       invokeRestart <- base::invokeRestart
[09:31:28.948]                       is.null <- base::is.null
[09:31:28.948]                       muffled <- FALSE
[09:31:28.948]                       if (inherits(cond, "message")) {
[09:31:28.948]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.948]                         if (muffled) 
[09:31:28.948]                           invokeRestart("muffleMessage")
[09:31:28.948]                       }
[09:31:28.948]                       else if (inherits(cond, "warning")) {
[09:31:28.948]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.948]                         if (muffled) 
[09:31:28.948]                           invokeRestart("muffleWarning")
[09:31:28.948]                       }
[09:31:28.948]                       else if (inherits(cond, "condition")) {
[09:31:28.948]                         if (!is.null(pattern)) {
[09:31:28.948]                           computeRestarts <- base::computeRestarts
[09:31:28.948]                           grepl <- base::grepl
[09:31:28.948]                           restarts <- computeRestarts(cond)
[09:31:28.948]                           for (restart in restarts) {
[09:31:28.948]                             name <- restart$name
[09:31:28.948]                             if (is.null(name)) 
[09:31:28.948]                               next
[09:31:28.948]                             if (!grepl(pattern, name)) 
[09:31:28.948]                               next
[09:31:28.948]                             invokeRestart(restart)
[09:31:28.948]                             muffled <- TRUE
[09:31:28.948]                             break
[09:31:28.948]                           }
[09:31:28.948]                         }
[09:31:28.948]                       }
[09:31:28.948]                       invisible(muffled)
[09:31:28.948]                     }
[09:31:28.948]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.948]                   }
[09:31:28.948]                 }
[09:31:28.948]                 else {
[09:31:28.948]                   if (TRUE) {
[09:31:28.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.948]                     {
[09:31:28.948]                       inherits <- base::inherits
[09:31:28.948]                       invokeRestart <- base::invokeRestart
[09:31:28.948]                       is.null <- base::is.null
[09:31:28.948]                       muffled <- FALSE
[09:31:28.948]                       if (inherits(cond, "message")) {
[09:31:28.948]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.948]                         if (muffled) 
[09:31:28.948]                           invokeRestart("muffleMessage")
[09:31:28.948]                       }
[09:31:28.948]                       else if (inherits(cond, "warning")) {
[09:31:28.948]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.948]                         if (muffled) 
[09:31:28.948]                           invokeRestart("muffleWarning")
[09:31:28.948]                       }
[09:31:28.948]                       else if (inherits(cond, "condition")) {
[09:31:28.948]                         if (!is.null(pattern)) {
[09:31:28.948]                           computeRestarts <- base::computeRestarts
[09:31:28.948]                           grepl <- base::grepl
[09:31:28.948]                           restarts <- computeRestarts(cond)
[09:31:28.948]                           for (restart in restarts) {
[09:31:28.948]                             name <- restart$name
[09:31:28.948]                             if (is.null(name)) 
[09:31:28.948]                               next
[09:31:28.948]                             if (!grepl(pattern, name)) 
[09:31:28.948]                               next
[09:31:28.948]                             invokeRestart(restart)
[09:31:28.948]                             muffled <- TRUE
[09:31:28.948]                             break
[09:31:28.948]                           }
[09:31:28.948]                         }
[09:31:28.948]                       }
[09:31:28.948]                       invisible(muffled)
[09:31:28.948]                     }
[09:31:28.948]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.948]                   }
[09:31:28.948]                 }
[09:31:28.948]             }
[09:31:28.948]         }))
[09:31:28.948]     }, error = function(ex) {
[09:31:28.948]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.948]                 ...future.rng), started = ...future.startTime, 
[09:31:28.948]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.948]             version = "1.8"), class = "FutureResult")
[09:31:28.948]     }, finally = {
[09:31:28.948]         if (!identical(...future.workdir, getwd())) 
[09:31:28.948]             setwd(...future.workdir)
[09:31:28.948]         {
[09:31:28.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.948]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.948]             }
[09:31:28.948]             base::options(...future.oldOptions)
[09:31:28.948]             if (.Platform$OS.type == "windows") {
[09:31:28.948]                 old_names <- names(...future.oldEnvVars)
[09:31:28.948]                 envs <- base::Sys.getenv()
[09:31:28.948]                 names <- names(envs)
[09:31:28.948]                 common <- intersect(names, old_names)
[09:31:28.948]                 added <- setdiff(names, old_names)
[09:31:28.948]                 removed <- setdiff(old_names, names)
[09:31:28.948]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.948]                   envs[common]]
[09:31:28.948]                 NAMES <- toupper(changed)
[09:31:28.948]                 args <- list()
[09:31:28.948]                 for (kk in seq_along(NAMES)) {
[09:31:28.948]                   name <- changed[[kk]]
[09:31:28.948]                   NAME <- NAMES[[kk]]
[09:31:28.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.948]                     next
[09:31:28.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.948]                 }
[09:31:28.948]                 NAMES <- toupper(added)
[09:31:28.948]                 for (kk in seq_along(NAMES)) {
[09:31:28.948]                   name <- added[[kk]]
[09:31:28.948]                   NAME <- NAMES[[kk]]
[09:31:28.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.948]                     next
[09:31:28.948]                   args[[name]] <- ""
[09:31:28.948]                 }
[09:31:28.948]                 NAMES <- toupper(removed)
[09:31:28.948]                 for (kk in seq_along(NAMES)) {
[09:31:28.948]                   name <- removed[[kk]]
[09:31:28.948]                   NAME <- NAMES[[kk]]
[09:31:28.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.948]                     next
[09:31:28.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.948]                 }
[09:31:28.948]                 if (length(args) > 0) 
[09:31:28.948]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.948]             }
[09:31:28.948]             else {
[09:31:28.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.948]             }
[09:31:28.948]             {
[09:31:28.948]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.948]                   0L) {
[09:31:28.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.948]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.948]                   base::options(opts)
[09:31:28.948]                 }
[09:31:28.948]                 {
[09:31:28.948]                   {
[09:31:28.948]                     NULL
[09:31:28.948]                     RNGkind("Mersenne-Twister")
[09:31:28.948]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.948]                       inherits = FALSE)
[09:31:28.948]                   }
[09:31:28.948]                   options(future.plan = NULL)
[09:31:28.948]                   if (is.na(NA_character_)) 
[09:31:28.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.948]                     .init = FALSE)
[09:31:28.948]                 }
[09:31:28.948]             }
[09:31:28.948]         }
[09:31:28.948]     })
[09:31:28.948]     if (TRUE) {
[09:31:28.948]         base::sink(type = "output", split = FALSE)
[09:31:28.948]         if (TRUE) {
[09:31:28.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.948]         }
[09:31:28.948]         else {
[09:31:28.948]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.948]         }
[09:31:28.948]         base::close(...future.stdout)
[09:31:28.948]         ...future.stdout <- NULL
[09:31:28.948]     }
[09:31:28.948]     ...future.result$conditions <- ...future.conditions
[09:31:28.948]     ...future.result$finished <- base::Sys.time()
[09:31:28.948]     ...future.result
[09:31:28.948] }
[09:31:28.950] assign_globals() ...
[09:31:28.950] List of 1
[09:31:28.950]  $ x: list()
[09:31:28.950]  - attr(*, "where")=List of 1
[09:31:28.950]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.950]  - attr(*, "resolved")= logi TRUE
[09:31:28.950]  - attr(*, "total_size")= num 0
[09:31:28.950]  - attr(*, "already-done")= logi TRUE
[09:31:28.952] - copied ‘x’ to environment
[09:31:28.952] assign_globals() ... done
[09:31:28.952] plan(): Setting new future strategy stack:
[09:31:28.952] List of future strategies:
[09:31:28.952] 1. sequential:
[09:31:28.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.952]    - tweaked: FALSE
[09:31:28.952]    - call: NULL
[09:31:28.953] plan(): nbrOfWorkers() = 1
[09:31:28.953] plan(): Setting new future strategy stack:
[09:31:28.954] List of future strategies:
[09:31:28.954] 1. sequential:
[09:31:28.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.954]    - tweaked: FALSE
[09:31:28.954]    - call: plan(strategy)
[09:31:28.954] plan(): nbrOfWorkers() = 1
[09:31:28.954] SequentialFuture started (and completed)
[09:31:28.954] - Launch lazy future ... done
[09:31:28.954] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.955] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.955] Searching for globals...
[09:31:28.957] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.957] Searching for globals ... DONE
[09:31:28.957] Resolving globals: TRUE
[09:31:28.957] Resolving any globals that are futures ...
[09:31:28.957] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.957] Resolving any globals that are futures ... DONE
[09:31:28.957] Resolving futures part of globals (recursively) ...
[09:31:28.958] resolve() on list ...
[09:31:28.958]  recursive: 99
[09:31:28.958]  length: 1
[09:31:28.958]  elements: ‘x’
[09:31:28.958]  length: 0 (resolved future 1)
[09:31:28.958] resolve() on list ... DONE
[09:31:28.958] - globals: [1] ‘x’
[09:31:28.958] Resolving futures part of globals (recursively) ... DONE
[09:31:28.958] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.959] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.959] - globals: [1] ‘x’
[09:31:28.959] 
[09:31:28.959] getGlobalsAndPackages() ... DONE
[09:31:28.959] run() for ‘Future’ ...
[09:31:28.959] - state: ‘created’
[09:31:28.959] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.960] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.960]   - Field: ‘label’
[09:31:28.960]   - Field: ‘local’
[09:31:28.960]   - Field: ‘owner’
[09:31:28.960]   - Field: ‘envir’
[09:31:28.960]   - Field: ‘packages’
[09:31:28.960]   - Field: ‘gc’
[09:31:28.960]   - Field: ‘conditions’
[09:31:28.960]   - Field: ‘expr’
[09:31:28.961]   - Field: ‘uuid’
[09:31:28.962]   - Field: ‘seed’
[09:31:28.962]   - Field: ‘version’
[09:31:28.962]   - Field: ‘result’
[09:31:28.962]   - Field: ‘asynchronous’
[09:31:28.962]   - Field: ‘calls’
[09:31:28.962]   - Field: ‘globals’
[09:31:28.962]   - Field: ‘stdout’
[09:31:28.962]   - Field: ‘earlySignal’
[09:31:28.962]   - Field: ‘lazy’
[09:31:28.962]   - Field: ‘state’
[09:31:28.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.962] - Launch lazy future ...
[09:31:28.963] Packages needed by the future expression (n = 0): <none>
[09:31:28.963] Packages needed by future strategies (n = 0): <none>
[09:31:28.963] {
[09:31:28.963]     {
[09:31:28.963]         {
[09:31:28.963]             ...future.startTime <- base::Sys.time()
[09:31:28.963]             {
[09:31:28.963]                 {
[09:31:28.963]                   {
[09:31:28.963]                     base::local({
[09:31:28.963]                       has_future <- base::requireNamespace("future", 
[09:31:28.963]                         quietly = TRUE)
[09:31:28.963]                       if (has_future) {
[09:31:28.963]                         ns <- base::getNamespace("future")
[09:31:28.963]                         version <- ns[[".package"]][["version"]]
[09:31:28.963]                         if (is.null(version)) 
[09:31:28.963]                           version <- utils::packageVersion("future")
[09:31:28.963]                       }
[09:31:28.963]                       else {
[09:31:28.963]                         version <- NULL
[09:31:28.963]                       }
[09:31:28.963]                       if (!has_future || version < "1.8.0") {
[09:31:28.963]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.963]                           "", base::R.version$version.string), 
[09:31:28.963]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.963]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.963]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.963]                             "release", "version")], collapse = " "), 
[09:31:28.963]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.963]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.963]                           info)
[09:31:28.963]                         info <- base::paste(info, collapse = "; ")
[09:31:28.963]                         if (!has_future) {
[09:31:28.963]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.963]                             info)
[09:31:28.963]                         }
[09:31:28.963]                         else {
[09:31:28.963]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.963]                             info, version)
[09:31:28.963]                         }
[09:31:28.963]                         base::stop(msg)
[09:31:28.963]                       }
[09:31:28.963]                     })
[09:31:28.963]                   }
[09:31:28.963]                   ...future.strategy.old <- future::plan("list")
[09:31:28.963]                   options(future.plan = NULL)
[09:31:28.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.963]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.963]                 }
[09:31:28.963]                 ...future.workdir <- getwd()
[09:31:28.963]             }
[09:31:28.963]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.963]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.963]         }
[09:31:28.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.963]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.963]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.963]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.963]             base::names(...future.oldOptions))
[09:31:28.963]     }
[09:31:28.963]     if (FALSE) {
[09:31:28.963]     }
[09:31:28.963]     else {
[09:31:28.963]         if (TRUE) {
[09:31:28.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.963]                 open = "w")
[09:31:28.963]         }
[09:31:28.963]         else {
[09:31:28.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.963]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.963]         }
[09:31:28.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.963]             base::sink(type = "output", split = FALSE)
[09:31:28.963]             base::close(...future.stdout)
[09:31:28.963]         }, add = TRUE)
[09:31:28.963]     }
[09:31:28.963]     ...future.frame <- base::sys.nframe()
[09:31:28.963]     ...future.conditions <- base::list()
[09:31:28.963]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.963]     if (FALSE) {
[09:31:28.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.963]     }
[09:31:28.963]     ...future.result <- base::tryCatch({
[09:31:28.963]         base::withCallingHandlers({
[09:31:28.963]             ...future.value <- base::withVisible(base::local({
[09:31:28.963]                 x["a"] <- list(1)
[09:31:28.963]                 x
[09:31:28.963]             }))
[09:31:28.963]             future::FutureResult(value = ...future.value$value, 
[09:31:28.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.963]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.963]                     ...future.globalenv.names))
[09:31:28.963]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.963]         }, condition = base::local({
[09:31:28.963]             c <- base::c
[09:31:28.963]             inherits <- base::inherits
[09:31:28.963]             invokeRestart <- base::invokeRestart
[09:31:28.963]             length <- base::length
[09:31:28.963]             list <- base::list
[09:31:28.963]             seq.int <- base::seq.int
[09:31:28.963]             signalCondition <- base::signalCondition
[09:31:28.963]             sys.calls <- base::sys.calls
[09:31:28.963]             `[[` <- base::`[[`
[09:31:28.963]             `+` <- base::`+`
[09:31:28.963]             `<<-` <- base::`<<-`
[09:31:28.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.963]                   3L)]
[09:31:28.963]             }
[09:31:28.963]             function(cond) {
[09:31:28.963]                 is_error <- inherits(cond, "error")
[09:31:28.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.963]                   NULL)
[09:31:28.963]                 if (is_error) {
[09:31:28.963]                   sessionInformation <- function() {
[09:31:28.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.963]                       search = base::search(), system = base::Sys.info())
[09:31:28.963]                   }
[09:31:28.963]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.963]                     cond$call), session = sessionInformation(), 
[09:31:28.963]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.963]                   signalCondition(cond)
[09:31:28.963]                 }
[09:31:28.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.963]                 "immediateCondition"))) {
[09:31:28.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.963]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.963]                   if (TRUE && !signal) {
[09:31:28.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.963]                     {
[09:31:28.963]                       inherits <- base::inherits
[09:31:28.963]                       invokeRestart <- base::invokeRestart
[09:31:28.963]                       is.null <- base::is.null
[09:31:28.963]                       muffled <- FALSE
[09:31:28.963]                       if (inherits(cond, "message")) {
[09:31:28.963]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.963]                         if (muffled) 
[09:31:28.963]                           invokeRestart("muffleMessage")
[09:31:28.963]                       }
[09:31:28.963]                       else if (inherits(cond, "warning")) {
[09:31:28.963]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.963]                         if (muffled) 
[09:31:28.963]                           invokeRestart("muffleWarning")
[09:31:28.963]                       }
[09:31:28.963]                       else if (inherits(cond, "condition")) {
[09:31:28.963]                         if (!is.null(pattern)) {
[09:31:28.963]                           computeRestarts <- base::computeRestarts
[09:31:28.963]                           grepl <- base::grepl
[09:31:28.963]                           restarts <- computeRestarts(cond)
[09:31:28.963]                           for (restart in restarts) {
[09:31:28.963]                             name <- restart$name
[09:31:28.963]                             if (is.null(name)) 
[09:31:28.963]                               next
[09:31:28.963]                             if (!grepl(pattern, name)) 
[09:31:28.963]                               next
[09:31:28.963]                             invokeRestart(restart)
[09:31:28.963]                             muffled <- TRUE
[09:31:28.963]                             break
[09:31:28.963]                           }
[09:31:28.963]                         }
[09:31:28.963]                       }
[09:31:28.963]                       invisible(muffled)
[09:31:28.963]                     }
[09:31:28.963]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.963]                   }
[09:31:28.963]                 }
[09:31:28.963]                 else {
[09:31:28.963]                   if (TRUE) {
[09:31:28.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.963]                     {
[09:31:28.963]                       inherits <- base::inherits
[09:31:28.963]                       invokeRestart <- base::invokeRestart
[09:31:28.963]                       is.null <- base::is.null
[09:31:28.963]                       muffled <- FALSE
[09:31:28.963]                       if (inherits(cond, "message")) {
[09:31:28.963]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.963]                         if (muffled) 
[09:31:28.963]                           invokeRestart("muffleMessage")
[09:31:28.963]                       }
[09:31:28.963]                       else if (inherits(cond, "warning")) {
[09:31:28.963]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.963]                         if (muffled) 
[09:31:28.963]                           invokeRestart("muffleWarning")
[09:31:28.963]                       }
[09:31:28.963]                       else if (inherits(cond, "condition")) {
[09:31:28.963]                         if (!is.null(pattern)) {
[09:31:28.963]                           computeRestarts <- base::computeRestarts
[09:31:28.963]                           grepl <- base::grepl
[09:31:28.963]                           restarts <- computeRestarts(cond)
[09:31:28.963]                           for (restart in restarts) {
[09:31:28.963]                             name <- restart$name
[09:31:28.963]                             if (is.null(name)) 
[09:31:28.963]                               next
[09:31:28.963]                             if (!grepl(pattern, name)) 
[09:31:28.963]                               next
[09:31:28.963]                             invokeRestart(restart)
[09:31:28.963]                             muffled <- TRUE
[09:31:28.963]                             break
[09:31:28.963]                           }
[09:31:28.963]                         }
[09:31:28.963]                       }
[09:31:28.963]                       invisible(muffled)
[09:31:28.963]                     }
[09:31:28.963]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.963]                   }
[09:31:28.963]                 }
[09:31:28.963]             }
[09:31:28.963]         }))
[09:31:28.963]     }, error = function(ex) {
[09:31:28.963]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.963]                 ...future.rng), started = ...future.startTime, 
[09:31:28.963]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.963]             version = "1.8"), class = "FutureResult")
[09:31:28.963]     }, finally = {
[09:31:28.963]         if (!identical(...future.workdir, getwd())) 
[09:31:28.963]             setwd(...future.workdir)
[09:31:28.963]         {
[09:31:28.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.963]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.963]             }
[09:31:28.963]             base::options(...future.oldOptions)
[09:31:28.963]             if (.Platform$OS.type == "windows") {
[09:31:28.963]                 old_names <- names(...future.oldEnvVars)
[09:31:28.963]                 envs <- base::Sys.getenv()
[09:31:28.963]                 names <- names(envs)
[09:31:28.963]                 common <- intersect(names, old_names)
[09:31:28.963]                 added <- setdiff(names, old_names)
[09:31:28.963]                 removed <- setdiff(old_names, names)
[09:31:28.963]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.963]                   envs[common]]
[09:31:28.963]                 NAMES <- toupper(changed)
[09:31:28.963]                 args <- list()
[09:31:28.963]                 for (kk in seq_along(NAMES)) {
[09:31:28.963]                   name <- changed[[kk]]
[09:31:28.963]                   NAME <- NAMES[[kk]]
[09:31:28.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.963]                     next
[09:31:28.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.963]                 }
[09:31:28.963]                 NAMES <- toupper(added)
[09:31:28.963]                 for (kk in seq_along(NAMES)) {
[09:31:28.963]                   name <- added[[kk]]
[09:31:28.963]                   NAME <- NAMES[[kk]]
[09:31:28.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.963]                     next
[09:31:28.963]                   args[[name]] <- ""
[09:31:28.963]                 }
[09:31:28.963]                 NAMES <- toupper(removed)
[09:31:28.963]                 for (kk in seq_along(NAMES)) {
[09:31:28.963]                   name <- removed[[kk]]
[09:31:28.963]                   NAME <- NAMES[[kk]]
[09:31:28.963]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.963]                     next
[09:31:28.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.963]                 }
[09:31:28.963]                 if (length(args) > 0) 
[09:31:28.963]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.963]             }
[09:31:28.963]             else {
[09:31:28.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.963]             }
[09:31:28.963]             {
[09:31:28.963]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.963]                   0L) {
[09:31:28.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.963]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.963]                   base::options(opts)
[09:31:28.963]                 }
[09:31:28.963]                 {
[09:31:28.963]                   {
[09:31:28.963]                     NULL
[09:31:28.963]                     RNGkind("Mersenne-Twister")
[09:31:28.963]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.963]                       inherits = FALSE)
[09:31:28.963]                   }
[09:31:28.963]                   options(future.plan = NULL)
[09:31:28.963]                   if (is.na(NA_character_)) 
[09:31:28.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.963]                     .init = FALSE)
[09:31:28.963]                 }
[09:31:28.963]             }
[09:31:28.963]         }
[09:31:28.963]     })
[09:31:28.963]     if (TRUE) {
[09:31:28.963]         base::sink(type = "output", split = FALSE)
[09:31:28.963]         if (TRUE) {
[09:31:28.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.963]         }
[09:31:28.963]         else {
[09:31:28.963]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.963]         }
[09:31:28.963]         base::close(...future.stdout)
[09:31:28.963]         ...future.stdout <- NULL
[09:31:28.963]     }
[09:31:28.963]     ...future.result$conditions <- ...future.conditions
[09:31:28.963]     ...future.result$finished <- base::Sys.time()
[09:31:28.963]     ...future.result
[09:31:28.963] }
[09:31:28.965] assign_globals() ...
[09:31:28.965] List of 1
[09:31:28.965]  $ x: list()
[09:31:28.965]  - attr(*, "where")=List of 1
[09:31:28.965]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.965]  - attr(*, "resolved")= logi TRUE
[09:31:28.965]  - attr(*, "total_size")= num 0
[09:31:28.965]  - attr(*, "already-done")= logi TRUE
[09:31:28.967] - copied ‘x’ to environment
[09:31:28.967] assign_globals() ... done
[09:31:28.967] plan(): Setting new future strategy stack:
[09:31:28.967] List of future strategies:
[09:31:28.967] 1. sequential:
[09:31:28.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.967]    - tweaked: FALSE
[09:31:28.967]    - call: NULL
[09:31:28.968] plan(): nbrOfWorkers() = 1
[09:31:28.968] plan(): Setting new future strategy stack:
[09:31:28.968] List of future strategies:
[09:31:28.968] 1. sequential:
[09:31:28.968]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.968]    - tweaked: FALSE
[09:31:28.968]    - call: plan(strategy)
[09:31:28.969] plan(): nbrOfWorkers() = 1
[09:31:28.969] SequentialFuture started (and completed)
[09:31:28.969] - Launch lazy future ... done
[09:31:28.969] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.969] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.970] Searching for globals...
[09:31:28.971] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.972] Searching for globals ... DONE
[09:31:28.972] Resolving globals: TRUE
[09:31:28.972] Resolving any globals that are futures ...
[09:31:28.972] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.972] Resolving any globals that are futures ... DONE
[09:31:28.972] Resolving futures part of globals (recursively) ...
[09:31:28.973] resolve() on list ...
[09:31:28.973]  recursive: 99
[09:31:28.973]  length: 1
[09:31:28.973]  elements: ‘x’
[09:31:28.973]  length: 0 (resolved future 1)
[09:31:28.973] resolve() on list ... DONE
[09:31:28.973] - globals: [1] ‘x’
[09:31:28.973] Resolving futures part of globals (recursively) ... DONE
[09:31:28.973] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.974] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.974] - globals: [1] ‘x’
[09:31:28.974] 
[09:31:28.974] getGlobalsAndPackages() ... DONE
[09:31:28.974] run() for ‘Future’ ...
[09:31:28.974] - state: ‘created’
[09:31:28.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.975]   - Field: ‘label’
[09:31:28.975]   - Field: ‘local’
[09:31:28.975]   - Field: ‘owner’
[09:31:28.975]   - Field: ‘envir’
[09:31:28.975]   - Field: ‘packages’
[09:31:28.975]   - Field: ‘gc’
[09:31:28.975]   - Field: ‘conditions’
[09:31:28.975]   - Field: ‘expr’
[09:31:28.975]   - Field: ‘uuid’
[09:31:28.975]   - Field: ‘seed’
[09:31:28.976]   - Field: ‘version’
[09:31:28.976]   - Field: ‘result’
[09:31:28.976]   - Field: ‘asynchronous’
[09:31:28.976]   - Field: ‘calls’
[09:31:28.976]   - Field: ‘globals’
[09:31:28.976]   - Field: ‘stdout’
[09:31:28.976]   - Field: ‘earlySignal’
[09:31:28.976]   - Field: ‘lazy’
[09:31:28.976]   - Field: ‘state’
[09:31:28.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.976] - Launch lazy future ...
[09:31:28.977] Packages needed by the future expression (n = 0): <none>
[09:31:28.977] Packages needed by future strategies (n = 0): <none>
[09:31:28.977] {
[09:31:28.977]     {
[09:31:28.977]         {
[09:31:28.977]             ...future.startTime <- base::Sys.time()
[09:31:28.977]             {
[09:31:28.977]                 {
[09:31:28.977]                   {
[09:31:28.977]                     base::local({
[09:31:28.977]                       has_future <- base::requireNamespace("future", 
[09:31:28.977]                         quietly = TRUE)
[09:31:28.977]                       if (has_future) {
[09:31:28.977]                         ns <- base::getNamespace("future")
[09:31:28.977]                         version <- ns[[".package"]][["version"]]
[09:31:28.977]                         if (is.null(version)) 
[09:31:28.977]                           version <- utils::packageVersion("future")
[09:31:28.977]                       }
[09:31:28.977]                       else {
[09:31:28.977]                         version <- NULL
[09:31:28.977]                       }
[09:31:28.977]                       if (!has_future || version < "1.8.0") {
[09:31:28.977]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.977]                           "", base::R.version$version.string), 
[09:31:28.977]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.977]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.977]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.977]                             "release", "version")], collapse = " "), 
[09:31:28.977]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.977]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.977]                           info)
[09:31:28.977]                         info <- base::paste(info, collapse = "; ")
[09:31:28.977]                         if (!has_future) {
[09:31:28.977]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.977]                             info)
[09:31:28.977]                         }
[09:31:28.977]                         else {
[09:31:28.977]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.977]                             info, version)
[09:31:28.977]                         }
[09:31:28.977]                         base::stop(msg)
[09:31:28.977]                       }
[09:31:28.977]                     })
[09:31:28.977]                   }
[09:31:28.977]                   ...future.strategy.old <- future::plan("list")
[09:31:28.977]                   options(future.plan = NULL)
[09:31:28.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.977]                 }
[09:31:28.977]                 ...future.workdir <- getwd()
[09:31:28.977]             }
[09:31:28.977]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.977]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.977]         }
[09:31:28.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.977]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.977]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.977]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.977]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.977]             base::names(...future.oldOptions))
[09:31:28.977]     }
[09:31:28.977]     if (FALSE) {
[09:31:28.977]     }
[09:31:28.977]     else {
[09:31:28.977]         if (TRUE) {
[09:31:28.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.977]                 open = "w")
[09:31:28.977]         }
[09:31:28.977]         else {
[09:31:28.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.977]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.977]         }
[09:31:28.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.977]             base::sink(type = "output", split = FALSE)
[09:31:28.977]             base::close(...future.stdout)
[09:31:28.977]         }, add = TRUE)
[09:31:28.977]     }
[09:31:28.977]     ...future.frame <- base::sys.nframe()
[09:31:28.977]     ...future.conditions <- base::list()
[09:31:28.977]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.977]     if (FALSE) {
[09:31:28.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.977]     }
[09:31:28.977]     ...future.result <- base::tryCatch({
[09:31:28.977]         base::withCallingHandlers({
[09:31:28.977]             ...future.value <- base::withVisible(base::local({
[09:31:28.977]                 x["a"] <- list(1)
[09:31:28.977]                 x
[09:31:28.977]             }))
[09:31:28.977]             future::FutureResult(value = ...future.value$value, 
[09:31:28.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.977]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.977]                     ...future.globalenv.names))
[09:31:28.977]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.977]         }, condition = base::local({
[09:31:28.977]             c <- base::c
[09:31:28.977]             inherits <- base::inherits
[09:31:28.977]             invokeRestart <- base::invokeRestart
[09:31:28.977]             length <- base::length
[09:31:28.977]             list <- base::list
[09:31:28.977]             seq.int <- base::seq.int
[09:31:28.977]             signalCondition <- base::signalCondition
[09:31:28.977]             sys.calls <- base::sys.calls
[09:31:28.977]             `[[` <- base::`[[`
[09:31:28.977]             `+` <- base::`+`
[09:31:28.977]             `<<-` <- base::`<<-`
[09:31:28.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.977]                   3L)]
[09:31:28.977]             }
[09:31:28.977]             function(cond) {
[09:31:28.977]                 is_error <- inherits(cond, "error")
[09:31:28.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.977]                   NULL)
[09:31:28.977]                 if (is_error) {
[09:31:28.977]                   sessionInformation <- function() {
[09:31:28.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.977]                       search = base::search(), system = base::Sys.info())
[09:31:28.977]                   }
[09:31:28.977]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.977]                     cond$call), session = sessionInformation(), 
[09:31:28.977]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.977]                   signalCondition(cond)
[09:31:28.977]                 }
[09:31:28.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.977]                 "immediateCondition"))) {
[09:31:28.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.977]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.977]                   if (TRUE && !signal) {
[09:31:28.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.977]                     {
[09:31:28.977]                       inherits <- base::inherits
[09:31:28.977]                       invokeRestart <- base::invokeRestart
[09:31:28.977]                       is.null <- base::is.null
[09:31:28.977]                       muffled <- FALSE
[09:31:28.977]                       if (inherits(cond, "message")) {
[09:31:28.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.977]                         if (muffled) 
[09:31:28.977]                           invokeRestart("muffleMessage")
[09:31:28.977]                       }
[09:31:28.977]                       else if (inherits(cond, "warning")) {
[09:31:28.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.977]                         if (muffled) 
[09:31:28.977]                           invokeRestart("muffleWarning")
[09:31:28.977]                       }
[09:31:28.977]                       else if (inherits(cond, "condition")) {
[09:31:28.977]                         if (!is.null(pattern)) {
[09:31:28.977]                           computeRestarts <- base::computeRestarts
[09:31:28.977]                           grepl <- base::grepl
[09:31:28.977]                           restarts <- computeRestarts(cond)
[09:31:28.977]                           for (restart in restarts) {
[09:31:28.977]                             name <- restart$name
[09:31:28.977]                             if (is.null(name)) 
[09:31:28.977]                               next
[09:31:28.977]                             if (!grepl(pattern, name)) 
[09:31:28.977]                               next
[09:31:28.977]                             invokeRestart(restart)
[09:31:28.977]                             muffled <- TRUE
[09:31:28.977]                             break
[09:31:28.977]                           }
[09:31:28.977]                         }
[09:31:28.977]                       }
[09:31:28.977]                       invisible(muffled)
[09:31:28.977]                     }
[09:31:28.977]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.977]                   }
[09:31:28.977]                 }
[09:31:28.977]                 else {
[09:31:28.977]                   if (TRUE) {
[09:31:28.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.977]                     {
[09:31:28.977]                       inherits <- base::inherits
[09:31:28.977]                       invokeRestart <- base::invokeRestart
[09:31:28.977]                       is.null <- base::is.null
[09:31:28.977]                       muffled <- FALSE
[09:31:28.977]                       if (inherits(cond, "message")) {
[09:31:28.977]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.977]                         if (muffled) 
[09:31:28.977]                           invokeRestart("muffleMessage")
[09:31:28.977]                       }
[09:31:28.977]                       else if (inherits(cond, "warning")) {
[09:31:28.977]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.977]                         if (muffled) 
[09:31:28.977]                           invokeRestart("muffleWarning")
[09:31:28.977]                       }
[09:31:28.977]                       else if (inherits(cond, "condition")) {
[09:31:28.977]                         if (!is.null(pattern)) {
[09:31:28.977]                           computeRestarts <- base::computeRestarts
[09:31:28.977]                           grepl <- base::grepl
[09:31:28.977]                           restarts <- computeRestarts(cond)
[09:31:28.977]                           for (restart in restarts) {
[09:31:28.977]                             name <- restart$name
[09:31:28.977]                             if (is.null(name)) 
[09:31:28.977]                               next
[09:31:28.977]                             if (!grepl(pattern, name)) 
[09:31:28.977]                               next
[09:31:28.977]                             invokeRestart(restart)
[09:31:28.977]                             muffled <- TRUE
[09:31:28.977]                             break
[09:31:28.977]                           }
[09:31:28.977]                         }
[09:31:28.977]                       }
[09:31:28.977]                       invisible(muffled)
[09:31:28.977]                     }
[09:31:28.977]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.977]                   }
[09:31:28.977]                 }
[09:31:28.977]             }
[09:31:28.977]         }))
[09:31:28.977]     }, error = function(ex) {
[09:31:28.977]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.977]                 ...future.rng), started = ...future.startTime, 
[09:31:28.977]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.977]             version = "1.8"), class = "FutureResult")
[09:31:28.977]     }, finally = {
[09:31:28.977]         if (!identical(...future.workdir, getwd())) 
[09:31:28.977]             setwd(...future.workdir)
[09:31:28.977]         {
[09:31:28.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.977]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.977]             }
[09:31:28.977]             base::options(...future.oldOptions)
[09:31:28.977]             if (.Platform$OS.type == "windows") {
[09:31:28.977]                 old_names <- names(...future.oldEnvVars)
[09:31:28.977]                 envs <- base::Sys.getenv()
[09:31:28.977]                 names <- names(envs)
[09:31:28.977]                 common <- intersect(names, old_names)
[09:31:28.977]                 added <- setdiff(names, old_names)
[09:31:28.977]                 removed <- setdiff(old_names, names)
[09:31:28.977]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.977]                   envs[common]]
[09:31:28.977]                 NAMES <- toupper(changed)
[09:31:28.977]                 args <- list()
[09:31:28.977]                 for (kk in seq_along(NAMES)) {
[09:31:28.977]                   name <- changed[[kk]]
[09:31:28.977]                   NAME <- NAMES[[kk]]
[09:31:28.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.977]                     next
[09:31:28.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.977]                 }
[09:31:28.977]                 NAMES <- toupper(added)
[09:31:28.977]                 for (kk in seq_along(NAMES)) {
[09:31:28.977]                   name <- added[[kk]]
[09:31:28.977]                   NAME <- NAMES[[kk]]
[09:31:28.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.977]                     next
[09:31:28.977]                   args[[name]] <- ""
[09:31:28.977]                 }
[09:31:28.977]                 NAMES <- toupper(removed)
[09:31:28.977]                 for (kk in seq_along(NAMES)) {
[09:31:28.977]                   name <- removed[[kk]]
[09:31:28.977]                   NAME <- NAMES[[kk]]
[09:31:28.977]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.977]                     next
[09:31:28.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.977]                 }
[09:31:28.977]                 if (length(args) > 0) 
[09:31:28.977]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.977]             }
[09:31:28.977]             else {
[09:31:28.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.977]             }
[09:31:28.977]             {
[09:31:28.977]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.977]                   0L) {
[09:31:28.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.977]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.977]                   base::options(opts)
[09:31:28.977]                 }
[09:31:28.977]                 {
[09:31:28.977]                   {
[09:31:28.977]                     NULL
[09:31:28.977]                     RNGkind("Mersenne-Twister")
[09:31:28.977]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.977]                       inherits = FALSE)
[09:31:28.977]                   }
[09:31:28.977]                   options(future.plan = NULL)
[09:31:28.977]                   if (is.na(NA_character_)) 
[09:31:28.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.977]                     .init = FALSE)
[09:31:28.977]                 }
[09:31:28.977]             }
[09:31:28.977]         }
[09:31:28.977]     })
[09:31:28.977]     if (TRUE) {
[09:31:28.977]         base::sink(type = "output", split = FALSE)
[09:31:28.977]         if (TRUE) {
[09:31:28.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.977]         }
[09:31:28.977]         else {
[09:31:28.977]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.977]         }
[09:31:28.977]         base::close(...future.stdout)
[09:31:28.977]         ...future.stdout <- NULL
[09:31:28.977]     }
[09:31:28.977]     ...future.result$conditions <- ...future.conditions
[09:31:28.977]     ...future.result$finished <- base::Sys.time()
[09:31:28.977]     ...future.result
[09:31:28.977] }
[09:31:28.979] assign_globals() ...
[09:31:28.979] List of 1
[09:31:28.979]  $ x: list()
[09:31:28.979]  - attr(*, "where")=List of 1
[09:31:28.979]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.979]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.979]  - attr(*, "resolved")= logi TRUE
[09:31:28.979]  - attr(*, "total_size")= num 0
[09:31:28.979]  - attr(*, "already-done")= logi TRUE
[09:31:28.981] - copied ‘x’ to environment
[09:31:28.981] assign_globals() ... done
[09:31:28.981] plan(): Setting new future strategy stack:
[09:31:28.981] List of future strategies:
[09:31:28.981] 1. sequential:
[09:31:28.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.981]    - tweaked: FALSE
[09:31:28.981]    - call: NULL
[09:31:28.982] plan(): nbrOfWorkers() = 1
[09:31:28.982] plan(): Setting new future strategy stack:
[09:31:28.982] List of future strategies:
[09:31:28.982] 1. sequential:
[09:31:28.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.982]    - tweaked: FALSE
[09:31:28.982]    - call: plan(strategy)
[09:31:28.983] plan(): nbrOfWorkers() = 1
[09:31:28.983] SequentialFuture started (and completed)
[09:31:28.983] - Launch lazy future ... done
[09:31:28.983] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.983] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.984] Searching for globals...
[09:31:28.986] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.986] Searching for globals ... DONE
[09:31:28.986] Resolving globals: TRUE
[09:31:28.986] Resolving any globals that are futures ...
[09:31:28.986] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:28.986] Resolving any globals that are futures ... DONE
[09:31:28.986] Resolving futures part of globals (recursively) ...
[09:31:28.987] resolve() on list ...
[09:31:28.988]  recursive: 99
[09:31:28.988]  length: 1
[09:31:28.988]  elements: ‘x’
[09:31:28.988]  length: 0 (resolved future 1)
[09:31:28.988] resolve() on list ... DONE
[09:31:28.988] - globals: [1] ‘x’
[09:31:28.988] Resolving futures part of globals (recursively) ... DONE
[09:31:28.988] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:28.989] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:28.989] - globals: [1] ‘x’
[09:31:28.989] 
[09:31:28.989] getGlobalsAndPackages() ... DONE
[09:31:28.989] run() for ‘Future’ ...
[09:31:28.989] - state: ‘created’
[09:31:28.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:28.990] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:28.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:28.990]   - Field: ‘label’
[09:31:28.990]   - Field: ‘local’
[09:31:28.990]   - Field: ‘owner’
[09:31:28.990]   - Field: ‘envir’
[09:31:28.990]   - Field: ‘packages’
[09:31:28.990]   - Field: ‘gc’
[09:31:28.990]   - Field: ‘conditions’
[09:31:28.990]   - Field: ‘expr’
[09:31:28.990]   - Field: ‘uuid’
[09:31:28.991]   - Field: ‘seed’
[09:31:28.991]   - Field: ‘version’
[09:31:28.991]   - Field: ‘result’
[09:31:28.991]   - Field: ‘asynchronous’
[09:31:28.991]   - Field: ‘calls’
[09:31:28.991]   - Field: ‘globals’
[09:31:28.991]   - Field: ‘stdout’
[09:31:28.991]   - Field: ‘earlySignal’
[09:31:28.991]   - Field: ‘lazy’
[09:31:28.991]   - Field: ‘state’
[09:31:28.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:28.991] - Launch lazy future ...
[09:31:28.992] Packages needed by the future expression (n = 0): <none>
[09:31:28.992] Packages needed by future strategies (n = 0): <none>
[09:31:28.992] {
[09:31:28.992]     {
[09:31:28.992]         {
[09:31:28.992]             ...future.startTime <- base::Sys.time()
[09:31:28.992]             {
[09:31:28.992]                 {
[09:31:28.992]                   {
[09:31:28.992]                     base::local({
[09:31:28.992]                       has_future <- base::requireNamespace("future", 
[09:31:28.992]                         quietly = TRUE)
[09:31:28.992]                       if (has_future) {
[09:31:28.992]                         ns <- base::getNamespace("future")
[09:31:28.992]                         version <- ns[[".package"]][["version"]]
[09:31:28.992]                         if (is.null(version)) 
[09:31:28.992]                           version <- utils::packageVersion("future")
[09:31:28.992]                       }
[09:31:28.992]                       else {
[09:31:28.992]                         version <- NULL
[09:31:28.992]                       }
[09:31:28.992]                       if (!has_future || version < "1.8.0") {
[09:31:28.992]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:28.992]                           "", base::R.version$version.string), 
[09:31:28.992]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:28.992]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:28.992]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:28.992]                             "release", "version")], collapse = " "), 
[09:31:28.992]                           hostname = base::Sys.info()[["nodename"]])
[09:31:28.992]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:28.992]                           info)
[09:31:28.992]                         info <- base::paste(info, collapse = "; ")
[09:31:28.992]                         if (!has_future) {
[09:31:28.992]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:28.992]                             info)
[09:31:28.992]                         }
[09:31:28.992]                         else {
[09:31:28.992]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:28.992]                             info, version)
[09:31:28.992]                         }
[09:31:28.992]                         base::stop(msg)
[09:31:28.992]                       }
[09:31:28.992]                     })
[09:31:28.992]                   }
[09:31:28.992]                   ...future.strategy.old <- future::plan("list")
[09:31:28.992]                   options(future.plan = NULL)
[09:31:28.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:28.992]                 }
[09:31:28.992]                 ...future.workdir <- getwd()
[09:31:28.992]             }
[09:31:28.992]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:28.992]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:28.992]         }
[09:31:28.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:28.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:28.992]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:28.992]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:28.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:28.992]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:28.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:28.992]             base::names(...future.oldOptions))
[09:31:28.992]     }
[09:31:28.992]     if (FALSE) {
[09:31:28.992]     }
[09:31:28.992]     else {
[09:31:28.992]         if (TRUE) {
[09:31:28.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:28.992]                 open = "w")
[09:31:28.992]         }
[09:31:28.992]         else {
[09:31:28.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:28.992]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:28.992]         }
[09:31:28.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:28.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:28.992]             base::sink(type = "output", split = FALSE)
[09:31:28.992]             base::close(...future.stdout)
[09:31:28.992]         }, add = TRUE)
[09:31:28.992]     }
[09:31:28.992]     ...future.frame <- base::sys.nframe()
[09:31:28.992]     ...future.conditions <- base::list()
[09:31:28.992]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:28.992]     if (FALSE) {
[09:31:28.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:28.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:28.992]     }
[09:31:28.992]     ...future.result <- base::tryCatch({
[09:31:28.992]         base::withCallingHandlers({
[09:31:28.992]             ...future.value <- base::withVisible(base::local({
[09:31:28.992]                 x["a"] <- list(1)
[09:31:28.992]                 x
[09:31:28.992]             }))
[09:31:28.992]             future::FutureResult(value = ...future.value$value, 
[09:31:28.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.992]                   ...future.rng), globalenv = if (FALSE) 
[09:31:28.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:28.992]                     ...future.globalenv.names))
[09:31:28.992]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:28.992]         }, condition = base::local({
[09:31:28.992]             c <- base::c
[09:31:28.992]             inherits <- base::inherits
[09:31:28.992]             invokeRestart <- base::invokeRestart
[09:31:28.992]             length <- base::length
[09:31:28.992]             list <- base::list
[09:31:28.992]             seq.int <- base::seq.int
[09:31:28.992]             signalCondition <- base::signalCondition
[09:31:28.992]             sys.calls <- base::sys.calls
[09:31:28.992]             `[[` <- base::`[[`
[09:31:28.992]             `+` <- base::`+`
[09:31:28.992]             `<<-` <- base::`<<-`
[09:31:28.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:28.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:28.992]                   3L)]
[09:31:28.992]             }
[09:31:28.992]             function(cond) {
[09:31:28.992]                 is_error <- inherits(cond, "error")
[09:31:28.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:28.992]                   NULL)
[09:31:28.992]                 if (is_error) {
[09:31:28.992]                   sessionInformation <- function() {
[09:31:28.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:28.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:28.992]                       search = base::search(), system = base::Sys.info())
[09:31:28.992]                   }
[09:31:28.992]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:28.992]                     cond$call), session = sessionInformation(), 
[09:31:28.992]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:28.992]                   signalCondition(cond)
[09:31:28.992]                 }
[09:31:28.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:28.992]                 "immediateCondition"))) {
[09:31:28.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:28.992]                   ...future.conditions[[length(...future.conditions) + 
[09:31:28.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:28.992]                   if (TRUE && !signal) {
[09:31:28.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.992]                     {
[09:31:28.992]                       inherits <- base::inherits
[09:31:28.992]                       invokeRestart <- base::invokeRestart
[09:31:28.992]                       is.null <- base::is.null
[09:31:28.992]                       muffled <- FALSE
[09:31:28.992]                       if (inherits(cond, "message")) {
[09:31:28.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.992]                         if (muffled) 
[09:31:28.992]                           invokeRestart("muffleMessage")
[09:31:28.992]                       }
[09:31:28.992]                       else if (inherits(cond, "warning")) {
[09:31:28.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.992]                         if (muffled) 
[09:31:28.992]                           invokeRestart("muffleWarning")
[09:31:28.992]                       }
[09:31:28.992]                       else if (inherits(cond, "condition")) {
[09:31:28.992]                         if (!is.null(pattern)) {
[09:31:28.992]                           computeRestarts <- base::computeRestarts
[09:31:28.992]                           grepl <- base::grepl
[09:31:28.992]                           restarts <- computeRestarts(cond)
[09:31:28.992]                           for (restart in restarts) {
[09:31:28.992]                             name <- restart$name
[09:31:28.992]                             if (is.null(name)) 
[09:31:28.992]                               next
[09:31:28.992]                             if (!grepl(pattern, name)) 
[09:31:28.992]                               next
[09:31:28.992]                             invokeRestart(restart)
[09:31:28.992]                             muffled <- TRUE
[09:31:28.992]                             break
[09:31:28.992]                           }
[09:31:28.992]                         }
[09:31:28.992]                       }
[09:31:28.992]                       invisible(muffled)
[09:31:28.992]                     }
[09:31:28.992]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.992]                   }
[09:31:28.992]                 }
[09:31:28.992]                 else {
[09:31:28.992]                   if (TRUE) {
[09:31:28.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:28.992]                     {
[09:31:28.992]                       inherits <- base::inherits
[09:31:28.992]                       invokeRestart <- base::invokeRestart
[09:31:28.992]                       is.null <- base::is.null
[09:31:28.992]                       muffled <- FALSE
[09:31:28.992]                       if (inherits(cond, "message")) {
[09:31:28.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:28.992]                         if (muffled) 
[09:31:28.992]                           invokeRestart("muffleMessage")
[09:31:28.992]                       }
[09:31:28.992]                       else if (inherits(cond, "warning")) {
[09:31:28.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:28.992]                         if (muffled) 
[09:31:28.992]                           invokeRestart("muffleWarning")
[09:31:28.992]                       }
[09:31:28.992]                       else if (inherits(cond, "condition")) {
[09:31:28.992]                         if (!is.null(pattern)) {
[09:31:28.992]                           computeRestarts <- base::computeRestarts
[09:31:28.992]                           grepl <- base::grepl
[09:31:28.992]                           restarts <- computeRestarts(cond)
[09:31:28.992]                           for (restart in restarts) {
[09:31:28.992]                             name <- restart$name
[09:31:28.992]                             if (is.null(name)) 
[09:31:28.992]                               next
[09:31:28.992]                             if (!grepl(pattern, name)) 
[09:31:28.992]                               next
[09:31:28.992]                             invokeRestart(restart)
[09:31:28.992]                             muffled <- TRUE
[09:31:28.992]                             break
[09:31:28.992]                           }
[09:31:28.992]                         }
[09:31:28.992]                       }
[09:31:28.992]                       invisible(muffled)
[09:31:28.992]                     }
[09:31:28.992]                     muffleCondition(cond, pattern = "^muffle")
[09:31:28.992]                   }
[09:31:28.992]                 }
[09:31:28.992]             }
[09:31:28.992]         }))
[09:31:28.992]     }, error = function(ex) {
[09:31:28.992]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:28.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:28.992]                 ...future.rng), started = ...future.startTime, 
[09:31:28.992]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:28.992]             version = "1.8"), class = "FutureResult")
[09:31:28.992]     }, finally = {
[09:31:28.992]         if (!identical(...future.workdir, getwd())) 
[09:31:28.992]             setwd(...future.workdir)
[09:31:28.992]         {
[09:31:28.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:28.992]                 ...future.oldOptions$nwarnings <- NULL
[09:31:28.992]             }
[09:31:28.992]             base::options(...future.oldOptions)
[09:31:28.992]             if (.Platform$OS.type == "windows") {
[09:31:28.992]                 old_names <- names(...future.oldEnvVars)
[09:31:28.992]                 envs <- base::Sys.getenv()
[09:31:28.992]                 names <- names(envs)
[09:31:28.992]                 common <- intersect(names, old_names)
[09:31:28.992]                 added <- setdiff(names, old_names)
[09:31:28.992]                 removed <- setdiff(old_names, names)
[09:31:28.992]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:28.992]                   envs[common]]
[09:31:28.992]                 NAMES <- toupper(changed)
[09:31:28.992]                 args <- list()
[09:31:28.992]                 for (kk in seq_along(NAMES)) {
[09:31:28.992]                   name <- changed[[kk]]
[09:31:28.992]                   NAME <- NAMES[[kk]]
[09:31:28.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.992]                     next
[09:31:28.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.992]                 }
[09:31:28.992]                 NAMES <- toupper(added)
[09:31:28.992]                 for (kk in seq_along(NAMES)) {
[09:31:28.992]                   name <- added[[kk]]
[09:31:28.992]                   NAME <- NAMES[[kk]]
[09:31:28.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.992]                     next
[09:31:28.992]                   args[[name]] <- ""
[09:31:28.992]                 }
[09:31:28.992]                 NAMES <- toupper(removed)
[09:31:28.992]                 for (kk in seq_along(NAMES)) {
[09:31:28.992]                   name <- removed[[kk]]
[09:31:28.992]                   NAME <- NAMES[[kk]]
[09:31:28.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:28.992]                     next
[09:31:28.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:28.992]                 }
[09:31:28.992]                 if (length(args) > 0) 
[09:31:28.992]                   base::do.call(base::Sys.setenv, args = args)
[09:31:28.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:28.992]             }
[09:31:28.992]             else {
[09:31:28.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:28.992]             }
[09:31:28.992]             {
[09:31:28.992]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:28.992]                   0L) {
[09:31:28.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:28.992]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:28.992]                   base::options(opts)
[09:31:28.992]                 }
[09:31:28.992]                 {
[09:31:28.992]                   {
[09:31:28.992]                     NULL
[09:31:28.992]                     RNGkind("Mersenne-Twister")
[09:31:28.992]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:28.992]                       inherits = FALSE)
[09:31:28.992]                   }
[09:31:28.992]                   options(future.plan = NULL)
[09:31:28.992]                   if (is.na(NA_character_)) 
[09:31:28.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:28.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:28.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:28.992]                     .init = FALSE)
[09:31:28.992]                 }
[09:31:28.992]             }
[09:31:28.992]         }
[09:31:28.992]     })
[09:31:28.992]     if (TRUE) {
[09:31:28.992]         base::sink(type = "output", split = FALSE)
[09:31:28.992]         if (TRUE) {
[09:31:28.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:28.992]         }
[09:31:28.992]         else {
[09:31:28.992]             ...future.result["stdout"] <- base::list(NULL)
[09:31:28.992]         }
[09:31:28.992]         base::close(...future.stdout)
[09:31:28.992]         ...future.stdout <- NULL
[09:31:28.992]     }
[09:31:28.992]     ...future.result$conditions <- ...future.conditions
[09:31:28.992]     ...future.result$finished <- base::Sys.time()
[09:31:28.992]     ...future.result
[09:31:28.992] }
[09:31:28.994] assign_globals() ...
[09:31:28.994] List of 1
[09:31:28.994]  $ x: list()
[09:31:28.994]  - attr(*, "where")=List of 1
[09:31:28.994]   ..$ x:<environment: R_EmptyEnv> 
[09:31:28.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:28.994]  - attr(*, "resolved")= logi TRUE
[09:31:28.994]  - attr(*, "total_size")= num 0
[09:31:28.994]  - attr(*, "already-done")= logi TRUE
[09:31:28.996] - copied ‘x’ to environment
[09:31:28.996] assign_globals() ... done
[09:31:28.996] plan(): Setting new future strategy stack:
[09:31:28.996] List of future strategies:
[09:31:28.996] 1. sequential:
[09:31:28.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.996]    - tweaked: FALSE
[09:31:28.996]    - call: NULL
[09:31:28.997] plan(): nbrOfWorkers() = 1
[09:31:28.997] plan(): Setting new future strategy stack:
[09:31:28.998] List of future strategies:
[09:31:28.998] 1. sequential:
[09:31:28.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:28.998]    - tweaked: FALSE
[09:31:28.998]    - call: plan(strategy)
[09:31:28.998] plan(): nbrOfWorkers() = 1
[09:31:28.998] SequentialFuture started (and completed)
[09:31:28.998] - Launch lazy future ... done
[09:31:28.998] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:28.999] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:28.999] Searching for globals...
[09:31:29.001] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:29.001] Searching for globals ... DONE
[09:31:29.001] Resolving globals: TRUE
[09:31:29.001] Resolving any globals that are futures ...
[09:31:29.001] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:29.001] Resolving any globals that are futures ... DONE
[09:31:29.002] Resolving futures part of globals (recursively) ...
[09:31:29.002] resolve() on list ...
[09:31:29.002]  recursive: 99
[09:31:29.002]  length: 2
[09:31:29.002]  elements: ‘x’, ‘name’
[09:31:29.002]  length: 1 (resolved future 1)
[09:31:29.002]  length: 0 (resolved future 2)
[09:31:29.002] resolve() on list ... DONE
[09:31:29.003] - globals: [2] ‘x’, ‘name’
[09:31:29.003] Resolving futures part of globals (recursively) ... DONE
[09:31:29.003] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:29.003] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[09:31:29.003] - globals: [2] ‘x’, ‘name’
[09:31:29.003] 
[09:31:29.003] getGlobalsAndPackages() ... DONE
[09:31:29.004] run() for ‘Future’ ...
[09:31:29.004] - state: ‘created’
[09:31:29.004] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:29.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:29.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:29.004]   - Field: ‘label’
[09:31:29.004]   - Field: ‘local’
[09:31:29.005]   - Field: ‘owner’
[09:31:29.005]   - Field: ‘envir’
[09:31:29.005]   - Field: ‘packages’
[09:31:29.005]   - Field: ‘gc’
[09:31:29.005]   - Field: ‘conditions’
[09:31:29.005]   - Field: ‘expr’
[09:31:29.005]   - Field: ‘uuid’
[09:31:29.005]   - Field: ‘seed’
[09:31:29.005]   - Field: ‘version’
[09:31:29.005]   - Field: ‘result’
[09:31:29.005]   - Field: ‘asynchronous’
[09:31:29.005]   - Field: ‘calls’
[09:31:29.006]   - Field: ‘globals’
[09:31:29.006]   - Field: ‘stdout’
[09:31:29.006]   - Field: ‘earlySignal’
[09:31:29.006]   - Field: ‘lazy’
[09:31:29.006]   - Field: ‘state’
[09:31:29.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:29.006] - Launch lazy future ...
[09:31:29.006] Packages needed by the future expression (n = 0): <none>
[09:31:29.006] Packages needed by future strategies (n = 0): <none>
[09:31:29.007] {
[09:31:29.007]     {
[09:31:29.007]         {
[09:31:29.007]             ...future.startTime <- base::Sys.time()
[09:31:29.007]             {
[09:31:29.007]                 {
[09:31:29.007]                   {
[09:31:29.007]                     base::local({
[09:31:29.007]                       has_future <- base::requireNamespace("future", 
[09:31:29.007]                         quietly = TRUE)
[09:31:29.007]                       if (has_future) {
[09:31:29.007]                         ns <- base::getNamespace("future")
[09:31:29.007]                         version <- ns[[".package"]][["version"]]
[09:31:29.007]                         if (is.null(version)) 
[09:31:29.007]                           version <- utils::packageVersion("future")
[09:31:29.007]                       }
[09:31:29.007]                       else {
[09:31:29.007]                         version <- NULL
[09:31:29.007]                       }
[09:31:29.007]                       if (!has_future || version < "1.8.0") {
[09:31:29.007]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.007]                           "", base::R.version$version.string), 
[09:31:29.007]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:29.007]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.007]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.007]                             "release", "version")], collapse = " "), 
[09:31:29.007]                           hostname = base::Sys.info()[["nodename"]])
[09:31:29.007]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.007]                           info)
[09:31:29.007]                         info <- base::paste(info, collapse = "; ")
[09:31:29.007]                         if (!has_future) {
[09:31:29.007]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.007]                             info)
[09:31:29.007]                         }
[09:31:29.007]                         else {
[09:31:29.007]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.007]                             info, version)
[09:31:29.007]                         }
[09:31:29.007]                         base::stop(msg)
[09:31:29.007]                       }
[09:31:29.007]                     })
[09:31:29.007]                   }
[09:31:29.007]                   ...future.strategy.old <- future::plan("list")
[09:31:29.007]                   options(future.plan = NULL)
[09:31:29.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.007]                 }
[09:31:29.007]                 ...future.workdir <- getwd()
[09:31:29.007]             }
[09:31:29.007]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.007]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.007]         }
[09:31:29.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.007]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.007]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.007]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.007]             base::names(...future.oldOptions))
[09:31:29.007]     }
[09:31:29.007]     if (FALSE) {
[09:31:29.007]     }
[09:31:29.007]     else {
[09:31:29.007]         if (TRUE) {
[09:31:29.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.007]                 open = "w")
[09:31:29.007]         }
[09:31:29.007]         else {
[09:31:29.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.007]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.007]         }
[09:31:29.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.007]             base::sink(type = "output", split = FALSE)
[09:31:29.007]             base::close(...future.stdout)
[09:31:29.007]         }, add = TRUE)
[09:31:29.007]     }
[09:31:29.007]     ...future.frame <- base::sys.nframe()
[09:31:29.007]     ...future.conditions <- base::list()
[09:31:29.007]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.007]     if (FALSE) {
[09:31:29.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.007]     }
[09:31:29.007]     ...future.result <- base::tryCatch({
[09:31:29.007]         base::withCallingHandlers({
[09:31:29.007]             ...future.value <- base::withVisible(base::local({
[09:31:29.007]                 x[name] <- list(1)
[09:31:29.007]                 x
[09:31:29.007]             }))
[09:31:29.007]             future::FutureResult(value = ...future.value$value, 
[09:31:29.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.007]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.007]                     ...future.globalenv.names))
[09:31:29.007]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.007]         }, condition = base::local({
[09:31:29.007]             c <- base::c
[09:31:29.007]             inherits <- base::inherits
[09:31:29.007]             invokeRestart <- base::invokeRestart
[09:31:29.007]             length <- base::length
[09:31:29.007]             list <- base::list
[09:31:29.007]             seq.int <- base::seq.int
[09:31:29.007]             signalCondition <- base::signalCondition
[09:31:29.007]             sys.calls <- base::sys.calls
[09:31:29.007]             `[[` <- base::`[[`
[09:31:29.007]             `+` <- base::`+`
[09:31:29.007]             `<<-` <- base::`<<-`
[09:31:29.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.007]                   3L)]
[09:31:29.007]             }
[09:31:29.007]             function(cond) {
[09:31:29.007]                 is_error <- inherits(cond, "error")
[09:31:29.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.007]                   NULL)
[09:31:29.007]                 if (is_error) {
[09:31:29.007]                   sessionInformation <- function() {
[09:31:29.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.007]                       search = base::search(), system = base::Sys.info())
[09:31:29.007]                   }
[09:31:29.007]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.007]                     cond$call), session = sessionInformation(), 
[09:31:29.007]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.007]                   signalCondition(cond)
[09:31:29.007]                 }
[09:31:29.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.007]                 "immediateCondition"))) {
[09:31:29.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.007]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.007]                   if (TRUE && !signal) {
[09:31:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.007]                     {
[09:31:29.007]                       inherits <- base::inherits
[09:31:29.007]                       invokeRestart <- base::invokeRestart
[09:31:29.007]                       is.null <- base::is.null
[09:31:29.007]                       muffled <- FALSE
[09:31:29.007]                       if (inherits(cond, "message")) {
[09:31:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.007]                         if (muffled) 
[09:31:29.007]                           invokeRestart("muffleMessage")
[09:31:29.007]                       }
[09:31:29.007]                       else if (inherits(cond, "warning")) {
[09:31:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.007]                         if (muffled) 
[09:31:29.007]                           invokeRestart("muffleWarning")
[09:31:29.007]                       }
[09:31:29.007]                       else if (inherits(cond, "condition")) {
[09:31:29.007]                         if (!is.null(pattern)) {
[09:31:29.007]                           computeRestarts <- base::computeRestarts
[09:31:29.007]                           grepl <- base::grepl
[09:31:29.007]                           restarts <- computeRestarts(cond)
[09:31:29.007]                           for (restart in restarts) {
[09:31:29.007]                             name <- restart$name
[09:31:29.007]                             if (is.null(name)) 
[09:31:29.007]                               next
[09:31:29.007]                             if (!grepl(pattern, name)) 
[09:31:29.007]                               next
[09:31:29.007]                             invokeRestart(restart)
[09:31:29.007]                             muffled <- TRUE
[09:31:29.007]                             break
[09:31:29.007]                           }
[09:31:29.007]                         }
[09:31:29.007]                       }
[09:31:29.007]                       invisible(muffled)
[09:31:29.007]                     }
[09:31:29.007]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.007]                   }
[09:31:29.007]                 }
[09:31:29.007]                 else {
[09:31:29.007]                   if (TRUE) {
[09:31:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.007]                     {
[09:31:29.007]                       inherits <- base::inherits
[09:31:29.007]                       invokeRestart <- base::invokeRestart
[09:31:29.007]                       is.null <- base::is.null
[09:31:29.007]                       muffled <- FALSE
[09:31:29.007]                       if (inherits(cond, "message")) {
[09:31:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.007]                         if (muffled) 
[09:31:29.007]                           invokeRestart("muffleMessage")
[09:31:29.007]                       }
[09:31:29.007]                       else if (inherits(cond, "warning")) {
[09:31:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.007]                         if (muffled) 
[09:31:29.007]                           invokeRestart("muffleWarning")
[09:31:29.007]                       }
[09:31:29.007]                       else if (inherits(cond, "condition")) {
[09:31:29.007]                         if (!is.null(pattern)) {
[09:31:29.007]                           computeRestarts <- base::computeRestarts
[09:31:29.007]                           grepl <- base::grepl
[09:31:29.007]                           restarts <- computeRestarts(cond)
[09:31:29.007]                           for (restart in restarts) {
[09:31:29.007]                             name <- restart$name
[09:31:29.007]                             if (is.null(name)) 
[09:31:29.007]                               next
[09:31:29.007]                             if (!grepl(pattern, name)) 
[09:31:29.007]                               next
[09:31:29.007]                             invokeRestart(restart)
[09:31:29.007]                             muffled <- TRUE
[09:31:29.007]                             break
[09:31:29.007]                           }
[09:31:29.007]                         }
[09:31:29.007]                       }
[09:31:29.007]                       invisible(muffled)
[09:31:29.007]                     }
[09:31:29.007]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.007]                   }
[09:31:29.007]                 }
[09:31:29.007]             }
[09:31:29.007]         }))
[09:31:29.007]     }, error = function(ex) {
[09:31:29.007]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.007]                 ...future.rng), started = ...future.startTime, 
[09:31:29.007]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.007]             version = "1.8"), class = "FutureResult")
[09:31:29.007]     }, finally = {
[09:31:29.007]         if (!identical(...future.workdir, getwd())) 
[09:31:29.007]             setwd(...future.workdir)
[09:31:29.007]         {
[09:31:29.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.007]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.007]             }
[09:31:29.007]             base::options(...future.oldOptions)
[09:31:29.007]             if (.Platform$OS.type == "windows") {
[09:31:29.007]                 old_names <- names(...future.oldEnvVars)
[09:31:29.007]                 envs <- base::Sys.getenv()
[09:31:29.007]                 names <- names(envs)
[09:31:29.007]                 common <- intersect(names, old_names)
[09:31:29.007]                 added <- setdiff(names, old_names)
[09:31:29.007]                 removed <- setdiff(old_names, names)
[09:31:29.007]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.007]                   envs[common]]
[09:31:29.007]                 NAMES <- toupper(changed)
[09:31:29.007]                 args <- list()
[09:31:29.007]                 for (kk in seq_along(NAMES)) {
[09:31:29.007]                   name <- changed[[kk]]
[09:31:29.007]                   NAME <- NAMES[[kk]]
[09:31:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.007]                     next
[09:31:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.007]                 }
[09:31:29.007]                 NAMES <- toupper(added)
[09:31:29.007]                 for (kk in seq_along(NAMES)) {
[09:31:29.007]                   name <- added[[kk]]
[09:31:29.007]                   NAME <- NAMES[[kk]]
[09:31:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.007]                     next
[09:31:29.007]                   args[[name]] <- ""
[09:31:29.007]                 }
[09:31:29.007]                 NAMES <- toupper(removed)
[09:31:29.007]                 for (kk in seq_along(NAMES)) {
[09:31:29.007]                   name <- removed[[kk]]
[09:31:29.007]                   NAME <- NAMES[[kk]]
[09:31:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.007]                     next
[09:31:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.007]                 }
[09:31:29.007]                 if (length(args) > 0) 
[09:31:29.007]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.007]             }
[09:31:29.007]             else {
[09:31:29.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.007]             }
[09:31:29.007]             {
[09:31:29.007]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.007]                   0L) {
[09:31:29.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.007]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.007]                   base::options(opts)
[09:31:29.007]                 }
[09:31:29.007]                 {
[09:31:29.007]                   {
[09:31:29.007]                     NULL
[09:31:29.007]                     RNGkind("Mersenne-Twister")
[09:31:29.007]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:29.007]                       inherits = FALSE)
[09:31:29.007]                   }
[09:31:29.007]                   options(future.plan = NULL)
[09:31:29.007]                   if (is.na(NA_character_)) 
[09:31:29.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.007]                     .init = FALSE)
[09:31:29.007]                 }
[09:31:29.007]             }
[09:31:29.007]         }
[09:31:29.007]     })
[09:31:29.007]     if (TRUE) {
[09:31:29.007]         base::sink(type = "output", split = FALSE)
[09:31:29.007]         if (TRUE) {
[09:31:29.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.007]         }
[09:31:29.007]         else {
[09:31:29.007]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.007]         }
[09:31:29.007]         base::close(...future.stdout)
[09:31:29.007]         ...future.stdout <- NULL
[09:31:29.007]     }
[09:31:29.007]     ...future.result$conditions <- ...future.conditions
[09:31:29.007]     ...future.result$finished <- base::Sys.time()
[09:31:29.007]     ...future.result
[09:31:29.007] }
[09:31:29.008] assign_globals() ...
[09:31:29.008] List of 2
[09:31:29.008]  $ x   : list()
[09:31:29.008]  $ name: chr "a"
[09:31:29.008]  - attr(*, "where")=List of 2
[09:31:29.008]   ..$ x   :<environment: R_EmptyEnv> 
[09:31:29.008]   ..$ name:<environment: R_EmptyEnv> 
[09:31:29.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.008]  - attr(*, "resolved")= logi TRUE
[09:31:29.008]  - attr(*, "total_size")= num 112
[09:31:29.008]  - attr(*, "already-done")= logi TRUE
[09:31:29.011] - copied ‘x’ to environment
[09:31:29.011] - copied ‘name’ to environment
[09:31:29.011] assign_globals() ... done
[09:31:29.011] plan(): Setting new future strategy stack:
[09:31:29.011] List of future strategies:
[09:31:29.011] 1. sequential:
[09:31:29.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.011]    - tweaked: FALSE
[09:31:29.011]    - call: NULL
[09:31:29.012] plan(): nbrOfWorkers() = 1
[09:31:29.012] plan(): Setting new future strategy stack:
[09:31:29.012] List of future strategies:
[09:31:29.012] 1. sequential:
[09:31:29.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.012]    - tweaked: FALSE
[09:31:29.012]    - call: plan(strategy)
[09:31:29.014] plan(): nbrOfWorkers() = 1
[09:31:29.014] SequentialFuture started (and completed)
[09:31:29.014] - Launch lazy future ... done
[09:31:29.014] run() for ‘SequentialFuture’ ... done
$a
[1] 1

Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- plan('multicore') ...
[09:31:29.023] plan(): Setting new future strategy stack:
[09:31:29.023] List of future strategies:
[09:31:29.023] 1. multicore:
[09:31:29.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.023]    - tweaked: FALSE
[09:31:29.023]    - call: plan(strategy)
[09:31:29.026] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.027] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.027] Searching for globals...
[09:31:29.029] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.029] Searching for globals ... DONE
[09:31:29.029] Resolving globals: TRUE
[09:31:29.029] Resolving any globals that are futures ...
[09:31:29.029] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.029] Resolving any globals that are futures ... DONE
[09:31:29.029] Resolving futures part of globals (recursively) ...
[09:31:29.030] resolve() on list ...
[09:31:29.030]  recursive: 99
[09:31:29.030]  length: 1
[09:31:29.030]  elements: ‘x’
[09:31:29.030]  length: 0 (resolved future 1)
[09:31:29.030] resolve() on list ... DONE
[09:31:29.030] - globals: [1] ‘x’
[09:31:29.030] Resolving futures part of globals (recursively) ... DONE
[09:31:29.030] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.031] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.031] - globals: [1] ‘x’
[09:31:29.031] 
[09:31:29.031] getGlobalsAndPackages() ... DONE
[09:31:29.031] run() for ‘Future’ ...
[09:31:29.031] - state: ‘created’
[09:31:29.031] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.035] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.035] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.035]   - Field: ‘label’
[09:31:29.035]   - Field: ‘local’
[09:31:29.035]   - Field: ‘owner’
[09:31:29.035]   - Field: ‘envir’
[09:31:29.035]   - Field: ‘workers’
[09:31:29.035]   - Field: ‘packages’
[09:31:29.036]   - Field: ‘gc’
[09:31:29.036]   - Field: ‘job’
[09:31:29.036]   - Field: ‘conditions’
[09:31:29.036]   - Field: ‘expr’
[09:31:29.036]   - Field: ‘uuid’
[09:31:29.036]   - Field: ‘seed’
[09:31:29.036]   - Field: ‘version’
[09:31:29.036]   - Field: ‘result’
[09:31:29.036]   - Field: ‘asynchronous’
[09:31:29.036]   - Field: ‘calls’
[09:31:29.036]   - Field: ‘globals’
[09:31:29.037]   - Field: ‘stdout’
[09:31:29.037]   - Field: ‘earlySignal’
[09:31:29.037]   - Field: ‘lazy’
[09:31:29.037]   - Field: ‘state’
[09:31:29.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.037] - Launch lazy future ...
[09:31:29.038] Packages needed by the future expression (n = 0): <none>
[09:31:29.038] Packages needed by future strategies (n = 0): <none>
[09:31:29.038] {
[09:31:29.038]     {
[09:31:29.038]         {
[09:31:29.038]             ...future.startTime <- base::Sys.time()
[09:31:29.038]             {
[09:31:29.038]                 {
[09:31:29.038]                   {
[09:31:29.038]                     {
[09:31:29.038]                       base::local({
[09:31:29.038]                         has_future <- base::requireNamespace("future", 
[09:31:29.038]                           quietly = TRUE)
[09:31:29.038]                         if (has_future) {
[09:31:29.038]                           ns <- base::getNamespace("future")
[09:31:29.038]                           version <- ns[[".package"]][["version"]]
[09:31:29.038]                           if (is.null(version)) 
[09:31:29.038]                             version <- utils::packageVersion("future")
[09:31:29.038]                         }
[09:31:29.038]                         else {
[09:31:29.038]                           version <- NULL
[09:31:29.038]                         }
[09:31:29.038]                         if (!has_future || version < "1.8.0") {
[09:31:29.038]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.038]                             "", base::R.version$version.string), 
[09:31:29.038]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.038]                               "release", "version")], collapse = " "), 
[09:31:29.038]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.038]                             info)
[09:31:29.038]                           info <- base::paste(info, collapse = "; ")
[09:31:29.038]                           if (!has_future) {
[09:31:29.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.038]                               info)
[09:31:29.038]                           }
[09:31:29.038]                           else {
[09:31:29.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.038]                               info, version)
[09:31:29.038]                           }
[09:31:29.038]                           base::stop(msg)
[09:31:29.038]                         }
[09:31:29.038]                       })
[09:31:29.038]                     }
[09:31:29.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.038]                     base::options(mc.cores = 1L)
[09:31:29.038]                   }
[09:31:29.038]                   ...future.strategy.old <- future::plan("list")
[09:31:29.038]                   options(future.plan = NULL)
[09:31:29.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.038]                 }
[09:31:29.038]                 ...future.workdir <- getwd()
[09:31:29.038]             }
[09:31:29.038]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.038]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.038]         }
[09:31:29.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.038]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.038]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.038]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.038]             base::names(...future.oldOptions))
[09:31:29.038]     }
[09:31:29.038]     if (FALSE) {
[09:31:29.038]     }
[09:31:29.038]     else {
[09:31:29.038]         if (TRUE) {
[09:31:29.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.038]                 open = "w")
[09:31:29.038]         }
[09:31:29.038]         else {
[09:31:29.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.038]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.038]         }
[09:31:29.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.038]             base::sink(type = "output", split = FALSE)
[09:31:29.038]             base::close(...future.stdout)
[09:31:29.038]         }, add = TRUE)
[09:31:29.038]     }
[09:31:29.038]     ...future.frame <- base::sys.nframe()
[09:31:29.038]     ...future.conditions <- base::list()
[09:31:29.038]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.038]     if (FALSE) {
[09:31:29.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.038]     }
[09:31:29.038]     ...future.result <- base::tryCatch({
[09:31:29.038]         base::withCallingHandlers({
[09:31:29.038]             ...future.value <- base::withVisible(base::local({
[09:31:29.038]                 withCallingHandlers({
[09:31:29.038]                   {
[09:31:29.038]                     x$a <- 1
[09:31:29.038]                     x
[09:31:29.038]                   }
[09:31:29.038]                 }, immediateCondition = function(cond) {
[09:31:29.038]                   save_rds <- function (object, pathname, ...) 
[09:31:29.038]                   {
[09:31:29.038]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.038]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.038]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.038]                         fi_tmp[["mtime"]])
[09:31:29.038]                     }
[09:31:29.038]                     tryCatch({
[09:31:29.038]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.038]                     }, error = function(ex) {
[09:31:29.038]                       msg <- conditionMessage(ex)
[09:31:29.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.038]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.038]                         fi_tmp[["mtime"]], msg)
[09:31:29.038]                       ex$message <- msg
[09:31:29.038]                       stop(ex)
[09:31:29.038]                     })
[09:31:29.038]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.038]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.038]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.038]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.038]                       fi <- file.info(pathname)
[09:31:29.038]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.038]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.038]                         fi[["size"]], fi[["mtime"]])
[09:31:29.038]                       stop(msg)
[09:31:29.038]                     }
[09:31:29.038]                     invisible(pathname)
[09:31:29.038]                   }
[09:31:29.038]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.038]                     rootPath = tempdir()) 
[09:31:29.038]                   {
[09:31:29.038]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.038]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.038]                       tmpdir = path, fileext = ".rds")
[09:31:29.038]                     save_rds(obj, file)
[09:31:29.038]                   }
[09:31:29.038]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.038]                   {
[09:31:29.038]                     inherits <- base::inherits
[09:31:29.038]                     invokeRestart <- base::invokeRestart
[09:31:29.038]                     is.null <- base::is.null
[09:31:29.038]                     muffled <- FALSE
[09:31:29.038]                     if (inherits(cond, "message")) {
[09:31:29.038]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.038]                       if (muffled) 
[09:31:29.038]                         invokeRestart("muffleMessage")
[09:31:29.038]                     }
[09:31:29.038]                     else if (inherits(cond, "warning")) {
[09:31:29.038]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.038]                       if (muffled) 
[09:31:29.038]                         invokeRestart("muffleWarning")
[09:31:29.038]                     }
[09:31:29.038]                     else if (inherits(cond, "condition")) {
[09:31:29.038]                       if (!is.null(pattern)) {
[09:31:29.038]                         computeRestarts <- base::computeRestarts
[09:31:29.038]                         grepl <- base::grepl
[09:31:29.038]                         restarts <- computeRestarts(cond)
[09:31:29.038]                         for (restart in restarts) {
[09:31:29.038]                           name <- restart$name
[09:31:29.038]                           if (is.null(name)) 
[09:31:29.038]                             next
[09:31:29.038]                           if (!grepl(pattern, name)) 
[09:31:29.038]                             next
[09:31:29.038]                           invokeRestart(restart)
[09:31:29.038]                           muffled <- TRUE
[09:31:29.038]                           break
[09:31:29.038]                         }
[09:31:29.038]                       }
[09:31:29.038]                     }
[09:31:29.038]                     invisible(muffled)
[09:31:29.038]                   }
[09:31:29.038]                   muffleCondition(cond)
[09:31:29.038]                 })
[09:31:29.038]             }))
[09:31:29.038]             future::FutureResult(value = ...future.value$value, 
[09:31:29.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.038]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.038]                     ...future.globalenv.names))
[09:31:29.038]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.038]         }, condition = base::local({
[09:31:29.038]             c <- base::c
[09:31:29.038]             inherits <- base::inherits
[09:31:29.038]             invokeRestart <- base::invokeRestart
[09:31:29.038]             length <- base::length
[09:31:29.038]             list <- base::list
[09:31:29.038]             seq.int <- base::seq.int
[09:31:29.038]             signalCondition <- base::signalCondition
[09:31:29.038]             sys.calls <- base::sys.calls
[09:31:29.038]             `[[` <- base::`[[`
[09:31:29.038]             `+` <- base::`+`
[09:31:29.038]             `<<-` <- base::`<<-`
[09:31:29.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.038]                   3L)]
[09:31:29.038]             }
[09:31:29.038]             function(cond) {
[09:31:29.038]                 is_error <- inherits(cond, "error")
[09:31:29.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.038]                   NULL)
[09:31:29.038]                 if (is_error) {
[09:31:29.038]                   sessionInformation <- function() {
[09:31:29.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.038]                       search = base::search(), system = base::Sys.info())
[09:31:29.038]                   }
[09:31:29.038]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.038]                     cond$call), session = sessionInformation(), 
[09:31:29.038]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.038]                   signalCondition(cond)
[09:31:29.038]                 }
[09:31:29.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.038]                 "immediateCondition"))) {
[09:31:29.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.038]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.038]                   if (TRUE && !signal) {
[09:31:29.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.038]                     {
[09:31:29.038]                       inherits <- base::inherits
[09:31:29.038]                       invokeRestart <- base::invokeRestart
[09:31:29.038]                       is.null <- base::is.null
[09:31:29.038]                       muffled <- FALSE
[09:31:29.038]                       if (inherits(cond, "message")) {
[09:31:29.038]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.038]                         if (muffled) 
[09:31:29.038]                           invokeRestart("muffleMessage")
[09:31:29.038]                       }
[09:31:29.038]                       else if (inherits(cond, "warning")) {
[09:31:29.038]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.038]                         if (muffled) 
[09:31:29.038]                           invokeRestart("muffleWarning")
[09:31:29.038]                       }
[09:31:29.038]                       else if (inherits(cond, "condition")) {
[09:31:29.038]                         if (!is.null(pattern)) {
[09:31:29.038]                           computeRestarts <- base::computeRestarts
[09:31:29.038]                           grepl <- base::grepl
[09:31:29.038]                           restarts <- computeRestarts(cond)
[09:31:29.038]                           for (restart in restarts) {
[09:31:29.038]                             name <- restart$name
[09:31:29.038]                             if (is.null(name)) 
[09:31:29.038]                               next
[09:31:29.038]                             if (!grepl(pattern, name)) 
[09:31:29.038]                               next
[09:31:29.038]                             invokeRestart(restart)
[09:31:29.038]                             muffled <- TRUE
[09:31:29.038]                             break
[09:31:29.038]                           }
[09:31:29.038]                         }
[09:31:29.038]                       }
[09:31:29.038]                       invisible(muffled)
[09:31:29.038]                     }
[09:31:29.038]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.038]                   }
[09:31:29.038]                 }
[09:31:29.038]                 else {
[09:31:29.038]                   if (TRUE) {
[09:31:29.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.038]                     {
[09:31:29.038]                       inherits <- base::inherits
[09:31:29.038]                       invokeRestart <- base::invokeRestart
[09:31:29.038]                       is.null <- base::is.null
[09:31:29.038]                       muffled <- FALSE
[09:31:29.038]                       if (inherits(cond, "message")) {
[09:31:29.038]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.038]                         if (muffled) 
[09:31:29.038]                           invokeRestart("muffleMessage")
[09:31:29.038]                       }
[09:31:29.038]                       else if (inherits(cond, "warning")) {
[09:31:29.038]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.038]                         if (muffled) 
[09:31:29.038]                           invokeRestart("muffleWarning")
[09:31:29.038]                       }
[09:31:29.038]                       else if (inherits(cond, "condition")) {
[09:31:29.038]                         if (!is.null(pattern)) {
[09:31:29.038]                           computeRestarts <- base::computeRestarts
[09:31:29.038]                           grepl <- base::grepl
[09:31:29.038]                           restarts <- computeRestarts(cond)
[09:31:29.038]                           for (restart in restarts) {
[09:31:29.038]                             name <- restart$name
[09:31:29.038]                             if (is.null(name)) 
[09:31:29.038]                               next
[09:31:29.038]                             if (!grepl(pattern, name)) 
[09:31:29.038]                               next
[09:31:29.038]                             invokeRestart(restart)
[09:31:29.038]                             muffled <- TRUE
[09:31:29.038]                             break
[09:31:29.038]                           }
[09:31:29.038]                         }
[09:31:29.038]                       }
[09:31:29.038]                       invisible(muffled)
[09:31:29.038]                     }
[09:31:29.038]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.038]                   }
[09:31:29.038]                 }
[09:31:29.038]             }
[09:31:29.038]         }))
[09:31:29.038]     }, error = function(ex) {
[09:31:29.038]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.038]                 ...future.rng), started = ...future.startTime, 
[09:31:29.038]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.038]             version = "1.8"), class = "FutureResult")
[09:31:29.038]     }, finally = {
[09:31:29.038]         if (!identical(...future.workdir, getwd())) 
[09:31:29.038]             setwd(...future.workdir)
[09:31:29.038]         {
[09:31:29.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.038]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.038]             }
[09:31:29.038]             base::options(...future.oldOptions)
[09:31:29.038]             if (.Platform$OS.type == "windows") {
[09:31:29.038]                 old_names <- names(...future.oldEnvVars)
[09:31:29.038]                 envs <- base::Sys.getenv()
[09:31:29.038]                 names <- names(envs)
[09:31:29.038]                 common <- intersect(names, old_names)
[09:31:29.038]                 added <- setdiff(names, old_names)
[09:31:29.038]                 removed <- setdiff(old_names, names)
[09:31:29.038]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.038]                   envs[common]]
[09:31:29.038]                 NAMES <- toupper(changed)
[09:31:29.038]                 args <- list()
[09:31:29.038]                 for (kk in seq_along(NAMES)) {
[09:31:29.038]                   name <- changed[[kk]]
[09:31:29.038]                   NAME <- NAMES[[kk]]
[09:31:29.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.038]                     next
[09:31:29.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.038]                 }
[09:31:29.038]                 NAMES <- toupper(added)
[09:31:29.038]                 for (kk in seq_along(NAMES)) {
[09:31:29.038]                   name <- added[[kk]]
[09:31:29.038]                   NAME <- NAMES[[kk]]
[09:31:29.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.038]                     next
[09:31:29.038]                   args[[name]] <- ""
[09:31:29.038]                 }
[09:31:29.038]                 NAMES <- toupper(removed)
[09:31:29.038]                 for (kk in seq_along(NAMES)) {
[09:31:29.038]                   name <- removed[[kk]]
[09:31:29.038]                   NAME <- NAMES[[kk]]
[09:31:29.038]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.038]                     next
[09:31:29.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.038]                 }
[09:31:29.038]                 if (length(args) > 0) 
[09:31:29.038]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.038]             }
[09:31:29.038]             else {
[09:31:29.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.038]             }
[09:31:29.038]             {
[09:31:29.038]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.038]                   0L) {
[09:31:29.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.038]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.038]                   base::options(opts)
[09:31:29.038]                 }
[09:31:29.038]                 {
[09:31:29.038]                   {
[09:31:29.038]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.038]                     NULL
[09:31:29.038]                   }
[09:31:29.038]                   options(future.plan = NULL)
[09:31:29.038]                   if (is.na(NA_character_)) 
[09:31:29.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.038]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.038]                     .init = FALSE)
[09:31:29.038]                 }
[09:31:29.038]             }
[09:31:29.038]         }
[09:31:29.038]     })
[09:31:29.038]     if (TRUE) {
[09:31:29.038]         base::sink(type = "output", split = FALSE)
[09:31:29.038]         if (TRUE) {
[09:31:29.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.038]         }
[09:31:29.038]         else {
[09:31:29.038]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.038]         }
[09:31:29.038]         base::close(...future.stdout)
[09:31:29.038]         ...future.stdout <- NULL
[09:31:29.038]     }
[09:31:29.038]     ...future.result$conditions <- ...future.conditions
[09:31:29.038]     ...future.result$finished <- base::Sys.time()
[09:31:29.038]     ...future.result
[09:31:29.038] }
[09:31:29.040] assign_globals() ...
[09:31:29.041] List of 1
[09:31:29.041]  $ x: list()
[09:31:29.041]  - attr(*, "where")=List of 1
[09:31:29.041]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.041]  - attr(*, "resolved")= logi TRUE
[09:31:29.041]  - attr(*, "total_size")= num 0
[09:31:29.041]  - attr(*, "already-done")= logi TRUE
[09:31:29.043] - copied ‘x’ to environment
[09:31:29.043] assign_globals() ... done
[09:31:29.043] requestCore(): workers = 2
[09:31:29.046] MulticoreFuture started
[09:31:29.046] - Launch lazy future ... done
[09:31:29.047] run() for ‘MulticoreFuture’ ... done
[09:31:29.047] plan(): Setting new future strategy stack:
[09:31:29.047] List of future strategies:
[09:31:29.047] 1. sequential:
[09:31:29.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.047]    - tweaked: FALSE
[09:31:29.047]    - call: NULL
[09:31:29.048] result() for MulticoreFuture ...
[09:31:29.048] plan(): nbrOfWorkers() = 1
[09:31:29.050] plan(): Setting new future strategy stack:
[09:31:29.050] List of future strategies:
[09:31:29.050] 1. multicore:
[09:31:29.050]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.050]    - tweaked: FALSE
[09:31:29.050]    - call: plan(strategy)
[09:31:29.059] plan(): nbrOfWorkers() = 2
[09:31:29.066] result() for MulticoreFuture ...
[09:31:29.066] result() for MulticoreFuture ... done
[09:31:29.066] result() for MulticoreFuture ... done
[09:31:29.066] result() for MulticoreFuture ...
[09:31:29.066] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.067] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.067] Searching for globals...
[09:31:29.070] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.070] Searching for globals ... DONE
[09:31:29.070] Resolving globals: TRUE
[09:31:29.070] Resolving any globals that are futures ...
[09:31:29.070] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.070] Resolving any globals that are futures ... DONE
[09:31:29.071] Resolving futures part of globals (recursively) ...
[09:31:29.071] resolve() on list ...
[09:31:29.071]  recursive: 99
[09:31:29.071]  length: 1
[09:31:29.071]  elements: ‘x’
[09:31:29.071]  length: 0 (resolved future 1)
[09:31:29.072] resolve() on list ... DONE
[09:31:29.072] - globals: [1] ‘x’
[09:31:29.072] Resolving futures part of globals (recursively) ... DONE
[09:31:29.072] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.072] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.073] - globals: [1] ‘x’
[09:31:29.073] 
[09:31:29.073] getGlobalsAndPackages() ... DONE
[09:31:29.073] run() for ‘Future’ ...
[09:31:29.073] - state: ‘created’
[09:31:29.073] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.077] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.077] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.077]   - Field: ‘label’
[09:31:29.078]   - Field: ‘local’
[09:31:29.078]   - Field: ‘owner’
[09:31:29.078]   - Field: ‘envir’
[09:31:29.078]   - Field: ‘workers’
[09:31:29.078]   - Field: ‘packages’
[09:31:29.078]   - Field: ‘gc’
[09:31:29.078]   - Field: ‘job’
[09:31:29.078]   - Field: ‘conditions’
[09:31:29.078]   - Field: ‘expr’
[09:31:29.079]   - Field: ‘uuid’
[09:31:29.079]   - Field: ‘seed’
[09:31:29.079]   - Field: ‘version’
[09:31:29.079]   - Field: ‘result’
[09:31:29.079]   - Field: ‘asynchronous’
[09:31:29.079]   - Field: ‘calls’
[09:31:29.079]   - Field: ‘globals’
[09:31:29.079]   - Field: ‘stdout’
[09:31:29.079]   - Field: ‘earlySignal’
[09:31:29.079]   - Field: ‘lazy’
[09:31:29.080]   - Field: ‘state’
[09:31:29.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.080] - Launch lazy future ...
[09:31:29.080] Packages needed by the future expression (n = 0): <none>
[09:31:29.080] Packages needed by future strategies (n = 0): <none>
[09:31:29.081] {
[09:31:29.081]     {
[09:31:29.081]         {
[09:31:29.081]             ...future.startTime <- base::Sys.time()
[09:31:29.081]             {
[09:31:29.081]                 {
[09:31:29.081]                   {
[09:31:29.081]                     {
[09:31:29.081]                       base::local({
[09:31:29.081]                         has_future <- base::requireNamespace("future", 
[09:31:29.081]                           quietly = TRUE)
[09:31:29.081]                         if (has_future) {
[09:31:29.081]                           ns <- base::getNamespace("future")
[09:31:29.081]                           version <- ns[[".package"]][["version"]]
[09:31:29.081]                           if (is.null(version)) 
[09:31:29.081]                             version <- utils::packageVersion("future")
[09:31:29.081]                         }
[09:31:29.081]                         else {
[09:31:29.081]                           version <- NULL
[09:31:29.081]                         }
[09:31:29.081]                         if (!has_future || version < "1.8.0") {
[09:31:29.081]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.081]                             "", base::R.version$version.string), 
[09:31:29.081]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.081]                               "release", "version")], collapse = " "), 
[09:31:29.081]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.081]                             info)
[09:31:29.081]                           info <- base::paste(info, collapse = "; ")
[09:31:29.081]                           if (!has_future) {
[09:31:29.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.081]                               info)
[09:31:29.081]                           }
[09:31:29.081]                           else {
[09:31:29.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.081]                               info, version)
[09:31:29.081]                           }
[09:31:29.081]                           base::stop(msg)
[09:31:29.081]                         }
[09:31:29.081]                       })
[09:31:29.081]                     }
[09:31:29.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.081]                     base::options(mc.cores = 1L)
[09:31:29.081]                   }
[09:31:29.081]                   ...future.strategy.old <- future::plan("list")
[09:31:29.081]                   options(future.plan = NULL)
[09:31:29.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.081]                 }
[09:31:29.081]                 ...future.workdir <- getwd()
[09:31:29.081]             }
[09:31:29.081]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.081]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.081]         }
[09:31:29.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.081]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.081]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.081]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.081]             base::names(...future.oldOptions))
[09:31:29.081]     }
[09:31:29.081]     if (FALSE) {
[09:31:29.081]     }
[09:31:29.081]     else {
[09:31:29.081]         if (TRUE) {
[09:31:29.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.081]                 open = "w")
[09:31:29.081]         }
[09:31:29.081]         else {
[09:31:29.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.081]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.081]         }
[09:31:29.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.081]             base::sink(type = "output", split = FALSE)
[09:31:29.081]             base::close(...future.stdout)
[09:31:29.081]         }, add = TRUE)
[09:31:29.081]     }
[09:31:29.081]     ...future.frame <- base::sys.nframe()
[09:31:29.081]     ...future.conditions <- base::list()
[09:31:29.081]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.081]     if (FALSE) {
[09:31:29.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.081]     }
[09:31:29.081]     ...future.result <- base::tryCatch({
[09:31:29.081]         base::withCallingHandlers({
[09:31:29.081]             ...future.value <- base::withVisible(base::local({
[09:31:29.081]                 withCallingHandlers({
[09:31:29.081]                   {
[09:31:29.081]                     x$a <- 1
[09:31:29.081]                     x
[09:31:29.081]                   }
[09:31:29.081]                 }, immediateCondition = function(cond) {
[09:31:29.081]                   save_rds <- function (object, pathname, ...) 
[09:31:29.081]                   {
[09:31:29.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.081]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.081]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.081]                         fi_tmp[["mtime"]])
[09:31:29.081]                     }
[09:31:29.081]                     tryCatch({
[09:31:29.081]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.081]                     }, error = function(ex) {
[09:31:29.081]                       msg <- conditionMessage(ex)
[09:31:29.081]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.081]                         fi_tmp[["mtime"]], msg)
[09:31:29.081]                       ex$message <- msg
[09:31:29.081]                       stop(ex)
[09:31:29.081]                     })
[09:31:29.081]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.081]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.081]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.081]                       fi <- file.info(pathname)
[09:31:29.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.081]                         fi[["size"]], fi[["mtime"]])
[09:31:29.081]                       stop(msg)
[09:31:29.081]                     }
[09:31:29.081]                     invisible(pathname)
[09:31:29.081]                   }
[09:31:29.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.081]                     rootPath = tempdir()) 
[09:31:29.081]                   {
[09:31:29.081]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.081]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.081]                       tmpdir = path, fileext = ".rds")
[09:31:29.081]                     save_rds(obj, file)
[09:31:29.081]                   }
[09:31:29.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.081]                   {
[09:31:29.081]                     inherits <- base::inherits
[09:31:29.081]                     invokeRestart <- base::invokeRestart
[09:31:29.081]                     is.null <- base::is.null
[09:31:29.081]                     muffled <- FALSE
[09:31:29.081]                     if (inherits(cond, "message")) {
[09:31:29.081]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.081]                       if (muffled) 
[09:31:29.081]                         invokeRestart("muffleMessage")
[09:31:29.081]                     }
[09:31:29.081]                     else if (inherits(cond, "warning")) {
[09:31:29.081]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.081]                       if (muffled) 
[09:31:29.081]                         invokeRestart("muffleWarning")
[09:31:29.081]                     }
[09:31:29.081]                     else if (inherits(cond, "condition")) {
[09:31:29.081]                       if (!is.null(pattern)) {
[09:31:29.081]                         computeRestarts <- base::computeRestarts
[09:31:29.081]                         grepl <- base::grepl
[09:31:29.081]                         restarts <- computeRestarts(cond)
[09:31:29.081]                         for (restart in restarts) {
[09:31:29.081]                           name <- restart$name
[09:31:29.081]                           if (is.null(name)) 
[09:31:29.081]                             next
[09:31:29.081]                           if (!grepl(pattern, name)) 
[09:31:29.081]                             next
[09:31:29.081]                           invokeRestart(restart)
[09:31:29.081]                           muffled <- TRUE
[09:31:29.081]                           break
[09:31:29.081]                         }
[09:31:29.081]                       }
[09:31:29.081]                     }
[09:31:29.081]                     invisible(muffled)
[09:31:29.081]                   }
[09:31:29.081]                   muffleCondition(cond)
[09:31:29.081]                 })
[09:31:29.081]             }))
[09:31:29.081]             future::FutureResult(value = ...future.value$value, 
[09:31:29.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.081]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.081]                     ...future.globalenv.names))
[09:31:29.081]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.081]         }, condition = base::local({
[09:31:29.081]             c <- base::c
[09:31:29.081]             inherits <- base::inherits
[09:31:29.081]             invokeRestart <- base::invokeRestart
[09:31:29.081]             length <- base::length
[09:31:29.081]             list <- base::list
[09:31:29.081]             seq.int <- base::seq.int
[09:31:29.081]             signalCondition <- base::signalCondition
[09:31:29.081]             sys.calls <- base::sys.calls
[09:31:29.081]             `[[` <- base::`[[`
[09:31:29.081]             `+` <- base::`+`
[09:31:29.081]             `<<-` <- base::`<<-`
[09:31:29.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.081]                   3L)]
[09:31:29.081]             }
[09:31:29.081]             function(cond) {
[09:31:29.081]                 is_error <- inherits(cond, "error")
[09:31:29.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.081]                   NULL)
[09:31:29.081]                 if (is_error) {
[09:31:29.081]                   sessionInformation <- function() {
[09:31:29.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.081]                       search = base::search(), system = base::Sys.info())
[09:31:29.081]                   }
[09:31:29.081]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.081]                     cond$call), session = sessionInformation(), 
[09:31:29.081]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.081]                   signalCondition(cond)
[09:31:29.081]                 }
[09:31:29.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.081]                 "immediateCondition"))) {
[09:31:29.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.081]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.081]                   if (TRUE && !signal) {
[09:31:29.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.081]                     {
[09:31:29.081]                       inherits <- base::inherits
[09:31:29.081]                       invokeRestart <- base::invokeRestart
[09:31:29.081]                       is.null <- base::is.null
[09:31:29.081]                       muffled <- FALSE
[09:31:29.081]                       if (inherits(cond, "message")) {
[09:31:29.081]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.081]                         if (muffled) 
[09:31:29.081]                           invokeRestart("muffleMessage")
[09:31:29.081]                       }
[09:31:29.081]                       else if (inherits(cond, "warning")) {
[09:31:29.081]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.081]                         if (muffled) 
[09:31:29.081]                           invokeRestart("muffleWarning")
[09:31:29.081]                       }
[09:31:29.081]                       else if (inherits(cond, "condition")) {
[09:31:29.081]                         if (!is.null(pattern)) {
[09:31:29.081]                           computeRestarts <- base::computeRestarts
[09:31:29.081]                           grepl <- base::grepl
[09:31:29.081]                           restarts <- computeRestarts(cond)
[09:31:29.081]                           for (restart in restarts) {
[09:31:29.081]                             name <- restart$name
[09:31:29.081]                             if (is.null(name)) 
[09:31:29.081]                               next
[09:31:29.081]                             if (!grepl(pattern, name)) 
[09:31:29.081]                               next
[09:31:29.081]                             invokeRestart(restart)
[09:31:29.081]                             muffled <- TRUE
[09:31:29.081]                             break
[09:31:29.081]                           }
[09:31:29.081]                         }
[09:31:29.081]                       }
[09:31:29.081]                       invisible(muffled)
[09:31:29.081]                     }
[09:31:29.081]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.081]                   }
[09:31:29.081]                 }
[09:31:29.081]                 else {
[09:31:29.081]                   if (TRUE) {
[09:31:29.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.081]                     {
[09:31:29.081]                       inherits <- base::inherits
[09:31:29.081]                       invokeRestart <- base::invokeRestart
[09:31:29.081]                       is.null <- base::is.null
[09:31:29.081]                       muffled <- FALSE
[09:31:29.081]                       if (inherits(cond, "message")) {
[09:31:29.081]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.081]                         if (muffled) 
[09:31:29.081]                           invokeRestart("muffleMessage")
[09:31:29.081]                       }
[09:31:29.081]                       else if (inherits(cond, "warning")) {
[09:31:29.081]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.081]                         if (muffled) 
[09:31:29.081]                           invokeRestart("muffleWarning")
[09:31:29.081]                       }
[09:31:29.081]                       else if (inherits(cond, "condition")) {
[09:31:29.081]                         if (!is.null(pattern)) {
[09:31:29.081]                           computeRestarts <- base::computeRestarts
[09:31:29.081]                           grepl <- base::grepl
[09:31:29.081]                           restarts <- computeRestarts(cond)
[09:31:29.081]                           for (restart in restarts) {
[09:31:29.081]                             name <- restart$name
[09:31:29.081]                             if (is.null(name)) 
[09:31:29.081]                               next
[09:31:29.081]                             if (!grepl(pattern, name)) 
[09:31:29.081]                               next
[09:31:29.081]                             invokeRestart(restart)
[09:31:29.081]                             muffled <- TRUE
[09:31:29.081]                             break
[09:31:29.081]                           }
[09:31:29.081]                         }
[09:31:29.081]                       }
[09:31:29.081]                       invisible(muffled)
[09:31:29.081]                     }
[09:31:29.081]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.081]                   }
[09:31:29.081]                 }
[09:31:29.081]             }
[09:31:29.081]         }))
[09:31:29.081]     }, error = function(ex) {
[09:31:29.081]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.081]                 ...future.rng), started = ...future.startTime, 
[09:31:29.081]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.081]             version = "1.8"), class = "FutureResult")
[09:31:29.081]     }, finally = {
[09:31:29.081]         if (!identical(...future.workdir, getwd())) 
[09:31:29.081]             setwd(...future.workdir)
[09:31:29.081]         {
[09:31:29.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.081]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.081]             }
[09:31:29.081]             base::options(...future.oldOptions)
[09:31:29.081]             if (.Platform$OS.type == "windows") {
[09:31:29.081]                 old_names <- names(...future.oldEnvVars)
[09:31:29.081]                 envs <- base::Sys.getenv()
[09:31:29.081]                 names <- names(envs)
[09:31:29.081]                 common <- intersect(names, old_names)
[09:31:29.081]                 added <- setdiff(names, old_names)
[09:31:29.081]                 removed <- setdiff(old_names, names)
[09:31:29.081]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.081]                   envs[common]]
[09:31:29.081]                 NAMES <- toupper(changed)
[09:31:29.081]                 args <- list()
[09:31:29.081]                 for (kk in seq_along(NAMES)) {
[09:31:29.081]                   name <- changed[[kk]]
[09:31:29.081]                   NAME <- NAMES[[kk]]
[09:31:29.081]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.081]                     next
[09:31:29.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.081]                 }
[09:31:29.081]                 NAMES <- toupper(added)
[09:31:29.081]                 for (kk in seq_along(NAMES)) {
[09:31:29.081]                   name <- added[[kk]]
[09:31:29.081]                   NAME <- NAMES[[kk]]
[09:31:29.081]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.081]                     next
[09:31:29.081]                   args[[name]] <- ""
[09:31:29.081]                 }
[09:31:29.081]                 NAMES <- toupper(removed)
[09:31:29.081]                 for (kk in seq_along(NAMES)) {
[09:31:29.081]                   name <- removed[[kk]]
[09:31:29.081]                   NAME <- NAMES[[kk]]
[09:31:29.081]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.081]                     next
[09:31:29.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.081]                 }
[09:31:29.081]                 if (length(args) > 0) 
[09:31:29.081]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.081]             }
[09:31:29.081]             else {
[09:31:29.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.081]             }
[09:31:29.081]             {
[09:31:29.081]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.081]                   0L) {
[09:31:29.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.081]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.081]                   base::options(opts)
[09:31:29.081]                 }
[09:31:29.081]                 {
[09:31:29.081]                   {
[09:31:29.081]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.081]                     NULL
[09:31:29.081]                   }
[09:31:29.081]                   options(future.plan = NULL)
[09:31:29.081]                   if (is.na(NA_character_)) 
[09:31:29.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.081]                     .init = FALSE)
[09:31:29.081]                 }
[09:31:29.081]             }
[09:31:29.081]         }
[09:31:29.081]     })
[09:31:29.081]     if (TRUE) {
[09:31:29.081]         base::sink(type = "output", split = FALSE)
[09:31:29.081]         if (TRUE) {
[09:31:29.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.081]         }
[09:31:29.081]         else {
[09:31:29.081]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.081]         }
[09:31:29.081]         base::close(...future.stdout)
[09:31:29.081]         ...future.stdout <- NULL
[09:31:29.081]     }
[09:31:29.081]     ...future.result$conditions <- ...future.conditions
[09:31:29.081]     ...future.result$finished <- base::Sys.time()
[09:31:29.081]     ...future.result
[09:31:29.081] }
[09:31:29.083] assign_globals() ...
[09:31:29.083] List of 1
[09:31:29.083]  $ x: list()
[09:31:29.083]  - attr(*, "where")=List of 1
[09:31:29.083]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.083]  - attr(*, "resolved")= logi TRUE
[09:31:29.083]  - attr(*, "total_size")= num 0
[09:31:29.083]  - attr(*, "already-done")= logi TRUE
[09:31:29.086] - copied ‘x’ to environment
[09:31:29.086] assign_globals() ... done
[09:31:29.086] requestCore(): workers = 2
[09:31:29.088] MulticoreFuture started
[09:31:29.088] - Launch lazy future ... done
[09:31:29.088] run() for ‘MulticoreFuture’ ... done
[09:31:29.089] result() for MulticoreFuture ...
[09:31:29.089] plan(): Setting new future strategy stack:
[09:31:29.089] List of future strategies:
[09:31:29.089] 1. sequential:
[09:31:29.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.089]    - tweaked: FALSE
[09:31:29.089]    - call: NULL
[09:31:29.090] plan(): nbrOfWorkers() = 1
[09:31:29.092] plan(): Setting new future strategy stack:
[09:31:29.092] List of future strategies:
[09:31:29.092] 1. multicore:
[09:31:29.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.092]    - tweaked: FALSE
[09:31:29.092]    - call: plan(strategy)
[09:31:29.097] plan(): nbrOfWorkers() = 2
[09:31:29.098] result() for MulticoreFuture ...
[09:31:29.098] result() for MulticoreFuture ... done
[09:31:29.098] result() for MulticoreFuture ... done
[09:31:29.099] result() for MulticoreFuture ...
[09:31:29.099] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.100] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.100] Searching for globals...
[09:31:29.103] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.103] Searching for globals ... DONE
[09:31:29.103] Resolving globals: TRUE
[09:31:29.103] Resolving any globals that are futures ...
[09:31:29.103] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.103] Resolving any globals that are futures ... DONE
[09:31:29.104] Resolving futures part of globals (recursively) ...
[09:31:29.104] resolve() on list ...
[09:31:29.104]  recursive: 99
[09:31:29.104]  length: 1
[09:31:29.104]  elements: ‘x’
[09:31:29.105]  length: 0 (resolved future 1)
[09:31:29.105] resolve() on list ... DONE
[09:31:29.105] - globals: [1] ‘x’
[09:31:29.105] Resolving futures part of globals (recursively) ... DONE
[09:31:29.105] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.105] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.106] - globals: [1] ‘x’
[09:31:29.106] 
[09:31:29.106] getGlobalsAndPackages() ... DONE
[09:31:29.106] run() for ‘Future’ ...
[09:31:29.106] - state: ‘created’
[09:31:29.106] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.113] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.113]   - Field: ‘label’
[09:31:29.113]   - Field: ‘local’
[09:31:29.113]   - Field: ‘owner’
[09:31:29.113]   - Field: ‘envir’
[09:31:29.113]   - Field: ‘workers’
[09:31:29.113]   - Field: ‘packages’
[09:31:29.113]   - Field: ‘gc’
[09:31:29.114]   - Field: ‘job’
[09:31:29.114]   - Field: ‘conditions’
[09:31:29.114]   - Field: ‘expr’
[09:31:29.114]   - Field: ‘uuid’
[09:31:29.114]   - Field: ‘seed’
[09:31:29.114]   - Field: ‘version’
[09:31:29.114]   - Field: ‘result’
[09:31:29.114]   - Field: ‘asynchronous’
[09:31:29.115]   - Field: ‘calls’
[09:31:29.115]   - Field: ‘globals’
[09:31:29.115]   - Field: ‘stdout’
[09:31:29.115]   - Field: ‘earlySignal’
[09:31:29.115]   - Field: ‘lazy’
[09:31:29.115]   - Field: ‘state’
[09:31:29.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.115] - Launch lazy future ...
[09:31:29.116] Packages needed by the future expression (n = 0): <none>
[09:31:29.116] Packages needed by future strategies (n = 0): <none>
[09:31:29.116] {
[09:31:29.116]     {
[09:31:29.116]         {
[09:31:29.116]             ...future.startTime <- base::Sys.time()
[09:31:29.116]             {
[09:31:29.116]                 {
[09:31:29.116]                   {
[09:31:29.116]                     {
[09:31:29.116]                       base::local({
[09:31:29.116]                         has_future <- base::requireNamespace("future", 
[09:31:29.116]                           quietly = TRUE)
[09:31:29.116]                         if (has_future) {
[09:31:29.116]                           ns <- base::getNamespace("future")
[09:31:29.116]                           version <- ns[[".package"]][["version"]]
[09:31:29.116]                           if (is.null(version)) 
[09:31:29.116]                             version <- utils::packageVersion("future")
[09:31:29.116]                         }
[09:31:29.116]                         else {
[09:31:29.116]                           version <- NULL
[09:31:29.116]                         }
[09:31:29.116]                         if (!has_future || version < "1.8.0") {
[09:31:29.116]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.116]                             "", base::R.version$version.string), 
[09:31:29.116]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.116]                               "release", "version")], collapse = " "), 
[09:31:29.116]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.116]                             info)
[09:31:29.116]                           info <- base::paste(info, collapse = "; ")
[09:31:29.116]                           if (!has_future) {
[09:31:29.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.116]                               info)
[09:31:29.116]                           }
[09:31:29.116]                           else {
[09:31:29.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.116]                               info, version)
[09:31:29.116]                           }
[09:31:29.116]                           base::stop(msg)
[09:31:29.116]                         }
[09:31:29.116]                       })
[09:31:29.116]                     }
[09:31:29.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.116]                     base::options(mc.cores = 1L)
[09:31:29.116]                   }
[09:31:29.116]                   ...future.strategy.old <- future::plan("list")
[09:31:29.116]                   options(future.plan = NULL)
[09:31:29.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.116]                 }
[09:31:29.116]                 ...future.workdir <- getwd()
[09:31:29.116]             }
[09:31:29.116]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.116]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.116]         }
[09:31:29.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.116]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.116]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.116]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.116]             base::names(...future.oldOptions))
[09:31:29.116]     }
[09:31:29.116]     if (FALSE) {
[09:31:29.116]     }
[09:31:29.116]     else {
[09:31:29.116]         if (TRUE) {
[09:31:29.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.116]                 open = "w")
[09:31:29.116]         }
[09:31:29.116]         else {
[09:31:29.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.116]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.116]         }
[09:31:29.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.116]             base::sink(type = "output", split = FALSE)
[09:31:29.116]             base::close(...future.stdout)
[09:31:29.116]         }, add = TRUE)
[09:31:29.116]     }
[09:31:29.116]     ...future.frame <- base::sys.nframe()
[09:31:29.116]     ...future.conditions <- base::list()
[09:31:29.116]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.116]     if (FALSE) {
[09:31:29.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.116]     }
[09:31:29.116]     ...future.result <- base::tryCatch({
[09:31:29.116]         base::withCallingHandlers({
[09:31:29.116]             ...future.value <- base::withVisible(base::local({
[09:31:29.116]                 withCallingHandlers({
[09:31:29.116]                   {
[09:31:29.116]                     x$a <- 1
[09:31:29.116]                     x
[09:31:29.116]                   }
[09:31:29.116]                 }, immediateCondition = function(cond) {
[09:31:29.116]                   save_rds <- function (object, pathname, ...) 
[09:31:29.116]                   {
[09:31:29.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.116]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.116]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.116]                         fi_tmp[["mtime"]])
[09:31:29.116]                     }
[09:31:29.116]                     tryCatch({
[09:31:29.116]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.116]                     }, error = function(ex) {
[09:31:29.116]                       msg <- conditionMessage(ex)
[09:31:29.116]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.116]                         fi_tmp[["mtime"]], msg)
[09:31:29.116]                       ex$message <- msg
[09:31:29.116]                       stop(ex)
[09:31:29.116]                     })
[09:31:29.116]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.116]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.116]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.116]                       fi <- file.info(pathname)
[09:31:29.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.116]                         fi[["size"]], fi[["mtime"]])
[09:31:29.116]                       stop(msg)
[09:31:29.116]                     }
[09:31:29.116]                     invisible(pathname)
[09:31:29.116]                   }
[09:31:29.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.116]                     rootPath = tempdir()) 
[09:31:29.116]                   {
[09:31:29.116]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.116]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.116]                       tmpdir = path, fileext = ".rds")
[09:31:29.116]                     save_rds(obj, file)
[09:31:29.116]                   }
[09:31:29.116]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.116]                   {
[09:31:29.116]                     inherits <- base::inherits
[09:31:29.116]                     invokeRestart <- base::invokeRestart
[09:31:29.116]                     is.null <- base::is.null
[09:31:29.116]                     muffled <- FALSE
[09:31:29.116]                     if (inherits(cond, "message")) {
[09:31:29.116]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.116]                       if (muffled) 
[09:31:29.116]                         invokeRestart("muffleMessage")
[09:31:29.116]                     }
[09:31:29.116]                     else if (inherits(cond, "warning")) {
[09:31:29.116]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.116]                       if (muffled) 
[09:31:29.116]                         invokeRestart("muffleWarning")
[09:31:29.116]                     }
[09:31:29.116]                     else if (inherits(cond, "condition")) {
[09:31:29.116]                       if (!is.null(pattern)) {
[09:31:29.116]                         computeRestarts <- base::computeRestarts
[09:31:29.116]                         grepl <- base::grepl
[09:31:29.116]                         restarts <- computeRestarts(cond)
[09:31:29.116]                         for (restart in restarts) {
[09:31:29.116]                           name <- restart$name
[09:31:29.116]                           if (is.null(name)) 
[09:31:29.116]                             next
[09:31:29.116]                           if (!grepl(pattern, name)) 
[09:31:29.116]                             next
[09:31:29.116]                           invokeRestart(restart)
[09:31:29.116]                           muffled <- TRUE
[09:31:29.116]                           break
[09:31:29.116]                         }
[09:31:29.116]                       }
[09:31:29.116]                     }
[09:31:29.116]                     invisible(muffled)
[09:31:29.116]                   }
[09:31:29.116]                   muffleCondition(cond)
[09:31:29.116]                 })
[09:31:29.116]             }))
[09:31:29.116]             future::FutureResult(value = ...future.value$value, 
[09:31:29.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.116]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.116]                     ...future.globalenv.names))
[09:31:29.116]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.116]         }, condition = base::local({
[09:31:29.116]             c <- base::c
[09:31:29.116]             inherits <- base::inherits
[09:31:29.116]             invokeRestart <- base::invokeRestart
[09:31:29.116]             length <- base::length
[09:31:29.116]             list <- base::list
[09:31:29.116]             seq.int <- base::seq.int
[09:31:29.116]             signalCondition <- base::signalCondition
[09:31:29.116]             sys.calls <- base::sys.calls
[09:31:29.116]             `[[` <- base::`[[`
[09:31:29.116]             `+` <- base::`+`
[09:31:29.116]             `<<-` <- base::`<<-`
[09:31:29.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.116]                   3L)]
[09:31:29.116]             }
[09:31:29.116]             function(cond) {
[09:31:29.116]                 is_error <- inherits(cond, "error")
[09:31:29.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.116]                   NULL)
[09:31:29.116]                 if (is_error) {
[09:31:29.116]                   sessionInformation <- function() {
[09:31:29.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.116]                       search = base::search(), system = base::Sys.info())
[09:31:29.116]                   }
[09:31:29.116]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.116]                     cond$call), session = sessionInformation(), 
[09:31:29.116]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.116]                   signalCondition(cond)
[09:31:29.116]                 }
[09:31:29.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.116]                 "immediateCondition"))) {
[09:31:29.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.116]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.116]                   if (TRUE && !signal) {
[09:31:29.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.116]                     {
[09:31:29.116]                       inherits <- base::inherits
[09:31:29.116]                       invokeRestart <- base::invokeRestart
[09:31:29.116]                       is.null <- base::is.null
[09:31:29.116]                       muffled <- FALSE
[09:31:29.116]                       if (inherits(cond, "message")) {
[09:31:29.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.116]                         if (muffled) 
[09:31:29.116]                           invokeRestart("muffleMessage")
[09:31:29.116]                       }
[09:31:29.116]                       else if (inherits(cond, "warning")) {
[09:31:29.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.116]                         if (muffled) 
[09:31:29.116]                           invokeRestart("muffleWarning")
[09:31:29.116]                       }
[09:31:29.116]                       else if (inherits(cond, "condition")) {
[09:31:29.116]                         if (!is.null(pattern)) {
[09:31:29.116]                           computeRestarts <- base::computeRestarts
[09:31:29.116]                           grepl <- base::grepl
[09:31:29.116]                           restarts <- computeRestarts(cond)
[09:31:29.116]                           for (restart in restarts) {
[09:31:29.116]                             name <- restart$name
[09:31:29.116]                             if (is.null(name)) 
[09:31:29.116]                               next
[09:31:29.116]                             if (!grepl(pattern, name)) 
[09:31:29.116]                               next
[09:31:29.116]                             invokeRestart(restart)
[09:31:29.116]                             muffled <- TRUE
[09:31:29.116]                             break
[09:31:29.116]                           }
[09:31:29.116]                         }
[09:31:29.116]                       }
[09:31:29.116]                       invisible(muffled)
[09:31:29.116]                     }
[09:31:29.116]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.116]                   }
[09:31:29.116]                 }
[09:31:29.116]                 else {
[09:31:29.116]                   if (TRUE) {
[09:31:29.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.116]                     {
[09:31:29.116]                       inherits <- base::inherits
[09:31:29.116]                       invokeRestart <- base::invokeRestart
[09:31:29.116]                       is.null <- base::is.null
[09:31:29.116]                       muffled <- FALSE
[09:31:29.116]                       if (inherits(cond, "message")) {
[09:31:29.116]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.116]                         if (muffled) 
[09:31:29.116]                           invokeRestart("muffleMessage")
[09:31:29.116]                       }
[09:31:29.116]                       else if (inherits(cond, "warning")) {
[09:31:29.116]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.116]                         if (muffled) 
[09:31:29.116]                           invokeRestart("muffleWarning")
[09:31:29.116]                       }
[09:31:29.116]                       else if (inherits(cond, "condition")) {
[09:31:29.116]                         if (!is.null(pattern)) {
[09:31:29.116]                           computeRestarts <- base::computeRestarts
[09:31:29.116]                           grepl <- base::grepl
[09:31:29.116]                           restarts <- computeRestarts(cond)
[09:31:29.116]                           for (restart in restarts) {
[09:31:29.116]                             name <- restart$name
[09:31:29.116]                             if (is.null(name)) 
[09:31:29.116]                               next
[09:31:29.116]                             if (!grepl(pattern, name)) 
[09:31:29.116]                               next
[09:31:29.116]                             invokeRestart(restart)
[09:31:29.116]                             muffled <- TRUE
[09:31:29.116]                             break
[09:31:29.116]                           }
[09:31:29.116]                         }
[09:31:29.116]                       }
[09:31:29.116]                       invisible(muffled)
[09:31:29.116]                     }
[09:31:29.116]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.116]                   }
[09:31:29.116]                 }
[09:31:29.116]             }
[09:31:29.116]         }))
[09:31:29.116]     }, error = function(ex) {
[09:31:29.116]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.116]                 ...future.rng), started = ...future.startTime, 
[09:31:29.116]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.116]             version = "1.8"), class = "FutureResult")
[09:31:29.116]     }, finally = {
[09:31:29.116]         if (!identical(...future.workdir, getwd())) 
[09:31:29.116]             setwd(...future.workdir)
[09:31:29.116]         {
[09:31:29.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.116]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.116]             }
[09:31:29.116]             base::options(...future.oldOptions)
[09:31:29.116]             if (.Platform$OS.type == "windows") {
[09:31:29.116]                 old_names <- names(...future.oldEnvVars)
[09:31:29.116]                 envs <- base::Sys.getenv()
[09:31:29.116]                 names <- names(envs)
[09:31:29.116]                 common <- intersect(names, old_names)
[09:31:29.116]                 added <- setdiff(names, old_names)
[09:31:29.116]                 removed <- setdiff(old_names, names)
[09:31:29.116]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.116]                   envs[common]]
[09:31:29.116]                 NAMES <- toupper(changed)
[09:31:29.116]                 args <- list()
[09:31:29.116]                 for (kk in seq_along(NAMES)) {
[09:31:29.116]                   name <- changed[[kk]]
[09:31:29.116]                   NAME <- NAMES[[kk]]
[09:31:29.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.116]                     next
[09:31:29.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.116]                 }
[09:31:29.116]                 NAMES <- toupper(added)
[09:31:29.116]                 for (kk in seq_along(NAMES)) {
[09:31:29.116]                   name <- added[[kk]]
[09:31:29.116]                   NAME <- NAMES[[kk]]
[09:31:29.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.116]                     next
[09:31:29.116]                   args[[name]] <- ""
[09:31:29.116]                 }
[09:31:29.116]                 NAMES <- toupper(removed)
[09:31:29.116]                 for (kk in seq_along(NAMES)) {
[09:31:29.116]                   name <- removed[[kk]]
[09:31:29.116]                   NAME <- NAMES[[kk]]
[09:31:29.116]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.116]                     next
[09:31:29.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.116]                 }
[09:31:29.116]                 if (length(args) > 0) 
[09:31:29.116]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.116]             }
[09:31:29.116]             else {
[09:31:29.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.116]             }
[09:31:29.116]             {
[09:31:29.116]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.116]                   0L) {
[09:31:29.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.116]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.116]                   base::options(opts)
[09:31:29.116]                 }
[09:31:29.116]                 {
[09:31:29.116]                   {
[09:31:29.116]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.116]                     NULL
[09:31:29.116]                   }
[09:31:29.116]                   options(future.plan = NULL)
[09:31:29.116]                   if (is.na(NA_character_)) 
[09:31:29.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.116]                     .init = FALSE)
[09:31:29.116]                 }
[09:31:29.116]             }
[09:31:29.116]         }
[09:31:29.116]     })
[09:31:29.116]     if (TRUE) {
[09:31:29.116]         base::sink(type = "output", split = FALSE)
[09:31:29.116]         if (TRUE) {
[09:31:29.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.116]         }
[09:31:29.116]         else {
[09:31:29.116]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.116]         }
[09:31:29.116]         base::close(...future.stdout)
[09:31:29.116]         ...future.stdout <- NULL
[09:31:29.116]     }
[09:31:29.116]     ...future.result$conditions <- ...future.conditions
[09:31:29.116]     ...future.result$finished <- base::Sys.time()
[09:31:29.116]     ...future.result
[09:31:29.116] }
[09:31:29.119] assign_globals() ...
[09:31:29.119] List of 1
[09:31:29.119]  $ x: list()
[09:31:29.119]  - attr(*, "where")=List of 1
[09:31:29.119]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.119]  - attr(*, "resolved")= logi TRUE
[09:31:29.119]  - attr(*, "total_size")= num 0
[09:31:29.119]  - attr(*, "already-done")= logi TRUE
[09:31:29.121] - copied ‘x’ to environment
[09:31:29.122] assign_globals() ... done
[09:31:29.122] requestCore(): workers = 2
[09:31:29.123] MulticoreFuture started
[09:31:29.124] - Launch lazy future ... done
[09:31:29.124] run() for ‘MulticoreFuture’ ... done
[09:31:29.124] result() for MulticoreFuture ...
[09:31:29.125] plan(): Setting new future strategy stack:
[09:31:29.125] List of future strategies:
[09:31:29.125] 1. sequential:
[09:31:29.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.125]    - tweaked: FALSE
[09:31:29.125]    - call: NULL
[09:31:29.126] plan(): nbrOfWorkers() = 1
[09:31:29.128] plan(): Setting new future strategy stack:
[09:31:29.128] List of future strategies:
[09:31:29.128] 1. multicore:
[09:31:29.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.128]    - tweaked: FALSE
[09:31:29.128]    - call: plan(strategy)
[09:31:29.133] plan(): nbrOfWorkers() = 2
[09:31:29.134] result() for MulticoreFuture ...
[09:31:29.134] result() for MulticoreFuture ... done
[09:31:29.134] result() for MulticoreFuture ... done
[09:31:29.134] result() for MulticoreFuture ...
[09:31:29.134] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.135] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.136] Searching for globals...
[09:31:29.138] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.138] Searching for globals ... DONE
[09:31:29.139] Resolving globals: TRUE
[09:31:29.139] Resolving any globals that are futures ...
[09:31:29.139] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:29.139] Resolving any globals that are futures ... DONE
[09:31:29.139] Resolving futures part of globals (recursively) ...
[09:31:29.140] resolve() on list ...
[09:31:29.140]  recursive: 99
[09:31:29.140]  length: 1
[09:31:29.140]  elements: ‘x’
[09:31:29.140]  length: 0 (resolved future 1)
[09:31:29.140] resolve() on list ... DONE
[09:31:29.140] - globals: [1] ‘x’
[09:31:29.141] Resolving futures part of globals (recursively) ... DONE
[09:31:29.141] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.141] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.141] - globals: [1] ‘x’
[09:31:29.141] 
[09:31:29.142] getGlobalsAndPackages() ... DONE
[09:31:29.142] run() for ‘Future’ ...
[09:31:29.142] - state: ‘created’
[09:31:29.142] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.146]   - Field: ‘label’
[09:31:29.147]   - Field: ‘local’
[09:31:29.147]   - Field: ‘owner’
[09:31:29.147]   - Field: ‘envir’
[09:31:29.147]   - Field: ‘workers’
[09:31:29.147]   - Field: ‘packages’
[09:31:29.147]   - Field: ‘gc’
[09:31:29.147]   - Field: ‘job’
[09:31:29.147]   - Field: ‘conditions’
[09:31:29.147]   - Field: ‘expr’
[09:31:29.148]   - Field: ‘uuid’
[09:31:29.148]   - Field: ‘seed’
[09:31:29.148]   - Field: ‘version’
[09:31:29.148]   - Field: ‘result’
[09:31:29.148]   - Field: ‘asynchronous’
[09:31:29.148]   - Field: ‘calls’
[09:31:29.148]   - Field: ‘globals’
[09:31:29.148]   - Field: ‘stdout’
[09:31:29.148]   - Field: ‘earlySignal’
[09:31:29.149]   - Field: ‘lazy’
[09:31:29.149]   - Field: ‘state’
[09:31:29.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.149] - Launch lazy future ...
[09:31:29.149] Packages needed by the future expression (n = 0): <none>
[09:31:29.149] Packages needed by future strategies (n = 0): <none>
[09:31:29.150] {
[09:31:29.150]     {
[09:31:29.150]         {
[09:31:29.150]             ...future.startTime <- base::Sys.time()
[09:31:29.150]             {
[09:31:29.150]                 {
[09:31:29.150]                   {
[09:31:29.150]                     {
[09:31:29.150]                       base::local({
[09:31:29.150]                         has_future <- base::requireNamespace("future", 
[09:31:29.150]                           quietly = TRUE)
[09:31:29.150]                         if (has_future) {
[09:31:29.150]                           ns <- base::getNamespace("future")
[09:31:29.150]                           version <- ns[[".package"]][["version"]]
[09:31:29.150]                           if (is.null(version)) 
[09:31:29.150]                             version <- utils::packageVersion("future")
[09:31:29.150]                         }
[09:31:29.150]                         else {
[09:31:29.150]                           version <- NULL
[09:31:29.150]                         }
[09:31:29.150]                         if (!has_future || version < "1.8.0") {
[09:31:29.150]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.150]                             "", base::R.version$version.string), 
[09:31:29.150]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.150]                               "release", "version")], collapse = " "), 
[09:31:29.150]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.150]                             info)
[09:31:29.150]                           info <- base::paste(info, collapse = "; ")
[09:31:29.150]                           if (!has_future) {
[09:31:29.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.150]                               info)
[09:31:29.150]                           }
[09:31:29.150]                           else {
[09:31:29.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.150]                               info, version)
[09:31:29.150]                           }
[09:31:29.150]                           base::stop(msg)
[09:31:29.150]                         }
[09:31:29.150]                       })
[09:31:29.150]                     }
[09:31:29.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.150]                     base::options(mc.cores = 1L)
[09:31:29.150]                   }
[09:31:29.150]                   ...future.strategy.old <- future::plan("list")
[09:31:29.150]                   options(future.plan = NULL)
[09:31:29.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.150]                 }
[09:31:29.150]                 ...future.workdir <- getwd()
[09:31:29.150]             }
[09:31:29.150]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.150]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.150]         }
[09:31:29.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.150]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.150]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.150]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.150]             base::names(...future.oldOptions))
[09:31:29.150]     }
[09:31:29.150]     if (FALSE) {
[09:31:29.150]     }
[09:31:29.150]     else {
[09:31:29.150]         if (TRUE) {
[09:31:29.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.150]                 open = "w")
[09:31:29.150]         }
[09:31:29.150]         else {
[09:31:29.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.150]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.150]         }
[09:31:29.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.150]             base::sink(type = "output", split = FALSE)
[09:31:29.150]             base::close(...future.stdout)
[09:31:29.150]         }, add = TRUE)
[09:31:29.150]     }
[09:31:29.150]     ...future.frame <- base::sys.nframe()
[09:31:29.150]     ...future.conditions <- base::list()
[09:31:29.150]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.150]     if (FALSE) {
[09:31:29.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.150]     }
[09:31:29.150]     ...future.result <- base::tryCatch({
[09:31:29.150]         base::withCallingHandlers({
[09:31:29.150]             ...future.value <- base::withVisible(base::local({
[09:31:29.150]                 withCallingHandlers({
[09:31:29.150]                   {
[09:31:29.150]                     x$a <- 1
[09:31:29.150]                     x
[09:31:29.150]                   }
[09:31:29.150]                 }, immediateCondition = function(cond) {
[09:31:29.150]                   save_rds <- function (object, pathname, ...) 
[09:31:29.150]                   {
[09:31:29.150]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.150]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.150]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.150]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.150]                         fi_tmp[["mtime"]])
[09:31:29.150]                     }
[09:31:29.150]                     tryCatch({
[09:31:29.150]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.150]                     }, error = function(ex) {
[09:31:29.150]                       msg <- conditionMessage(ex)
[09:31:29.150]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.150]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.150]                         fi_tmp[["mtime"]], msg)
[09:31:29.150]                       ex$message <- msg
[09:31:29.150]                       stop(ex)
[09:31:29.150]                     })
[09:31:29.150]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.150]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.150]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.150]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.150]                       fi <- file.info(pathname)
[09:31:29.150]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.150]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.150]                         fi[["size"]], fi[["mtime"]])
[09:31:29.150]                       stop(msg)
[09:31:29.150]                     }
[09:31:29.150]                     invisible(pathname)
[09:31:29.150]                   }
[09:31:29.150]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.150]                     rootPath = tempdir()) 
[09:31:29.150]                   {
[09:31:29.150]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.150]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.150]                       tmpdir = path, fileext = ".rds")
[09:31:29.150]                     save_rds(obj, file)
[09:31:29.150]                   }
[09:31:29.150]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.150]                   {
[09:31:29.150]                     inherits <- base::inherits
[09:31:29.150]                     invokeRestart <- base::invokeRestart
[09:31:29.150]                     is.null <- base::is.null
[09:31:29.150]                     muffled <- FALSE
[09:31:29.150]                     if (inherits(cond, "message")) {
[09:31:29.150]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.150]                       if (muffled) 
[09:31:29.150]                         invokeRestart("muffleMessage")
[09:31:29.150]                     }
[09:31:29.150]                     else if (inherits(cond, "warning")) {
[09:31:29.150]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.150]                       if (muffled) 
[09:31:29.150]                         invokeRestart("muffleWarning")
[09:31:29.150]                     }
[09:31:29.150]                     else if (inherits(cond, "condition")) {
[09:31:29.150]                       if (!is.null(pattern)) {
[09:31:29.150]                         computeRestarts <- base::computeRestarts
[09:31:29.150]                         grepl <- base::grepl
[09:31:29.150]                         restarts <- computeRestarts(cond)
[09:31:29.150]                         for (restart in restarts) {
[09:31:29.150]                           name <- restart$name
[09:31:29.150]                           if (is.null(name)) 
[09:31:29.150]                             next
[09:31:29.150]                           if (!grepl(pattern, name)) 
[09:31:29.150]                             next
[09:31:29.150]                           invokeRestart(restart)
[09:31:29.150]                           muffled <- TRUE
[09:31:29.150]                           break
[09:31:29.150]                         }
[09:31:29.150]                       }
[09:31:29.150]                     }
[09:31:29.150]                     invisible(muffled)
[09:31:29.150]                   }
[09:31:29.150]                   muffleCondition(cond)
[09:31:29.150]                 })
[09:31:29.150]             }))
[09:31:29.150]             future::FutureResult(value = ...future.value$value, 
[09:31:29.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.150]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.150]                     ...future.globalenv.names))
[09:31:29.150]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.150]         }, condition = base::local({
[09:31:29.150]             c <- base::c
[09:31:29.150]             inherits <- base::inherits
[09:31:29.150]             invokeRestart <- base::invokeRestart
[09:31:29.150]             length <- base::length
[09:31:29.150]             list <- base::list
[09:31:29.150]             seq.int <- base::seq.int
[09:31:29.150]             signalCondition <- base::signalCondition
[09:31:29.150]             sys.calls <- base::sys.calls
[09:31:29.150]             `[[` <- base::`[[`
[09:31:29.150]             `+` <- base::`+`
[09:31:29.150]             `<<-` <- base::`<<-`
[09:31:29.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.150]                   3L)]
[09:31:29.150]             }
[09:31:29.150]             function(cond) {
[09:31:29.150]                 is_error <- inherits(cond, "error")
[09:31:29.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.150]                   NULL)
[09:31:29.150]                 if (is_error) {
[09:31:29.150]                   sessionInformation <- function() {
[09:31:29.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.150]                       search = base::search(), system = base::Sys.info())
[09:31:29.150]                   }
[09:31:29.150]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.150]                     cond$call), session = sessionInformation(), 
[09:31:29.150]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.150]                   signalCondition(cond)
[09:31:29.150]                 }
[09:31:29.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.150]                 "immediateCondition"))) {
[09:31:29.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.150]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.150]                   if (TRUE && !signal) {
[09:31:29.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.150]                     {
[09:31:29.150]                       inherits <- base::inherits
[09:31:29.150]                       invokeRestart <- base::invokeRestart
[09:31:29.150]                       is.null <- base::is.null
[09:31:29.150]                       muffled <- FALSE
[09:31:29.150]                       if (inherits(cond, "message")) {
[09:31:29.150]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.150]                         if (muffled) 
[09:31:29.150]                           invokeRestart("muffleMessage")
[09:31:29.150]                       }
[09:31:29.150]                       else if (inherits(cond, "warning")) {
[09:31:29.150]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.150]                         if (muffled) 
[09:31:29.150]                           invokeRestart("muffleWarning")
[09:31:29.150]                       }
[09:31:29.150]                       else if (inherits(cond, "condition")) {
[09:31:29.150]                         if (!is.null(pattern)) {
[09:31:29.150]                           computeRestarts <- base::computeRestarts
[09:31:29.150]                           grepl <- base::grepl
[09:31:29.150]                           restarts <- computeRestarts(cond)
[09:31:29.150]                           for (restart in restarts) {
[09:31:29.150]                             name <- restart$name
[09:31:29.150]                             if (is.null(name)) 
[09:31:29.150]                               next
[09:31:29.150]                             if (!grepl(pattern, name)) 
[09:31:29.150]                               next
[09:31:29.150]                             invokeRestart(restart)
[09:31:29.150]                             muffled <- TRUE
[09:31:29.150]                             break
[09:31:29.150]                           }
[09:31:29.150]                         }
[09:31:29.150]                       }
[09:31:29.150]                       invisible(muffled)
[09:31:29.150]                     }
[09:31:29.150]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.150]                   }
[09:31:29.150]                 }
[09:31:29.150]                 else {
[09:31:29.150]                   if (TRUE) {
[09:31:29.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.150]                     {
[09:31:29.150]                       inherits <- base::inherits
[09:31:29.150]                       invokeRestart <- base::invokeRestart
[09:31:29.150]                       is.null <- base::is.null
[09:31:29.150]                       muffled <- FALSE
[09:31:29.150]                       if (inherits(cond, "message")) {
[09:31:29.150]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.150]                         if (muffled) 
[09:31:29.150]                           invokeRestart("muffleMessage")
[09:31:29.150]                       }
[09:31:29.150]                       else if (inherits(cond, "warning")) {
[09:31:29.150]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.150]                         if (muffled) 
[09:31:29.150]                           invokeRestart("muffleWarning")
[09:31:29.150]                       }
[09:31:29.150]                       else if (inherits(cond, "condition")) {
[09:31:29.150]                         if (!is.null(pattern)) {
[09:31:29.150]                           computeRestarts <- base::computeRestarts
[09:31:29.150]                           grepl <- base::grepl
[09:31:29.150]                           restarts <- computeRestarts(cond)
[09:31:29.150]                           for (restart in restarts) {
[09:31:29.150]                             name <- restart$name
[09:31:29.150]                             if (is.null(name)) 
[09:31:29.150]                               next
[09:31:29.150]                             if (!grepl(pattern, name)) 
[09:31:29.150]                               next
[09:31:29.150]                             invokeRestart(restart)
[09:31:29.150]                             muffled <- TRUE
[09:31:29.150]                             break
[09:31:29.150]                           }
[09:31:29.150]                         }
[09:31:29.150]                       }
[09:31:29.150]                       invisible(muffled)
[09:31:29.150]                     }
[09:31:29.150]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.150]                   }
[09:31:29.150]                 }
[09:31:29.150]             }
[09:31:29.150]         }))
[09:31:29.150]     }, error = function(ex) {
[09:31:29.150]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.150]                 ...future.rng), started = ...future.startTime, 
[09:31:29.150]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.150]             version = "1.8"), class = "FutureResult")
[09:31:29.150]     }, finally = {
[09:31:29.150]         if (!identical(...future.workdir, getwd())) 
[09:31:29.150]             setwd(...future.workdir)
[09:31:29.150]         {
[09:31:29.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.150]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.150]             }
[09:31:29.150]             base::options(...future.oldOptions)
[09:31:29.150]             if (.Platform$OS.type == "windows") {
[09:31:29.150]                 old_names <- names(...future.oldEnvVars)
[09:31:29.150]                 envs <- base::Sys.getenv()
[09:31:29.150]                 names <- names(envs)
[09:31:29.150]                 common <- intersect(names, old_names)
[09:31:29.150]                 added <- setdiff(names, old_names)
[09:31:29.150]                 removed <- setdiff(old_names, names)
[09:31:29.150]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.150]                   envs[common]]
[09:31:29.150]                 NAMES <- toupper(changed)
[09:31:29.150]                 args <- list()
[09:31:29.150]                 for (kk in seq_along(NAMES)) {
[09:31:29.150]                   name <- changed[[kk]]
[09:31:29.150]                   NAME <- NAMES[[kk]]
[09:31:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.150]                     next
[09:31:29.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.150]                 }
[09:31:29.150]                 NAMES <- toupper(added)
[09:31:29.150]                 for (kk in seq_along(NAMES)) {
[09:31:29.150]                   name <- added[[kk]]
[09:31:29.150]                   NAME <- NAMES[[kk]]
[09:31:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.150]                     next
[09:31:29.150]                   args[[name]] <- ""
[09:31:29.150]                 }
[09:31:29.150]                 NAMES <- toupper(removed)
[09:31:29.150]                 for (kk in seq_along(NAMES)) {
[09:31:29.150]                   name <- removed[[kk]]
[09:31:29.150]                   NAME <- NAMES[[kk]]
[09:31:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.150]                     next
[09:31:29.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.150]                 }
[09:31:29.150]                 if (length(args) > 0) 
[09:31:29.150]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.150]             }
[09:31:29.150]             else {
[09:31:29.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.150]             }
[09:31:29.150]             {
[09:31:29.150]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.150]                   0L) {
[09:31:29.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.150]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.150]                   base::options(opts)
[09:31:29.150]                 }
[09:31:29.150]                 {
[09:31:29.150]                   {
[09:31:29.150]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.150]                     NULL
[09:31:29.150]                   }
[09:31:29.150]                   options(future.plan = NULL)
[09:31:29.150]                   if (is.na(NA_character_)) 
[09:31:29.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.150]                     .init = FALSE)
[09:31:29.150]                 }
[09:31:29.150]             }
[09:31:29.150]         }
[09:31:29.150]     })
[09:31:29.150]     if (TRUE) {
[09:31:29.150]         base::sink(type = "output", split = FALSE)
[09:31:29.150]         if (TRUE) {
[09:31:29.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.150]         }
[09:31:29.150]         else {
[09:31:29.150]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.150]         }
[09:31:29.150]         base::close(...future.stdout)
[09:31:29.150]         ...future.stdout <- NULL
[09:31:29.150]     }
[09:31:29.150]     ...future.result$conditions <- ...future.conditions
[09:31:29.150]     ...future.result$finished <- base::Sys.time()
[09:31:29.150]     ...future.result
[09:31:29.150] }
[09:31:29.152] assign_globals() ...
[09:31:29.152] List of 1
[09:31:29.152]  $ x: list()
[09:31:29.152]  - attr(*, "where")=List of 1
[09:31:29.152]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.152]  - attr(*, "resolved")= logi TRUE
[09:31:29.152]  - attr(*, "total_size")= num 0
[09:31:29.152]  - attr(*, "already-done")= logi TRUE
[09:31:29.155] - copied ‘x’ to environment
[09:31:29.155] assign_globals() ... done
[09:31:29.155] requestCore(): workers = 2
[09:31:29.157] MulticoreFuture started
[09:31:29.157] - Launch lazy future ... done
[09:31:29.158] run() for ‘MulticoreFuture’ ... done
[09:31:29.158] result() for MulticoreFuture ...
[09:31:29.158] plan(): Setting new future strategy stack:
[09:31:29.158] List of future strategies:
[09:31:29.158] 1. sequential:
[09:31:29.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.158]    - tweaked: FALSE
[09:31:29.158]    - call: NULL
[09:31:29.159] plan(): nbrOfWorkers() = 1
[09:31:29.161] plan(): Setting new future strategy stack:
[09:31:29.161] List of future strategies:
[09:31:29.161] 1. multicore:
[09:31:29.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.161]    - tweaked: FALSE
[09:31:29.161]    - call: plan(strategy)
[09:31:29.170] plan(): nbrOfWorkers() = 2
[09:31:29.171] result() for MulticoreFuture ...
[09:31:29.171] result() for MulticoreFuture ... done
[09:31:29.171] result() for MulticoreFuture ... done
[09:31:29.172] result() for MulticoreFuture ...
[09:31:29.172] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.173] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.173] Searching for globals...
[09:31:29.178] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:29.179] Searching for globals ... DONE
[09:31:29.179] Resolving globals: TRUE
[09:31:29.179] Resolving any globals that are futures ...
[09:31:29.179] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:29.179] Resolving any globals that are futures ... DONE
[09:31:29.180] 
[09:31:29.180] 
[09:31:29.180] getGlobalsAndPackages() ... DONE
[09:31:29.180] run() for ‘Future’ ...
[09:31:29.180] - state: ‘created’
[09:31:29.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.184] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.185] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.185]   - Field: ‘label’
[09:31:29.185]   - Field: ‘local’
[09:31:29.185]   - Field: ‘owner’
[09:31:29.185]   - Field: ‘envir’
[09:31:29.185]   - Field: ‘workers’
[09:31:29.185]   - Field: ‘packages’
[09:31:29.185]   - Field: ‘gc’
[09:31:29.186]   - Field: ‘job’
[09:31:29.186]   - Field: ‘conditions’
[09:31:29.186]   - Field: ‘expr’
[09:31:29.186]   - Field: ‘uuid’
[09:31:29.186]   - Field: ‘seed’
[09:31:29.186]   - Field: ‘version’
[09:31:29.186]   - Field: ‘result’
[09:31:29.186]   - Field: ‘asynchronous’
[09:31:29.186]   - Field: ‘calls’
[09:31:29.186]   - Field: ‘globals’
[09:31:29.187]   - Field: ‘stdout’
[09:31:29.187]   - Field: ‘earlySignal’
[09:31:29.187]   - Field: ‘lazy’
[09:31:29.187]   - Field: ‘state’
[09:31:29.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.187] - Launch lazy future ...
[09:31:29.187] Packages needed by the future expression (n = 0): <none>
[09:31:29.188] Packages needed by future strategies (n = 0): <none>
[09:31:29.188] {
[09:31:29.188]     {
[09:31:29.188]         {
[09:31:29.188]             ...future.startTime <- base::Sys.time()
[09:31:29.188]             {
[09:31:29.188]                 {
[09:31:29.188]                   {
[09:31:29.188]                     {
[09:31:29.188]                       base::local({
[09:31:29.188]                         has_future <- base::requireNamespace("future", 
[09:31:29.188]                           quietly = TRUE)
[09:31:29.188]                         if (has_future) {
[09:31:29.188]                           ns <- base::getNamespace("future")
[09:31:29.188]                           version <- ns[[".package"]][["version"]]
[09:31:29.188]                           if (is.null(version)) 
[09:31:29.188]                             version <- utils::packageVersion("future")
[09:31:29.188]                         }
[09:31:29.188]                         else {
[09:31:29.188]                           version <- NULL
[09:31:29.188]                         }
[09:31:29.188]                         if (!has_future || version < "1.8.0") {
[09:31:29.188]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.188]                             "", base::R.version$version.string), 
[09:31:29.188]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.188]                               "release", "version")], collapse = " "), 
[09:31:29.188]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.188]                             info)
[09:31:29.188]                           info <- base::paste(info, collapse = "; ")
[09:31:29.188]                           if (!has_future) {
[09:31:29.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.188]                               info)
[09:31:29.188]                           }
[09:31:29.188]                           else {
[09:31:29.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.188]                               info, version)
[09:31:29.188]                           }
[09:31:29.188]                           base::stop(msg)
[09:31:29.188]                         }
[09:31:29.188]                       })
[09:31:29.188]                     }
[09:31:29.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.188]                     base::options(mc.cores = 1L)
[09:31:29.188]                   }
[09:31:29.188]                   ...future.strategy.old <- future::plan("list")
[09:31:29.188]                   options(future.plan = NULL)
[09:31:29.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.188]                 }
[09:31:29.188]                 ...future.workdir <- getwd()
[09:31:29.188]             }
[09:31:29.188]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.188]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.188]         }
[09:31:29.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.188]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.188]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.188]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.188]             base::names(...future.oldOptions))
[09:31:29.188]     }
[09:31:29.188]     if (FALSE) {
[09:31:29.188]     }
[09:31:29.188]     else {
[09:31:29.188]         if (TRUE) {
[09:31:29.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.188]                 open = "w")
[09:31:29.188]         }
[09:31:29.188]         else {
[09:31:29.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.188]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.188]         }
[09:31:29.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.188]             base::sink(type = "output", split = FALSE)
[09:31:29.188]             base::close(...future.stdout)
[09:31:29.188]         }, add = TRUE)
[09:31:29.188]     }
[09:31:29.188]     ...future.frame <- base::sys.nframe()
[09:31:29.188]     ...future.conditions <- base::list()
[09:31:29.188]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.188]     if (FALSE) {
[09:31:29.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.188]     }
[09:31:29.188]     ...future.result <- base::tryCatch({
[09:31:29.188]         base::withCallingHandlers({
[09:31:29.188]             ...future.value <- base::withVisible(base::local({
[09:31:29.188]                 withCallingHandlers({
[09:31:29.188]                   {
[09:31:29.188]                     x <- list(b = 2)
[09:31:29.188]                     x$a <- 1
[09:31:29.188]                     x
[09:31:29.188]                   }
[09:31:29.188]                 }, immediateCondition = function(cond) {
[09:31:29.188]                   save_rds <- function (object, pathname, ...) 
[09:31:29.188]                   {
[09:31:29.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.188]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.188]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.188]                         fi_tmp[["mtime"]])
[09:31:29.188]                     }
[09:31:29.188]                     tryCatch({
[09:31:29.188]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.188]                     }, error = function(ex) {
[09:31:29.188]                       msg <- conditionMessage(ex)
[09:31:29.188]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.188]                         fi_tmp[["mtime"]], msg)
[09:31:29.188]                       ex$message <- msg
[09:31:29.188]                       stop(ex)
[09:31:29.188]                     })
[09:31:29.188]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.188]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.188]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.188]                       fi <- file.info(pathname)
[09:31:29.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.188]                         fi[["size"]], fi[["mtime"]])
[09:31:29.188]                       stop(msg)
[09:31:29.188]                     }
[09:31:29.188]                     invisible(pathname)
[09:31:29.188]                   }
[09:31:29.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.188]                     rootPath = tempdir()) 
[09:31:29.188]                   {
[09:31:29.188]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.188]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.188]                       tmpdir = path, fileext = ".rds")
[09:31:29.188]                     save_rds(obj, file)
[09:31:29.188]                   }
[09:31:29.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.188]                   {
[09:31:29.188]                     inherits <- base::inherits
[09:31:29.188]                     invokeRestart <- base::invokeRestart
[09:31:29.188]                     is.null <- base::is.null
[09:31:29.188]                     muffled <- FALSE
[09:31:29.188]                     if (inherits(cond, "message")) {
[09:31:29.188]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.188]                       if (muffled) 
[09:31:29.188]                         invokeRestart("muffleMessage")
[09:31:29.188]                     }
[09:31:29.188]                     else if (inherits(cond, "warning")) {
[09:31:29.188]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.188]                       if (muffled) 
[09:31:29.188]                         invokeRestart("muffleWarning")
[09:31:29.188]                     }
[09:31:29.188]                     else if (inherits(cond, "condition")) {
[09:31:29.188]                       if (!is.null(pattern)) {
[09:31:29.188]                         computeRestarts <- base::computeRestarts
[09:31:29.188]                         grepl <- base::grepl
[09:31:29.188]                         restarts <- computeRestarts(cond)
[09:31:29.188]                         for (restart in restarts) {
[09:31:29.188]                           name <- restart$name
[09:31:29.188]                           if (is.null(name)) 
[09:31:29.188]                             next
[09:31:29.188]                           if (!grepl(pattern, name)) 
[09:31:29.188]                             next
[09:31:29.188]                           invokeRestart(restart)
[09:31:29.188]                           muffled <- TRUE
[09:31:29.188]                           break
[09:31:29.188]                         }
[09:31:29.188]                       }
[09:31:29.188]                     }
[09:31:29.188]                     invisible(muffled)
[09:31:29.188]                   }
[09:31:29.188]                   muffleCondition(cond)
[09:31:29.188]                 })
[09:31:29.188]             }))
[09:31:29.188]             future::FutureResult(value = ...future.value$value, 
[09:31:29.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.188]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.188]                     ...future.globalenv.names))
[09:31:29.188]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.188]         }, condition = base::local({
[09:31:29.188]             c <- base::c
[09:31:29.188]             inherits <- base::inherits
[09:31:29.188]             invokeRestart <- base::invokeRestart
[09:31:29.188]             length <- base::length
[09:31:29.188]             list <- base::list
[09:31:29.188]             seq.int <- base::seq.int
[09:31:29.188]             signalCondition <- base::signalCondition
[09:31:29.188]             sys.calls <- base::sys.calls
[09:31:29.188]             `[[` <- base::`[[`
[09:31:29.188]             `+` <- base::`+`
[09:31:29.188]             `<<-` <- base::`<<-`
[09:31:29.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.188]                   3L)]
[09:31:29.188]             }
[09:31:29.188]             function(cond) {
[09:31:29.188]                 is_error <- inherits(cond, "error")
[09:31:29.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.188]                   NULL)
[09:31:29.188]                 if (is_error) {
[09:31:29.188]                   sessionInformation <- function() {
[09:31:29.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.188]                       search = base::search(), system = base::Sys.info())
[09:31:29.188]                   }
[09:31:29.188]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.188]                     cond$call), session = sessionInformation(), 
[09:31:29.188]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.188]                   signalCondition(cond)
[09:31:29.188]                 }
[09:31:29.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.188]                 "immediateCondition"))) {
[09:31:29.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.188]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.188]                   if (TRUE && !signal) {
[09:31:29.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.188]                     {
[09:31:29.188]                       inherits <- base::inherits
[09:31:29.188]                       invokeRestart <- base::invokeRestart
[09:31:29.188]                       is.null <- base::is.null
[09:31:29.188]                       muffled <- FALSE
[09:31:29.188]                       if (inherits(cond, "message")) {
[09:31:29.188]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.188]                         if (muffled) 
[09:31:29.188]                           invokeRestart("muffleMessage")
[09:31:29.188]                       }
[09:31:29.188]                       else if (inherits(cond, "warning")) {
[09:31:29.188]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.188]                         if (muffled) 
[09:31:29.188]                           invokeRestart("muffleWarning")
[09:31:29.188]                       }
[09:31:29.188]                       else if (inherits(cond, "condition")) {
[09:31:29.188]                         if (!is.null(pattern)) {
[09:31:29.188]                           computeRestarts <- base::computeRestarts
[09:31:29.188]                           grepl <- base::grepl
[09:31:29.188]                           restarts <- computeRestarts(cond)
[09:31:29.188]                           for (restart in restarts) {
[09:31:29.188]                             name <- restart$name
[09:31:29.188]                             if (is.null(name)) 
[09:31:29.188]                               next
[09:31:29.188]                             if (!grepl(pattern, name)) 
[09:31:29.188]                               next
[09:31:29.188]                             invokeRestart(restart)
[09:31:29.188]                             muffled <- TRUE
[09:31:29.188]                             break
[09:31:29.188]                           }
[09:31:29.188]                         }
[09:31:29.188]                       }
[09:31:29.188]                       invisible(muffled)
[09:31:29.188]                     }
[09:31:29.188]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.188]                   }
[09:31:29.188]                 }
[09:31:29.188]                 else {
[09:31:29.188]                   if (TRUE) {
[09:31:29.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.188]                     {
[09:31:29.188]                       inherits <- base::inherits
[09:31:29.188]                       invokeRestart <- base::invokeRestart
[09:31:29.188]                       is.null <- base::is.null
[09:31:29.188]                       muffled <- FALSE
[09:31:29.188]                       if (inherits(cond, "message")) {
[09:31:29.188]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.188]                         if (muffled) 
[09:31:29.188]                           invokeRestart("muffleMessage")
[09:31:29.188]                       }
[09:31:29.188]                       else if (inherits(cond, "warning")) {
[09:31:29.188]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.188]                         if (muffled) 
[09:31:29.188]                           invokeRestart("muffleWarning")
[09:31:29.188]                       }
[09:31:29.188]                       else if (inherits(cond, "condition")) {
[09:31:29.188]                         if (!is.null(pattern)) {
[09:31:29.188]                           computeRestarts <- base::computeRestarts
[09:31:29.188]                           grepl <- base::grepl
[09:31:29.188]                           restarts <- computeRestarts(cond)
[09:31:29.188]                           for (restart in restarts) {
[09:31:29.188]                             name <- restart$name
[09:31:29.188]                             if (is.null(name)) 
[09:31:29.188]                               next
[09:31:29.188]                             if (!grepl(pattern, name)) 
[09:31:29.188]                               next
[09:31:29.188]                             invokeRestart(restart)
[09:31:29.188]                             muffled <- TRUE
[09:31:29.188]                             break
[09:31:29.188]                           }
[09:31:29.188]                         }
[09:31:29.188]                       }
[09:31:29.188]                       invisible(muffled)
[09:31:29.188]                     }
[09:31:29.188]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.188]                   }
[09:31:29.188]                 }
[09:31:29.188]             }
[09:31:29.188]         }))
[09:31:29.188]     }, error = function(ex) {
[09:31:29.188]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.188]                 ...future.rng), started = ...future.startTime, 
[09:31:29.188]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.188]             version = "1.8"), class = "FutureResult")
[09:31:29.188]     }, finally = {
[09:31:29.188]         if (!identical(...future.workdir, getwd())) 
[09:31:29.188]             setwd(...future.workdir)
[09:31:29.188]         {
[09:31:29.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.188]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.188]             }
[09:31:29.188]             base::options(...future.oldOptions)
[09:31:29.188]             if (.Platform$OS.type == "windows") {
[09:31:29.188]                 old_names <- names(...future.oldEnvVars)
[09:31:29.188]                 envs <- base::Sys.getenv()
[09:31:29.188]                 names <- names(envs)
[09:31:29.188]                 common <- intersect(names, old_names)
[09:31:29.188]                 added <- setdiff(names, old_names)
[09:31:29.188]                 removed <- setdiff(old_names, names)
[09:31:29.188]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.188]                   envs[common]]
[09:31:29.188]                 NAMES <- toupper(changed)
[09:31:29.188]                 args <- list()
[09:31:29.188]                 for (kk in seq_along(NAMES)) {
[09:31:29.188]                   name <- changed[[kk]]
[09:31:29.188]                   NAME <- NAMES[[kk]]
[09:31:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.188]                     next
[09:31:29.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.188]                 }
[09:31:29.188]                 NAMES <- toupper(added)
[09:31:29.188]                 for (kk in seq_along(NAMES)) {
[09:31:29.188]                   name <- added[[kk]]
[09:31:29.188]                   NAME <- NAMES[[kk]]
[09:31:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.188]                     next
[09:31:29.188]                   args[[name]] <- ""
[09:31:29.188]                 }
[09:31:29.188]                 NAMES <- toupper(removed)
[09:31:29.188]                 for (kk in seq_along(NAMES)) {
[09:31:29.188]                   name <- removed[[kk]]
[09:31:29.188]                   NAME <- NAMES[[kk]]
[09:31:29.188]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.188]                     next
[09:31:29.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.188]                 }
[09:31:29.188]                 if (length(args) > 0) 
[09:31:29.188]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.188]             }
[09:31:29.188]             else {
[09:31:29.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.188]             }
[09:31:29.188]             {
[09:31:29.188]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.188]                   0L) {
[09:31:29.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.188]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.188]                   base::options(opts)
[09:31:29.188]                 }
[09:31:29.188]                 {
[09:31:29.188]                   {
[09:31:29.188]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.188]                     NULL
[09:31:29.188]                   }
[09:31:29.188]                   options(future.plan = NULL)
[09:31:29.188]                   if (is.na(NA_character_)) 
[09:31:29.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.188]                     .init = FALSE)
[09:31:29.188]                 }
[09:31:29.188]             }
[09:31:29.188]         }
[09:31:29.188]     })
[09:31:29.188]     if (TRUE) {
[09:31:29.188]         base::sink(type = "output", split = FALSE)
[09:31:29.188]         if (TRUE) {
[09:31:29.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.188]         }
[09:31:29.188]         else {
[09:31:29.188]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.188]         }
[09:31:29.188]         base::close(...future.stdout)
[09:31:29.188]         ...future.stdout <- NULL
[09:31:29.188]     }
[09:31:29.188]     ...future.result$conditions <- ...future.conditions
[09:31:29.188]     ...future.result$finished <- base::Sys.time()
[09:31:29.188]     ...future.result
[09:31:29.188] }
[09:31:29.190] requestCore(): workers = 2
[09:31:29.192] MulticoreFuture started
[09:31:29.193] - Launch lazy future ... done
[09:31:29.193] run() for ‘MulticoreFuture’ ... done
[09:31:29.193] plan(): Setting new future strategy stack:
[09:31:29.193] result() for MulticoreFuture ...
[09:31:29.193] List of future strategies:
[09:31:29.193] 1. sequential:
[09:31:29.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.193]    - tweaked: FALSE
[09:31:29.193]    - call: NULL
[09:31:29.194] plan(): nbrOfWorkers() = 1
[09:31:29.197] plan(): Setting new future strategy stack:
[09:31:29.197] List of future strategies:
[09:31:29.197] 1. multicore:
[09:31:29.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.197]    - tweaked: FALSE
[09:31:29.197]    - call: plan(strategy)
[09:31:29.202] plan(): nbrOfWorkers() = 2
[09:31:29.203] result() for MulticoreFuture ...
[09:31:29.203] result() for MulticoreFuture ... done
[09:31:29.203] result() for MulticoreFuture ... done
[09:31:29.203] result() for MulticoreFuture ...
[09:31:29.203] result() for MulticoreFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.204] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.204] Searching for globals...
[09:31:29.207] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.207] Searching for globals ... DONE
[09:31:29.207] Resolving globals: TRUE
[09:31:29.207] Resolving any globals that are futures ...
[09:31:29.207] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.207] Resolving any globals that are futures ... DONE
[09:31:29.208] Resolving futures part of globals (recursively) ...
[09:31:29.208] resolve() on list ...
[09:31:29.208]  recursive: 99
[09:31:29.209]  length: 1
[09:31:29.209]  elements: ‘x’
[09:31:29.209]  length: 0 (resolved future 1)
[09:31:29.209] resolve() on list ... DONE
[09:31:29.209] - globals: [1] ‘x’
[09:31:29.209] Resolving futures part of globals (recursively) ... DONE
[09:31:29.209] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.210] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.210] - globals: [1] ‘x’
[09:31:29.210] 
[09:31:29.210] getGlobalsAndPackages() ... DONE
[09:31:29.210] run() for ‘Future’ ...
[09:31:29.211] - state: ‘created’
[09:31:29.211] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.215] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.215]   - Field: ‘label’
[09:31:29.215]   - Field: ‘local’
[09:31:29.215]   - Field: ‘owner’
[09:31:29.215]   - Field: ‘envir’
[09:31:29.215]   - Field: ‘workers’
[09:31:29.215]   - Field: ‘packages’
[09:31:29.216]   - Field: ‘gc’
[09:31:29.216]   - Field: ‘job’
[09:31:29.216]   - Field: ‘conditions’
[09:31:29.216]   - Field: ‘expr’
[09:31:29.216]   - Field: ‘uuid’
[09:31:29.216]   - Field: ‘seed’
[09:31:29.216]   - Field: ‘version’
[09:31:29.216]   - Field: ‘result’
[09:31:29.216]   - Field: ‘asynchronous’
[09:31:29.217]   - Field: ‘calls’
[09:31:29.217]   - Field: ‘globals’
[09:31:29.217]   - Field: ‘stdout’
[09:31:29.217]   - Field: ‘earlySignal’
[09:31:29.217]   - Field: ‘lazy’
[09:31:29.217]   - Field: ‘state’
[09:31:29.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.217] - Launch lazy future ...
[09:31:29.218] Packages needed by the future expression (n = 0): <none>
[09:31:29.218] Packages needed by future strategies (n = 0): <none>
[09:31:29.218] {
[09:31:29.218]     {
[09:31:29.218]         {
[09:31:29.218]             ...future.startTime <- base::Sys.time()
[09:31:29.218]             {
[09:31:29.218]                 {
[09:31:29.218]                   {
[09:31:29.218]                     {
[09:31:29.218]                       base::local({
[09:31:29.218]                         has_future <- base::requireNamespace("future", 
[09:31:29.218]                           quietly = TRUE)
[09:31:29.218]                         if (has_future) {
[09:31:29.218]                           ns <- base::getNamespace("future")
[09:31:29.218]                           version <- ns[[".package"]][["version"]]
[09:31:29.218]                           if (is.null(version)) 
[09:31:29.218]                             version <- utils::packageVersion("future")
[09:31:29.218]                         }
[09:31:29.218]                         else {
[09:31:29.218]                           version <- NULL
[09:31:29.218]                         }
[09:31:29.218]                         if (!has_future || version < "1.8.0") {
[09:31:29.218]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.218]                             "", base::R.version$version.string), 
[09:31:29.218]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.218]                               "release", "version")], collapse = " "), 
[09:31:29.218]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.218]                             info)
[09:31:29.218]                           info <- base::paste(info, collapse = "; ")
[09:31:29.218]                           if (!has_future) {
[09:31:29.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.218]                               info)
[09:31:29.218]                           }
[09:31:29.218]                           else {
[09:31:29.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.218]                               info, version)
[09:31:29.218]                           }
[09:31:29.218]                           base::stop(msg)
[09:31:29.218]                         }
[09:31:29.218]                       })
[09:31:29.218]                     }
[09:31:29.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.218]                     base::options(mc.cores = 1L)
[09:31:29.218]                   }
[09:31:29.218]                   ...future.strategy.old <- future::plan("list")
[09:31:29.218]                   options(future.plan = NULL)
[09:31:29.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.218]                 }
[09:31:29.218]                 ...future.workdir <- getwd()
[09:31:29.218]             }
[09:31:29.218]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.218]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.218]         }
[09:31:29.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.218]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.218]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.218]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.218]             base::names(...future.oldOptions))
[09:31:29.218]     }
[09:31:29.218]     if (FALSE) {
[09:31:29.218]     }
[09:31:29.218]     else {
[09:31:29.218]         if (TRUE) {
[09:31:29.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.218]                 open = "w")
[09:31:29.218]         }
[09:31:29.218]         else {
[09:31:29.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.218]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.218]         }
[09:31:29.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.218]             base::sink(type = "output", split = FALSE)
[09:31:29.218]             base::close(...future.stdout)
[09:31:29.218]         }, add = TRUE)
[09:31:29.218]     }
[09:31:29.218]     ...future.frame <- base::sys.nframe()
[09:31:29.218]     ...future.conditions <- base::list()
[09:31:29.218]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.218]     if (FALSE) {
[09:31:29.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.218]     }
[09:31:29.218]     ...future.result <- base::tryCatch({
[09:31:29.218]         base::withCallingHandlers({
[09:31:29.218]             ...future.value <- base::withVisible(base::local({
[09:31:29.218]                 withCallingHandlers({
[09:31:29.218]                   {
[09:31:29.218]                     x[["a"]] <- 1
[09:31:29.218]                     x
[09:31:29.218]                   }
[09:31:29.218]                 }, immediateCondition = function(cond) {
[09:31:29.218]                   save_rds <- function (object, pathname, ...) 
[09:31:29.218]                   {
[09:31:29.218]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.218]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.218]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.218]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.218]                         fi_tmp[["mtime"]])
[09:31:29.218]                     }
[09:31:29.218]                     tryCatch({
[09:31:29.218]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.218]                     }, error = function(ex) {
[09:31:29.218]                       msg <- conditionMessage(ex)
[09:31:29.218]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.218]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.218]                         fi_tmp[["mtime"]], msg)
[09:31:29.218]                       ex$message <- msg
[09:31:29.218]                       stop(ex)
[09:31:29.218]                     })
[09:31:29.218]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.218]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.218]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.218]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.218]                       fi <- file.info(pathname)
[09:31:29.218]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.218]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.218]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.218]                         fi[["size"]], fi[["mtime"]])
[09:31:29.218]                       stop(msg)
[09:31:29.218]                     }
[09:31:29.218]                     invisible(pathname)
[09:31:29.218]                   }
[09:31:29.218]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.218]                     rootPath = tempdir()) 
[09:31:29.218]                   {
[09:31:29.218]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.218]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.218]                       tmpdir = path, fileext = ".rds")
[09:31:29.218]                     save_rds(obj, file)
[09:31:29.218]                   }
[09:31:29.218]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.218]                   {
[09:31:29.218]                     inherits <- base::inherits
[09:31:29.218]                     invokeRestart <- base::invokeRestart
[09:31:29.218]                     is.null <- base::is.null
[09:31:29.218]                     muffled <- FALSE
[09:31:29.218]                     if (inherits(cond, "message")) {
[09:31:29.218]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.218]                       if (muffled) 
[09:31:29.218]                         invokeRestart("muffleMessage")
[09:31:29.218]                     }
[09:31:29.218]                     else if (inherits(cond, "warning")) {
[09:31:29.218]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.218]                       if (muffled) 
[09:31:29.218]                         invokeRestart("muffleWarning")
[09:31:29.218]                     }
[09:31:29.218]                     else if (inherits(cond, "condition")) {
[09:31:29.218]                       if (!is.null(pattern)) {
[09:31:29.218]                         computeRestarts <- base::computeRestarts
[09:31:29.218]                         grepl <- base::grepl
[09:31:29.218]                         restarts <- computeRestarts(cond)
[09:31:29.218]                         for (restart in restarts) {
[09:31:29.218]                           name <- restart$name
[09:31:29.218]                           if (is.null(name)) 
[09:31:29.218]                             next
[09:31:29.218]                           if (!grepl(pattern, name)) 
[09:31:29.218]                             next
[09:31:29.218]                           invokeRestart(restart)
[09:31:29.218]                           muffled <- TRUE
[09:31:29.218]                           break
[09:31:29.218]                         }
[09:31:29.218]                       }
[09:31:29.218]                     }
[09:31:29.218]                     invisible(muffled)
[09:31:29.218]                   }
[09:31:29.218]                   muffleCondition(cond)
[09:31:29.218]                 })
[09:31:29.218]             }))
[09:31:29.218]             future::FutureResult(value = ...future.value$value, 
[09:31:29.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.218]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.218]                     ...future.globalenv.names))
[09:31:29.218]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.218]         }, condition = base::local({
[09:31:29.218]             c <- base::c
[09:31:29.218]             inherits <- base::inherits
[09:31:29.218]             invokeRestart <- base::invokeRestart
[09:31:29.218]             length <- base::length
[09:31:29.218]             list <- base::list
[09:31:29.218]             seq.int <- base::seq.int
[09:31:29.218]             signalCondition <- base::signalCondition
[09:31:29.218]             sys.calls <- base::sys.calls
[09:31:29.218]             `[[` <- base::`[[`
[09:31:29.218]             `+` <- base::`+`
[09:31:29.218]             `<<-` <- base::`<<-`
[09:31:29.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.218]                   3L)]
[09:31:29.218]             }
[09:31:29.218]             function(cond) {
[09:31:29.218]                 is_error <- inherits(cond, "error")
[09:31:29.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.218]                   NULL)
[09:31:29.218]                 if (is_error) {
[09:31:29.218]                   sessionInformation <- function() {
[09:31:29.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.218]                       search = base::search(), system = base::Sys.info())
[09:31:29.218]                   }
[09:31:29.218]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.218]                     cond$call), session = sessionInformation(), 
[09:31:29.218]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.218]                   signalCondition(cond)
[09:31:29.218]                 }
[09:31:29.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.218]                 "immediateCondition"))) {
[09:31:29.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.218]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.218]                   if (TRUE && !signal) {
[09:31:29.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.218]                     {
[09:31:29.218]                       inherits <- base::inherits
[09:31:29.218]                       invokeRestart <- base::invokeRestart
[09:31:29.218]                       is.null <- base::is.null
[09:31:29.218]                       muffled <- FALSE
[09:31:29.218]                       if (inherits(cond, "message")) {
[09:31:29.218]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.218]                         if (muffled) 
[09:31:29.218]                           invokeRestart("muffleMessage")
[09:31:29.218]                       }
[09:31:29.218]                       else if (inherits(cond, "warning")) {
[09:31:29.218]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.218]                         if (muffled) 
[09:31:29.218]                           invokeRestart("muffleWarning")
[09:31:29.218]                       }
[09:31:29.218]                       else if (inherits(cond, "condition")) {
[09:31:29.218]                         if (!is.null(pattern)) {
[09:31:29.218]                           computeRestarts <- base::computeRestarts
[09:31:29.218]                           grepl <- base::grepl
[09:31:29.218]                           restarts <- computeRestarts(cond)
[09:31:29.218]                           for (restart in restarts) {
[09:31:29.218]                             name <- restart$name
[09:31:29.218]                             if (is.null(name)) 
[09:31:29.218]                               next
[09:31:29.218]                             if (!grepl(pattern, name)) 
[09:31:29.218]                               next
[09:31:29.218]                             invokeRestart(restart)
[09:31:29.218]                             muffled <- TRUE
[09:31:29.218]                             break
[09:31:29.218]                           }
[09:31:29.218]                         }
[09:31:29.218]                       }
[09:31:29.218]                       invisible(muffled)
[09:31:29.218]                     }
[09:31:29.218]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.218]                   }
[09:31:29.218]                 }
[09:31:29.218]                 else {
[09:31:29.218]                   if (TRUE) {
[09:31:29.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.218]                     {
[09:31:29.218]                       inherits <- base::inherits
[09:31:29.218]                       invokeRestart <- base::invokeRestart
[09:31:29.218]                       is.null <- base::is.null
[09:31:29.218]                       muffled <- FALSE
[09:31:29.218]                       if (inherits(cond, "message")) {
[09:31:29.218]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.218]                         if (muffled) 
[09:31:29.218]                           invokeRestart("muffleMessage")
[09:31:29.218]                       }
[09:31:29.218]                       else if (inherits(cond, "warning")) {
[09:31:29.218]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.218]                         if (muffled) 
[09:31:29.218]                           invokeRestart("muffleWarning")
[09:31:29.218]                       }
[09:31:29.218]                       else if (inherits(cond, "condition")) {
[09:31:29.218]                         if (!is.null(pattern)) {
[09:31:29.218]                           computeRestarts <- base::computeRestarts
[09:31:29.218]                           grepl <- base::grepl
[09:31:29.218]                           restarts <- computeRestarts(cond)
[09:31:29.218]                           for (restart in restarts) {
[09:31:29.218]                             name <- restart$name
[09:31:29.218]                             if (is.null(name)) 
[09:31:29.218]                               next
[09:31:29.218]                             if (!grepl(pattern, name)) 
[09:31:29.218]                               next
[09:31:29.218]                             invokeRestart(restart)
[09:31:29.218]                             muffled <- TRUE
[09:31:29.218]                             break
[09:31:29.218]                           }
[09:31:29.218]                         }
[09:31:29.218]                       }
[09:31:29.218]                       invisible(muffled)
[09:31:29.218]                     }
[09:31:29.218]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.218]                   }
[09:31:29.218]                 }
[09:31:29.218]             }
[09:31:29.218]         }))
[09:31:29.218]     }, error = function(ex) {
[09:31:29.218]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.218]                 ...future.rng), started = ...future.startTime, 
[09:31:29.218]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.218]             version = "1.8"), class = "FutureResult")
[09:31:29.218]     }, finally = {
[09:31:29.218]         if (!identical(...future.workdir, getwd())) 
[09:31:29.218]             setwd(...future.workdir)
[09:31:29.218]         {
[09:31:29.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.218]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.218]             }
[09:31:29.218]             base::options(...future.oldOptions)
[09:31:29.218]             if (.Platform$OS.type == "windows") {
[09:31:29.218]                 old_names <- names(...future.oldEnvVars)
[09:31:29.218]                 envs <- base::Sys.getenv()
[09:31:29.218]                 names <- names(envs)
[09:31:29.218]                 common <- intersect(names, old_names)
[09:31:29.218]                 added <- setdiff(names, old_names)
[09:31:29.218]                 removed <- setdiff(old_names, names)
[09:31:29.218]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.218]                   envs[common]]
[09:31:29.218]                 NAMES <- toupper(changed)
[09:31:29.218]                 args <- list()
[09:31:29.218]                 for (kk in seq_along(NAMES)) {
[09:31:29.218]                   name <- changed[[kk]]
[09:31:29.218]                   NAME <- NAMES[[kk]]
[09:31:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.218]                     next
[09:31:29.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.218]                 }
[09:31:29.218]                 NAMES <- toupper(added)
[09:31:29.218]                 for (kk in seq_along(NAMES)) {
[09:31:29.218]                   name <- added[[kk]]
[09:31:29.218]                   NAME <- NAMES[[kk]]
[09:31:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.218]                     next
[09:31:29.218]                   args[[name]] <- ""
[09:31:29.218]                 }
[09:31:29.218]                 NAMES <- toupper(removed)
[09:31:29.218]                 for (kk in seq_along(NAMES)) {
[09:31:29.218]                   name <- removed[[kk]]
[09:31:29.218]                   NAME <- NAMES[[kk]]
[09:31:29.218]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.218]                     next
[09:31:29.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.218]                 }
[09:31:29.218]                 if (length(args) > 0) 
[09:31:29.218]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.218]             }
[09:31:29.218]             else {
[09:31:29.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.218]             }
[09:31:29.218]             {
[09:31:29.218]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.218]                   0L) {
[09:31:29.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.218]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.218]                   base::options(opts)
[09:31:29.218]                 }
[09:31:29.218]                 {
[09:31:29.218]                   {
[09:31:29.218]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.218]                     NULL
[09:31:29.218]                   }
[09:31:29.218]                   options(future.plan = NULL)
[09:31:29.218]                   if (is.na(NA_character_)) 
[09:31:29.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.218]                     .init = FALSE)
[09:31:29.218]                 }
[09:31:29.218]             }
[09:31:29.218]         }
[09:31:29.218]     })
[09:31:29.218]     if (TRUE) {
[09:31:29.218]         base::sink(type = "output", split = FALSE)
[09:31:29.218]         if (TRUE) {
[09:31:29.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.218]         }
[09:31:29.218]         else {
[09:31:29.218]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.218]         }
[09:31:29.218]         base::close(...future.stdout)
[09:31:29.218]         ...future.stdout <- NULL
[09:31:29.218]     }
[09:31:29.218]     ...future.result$conditions <- ...future.conditions
[09:31:29.218]     ...future.result$finished <- base::Sys.time()
[09:31:29.218]     ...future.result
[09:31:29.218] }
[09:31:29.221] assign_globals() ...
[09:31:29.221] List of 1
[09:31:29.221]  $ x: list()
[09:31:29.221]  - attr(*, "where")=List of 1
[09:31:29.221]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.221]  - attr(*, "resolved")= logi TRUE
[09:31:29.221]  - attr(*, "total_size")= num 0
[09:31:29.221]  - attr(*, "already-done")= logi TRUE
[09:31:29.224] - copied ‘x’ to environment
[09:31:29.224] assign_globals() ... done
[09:31:29.224] requestCore(): workers = 2
[09:31:29.226] MulticoreFuture started
[09:31:29.226] - Launch lazy future ... done
[09:31:29.227] plan(): Setting new future strategy stack:
[09:31:29.226] run() for ‘MulticoreFuture’ ... done
[09:31:29.231] result() for MulticoreFuture ...
[09:31:29.227] List of future strategies:
[09:31:29.227] 1. sequential:
[09:31:29.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.227]    - tweaked: FALSE
[09:31:29.227]    - call: NULL
[09:31:29.231] plan(): nbrOfWorkers() = 1
[09:31:29.234] plan(): Setting new future strategy stack:
[09:31:29.234] List of future strategies:
[09:31:29.234] 1. multicore:
[09:31:29.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.234]    - tweaked: FALSE
[09:31:29.234]    - call: plan(strategy)
[09:31:29.239] plan(): nbrOfWorkers() = 2
[09:31:29.239] result() for MulticoreFuture ...
[09:31:29.240] result() for MulticoreFuture ... done
[09:31:29.240] result() for MulticoreFuture ... done
[09:31:29.240] result() for MulticoreFuture ...
[09:31:29.240] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.241] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.241] Searching for globals...
[09:31:29.244] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.244] Searching for globals ... DONE
[09:31:29.244] Resolving globals: TRUE
[09:31:29.245] Resolving any globals that are futures ...
[09:31:29.245] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.245] Resolving any globals that are futures ... DONE
[09:31:29.245] Resolving futures part of globals (recursively) ...
[09:31:29.246] resolve() on list ...
[09:31:29.246]  recursive: 99
[09:31:29.246]  length: 1
[09:31:29.246]  elements: ‘x’
[09:31:29.246]  length: 0 (resolved future 1)
[09:31:29.246] resolve() on list ... DONE
[09:31:29.246] - globals: [1] ‘x’
[09:31:29.246] Resolving futures part of globals (recursively) ... DONE
[09:31:29.247] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.247] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.247] - globals: [1] ‘x’
[09:31:29.247] 
[09:31:29.247] getGlobalsAndPackages() ... DONE
[09:31:29.248] run() for ‘Future’ ...
[09:31:29.248] - state: ‘created’
[09:31:29.248] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.252] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.252] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.252]   - Field: ‘label’
[09:31:29.252]   - Field: ‘local’
[09:31:29.252]   - Field: ‘owner’
[09:31:29.252]   - Field: ‘envir’
[09:31:29.252]   - Field: ‘workers’
[09:31:29.253]   - Field: ‘packages’
[09:31:29.253]   - Field: ‘gc’
[09:31:29.253]   - Field: ‘job’
[09:31:29.253]   - Field: ‘conditions’
[09:31:29.253]   - Field: ‘expr’
[09:31:29.253]   - Field: ‘uuid’
[09:31:29.253]   - Field: ‘seed’
[09:31:29.253]   - Field: ‘version’
[09:31:29.253]   - Field: ‘result’
[09:31:29.254]   - Field: ‘asynchronous’
[09:31:29.254]   - Field: ‘calls’
[09:31:29.254]   - Field: ‘globals’
[09:31:29.254]   - Field: ‘stdout’
[09:31:29.254]   - Field: ‘earlySignal’
[09:31:29.254]   - Field: ‘lazy’
[09:31:29.254]   - Field: ‘state’
[09:31:29.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.254] - Launch lazy future ...
[09:31:29.255] Packages needed by the future expression (n = 0): <none>
[09:31:29.255] Packages needed by future strategies (n = 0): <none>
[09:31:29.255] {
[09:31:29.255]     {
[09:31:29.255]         {
[09:31:29.255]             ...future.startTime <- base::Sys.time()
[09:31:29.255]             {
[09:31:29.255]                 {
[09:31:29.255]                   {
[09:31:29.255]                     {
[09:31:29.255]                       base::local({
[09:31:29.255]                         has_future <- base::requireNamespace("future", 
[09:31:29.255]                           quietly = TRUE)
[09:31:29.255]                         if (has_future) {
[09:31:29.255]                           ns <- base::getNamespace("future")
[09:31:29.255]                           version <- ns[[".package"]][["version"]]
[09:31:29.255]                           if (is.null(version)) 
[09:31:29.255]                             version <- utils::packageVersion("future")
[09:31:29.255]                         }
[09:31:29.255]                         else {
[09:31:29.255]                           version <- NULL
[09:31:29.255]                         }
[09:31:29.255]                         if (!has_future || version < "1.8.0") {
[09:31:29.255]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.255]                             "", base::R.version$version.string), 
[09:31:29.255]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.255]                               "release", "version")], collapse = " "), 
[09:31:29.255]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.255]                             info)
[09:31:29.255]                           info <- base::paste(info, collapse = "; ")
[09:31:29.255]                           if (!has_future) {
[09:31:29.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.255]                               info)
[09:31:29.255]                           }
[09:31:29.255]                           else {
[09:31:29.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.255]                               info, version)
[09:31:29.255]                           }
[09:31:29.255]                           base::stop(msg)
[09:31:29.255]                         }
[09:31:29.255]                       })
[09:31:29.255]                     }
[09:31:29.255]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.255]                     base::options(mc.cores = 1L)
[09:31:29.255]                   }
[09:31:29.255]                   ...future.strategy.old <- future::plan("list")
[09:31:29.255]                   options(future.plan = NULL)
[09:31:29.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.255]                 }
[09:31:29.255]                 ...future.workdir <- getwd()
[09:31:29.255]             }
[09:31:29.255]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.255]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.255]         }
[09:31:29.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.255]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.255]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.255]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.255]             base::names(...future.oldOptions))
[09:31:29.255]     }
[09:31:29.255]     if (FALSE) {
[09:31:29.255]     }
[09:31:29.255]     else {
[09:31:29.255]         if (TRUE) {
[09:31:29.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.255]                 open = "w")
[09:31:29.255]         }
[09:31:29.255]         else {
[09:31:29.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.255]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.255]         }
[09:31:29.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.255]             base::sink(type = "output", split = FALSE)
[09:31:29.255]             base::close(...future.stdout)
[09:31:29.255]         }, add = TRUE)
[09:31:29.255]     }
[09:31:29.255]     ...future.frame <- base::sys.nframe()
[09:31:29.255]     ...future.conditions <- base::list()
[09:31:29.255]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.255]     if (FALSE) {
[09:31:29.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.255]     }
[09:31:29.255]     ...future.result <- base::tryCatch({
[09:31:29.255]         base::withCallingHandlers({
[09:31:29.255]             ...future.value <- base::withVisible(base::local({
[09:31:29.255]                 withCallingHandlers({
[09:31:29.255]                   {
[09:31:29.255]                     x[["a"]] <- 1
[09:31:29.255]                     x
[09:31:29.255]                   }
[09:31:29.255]                 }, immediateCondition = function(cond) {
[09:31:29.255]                   save_rds <- function (object, pathname, ...) 
[09:31:29.255]                   {
[09:31:29.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.255]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.255]                         fi_tmp[["mtime"]])
[09:31:29.255]                     }
[09:31:29.255]                     tryCatch({
[09:31:29.255]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.255]                     }, error = function(ex) {
[09:31:29.255]                       msg <- conditionMessage(ex)
[09:31:29.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.255]                         fi_tmp[["mtime"]], msg)
[09:31:29.255]                       ex$message <- msg
[09:31:29.255]                       stop(ex)
[09:31:29.255]                     })
[09:31:29.255]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.255]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.255]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.255]                       fi <- file.info(pathname)
[09:31:29.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.255]                         fi[["size"]], fi[["mtime"]])
[09:31:29.255]                       stop(msg)
[09:31:29.255]                     }
[09:31:29.255]                     invisible(pathname)
[09:31:29.255]                   }
[09:31:29.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.255]                     rootPath = tempdir()) 
[09:31:29.255]                   {
[09:31:29.255]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.255]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.255]                       tmpdir = path, fileext = ".rds")
[09:31:29.255]                     save_rds(obj, file)
[09:31:29.255]                   }
[09:31:29.255]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.255]                   {
[09:31:29.255]                     inherits <- base::inherits
[09:31:29.255]                     invokeRestart <- base::invokeRestart
[09:31:29.255]                     is.null <- base::is.null
[09:31:29.255]                     muffled <- FALSE
[09:31:29.255]                     if (inherits(cond, "message")) {
[09:31:29.255]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.255]                       if (muffled) 
[09:31:29.255]                         invokeRestart("muffleMessage")
[09:31:29.255]                     }
[09:31:29.255]                     else if (inherits(cond, "warning")) {
[09:31:29.255]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.255]                       if (muffled) 
[09:31:29.255]                         invokeRestart("muffleWarning")
[09:31:29.255]                     }
[09:31:29.255]                     else if (inherits(cond, "condition")) {
[09:31:29.255]                       if (!is.null(pattern)) {
[09:31:29.255]                         computeRestarts <- base::computeRestarts
[09:31:29.255]                         grepl <- base::grepl
[09:31:29.255]                         restarts <- computeRestarts(cond)
[09:31:29.255]                         for (restart in restarts) {
[09:31:29.255]                           name <- restart$name
[09:31:29.255]                           if (is.null(name)) 
[09:31:29.255]                             next
[09:31:29.255]                           if (!grepl(pattern, name)) 
[09:31:29.255]                             next
[09:31:29.255]                           invokeRestart(restart)
[09:31:29.255]                           muffled <- TRUE
[09:31:29.255]                           break
[09:31:29.255]                         }
[09:31:29.255]                       }
[09:31:29.255]                     }
[09:31:29.255]                     invisible(muffled)
[09:31:29.255]                   }
[09:31:29.255]                   muffleCondition(cond)
[09:31:29.255]                 })
[09:31:29.255]             }))
[09:31:29.255]             future::FutureResult(value = ...future.value$value, 
[09:31:29.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.255]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.255]                     ...future.globalenv.names))
[09:31:29.255]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.255]         }, condition = base::local({
[09:31:29.255]             c <- base::c
[09:31:29.255]             inherits <- base::inherits
[09:31:29.255]             invokeRestart <- base::invokeRestart
[09:31:29.255]             length <- base::length
[09:31:29.255]             list <- base::list
[09:31:29.255]             seq.int <- base::seq.int
[09:31:29.255]             signalCondition <- base::signalCondition
[09:31:29.255]             sys.calls <- base::sys.calls
[09:31:29.255]             `[[` <- base::`[[`
[09:31:29.255]             `+` <- base::`+`
[09:31:29.255]             `<<-` <- base::`<<-`
[09:31:29.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.255]                   3L)]
[09:31:29.255]             }
[09:31:29.255]             function(cond) {
[09:31:29.255]                 is_error <- inherits(cond, "error")
[09:31:29.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.255]                   NULL)
[09:31:29.255]                 if (is_error) {
[09:31:29.255]                   sessionInformation <- function() {
[09:31:29.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.255]                       search = base::search(), system = base::Sys.info())
[09:31:29.255]                   }
[09:31:29.255]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.255]                     cond$call), session = sessionInformation(), 
[09:31:29.255]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.255]                   signalCondition(cond)
[09:31:29.255]                 }
[09:31:29.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.255]                 "immediateCondition"))) {
[09:31:29.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.255]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.255]                   if (TRUE && !signal) {
[09:31:29.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.255]                     {
[09:31:29.255]                       inherits <- base::inherits
[09:31:29.255]                       invokeRestart <- base::invokeRestart
[09:31:29.255]                       is.null <- base::is.null
[09:31:29.255]                       muffled <- FALSE
[09:31:29.255]                       if (inherits(cond, "message")) {
[09:31:29.255]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.255]                         if (muffled) 
[09:31:29.255]                           invokeRestart("muffleMessage")
[09:31:29.255]                       }
[09:31:29.255]                       else if (inherits(cond, "warning")) {
[09:31:29.255]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.255]                         if (muffled) 
[09:31:29.255]                           invokeRestart("muffleWarning")
[09:31:29.255]                       }
[09:31:29.255]                       else if (inherits(cond, "condition")) {
[09:31:29.255]                         if (!is.null(pattern)) {
[09:31:29.255]                           computeRestarts <- base::computeRestarts
[09:31:29.255]                           grepl <- base::grepl
[09:31:29.255]                           restarts <- computeRestarts(cond)
[09:31:29.255]                           for (restart in restarts) {
[09:31:29.255]                             name <- restart$name
[09:31:29.255]                             if (is.null(name)) 
[09:31:29.255]                               next
[09:31:29.255]                             if (!grepl(pattern, name)) 
[09:31:29.255]                               next
[09:31:29.255]                             invokeRestart(restart)
[09:31:29.255]                             muffled <- TRUE
[09:31:29.255]                             break
[09:31:29.255]                           }
[09:31:29.255]                         }
[09:31:29.255]                       }
[09:31:29.255]                       invisible(muffled)
[09:31:29.255]                     }
[09:31:29.255]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.255]                   }
[09:31:29.255]                 }
[09:31:29.255]                 else {
[09:31:29.255]                   if (TRUE) {
[09:31:29.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.255]                     {
[09:31:29.255]                       inherits <- base::inherits
[09:31:29.255]                       invokeRestart <- base::invokeRestart
[09:31:29.255]                       is.null <- base::is.null
[09:31:29.255]                       muffled <- FALSE
[09:31:29.255]                       if (inherits(cond, "message")) {
[09:31:29.255]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.255]                         if (muffled) 
[09:31:29.255]                           invokeRestart("muffleMessage")
[09:31:29.255]                       }
[09:31:29.255]                       else if (inherits(cond, "warning")) {
[09:31:29.255]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.255]                         if (muffled) 
[09:31:29.255]                           invokeRestart("muffleWarning")
[09:31:29.255]                       }
[09:31:29.255]                       else if (inherits(cond, "condition")) {
[09:31:29.255]                         if (!is.null(pattern)) {
[09:31:29.255]                           computeRestarts <- base::computeRestarts
[09:31:29.255]                           grepl <- base::grepl
[09:31:29.255]                           restarts <- computeRestarts(cond)
[09:31:29.255]                           for (restart in restarts) {
[09:31:29.255]                             name <- restart$name
[09:31:29.255]                             if (is.null(name)) 
[09:31:29.255]                               next
[09:31:29.255]                             if (!grepl(pattern, name)) 
[09:31:29.255]                               next
[09:31:29.255]                             invokeRestart(restart)
[09:31:29.255]                             muffled <- TRUE
[09:31:29.255]                             break
[09:31:29.255]                           }
[09:31:29.255]                         }
[09:31:29.255]                       }
[09:31:29.255]                       invisible(muffled)
[09:31:29.255]                     }
[09:31:29.255]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.255]                   }
[09:31:29.255]                 }
[09:31:29.255]             }
[09:31:29.255]         }))
[09:31:29.255]     }, error = function(ex) {
[09:31:29.255]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.255]                 ...future.rng), started = ...future.startTime, 
[09:31:29.255]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.255]             version = "1.8"), class = "FutureResult")
[09:31:29.255]     }, finally = {
[09:31:29.255]         if (!identical(...future.workdir, getwd())) 
[09:31:29.255]             setwd(...future.workdir)
[09:31:29.255]         {
[09:31:29.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.255]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.255]             }
[09:31:29.255]             base::options(...future.oldOptions)
[09:31:29.255]             if (.Platform$OS.type == "windows") {
[09:31:29.255]                 old_names <- names(...future.oldEnvVars)
[09:31:29.255]                 envs <- base::Sys.getenv()
[09:31:29.255]                 names <- names(envs)
[09:31:29.255]                 common <- intersect(names, old_names)
[09:31:29.255]                 added <- setdiff(names, old_names)
[09:31:29.255]                 removed <- setdiff(old_names, names)
[09:31:29.255]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.255]                   envs[common]]
[09:31:29.255]                 NAMES <- toupper(changed)
[09:31:29.255]                 args <- list()
[09:31:29.255]                 for (kk in seq_along(NAMES)) {
[09:31:29.255]                   name <- changed[[kk]]
[09:31:29.255]                   NAME <- NAMES[[kk]]
[09:31:29.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.255]                     next
[09:31:29.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.255]                 }
[09:31:29.255]                 NAMES <- toupper(added)
[09:31:29.255]                 for (kk in seq_along(NAMES)) {
[09:31:29.255]                   name <- added[[kk]]
[09:31:29.255]                   NAME <- NAMES[[kk]]
[09:31:29.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.255]                     next
[09:31:29.255]                   args[[name]] <- ""
[09:31:29.255]                 }
[09:31:29.255]                 NAMES <- toupper(removed)
[09:31:29.255]                 for (kk in seq_along(NAMES)) {
[09:31:29.255]                   name <- removed[[kk]]
[09:31:29.255]                   NAME <- NAMES[[kk]]
[09:31:29.255]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.255]                     next
[09:31:29.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.255]                 }
[09:31:29.255]                 if (length(args) > 0) 
[09:31:29.255]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.255]             }
[09:31:29.255]             else {
[09:31:29.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.255]             }
[09:31:29.255]             {
[09:31:29.255]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.255]                   0L) {
[09:31:29.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.255]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.255]                   base::options(opts)
[09:31:29.255]                 }
[09:31:29.255]                 {
[09:31:29.255]                   {
[09:31:29.255]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.255]                     NULL
[09:31:29.255]                   }
[09:31:29.255]                   options(future.plan = NULL)
[09:31:29.255]                   if (is.na(NA_character_)) 
[09:31:29.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.255]                     .init = FALSE)
[09:31:29.255]                 }
[09:31:29.255]             }
[09:31:29.255]         }
[09:31:29.255]     })
[09:31:29.255]     if (TRUE) {
[09:31:29.255]         base::sink(type = "output", split = FALSE)
[09:31:29.255]         if (TRUE) {
[09:31:29.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.255]         }
[09:31:29.255]         else {
[09:31:29.255]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.255]         }
[09:31:29.255]         base::close(...future.stdout)
[09:31:29.255]         ...future.stdout <- NULL
[09:31:29.255]     }
[09:31:29.255]     ...future.result$conditions <- ...future.conditions
[09:31:29.255]     ...future.result$finished <- base::Sys.time()
[09:31:29.255]     ...future.result
[09:31:29.255] }
[09:31:29.258] assign_globals() ...
[09:31:29.258] List of 1
[09:31:29.258]  $ x: list()
[09:31:29.258]  - attr(*, "where")=List of 1
[09:31:29.258]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.258]  - attr(*, "resolved")= logi TRUE
[09:31:29.258]  - attr(*, "total_size")= num 0
[09:31:29.258]  - attr(*, "already-done")= logi TRUE
[09:31:29.261] - copied ‘x’ to environment
[09:31:29.261] assign_globals() ... done
[09:31:29.261] requestCore(): workers = 2
[09:31:29.263] MulticoreFuture started
[09:31:29.263] - Launch lazy future ... done
[09:31:29.263] run() for ‘MulticoreFuture’ ... done
[09:31:29.263] result() for MulticoreFuture ...
[09:31:29.264] plan(): Setting new future strategy stack:
[09:31:29.264] List of future strategies:
[09:31:29.264] 1. sequential:
[09:31:29.264]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.264]    - tweaked: FALSE
[09:31:29.264]    - call: NULL
[09:31:29.265] plan(): nbrOfWorkers() = 1
[09:31:29.267] plan(): Setting new future strategy stack:
[09:31:29.267] List of future strategies:
[09:31:29.267] 1. multicore:
[09:31:29.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.267]    - tweaked: FALSE
[09:31:29.267]    - call: plan(strategy)
[09:31:29.272] plan(): nbrOfWorkers() = 2
[09:31:29.273] result() for MulticoreFuture ...
[09:31:29.273] result() for MulticoreFuture ... done
[09:31:29.273] result() for MulticoreFuture ... done
[09:31:29.273] result() for MulticoreFuture ...
[09:31:29.273] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.274] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.274] Searching for globals...
[09:31:29.277] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.277] Searching for globals ... DONE
[09:31:29.277] Resolving globals: TRUE
[09:31:29.277] Resolving any globals that are futures ...
[09:31:29.277] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:29.277] Resolving any globals that are futures ... DONE
[09:31:29.278] Resolving futures part of globals (recursively) ...
[09:31:29.278] resolve() on list ...
[09:31:29.278]  recursive: 99
[09:31:29.278]  length: 1
[09:31:29.278]  elements: ‘x’
[09:31:29.279]  length: 0 (resolved future 1)
[09:31:29.279] resolve() on list ... DONE
[09:31:29.279] - globals: [1] ‘x’
[09:31:29.279] Resolving futures part of globals (recursively) ... DONE
[09:31:29.279] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.280] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.280] - globals: [1] ‘x’
[09:31:29.280] 
[09:31:29.280] getGlobalsAndPackages() ... DONE
[09:31:29.280] run() for ‘Future’ ...
[09:31:29.280] - state: ‘created’
[09:31:29.281] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.285] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.285] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.285]   - Field: ‘label’
[09:31:29.285]   - Field: ‘local’
[09:31:29.285]   - Field: ‘owner’
[09:31:29.285]   - Field: ‘envir’
[09:31:29.285]   - Field: ‘workers’
[09:31:29.285]   - Field: ‘packages’
[09:31:29.286]   - Field: ‘gc’
[09:31:29.286]   - Field: ‘job’
[09:31:29.286]   - Field: ‘conditions’
[09:31:29.286]   - Field: ‘expr’
[09:31:29.286]   - Field: ‘uuid’
[09:31:29.288]   - Field: ‘seed’
[09:31:29.288]   - Field: ‘version’
[09:31:29.289]   - Field: ‘result’
[09:31:29.289]   - Field: ‘asynchronous’
[09:31:29.289]   - Field: ‘calls’
[09:31:29.289]   - Field: ‘globals’
[09:31:29.289]   - Field: ‘stdout’
[09:31:29.289]   - Field: ‘earlySignal’
[09:31:29.289]   - Field: ‘lazy’
[09:31:29.289]   - Field: ‘state’
[09:31:29.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.290] - Launch lazy future ...
[09:31:29.290] Packages needed by the future expression (n = 0): <none>
[09:31:29.290] Packages needed by future strategies (n = 0): <none>
[09:31:29.291] {
[09:31:29.291]     {
[09:31:29.291]         {
[09:31:29.291]             ...future.startTime <- base::Sys.time()
[09:31:29.291]             {
[09:31:29.291]                 {
[09:31:29.291]                   {
[09:31:29.291]                     {
[09:31:29.291]                       base::local({
[09:31:29.291]                         has_future <- base::requireNamespace("future", 
[09:31:29.291]                           quietly = TRUE)
[09:31:29.291]                         if (has_future) {
[09:31:29.291]                           ns <- base::getNamespace("future")
[09:31:29.291]                           version <- ns[[".package"]][["version"]]
[09:31:29.291]                           if (is.null(version)) 
[09:31:29.291]                             version <- utils::packageVersion("future")
[09:31:29.291]                         }
[09:31:29.291]                         else {
[09:31:29.291]                           version <- NULL
[09:31:29.291]                         }
[09:31:29.291]                         if (!has_future || version < "1.8.0") {
[09:31:29.291]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.291]                             "", base::R.version$version.string), 
[09:31:29.291]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.291]                               "release", "version")], collapse = " "), 
[09:31:29.291]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.291]                             info)
[09:31:29.291]                           info <- base::paste(info, collapse = "; ")
[09:31:29.291]                           if (!has_future) {
[09:31:29.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.291]                               info)
[09:31:29.291]                           }
[09:31:29.291]                           else {
[09:31:29.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.291]                               info, version)
[09:31:29.291]                           }
[09:31:29.291]                           base::stop(msg)
[09:31:29.291]                         }
[09:31:29.291]                       })
[09:31:29.291]                     }
[09:31:29.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.291]                     base::options(mc.cores = 1L)
[09:31:29.291]                   }
[09:31:29.291]                   ...future.strategy.old <- future::plan("list")
[09:31:29.291]                   options(future.plan = NULL)
[09:31:29.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.291]                 }
[09:31:29.291]                 ...future.workdir <- getwd()
[09:31:29.291]             }
[09:31:29.291]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.291]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.291]         }
[09:31:29.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.291]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.291]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.291]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.291]             base::names(...future.oldOptions))
[09:31:29.291]     }
[09:31:29.291]     if (FALSE) {
[09:31:29.291]     }
[09:31:29.291]     else {
[09:31:29.291]         if (TRUE) {
[09:31:29.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.291]                 open = "w")
[09:31:29.291]         }
[09:31:29.291]         else {
[09:31:29.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.291]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.291]         }
[09:31:29.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.291]             base::sink(type = "output", split = FALSE)
[09:31:29.291]             base::close(...future.stdout)
[09:31:29.291]         }, add = TRUE)
[09:31:29.291]     }
[09:31:29.291]     ...future.frame <- base::sys.nframe()
[09:31:29.291]     ...future.conditions <- base::list()
[09:31:29.291]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.291]     if (FALSE) {
[09:31:29.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.291]     }
[09:31:29.291]     ...future.result <- base::tryCatch({
[09:31:29.291]         base::withCallingHandlers({
[09:31:29.291]             ...future.value <- base::withVisible(base::local({
[09:31:29.291]                 withCallingHandlers({
[09:31:29.291]                   {
[09:31:29.291]                     x[["a"]] <- 1
[09:31:29.291]                     x
[09:31:29.291]                   }
[09:31:29.291]                 }, immediateCondition = function(cond) {
[09:31:29.291]                   save_rds <- function (object, pathname, ...) 
[09:31:29.291]                   {
[09:31:29.291]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.291]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.291]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.291]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.291]                         fi_tmp[["mtime"]])
[09:31:29.291]                     }
[09:31:29.291]                     tryCatch({
[09:31:29.291]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.291]                     }, error = function(ex) {
[09:31:29.291]                       msg <- conditionMessage(ex)
[09:31:29.291]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.291]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.291]                         fi_tmp[["mtime"]], msg)
[09:31:29.291]                       ex$message <- msg
[09:31:29.291]                       stop(ex)
[09:31:29.291]                     })
[09:31:29.291]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.291]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.291]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.291]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.291]                       fi <- file.info(pathname)
[09:31:29.291]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.291]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.291]                         fi[["size"]], fi[["mtime"]])
[09:31:29.291]                       stop(msg)
[09:31:29.291]                     }
[09:31:29.291]                     invisible(pathname)
[09:31:29.291]                   }
[09:31:29.291]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.291]                     rootPath = tempdir()) 
[09:31:29.291]                   {
[09:31:29.291]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.291]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.291]                       tmpdir = path, fileext = ".rds")
[09:31:29.291]                     save_rds(obj, file)
[09:31:29.291]                   }
[09:31:29.291]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.291]                   {
[09:31:29.291]                     inherits <- base::inherits
[09:31:29.291]                     invokeRestart <- base::invokeRestart
[09:31:29.291]                     is.null <- base::is.null
[09:31:29.291]                     muffled <- FALSE
[09:31:29.291]                     if (inherits(cond, "message")) {
[09:31:29.291]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.291]                       if (muffled) 
[09:31:29.291]                         invokeRestart("muffleMessage")
[09:31:29.291]                     }
[09:31:29.291]                     else if (inherits(cond, "warning")) {
[09:31:29.291]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.291]                       if (muffled) 
[09:31:29.291]                         invokeRestart("muffleWarning")
[09:31:29.291]                     }
[09:31:29.291]                     else if (inherits(cond, "condition")) {
[09:31:29.291]                       if (!is.null(pattern)) {
[09:31:29.291]                         computeRestarts <- base::computeRestarts
[09:31:29.291]                         grepl <- base::grepl
[09:31:29.291]                         restarts <- computeRestarts(cond)
[09:31:29.291]                         for (restart in restarts) {
[09:31:29.291]                           name <- restart$name
[09:31:29.291]                           if (is.null(name)) 
[09:31:29.291]                             next
[09:31:29.291]                           if (!grepl(pattern, name)) 
[09:31:29.291]                             next
[09:31:29.291]                           invokeRestart(restart)
[09:31:29.291]                           muffled <- TRUE
[09:31:29.291]                           break
[09:31:29.291]                         }
[09:31:29.291]                       }
[09:31:29.291]                     }
[09:31:29.291]                     invisible(muffled)
[09:31:29.291]                   }
[09:31:29.291]                   muffleCondition(cond)
[09:31:29.291]                 })
[09:31:29.291]             }))
[09:31:29.291]             future::FutureResult(value = ...future.value$value, 
[09:31:29.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.291]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.291]                     ...future.globalenv.names))
[09:31:29.291]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.291]         }, condition = base::local({
[09:31:29.291]             c <- base::c
[09:31:29.291]             inherits <- base::inherits
[09:31:29.291]             invokeRestart <- base::invokeRestart
[09:31:29.291]             length <- base::length
[09:31:29.291]             list <- base::list
[09:31:29.291]             seq.int <- base::seq.int
[09:31:29.291]             signalCondition <- base::signalCondition
[09:31:29.291]             sys.calls <- base::sys.calls
[09:31:29.291]             `[[` <- base::`[[`
[09:31:29.291]             `+` <- base::`+`
[09:31:29.291]             `<<-` <- base::`<<-`
[09:31:29.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.291]                   3L)]
[09:31:29.291]             }
[09:31:29.291]             function(cond) {
[09:31:29.291]                 is_error <- inherits(cond, "error")
[09:31:29.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.291]                   NULL)
[09:31:29.291]                 if (is_error) {
[09:31:29.291]                   sessionInformation <- function() {
[09:31:29.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.291]                       search = base::search(), system = base::Sys.info())
[09:31:29.291]                   }
[09:31:29.291]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.291]                     cond$call), session = sessionInformation(), 
[09:31:29.291]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.291]                   signalCondition(cond)
[09:31:29.291]                 }
[09:31:29.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.291]                 "immediateCondition"))) {
[09:31:29.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.291]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.291]                   if (TRUE && !signal) {
[09:31:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.291]                     {
[09:31:29.291]                       inherits <- base::inherits
[09:31:29.291]                       invokeRestart <- base::invokeRestart
[09:31:29.291]                       is.null <- base::is.null
[09:31:29.291]                       muffled <- FALSE
[09:31:29.291]                       if (inherits(cond, "message")) {
[09:31:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.291]                         if (muffled) 
[09:31:29.291]                           invokeRestart("muffleMessage")
[09:31:29.291]                       }
[09:31:29.291]                       else if (inherits(cond, "warning")) {
[09:31:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.291]                         if (muffled) 
[09:31:29.291]                           invokeRestart("muffleWarning")
[09:31:29.291]                       }
[09:31:29.291]                       else if (inherits(cond, "condition")) {
[09:31:29.291]                         if (!is.null(pattern)) {
[09:31:29.291]                           computeRestarts <- base::computeRestarts
[09:31:29.291]                           grepl <- base::grepl
[09:31:29.291]                           restarts <- computeRestarts(cond)
[09:31:29.291]                           for (restart in restarts) {
[09:31:29.291]                             name <- restart$name
[09:31:29.291]                             if (is.null(name)) 
[09:31:29.291]                               next
[09:31:29.291]                             if (!grepl(pattern, name)) 
[09:31:29.291]                               next
[09:31:29.291]                             invokeRestart(restart)
[09:31:29.291]                             muffled <- TRUE
[09:31:29.291]                             break
[09:31:29.291]                           }
[09:31:29.291]                         }
[09:31:29.291]                       }
[09:31:29.291]                       invisible(muffled)
[09:31:29.291]                     }
[09:31:29.291]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.291]                   }
[09:31:29.291]                 }
[09:31:29.291]                 else {
[09:31:29.291]                   if (TRUE) {
[09:31:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.291]                     {
[09:31:29.291]                       inherits <- base::inherits
[09:31:29.291]                       invokeRestart <- base::invokeRestart
[09:31:29.291]                       is.null <- base::is.null
[09:31:29.291]                       muffled <- FALSE
[09:31:29.291]                       if (inherits(cond, "message")) {
[09:31:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.291]                         if (muffled) 
[09:31:29.291]                           invokeRestart("muffleMessage")
[09:31:29.291]                       }
[09:31:29.291]                       else if (inherits(cond, "warning")) {
[09:31:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.291]                         if (muffled) 
[09:31:29.291]                           invokeRestart("muffleWarning")
[09:31:29.291]                       }
[09:31:29.291]                       else if (inherits(cond, "condition")) {
[09:31:29.291]                         if (!is.null(pattern)) {
[09:31:29.291]                           computeRestarts <- base::computeRestarts
[09:31:29.291]                           grepl <- base::grepl
[09:31:29.291]                           restarts <- computeRestarts(cond)
[09:31:29.291]                           for (restart in restarts) {
[09:31:29.291]                             name <- restart$name
[09:31:29.291]                             if (is.null(name)) 
[09:31:29.291]                               next
[09:31:29.291]                             if (!grepl(pattern, name)) 
[09:31:29.291]                               next
[09:31:29.291]                             invokeRestart(restart)
[09:31:29.291]                             muffled <- TRUE
[09:31:29.291]                             break
[09:31:29.291]                           }
[09:31:29.291]                         }
[09:31:29.291]                       }
[09:31:29.291]                       invisible(muffled)
[09:31:29.291]                     }
[09:31:29.291]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.291]                   }
[09:31:29.291]                 }
[09:31:29.291]             }
[09:31:29.291]         }))
[09:31:29.291]     }, error = function(ex) {
[09:31:29.291]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.291]                 ...future.rng), started = ...future.startTime, 
[09:31:29.291]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.291]             version = "1.8"), class = "FutureResult")
[09:31:29.291]     }, finally = {
[09:31:29.291]         if (!identical(...future.workdir, getwd())) 
[09:31:29.291]             setwd(...future.workdir)
[09:31:29.291]         {
[09:31:29.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.291]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.291]             }
[09:31:29.291]             base::options(...future.oldOptions)
[09:31:29.291]             if (.Platform$OS.type == "windows") {
[09:31:29.291]                 old_names <- names(...future.oldEnvVars)
[09:31:29.291]                 envs <- base::Sys.getenv()
[09:31:29.291]                 names <- names(envs)
[09:31:29.291]                 common <- intersect(names, old_names)
[09:31:29.291]                 added <- setdiff(names, old_names)
[09:31:29.291]                 removed <- setdiff(old_names, names)
[09:31:29.291]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.291]                   envs[common]]
[09:31:29.291]                 NAMES <- toupper(changed)
[09:31:29.291]                 args <- list()
[09:31:29.291]                 for (kk in seq_along(NAMES)) {
[09:31:29.291]                   name <- changed[[kk]]
[09:31:29.291]                   NAME <- NAMES[[kk]]
[09:31:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.291]                     next
[09:31:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.291]                 }
[09:31:29.291]                 NAMES <- toupper(added)
[09:31:29.291]                 for (kk in seq_along(NAMES)) {
[09:31:29.291]                   name <- added[[kk]]
[09:31:29.291]                   NAME <- NAMES[[kk]]
[09:31:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.291]                     next
[09:31:29.291]                   args[[name]] <- ""
[09:31:29.291]                 }
[09:31:29.291]                 NAMES <- toupper(removed)
[09:31:29.291]                 for (kk in seq_along(NAMES)) {
[09:31:29.291]                   name <- removed[[kk]]
[09:31:29.291]                   NAME <- NAMES[[kk]]
[09:31:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.291]                     next
[09:31:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.291]                 }
[09:31:29.291]                 if (length(args) > 0) 
[09:31:29.291]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.291]             }
[09:31:29.291]             else {
[09:31:29.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.291]             }
[09:31:29.291]             {
[09:31:29.291]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.291]                   0L) {
[09:31:29.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.291]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.291]                   base::options(opts)
[09:31:29.291]                 }
[09:31:29.291]                 {
[09:31:29.291]                   {
[09:31:29.291]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.291]                     NULL
[09:31:29.291]                   }
[09:31:29.291]                   options(future.plan = NULL)
[09:31:29.291]                   if (is.na(NA_character_)) 
[09:31:29.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.291]                     .init = FALSE)
[09:31:29.291]                 }
[09:31:29.291]             }
[09:31:29.291]         }
[09:31:29.291]     })
[09:31:29.291]     if (TRUE) {
[09:31:29.291]         base::sink(type = "output", split = FALSE)
[09:31:29.291]         if (TRUE) {
[09:31:29.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.291]         }
[09:31:29.291]         else {
[09:31:29.291]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.291]         }
[09:31:29.291]         base::close(...future.stdout)
[09:31:29.291]         ...future.stdout <- NULL
[09:31:29.291]     }
[09:31:29.291]     ...future.result$conditions <- ...future.conditions
[09:31:29.291]     ...future.result$finished <- base::Sys.time()
[09:31:29.291]     ...future.result
[09:31:29.291] }
[09:31:29.293] assign_globals() ...
[09:31:29.293] List of 1
[09:31:29.293]  $ x: list()
[09:31:29.293]  - attr(*, "where")=List of 1
[09:31:29.293]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.293]  - attr(*, "resolved")= logi TRUE
[09:31:29.293]  - attr(*, "total_size")= num 0
[09:31:29.293]  - attr(*, "already-done")= logi TRUE
[09:31:29.296] - copied ‘x’ to environment
[09:31:29.296] assign_globals() ... done
[09:31:29.296] requestCore(): workers = 2
[09:31:29.298] MulticoreFuture started
[09:31:29.298] - Launch lazy future ... done
[09:31:29.299] run() for ‘MulticoreFuture’ ... done
[09:31:29.299] plan(): Setting new future strategy stack:
[09:31:29.299] result() for MulticoreFuture ...
[09:31:29.299] List of future strategies:
[09:31:29.299] 1. sequential:
[09:31:29.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.299]    - tweaked: FALSE
[09:31:29.299]    - call: NULL
[09:31:29.300] plan(): nbrOfWorkers() = 1
[09:31:29.302] plan(): Setting new future strategy stack:
[09:31:29.302] List of future strategies:
[09:31:29.302] 1. multicore:
[09:31:29.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.302]    - tweaked: FALSE
[09:31:29.302]    - call: plan(strategy)
[09:31:29.307] plan(): nbrOfWorkers() = 2
[09:31:29.308] result() for MulticoreFuture ...
[09:31:29.308] result() for MulticoreFuture ... done
[09:31:29.308] result() for MulticoreFuture ... done
[09:31:29.309] result() for MulticoreFuture ...
[09:31:29.309] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.309] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.309] Searching for globals...
[09:31:29.312] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.312] Searching for globals ... DONE
[09:31:29.313] Resolving globals: TRUE
[09:31:29.313] Resolving any globals that are futures ...
[09:31:29.313] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.313] Resolving any globals that are futures ... DONE
[09:31:29.313] Resolving futures part of globals (recursively) ...
[09:31:29.314] resolve() on list ...
[09:31:29.314]  recursive: 99
[09:31:29.314]  length: 1
[09:31:29.314]  elements: ‘x’
[09:31:29.314]  length: 0 (resolved future 1)
[09:31:29.314] resolve() on list ... DONE
[09:31:29.314] - globals: [1] ‘x’
[09:31:29.315] Resolving futures part of globals (recursively) ... DONE
[09:31:29.315] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.315] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.315] - globals: [1] ‘x’
[09:31:29.315] 
[09:31:29.316] getGlobalsAndPackages() ... DONE
[09:31:29.316] run() for ‘Future’ ...
[09:31:29.316] - state: ‘created’
[09:31:29.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.320] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.320]   - Field: ‘label’
[09:31:29.320]   - Field: ‘local’
[09:31:29.320]   - Field: ‘owner’
[09:31:29.321]   - Field: ‘envir’
[09:31:29.321]   - Field: ‘workers’
[09:31:29.321]   - Field: ‘packages’
[09:31:29.321]   - Field: ‘gc’
[09:31:29.321]   - Field: ‘job’
[09:31:29.321]   - Field: ‘conditions’
[09:31:29.321]   - Field: ‘expr’
[09:31:29.321]   - Field: ‘uuid’
[09:31:29.321]   - Field: ‘seed’
[09:31:29.322]   - Field: ‘version’
[09:31:29.322]   - Field: ‘result’
[09:31:29.322]   - Field: ‘asynchronous’
[09:31:29.322]   - Field: ‘calls’
[09:31:29.322]   - Field: ‘globals’
[09:31:29.322]   - Field: ‘stdout’
[09:31:29.322]   - Field: ‘earlySignal’
[09:31:29.322]   - Field: ‘lazy’
[09:31:29.322]   - Field: ‘state’
[09:31:29.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.323] - Launch lazy future ...
[09:31:29.323] Packages needed by the future expression (n = 0): <none>
[09:31:29.323] Packages needed by future strategies (n = 0): <none>
[09:31:29.324] {
[09:31:29.324]     {
[09:31:29.324]         {
[09:31:29.324]             ...future.startTime <- base::Sys.time()
[09:31:29.324]             {
[09:31:29.324]                 {
[09:31:29.324]                   {
[09:31:29.324]                     {
[09:31:29.324]                       base::local({
[09:31:29.324]                         has_future <- base::requireNamespace("future", 
[09:31:29.324]                           quietly = TRUE)
[09:31:29.324]                         if (has_future) {
[09:31:29.324]                           ns <- base::getNamespace("future")
[09:31:29.324]                           version <- ns[[".package"]][["version"]]
[09:31:29.324]                           if (is.null(version)) 
[09:31:29.324]                             version <- utils::packageVersion("future")
[09:31:29.324]                         }
[09:31:29.324]                         else {
[09:31:29.324]                           version <- NULL
[09:31:29.324]                         }
[09:31:29.324]                         if (!has_future || version < "1.8.0") {
[09:31:29.324]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.324]                             "", base::R.version$version.string), 
[09:31:29.324]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.324]                               "release", "version")], collapse = " "), 
[09:31:29.324]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.324]                             info)
[09:31:29.324]                           info <- base::paste(info, collapse = "; ")
[09:31:29.324]                           if (!has_future) {
[09:31:29.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.324]                               info)
[09:31:29.324]                           }
[09:31:29.324]                           else {
[09:31:29.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.324]                               info, version)
[09:31:29.324]                           }
[09:31:29.324]                           base::stop(msg)
[09:31:29.324]                         }
[09:31:29.324]                       })
[09:31:29.324]                     }
[09:31:29.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.324]                     base::options(mc.cores = 1L)
[09:31:29.324]                   }
[09:31:29.324]                   ...future.strategy.old <- future::plan("list")
[09:31:29.324]                   options(future.plan = NULL)
[09:31:29.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.324]                 }
[09:31:29.324]                 ...future.workdir <- getwd()
[09:31:29.324]             }
[09:31:29.324]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.324]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.324]         }
[09:31:29.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.324]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.324]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.324]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.324]             base::names(...future.oldOptions))
[09:31:29.324]     }
[09:31:29.324]     if (FALSE) {
[09:31:29.324]     }
[09:31:29.324]     else {
[09:31:29.324]         if (TRUE) {
[09:31:29.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.324]                 open = "w")
[09:31:29.324]         }
[09:31:29.324]         else {
[09:31:29.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.324]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.324]         }
[09:31:29.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.324]             base::sink(type = "output", split = FALSE)
[09:31:29.324]             base::close(...future.stdout)
[09:31:29.324]         }, add = TRUE)
[09:31:29.324]     }
[09:31:29.324]     ...future.frame <- base::sys.nframe()
[09:31:29.324]     ...future.conditions <- base::list()
[09:31:29.324]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.324]     if (FALSE) {
[09:31:29.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.324]     }
[09:31:29.324]     ...future.result <- base::tryCatch({
[09:31:29.324]         base::withCallingHandlers({
[09:31:29.324]             ...future.value <- base::withVisible(base::local({
[09:31:29.324]                 withCallingHandlers({
[09:31:29.324]                   {
[09:31:29.324]                     x["a"] <- list(1)
[09:31:29.324]                     x
[09:31:29.324]                   }
[09:31:29.324]                 }, immediateCondition = function(cond) {
[09:31:29.324]                   save_rds <- function (object, pathname, ...) 
[09:31:29.324]                   {
[09:31:29.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.324]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.324]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.324]                         fi_tmp[["mtime"]])
[09:31:29.324]                     }
[09:31:29.324]                     tryCatch({
[09:31:29.324]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.324]                     }, error = function(ex) {
[09:31:29.324]                       msg <- conditionMessage(ex)
[09:31:29.324]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.324]                         fi_tmp[["mtime"]], msg)
[09:31:29.324]                       ex$message <- msg
[09:31:29.324]                       stop(ex)
[09:31:29.324]                     })
[09:31:29.324]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.324]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.324]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.324]                       fi <- file.info(pathname)
[09:31:29.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.324]                         fi[["size"]], fi[["mtime"]])
[09:31:29.324]                       stop(msg)
[09:31:29.324]                     }
[09:31:29.324]                     invisible(pathname)
[09:31:29.324]                   }
[09:31:29.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.324]                     rootPath = tempdir()) 
[09:31:29.324]                   {
[09:31:29.324]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.324]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.324]                       tmpdir = path, fileext = ".rds")
[09:31:29.324]                     save_rds(obj, file)
[09:31:29.324]                   }
[09:31:29.324]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.324]                   {
[09:31:29.324]                     inherits <- base::inherits
[09:31:29.324]                     invokeRestart <- base::invokeRestart
[09:31:29.324]                     is.null <- base::is.null
[09:31:29.324]                     muffled <- FALSE
[09:31:29.324]                     if (inherits(cond, "message")) {
[09:31:29.324]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.324]                       if (muffled) 
[09:31:29.324]                         invokeRestart("muffleMessage")
[09:31:29.324]                     }
[09:31:29.324]                     else if (inherits(cond, "warning")) {
[09:31:29.324]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.324]                       if (muffled) 
[09:31:29.324]                         invokeRestart("muffleWarning")
[09:31:29.324]                     }
[09:31:29.324]                     else if (inherits(cond, "condition")) {
[09:31:29.324]                       if (!is.null(pattern)) {
[09:31:29.324]                         computeRestarts <- base::computeRestarts
[09:31:29.324]                         grepl <- base::grepl
[09:31:29.324]                         restarts <- computeRestarts(cond)
[09:31:29.324]                         for (restart in restarts) {
[09:31:29.324]                           name <- restart$name
[09:31:29.324]                           if (is.null(name)) 
[09:31:29.324]                             next
[09:31:29.324]                           if (!grepl(pattern, name)) 
[09:31:29.324]                             next
[09:31:29.324]                           invokeRestart(restart)
[09:31:29.324]                           muffled <- TRUE
[09:31:29.324]                           break
[09:31:29.324]                         }
[09:31:29.324]                       }
[09:31:29.324]                     }
[09:31:29.324]                     invisible(muffled)
[09:31:29.324]                   }
[09:31:29.324]                   muffleCondition(cond)
[09:31:29.324]                 })
[09:31:29.324]             }))
[09:31:29.324]             future::FutureResult(value = ...future.value$value, 
[09:31:29.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.324]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.324]                     ...future.globalenv.names))
[09:31:29.324]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.324]         }, condition = base::local({
[09:31:29.324]             c <- base::c
[09:31:29.324]             inherits <- base::inherits
[09:31:29.324]             invokeRestart <- base::invokeRestart
[09:31:29.324]             length <- base::length
[09:31:29.324]             list <- base::list
[09:31:29.324]             seq.int <- base::seq.int
[09:31:29.324]             signalCondition <- base::signalCondition
[09:31:29.324]             sys.calls <- base::sys.calls
[09:31:29.324]             `[[` <- base::`[[`
[09:31:29.324]             `+` <- base::`+`
[09:31:29.324]             `<<-` <- base::`<<-`
[09:31:29.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.324]                   3L)]
[09:31:29.324]             }
[09:31:29.324]             function(cond) {
[09:31:29.324]                 is_error <- inherits(cond, "error")
[09:31:29.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.324]                   NULL)
[09:31:29.324]                 if (is_error) {
[09:31:29.324]                   sessionInformation <- function() {
[09:31:29.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.324]                       search = base::search(), system = base::Sys.info())
[09:31:29.324]                   }
[09:31:29.324]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.324]                     cond$call), session = sessionInformation(), 
[09:31:29.324]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.324]                   signalCondition(cond)
[09:31:29.324]                 }
[09:31:29.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.324]                 "immediateCondition"))) {
[09:31:29.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.324]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.324]                   if (TRUE && !signal) {
[09:31:29.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.324]                     {
[09:31:29.324]                       inherits <- base::inherits
[09:31:29.324]                       invokeRestart <- base::invokeRestart
[09:31:29.324]                       is.null <- base::is.null
[09:31:29.324]                       muffled <- FALSE
[09:31:29.324]                       if (inherits(cond, "message")) {
[09:31:29.324]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.324]                         if (muffled) 
[09:31:29.324]                           invokeRestart("muffleMessage")
[09:31:29.324]                       }
[09:31:29.324]                       else if (inherits(cond, "warning")) {
[09:31:29.324]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.324]                         if (muffled) 
[09:31:29.324]                           invokeRestart("muffleWarning")
[09:31:29.324]                       }
[09:31:29.324]                       else if (inherits(cond, "condition")) {
[09:31:29.324]                         if (!is.null(pattern)) {
[09:31:29.324]                           computeRestarts <- base::computeRestarts
[09:31:29.324]                           grepl <- base::grepl
[09:31:29.324]                           restarts <- computeRestarts(cond)
[09:31:29.324]                           for (restart in restarts) {
[09:31:29.324]                             name <- restart$name
[09:31:29.324]                             if (is.null(name)) 
[09:31:29.324]                               next
[09:31:29.324]                             if (!grepl(pattern, name)) 
[09:31:29.324]                               next
[09:31:29.324]                             invokeRestart(restart)
[09:31:29.324]                             muffled <- TRUE
[09:31:29.324]                             break
[09:31:29.324]                           }
[09:31:29.324]                         }
[09:31:29.324]                       }
[09:31:29.324]                       invisible(muffled)
[09:31:29.324]                     }
[09:31:29.324]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.324]                   }
[09:31:29.324]                 }
[09:31:29.324]                 else {
[09:31:29.324]                   if (TRUE) {
[09:31:29.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.324]                     {
[09:31:29.324]                       inherits <- base::inherits
[09:31:29.324]                       invokeRestart <- base::invokeRestart
[09:31:29.324]                       is.null <- base::is.null
[09:31:29.324]                       muffled <- FALSE
[09:31:29.324]                       if (inherits(cond, "message")) {
[09:31:29.324]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.324]                         if (muffled) 
[09:31:29.324]                           invokeRestart("muffleMessage")
[09:31:29.324]                       }
[09:31:29.324]                       else if (inherits(cond, "warning")) {
[09:31:29.324]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.324]                         if (muffled) 
[09:31:29.324]                           invokeRestart("muffleWarning")
[09:31:29.324]                       }
[09:31:29.324]                       else if (inherits(cond, "condition")) {
[09:31:29.324]                         if (!is.null(pattern)) {
[09:31:29.324]                           computeRestarts <- base::computeRestarts
[09:31:29.324]                           grepl <- base::grepl
[09:31:29.324]                           restarts <- computeRestarts(cond)
[09:31:29.324]                           for (restart in restarts) {
[09:31:29.324]                             name <- restart$name
[09:31:29.324]                             if (is.null(name)) 
[09:31:29.324]                               next
[09:31:29.324]                             if (!grepl(pattern, name)) 
[09:31:29.324]                               next
[09:31:29.324]                             invokeRestart(restart)
[09:31:29.324]                             muffled <- TRUE
[09:31:29.324]                             break
[09:31:29.324]                           }
[09:31:29.324]                         }
[09:31:29.324]                       }
[09:31:29.324]                       invisible(muffled)
[09:31:29.324]                     }
[09:31:29.324]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.324]                   }
[09:31:29.324]                 }
[09:31:29.324]             }
[09:31:29.324]         }))
[09:31:29.324]     }, error = function(ex) {
[09:31:29.324]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.324]                 ...future.rng), started = ...future.startTime, 
[09:31:29.324]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.324]             version = "1.8"), class = "FutureResult")
[09:31:29.324]     }, finally = {
[09:31:29.324]         if (!identical(...future.workdir, getwd())) 
[09:31:29.324]             setwd(...future.workdir)
[09:31:29.324]         {
[09:31:29.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.324]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.324]             }
[09:31:29.324]             base::options(...future.oldOptions)
[09:31:29.324]             if (.Platform$OS.type == "windows") {
[09:31:29.324]                 old_names <- names(...future.oldEnvVars)
[09:31:29.324]                 envs <- base::Sys.getenv()
[09:31:29.324]                 names <- names(envs)
[09:31:29.324]                 common <- intersect(names, old_names)
[09:31:29.324]                 added <- setdiff(names, old_names)
[09:31:29.324]                 removed <- setdiff(old_names, names)
[09:31:29.324]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.324]                   envs[common]]
[09:31:29.324]                 NAMES <- toupper(changed)
[09:31:29.324]                 args <- list()
[09:31:29.324]                 for (kk in seq_along(NAMES)) {
[09:31:29.324]                   name <- changed[[kk]]
[09:31:29.324]                   NAME <- NAMES[[kk]]
[09:31:29.324]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.324]                     next
[09:31:29.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.324]                 }
[09:31:29.324]                 NAMES <- toupper(added)
[09:31:29.324]                 for (kk in seq_along(NAMES)) {
[09:31:29.324]                   name <- added[[kk]]
[09:31:29.324]                   NAME <- NAMES[[kk]]
[09:31:29.324]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.324]                     next
[09:31:29.324]                   args[[name]] <- ""
[09:31:29.324]                 }
[09:31:29.324]                 NAMES <- toupper(removed)
[09:31:29.324]                 for (kk in seq_along(NAMES)) {
[09:31:29.324]                   name <- removed[[kk]]
[09:31:29.324]                   NAME <- NAMES[[kk]]
[09:31:29.324]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.324]                     next
[09:31:29.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.324]                 }
[09:31:29.324]                 if (length(args) > 0) 
[09:31:29.324]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.324]             }
[09:31:29.324]             else {
[09:31:29.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.324]             }
[09:31:29.324]             {
[09:31:29.324]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.324]                   0L) {
[09:31:29.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.324]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.324]                   base::options(opts)
[09:31:29.324]                 }
[09:31:29.324]                 {
[09:31:29.324]                   {
[09:31:29.324]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.324]                     NULL
[09:31:29.324]                   }
[09:31:29.324]                   options(future.plan = NULL)
[09:31:29.324]                   if (is.na(NA_character_)) 
[09:31:29.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.324]                     .init = FALSE)
[09:31:29.324]                 }
[09:31:29.324]             }
[09:31:29.324]         }
[09:31:29.324]     })
[09:31:29.324]     if (TRUE) {
[09:31:29.324]         base::sink(type = "output", split = FALSE)
[09:31:29.324]         if (TRUE) {
[09:31:29.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.324]         }
[09:31:29.324]         else {
[09:31:29.324]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.324]         }
[09:31:29.324]         base::close(...future.stdout)
[09:31:29.324]         ...future.stdout <- NULL
[09:31:29.324]     }
[09:31:29.324]     ...future.result$conditions <- ...future.conditions
[09:31:29.324]     ...future.result$finished <- base::Sys.time()
[09:31:29.324]     ...future.result
[09:31:29.324] }
[09:31:29.326] assign_globals() ...
[09:31:29.326] List of 1
[09:31:29.326]  $ x: list()
[09:31:29.326]  - attr(*, "where")=List of 1
[09:31:29.326]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.326]  - attr(*, "resolved")= logi TRUE
[09:31:29.326]  - attr(*, "total_size")= num 0
[09:31:29.326]  - attr(*, "already-done")= logi TRUE
[09:31:29.329] - copied ‘x’ to environment
[09:31:29.329] assign_globals() ... done
[09:31:29.329] requestCore(): workers = 2
[09:31:29.331] MulticoreFuture started
[09:31:29.331] - Launch lazy future ... done
[09:31:29.331] run() for ‘MulticoreFuture’ ... done
[09:31:29.332] result() for MulticoreFuture ...
[09:31:29.332] plan(): Setting new future strategy stack:
[09:31:29.332] List of future strategies:
[09:31:29.332] 1. sequential:
[09:31:29.332]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.332]    - tweaked: FALSE
[09:31:29.332]    - call: NULL
[09:31:29.333] plan(): nbrOfWorkers() = 1
[09:31:29.335] plan(): Setting new future strategy stack:
[09:31:29.335] List of future strategies:
[09:31:29.335] 1. multicore:
[09:31:29.335]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.335]    - tweaked: FALSE
[09:31:29.335]    - call: plan(strategy)
[09:31:29.340] plan(): nbrOfWorkers() = 2
[09:31:29.341] result() for MulticoreFuture ...
[09:31:29.341] result() for MulticoreFuture ... done
[09:31:29.341] result() for MulticoreFuture ... done
[09:31:29.341] result() for MulticoreFuture ...
[09:31:29.341] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.342] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.342] Searching for globals...
[09:31:29.348] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.348] Searching for globals ... DONE
[09:31:29.348] Resolving globals: TRUE
[09:31:29.348] Resolving any globals that are futures ...
[09:31:29.349] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.349] Resolving any globals that are futures ... DONE
[09:31:29.349] Resolving futures part of globals (recursively) ...
[09:31:29.350] resolve() on list ...
[09:31:29.350]  recursive: 99
[09:31:29.350]  length: 1
[09:31:29.350]  elements: ‘x’
[09:31:29.350]  length: 0 (resolved future 1)
[09:31:29.350] resolve() on list ... DONE
[09:31:29.350] - globals: [1] ‘x’
[09:31:29.350] Resolving futures part of globals (recursively) ... DONE
[09:31:29.351] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.351] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.351] - globals: [1] ‘x’
[09:31:29.351] 
[09:31:29.351] getGlobalsAndPackages() ... DONE
[09:31:29.352] run() for ‘Future’ ...
[09:31:29.352] - state: ‘created’
[09:31:29.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.356]   - Field: ‘label’
[09:31:29.356]   - Field: ‘local’
[09:31:29.356]   - Field: ‘owner’
[09:31:29.357]   - Field: ‘envir’
[09:31:29.357]   - Field: ‘workers’
[09:31:29.357]   - Field: ‘packages’
[09:31:29.357]   - Field: ‘gc’
[09:31:29.357]   - Field: ‘job’
[09:31:29.357]   - Field: ‘conditions’
[09:31:29.357]   - Field: ‘expr’
[09:31:29.357]   - Field: ‘uuid’
[09:31:29.357]   - Field: ‘seed’
[09:31:29.358]   - Field: ‘version’
[09:31:29.358]   - Field: ‘result’
[09:31:29.358]   - Field: ‘asynchronous’
[09:31:29.358]   - Field: ‘calls’
[09:31:29.358]   - Field: ‘globals’
[09:31:29.358]   - Field: ‘stdout’
[09:31:29.358]   - Field: ‘earlySignal’
[09:31:29.358]   - Field: ‘lazy’
[09:31:29.358]   - Field: ‘state’
[09:31:29.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.359] - Launch lazy future ...
[09:31:29.359] Packages needed by the future expression (n = 0): <none>
[09:31:29.359] Packages needed by future strategies (n = 0): <none>
[09:31:29.360] {
[09:31:29.360]     {
[09:31:29.360]         {
[09:31:29.360]             ...future.startTime <- base::Sys.time()
[09:31:29.360]             {
[09:31:29.360]                 {
[09:31:29.360]                   {
[09:31:29.360]                     {
[09:31:29.360]                       base::local({
[09:31:29.360]                         has_future <- base::requireNamespace("future", 
[09:31:29.360]                           quietly = TRUE)
[09:31:29.360]                         if (has_future) {
[09:31:29.360]                           ns <- base::getNamespace("future")
[09:31:29.360]                           version <- ns[[".package"]][["version"]]
[09:31:29.360]                           if (is.null(version)) 
[09:31:29.360]                             version <- utils::packageVersion("future")
[09:31:29.360]                         }
[09:31:29.360]                         else {
[09:31:29.360]                           version <- NULL
[09:31:29.360]                         }
[09:31:29.360]                         if (!has_future || version < "1.8.0") {
[09:31:29.360]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.360]                             "", base::R.version$version.string), 
[09:31:29.360]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.360]                               "release", "version")], collapse = " "), 
[09:31:29.360]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.360]                             info)
[09:31:29.360]                           info <- base::paste(info, collapse = "; ")
[09:31:29.360]                           if (!has_future) {
[09:31:29.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.360]                               info)
[09:31:29.360]                           }
[09:31:29.360]                           else {
[09:31:29.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.360]                               info, version)
[09:31:29.360]                           }
[09:31:29.360]                           base::stop(msg)
[09:31:29.360]                         }
[09:31:29.360]                       })
[09:31:29.360]                     }
[09:31:29.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.360]                     base::options(mc.cores = 1L)
[09:31:29.360]                   }
[09:31:29.360]                   ...future.strategy.old <- future::plan("list")
[09:31:29.360]                   options(future.plan = NULL)
[09:31:29.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.360]                 }
[09:31:29.360]                 ...future.workdir <- getwd()
[09:31:29.360]             }
[09:31:29.360]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.360]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.360]         }
[09:31:29.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.360]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.360]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.360]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.360]             base::names(...future.oldOptions))
[09:31:29.360]     }
[09:31:29.360]     if (FALSE) {
[09:31:29.360]     }
[09:31:29.360]     else {
[09:31:29.360]         if (TRUE) {
[09:31:29.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.360]                 open = "w")
[09:31:29.360]         }
[09:31:29.360]         else {
[09:31:29.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.360]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.360]         }
[09:31:29.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.360]             base::sink(type = "output", split = FALSE)
[09:31:29.360]             base::close(...future.stdout)
[09:31:29.360]         }, add = TRUE)
[09:31:29.360]     }
[09:31:29.360]     ...future.frame <- base::sys.nframe()
[09:31:29.360]     ...future.conditions <- base::list()
[09:31:29.360]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.360]     if (FALSE) {
[09:31:29.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.360]     }
[09:31:29.360]     ...future.result <- base::tryCatch({
[09:31:29.360]         base::withCallingHandlers({
[09:31:29.360]             ...future.value <- base::withVisible(base::local({
[09:31:29.360]                 withCallingHandlers({
[09:31:29.360]                   {
[09:31:29.360]                     x["a"] <- list(1)
[09:31:29.360]                     x
[09:31:29.360]                   }
[09:31:29.360]                 }, immediateCondition = function(cond) {
[09:31:29.360]                   save_rds <- function (object, pathname, ...) 
[09:31:29.360]                   {
[09:31:29.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.360]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.360]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.360]                         fi_tmp[["mtime"]])
[09:31:29.360]                     }
[09:31:29.360]                     tryCatch({
[09:31:29.360]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.360]                     }, error = function(ex) {
[09:31:29.360]                       msg <- conditionMessage(ex)
[09:31:29.360]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.360]                         fi_tmp[["mtime"]], msg)
[09:31:29.360]                       ex$message <- msg
[09:31:29.360]                       stop(ex)
[09:31:29.360]                     })
[09:31:29.360]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.360]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.360]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.360]                       fi <- file.info(pathname)
[09:31:29.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.360]                         fi[["size"]], fi[["mtime"]])
[09:31:29.360]                       stop(msg)
[09:31:29.360]                     }
[09:31:29.360]                     invisible(pathname)
[09:31:29.360]                   }
[09:31:29.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.360]                     rootPath = tempdir()) 
[09:31:29.360]                   {
[09:31:29.360]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.360]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.360]                       tmpdir = path, fileext = ".rds")
[09:31:29.360]                     save_rds(obj, file)
[09:31:29.360]                   }
[09:31:29.360]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.360]                   {
[09:31:29.360]                     inherits <- base::inherits
[09:31:29.360]                     invokeRestart <- base::invokeRestart
[09:31:29.360]                     is.null <- base::is.null
[09:31:29.360]                     muffled <- FALSE
[09:31:29.360]                     if (inherits(cond, "message")) {
[09:31:29.360]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.360]                       if (muffled) 
[09:31:29.360]                         invokeRestart("muffleMessage")
[09:31:29.360]                     }
[09:31:29.360]                     else if (inherits(cond, "warning")) {
[09:31:29.360]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.360]                       if (muffled) 
[09:31:29.360]                         invokeRestart("muffleWarning")
[09:31:29.360]                     }
[09:31:29.360]                     else if (inherits(cond, "condition")) {
[09:31:29.360]                       if (!is.null(pattern)) {
[09:31:29.360]                         computeRestarts <- base::computeRestarts
[09:31:29.360]                         grepl <- base::grepl
[09:31:29.360]                         restarts <- computeRestarts(cond)
[09:31:29.360]                         for (restart in restarts) {
[09:31:29.360]                           name <- restart$name
[09:31:29.360]                           if (is.null(name)) 
[09:31:29.360]                             next
[09:31:29.360]                           if (!grepl(pattern, name)) 
[09:31:29.360]                             next
[09:31:29.360]                           invokeRestart(restart)
[09:31:29.360]                           muffled <- TRUE
[09:31:29.360]                           break
[09:31:29.360]                         }
[09:31:29.360]                       }
[09:31:29.360]                     }
[09:31:29.360]                     invisible(muffled)
[09:31:29.360]                   }
[09:31:29.360]                   muffleCondition(cond)
[09:31:29.360]                 })
[09:31:29.360]             }))
[09:31:29.360]             future::FutureResult(value = ...future.value$value, 
[09:31:29.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.360]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.360]                     ...future.globalenv.names))
[09:31:29.360]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.360]         }, condition = base::local({
[09:31:29.360]             c <- base::c
[09:31:29.360]             inherits <- base::inherits
[09:31:29.360]             invokeRestart <- base::invokeRestart
[09:31:29.360]             length <- base::length
[09:31:29.360]             list <- base::list
[09:31:29.360]             seq.int <- base::seq.int
[09:31:29.360]             signalCondition <- base::signalCondition
[09:31:29.360]             sys.calls <- base::sys.calls
[09:31:29.360]             `[[` <- base::`[[`
[09:31:29.360]             `+` <- base::`+`
[09:31:29.360]             `<<-` <- base::`<<-`
[09:31:29.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.360]                   3L)]
[09:31:29.360]             }
[09:31:29.360]             function(cond) {
[09:31:29.360]                 is_error <- inherits(cond, "error")
[09:31:29.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.360]                   NULL)
[09:31:29.360]                 if (is_error) {
[09:31:29.360]                   sessionInformation <- function() {
[09:31:29.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.360]                       search = base::search(), system = base::Sys.info())
[09:31:29.360]                   }
[09:31:29.360]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.360]                     cond$call), session = sessionInformation(), 
[09:31:29.360]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.360]                   signalCondition(cond)
[09:31:29.360]                 }
[09:31:29.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.360]                 "immediateCondition"))) {
[09:31:29.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.360]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.360]                   if (TRUE && !signal) {
[09:31:29.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.360]                     {
[09:31:29.360]                       inherits <- base::inherits
[09:31:29.360]                       invokeRestart <- base::invokeRestart
[09:31:29.360]                       is.null <- base::is.null
[09:31:29.360]                       muffled <- FALSE
[09:31:29.360]                       if (inherits(cond, "message")) {
[09:31:29.360]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.360]                         if (muffled) 
[09:31:29.360]                           invokeRestart("muffleMessage")
[09:31:29.360]                       }
[09:31:29.360]                       else if (inherits(cond, "warning")) {
[09:31:29.360]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.360]                         if (muffled) 
[09:31:29.360]                           invokeRestart("muffleWarning")
[09:31:29.360]                       }
[09:31:29.360]                       else if (inherits(cond, "condition")) {
[09:31:29.360]                         if (!is.null(pattern)) {
[09:31:29.360]                           computeRestarts <- base::computeRestarts
[09:31:29.360]                           grepl <- base::grepl
[09:31:29.360]                           restarts <- computeRestarts(cond)
[09:31:29.360]                           for (restart in restarts) {
[09:31:29.360]                             name <- restart$name
[09:31:29.360]                             if (is.null(name)) 
[09:31:29.360]                               next
[09:31:29.360]                             if (!grepl(pattern, name)) 
[09:31:29.360]                               next
[09:31:29.360]                             invokeRestart(restart)
[09:31:29.360]                             muffled <- TRUE
[09:31:29.360]                             break
[09:31:29.360]                           }
[09:31:29.360]                         }
[09:31:29.360]                       }
[09:31:29.360]                       invisible(muffled)
[09:31:29.360]                     }
[09:31:29.360]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.360]                   }
[09:31:29.360]                 }
[09:31:29.360]                 else {
[09:31:29.360]                   if (TRUE) {
[09:31:29.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.360]                     {
[09:31:29.360]                       inherits <- base::inherits
[09:31:29.360]                       invokeRestart <- base::invokeRestart
[09:31:29.360]                       is.null <- base::is.null
[09:31:29.360]                       muffled <- FALSE
[09:31:29.360]                       if (inherits(cond, "message")) {
[09:31:29.360]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.360]                         if (muffled) 
[09:31:29.360]                           invokeRestart("muffleMessage")
[09:31:29.360]                       }
[09:31:29.360]                       else if (inherits(cond, "warning")) {
[09:31:29.360]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.360]                         if (muffled) 
[09:31:29.360]                           invokeRestart("muffleWarning")
[09:31:29.360]                       }
[09:31:29.360]                       else if (inherits(cond, "condition")) {
[09:31:29.360]                         if (!is.null(pattern)) {
[09:31:29.360]                           computeRestarts <- base::computeRestarts
[09:31:29.360]                           grepl <- base::grepl
[09:31:29.360]                           restarts <- computeRestarts(cond)
[09:31:29.360]                           for (restart in restarts) {
[09:31:29.360]                             name <- restart$name
[09:31:29.360]                             if (is.null(name)) 
[09:31:29.360]                               next
[09:31:29.360]                             if (!grepl(pattern, name)) 
[09:31:29.360]                               next
[09:31:29.360]                             invokeRestart(restart)
[09:31:29.360]                             muffled <- TRUE
[09:31:29.360]                             break
[09:31:29.360]                           }
[09:31:29.360]                         }
[09:31:29.360]                       }
[09:31:29.360]                       invisible(muffled)
[09:31:29.360]                     }
[09:31:29.360]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.360]                   }
[09:31:29.360]                 }
[09:31:29.360]             }
[09:31:29.360]         }))
[09:31:29.360]     }, error = function(ex) {
[09:31:29.360]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.360]                 ...future.rng), started = ...future.startTime, 
[09:31:29.360]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.360]             version = "1.8"), class = "FutureResult")
[09:31:29.360]     }, finally = {
[09:31:29.360]         if (!identical(...future.workdir, getwd())) 
[09:31:29.360]             setwd(...future.workdir)
[09:31:29.360]         {
[09:31:29.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.360]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.360]             }
[09:31:29.360]             base::options(...future.oldOptions)
[09:31:29.360]             if (.Platform$OS.type == "windows") {
[09:31:29.360]                 old_names <- names(...future.oldEnvVars)
[09:31:29.360]                 envs <- base::Sys.getenv()
[09:31:29.360]                 names <- names(envs)
[09:31:29.360]                 common <- intersect(names, old_names)
[09:31:29.360]                 added <- setdiff(names, old_names)
[09:31:29.360]                 removed <- setdiff(old_names, names)
[09:31:29.360]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.360]                   envs[common]]
[09:31:29.360]                 NAMES <- toupper(changed)
[09:31:29.360]                 args <- list()
[09:31:29.360]                 for (kk in seq_along(NAMES)) {
[09:31:29.360]                   name <- changed[[kk]]
[09:31:29.360]                   NAME <- NAMES[[kk]]
[09:31:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.360]                     next
[09:31:29.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.360]                 }
[09:31:29.360]                 NAMES <- toupper(added)
[09:31:29.360]                 for (kk in seq_along(NAMES)) {
[09:31:29.360]                   name <- added[[kk]]
[09:31:29.360]                   NAME <- NAMES[[kk]]
[09:31:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.360]                     next
[09:31:29.360]                   args[[name]] <- ""
[09:31:29.360]                 }
[09:31:29.360]                 NAMES <- toupper(removed)
[09:31:29.360]                 for (kk in seq_along(NAMES)) {
[09:31:29.360]                   name <- removed[[kk]]
[09:31:29.360]                   NAME <- NAMES[[kk]]
[09:31:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.360]                     next
[09:31:29.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.360]                 }
[09:31:29.360]                 if (length(args) > 0) 
[09:31:29.360]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.360]             }
[09:31:29.360]             else {
[09:31:29.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.360]             }
[09:31:29.360]             {
[09:31:29.360]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.360]                   0L) {
[09:31:29.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.360]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.360]                   base::options(opts)
[09:31:29.360]                 }
[09:31:29.360]                 {
[09:31:29.360]                   {
[09:31:29.360]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.360]                     NULL
[09:31:29.360]                   }
[09:31:29.360]                   options(future.plan = NULL)
[09:31:29.360]                   if (is.na(NA_character_)) 
[09:31:29.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.360]                     .init = FALSE)
[09:31:29.360]                 }
[09:31:29.360]             }
[09:31:29.360]         }
[09:31:29.360]     })
[09:31:29.360]     if (TRUE) {
[09:31:29.360]         base::sink(type = "output", split = FALSE)
[09:31:29.360]         if (TRUE) {
[09:31:29.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.360]         }
[09:31:29.360]         else {
[09:31:29.360]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.360]         }
[09:31:29.360]         base::close(...future.stdout)
[09:31:29.360]         ...future.stdout <- NULL
[09:31:29.360]     }
[09:31:29.360]     ...future.result$conditions <- ...future.conditions
[09:31:29.360]     ...future.result$finished <- base::Sys.time()
[09:31:29.360]     ...future.result
[09:31:29.360] }
[09:31:29.362] assign_globals() ...
[09:31:29.362] List of 1
[09:31:29.362]  $ x: list()
[09:31:29.362]  - attr(*, "where")=List of 1
[09:31:29.362]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.362]  - attr(*, "resolved")= logi TRUE
[09:31:29.362]  - attr(*, "total_size")= num 0
[09:31:29.362]  - attr(*, "already-done")= logi TRUE
[09:31:29.365] - copied ‘x’ to environment
[09:31:29.365] assign_globals() ... done
[09:31:29.365] requestCore(): workers = 2
[09:31:29.367] MulticoreFuture started
[09:31:29.367] - Launch lazy future ... done
[09:31:29.367] run() for ‘MulticoreFuture’ ... done
[09:31:29.367] result() for MulticoreFuture ...
[09:31:29.368] plan(): Setting new future strategy stack:
[09:31:29.368] List of future strategies:
[09:31:29.368] 1. sequential:
[09:31:29.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.368]    - tweaked: FALSE
[09:31:29.368]    - call: NULL
[09:31:29.369] plan(): nbrOfWorkers() = 1
[09:31:29.371] plan(): Setting new future strategy stack:
[09:31:29.371] List of future strategies:
[09:31:29.371] 1. multicore:
[09:31:29.371]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.371]    - tweaked: FALSE
[09:31:29.371]    - call: plan(strategy)
[09:31:29.376] plan(): nbrOfWorkers() = 2
[09:31:29.377] result() for MulticoreFuture ...
[09:31:29.377] result() for MulticoreFuture ... done
[09:31:29.377] result() for MulticoreFuture ... done
[09:31:29.377] result() for MulticoreFuture ...
[09:31:29.377] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.378] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.379] Searching for globals...
[09:31:29.381] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.381] Searching for globals ... DONE
[09:31:29.382] Resolving globals: TRUE
[09:31:29.382] Resolving any globals that are futures ...
[09:31:29.382] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:29.382] Resolving any globals that are futures ... DONE
[09:31:29.382] Resolving futures part of globals (recursively) ...
[09:31:29.383] resolve() on list ...
[09:31:29.383]  recursive: 99
[09:31:29.383]  length: 1
[09:31:29.383]  elements: ‘x’
[09:31:29.383]  length: 0 (resolved future 1)
[09:31:29.383] resolve() on list ... DONE
[09:31:29.383] - globals: [1] ‘x’
[09:31:29.384] Resolving futures part of globals (recursively) ... DONE
[09:31:29.384] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:29.384] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:29.384] - globals: [1] ‘x’
[09:31:29.384] 
[09:31:29.385] getGlobalsAndPackages() ... DONE
[09:31:29.385] run() for ‘Future’ ...
[09:31:29.385] - state: ‘created’
[09:31:29.385] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.389]   - Field: ‘label’
[09:31:29.389]   - Field: ‘local’
[09:31:29.390]   - Field: ‘owner’
[09:31:29.390]   - Field: ‘envir’
[09:31:29.390]   - Field: ‘workers’
[09:31:29.390]   - Field: ‘packages’
[09:31:29.390]   - Field: ‘gc’
[09:31:29.390]   - Field: ‘job’
[09:31:29.390]   - Field: ‘conditions’
[09:31:29.390]   - Field: ‘expr’
[09:31:29.390]   - Field: ‘uuid’
[09:31:29.391]   - Field: ‘seed’
[09:31:29.391]   - Field: ‘version’
[09:31:29.391]   - Field: ‘result’
[09:31:29.391]   - Field: ‘asynchronous’
[09:31:29.391]   - Field: ‘calls’
[09:31:29.391]   - Field: ‘globals’
[09:31:29.391]   - Field: ‘stdout’
[09:31:29.391]   - Field: ‘earlySignal’
[09:31:29.391]   - Field: ‘lazy’
[09:31:29.391]   - Field: ‘state’
[09:31:29.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.392] - Launch lazy future ...
[09:31:29.392] Packages needed by the future expression (n = 0): <none>
[09:31:29.392] Packages needed by future strategies (n = 0): <none>
[09:31:29.393] {
[09:31:29.393]     {
[09:31:29.393]         {
[09:31:29.393]             ...future.startTime <- base::Sys.time()
[09:31:29.393]             {
[09:31:29.393]                 {
[09:31:29.393]                   {
[09:31:29.393]                     {
[09:31:29.393]                       base::local({
[09:31:29.393]                         has_future <- base::requireNamespace("future", 
[09:31:29.393]                           quietly = TRUE)
[09:31:29.393]                         if (has_future) {
[09:31:29.393]                           ns <- base::getNamespace("future")
[09:31:29.393]                           version <- ns[[".package"]][["version"]]
[09:31:29.393]                           if (is.null(version)) 
[09:31:29.393]                             version <- utils::packageVersion("future")
[09:31:29.393]                         }
[09:31:29.393]                         else {
[09:31:29.393]                           version <- NULL
[09:31:29.393]                         }
[09:31:29.393]                         if (!has_future || version < "1.8.0") {
[09:31:29.393]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.393]                             "", base::R.version$version.string), 
[09:31:29.393]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.393]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.393]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.393]                               "release", "version")], collapse = " "), 
[09:31:29.393]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.393]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.393]                             info)
[09:31:29.393]                           info <- base::paste(info, collapse = "; ")
[09:31:29.393]                           if (!has_future) {
[09:31:29.393]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.393]                               info)
[09:31:29.393]                           }
[09:31:29.393]                           else {
[09:31:29.393]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.393]                               info, version)
[09:31:29.393]                           }
[09:31:29.393]                           base::stop(msg)
[09:31:29.393]                         }
[09:31:29.393]                       })
[09:31:29.393]                     }
[09:31:29.393]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.393]                     base::options(mc.cores = 1L)
[09:31:29.393]                   }
[09:31:29.393]                   ...future.strategy.old <- future::plan("list")
[09:31:29.393]                   options(future.plan = NULL)
[09:31:29.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.393]                 }
[09:31:29.393]                 ...future.workdir <- getwd()
[09:31:29.393]             }
[09:31:29.393]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.393]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.393]         }
[09:31:29.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.393]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.393]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.393]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.393]             base::names(...future.oldOptions))
[09:31:29.393]     }
[09:31:29.393]     if (FALSE) {
[09:31:29.393]     }
[09:31:29.393]     else {
[09:31:29.393]         if (TRUE) {
[09:31:29.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.393]                 open = "w")
[09:31:29.393]         }
[09:31:29.393]         else {
[09:31:29.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.393]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.393]         }
[09:31:29.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.393]             base::sink(type = "output", split = FALSE)
[09:31:29.393]             base::close(...future.stdout)
[09:31:29.393]         }, add = TRUE)
[09:31:29.393]     }
[09:31:29.393]     ...future.frame <- base::sys.nframe()
[09:31:29.393]     ...future.conditions <- base::list()
[09:31:29.393]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.393]     if (FALSE) {
[09:31:29.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.393]     }
[09:31:29.393]     ...future.result <- base::tryCatch({
[09:31:29.393]         base::withCallingHandlers({
[09:31:29.393]             ...future.value <- base::withVisible(base::local({
[09:31:29.393]                 withCallingHandlers({
[09:31:29.393]                   {
[09:31:29.393]                     x["a"] <- list(1)
[09:31:29.393]                     x
[09:31:29.393]                   }
[09:31:29.393]                 }, immediateCondition = function(cond) {
[09:31:29.393]                   save_rds <- function (object, pathname, ...) 
[09:31:29.393]                   {
[09:31:29.393]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.393]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.393]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.393]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.393]                         fi_tmp[["mtime"]])
[09:31:29.393]                     }
[09:31:29.393]                     tryCatch({
[09:31:29.393]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.393]                     }, error = function(ex) {
[09:31:29.393]                       msg <- conditionMessage(ex)
[09:31:29.393]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.393]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.393]                         fi_tmp[["mtime"]], msg)
[09:31:29.393]                       ex$message <- msg
[09:31:29.393]                       stop(ex)
[09:31:29.393]                     })
[09:31:29.393]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.393]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.393]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.393]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.393]                       fi <- file.info(pathname)
[09:31:29.393]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.393]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.393]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.393]                         fi[["size"]], fi[["mtime"]])
[09:31:29.393]                       stop(msg)
[09:31:29.393]                     }
[09:31:29.393]                     invisible(pathname)
[09:31:29.393]                   }
[09:31:29.393]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.393]                     rootPath = tempdir()) 
[09:31:29.393]                   {
[09:31:29.393]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.393]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.393]                       tmpdir = path, fileext = ".rds")
[09:31:29.393]                     save_rds(obj, file)
[09:31:29.393]                   }
[09:31:29.393]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.393]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.393]                   {
[09:31:29.393]                     inherits <- base::inherits
[09:31:29.393]                     invokeRestart <- base::invokeRestart
[09:31:29.393]                     is.null <- base::is.null
[09:31:29.393]                     muffled <- FALSE
[09:31:29.393]                     if (inherits(cond, "message")) {
[09:31:29.393]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.393]                       if (muffled) 
[09:31:29.393]                         invokeRestart("muffleMessage")
[09:31:29.393]                     }
[09:31:29.393]                     else if (inherits(cond, "warning")) {
[09:31:29.393]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.393]                       if (muffled) 
[09:31:29.393]                         invokeRestart("muffleWarning")
[09:31:29.393]                     }
[09:31:29.393]                     else if (inherits(cond, "condition")) {
[09:31:29.393]                       if (!is.null(pattern)) {
[09:31:29.393]                         computeRestarts <- base::computeRestarts
[09:31:29.393]                         grepl <- base::grepl
[09:31:29.393]                         restarts <- computeRestarts(cond)
[09:31:29.393]                         for (restart in restarts) {
[09:31:29.393]                           name <- restart$name
[09:31:29.393]                           if (is.null(name)) 
[09:31:29.393]                             next
[09:31:29.393]                           if (!grepl(pattern, name)) 
[09:31:29.393]                             next
[09:31:29.393]                           invokeRestart(restart)
[09:31:29.393]                           muffled <- TRUE
[09:31:29.393]                           break
[09:31:29.393]                         }
[09:31:29.393]                       }
[09:31:29.393]                     }
[09:31:29.393]                     invisible(muffled)
[09:31:29.393]                   }
[09:31:29.393]                   muffleCondition(cond)
[09:31:29.393]                 })
[09:31:29.393]             }))
[09:31:29.393]             future::FutureResult(value = ...future.value$value, 
[09:31:29.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.393]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.393]                     ...future.globalenv.names))
[09:31:29.393]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.393]         }, condition = base::local({
[09:31:29.393]             c <- base::c
[09:31:29.393]             inherits <- base::inherits
[09:31:29.393]             invokeRestart <- base::invokeRestart
[09:31:29.393]             length <- base::length
[09:31:29.393]             list <- base::list
[09:31:29.393]             seq.int <- base::seq.int
[09:31:29.393]             signalCondition <- base::signalCondition
[09:31:29.393]             sys.calls <- base::sys.calls
[09:31:29.393]             `[[` <- base::`[[`
[09:31:29.393]             `+` <- base::`+`
[09:31:29.393]             `<<-` <- base::`<<-`
[09:31:29.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.393]                   3L)]
[09:31:29.393]             }
[09:31:29.393]             function(cond) {
[09:31:29.393]                 is_error <- inherits(cond, "error")
[09:31:29.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.393]                   NULL)
[09:31:29.393]                 if (is_error) {
[09:31:29.393]                   sessionInformation <- function() {
[09:31:29.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.393]                       search = base::search(), system = base::Sys.info())
[09:31:29.393]                   }
[09:31:29.393]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.393]                     cond$call), session = sessionInformation(), 
[09:31:29.393]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.393]                   signalCondition(cond)
[09:31:29.393]                 }
[09:31:29.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.393]                 "immediateCondition"))) {
[09:31:29.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.393]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.393]                   if (TRUE && !signal) {
[09:31:29.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.393]                     {
[09:31:29.393]                       inherits <- base::inherits
[09:31:29.393]                       invokeRestart <- base::invokeRestart
[09:31:29.393]                       is.null <- base::is.null
[09:31:29.393]                       muffled <- FALSE
[09:31:29.393]                       if (inherits(cond, "message")) {
[09:31:29.393]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.393]                         if (muffled) 
[09:31:29.393]                           invokeRestart("muffleMessage")
[09:31:29.393]                       }
[09:31:29.393]                       else if (inherits(cond, "warning")) {
[09:31:29.393]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.393]                         if (muffled) 
[09:31:29.393]                           invokeRestart("muffleWarning")
[09:31:29.393]                       }
[09:31:29.393]                       else if (inherits(cond, "condition")) {
[09:31:29.393]                         if (!is.null(pattern)) {
[09:31:29.393]                           computeRestarts <- base::computeRestarts
[09:31:29.393]                           grepl <- base::grepl
[09:31:29.393]                           restarts <- computeRestarts(cond)
[09:31:29.393]                           for (restart in restarts) {
[09:31:29.393]                             name <- restart$name
[09:31:29.393]                             if (is.null(name)) 
[09:31:29.393]                               next
[09:31:29.393]                             if (!grepl(pattern, name)) 
[09:31:29.393]                               next
[09:31:29.393]                             invokeRestart(restart)
[09:31:29.393]                             muffled <- TRUE
[09:31:29.393]                             break
[09:31:29.393]                           }
[09:31:29.393]                         }
[09:31:29.393]                       }
[09:31:29.393]                       invisible(muffled)
[09:31:29.393]                     }
[09:31:29.393]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.393]                   }
[09:31:29.393]                 }
[09:31:29.393]                 else {
[09:31:29.393]                   if (TRUE) {
[09:31:29.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.393]                     {
[09:31:29.393]                       inherits <- base::inherits
[09:31:29.393]                       invokeRestart <- base::invokeRestart
[09:31:29.393]                       is.null <- base::is.null
[09:31:29.393]                       muffled <- FALSE
[09:31:29.393]                       if (inherits(cond, "message")) {
[09:31:29.393]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.393]                         if (muffled) 
[09:31:29.393]                           invokeRestart("muffleMessage")
[09:31:29.393]                       }
[09:31:29.393]                       else if (inherits(cond, "warning")) {
[09:31:29.393]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.393]                         if (muffled) 
[09:31:29.393]                           invokeRestart("muffleWarning")
[09:31:29.393]                       }
[09:31:29.393]                       else if (inherits(cond, "condition")) {
[09:31:29.393]                         if (!is.null(pattern)) {
[09:31:29.393]                           computeRestarts <- base::computeRestarts
[09:31:29.393]                           grepl <- base::grepl
[09:31:29.393]                           restarts <- computeRestarts(cond)
[09:31:29.393]                           for (restart in restarts) {
[09:31:29.393]                             name <- restart$name
[09:31:29.393]                             if (is.null(name)) 
[09:31:29.393]                               next
[09:31:29.393]                             if (!grepl(pattern, name)) 
[09:31:29.393]                               next
[09:31:29.393]                             invokeRestart(restart)
[09:31:29.393]                             muffled <- TRUE
[09:31:29.393]                             break
[09:31:29.393]                           }
[09:31:29.393]                         }
[09:31:29.393]                       }
[09:31:29.393]                       invisible(muffled)
[09:31:29.393]                     }
[09:31:29.393]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.393]                   }
[09:31:29.393]                 }
[09:31:29.393]             }
[09:31:29.393]         }))
[09:31:29.393]     }, error = function(ex) {
[09:31:29.393]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.393]                 ...future.rng), started = ...future.startTime, 
[09:31:29.393]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.393]             version = "1.8"), class = "FutureResult")
[09:31:29.393]     }, finally = {
[09:31:29.393]         if (!identical(...future.workdir, getwd())) 
[09:31:29.393]             setwd(...future.workdir)
[09:31:29.393]         {
[09:31:29.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.393]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.393]             }
[09:31:29.393]             base::options(...future.oldOptions)
[09:31:29.393]             if (.Platform$OS.type == "windows") {
[09:31:29.393]                 old_names <- names(...future.oldEnvVars)
[09:31:29.393]                 envs <- base::Sys.getenv()
[09:31:29.393]                 names <- names(envs)
[09:31:29.393]                 common <- intersect(names, old_names)
[09:31:29.393]                 added <- setdiff(names, old_names)
[09:31:29.393]                 removed <- setdiff(old_names, names)
[09:31:29.393]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.393]                   envs[common]]
[09:31:29.393]                 NAMES <- toupper(changed)
[09:31:29.393]                 args <- list()
[09:31:29.393]                 for (kk in seq_along(NAMES)) {
[09:31:29.393]                   name <- changed[[kk]]
[09:31:29.393]                   NAME <- NAMES[[kk]]
[09:31:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.393]                     next
[09:31:29.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.393]                 }
[09:31:29.393]                 NAMES <- toupper(added)
[09:31:29.393]                 for (kk in seq_along(NAMES)) {
[09:31:29.393]                   name <- added[[kk]]
[09:31:29.393]                   NAME <- NAMES[[kk]]
[09:31:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.393]                     next
[09:31:29.393]                   args[[name]] <- ""
[09:31:29.393]                 }
[09:31:29.393]                 NAMES <- toupper(removed)
[09:31:29.393]                 for (kk in seq_along(NAMES)) {
[09:31:29.393]                   name <- removed[[kk]]
[09:31:29.393]                   NAME <- NAMES[[kk]]
[09:31:29.393]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.393]                     next
[09:31:29.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.393]                 }
[09:31:29.393]                 if (length(args) > 0) 
[09:31:29.393]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.393]             }
[09:31:29.393]             else {
[09:31:29.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.393]             }
[09:31:29.393]             {
[09:31:29.393]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.393]                   0L) {
[09:31:29.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.393]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.393]                   base::options(opts)
[09:31:29.393]                 }
[09:31:29.393]                 {
[09:31:29.393]                   {
[09:31:29.393]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.393]                     NULL
[09:31:29.393]                   }
[09:31:29.393]                   options(future.plan = NULL)
[09:31:29.393]                   if (is.na(NA_character_)) 
[09:31:29.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.393]                     .init = FALSE)
[09:31:29.393]                 }
[09:31:29.393]             }
[09:31:29.393]         }
[09:31:29.393]     })
[09:31:29.393]     if (TRUE) {
[09:31:29.393]         base::sink(type = "output", split = FALSE)
[09:31:29.393]         if (TRUE) {
[09:31:29.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.393]         }
[09:31:29.393]         else {
[09:31:29.393]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.393]         }
[09:31:29.393]         base::close(...future.stdout)
[09:31:29.393]         ...future.stdout <- NULL
[09:31:29.393]     }
[09:31:29.393]     ...future.result$conditions <- ...future.conditions
[09:31:29.393]     ...future.result$finished <- base::Sys.time()
[09:31:29.393]     ...future.result
[09:31:29.393] }
[09:31:29.395] assign_globals() ...
[09:31:29.397] List of 1
[09:31:29.397]  $ x: list()
[09:31:29.397]  - attr(*, "where")=List of 1
[09:31:29.397]   ..$ x:<environment: R_EmptyEnv> 
[09:31:29.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.397]  - attr(*, "resolved")= logi TRUE
[09:31:29.397]  - attr(*, "total_size")= num 0
[09:31:29.397]  - attr(*, "already-done")= logi TRUE
[09:31:29.401] - copied ‘x’ to environment
[09:31:29.401] assign_globals() ... done
[09:31:29.401] requestCore(): workers = 2
[09:31:29.403] MulticoreFuture started
[09:31:29.403] - Launch lazy future ... done
[09:31:29.403] run() for ‘MulticoreFuture’ ... done
[09:31:29.404] result() for MulticoreFuture ...
[09:31:29.404] plan(): Setting new future strategy stack:
[09:31:29.404] List of future strategies:
[09:31:29.404] 1. sequential:
[09:31:29.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.404]    - tweaked: FALSE
[09:31:29.404]    - call: NULL
[09:31:29.405] plan(): nbrOfWorkers() = 1
[09:31:29.407] plan(): Setting new future strategy stack:
[09:31:29.407] List of future strategies:
[09:31:29.407] 1. multicore:
[09:31:29.407]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.407]    - tweaked: FALSE
[09:31:29.407]    - call: plan(strategy)
[09:31:29.412] plan(): nbrOfWorkers() = 2
[09:31:29.413] result() for MulticoreFuture ...
[09:31:29.413] result() for MulticoreFuture ... done
[09:31:29.413] result() for MulticoreFuture ... done
[09:31:29.413] result() for MulticoreFuture ...
[09:31:29.413] result() for MulticoreFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.414] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.415] Searching for globals...
[09:31:29.418] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:29.418] Searching for globals ... DONE
[09:31:29.418] Resolving globals: TRUE
[09:31:29.418] Resolving any globals that are futures ...
[09:31:29.418] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:29.418] Resolving any globals that are futures ... DONE
[09:31:29.419] Resolving futures part of globals (recursively) ...
[09:31:29.419] resolve() on list ...
[09:31:29.419]  recursive: 99
[09:31:29.419]  length: 2
[09:31:29.419]  elements: ‘x’, ‘name’
[09:31:29.420]  length: 1 (resolved future 1)
[09:31:29.420]  length: 0 (resolved future 2)
[09:31:29.420] resolve() on list ... DONE
[09:31:29.420] - globals: [2] ‘x’, ‘name’
[09:31:29.420] Resolving futures part of globals (recursively) ... DONE
[09:31:29.420] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:29.421] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[09:31:29.421] - globals: [2] ‘x’, ‘name’
[09:31:29.421] 
[09:31:29.421] getGlobalsAndPackages() ... DONE
[09:31:29.421] run() for ‘Future’ ...
[09:31:29.422] - state: ‘created’
[09:31:29.422] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:29.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:29.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:29.426]   - Field: ‘label’
[09:31:29.426]   - Field: ‘local’
[09:31:29.426]   - Field: ‘owner’
[09:31:29.426]   - Field: ‘envir’
[09:31:29.426]   - Field: ‘workers’
[09:31:29.427]   - Field: ‘packages’
[09:31:29.427]   - Field: ‘gc’
[09:31:29.427]   - Field: ‘job’
[09:31:29.427]   - Field: ‘conditions’
[09:31:29.427]   - Field: ‘expr’
[09:31:29.427]   - Field: ‘uuid’
[09:31:29.427]   - Field: ‘seed’
[09:31:29.427]   - Field: ‘version’
[09:31:29.427]   - Field: ‘result’
[09:31:29.427]   - Field: ‘asynchronous’
[09:31:29.428]   - Field: ‘calls’
[09:31:29.428]   - Field: ‘globals’
[09:31:29.428]   - Field: ‘stdout’
[09:31:29.428]   - Field: ‘earlySignal’
[09:31:29.428]   - Field: ‘lazy’
[09:31:29.428]   - Field: ‘state’
[09:31:29.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:29.428] - Launch lazy future ...
[09:31:29.429] Packages needed by the future expression (n = 0): <none>
[09:31:29.429] Packages needed by future strategies (n = 0): <none>
[09:31:29.429] {
[09:31:29.429]     {
[09:31:29.429]         {
[09:31:29.429]             ...future.startTime <- base::Sys.time()
[09:31:29.429]             {
[09:31:29.429]                 {
[09:31:29.429]                   {
[09:31:29.429]                     {
[09:31:29.429]                       base::local({
[09:31:29.429]                         has_future <- base::requireNamespace("future", 
[09:31:29.429]                           quietly = TRUE)
[09:31:29.429]                         if (has_future) {
[09:31:29.429]                           ns <- base::getNamespace("future")
[09:31:29.429]                           version <- ns[[".package"]][["version"]]
[09:31:29.429]                           if (is.null(version)) 
[09:31:29.429]                             version <- utils::packageVersion("future")
[09:31:29.429]                         }
[09:31:29.429]                         else {
[09:31:29.429]                           version <- NULL
[09:31:29.429]                         }
[09:31:29.429]                         if (!has_future || version < "1.8.0") {
[09:31:29.429]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.429]                             "", base::R.version$version.string), 
[09:31:29.429]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.429]                               "release", "version")], collapse = " "), 
[09:31:29.429]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.429]                             info)
[09:31:29.429]                           info <- base::paste(info, collapse = "; ")
[09:31:29.429]                           if (!has_future) {
[09:31:29.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.429]                               info)
[09:31:29.429]                           }
[09:31:29.429]                           else {
[09:31:29.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.429]                               info, version)
[09:31:29.429]                           }
[09:31:29.429]                           base::stop(msg)
[09:31:29.429]                         }
[09:31:29.429]                       })
[09:31:29.429]                     }
[09:31:29.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.429]                     base::options(mc.cores = 1L)
[09:31:29.429]                   }
[09:31:29.429]                   ...future.strategy.old <- future::plan("list")
[09:31:29.429]                   options(future.plan = NULL)
[09:31:29.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.429]                 }
[09:31:29.429]                 ...future.workdir <- getwd()
[09:31:29.429]             }
[09:31:29.429]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.429]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.429]         }
[09:31:29.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.429]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.429]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.429]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.429]             base::names(...future.oldOptions))
[09:31:29.429]     }
[09:31:29.429]     if (FALSE) {
[09:31:29.429]     }
[09:31:29.429]     else {
[09:31:29.429]         if (TRUE) {
[09:31:29.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.429]                 open = "w")
[09:31:29.429]         }
[09:31:29.429]         else {
[09:31:29.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.429]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.429]         }
[09:31:29.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.429]             base::sink(type = "output", split = FALSE)
[09:31:29.429]             base::close(...future.stdout)
[09:31:29.429]         }, add = TRUE)
[09:31:29.429]     }
[09:31:29.429]     ...future.frame <- base::sys.nframe()
[09:31:29.429]     ...future.conditions <- base::list()
[09:31:29.429]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.429]     if (FALSE) {
[09:31:29.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.429]     }
[09:31:29.429]     ...future.result <- base::tryCatch({
[09:31:29.429]         base::withCallingHandlers({
[09:31:29.429]             ...future.value <- base::withVisible(base::local({
[09:31:29.429]                 withCallingHandlers({
[09:31:29.429]                   {
[09:31:29.429]                     x[name] <- list(1)
[09:31:29.429]                     x
[09:31:29.429]                   }
[09:31:29.429]                 }, immediateCondition = function(cond) {
[09:31:29.429]                   save_rds <- function (object, pathname, ...) 
[09:31:29.429]                   {
[09:31:29.429]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:29.429]                     if (file_test("-f", pathname_tmp)) {
[09:31:29.429]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.429]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:29.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.429]                         fi_tmp[["mtime"]])
[09:31:29.429]                     }
[09:31:29.429]                     tryCatch({
[09:31:29.429]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:29.429]                     }, error = function(ex) {
[09:31:29.429]                       msg <- conditionMessage(ex)
[09:31:29.429]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.429]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:29.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.429]                         fi_tmp[["mtime"]], msg)
[09:31:29.429]                       ex$message <- msg
[09:31:29.429]                       stop(ex)
[09:31:29.429]                     })
[09:31:29.429]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:29.429]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:29.429]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:29.429]                       fi_tmp <- file.info(pathname_tmp)
[09:31:29.429]                       fi <- file.info(pathname)
[09:31:29.429]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:29.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:29.429]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:29.429]                         fi[["size"]], fi[["mtime"]])
[09:31:29.429]                       stop(msg)
[09:31:29.429]                     }
[09:31:29.429]                     invisible(pathname)
[09:31:29.429]                   }
[09:31:29.429]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:29.429]                     rootPath = tempdir()) 
[09:31:29.429]                   {
[09:31:29.429]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:29.429]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:29.429]                       tmpdir = path, fileext = ".rds")
[09:31:29.429]                     save_rds(obj, file)
[09:31:29.429]                   }
[09:31:29.429]                   saveImmediateCondition(cond, path = "/tmp/RtmpCoZ46w/.future/immediateConditions")
[09:31:29.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.429]                   {
[09:31:29.429]                     inherits <- base::inherits
[09:31:29.429]                     invokeRestart <- base::invokeRestart
[09:31:29.429]                     is.null <- base::is.null
[09:31:29.429]                     muffled <- FALSE
[09:31:29.429]                     if (inherits(cond, "message")) {
[09:31:29.429]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.429]                       if (muffled) 
[09:31:29.429]                         invokeRestart("muffleMessage")
[09:31:29.429]                     }
[09:31:29.429]                     else if (inherits(cond, "warning")) {
[09:31:29.429]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.429]                       if (muffled) 
[09:31:29.429]                         invokeRestart("muffleWarning")
[09:31:29.429]                     }
[09:31:29.429]                     else if (inherits(cond, "condition")) {
[09:31:29.429]                       if (!is.null(pattern)) {
[09:31:29.429]                         computeRestarts <- base::computeRestarts
[09:31:29.429]                         grepl <- base::grepl
[09:31:29.429]                         restarts <- computeRestarts(cond)
[09:31:29.429]                         for (restart in restarts) {
[09:31:29.429]                           name <- restart$name
[09:31:29.429]                           if (is.null(name)) 
[09:31:29.429]                             next
[09:31:29.429]                           if (!grepl(pattern, name)) 
[09:31:29.429]                             next
[09:31:29.429]                           invokeRestart(restart)
[09:31:29.429]                           muffled <- TRUE
[09:31:29.429]                           break
[09:31:29.429]                         }
[09:31:29.429]                       }
[09:31:29.429]                     }
[09:31:29.429]                     invisible(muffled)
[09:31:29.429]                   }
[09:31:29.429]                   muffleCondition(cond)
[09:31:29.429]                 })
[09:31:29.429]             }))
[09:31:29.429]             future::FutureResult(value = ...future.value$value, 
[09:31:29.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.429]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.429]                     ...future.globalenv.names))
[09:31:29.429]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.429]         }, condition = base::local({
[09:31:29.429]             c <- base::c
[09:31:29.429]             inherits <- base::inherits
[09:31:29.429]             invokeRestart <- base::invokeRestart
[09:31:29.429]             length <- base::length
[09:31:29.429]             list <- base::list
[09:31:29.429]             seq.int <- base::seq.int
[09:31:29.429]             signalCondition <- base::signalCondition
[09:31:29.429]             sys.calls <- base::sys.calls
[09:31:29.429]             `[[` <- base::`[[`
[09:31:29.429]             `+` <- base::`+`
[09:31:29.429]             `<<-` <- base::`<<-`
[09:31:29.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.429]                   3L)]
[09:31:29.429]             }
[09:31:29.429]             function(cond) {
[09:31:29.429]                 is_error <- inherits(cond, "error")
[09:31:29.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.429]                   NULL)
[09:31:29.429]                 if (is_error) {
[09:31:29.429]                   sessionInformation <- function() {
[09:31:29.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.429]                       search = base::search(), system = base::Sys.info())
[09:31:29.429]                   }
[09:31:29.429]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.429]                     cond$call), session = sessionInformation(), 
[09:31:29.429]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.429]                   signalCondition(cond)
[09:31:29.429]                 }
[09:31:29.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.429]                 "immediateCondition"))) {
[09:31:29.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.429]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.429]                   if (TRUE && !signal) {
[09:31:29.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.429]                     {
[09:31:29.429]                       inherits <- base::inherits
[09:31:29.429]                       invokeRestart <- base::invokeRestart
[09:31:29.429]                       is.null <- base::is.null
[09:31:29.429]                       muffled <- FALSE
[09:31:29.429]                       if (inherits(cond, "message")) {
[09:31:29.429]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.429]                         if (muffled) 
[09:31:29.429]                           invokeRestart("muffleMessage")
[09:31:29.429]                       }
[09:31:29.429]                       else if (inherits(cond, "warning")) {
[09:31:29.429]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.429]                         if (muffled) 
[09:31:29.429]                           invokeRestart("muffleWarning")
[09:31:29.429]                       }
[09:31:29.429]                       else if (inherits(cond, "condition")) {
[09:31:29.429]                         if (!is.null(pattern)) {
[09:31:29.429]                           computeRestarts <- base::computeRestarts
[09:31:29.429]                           grepl <- base::grepl
[09:31:29.429]                           restarts <- computeRestarts(cond)
[09:31:29.429]                           for (restart in restarts) {
[09:31:29.429]                             name <- restart$name
[09:31:29.429]                             if (is.null(name)) 
[09:31:29.429]                               next
[09:31:29.429]                             if (!grepl(pattern, name)) 
[09:31:29.429]                               next
[09:31:29.429]                             invokeRestart(restart)
[09:31:29.429]                             muffled <- TRUE
[09:31:29.429]                             break
[09:31:29.429]                           }
[09:31:29.429]                         }
[09:31:29.429]                       }
[09:31:29.429]                       invisible(muffled)
[09:31:29.429]                     }
[09:31:29.429]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.429]                   }
[09:31:29.429]                 }
[09:31:29.429]                 else {
[09:31:29.429]                   if (TRUE) {
[09:31:29.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.429]                     {
[09:31:29.429]                       inherits <- base::inherits
[09:31:29.429]                       invokeRestart <- base::invokeRestart
[09:31:29.429]                       is.null <- base::is.null
[09:31:29.429]                       muffled <- FALSE
[09:31:29.429]                       if (inherits(cond, "message")) {
[09:31:29.429]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.429]                         if (muffled) 
[09:31:29.429]                           invokeRestart("muffleMessage")
[09:31:29.429]                       }
[09:31:29.429]                       else if (inherits(cond, "warning")) {
[09:31:29.429]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.429]                         if (muffled) 
[09:31:29.429]                           invokeRestart("muffleWarning")
[09:31:29.429]                       }
[09:31:29.429]                       else if (inherits(cond, "condition")) {
[09:31:29.429]                         if (!is.null(pattern)) {
[09:31:29.429]                           computeRestarts <- base::computeRestarts
[09:31:29.429]                           grepl <- base::grepl
[09:31:29.429]                           restarts <- computeRestarts(cond)
[09:31:29.429]                           for (restart in restarts) {
[09:31:29.429]                             name <- restart$name
[09:31:29.429]                             if (is.null(name)) 
[09:31:29.429]                               next
[09:31:29.429]                             if (!grepl(pattern, name)) 
[09:31:29.429]                               next
[09:31:29.429]                             invokeRestart(restart)
[09:31:29.429]                             muffled <- TRUE
[09:31:29.429]                             break
[09:31:29.429]                           }
[09:31:29.429]                         }
[09:31:29.429]                       }
[09:31:29.429]                       invisible(muffled)
[09:31:29.429]                     }
[09:31:29.429]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.429]                   }
[09:31:29.429]                 }
[09:31:29.429]             }
[09:31:29.429]         }))
[09:31:29.429]     }, error = function(ex) {
[09:31:29.429]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.429]                 ...future.rng), started = ...future.startTime, 
[09:31:29.429]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.429]             version = "1.8"), class = "FutureResult")
[09:31:29.429]     }, finally = {
[09:31:29.429]         if (!identical(...future.workdir, getwd())) 
[09:31:29.429]             setwd(...future.workdir)
[09:31:29.429]         {
[09:31:29.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.429]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.429]             }
[09:31:29.429]             base::options(...future.oldOptions)
[09:31:29.429]             if (.Platform$OS.type == "windows") {
[09:31:29.429]                 old_names <- names(...future.oldEnvVars)
[09:31:29.429]                 envs <- base::Sys.getenv()
[09:31:29.429]                 names <- names(envs)
[09:31:29.429]                 common <- intersect(names, old_names)
[09:31:29.429]                 added <- setdiff(names, old_names)
[09:31:29.429]                 removed <- setdiff(old_names, names)
[09:31:29.429]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.429]                   envs[common]]
[09:31:29.429]                 NAMES <- toupper(changed)
[09:31:29.429]                 args <- list()
[09:31:29.429]                 for (kk in seq_along(NAMES)) {
[09:31:29.429]                   name <- changed[[kk]]
[09:31:29.429]                   NAME <- NAMES[[kk]]
[09:31:29.429]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.429]                     next
[09:31:29.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.429]                 }
[09:31:29.429]                 NAMES <- toupper(added)
[09:31:29.429]                 for (kk in seq_along(NAMES)) {
[09:31:29.429]                   name <- added[[kk]]
[09:31:29.429]                   NAME <- NAMES[[kk]]
[09:31:29.429]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.429]                     next
[09:31:29.429]                   args[[name]] <- ""
[09:31:29.429]                 }
[09:31:29.429]                 NAMES <- toupper(removed)
[09:31:29.429]                 for (kk in seq_along(NAMES)) {
[09:31:29.429]                   name <- removed[[kk]]
[09:31:29.429]                   NAME <- NAMES[[kk]]
[09:31:29.429]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.429]                     next
[09:31:29.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.429]                 }
[09:31:29.429]                 if (length(args) > 0) 
[09:31:29.429]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.429]             }
[09:31:29.429]             else {
[09:31:29.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.429]             }
[09:31:29.429]             {
[09:31:29.429]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.429]                   0L) {
[09:31:29.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.429]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.429]                   base::options(opts)
[09:31:29.429]                 }
[09:31:29.429]                 {
[09:31:29.429]                   {
[09:31:29.429]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.429]                     NULL
[09:31:29.429]                   }
[09:31:29.429]                   options(future.plan = NULL)
[09:31:29.429]                   if (is.na(NA_character_)) 
[09:31:29.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.429]                     .init = FALSE)
[09:31:29.429]                 }
[09:31:29.429]             }
[09:31:29.429]         }
[09:31:29.429]     })
[09:31:29.429]     if (TRUE) {
[09:31:29.429]         base::sink(type = "output", split = FALSE)
[09:31:29.429]         if (TRUE) {
[09:31:29.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.429]         }
[09:31:29.429]         else {
[09:31:29.429]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.429]         }
[09:31:29.429]         base::close(...future.stdout)
[09:31:29.429]         ...future.stdout <- NULL
[09:31:29.429]     }
[09:31:29.429]     ...future.result$conditions <- ...future.conditions
[09:31:29.429]     ...future.result$finished <- base::Sys.time()
[09:31:29.429]     ...future.result
[09:31:29.429] }
[09:31:29.432] assign_globals() ...
[09:31:29.432] List of 2
[09:31:29.432]  $ x   : list()
[09:31:29.432]  $ name: chr "a"
[09:31:29.432]  - attr(*, "where")=List of 2
[09:31:29.432]   ..$ x   :<environment: R_EmptyEnv> 
[09:31:29.432]   ..$ name:<environment: R_EmptyEnv> 
[09:31:29.432]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:29.432]  - attr(*, "resolved")= logi TRUE
[09:31:29.432]  - attr(*, "total_size")= num 112
[09:31:29.432]  - attr(*, "already-done")= logi TRUE
[09:31:29.435] - copied ‘x’ to environment
[09:31:29.435] - copied ‘name’ to environment
[09:31:29.435] assign_globals() ... done
[09:31:29.436] requestCore(): workers = 2
[09:31:29.437] MulticoreFuture started
[09:31:29.438] - Launch lazy future ... done
[09:31:29.438] run() for ‘MulticoreFuture’ ... done
[09:31:29.438] result() for MulticoreFuture ...
[09:31:29.438] plan(): Setting new future strategy stack:
[09:31:29.438] List of future strategies:
[09:31:29.438] 1. sequential:
[09:31:29.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:29.438]    - tweaked: FALSE
[09:31:29.438]    - call: NULL
[09:31:29.439] plan(): nbrOfWorkers() = 1
[09:31:29.441] plan(): Setting new future strategy stack:
[09:31:29.441] List of future strategies:
[09:31:29.441] 1. multicore:
[09:31:29.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:29.441]    - tweaked: FALSE
[09:31:29.441]    - call: plan(strategy)
[09:31:29.446] plan(): nbrOfWorkers() = 2
[09:31:29.447] result() for MulticoreFuture ...
[09:31:29.447] result() for MulticoreFuture ... done
[09:31:29.448] result() for MulticoreFuture ... done
[09:31:29.448] result() for MulticoreFuture ...
[09:31:29.448] result() for MulticoreFuture ... done
$a
[1] 1

- plan('multisession') ...
[09:31:29.449] plan(): Setting new future strategy stack:
[09:31:29.449] List of future strategies:
[09:31:29.449] 1. multisession:
[09:31:29.449]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:29.449]    - tweaked: FALSE
[09:31:29.449]    - call: plan(strategy)
[09:31:29.450] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:29.450] multisession:
[09:31:29.450] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:29.450] - tweaked: FALSE
[09:31:29.450] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:29.459] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:29.459] Not searching for globals
[09:31:29.459] - globals: [0] <none>
[09:31:29.460] getGlobalsAndPackages() ... DONE
[09:31:29.460] [local output] makeClusterPSOCK() ...
[09:31:29.503] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:29.504] [local output] Base port: 11274
[09:31:29.504] [local output] Getting setup options for 2 cluster nodes ...
[09:31:29.504] [local output]  - Node 1 of 2 ...
[09:31:29.505] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:29.505] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpCoZ46w/worker.rank=1.parallelly.parent=44173.ac8d1f5e94d3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpCoZ46w/worker.rank=1.parallelly.parent=44173.ac8d1f5e94d3.pid")'’
[09:31:29.690] - Possible to infer worker's PID: TRUE
[09:31:29.691] [local output] Rscript port: 11274

[09:31:29.691] [local output]  - Node 2 of 2 ...
[09:31:29.691] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:29.692] [local output] Rscript port: 11274

[09:31:29.692] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:29.692] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:29.693] [local output] Setting up PSOCK nodes in parallel
[09:31:29.693] List of 36
[09:31:29.693]  $ worker          : chr "localhost"
[09:31:29.693]   ..- attr(*, "localhost")= logi TRUE
[09:31:29.693]  $ master          : chr "localhost"
[09:31:29.693]  $ port            : int 11274
[09:31:29.693]  $ connectTimeout  : num 120
[09:31:29.693]  $ timeout         : num 2592000
[09:31:29.693]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:29.693]  $ homogeneous     : logi TRUE
[09:31:29.693]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:29.693]  $ rscript_envs    : NULL
[09:31:29.693]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:29.693]  $ rscript_startup : NULL
[09:31:29.693]  $ rscript_sh      : chr "sh"
[09:31:29.693]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:29.693]  $ methods         : logi TRUE
[09:31:29.693]  $ socketOptions   : chr "no-delay"
[09:31:29.693]  $ useXDR          : logi FALSE
[09:31:29.693]  $ outfile         : chr "/dev/null"
[09:31:29.693]  $ renice          : int NA
[09:31:29.693]  $ rshcmd          : NULL
[09:31:29.693]  $ user            : chr(0) 
[09:31:29.693]  $ revtunnel       : logi FALSE
[09:31:29.693]  $ rshlogfile      : NULL
[09:31:29.693]  $ rshopts         : chr(0) 
[09:31:29.693]  $ rank            : int 1
[09:31:29.693]  $ manual          : logi FALSE
[09:31:29.693]  $ dryrun          : logi FALSE
[09:31:29.693]  $ quiet           : logi FALSE
[09:31:29.693]  $ setup_strategy  : chr "parallel"
[09:31:29.693]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:29.693]  $ pidfile         : chr "/tmp/RtmpCoZ46w/worker.rank=1.parallelly.parent=44173.ac8d1f5e94d3.pid"
[09:31:29.693]  $ rshcmd_label    : NULL
[09:31:29.693]  $ rsh_call        : NULL
[09:31:29.693]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:29.693]  $ localMachine    : logi TRUE
[09:31:29.693]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:29.693]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:29.693]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:29.693]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:29.693]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:29.693]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:29.693]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:29.693]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:29.693]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:29.693]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:29.693]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:29.693]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:29.693]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:29.693]  $ arguments       :List of 28
[09:31:29.693]   ..$ worker          : chr "localhost"
[09:31:29.693]   ..$ master          : NULL
[09:31:29.693]   ..$ port            : int 11274
[09:31:29.693]   ..$ connectTimeout  : num 120
[09:31:29.693]   ..$ timeout         : num 2592000
[09:31:29.693]   ..$ rscript         : NULL
[09:31:29.693]   ..$ homogeneous     : NULL
[09:31:29.693]   ..$ rscript_args    : NULL
[09:31:29.693]   ..$ rscript_envs    : NULL
[09:31:29.693]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:29.693]   ..$ rscript_startup : NULL
[09:31:29.693]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:29.693]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:29.693]   ..$ methods         : logi TRUE
[09:31:29.693]   ..$ socketOptions   : chr "no-delay"
[09:31:29.693]   ..$ useXDR          : logi FALSE
[09:31:29.693]   ..$ outfile         : chr "/dev/null"
[09:31:29.693]   ..$ renice          : int NA
[09:31:29.693]   ..$ rshcmd          : NULL
[09:31:29.693]   ..$ user            : NULL
[09:31:29.693]   ..$ revtunnel       : logi NA
[09:31:29.693]   ..$ rshlogfile      : NULL
[09:31:29.693]   ..$ rshopts         : NULL
[09:31:29.693]   ..$ rank            : int 1
[09:31:29.693]   ..$ manual          : logi FALSE
[09:31:29.693]   ..$ dryrun          : logi FALSE
[09:31:29.693]   ..$ quiet           : logi FALSE
[09:31:29.693]   ..$ setup_strategy  : chr "parallel"
[09:31:29.693]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:29.709] [local output] System call to launch all workers:
[09:31:29.709] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpCoZ46w/worker.rank=1.parallelly.parent=44173.ac8d1f5e94d3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11274 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:29.709] [local output] Starting PSOCK main server
[09:31:29.715] [local output] Workers launched
[09:31:29.715] [local output] Waiting for workers to connect back
[09:31:29.715]  - [local output] 0 workers out of 2 ready
[09:31:29.956]  - [local output] 0 workers out of 2 ready
[09:31:29.956]  - [local output] 1 workers out of 2 ready
[09:31:29.957]  - [local output] 1 workers out of 2 ready
[09:31:29.958]  - [local output] 2 workers out of 2 ready
[09:31:29.958] [local output] Launching of workers completed
[09:31:29.958] [local output] Collecting session information from workers
[09:31:29.959] [local output]  - Worker #1 of 2
[09:31:29.959] [local output]  - Worker #2 of 2
[09:31:29.959] [local output] makeClusterPSOCK() ... done
[09:31:29.972] Packages needed by the future expression (n = 0): <none>
[09:31:29.972] Packages needed by future strategies (n = 0): <none>
[09:31:29.973] {
[09:31:29.973]     {
[09:31:29.973]         {
[09:31:29.973]             ...future.startTime <- base::Sys.time()
[09:31:29.973]             {
[09:31:29.973]                 {
[09:31:29.973]                   {
[09:31:29.973]                     {
[09:31:29.973]                       base::local({
[09:31:29.973]                         has_future <- base::requireNamespace("future", 
[09:31:29.973]                           quietly = TRUE)
[09:31:29.973]                         if (has_future) {
[09:31:29.973]                           ns <- base::getNamespace("future")
[09:31:29.973]                           version <- ns[[".package"]][["version"]]
[09:31:29.973]                           if (is.null(version)) 
[09:31:29.973]                             version <- utils::packageVersion("future")
[09:31:29.973]                         }
[09:31:29.973]                         else {
[09:31:29.973]                           version <- NULL
[09:31:29.973]                         }
[09:31:29.973]                         if (!has_future || version < "1.8.0") {
[09:31:29.973]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:29.973]                             "", base::R.version$version.string), 
[09:31:29.973]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:29.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:29.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:29.973]                               "release", "version")], collapse = " "), 
[09:31:29.973]                             hostname = base::Sys.info()[["nodename"]])
[09:31:29.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:29.973]                             info)
[09:31:29.973]                           info <- base::paste(info, collapse = "; ")
[09:31:29.973]                           if (!has_future) {
[09:31:29.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:29.973]                               info)
[09:31:29.973]                           }
[09:31:29.973]                           else {
[09:31:29.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:29.973]                               info, version)
[09:31:29.973]                           }
[09:31:29.973]                           base::stop(msg)
[09:31:29.973]                         }
[09:31:29.973]                       })
[09:31:29.973]                     }
[09:31:29.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:29.973]                     base::options(mc.cores = 1L)
[09:31:29.973]                   }
[09:31:29.973]                   ...future.strategy.old <- future::plan("list")
[09:31:29.973]                   options(future.plan = NULL)
[09:31:29.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:29.973]                 }
[09:31:29.973]                 ...future.workdir <- getwd()
[09:31:29.973]             }
[09:31:29.973]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:29.973]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:29.973]         }
[09:31:29.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:29.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:29.973]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:29.973]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:29.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:29.973]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:29.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:29.973]             base::names(...future.oldOptions))
[09:31:29.973]     }
[09:31:29.973]     if (FALSE) {
[09:31:29.973]     }
[09:31:29.973]     else {
[09:31:29.973]         if (TRUE) {
[09:31:29.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:29.973]                 open = "w")
[09:31:29.973]         }
[09:31:29.973]         else {
[09:31:29.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:29.973]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:29.973]         }
[09:31:29.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:29.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:29.973]             base::sink(type = "output", split = FALSE)
[09:31:29.973]             base::close(...future.stdout)
[09:31:29.973]         }, add = TRUE)
[09:31:29.973]     }
[09:31:29.973]     ...future.frame <- base::sys.nframe()
[09:31:29.973]     ...future.conditions <- base::list()
[09:31:29.973]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:29.973]     if (FALSE) {
[09:31:29.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:29.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:29.973]     }
[09:31:29.973]     ...future.result <- base::tryCatch({
[09:31:29.973]         base::withCallingHandlers({
[09:31:29.973]             ...future.value <- base::withVisible(base::local({
[09:31:29.973]                 ...future.makeSendCondition <- base::local({
[09:31:29.973]                   sendCondition <- NULL
[09:31:29.973]                   function(frame = 1L) {
[09:31:29.973]                     if (is.function(sendCondition)) 
[09:31:29.973]                       return(sendCondition)
[09:31:29.973]                     ns <- getNamespace("parallel")
[09:31:29.973]                     if (exists("sendData", mode = "function", 
[09:31:29.973]                       envir = ns)) {
[09:31:29.973]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:29.973]                         envir = ns)
[09:31:29.973]                       envir <- sys.frame(frame)
[09:31:29.973]                       master <- NULL
[09:31:29.973]                       while (!identical(envir, .GlobalEnv) && 
[09:31:29.973]                         !identical(envir, emptyenv())) {
[09:31:29.973]                         if (exists("master", mode = "list", envir = envir, 
[09:31:29.973]                           inherits = FALSE)) {
[09:31:29.973]                           master <- get("master", mode = "list", 
[09:31:29.973]                             envir = envir, inherits = FALSE)
[09:31:29.973]                           if (inherits(master, c("SOCKnode", 
[09:31:29.973]                             "SOCK0node"))) {
[09:31:29.973]                             sendCondition <<- function(cond) {
[09:31:29.973]                               data <- list(type = "VALUE", value = cond, 
[09:31:29.973]                                 success = TRUE)
[09:31:29.973]                               parallel_sendData(master, data)
[09:31:29.973]                             }
[09:31:29.973]                             return(sendCondition)
[09:31:29.973]                           }
[09:31:29.973]                         }
[09:31:29.973]                         frame <- frame + 1L
[09:31:29.973]                         envir <- sys.frame(frame)
[09:31:29.973]                       }
[09:31:29.973]                     }
[09:31:29.973]                     sendCondition <<- function(cond) NULL
[09:31:29.973]                   }
[09:31:29.973]                 })
[09:31:29.973]                 withCallingHandlers({
[09:31:29.973]                   NA
[09:31:29.973]                 }, immediateCondition = function(cond) {
[09:31:29.973]                   sendCondition <- ...future.makeSendCondition()
[09:31:29.973]                   sendCondition(cond)
[09:31:29.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.973]                   {
[09:31:29.973]                     inherits <- base::inherits
[09:31:29.973]                     invokeRestart <- base::invokeRestart
[09:31:29.973]                     is.null <- base::is.null
[09:31:29.973]                     muffled <- FALSE
[09:31:29.973]                     if (inherits(cond, "message")) {
[09:31:29.973]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:29.973]                       if (muffled) 
[09:31:29.973]                         invokeRestart("muffleMessage")
[09:31:29.973]                     }
[09:31:29.973]                     else if (inherits(cond, "warning")) {
[09:31:29.973]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:29.973]                       if (muffled) 
[09:31:29.973]                         invokeRestart("muffleWarning")
[09:31:29.973]                     }
[09:31:29.973]                     else if (inherits(cond, "condition")) {
[09:31:29.973]                       if (!is.null(pattern)) {
[09:31:29.973]                         computeRestarts <- base::computeRestarts
[09:31:29.973]                         grepl <- base::grepl
[09:31:29.973]                         restarts <- computeRestarts(cond)
[09:31:29.973]                         for (restart in restarts) {
[09:31:29.973]                           name <- restart$name
[09:31:29.973]                           if (is.null(name)) 
[09:31:29.973]                             next
[09:31:29.973]                           if (!grepl(pattern, name)) 
[09:31:29.973]                             next
[09:31:29.973]                           invokeRestart(restart)
[09:31:29.973]                           muffled <- TRUE
[09:31:29.973]                           break
[09:31:29.973]                         }
[09:31:29.973]                       }
[09:31:29.973]                     }
[09:31:29.973]                     invisible(muffled)
[09:31:29.973]                   }
[09:31:29.973]                   muffleCondition(cond)
[09:31:29.973]                 })
[09:31:29.973]             }))
[09:31:29.973]             future::FutureResult(value = ...future.value$value, 
[09:31:29.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.973]                   ...future.rng), globalenv = if (FALSE) 
[09:31:29.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:29.973]                     ...future.globalenv.names))
[09:31:29.973]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:29.973]         }, condition = base::local({
[09:31:29.973]             c <- base::c
[09:31:29.973]             inherits <- base::inherits
[09:31:29.973]             invokeRestart <- base::invokeRestart
[09:31:29.973]             length <- base::length
[09:31:29.973]             list <- base::list
[09:31:29.973]             seq.int <- base::seq.int
[09:31:29.973]             signalCondition <- base::signalCondition
[09:31:29.973]             sys.calls <- base::sys.calls
[09:31:29.973]             `[[` <- base::`[[`
[09:31:29.973]             `+` <- base::`+`
[09:31:29.973]             `<<-` <- base::`<<-`
[09:31:29.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:29.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:29.973]                   3L)]
[09:31:29.973]             }
[09:31:29.973]             function(cond) {
[09:31:29.973]                 is_error <- inherits(cond, "error")
[09:31:29.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:29.973]                   NULL)
[09:31:29.973]                 if (is_error) {
[09:31:29.973]                   sessionInformation <- function() {
[09:31:29.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:29.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:29.973]                       search = base::search(), system = base::Sys.info())
[09:31:29.973]                   }
[09:31:29.973]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:29.973]                     cond$call), session = sessionInformation(), 
[09:31:29.973]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:29.973]                   signalCondition(cond)
[09:31:29.973]                 }
[09:31:29.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:29.973]                 "immediateCondition"))) {
[09:31:29.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:29.973]                   ...future.conditions[[length(...future.conditions) + 
[09:31:29.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:29.973]                   if (TRUE && !signal) {
[09:31:29.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.973]                     {
[09:31:29.973]                       inherits <- base::inherits
[09:31:29.973]                       invokeRestart <- base::invokeRestart
[09:31:29.973]                       is.null <- base::is.null
[09:31:29.973]                       muffled <- FALSE
[09:31:29.973]                       if (inherits(cond, "message")) {
[09:31:29.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.973]                         if (muffled) 
[09:31:29.973]                           invokeRestart("muffleMessage")
[09:31:29.973]                       }
[09:31:29.973]                       else if (inherits(cond, "warning")) {
[09:31:29.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.973]                         if (muffled) 
[09:31:29.973]                           invokeRestart("muffleWarning")
[09:31:29.973]                       }
[09:31:29.973]                       else if (inherits(cond, "condition")) {
[09:31:29.973]                         if (!is.null(pattern)) {
[09:31:29.973]                           computeRestarts <- base::computeRestarts
[09:31:29.973]                           grepl <- base::grepl
[09:31:29.973]                           restarts <- computeRestarts(cond)
[09:31:29.973]                           for (restart in restarts) {
[09:31:29.973]                             name <- restart$name
[09:31:29.973]                             if (is.null(name)) 
[09:31:29.973]                               next
[09:31:29.973]                             if (!grepl(pattern, name)) 
[09:31:29.973]                               next
[09:31:29.973]                             invokeRestart(restart)
[09:31:29.973]                             muffled <- TRUE
[09:31:29.973]                             break
[09:31:29.973]                           }
[09:31:29.973]                         }
[09:31:29.973]                       }
[09:31:29.973]                       invisible(muffled)
[09:31:29.973]                     }
[09:31:29.973]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.973]                   }
[09:31:29.973]                 }
[09:31:29.973]                 else {
[09:31:29.973]                   if (TRUE) {
[09:31:29.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:29.973]                     {
[09:31:29.973]                       inherits <- base::inherits
[09:31:29.973]                       invokeRestart <- base::invokeRestart
[09:31:29.973]                       is.null <- base::is.null
[09:31:29.973]                       muffled <- FALSE
[09:31:29.973]                       if (inherits(cond, "message")) {
[09:31:29.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:29.973]                         if (muffled) 
[09:31:29.973]                           invokeRestart("muffleMessage")
[09:31:29.973]                       }
[09:31:29.973]                       else if (inherits(cond, "warning")) {
[09:31:29.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:29.973]                         if (muffled) 
[09:31:29.973]                           invokeRestart("muffleWarning")
[09:31:29.973]                       }
[09:31:29.973]                       else if (inherits(cond, "condition")) {
[09:31:29.973]                         if (!is.null(pattern)) {
[09:31:29.973]                           computeRestarts <- base::computeRestarts
[09:31:29.973]                           grepl <- base::grepl
[09:31:29.973]                           restarts <- computeRestarts(cond)
[09:31:29.973]                           for (restart in restarts) {
[09:31:29.973]                             name <- restart$name
[09:31:29.973]                             if (is.null(name)) 
[09:31:29.973]                               next
[09:31:29.973]                             if (!grepl(pattern, name)) 
[09:31:29.973]                               next
[09:31:29.973]                             invokeRestart(restart)
[09:31:29.973]                             muffled <- TRUE
[09:31:29.973]                             break
[09:31:29.973]                           }
[09:31:29.973]                         }
[09:31:29.973]                       }
[09:31:29.973]                       invisible(muffled)
[09:31:29.973]                     }
[09:31:29.973]                     muffleCondition(cond, pattern = "^muffle")
[09:31:29.973]                   }
[09:31:29.973]                 }
[09:31:29.973]             }
[09:31:29.973]         }))
[09:31:29.973]     }, error = function(ex) {
[09:31:29.973]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:29.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:29.973]                 ...future.rng), started = ...future.startTime, 
[09:31:29.973]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:29.973]             version = "1.8"), class = "FutureResult")
[09:31:29.973]     }, finally = {
[09:31:29.973]         if (!identical(...future.workdir, getwd())) 
[09:31:29.973]             setwd(...future.workdir)
[09:31:29.973]         {
[09:31:29.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:29.973]                 ...future.oldOptions$nwarnings <- NULL
[09:31:29.973]             }
[09:31:29.973]             base::options(...future.oldOptions)
[09:31:29.973]             if (.Platform$OS.type == "windows") {
[09:31:29.973]                 old_names <- names(...future.oldEnvVars)
[09:31:29.973]                 envs <- base::Sys.getenv()
[09:31:29.973]                 names <- names(envs)
[09:31:29.973]                 common <- intersect(names, old_names)
[09:31:29.973]                 added <- setdiff(names, old_names)
[09:31:29.973]                 removed <- setdiff(old_names, names)
[09:31:29.973]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:29.973]                   envs[common]]
[09:31:29.973]                 NAMES <- toupper(changed)
[09:31:29.973]                 args <- list()
[09:31:29.973]                 for (kk in seq_along(NAMES)) {
[09:31:29.973]                   name <- changed[[kk]]
[09:31:29.973]                   NAME <- NAMES[[kk]]
[09:31:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.973]                     next
[09:31:29.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.973]                 }
[09:31:29.973]                 NAMES <- toupper(added)
[09:31:29.973]                 for (kk in seq_along(NAMES)) {
[09:31:29.973]                   name <- added[[kk]]
[09:31:29.973]                   NAME <- NAMES[[kk]]
[09:31:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.973]                     next
[09:31:29.973]                   args[[name]] <- ""
[09:31:29.973]                 }
[09:31:29.973]                 NAMES <- toupper(removed)
[09:31:29.973]                 for (kk in seq_along(NAMES)) {
[09:31:29.973]                   name <- removed[[kk]]
[09:31:29.973]                   NAME <- NAMES[[kk]]
[09:31:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:29.973]                     next
[09:31:29.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:29.973]                 }
[09:31:29.973]                 if (length(args) > 0) 
[09:31:29.973]                   base::do.call(base::Sys.setenv, args = args)
[09:31:29.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:29.973]             }
[09:31:29.973]             else {
[09:31:29.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:29.973]             }
[09:31:29.973]             {
[09:31:29.973]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:29.973]                   0L) {
[09:31:29.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:29.973]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:29.973]                   base::options(opts)
[09:31:29.973]                 }
[09:31:29.973]                 {
[09:31:29.973]                   {
[09:31:29.973]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:29.973]                     NULL
[09:31:29.973]                   }
[09:31:29.973]                   options(future.plan = NULL)
[09:31:29.973]                   if (is.na(NA_character_)) 
[09:31:29.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:29.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:29.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:29.973]                     .init = FALSE)
[09:31:29.973]                 }
[09:31:29.973]             }
[09:31:29.973]         }
[09:31:29.973]     })
[09:31:29.973]     if (TRUE) {
[09:31:29.973]         base::sink(type = "output", split = FALSE)
[09:31:29.973]         if (TRUE) {
[09:31:29.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:29.973]         }
[09:31:29.973]         else {
[09:31:29.973]             ...future.result["stdout"] <- base::list(NULL)
[09:31:29.973]         }
[09:31:29.973]         base::close(...future.stdout)
[09:31:29.973]         ...future.stdout <- NULL
[09:31:29.973]     }
[09:31:29.973]     ...future.result$conditions <- ...future.conditions
[09:31:29.973]     ...future.result$finished <- base::Sys.time()
[09:31:29.973]     ...future.result
[09:31:29.973] }
[09:31:30.024] MultisessionFuture started
[09:31:30.024] result() for ClusterFuture ...
[09:31:30.024] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.025] - Validating connection of MultisessionFuture
[09:31:30.055] - received message: FutureResult
[09:31:30.055] - Received FutureResult
[09:31:30.056] - Erased future from FutureRegistry
[09:31:30.056] result() for ClusterFuture ...
[09:31:30.056] - result already collected: FutureResult
[09:31:30.056] result() for ClusterFuture ... done
[09:31:30.056] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.056] result() for ClusterFuture ... done
[09:31:30.056] result() for ClusterFuture ...
[09:31:30.056] - result already collected: FutureResult
[09:31:30.057] result() for ClusterFuture ... done
[09:31:30.057] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:30.061] plan(): nbrOfWorkers() = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.061] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.062] Searching for globals...
[09:31:30.064] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.064] Searching for globals ... DONE
[09:31:30.065] Resolving globals: TRUE
[09:31:30.065] Resolving any globals that are futures ...
[09:31:30.065] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.065] Resolving any globals that are futures ... DONE
[09:31:30.065] Resolving futures part of globals (recursively) ...
[09:31:30.066] resolve() on list ...
[09:31:30.066]  recursive: 99
[09:31:30.066]  length: 1
[09:31:30.066]  elements: ‘x’
[09:31:30.066]  length: 0 (resolved future 1)
[09:31:30.066] resolve() on list ... DONE
[09:31:30.066] - globals: [1] ‘x’
[09:31:30.067] Resolving futures part of globals (recursively) ... DONE
[09:31:30.067] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.067] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.067] - globals: [1] ‘x’
[09:31:30.067] 
[09:31:30.068] getGlobalsAndPackages() ... DONE
[09:31:30.068] run() for ‘Future’ ...
[09:31:30.068] - state: ‘created’
[09:31:30.068] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.082] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.082]   - Field: ‘node’
[09:31:30.083]   - Field: ‘label’
[09:31:30.083]   - Field: ‘local’
[09:31:30.083]   - Field: ‘owner’
[09:31:30.083]   - Field: ‘envir’
[09:31:30.083]   - Field: ‘workers’
[09:31:30.083]   - Field: ‘packages’
[09:31:30.083]   - Field: ‘gc’
[09:31:30.083]   - Field: ‘conditions’
[09:31:30.083]   - Field: ‘persistent’
[09:31:30.084]   - Field: ‘expr’
[09:31:30.084]   - Field: ‘uuid’
[09:31:30.084]   - Field: ‘seed’
[09:31:30.084]   - Field: ‘version’
[09:31:30.084]   - Field: ‘result’
[09:31:30.084]   - Field: ‘asynchronous’
[09:31:30.084]   - Field: ‘calls’
[09:31:30.084]   - Field: ‘globals’
[09:31:30.085]   - Field: ‘stdout’
[09:31:30.085]   - Field: ‘earlySignal’
[09:31:30.085]   - Field: ‘lazy’
[09:31:30.085]   - Field: ‘state’
[09:31:30.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.085] - Launch lazy future ...
[09:31:30.085] Packages needed by the future expression (n = 0): <none>
[09:31:30.086] Packages needed by future strategies (n = 0): <none>
[09:31:30.086] {
[09:31:30.086]     {
[09:31:30.086]         {
[09:31:30.086]             ...future.startTime <- base::Sys.time()
[09:31:30.086]             {
[09:31:30.086]                 {
[09:31:30.086]                   {
[09:31:30.086]                     {
[09:31:30.086]                       base::local({
[09:31:30.086]                         has_future <- base::requireNamespace("future", 
[09:31:30.086]                           quietly = TRUE)
[09:31:30.086]                         if (has_future) {
[09:31:30.086]                           ns <- base::getNamespace("future")
[09:31:30.086]                           version <- ns[[".package"]][["version"]]
[09:31:30.086]                           if (is.null(version)) 
[09:31:30.086]                             version <- utils::packageVersion("future")
[09:31:30.086]                         }
[09:31:30.086]                         else {
[09:31:30.086]                           version <- NULL
[09:31:30.086]                         }
[09:31:30.086]                         if (!has_future || version < "1.8.0") {
[09:31:30.086]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.086]                             "", base::R.version$version.string), 
[09:31:30.086]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.086]                               "release", "version")], collapse = " "), 
[09:31:30.086]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.086]                             info)
[09:31:30.086]                           info <- base::paste(info, collapse = "; ")
[09:31:30.086]                           if (!has_future) {
[09:31:30.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.086]                               info)
[09:31:30.086]                           }
[09:31:30.086]                           else {
[09:31:30.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.086]                               info, version)
[09:31:30.086]                           }
[09:31:30.086]                           base::stop(msg)
[09:31:30.086]                         }
[09:31:30.086]                       })
[09:31:30.086]                     }
[09:31:30.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.086]                     base::options(mc.cores = 1L)
[09:31:30.086]                   }
[09:31:30.086]                   ...future.strategy.old <- future::plan("list")
[09:31:30.086]                   options(future.plan = NULL)
[09:31:30.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.086]                 }
[09:31:30.086]                 ...future.workdir <- getwd()
[09:31:30.086]             }
[09:31:30.086]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.086]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.086]         }
[09:31:30.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.086]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.086]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.086]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.086]             base::names(...future.oldOptions))
[09:31:30.086]     }
[09:31:30.086]     if (FALSE) {
[09:31:30.086]     }
[09:31:30.086]     else {
[09:31:30.086]         if (TRUE) {
[09:31:30.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.086]                 open = "w")
[09:31:30.086]         }
[09:31:30.086]         else {
[09:31:30.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.086]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.086]         }
[09:31:30.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.086]             base::sink(type = "output", split = FALSE)
[09:31:30.086]             base::close(...future.stdout)
[09:31:30.086]         }, add = TRUE)
[09:31:30.086]     }
[09:31:30.086]     ...future.frame <- base::sys.nframe()
[09:31:30.086]     ...future.conditions <- base::list()
[09:31:30.086]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.086]     if (FALSE) {
[09:31:30.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.086]     }
[09:31:30.086]     ...future.result <- base::tryCatch({
[09:31:30.086]         base::withCallingHandlers({
[09:31:30.086]             ...future.value <- base::withVisible(base::local({
[09:31:30.086]                 ...future.makeSendCondition <- base::local({
[09:31:30.086]                   sendCondition <- NULL
[09:31:30.086]                   function(frame = 1L) {
[09:31:30.086]                     if (is.function(sendCondition)) 
[09:31:30.086]                       return(sendCondition)
[09:31:30.086]                     ns <- getNamespace("parallel")
[09:31:30.086]                     if (exists("sendData", mode = "function", 
[09:31:30.086]                       envir = ns)) {
[09:31:30.086]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.086]                         envir = ns)
[09:31:30.086]                       envir <- sys.frame(frame)
[09:31:30.086]                       master <- NULL
[09:31:30.086]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.086]                         !identical(envir, emptyenv())) {
[09:31:30.086]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.086]                           inherits = FALSE)) {
[09:31:30.086]                           master <- get("master", mode = "list", 
[09:31:30.086]                             envir = envir, inherits = FALSE)
[09:31:30.086]                           if (inherits(master, c("SOCKnode", 
[09:31:30.086]                             "SOCK0node"))) {
[09:31:30.086]                             sendCondition <<- function(cond) {
[09:31:30.086]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.086]                                 success = TRUE)
[09:31:30.086]                               parallel_sendData(master, data)
[09:31:30.086]                             }
[09:31:30.086]                             return(sendCondition)
[09:31:30.086]                           }
[09:31:30.086]                         }
[09:31:30.086]                         frame <- frame + 1L
[09:31:30.086]                         envir <- sys.frame(frame)
[09:31:30.086]                       }
[09:31:30.086]                     }
[09:31:30.086]                     sendCondition <<- function(cond) NULL
[09:31:30.086]                   }
[09:31:30.086]                 })
[09:31:30.086]                 withCallingHandlers({
[09:31:30.086]                   {
[09:31:30.086]                     x$a <- 1
[09:31:30.086]                     x
[09:31:30.086]                   }
[09:31:30.086]                 }, immediateCondition = function(cond) {
[09:31:30.086]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.086]                   sendCondition(cond)
[09:31:30.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.086]                   {
[09:31:30.086]                     inherits <- base::inherits
[09:31:30.086]                     invokeRestart <- base::invokeRestart
[09:31:30.086]                     is.null <- base::is.null
[09:31:30.086]                     muffled <- FALSE
[09:31:30.086]                     if (inherits(cond, "message")) {
[09:31:30.086]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.086]                       if (muffled) 
[09:31:30.086]                         invokeRestart("muffleMessage")
[09:31:30.086]                     }
[09:31:30.086]                     else if (inherits(cond, "warning")) {
[09:31:30.086]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.086]                       if (muffled) 
[09:31:30.086]                         invokeRestart("muffleWarning")
[09:31:30.086]                     }
[09:31:30.086]                     else if (inherits(cond, "condition")) {
[09:31:30.086]                       if (!is.null(pattern)) {
[09:31:30.086]                         computeRestarts <- base::computeRestarts
[09:31:30.086]                         grepl <- base::grepl
[09:31:30.086]                         restarts <- computeRestarts(cond)
[09:31:30.086]                         for (restart in restarts) {
[09:31:30.086]                           name <- restart$name
[09:31:30.086]                           if (is.null(name)) 
[09:31:30.086]                             next
[09:31:30.086]                           if (!grepl(pattern, name)) 
[09:31:30.086]                             next
[09:31:30.086]                           invokeRestart(restart)
[09:31:30.086]                           muffled <- TRUE
[09:31:30.086]                           break
[09:31:30.086]                         }
[09:31:30.086]                       }
[09:31:30.086]                     }
[09:31:30.086]                     invisible(muffled)
[09:31:30.086]                   }
[09:31:30.086]                   muffleCondition(cond)
[09:31:30.086]                 })
[09:31:30.086]             }))
[09:31:30.086]             future::FutureResult(value = ...future.value$value, 
[09:31:30.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.086]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.086]                     ...future.globalenv.names))
[09:31:30.086]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.086]         }, condition = base::local({
[09:31:30.086]             c <- base::c
[09:31:30.086]             inherits <- base::inherits
[09:31:30.086]             invokeRestart <- base::invokeRestart
[09:31:30.086]             length <- base::length
[09:31:30.086]             list <- base::list
[09:31:30.086]             seq.int <- base::seq.int
[09:31:30.086]             signalCondition <- base::signalCondition
[09:31:30.086]             sys.calls <- base::sys.calls
[09:31:30.086]             `[[` <- base::`[[`
[09:31:30.086]             `+` <- base::`+`
[09:31:30.086]             `<<-` <- base::`<<-`
[09:31:30.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.086]                   3L)]
[09:31:30.086]             }
[09:31:30.086]             function(cond) {
[09:31:30.086]                 is_error <- inherits(cond, "error")
[09:31:30.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.086]                   NULL)
[09:31:30.086]                 if (is_error) {
[09:31:30.086]                   sessionInformation <- function() {
[09:31:30.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.086]                       search = base::search(), system = base::Sys.info())
[09:31:30.086]                   }
[09:31:30.086]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.086]                     cond$call), session = sessionInformation(), 
[09:31:30.086]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.086]                   signalCondition(cond)
[09:31:30.086]                 }
[09:31:30.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.086]                 "immediateCondition"))) {
[09:31:30.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.086]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.086]                   if (TRUE && !signal) {
[09:31:30.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.086]                     {
[09:31:30.086]                       inherits <- base::inherits
[09:31:30.086]                       invokeRestart <- base::invokeRestart
[09:31:30.086]                       is.null <- base::is.null
[09:31:30.086]                       muffled <- FALSE
[09:31:30.086]                       if (inherits(cond, "message")) {
[09:31:30.086]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.086]                         if (muffled) 
[09:31:30.086]                           invokeRestart("muffleMessage")
[09:31:30.086]                       }
[09:31:30.086]                       else if (inherits(cond, "warning")) {
[09:31:30.086]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.086]                         if (muffled) 
[09:31:30.086]                           invokeRestart("muffleWarning")
[09:31:30.086]                       }
[09:31:30.086]                       else if (inherits(cond, "condition")) {
[09:31:30.086]                         if (!is.null(pattern)) {
[09:31:30.086]                           computeRestarts <- base::computeRestarts
[09:31:30.086]                           grepl <- base::grepl
[09:31:30.086]                           restarts <- computeRestarts(cond)
[09:31:30.086]                           for (restart in restarts) {
[09:31:30.086]                             name <- restart$name
[09:31:30.086]                             if (is.null(name)) 
[09:31:30.086]                               next
[09:31:30.086]                             if (!grepl(pattern, name)) 
[09:31:30.086]                               next
[09:31:30.086]                             invokeRestart(restart)
[09:31:30.086]                             muffled <- TRUE
[09:31:30.086]                             break
[09:31:30.086]                           }
[09:31:30.086]                         }
[09:31:30.086]                       }
[09:31:30.086]                       invisible(muffled)
[09:31:30.086]                     }
[09:31:30.086]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.086]                   }
[09:31:30.086]                 }
[09:31:30.086]                 else {
[09:31:30.086]                   if (TRUE) {
[09:31:30.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.086]                     {
[09:31:30.086]                       inherits <- base::inherits
[09:31:30.086]                       invokeRestart <- base::invokeRestart
[09:31:30.086]                       is.null <- base::is.null
[09:31:30.086]                       muffled <- FALSE
[09:31:30.086]                       if (inherits(cond, "message")) {
[09:31:30.086]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.086]                         if (muffled) 
[09:31:30.086]                           invokeRestart("muffleMessage")
[09:31:30.086]                       }
[09:31:30.086]                       else if (inherits(cond, "warning")) {
[09:31:30.086]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.086]                         if (muffled) 
[09:31:30.086]                           invokeRestart("muffleWarning")
[09:31:30.086]                       }
[09:31:30.086]                       else if (inherits(cond, "condition")) {
[09:31:30.086]                         if (!is.null(pattern)) {
[09:31:30.086]                           computeRestarts <- base::computeRestarts
[09:31:30.086]                           grepl <- base::grepl
[09:31:30.086]                           restarts <- computeRestarts(cond)
[09:31:30.086]                           for (restart in restarts) {
[09:31:30.086]                             name <- restart$name
[09:31:30.086]                             if (is.null(name)) 
[09:31:30.086]                               next
[09:31:30.086]                             if (!grepl(pattern, name)) 
[09:31:30.086]                               next
[09:31:30.086]                             invokeRestart(restart)
[09:31:30.086]                             muffled <- TRUE
[09:31:30.086]                             break
[09:31:30.086]                           }
[09:31:30.086]                         }
[09:31:30.086]                       }
[09:31:30.086]                       invisible(muffled)
[09:31:30.086]                     }
[09:31:30.086]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.086]                   }
[09:31:30.086]                 }
[09:31:30.086]             }
[09:31:30.086]         }))
[09:31:30.086]     }, error = function(ex) {
[09:31:30.086]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.086]                 ...future.rng), started = ...future.startTime, 
[09:31:30.086]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.086]             version = "1.8"), class = "FutureResult")
[09:31:30.086]     }, finally = {
[09:31:30.086]         if (!identical(...future.workdir, getwd())) 
[09:31:30.086]             setwd(...future.workdir)
[09:31:30.086]         {
[09:31:30.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.086]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.086]             }
[09:31:30.086]             base::options(...future.oldOptions)
[09:31:30.086]             if (.Platform$OS.type == "windows") {
[09:31:30.086]                 old_names <- names(...future.oldEnvVars)
[09:31:30.086]                 envs <- base::Sys.getenv()
[09:31:30.086]                 names <- names(envs)
[09:31:30.086]                 common <- intersect(names, old_names)
[09:31:30.086]                 added <- setdiff(names, old_names)
[09:31:30.086]                 removed <- setdiff(old_names, names)
[09:31:30.086]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.086]                   envs[common]]
[09:31:30.086]                 NAMES <- toupper(changed)
[09:31:30.086]                 args <- list()
[09:31:30.086]                 for (kk in seq_along(NAMES)) {
[09:31:30.086]                   name <- changed[[kk]]
[09:31:30.086]                   NAME <- NAMES[[kk]]
[09:31:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.086]                     next
[09:31:30.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.086]                 }
[09:31:30.086]                 NAMES <- toupper(added)
[09:31:30.086]                 for (kk in seq_along(NAMES)) {
[09:31:30.086]                   name <- added[[kk]]
[09:31:30.086]                   NAME <- NAMES[[kk]]
[09:31:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.086]                     next
[09:31:30.086]                   args[[name]] <- ""
[09:31:30.086]                 }
[09:31:30.086]                 NAMES <- toupper(removed)
[09:31:30.086]                 for (kk in seq_along(NAMES)) {
[09:31:30.086]                   name <- removed[[kk]]
[09:31:30.086]                   NAME <- NAMES[[kk]]
[09:31:30.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.086]                     next
[09:31:30.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.086]                 }
[09:31:30.086]                 if (length(args) > 0) 
[09:31:30.086]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.086]             }
[09:31:30.086]             else {
[09:31:30.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.086]             }
[09:31:30.086]             {
[09:31:30.086]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.086]                   0L) {
[09:31:30.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.086]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.086]                   base::options(opts)
[09:31:30.086]                 }
[09:31:30.086]                 {
[09:31:30.086]                   {
[09:31:30.086]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.086]                     NULL
[09:31:30.086]                   }
[09:31:30.086]                   options(future.plan = NULL)
[09:31:30.086]                   if (is.na(NA_character_)) 
[09:31:30.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.086]                     .init = FALSE)
[09:31:30.086]                 }
[09:31:30.086]             }
[09:31:30.086]         }
[09:31:30.086]     })
[09:31:30.086]     if (TRUE) {
[09:31:30.086]         base::sink(type = "output", split = FALSE)
[09:31:30.086]         if (TRUE) {
[09:31:30.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.086]         }
[09:31:30.086]         else {
[09:31:30.086]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.086]         }
[09:31:30.086]         base::close(...future.stdout)
[09:31:30.086]         ...future.stdout <- NULL
[09:31:30.086]     }
[09:31:30.086]     ...future.result$conditions <- ...future.conditions
[09:31:30.086]     ...future.result$finished <- base::Sys.time()
[09:31:30.086]     ...future.result
[09:31:30.086] }
[09:31:30.089] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.089] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.089] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.090] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.090] MultisessionFuture started
[09:31:30.090] - Launch lazy future ... done
[09:31:30.090] run() for ‘MultisessionFuture’ ... done
[09:31:30.090] result() for ClusterFuture ...
[09:31:30.091] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.091] - Validating connection of MultisessionFuture
[09:31:30.092] - received message: FutureResult
[09:31:30.092] - Received FutureResult
[09:31:30.092] - Erased future from FutureRegistry
[09:31:30.092] result() for ClusterFuture ...
[09:31:30.092] - result already collected: FutureResult
[09:31:30.092] result() for ClusterFuture ... done
[09:31:30.092] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.092] result() for ClusterFuture ... done
[09:31:30.092] result() for ClusterFuture ...
[09:31:30.093] - result already collected: FutureResult
[09:31:30.093] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.093] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.093] Searching for globals...
[09:31:30.096] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.096] Searching for globals ... DONE
[09:31:30.096] Resolving globals: TRUE
[09:31:30.096] Resolving any globals that are futures ...
[09:31:30.096] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.096] Resolving any globals that are futures ... DONE
[09:31:30.097] Resolving futures part of globals (recursively) ...
[09:31:30.097] resolve() on list ...
[09:31:30.097]  recursive: 99
[09:31:30.097]  length: 1
[09:31:30.097]  elements: ‘x’
[09:31:30.097]  length: 0 (resolved future 1)
[09:31:30.098] resolve() on list ... DONE
[09:31:30.098] - globals: [1] ‘x’
[09:31:30.098] Resolving futures part of globals (recursively) ... DONE
[09:31:30.098] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.098] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.098] - globals: [1] ‘x’
[09:31:30.099] 
[09:31:30.099] getGlobalsAndPackages() ... DONE
[09:31:30.099] run() for ‘Future’ ...
[09:31:30.099] - state: ‘created’
[09:31:30.099] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.113]   - Field: ‘node’
[09:31:30.114]   - Field: ‘label’
[09:31:30.114]   - Field: ‘local’
[09:31:30.114]   - Field: ‘owner’
[09:31:30.114]   - Field: ‘envir’
[09:31:30.114]   - Field: ‘workers’
[09:31:30.114]   - Field: ‘packages’
[09:31:30.114]   - Field: ‘gc’
[09:31:30.114]   - Field: ‘conditions’
[09:31:30.114]   - Field: ‘persistent’
[09:31:30.114]   - Field: ‘expr’
[09:31:30.115]   - Field: ‘uuid’
[09:31:30.115]   - Field: ‘seed’
[09:31:30.115]   - Field: ‘version’
[09:31:30.115]   - Field: ‘result’
[09:31:30.115]   - Field: ‘asynchronous’
[09:31:30.115]   - Field: ‘calls’
[09:31:30.115]   - Field: ‘globals’
[09:31:30.115]   - Field: ‘stdout’
[09:31:30.115]   - Field: ‘earlySignal’
[09:31:30.116]   - Field: ‘lazy’
[09:31:30.116]   - Field: ‘state’
[09:31:30.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.116] - Launch lazy future ...
[09:31:30.116] Packages needed by the future expression (n = 0): <none>
[09:31:30.116] Packages needed by future strategies (n = 0): <none>
[09:31:30.117] {
[09:31:30.117]     {
[09:31:30.117]         {
[09:31:30.117]             ...future.startTime <- base::Sys.time()
[09:31:30.117]             {
[09:31:30.117]                 {
[09:31:30.117]                   {
[09:31:30.117]                     {
[09:31:30.117]                       base::local({
[09:31:30.117]                         has_future <- base::requireNamespace("future", 
[09:31:30.117]                           quietly = TRUE)
[09:31:30.117]                         if (has_future) {
[09:31:30.117]                           ns <- base::getNamespace("future")
[09:31:30.117]                           version <- ns[[".package"]][["version"]]
[09:31:30.117]                           if (is.null(version)) 
[09:31:30.117]                             version <- utils::packageVersion("future")
[09:31:30.117]                         }
[09:31:30.117]                         else {
[09:31:30.117]                           version <- NULL
[09:31:30.117]                         }
[09:31:30.117]                         if (!has_future || version < "1.8.0") {
[09:31:30.117]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.117]                             "", base::R.version$version.string), 
[09:31:30.117]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.117]                               "release", "version")], collapse = " "), 
[09:31:30.117]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.117]                             info)
[09:31:30.117]                           info <- base::paste(info, collapse = "; ")
[09:31:30.117]                           if (!has_future) {
[09:31:30.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.117]                               info)
[09:31:30.117]                           }
[09:31:30.117]                           else {
[09:31:30.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.117]                               info, version)
[09:31:30.117]                           }
[09:31:30.117]                           base::stop(msg)
[09:31:30.117]                         }
[09:31:30.117]                       })
[09:31:30.117]                     }
[09:31:30.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.117]                     base::options(mc.cores = 1L)
[09:31:30.117]                   }
[09:31:30.117]                   ...future.strategy.old <- future::plan("list")
[09:31:30.117]                   options(future.plan = NULL)
[09:31:30.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.117]                 }
[09:31:30.117]                 ...future.workdir <- getwd()
[09:31:30.117]             }
[09:31:30.117]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.117]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.117]         }
[09:31:30.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.117]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.117]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.117]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.117]             base::names(...future.oldOptions))
[09:31:30.117]     }
[09:31:30.117]     if (FALSE) {
[09:31:30.117]     }
[09:31:30.117]     else {
[09:31:30.117]         if (TRUE) {
[09:31:30.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.117]                 open = "w")
[09:31:30.117]         }
[09:31:30.117]         else {
[09:31:30.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.117]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.117]         }
[09:31:30.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.117]             base::sink(type = "output", split = FALSE)
[09:31:30.117]             base::close(...future.stdout)
[09:31:30.117]         }, add = TRUE)
[09:31:30.117]     }
[09:31:30.117]     ...future.frame <- base::sys.nframe()
[09:31:30.117]     ...future.conditions <- base::list()
[09:31:30.117]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.117]     if (FALSE) {
[09:31:30.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.117]     }
[09:31:30.117]     ...future.result <- base::tryCatch({
[09:31:30.117]         base::withCallingHandlers({
[09:31:30.117]             ...future.value <- base::withVisible(base::local({
[09:31:30.117]                 ...future.makeSendCondition <- base::local({
[09:31:30.117]                   sendCondition <- NULL
[09:31:30.117]                   function(frame = 1L) {
[09:31:30.117]                     if (is.function(sendCondition)) 
[09:31:30.117]                       return(sendCondition)
[09:31:30.117]                     ns <- getNamespace("parallel")
[09:31:30.117]                     if (exists("sendData", mode = "function", 
[09:31:30.117]                       envir = ns)) {
[09:31:30.117]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.117]                         envir = ns)
[09:31:30.117]                       envir <- sys.frame(frame)
[09:31:30.117]                       master <- NULL
[09:31:30.117]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.117]                         !identical(envir, emptyenv())) {
[09:31:30.117]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.117]                           inherits = FALSE)) {
[09:31:30.117]                           master <- get("master", mode = "list", 
[09:31:30.117]                             envir = envir, inherits = FALSE)
[09:31:30.117]                           if (inherits(master, c("SOCKnode", 
[09:31:30.117]                             "SOCK0node"))) {
[09:31:30.117]                             sendCondition <<- function(cond) {
[09:31:30.117]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.117]                                 success = TRUE)
[09:31:30.117]                               parallel_sendData(master, data)
[09:31:30.117]                             }
[09:31:30.117]                             return(sendCondition)
[09:31:30.117]                           }
[09:31:30.117]                         }
[09:31:30.117]                         frame <- frame + 1L
[09:31:30.117]                         envir <- sys.frame(frame)
[09:31:30.117]                       }
[09:31:30.117]                     }
[09:31:30.117]                     sendCondition <<- function(cond) NULL
[09:31:30.117]                   }
[09:31:30.117]                 })
[09:31:30.117]                 withCallingHandlers({
[09:31:30.117]                   {
[09:31:30.117]                     x$a <- 1
[09:31:30.117]                     x
[09:31:30.117]                   }
[09:31:30.117]                 }, immediateCondition = function(cond) {
[09:31:30.117]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.117]                   sendCondition(cond)
[09:31:30.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.117]                   {
[09:31:30.117]                     inherits <- base::inherits
[09:31:30.117]                     invokeRestart <- base::invokeRestart
[09:31:30.117]                     is.null <- base::is.null
[09:31:30.117]                     muffled <- FALSE
[09:31:30.117]                     if (inherits(cond, "message")) {
[09:31:30.117]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.117]                       if (muffled) 
[09:31:30.117]                         invokeRestart("muffleMessage")
[09:31:30.117]                     }
[09:31:30.117]                     else if (inherits(cond, "warning")) {
[09:31:30.117]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.117]                       if (muffled) 
[09:31:30.117]                         invokeRestart("muffleWarning")
[09:31:30.117]                     }
[09:31:30.117]                     else if (inherits(cond, "condition")) {
[09:31:30.117]                       if (!is.null(pattern)) {
[09:31:30.117]                         computeRestarts <- base::computeRestarts
[09:31:30.117]                         grepl <- base::grepl
[09:31:30.117]                         restarts <- computeRestarts(cond)
[09:31:30.117]                         for (restart in restarts) {
[09:31:30.117]                           name <- restart$name
[09:31:30.117]                           if (is.null(name)) 
[09:31:30.117]                             next
[09:31:30.117]                           if (!grepl(pattern, name)) 
[09:31:30.117]                             next
[09:31:30.117]                           invokeRestart(restart)
[09:31:30.117]                           muffled <- TRUE
[09:31:30.117]                           break
[09:31:30.117]                         }
[09:31:30.117]                       }
[09:31:30.117]                     }
[09:31:30.117]                     invisible(muffled)
[09:31:30.117]                   }
[09:31:30.117]                   muffleCondition(cond)
[09:31:30.117]                 })
[09:31:30.117]             }))
[09:31:30.117]             future::FutureResult(value = ...future.value$value, 
[09:31:30.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.117]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.117]                     ...future.globalenv.names))
[09:31:30.117]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.117]         }, condition = base::local({
[09:31:30.117]             c <- base::c
[09:31:30.117]             inherits <- base::inherits
[09:31:30.117]             invokeRestart <- base::invokeRestart
[09:31:30.117]             length <- base::length
[09:31:30.117]             list <- base::list
[09:31:30.117]             seq.int <- base::seq.int
[09:31:30.117]             signalCondition <- base::signalCondition
[09:31:30.117]             sys.calls <- base::sys.calls
[09:31:30.117]             `[[` <- base::`[[`
[09:31:30.117]             `+` <- base::`+`
[09:31:30.117]             `<<-` <- base::`<<-`
[09:31:30.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.117]                   3L)]
[09:31:30.117]             }
[09:31:30.117]             function(cond) {
[09:31:30.117]                 is_error <- inherits(cond, "error")
[09:31:30.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.117]                   NULL)
[09:31:30.117]                 if (is_error) {
[09:31:30.117]                   sessionInformation <- function() {
[09:31:30.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.117]                       search = base::search(), system = base::Sys.info())
[09:31:30.117]                   }
[09:31:30.117]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.117]                     cond$call), session = sessionInformation(), 
[09:31:30.117]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.117]                   signalCondition(cond)
[09:31:30.117]                 }
[09:31:30.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.117]                 "immediateCondition"))) {
[09:31:30.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.117]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.117]                   if (TRUE && !signal) {
[09:31:30.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.117]                     {
[09:31:30.117]                       inherits <- base::inherits
[09:31:30.117]                       invokeRestart <- base::invokeRestart
[09:31:30.117]                       is.null <- base::is.null
[09:31:30.117]                       muffled <- FALSE
[09:31:30.117]                       if (inherits(cond, "message")) {
[09:31:30.117]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.117]                         if (muffled) 
[09:31:30.117]                           invokeRestart("muffleMessage")
[09:31:30.117]                       }
[09:31:30.117]                       else if (inherits(cond, "warning")) {
[09:31:30.117]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.117]                         if (muffled) 
[09:31:30.117]                           invokeRestart("muffleWarning")
[09:31:30.117]                       }
[09:31:30.117]                       else if (inherits(cond, "condition")) {
[09:31:30.117]                         if (!is.null(pattern)) {
[09:31:30.117]                           computeRestarts <- base::computeRestarts
[09:31:30.117]                           grepl <- base::grepl
[09:31:30.117]                           restarts <- computeRestarts(cond)
[09:31:30.117]                           for (restart in restarts) {
[09:31:30.117]                             name <- restart$name
[09:31:30.117]                             if (is.null(name)) 
[09:31:30.117]                               next
[09:31:30.117]                             if (!grepl(pattern, name)) 
[09:31:30.117]                               next
[09:31:30.117]                             invokeRestart(restart)
[09:31:30.117]                             muffled <- TRUE
[09:31:30.117]                             break
[09:31:30.117]                           }
[09:31:30.117]                         }
[09:31:30.117]                       }
[09:31:30.117]                       invisible(muffled)
[09:31:30.117]                     }
[09:31:30.117]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.117]                   }
[09:31:30.117]                 }
[09:31:30.117]                 else {
[09:31:30.117]                   if (TRUE) {
[09:31:30.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.117]                     {
[09:31:30.117]                       inherits <- base::inherits
[09:31:30.117]                       invokeRestart <- base::invokeRestart
[09:31:30.117]                       is.null <- base::is.null
[09:31:30.117]                       muffled <- FALSE
[09:31:30.117]                       if (inherits(cond, "message")) {
[09:31:30.117]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.117]                         if (muffled) 
[09:31:30.117]                           invokeRestart("muffleMessage")
[09:31:30.117]                       }
[09:31:30.117]                       else if (inherits(cond, "warning")) {
[09:31:30.117]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.117]                         if (muffled) 
[09:31:30.117]                           invokeRestart("muffleWarning")
[09:31:30.117]                       }
[09:31:30.117]                       else if (inherits(cond, "condition")) {
[09:31:30.117]                         if (!is.null(pattern)) {
[09:31:30.117]                           computeRestarts <- base::computeRestarts
[09:31:30.117]                           grepl <- base::grepl
[09:31:30.117]                           restarts <- computeRestarts(cond)
[09:31:30.117]                           for (restart in restarts) {
[09:31:30.117]                             name <- restart$name
[09:31:30.117]                             if (is.null(name)) 
[09:31:30.117]                               next
[09:31:30.117]                             if (!grepl(pattern, name)) 
[09:31:30.117]                               next
[09:31:30.117]                             invokeRestart(restart)
[09:31:30.117]                             muffled <- TRUE
[09:31:30.117]                             break
[09:31:30.117]                           }
[09:31:30.117]                         }
[09:31:30.117]                       }
[09:31:30.117]                       invisible(muffled)
[09:31:30.117]                     }
[09:31:30.117]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.117]                   }
[09:31:30.117]                 }
[09:31:30.117]             }
[09:31:30.117]         }))
[09:31:30.117]     }, error = function(ex) {
[09:31:30.117]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.117]                 ...future.rng), started = ...future.startTime, 
[09:31:30.117]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.117]             version = "1.8"), class = "FutureResult")
[09:31:30.117]     }, finally = {
[09:31:30.117]         if (!identical(...future.workdir, getwd())) 
[09:31:30.117]             setwd(...future.workdir)
[09:31:30.117]         {
[09:31:30.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.117]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.117]             }
[09:31:30.117]             base::options(...future.oldOptions)
[09:31:30.117]             if (.Platform$OS.type == "windows") {
[09:31:30.117]                 old_names <- names(...future.oldEnvVars)
[09:31:30.117]                 envs <- base::Sys.getenv()
[09:31:30.117]                 names <- names(envs)
[09:31:30.117]                 common <- intersect(names, old_names)
[09:31:30.117]                 added <- setdiff(names, old_names)
[09:31:30.117]                 removed <- setdiff(old_names, names)
[09:31:30.117]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.117]                   envs[common]]
[09:31:30.117]                 NAMES <- toupper(changed)
[09:31:30.117]                 args <- list()
[09:31:30.117]                 for (kk in seq_along(NAMES)) {
[09:31:30.117]                   name <- changed[[kk]]
[09:31:30.117]                   NAME <- NAMES[[kk]]
[09:31:30.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.117]                     next
[09:31:30.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.117]                 }
[09:31:30.117]                 NAMES <- toupper(added)
[09:31:30.117]                 for (kk in seq_along(NAMES)) {
[09:31:30.117]                   name <- added[[kk]]
[09:31:30.117]                   NAME <- NAMES[[kk]]
[09:31:30.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.117]                     next
[09:31:30.117]                   args[[name]] <- ""
[09:31:30.117]                 }
[09:31:30.117]                 NAMES <- toupper(removed)
[09:31:30.117]                 for (kk in seq_along(NAMES)) {
[09:31:30.117]                   name <- removed[[kk]]
[09:31:30.117]                   NAME <- NAMES[[kk]]
[09:31:30.117]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.117]                     next
[09:31:30.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.117]                 }
[09:31:30.117]                 if (length(args) > 0) 
[09:31:30.117]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.117]             }
[09:31:30.117]             else {
[09:31:30.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.117]             }
[09:31:30.117]             {
[09:31:30.117]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.117]                   0L) {
[09:31:30.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.117]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.117]                   base::options(opts)
[09:31:30.117]                 }
[09:31:30.117]                 {
[09:31:30.117]                   {
[09:31:30.117]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.117]                     NULL
[09:31:30.117]                   }
[09:31:30.117]                   options(future.plan = NULL)
[09:31:30.117]                   if (is.na(NA_character_)) 
[09:31:30.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.117]                     .init = FALSE)
[09:31:30.117]                 }
[09:31:30.117]             }
[09:31:30.117]         }
[09:31:30.117]     })
[09:31:30.117]     if (TRUE) {
[09:31:30.117]         base::sink(type = "output", split = FALSE)
[09:31:30.117]         if (TRUE) {
[09:31:30.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.117]         }
[09:31:30.117]         else {
[09:31:30.117]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.117]         }
[09:31:30.117]         base::close(...future.stdout)
[09:31:30.117]         ...future.stdout <- NULL
[09:31:30.117]     }
[09:31:30.117]     ...future.result$conditions <- ...future.conditions
[09:31:30.117]     ...future.result$finished <- base::Sys.time()
[09:31:30.117]     ...future.result
[09:31:30.117] }
[09:31:30.120] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.120] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.120] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.120] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.121] MultisessionFuture started
[09:31:30.121] - Launch lazy future ... done
[09:31:30.121] run() for ‘MultisessionFuture’ ... done
[09:31:30.122] result() for ClusterFuture ...
[09:31:30.122] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.122] - Validating connection of MultisessionFuture
[09:31:30.126] - received message: FutureResult
[09:31:30.126] - Received FutureResult
[09:31:30.126] - Erased future from FutureRegistry
[09:31:30.126] result() for ClusterFuture ...
[09:31:30.127] - result already collected: FutureResult
[09:31:30.127] result() for ClusterFuture ... done
[09:31:30.127] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.127] result() for ClusterFuture ... done
[09:31:30.127] result() for ClusterFuture ...
[09:31:30.127] - result already collected: FutureResult
[09:31:30.127] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.128] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.128] Searching for globals...
[09:31:30.130] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.131] Searching for globals ... DONE
[09:31:30.131] Resolving globals: TRUE
[09:31:30.131] Resolving any globals that are futures ...
[09:31:30.131] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.131] Resolving any globals that are futures ... DONE
[09:31:30.131] Resolving futures part of globals (recursively) ...
[09:31:30.132] resolve() on list ...
[09:31:30.132]  recursive: 99
[09:31:30.132]  length: 1
[09:31:30.132]  elements: ‘x’
[09:31:30.132]  length: 0 (resolved future 1)
[09:31:30.132] resolve() on list ... DONE
[09:31:30.133] - globals: [1] ‘x’
[09:31:30.133] Resolving futures part of globals (recursively) ... DONE
[09:31:30.133] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.133] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.133] - globals: [1] ‘x’
[09:31:30.133] 
[09:31:30.134] getGlobalsAndPackages() ... DONE
[09:31:30.134] run() for ‘Future’ ...
[09:31:30.134] - state: ‘created’
[09:31:30.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.150] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.150]   - Field: ‘node’
[09:31:30.150]   - Field: ‘label’
[09:31:30.151]   - Field: ‘local’
[09:31:30.151]   - Field: ‘owner’
[09:31:30.151]   - Field: ‘envir’
[09:31:30.151]   - Field: ‘workers’
[09:31:30.151]   - Field: ‘packages’
[09:31:30.151]   - Field: ‘gc’
[09:31:30.151]   - Field: ‘conditions’
[09:31:30.151]   - Field: ‘persistent’
[09:31:30.151]   - Field: ‘expr’
[09:31:30.151]   - Field: ‘uuid’
[09:31:30.151]   - Field: ‘seed’
[09:31:30.152]   - Field: ‘version’
[09:31:30.152]   - Field: ‘result’
[09:31:30.152]   - Field: ‘asynchronous’
[09:31:30.152]   - Field: ‘calls’
[09:31:30.152]   - Field: ‘globals’
[09:31:30.152]   - Field: ‘stdout’
[09:31:30.152]   - Field: ‘earlySignal’
[09:31:30.152]   - Field: ‘lazy’
[09:31:30.152]   - Field: ‘state’
[09:31:30.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.152] - Launch lazy future ...
[09:31:30.153] Packages needed by the future expression (n = 0): <none>
[09:31:30.153] Packages needed by future strategies (n = 0): <none>
[09:31:30.153] {
[09:31:30.153]     {
[09:31:30.153]         {
[09:31:30.153]             ...future.startTime <- base::Sys.time()
[09:31:30.153]             {
[09:31:30.153]                 {
[09:31:30.153]                   {
[09:31:30.153]                     {
[09:31:30.153]                       base::local({
[09:31:30.153]                         has_future <- base::requireNamespace("future", 
[09:31:30.153]                           quietly = TRUE)
[09:31:30.153]                         if (has_future) {
[09:31:30.153]                           ns <- base::getNamespace("future")
[09:31:30.153]                           version <- ns[[".package"]][["version"]]
[09:31:30.153]                           if (is.null(version)) 
[09:31:30.153]                             version <- utils::packageVersion("future")
[09:31:30.153]                         }
[09:31:30.153]                         else {
[09:31:30.153]                           version <- NULL
[09:31:30.153]                         }
[09:31:30.153]                         if (!has_future || version < "1.8.0") {
[09:31:30.153]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.153]                             "", base::R.version$version.string), 
[09:31:30.153]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.153]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.153]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.153]                               "release", "version")], collapse = " "), 
[09:31:30.153]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.153]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.153]                             info)
[09:31:30.153]                           info <- base::paste(info, collapse = "; ")
[09:31:30.153]                           if (!has_future) {
[09:31:30.153]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.153]                               info)
[09:31:30.153]                           }
[09:31:30.153]                           else {
[09:31:30.153]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.153]                               info, version)
[09:31:30.153]                           }
[09:31:30.153]                           base::stop(msg)
[09:31:30.153]                         }
[09:31:30.153]                       })
[09:31:30.153]                     }
[09:31:30.153]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.153]                     base::options(mc.cores = 1L)
[09:31:30.153]                   }
[09:31:30.153]                   ...future.strategy.old <- future::plan("list")
[09:31:30.153]                   options(future.plan = NULL)
[09:31:30.153]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.153]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.153]                 }
[09:31:30.153]                 ...future.workdir <- getwd()
[09:31:30.153]             }
[09:31:30.153]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.153]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.153]         }
[09:31:30.153]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.153]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.153]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.153]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.153]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.153]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.153]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.153]             base::names(...future.oldOptions))
[09:31:30.153]     }
[09:31:30.153]     if (FALSE) {
[09:31:30.153]     }
[09:31:30.153]     else {
[09:31:30.153]         if (TRUE) {
[09:31:30.153]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.153]                 open = "w")
[09:31:30.153]         }
[09:31:30.153]         else {
[09:31:30.153]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.153]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.153]         }
[09:31:30.153]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.153]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.153]             base::sink(type = "output", split = FALSE)
[09:31:30.153]             base::close(...future.stdout)
[09:31:30.153]         }, add = TRUE)
[09:31:30.153]     }
[09:31:30.153]     ...future.frame <- base::sys.nframe()
[09:31:30.153]     ...future.conditions <- base::list()
[09:31:30.153]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.153]     if (FALSE) {
[09:31:30.153]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.153]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.153]     }
[09:31:30.153]     ...future.result <- base::tryCatch({
[09:31:30.153]         base::withCallingHandlers({
[09:31:30.153]             ...future.value <- base::withVisible(base::local({
[09:31:30.153]                 ...future.makeSendCondition <- base::local({
[09:31:30.153]                   sendCondition <- NULL
[09:31:30.153]                   function(frame = 1L) {
[09:31:30.153]                     if (is.function(sendCondition)) 
[09:31:30.153]                       return(sendCondition)
[09:31:30.153]                     ns <- getNamespace("parallel")
[09:31:30.153]                     if (exists("sendData", mode = "function", 
[09:31:30.153]                       envir = ns)) {
[09:31:30.153]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.153]                         envir = ns)
[09:31:30.153]                       envir <- sys.frame(frame)
[09:31:30.153]                       master <- NULL
[09:31:30.153]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.153]                         !identical(envir, emptyenv())) {
[09:31:30.153]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.153]                           inherits = FALSE)) {
[09:31:30.153]                           master <- get("master", mode = "list", 
[09:31:30.153]                             envir = envir, inherits = FALSE)
[09:31:30.153]                           if (inherits(master, c("SOCKnode", 
[09:31:30.153]                             "SOCK0node"))) {
[09:31:30.153]                             sendCondition <<- function(cond) {
[09:31:30.153]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.153]                                 success = TRUE)
[09:31:30.153]                               parallel_sendData(master, data)
[09:31:30.153]                             }
[09:31:30.153]                             return(sendCondition)
[09:31:30.153]                           }
[09:31:30.153]                         }
[09:31:30.153]                         frame <- frame + 1L
[09:31:30.153]                         envir <- sys.frame(frame)
[09:31:30.153]                       }
[09:31:30.153]                     }
[09:31:30.153]                     sendCondition <<- function(cond) NULL
[09:31:30.153]                   }
[09:31:30.153]                 })
[09:31:30.153]                 withCallingHandlers({
[09:31:30.153]                   {
[09:31:30.153]                     x$a <- 1
[09:31:30.153]                     x
[09:31:30.153]                   }
[09:31:30.153]                 }, immediateCondition = function(cond) {
[09:31:30.153]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.153]                   sendCondition(cond)
[09:31:30.153]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.153]                   {
[09:31:30.153]                     inherits <- base::inherits
[09:31:30.153]                     invokeRestart <- base::invokeRestart
[09:31:30.153]                     is.null <- base::is.null
[09:31:30.153]                     muffled <- FALSE
[09:31:30.153]                     if (inherits(cond, "message")) {
[09:31:30.153]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.153]                       if (muffled) 
[09:31:30.153]                         invokeRestart("muffleMessage")
[09:31:30.153]                     }
[09:31:30.153]                     else if (inherits(cond, "warning")) {
[09:31:30.153]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.153]                       if (muffled) 
[09:31:30.153]                         invokeRestart("muffleWarning")
[09:31:30.153]                     }
[09:31:30.153]                     else if (inherits(cond, "condition")) {
[09:31:30.153]                       if (!is.null(pattern)) {
[09:31:30.153]                         computeRestarts <- base::computeRestarts
[09:31:30.153]                         grepl <- base::grepl
[09:31:30.153]                         restarts <- computeRestarts(cond)
[09:31:30.153]                         for (restart in restarts) {
[09:31:30.153]                           name <- restart$name
[09:31:30.153]                           if (is.null(name)) 
[09:31:30.153]                             next
[09:31:30.153]                           if (!grepl(pattern, name)) 
[09:31:30.153]                             next
[09:31:30.153]                           invokeRestart(restart)
[09:31:30.153]                           muffled <- TRUE
[09:31:30.153]                           break
[09:31:30.153]                         }
[09:31:30.153]                       }
[09:31:30.153]                     }
[09:31:30.153]                     invisible(muffled)
[09:31:30.153]                   }
[09:31:30.153]                   muffleCondition(cond)
[09:31:30.153]                 })
[09:31:30.153]             }))
[09:31:30.153]             future::FutureResult(value = ...future.value$value, 
[09:31:30.153]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.153]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.153]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.153]                     ...future.globalenv.names))
[09:31:30.153]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.153]         }, condition = base::local({
[09:31:30.153]             c <- base::c
[09:31:30.153]             inherits <- base::inherits
[09:31:30.153]             invokeRestart <- base::invokeRestart
[09:31:30.153]             length <- base::length
[09:31:30.153]             list <- base::list
[09:31:30.153]             seq.int <- base::seq.int
[09:31:30.153]             signalCondition <- base::signalCondition
[09:31:30.153]             sys.calls <- base::sys.calls
[09:31:30.153]             `[[` <- base::`[[`
[09:31:30.153]             `+` <- base::`+`
[09:31:30.153]             `<<-` <- base::`<<-`
[09:31:30.153]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.153]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.153]                   3L)]
[09:31:30.153]             }
[09:31:30.153]             function(cond) {
[09:31:30.153]                 is_error <- inherits(cond, "error")
[09:31:30.153]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.153]                   NULL)
[09:31:30.153]                 if (is_error) {
[09:31:30.153]                   sessionInformation <- function() {
[09:31:30.153]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.153]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.153]                       search = base::search(), system = base::Sys.info())
[09:31:30.153]                   }
[09:31:30.153]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.153]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.153]                     cond$call), session = sessionInformation(), 
[09:31:30.153]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.153]                   signalCondition(cond)
[09:31:30.153]                 }
[09:31:30.153]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.153]                 "immediateCondition"))) {
[09:31:30.153]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.153]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.153]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.153]                   if (TRUE && !signal) {
[09:31:30.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.153]                     {
[09:31:30.153]                       inherits <- base::inherits
[09:31:30.153]                       invokeRestart <- base::invokeRestart
[09:31:30.153]                       is.null <- base::is.null
[09:31:30.153]                       muffled <- FALSE
[09:31:30.153]                       if (inherits(cond, "message")) {
[09:31:30.153]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.153]                         if (muffled) 
[09:31:30.153]                           invokeRestart("muffleMessage")
[09:31:30.153]                       }
[09:31:30.153]                       else if (inherits(cond, "warning")) {
[09:31:30.153]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.153]                         if (muffled) 
[09:31:30.153]                           invokeRestart("muffleWarning")
[09:31:30.153]                       }
[09:31:30.153]                       else if (inherits(cond, "condition")) {
[09:31:30.153]                         if (!is.null(pattern)) {
[09:31:30.153]                           computeRestarts <- base::computeRestarts
[09:31:30.153]                           grepl <- base::grepl
[09:31:30.153]                           restarts <- computeRestarts(cond)
[09:31:30.153]                           for (restart in restarts) {
[09:31:30.153]                             name <- restart$name
[09:31:30.153]                             if (is.null(name)) 
[09:31:30.153]                               next
[09:31:30.153]                             if (!grepl(pattern, name)) 
[09:31:30.153]                               next
[09:31:30.153]                             invokeRestart(restart)
[09:31:30.153]                             muffled <- TRUE
[09:31:30.153]                             break
[09:31:30.153]                           }
[09:31:30.153]                         }
[09:31:30.153]                       }
[09:31:30.153]                       invisible(muffled)
[09:31:30.153]                     }
[09:31:30.153]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.153]                   }
[09:31:30.153]                 }
[09:31:30.153]                 else {
[09:31:30.153]                   if (TRUE) {
[09:31:30.153]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.153]                     {
[09:31:30.153]                       inherits <- base::inherits
[09:31:30.153]                       invokeRestart <- base::invokeRestart
[09:31:30.153]                       is.null <- base::is.null
[09:31:30.153]                       muffled <- FALSE
[09:31:30.153]                       if (inherits(cond, "message")) {
[09:31:30.153]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.153]                         if (muffled) 
[09:31:30.153]                           invokeRestart("muffleMessage")
[09:31:30.153]                       }
[09:31:30.153]                       else if (inherits(cond, "warning")) {
[09:31:30.153]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.153]                         if (muffled) 
[09:31:30.153]                           invokeRestart("muffleWarning")
[09:31:30.153]                       }
[09:31:30.153]                       else if (inherits(cond, "condition")) {
[09:31:30.153]                         if (!is.null(pattern)) {
[09:31:30.153]                           computeRestarts <- base::computeRestarts
[09:31:30.153]                           grepl <- base::grepl
[09:31:30.153]                           restarts <- computeRestarts(cond)
[09:31:30.153]                           for (restart in restarts) {
[09:31:30.153]                             name <- restart$name
[09:31:30.153]                             if (is.null(name)) 
[09:31:30.153]                               next
[09:31:30.153]                             if (!grepl(pattern, name)) 
[09:31:30.153]                               next
[09:31:30.153]                             invokeRestart(restart)
[09:31:30.153]                             muffled <- TRUE
[09:31:30.153]                             break
[09:31:30.153]                           }
[09:31:30.153]                         }
[09:31:30.153]                       }
[09:31:30.153]                       invisible(muffled)
[09:31:30.153]                     }
[09:31:30.153]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.153]                   }
[09:31:30.153]                 }
[09:31:30.153]             }
[09:31:30.153]         }))
[09:31:30.153]     }, error = function(ex) {
[09:31:30.153]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.153]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.153]                 ...future.rng), started = ...future.startTime, 
[09:31:30.153]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.153]             version = "1.8"), class = "FutureResult")
[09:31:30.153]     }, finally = {
[09:31:30.153]         if (!identical(...future.workdir, getwd())) 
[09:31:30.153]             setwd(...future.workdir)
[09:31:30.153]         {
[09:31:30.153]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.153]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.153]             }
[09:31:30.153]             base::options(...future.oldOptions)
[09:31:30.153]             if (.Platform$OS.type == "windows") {
[09:31:30.153]                 old_names <- names(...future.oldEnvVars)
[09:31:30.153]                 envs <- base::Sys.getenv()
[09:31:30.153]                 names <- names(envs)
[09:31:30.153]                 common <- intersect(names, old_names)
[09:31:30.153]                 added <- setdiff(names, old_names)
[09:31:30.153]                 removed <- setdiff(old_names, names)
[09:31:30.153]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.153]                   envs[common]]
[09:31:30.153]                 NAMES <- toupper(changed)
[09:31:30.153]                 args <- list()
[09:31:30.153]                 for (kk in seq_along(NAMES)) {
[09:31:30.153]                   name <- changed[[kk]]
[09:31:30.153]                   NAME <- NAMES[[kk]]
[09:31:30.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.153]                     next
[09:31:30.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.153]                 }
[09:31:30.153]                 NAMES <- toupper(added)
[09:31:30.153]                 for (kk in seq_along(NAMES)) {
[09:31:30.153]                   name <- added[[kk]]
[09:31:30.153]                   NAME <- NAMES[[kk]]
[09:31:30.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.153]                     next
[09:31:30.153]                   args[[name]] <- ""
[09:31:30.153]                 }
[09:31:30.153]                 NAMES <- toupper(removed)
[09:31:30.153]                 for (kk in seq_along(NAMES)) {
[09:31:30.153]                   name <- removed[[kk]]
[09:31:30.153]                   NAME <- NAMES[[kk]]
[09:31:30.153]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.153]                     next
[09:31:30.153]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.153]                 }
[09:31:30.153]                 if (length(args) > 0) 
[09:31:30.153]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.153]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.153]             }
[09:31:30.153]             else {
[09:31:30.153]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.153]             }
[09:31:30.153]             {
[09:31:30.153]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.153]                   0L) {
[09:31:30.153]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.153]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.153]                   base::options(opts)
[09:31:30.153]                 }
[09:31:30.153]                 {
[09:31:30.153]                   {
[09:31:30.153]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.153]                     NULL
[09:31:30.153]                   }
[09:31:30.153]                   options(future.plan = NULL)
[09:31:30.153]                   if (is.na(NA_character_)) 
[09:31:30.153]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.153]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.153]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.153]                     .init = FALSE)
[09:31:30.153]                 }
[09:31:30.153]             }
[09:31:30.153]         }
[09:31:30.153]     })
[09:31:30.153]     if (TRUE) {
[09:31:30.153]         base::sink(type = "output", split = FALSE)
[09:31:30.153]         if (TRUE) {
[09:31:30.153]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.153]         }
[09:31:30.153]         else {
[09:31:30.153]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.153]         }
[09:31:30.153]         base::close(...future.stdout)
[09:31:30.153]         ...future.stdout <- NULL
[09:31:30.153]     }
[09:31:30.153]     ...future.result$conditions <- ...future.conditions
[09:31:30.153]     ...future.result$finished <- base::Sys.time()
[09:31:30.153]     ...future.result
[09:31:30.153] }
[09:31:30.156] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.156] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.156] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.156] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.157] MultisessionFuture started
[09:31:30.157] - Launch lazy future ... done
[09:31:30.157] run() for ‘MultisessionFuture’ ... done
[09:31:30.157] result() for ClusterFuture ...
[09:31:30.157] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.158] - Validating connection of MultisessionFuture
[09:31:30.159] - received message: FutureResult
[09:31:30.159] - Received FutureResult
[09:31:30.159] - Erased future from FutureRegistry
[09:31:30.159] result() for ClusterFuture ...
[09:31:30.159] - result already collected: FutureResult
[09:31:30.159] result() for ClusterFuture ... done
[09:31:30.159] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.159] result() for ClusterFuture ... done
[09:31:30.159] result() for ClusterFuture ...
[09:31:30.159] - result already collected: FutureResult
[09:31:30.159] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.160] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.160] Searching for globals...
[09:31:30.162] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.162] Searching for globals ... DONE
[09:31:30.162] Resolving globals: TRUE
[09:31:30.162] Resolving any globals that are futures ...
[09:31:30.162] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘$’, ‘$<-’
[09:31:30.162] Resolving any globals that are futures ... DONE
[09:31:30.163] Resolving futures part of globals (recursively) ...
[09:31:30.163] resolve() on list ...
[09:31:30.163]  recursive: 99
[09:31:30.163]  length: 1
[09:31:30.163]  elements: ‘x’
[09:31:30.163]  length: 0 (resolved future 1)
[09:31:30.163] resolve() on list ... DONE
[09:31:30.163] - globals: [1] ‘x’
[09:31:30.164] Resolving futures part of globals (recursively) ... DONE
[09:31:30.164] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.164] The total size of the 1 globals exported for future expression (‘{; x$a <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.164] - globals: [1] ‘x’
[09:31:30.164] 
[09:31:30.164] getGlobalsAndPackages() ... DONE
[09:31:30.165] run() for ‘Future’ ...
[09:31:30.165] - state: ‘created’
[09:31:30.165] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.178] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.178]   - Field: ‘node’
[09:31:30.178]   - Field: ‘label’
[09:31:30.178]   - Field: ‘local’
[09:31:30.178]   - Field: ‘owner’
[09:31:30.178]   - Field: ‘envir’
[09:31:30.179]   - Field: ‘workers’
[09:31:30.179]   - Field: ‘packages’
[09:31:30.179]   - Field: ‘gc’
[09:31:30.179]   - Field: ‘conditions’
[09:31:30.179]   - Field: ‘persistent’
[09:31:30.179]   - Field: ‘expr’
[09:31:30.179]   - Field: ‘uuid’
[09:31:30.179]   - Field: ‘seed’
[09:31:30.179]   - Field: ‘version’
[09:31:30.179]   - Field: ‘result’
[09:31:30.179]   - Field: ‘asynchronous’
[09:31:30.180]   - Field: ‘calls’
[09:31:30.180]   - Field: ‘globals’
[09:31:30.180]   - Field: ‘stdout’
[09:31:30.180]   - Field: ‘earlySignal’
[09:31:30.180]   - Field: ‘lazy’
[09:31:30.180]   - Field: ‘state’
[09:31:30.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.180] - Launch lazy future ...
[09:31:30.180] Packages needed by the future expression (n = 0): <none>
[09:31:30.181] Packages needed by future strategies (n = 0): <none>
[09:31:30.181] {
[09:31:30.181]     {
[09:31:30.181]         {
[09:31:30.181]             ...future.startTime <- base::Sys.time()
[09:31:30.181]             {
[09:31:30.181]                 {
[09:31:30.181]                   {
[09:31:30.181]                     {
[09:31:30.181]                       base::local({
[09:31:30.181]                         has_future <- base::requireNamespace("future", 
[09:31:30.181]                           quietly = TRUE)
[09:31:30.181]                         if (has_future) {
[09:31:30.181]                           ns <- base::getNamespace("future")
[09:31:30.181]                           version <- ns[[".package"]][["version"]]
[09:31:30.181]                           if (is.null(version)) 
[09:31:30.181]                             version <- utils::packageVersion("future")
[09:31:30.181]                         }
[09:31:30.181]                         else {
[09:31:30.181]                           version <- NULL
[09:31:30.181]                         }
[09:31:30.181]                         if (!has_future || version < "1.8.0") {
[09:31:30.181]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.181]                             "", base::R.version$version.string), 
[09:31:30.181]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.181]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.181]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.181]                               "release", "version")], collapse = " "), 
[09:31:30.181]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.181]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.181]                             info)
[09:31:30.181]                           info <- base::paste(info, collapse = "; ")
[09:31:30.181]                           if (!has_future) {
[09:31:30.181]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.181]                               info)
[09:31:30.181]                           }
[09:31:30.181]                           else {
[09:31:30.181]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.181]                               info, version)
[09:31:30.181]                           }
[09:31:30.181]                           base::stop(msg)
[09:31:30.181]                         }
[09:31:30.181]                       })
[09:31:30.181]                     }
[09:31:30.181]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.181]                     base::options(mc.cores = 1L)
[09:31:30.181]                   }
[09:31:30.181]                   ...future.strategy.old <- future::plan("list")
[09:31:30.181]                   options(future.plan = NULL)
[09:31:30.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.181]                 }
[09:31:30.181]                 ...future.workdir <- getwd()
[09:31:30.181]             }
[09:31:30.181]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.181]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.181]         }
[09:31:30.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.181]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.181]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.181]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.181]             base::names(...future.oldOptions))
[09:31:30.181]     }
[09:31:30.181]     if (FALSE) {
[09:31:30.181]     }
[09:31:30.181]     else {
[09:31:30.181]         if (TRUE) {
[09:31:30.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.181]                 open = "w")
[09:31:30.181]         }
[09:31:30.181]         else {
[09:31:30.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.181]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.181]         }
[09:31:30.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.181]             base::sink(type = "output", split = FALSE)
[09:31:30.181]             base::close(...future.stdout)
[09:31:30.181]         }, add = TRUE)
[09:31:30.181]     }
[09:31:30.181]     ...future.frame <- base::sys.nframe()
[09:31:30.181]     ...future.conditions <- base::list()
[09:31:30.181]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.181]     if (FALSE) {
[09:31:30.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.181]     }
[09:31:30.181]     ...future.result <- base::tryCatch({
[09:31:30.181]         base::withCallingHandlers({
[09:31:30.181]             ...future.value <- base::withVisible(base::local({
[09:31:30.181]                 ...future.makeSendCondition <- base::local({
[09:31:30.181]                   sendCondition <- NULL
[09:31:30.181]                   function(frame = 1L) {
[09:31:30.181]                     if (is.function(sendCondition)) 
[09:31:30.181]                       return(sendCondition)
[09:31:30.181]                     ns <- getNamespace("parallel")
[09:31:30.181]                     if (exists("sendData", mode = "function", 
[09:31:30.181]                       envir = ns)) {
[09:31:30.181]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.181]                         envir = ns)
[09:31:30.181]                       envir <- sys.frame(frame)
[09:31:30.181]                       master <- NULL
[09:31:30.181]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.181]                         !identical(envir, emptyenv())) {
[09:31:30.181]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.181]                           inherits = FALSE)) {
[09:31:30.181]                           master <- get("master", mode = "list", 
[09:31:30.181]                             envir = envir, inherits = FALSE)
[09:31:30.181]                           if (inherits(master, c("SOCKnode", 
[09:31:30.181]                             "SOCK0node"))) {
[09:31:30.181]                             sendCondition <<- function(cond) {
[09:31:30.181]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.181]                                 success = TRUE)
[09:31:30.181]                               parallel_sendData(master, data)
[09:31:30.181]                             }
[09:31:30.181]                             return(sendCondition)
[09:31:30.181]                           }
[09:31:30.181]                         }
[09:31:30.181]                         frame <- frame + 1L
[09:31:30.181]                         envir <- sys.frame(frame)
[09:31:30.181]                       }
[09:31:30.181]                     }
[09:31:30.181]                     sendCondition <<- function(cond) NULL
[09:31:30.181]                   }
[09:31:30.181]                 })
[09:31:30.181]                 withCallingHandlers({
[09:31:30.181]                   {
[09:31:30.181]                     x$a <- 1
[09:31:30.181]                     x
[09:31:30.181]                   }
[09:31:30.181]                 }, immediateCondition = function(cond) {
[09:31:30.181]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.181]                   sendCondition(cond)
[09:31:30.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.181]                   {
[09:31:30.181]                     inherits <- base::inherits
[09:31:30.181]                     invokeRestart <- base::invokeRestart
[09:31:30.181]                     is.null <- base::is.null
[09:31:30.181]                     muffled <- FALSE
[09:31:30.181]                     if (inherits(cond, "message")) {
[09:31:30.181]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.181]                       if (muffled) 
[09:31:30.181]                         invokeRestart("muffleMessage")
[09:31:30.181]                     }
[09:31:30.181]                     else if (inherits(cond, "warning")) {
[09:31:30.181]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.181]                       if (muffled) 
[09:31:30.181]                         invokeRestart("muffleWarning")
[09:31:30.181]                     }
[09:31:30.181]                     else if (inherits(cond, "condition")) {
[09:31:30.181]                       if (!is.null(pattern)) {
[09:31:30.181]                         computeRestarts <- base::computeRestarts
[09:31:30.181]                         grepl <- base::grepl
[09:31:30.181]                         restarts <- computeRestarts(cond)
[09:31:30.181]                         for (restart in restarts) {
[09:31:30.181]                           name <- restart$name
[09:31:30.181]                           if (is.null(name)) 
[09:31:30.181]                             next
[09:31:30.181]                           if (!grepl(pattern, name)) 
[09:31:30.181]                             next
[09:31:30.181]                           invokeRestart(restart)
[09:31:30.181]                           muffled <- TRUE
[09:31:30.181]                           break
[09:31:30.181]                         }
[09:31:30.181]                       }
[09:31:30.181]                     }
[09:31:30.181]                     invisible(muffled)
[09:31:30.181]                   }
[09:31:30.181]                   muffleCondition(cond)
[09:31:30.181]                 })
[09:31:30.181]             }))
[09:31:30.181]             future::FutureResult(value = ...future.value$value, 
[09:31:30.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.181]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.181]                     ...future.globalenv.names))
[09:31:30.181]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.181]         }, condition = base::local({
[09:31:30.181]             c <- base::c
[09:31:30.181]             inherits <- base::inherits
[09:31:30.181]             invokeRestart <- base::invokeRestart
[09:31:30.181]             length <- base::length
[09:31:30.181]             list <- base::list
[09:31:30.181]             seq.int <- base::seq.int
[09:31:30.181]             signalCondition <- base::signalCondition
[09:31:30.181]             sys.calls <- base::sys.calls
[09:31:30.181]             `[[` <- base::`[[`
[09:31:30.181]             `+` <- base::`+`
[09:31:30.181]             `<<-` <- base::`<<-`
[09:31:30.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.181]                   3L)]
[09:31:30.181]             }
[09:31:30.181]             function(cond) {
[09:31:30.181]                 is_error <- inherits(cond, "error")
[09:31:30.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.181]                   NULL)
[09:31:30.181]                 if (is_error) {
[09:31:30.181]                   sessionInformation <- function() {
[09:31:30.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.181]                       search = base::search(), system = base::Sys.info())
[09:31:30.181]                   }
[09:31:30.181]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.181]                     cond$call), session = sessionInformation(), 
[09:31:30.181]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.181]                   signalCondition(cond)
[09:31:30.181]                 }
[09:31:30.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.181]                 "immediateCondition"))) {
[09:31:30.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.181]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.181]                   if (TRUE && !signal) {
[09:31:30.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.181]                     {
[09:31:30.181]                       inherits <- base::inherits
[09:31:30.181]                       invokeRestart <- base::invokeRestart
[09:31:30.181]                       is.null <- base::is.null
[09:31:30.181]                       muffled <- FALSE
[09:31:30.181]                       if (inherits(cond, "message")) {
[09:31:30.181]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.181]                         if (muffled) 
[09:31:30.181]                           invokeRestart("muffleMessage")
[09:31:30.181]                       }
[09:31:30.181]                       else if (inherits(cond, "warning")) {
[09:31:30.181]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.181]                         if (muffled) 
[09:31:30.181]                           invokeRestart("muffleWarning")
[09:31:30.181]                       }
[09:31:30.181]                       else if (inherits(cond, "condition")) {
[09:31:30.181]                         if (!is.null(pattern)) {
[09:31:30.181]                           computeRestarts <- base::computeRestarts
[09:31:30.181]                           grepl <- base::grepl
[09:31:30.181]                           restarts <- computeRestarts(cond)
[09:31:30.181]                           for (restart in restarts) {
[09:31:30.181]                             name <- restart$name
[09:31:30.181]                             if (is.null(name)) 
[09:31:30.181]                               next
[09:31:30.181]                             if (!grepl(pattern, name)) 
[09:31:30.181]                               next
[09:31:30.181]                             invokeRestart(restart)
[09:31:30.181]                             muffled <- TRUE
[09:31:30.181]                             break
[09:31:30.181]                           }
[09:31:30.181]                         }
[09:31:30.181]                       }
[09:31:30.181]                       invisible(muffled)
[09:31:30.181]                     }
[09:31:30.181]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.181]                   }
[09:31:30.181]                 }
[09:31:30.181]                 else {
[09:31:30.181]                   if (TRUE) {
[09:31:30.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.181]                     {
[09:31:30.181]                       inherits <- base::inherits
[09:31:30.181]                       invokeRestart <- base::invokeRestart
[09:31:30.181]                       is.null <- base::is.null
[09:31:30.181]                       muffled <- FALSE
[09:31:30.181]                       if (inherits(cond, "message")) {
[09:31:30.181]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.181]                         if (muffled) 
[09:31:30.181]                           invokeRestart("muffleMessage")
[09:31:30.181]                       }
[09:31:30.181]                       else if (inherits(cond, "warning")) {
[09:31:30.181]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.181]                         if (muffled) 
[09:31:30.181]                           invokeRestart("muffleWarning")
[09:31:30.181]                       }
[09:31:30.181]                       else if (inherits(cond, "condition")) {
[09:31:30.181]                         if (!is.null(pattern)) {
[09:31:30.181]                           computeRestarts <- base::computeRestarts
[09:31:30.181]                           grepl <- base::grepl
[09:31:30.181]                           restarts <- computeRestarts(cond)
[09:31:30.181]                           for (restart in restarts) {
[09:31:30.181]                             name <- restart$name
[09:31:30.181]                             if (is.null(name)) 
[09:31:30.181]                               next
[09:31:30.181]                             if (!grepl(pattern, name)) 
[09:31:30.181]                               next
[09:31:30.181]                             invokeRestart(restart)
[09:31:30.181]                             muffled <- TRUE
[09:31:30.181]                             break
[09:31:30.181]                           }
[09:31:30.181]                         }
[09:31:30.181]                       }
[09:31:30.181]                       invisible(muffled)
[09:31:30.181]                     }
[09:31:30.181]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.181]                   }
[09:31:30.181]                 }
[09:31:30.181]             }
[09:31:30.181]         }))
[09:31:30.181]     }, error = function(ex) {
[09:31:30.181]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.181]                 ...future.rng), started = ...future.startTime, 
[09:31:30.181]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.181]             version = "1.8"), class = "FutureResult")
[09:31:30.181]     }, finally = {
[09:31:30.181]         if (!identical(...future.workdir, getwd())) 
[09:31:30.181]             setwd(...future.workdir)
[09:31:30.181]         {
[09:31:30.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.181]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.181]             }
[09:31:30.181]             base::options(...future.oldOptions)
[09:31:30.181]             if (.Platform$OS.type == "windows") {
[09:31:30.181]                 old_names <- names(...future.oldEnvVars)
[09:31:30.181]                 envs <- base::Sys.getenv()
[09:31:30.181]                 names <- names(envs)
[09:31:30.181]                 common <- intersect(names, old_names)
[09:31:30.181]                 added <- setdiff(names, old_names)
[09:31:30.181]                 removed <- setdiff(old_names, names)
[09:31:30.181]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.181]                   envs[common]]
[09:31:30.181]                 NAMES <- toupper(changed)
[09:31:30.181]                 args <- list()
[09:31:30.181]                 for (kk in seq_along(NAMES)) {
[09:31:30.181]                   name <- changed[[kk]]
[09:31:30.181]                   NAME <- NAMES[[kk]]
[09:31:30.181]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.181]                     next
[09:31:30.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.181]                 }
[09:31:30.181]                 NAMES <- toupper(added)
[09:31:30.181]                 for (kk in seq_along(NAMES)) {
[09:31:30.181]                   name <- added[[kk]]
[09:31:30.181]                   NAME <- NAMES[[kk]]
[09:31:30.181]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.181]                     next
[09:31:30.181]                   args[[name]] <- ""
[09:31:30.181]                 }
[09:31:30.181]                 NAMES <- toupper(removed)
[09:31:30.181]                 for (kk in seq_along(NAMES)) {
[09:31:30.181]                   name <- removed[[kk]]
[09:31:30.181]                   NAME <- NAMES[[kk]]
[09:31:30.181]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.181]                     next
[09:31:30.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.181]                 }
[09:31:30.181]                 if (length(args) > 0) 
[09:31:30.181]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.181]             }
[09:31:30.181]             else {
[09:31:30.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.181]             }
[09:31:30.181]             {
[09:31:30.181]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.181]                   0L) {
[09:31:30.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.181]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.181]                   base::options(opts)
[09:31:30.181]                 }
[09:31:30.181]                 {
[09:31:30.181]                   {
[09:31:30.181]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.181]                     NULL
[09:31:30.181]                   }
[09:31:30.181]                   options(future.plan = NULL)
[09:31:30.181]                   if (is.na(NA_character_)) 
[09:31:30.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.181]                     .init = FALSE)
[09:31:30.181]                 }
[09:31:30.181]             }
[09:31:30.181]         }
[09:31:30.181]     })
[09:31:30.181]     if (TRUE) {
[09:31:30.181]         base::sink(type = "output", split = FALSE)
[09:31:30.181]         if (TRUE) {
[09:31:30.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.181]         }
[09:31:30.181]         else {
[09:31:30.181]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.181]         }
[09:31:30.181]         base::close(...future.stdout)
[09:31:30.181]         ...future.stdout <- NULL
[09:31:30.181]     }
[09:31:30.181]     ...future.result$conditions <- ...future.conditions
[09:31:30.181]     ...future.result$finished <- base::Sys.time()
[09:31:30.181]     ...future.result
[09:31:30.181] }
[09:31:30.183] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.183] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.184] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.184] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.184] MultisessionFuture started
[09:31:30.184] - Launch lazy future ... done
[09:31:30.185] run() for ‘MultisessionFuture’ ... done
[09:31:30.185] result() for ClusterFuture ...
[09:31:30.185] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.185] - Validating connection of MultisessionFuture
[09:31:30.186] - received message: FutureResult
[09:31:30.186] - Received FutureResult
[09:31:30.186] - Erased future from FutureRegistry
[09:31:30.186] result() for ClusterFuture ...
[09:31:30.186] - result already collected: FutureResult
[09:31:30.186] result() for ClusterFuture ... done
[09:31:30.186] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.186] result() for ClusterFuture ... done
[09:31:30.186] result() for ClusterFuture ...
[09:31:30.187] - result already collected: FutureResult
[09:31:30.187] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.187] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.187] Searching for globals...
[09:31:30.189] - globals found: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:30.190] Searching for globals ... DONE
[09:31:30.190] Resolving globals: TRUE
[09:31:30.190] Resolving any globals that are futures ...
[09:31:30.190] - globals: [5] ‘{’, ‘<-’, ‘list’, ‘$’, ‘$<-’
[09:31:30.190] Resolving any globals that are futures ... DONE
[09:31:30.190] 
[09:31:30.190] 
[09:31:30.191] getGlobalsAndPackages() ... DONE
[09:31:30.191] run() for ‘Future’ ...
[09:31:30.191] - state: ‘created’
[09:31:30.191] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.206] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.206] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.206]   - Field: ‘node’
[09:31:30.206]   - Field: ‘label’
[09:31:30.206]   - Field: ‘local’
[09:31:30.206]   - Field: ‘owner’
[09:31:30.207]   - Field: ‘envir’
[09:31:30.207]   - Field: ‘workers’
[09:31:30.207]   - Field: ‘packages’
[09:31:30.207]   - Field: ‘gc’
[09:31:30.207]   - Field: ‘conditions’
[09:31:30.207]   - Field: ‘persistent’
[09:31:30.207]   - Field: ‘expr’
[09:31:30.207]   - Field: ‘uuid’
[09:31:30.207]   - Field: ‘seed’
[09:31:30.207]   - Field: ‘version’
[09:31:30.207]   - Field: ‘result’
[09:31:30.208]   - Field: ‘asynchronous’
[09:31:30.208]   - Field: ‘calls’
[09:31:30.208]   - Field: ‘globals’
[09:31:30.208]   - Field: ‘stdout’
[09:31:30.208]   - Field: ‘earlySignal’
[09:31:30.208]   - Field: ‘lazy’
[09:31:30.208]   - Field: ‘state’
[09:31:30.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.208] - Launch lazy future ...
[09:31:30.209] Packages needed by the future expression (n = 0): <none>
[09:31:30.209] Packages needed by future strategies (n = 0): <none>
[09:31:30.209] {
[09:31:30.209]     {
[09:31:30.209]         {
[09:31:30.209]             ...future.startTime <- base::Sys.time()
[09:31:30.209]             {
[09:31:30.209]                 {
[09:31:30.209]                   {
[09:31:30.209]                     {
[09:31:30.209]                       base::local({
[09:31:30.209]                         has_future <- base::requireNamespace("future", 
[09:31:30.209]                           quietly = TRUE)
[09:31:30.209]                         if (has_future) {
[09:31:30.209]                           ns <- base::getNamespace("future")
[09:31:30.209]                           version <- ns[[".package"]][["version"]]
[09:31:30.209]                           if (is.null(version)) 
[09:31:30.209]                             version <- utils::packageVersion("future")
[09:31:30.209]                         }
[09:31:30.209]                         else {
[09:31:30.209]                           version <- NULL
[09:31:30.209]                         }
[09:31:30.209]                         if (!has_future || version < "1.8.0") {
[09:31:30.209]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.209]                             "", base::R.version$version.string), 
[09:31:30.209]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.209]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.209]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.209]                               "release", "version")], collapse = " "), 
[09:31:30.209]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.209]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.209]                             info)
[09:31:30.209]                           info <- base::paste(info, collapse = "; ")
[09:31:30.209]                           if (!has_future) {
[09:31:30.209]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.209]                               info)
[09:31:30.209]                           }
[09:31:30.209]                           else {
[09:31:30.209]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.209]                               info, version)
[09:31:30.209]                           }
[09:31:30.209]                           base::stop(msg)
[09:31:30.209]                         }
[09:31:30.209]                       })
[09:31:30.209]                     }
[09:31:30.209]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.209]                     base::options(mc.cores = 1L)
[09:31:30.209]                   }
[09:31:30.209]                   ...future.strategy.old <- future::plan("list")
[09:31:30.209]                   options(future.plan = NULL)
[09:31:30.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.209]                 }
[09:31:30.209]                 ...future.workdir <- getwd()
[09:31:30.209]             }
[09:31:30.209]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.209]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.209]         }
[09:31:30.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.209]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.209]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.209]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.209]             base::names(...future.oldOptions))
[09:31:30.209]     }
[09:31:30.209]     if (FALSE) {
[09:31:30.209]     }
[09:31:30.209]     else {
[09:31:30.209]         if (TRUE) {
[09:31:30.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.209]                 open = "w")
[09:31:30.209]         }
[09:31:30.209]         else {
[09:31:30.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.209]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.209]         }
[09:31:30.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.209]             base::sink(type = "output", split = FALSE)
[09:31:30.209]             base::close(...future.stdout)
[09:31:30.209]         }, add = TRUE)
[09:31:30.209]     }
[09:31:30.209]     ...future.frame <- base::sys.nframe()
[09:31:30.209]     ...future.conditions <- base::list()
[09:31:30.209]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.209]     if (FALSE) {
[09:31:30.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.209]     }
[09:31:30.209]     ...future.result <- base::tryCatch({
[09:31:30.209]         base::withCallingHandlers({
[09:31:30.209]             ...future.value <- base::withVisible(base::local({
[09:31:30.209]                 ...future.makeSendCondition <- base::local({
[09:31:30.209]                   sendCondition <- NULL
[09:31:30.209]                   function(frame = 1L) {
[09:31:30.209]                     if (is.function(sendCondition)) 
[09:31:30.209]                       return(sendCondition)
[09:31:30.209]                     ns <- getNamespace("parallel")
[09:31:30.209]                     if (exists("sendData", mode = "function", 
[09:31:30.209]                       envir = ns)) {
[09:31:30.209]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.209]                         envir = ns)
[09:31:30.209]                       envir <- sys.frame(frame)
[09:31:30.209]                       master <- NULL
[09:31:30.209]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.209]                         !identical(envir, emptyenv())) {
[09:31:30.209]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.209]                           inherits = FALSE)) {
[09:31:30.209]                           master <- get("master", mode = "list", 
[09:31:30.209]                             envir = envir, inherits = FALSE)
[09:31:30.209]                           if (inherits(master, c("SOCKnode", 
[09:31:30.209]                             "SOCK0node"))) {
[09:31:30.209]                             sendCondition <<- function(cond) {
[09:31:30.209]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.209]                                 success = TRUE)
[09:31:30.209]                               parallel_sendData(master, data)
[09:31:30.209]                             }
[09:31:30.209]                             return(sendCondition)
[09:31:30.209]                           }
[09:31:30.209]                         }
[09:31:30.209]                         frame <- frame + 1L
[09:31:30.209]                         envir <- sys.frame(frame)
[09:31:30.209]                       }
[09:31:30.209]                     }
[09:31:30.209]                     sendCondition <<- function(cond) NULL
[09:31:30.209]                   }
[09:31:30.209]                 })
[09:31:30.209]                 withCallingHandlers({
[09:31:30.209]                   {
[09:31:30.209]                     x <- list(b = 2)
[09:31:30.209]                     x$a <- 1
[09:31:30.209]                     x
[09:31:30.209]                   }
[09:31:30.209]                 }, immediateCondition = function(cond) {
[09:31:30.209]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.209]                   sendCondition(cond)
[09:31:30.209]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.209]                   {
[09:31:30.209]                     inherits <- base::inherits
[09:31:30.209]                     invokeRestart <- base::invokeRestart
[09:31:30.209]                     is.null <- base::is.null
[09:31:30.209]                     muffled <- FALSE
[09:31:30.209]                     if (inherits(cond, "message")) {
[09:31:30.209]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.209]                       if (muffled) 
[09:31:30.209]                         invokeRestart("muffleMessage")
[09:31:30.209]                     }
[09:31:30.209]                     else if (inherits(cond, "warning")) {
[09:31:30.209]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.209]                       if (muffled) 
[09:31:30.209]                         invokeRestart("muffleWarning")
[09:31:30.209]                     }
[09:31:30.209]                     else if (inherits(cond, "condition")) {
[09:31:30.209]                       if (!is.null(pattern)) {
[09:31:30.209]                         computeRestarts <- base::computeRestarts
[09:31:30.209]                         grepl <- base::grepl
[09:31:30.209]                         restarts <- computeRestarts(cond)
[09:31:30.209]                         for (restart in restarts) {
[09:31:30.209]                           name <- restart$name
[09:31:30.209]                           if (is.null(name)) 
[09:31:30.209]                             next
[09:31:30.209]                           if (!grepl(pattern, name)) 
[09:31:30.209]                             next
[09:31:30.209]                           invokeRestart(restart)
[09:31:30.209]                           muffled <- TRUE
[09:31:30.209]                           break
[09:31:30.209]                         }
[09:31:30.209]                       }
[09:31:30.209]                     }
[09:31:30.209]                     invisible(muffled)
[09:31:30.209]                   }
[09:31:30.209]                   muffleCondition(cond)
[09:31:30.209]                 })
[09:31:30.209]             }))
[09:31:30.209]             future::FutureResult(value = ...future.value$value, 
[09:31:30.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.209]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.209]                     ...future.globalenv.names))
[09:31:30.209]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.209]         }, condition = base::local({
[09:31:30.209]             c <- base::c
[09:31:30.209]             inherits <- base::inherits
[09:31:30.209]             invokeRestart <- base::invokeRestart
[09:31:30.209]             length <- base::length
[09:31:30.209]             list <- base::list
[09:31:30.209]             seq.int <- base::seq.int
[09:31:30.209]             signalCondition <- base::signalCondition
[09:31:30.209]             sys.calls <- base::sys.calls
[09:31:30.209]             `[[` <- base::`[[`
[09:31:30.209]             `+` <- base::`+`
[09:31:30.209]             `<<-` <- base::`<<-`
[09:31:30.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.209]                   3L)]
[09:31:30.209]             }
[09:31:30.209]             function(cond) {
[09:31:30.209]                 is_error <- inherits(cond, "error")
[09:31:30.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.209]                   NULL)
[09:31:30.209]                 if (is_error) {
[09:31:30.209]                   sessionInformation <- function() {
[09:31:30.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.209]                       search = base::search(), system = base::Sys.info())
[09:31:30.209]                   }
[09:31:30.209]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.209]                     cond$call), session = sessionInformation(), 
[09:31:30.209]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.209]                   signalCondition(cond)
[09:31:30.209]                 }
[09:31:30.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.209]                 "immediateCondition"))) {
[09:31:30.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.209]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.209]                   if (TRUE && !signal) {
[09:31:30.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.209]                     {
[09:31:30.209]                       inherits <- base::inherits
[09:31:30.209]                       invokeRestart <- base::invokeRestart
[09:31:30.209]                       is.null <- base::is.null
[09:31:30.209]                       muffled <- FALSE
[09:31:30.209]                       if (inherits(cond, "message")) {
[09:31:30.209]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.209]                         if (muffled) 
[09:31:30.209]                           invokeRestart("muffleMessage")
[09:31:30.209]                       }
[09:31:30.209]                       else if (inherits(cond, "warning")) {
[09:31:30.209]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.209]                         if (muffled) 
[09:31:30.209]                           invokeRestart("muffleWarning")
[09:31:30.209]                       }
[09:31:30.209]                       else if (inherits(cond, "condition")) {
[09:31:30.209]                         if (!is.null(pattern)) {
[09:31:30.209]                           computeRestarts <- base::computeRestarts
[09:31:30.209]                           grepl <- base::grepl
[09:31:30.209]                           restarts <- computeRestarts(cond)
[09:31:30.209]                           for (restart in restarts) {
[09:31:30.209]                             name <- restart$name
[09:31:30.209]                             if (is.null(name)) 
[09:31:30.209]                               next
[09:31:30.209]                             if (!grepl(pattern, name)) 
[09:31:30.209]                               next
[09:31:30.209]                             invokeRestart(restart)
[09:31:30.209]                             muffled <- TRUE
[09:31:30.209]                             break
[09:31:30.209]                           }
[09:31:30.209]                         }
[09:31:30.209]                       }
[09:31:30.209]                       invisible(muffled)
[09:31:30.209]                     }
[09:31:30.209]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.209]                   }
[09:31:30.209]                 }
[09:31:30.209]                 else {
[09:31:30.209]                   if (TRUE) {
[09:31:30.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.209]                     {
[09:31:30.209]                       inherits <- base::inherits
[09:31:30.209]                       invokeRestart <- base::invokeRestart
[09:31:30.209]                       is.null <- base::is.null
[09:31:30.209]                       muffled <- FALSE
[09:31:30.209]                       if (inherits(cond, "message")) {
[09:31:30.209]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.209]                         if (muffled) 
[09:31:30.209]                           invokeRestart("muffleMessage")
[09:31:30.209]                       }
[09:31:30.209]                       else if (inherits(cond, "warning")) {
[09:31:30.209]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.209]                         if (muffled) 
[09:31:30.209]                           invokeRestart("muffleWarning")
[09:31:30.209]                       }
[09:31:30.209]                       else if (inherits(cond, "condition")) {
[09:31:30.209]                         if (!is.null(pattern)) {
[09:31:30.209]                           computeRestarts <- base::computeRestarts
[09:31:30.209]                           grepl <- base::grepl
[09:31:30.209]                           restarts <- computeRestarts(cond)
[09:31:30.209]                           for (restart in restarts) {
[09:31:30.209]                             name <- restart$name
[09:31:30.209]                             if (is.null(name)) 
[09:31:30.209]                               next
[09:31:30.209]                             if (!grepl(pattern, name)) 
[09:31:30.209]                               next
[09:31:30.209]                             invokeRestart(restart)
[09:31:30.209]                             muffled <- TRUE
[09:31:30.209]                             break
[09:31:30.209]                           }
[09:31:30.209]                         }
[09:31:30.209]                       }
[09:31:30.209]                       invisible(muffled)
[09:31:30.209]                     }
[09:31:30.209]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.209]                   }
[09:31:30.209]                 }
[09:31:30.209]             }
[09:31:30.209]         }))
[09:31:30.209]     }, error = function(ex) {
[09:31:30.209]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.209]                 ...future.rng), started = ...future.startTime, 
[09:31:30.209]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.209]             version = "1.8"), class = "FutureResult")
[09:31:30.209]     }, finally = {
[09:31:30.209]         if (!identical(...future.workdir, getwd())) 
[09:31:30.209]             setwd(...future.workdir)
[09:31:30.209]         {
[09:31:30.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.209]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.209]             }
[09:31:30.209]             base::options(...future.oldOptions)
[09:31:30.209]             if (.Platform$OS.type == "windows") {
[09:31:30.209]                 old_names <- names(...future.oldEnvVars)
[09:31:30.209]                 envs <- base::Sys.getenv()
[09:31:30.209]                 names <- names(envs)
[09:31:30.209]                 common <- intersect(names, old_names)
[09:31:30.209]                 added <- setdiff(names, old_names)
[09:31:30.209]                 removed <- setdiff(old_names, names)
[09:31:30.209]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.209]                   envs[common]]
[09:31:30.209]                 NAMES <- toupper(changed)
[09:31:30.209]                 args <- list()
[09:31:30.209]                 for (kk in seq_along(NAMES)) {
[09:31:30.209]                   name <- changed[[kk]]
[09:31:30.209]                   NAME <- NAMES[[kk]]
[09:31:30.209]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.209]                     next
[09:31:30.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.209]                 }
[09:31:30.209]                 NAMES <- toupper(added)
[09:31:30.209]                 for (kk in seq_along(NAMES)) {
[09:31:30.209]                   name <- added[[kk]]
[09:31:30.209]                   NAME <- NAMES[[kk]]
[09:31:30.209]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.209]                     next
[09:31:30.209]                   args[[name]] <- ""
[09:31:30.209]                 }
[09:31:30.209]                 NAMES <- toupper(removed)
[09:31:30.209]                 for (kk in seq_along(NAMES)) {
[09:31:30.209]                   name <- removed[[kk]]
[09:31:30.209]                   NAME <- NAMES[[kk]]
[09:31:30.209]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.209]                     next
[09:31:30.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.209]                 }
[09:31:30.209]                 if (length(args) > 0) 
[09:31:30.209]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.209]             }
[09:31:30.209]             else {
[09:31:30.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.209]             }
[09:31:30.209]             {
[09:31:30.209]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.209]                   0L) {
[09:31:30.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.209]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.209]                   base::options(opts)
[09:31:30.209]                 }
[09:31:30.209]                 {
[09:31:30.209]                   {
[09:31:30.209]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.209]                     NULL
[09:31:30.209]                   }
[09:31:30.209]                   options(future.plan = NULL)
[09:31:30.209]                   if (is.na(NA_character_)) 
[09:31:30.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.209]                     .init = FALSE)
[09:31:30.209]                 }
[09:31:30.209]             }
[09:31:30.209]         }
[09:31:30.209]     })
[09:31:30.209]     if (TRUE) {
[09:31:30.209]         base::sink(type = "output", split = FALSE)
[09:31:30.209]         if (TRUE) {
[09:31:30.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.209]         }
[09:31:30.209]         else {
[09:31:30.209]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.209]         }
[09:31:30.209]         base::close(...future.stdout)
[09:31:30.209]         ...future.stdout <- NULL
[09:31:30.209]     }
[09:31:30.209]     ...future.result$conditions <- ...future.conditions
[09:31:30.209]     ...future.result$finished <- base::Sys.time()
[09:31:30.209]     ...future.result
[09:31:30.209] }
[09:31:30.212] MultisessionFuture started
[09:31:30.212] - Launch lazy future ... done
[09:31:30.212] run() for ‘MultisessionFuture’ ... done
[09:31:30.212] result() for ClusterFuture ...
[09:31:30.213] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.213] - Validating connection of MultisessionFuture
[09:31:30.214] - received message: FutureResult
[09:31:30.214] - Received FutureResult
[09:31:30.214] - Erased future from FutureRegistry
[09:31:30.214] result() for ClusterFuture ...
[09:31:30.214] - result already collected: FutureResult
[09:31:30.214] result() for ClusterFuture ... done
[09:31:30.214] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.214] result() for ClusterFuture ... done
[09:31:30.214] result() for ClusterFuture ...
[09:31:30.215] - result already collected: FutureResult
[09:31:30.215] result() for ClusterFuture ... done
$b
[1] 2

$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.215] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.215] Searching for globals...
[09:31:30.217] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.217] Searching for globals ... DONE
[09:31:30.217] Resolving globals: TRUE
[09:31:30.217] Resolving any globals that are futures ...
[09:31:30.217] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.217] Resolving any globals that are futures ... DONE
[09:31:30.218] Resolving futures part of globals (recursively) ...
[09:31:30.218] resolve() on list ...
[09:31:30.218]  recursive: 99
[09:31:30.218]  length: 1
[09:31:30.218]  elements: ‘x’
[09:31:30.218]  length: 0 (resolved future 1)
[09:31:30.218] resolve() on list ... DONE
[09:31:30.219] - globals: [1] ‘x’
[09:31:30.219] Resolving futures part of globals (recursively) ... DONE
[09:31:30.219] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.219] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.219] - globals: [1] ‘x’
[09:31:30.219] 
[09:31:30.219] getGlobalsAndPackages() ... DONE
[09:31:30.220] run() for ‘Future’ ...
[09:31:30.220] - state: ‘created’
[09:31:30.220] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.233]   - Field: ‘node’
[09:31:30.233]   - Field: ‘label’
[09:31:30.233]   - Field: ‘local’
[09:31:30.233]   - Field: ‘owner’
[09:31:30.234]   - Field: ‘envir’
[09:31:30.234]   - Field: ‘workers’
[09:31:30.234]   - Field: ‘packages’
[09:31:30.234]   - Field: ‘gc’
[09:31:30.234]   - Field: ‘conditions’
[09:31:30.234]   - Field: ‘persistent’
[09:31:30.234]   - Field: ‘expr’
[09:31:30.234]   - Field: ‘uuid’
[09:31:30.234]   - Field: ‘seed’
[09:31:30.234]   - Field: ‘version’
[09:31:30.234]   - Field: ‘result’
[09:31:30.235]   - Field: ‘asynchronous’
[09:31:30.235]   - Field: ‘calls’
[09:31:30.235]   - Field: ‘globals’
[09:31:30.235]   - Field: ‘stdout’
[09:31:30.235]   - Field: ‘earlySignal’
[09:31:30.235]   - Field: ‘lazy’
[09:31:30.235]   - Field: ‘state’
[09:31:30.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.235] - Launch lazy future ...
[09:31:30.235] Packages needed by the future expression (n = 0): <none>
[09:31:30.236] Packages needed by future strategies (n = 0): <none>
[09:31:30.236] {
[09:31:30.236]     {
[09:31:30.236]         {
[09:31:30.236]             ...future.startTime <- base::Sys.time()
[09:31:30.236]             {
[09:31:30.236]                 {
[09:31:30.236]                   {
[09:31:30.236]                     {
[09:31:30.236]                       base::local({
[09:31:30.236]                         has_future <- base::requireNamespace("future", 
[09:31:30.236]                           quietly = TRUE)
[09:31:30.236]                         if (has_future) {
[09:31:30.236]                           ns <- base::getNamespace("future")
[09:31:30.236]                           version <- ns[[".package"]][["version"]]
[09:31:30.236]                           if (is.null(version)) 
[09:31:30.236]                             version <- utils::packageVersion("future")
[09:31:30.236]                         }
[09:31:30.236]                         else {
[09:31:30.236]                           version <- NULL
[09:31:30.236]                         }
[09:31:30.236]                         if (!has_future || version < "1.8.0") {
[09:31:30.236]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.236]                             "", base::R.version$version.string), 
[09:31:30.236]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.236]                               "release", "version")], collapse = " "), 
[09:31:30.236]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.236]                             info)
[09:31:30.236]                           info <- base::paste(info, collapse = "; ")
[09:31:30.236]                           if (!has_future) {
[09:31:30.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.236]                               info)
[09:31:30.236]                           }
[09:31:30.236]                           else {
[09:31:30.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.236]                               info, version)
[09:31:30.236]                           }
[09:31:30.236]                           base::stop(msg)
[09:31:30.236]                         }
[09:31:30.236]                       })
[09:31:30.236]                     }
[09:31:30.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.236]                     base::options(mc.cores = 1L)
[09:31:30.236]                   }
[09:31:30.236]                   ...future.strategy.old <- future::plan("list")
[09:31:30.236]                   options(future.plan = NULL)
[09:31:30.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.236]                 }
[09:31:30.236]                 ...future.workdir <- getwd()
[09:31:30.236]             }
[09:31:30.236]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.236]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.236]         }
[09:31:30.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.236]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.236]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.236]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.236]             base::names(...future.oldOptions))
[09:31:30.236]     }
[09:31:30.236]     if (FALSE) {
[09:31:30.236]     }
[09:31:30.236]     else {
[09:31:30.236]         if (TRUE) {
[09:31:30.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.236]                 open = "w")
[09:31:30.236]         }
[09:31:30.236]         else {
[09:31:30.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.236]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.236]         }
[09:31:30.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.236]             base::sink(type = "output", split = FALSE)
[09:31:30.236]             base::close(...future.stdout)
[09:31:30.236]         }, add = TRUE)
[09:31:30.236]     }
[09:31:30.236]     ...future.frame <- base::sys.nframe()
[09:31:30.236]     ...future.conditions <- base::list()
[09:31:30.236]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.236]     if (FALSE) {
[09:31:30.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.236]     }
[09:31:30.236]     ...future.result <- base::tryCatch({
[09:31:30.236]         base::withCallingHandlers({
[09:31:30.236]             ...future.value <- base::withVisible(base::local({
[09:31:30.236]                 ...future.makeSendCondition <- base::local({
[09:31:30.236]                   sendCondition <- NULL
[09:31:30.236]                   function(frame = 1L) {
[09:31:30.236]                     if (is.function(sendCondition)) 
[09:31:30.236]                       return(sendCondition)
[09:31:30.236]                     ns <- getNamespace("parallel")
[09:31:30.236]                     if (exists("sendData", mode = "function", 
[09:31:30.236]                       envir = ns)) {
[09:31:30.236]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.236]                         envir = ns)
[09:31:30.236]                       envir <- sys.frame(frame)
[09:31:30.236]                       master <- NULL
[09:31:30.236]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.236]                         !identical(envir, emptyenv())) {
[09:31:30.236]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.236]                           inherits = FALSE)) {
[09:31:30.236]                           master <- get("master", mode = "list", 
[09:31:30.236]                             envir = envir, inherits = FALSE)
[09:31:30.236]                           if (inherits(master, c("SOCKnode", 
[09:31:30.236]                             "SOCK0node"))) {
[09:31:30.236]                             sendCondition <<- function(cond) {
[09:31:30.236]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.236]                                 success = TRUE)
[09:31:30.236]                               parallel_sendData(master, data)
[09:31:30.236]                             }
[09:31:30.236]                             return(sendCondition)
[09:31:30.236]                           }
[09:31:30.236]                         }
[09:31:30.236]                         frame <- frame + 1L
[09:31:30.236]                         envir <- sys.frame(frame)
[09:31:30.236]                       }
[09:31:30.236]                     }
[09:31:30.236]                     sendCondition <<- function(cond) NULL
[09:31:30.236]                   }
[09:31:30.236]                 })
[09:31:30.236]                 withCallingHandlers({
[09:31:30.236]                   {
[09:31:30.236]                     x[["a"]] <- 1
[09:31:30.236]                     x
[09:31:30.236]                   }
[09:31:30.236]                 }, immediateCondition = function(cond) {
[09:31:30.236]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.236]                   sendCondition(cond)
[09:31:30.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.236]                   {
[09:31:30.236]                     inherits <- base::inherits
[09:31:30.236]                     invokeRestart <- base::invokeRestart
[09:31:30.236]                     is.null <- base::is.null
[09:31:30.236]                     muffled <- FALSE
[09:31:30.236]                     if (inherits(cond, "message")) {
[09:31:30.236]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.236]                       if (muffled) 
[09:31:30.236]                         invokeRestart("muffleMessage")
[09:31:30.236]                     }
[09:31:30.236]                     else if (inherits(cond, "warning")) {
[09:31:30.236]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.236]                       if (muffled) 
[09:31:30.236]                         invokeRestart("muffleWarning")
[09:31:30.236]                     }
[09:31:30.236]                     else if (inherits(cond, "condition")) {
[09:31:30.236]                       if (!is.null(pattern)) {
[09:31:30.236]                         computeRestarts <- base::computeRestarts
[09:31:30.236]                         grepl <- base::grepl
[09:31:30.236]                         restarts <- computeRestarts(cond)
[09:31:30.236]                         for (restart in restarts) {
[09:31:30.236]                           name <- restart$name
[09:31:30.236]                           if (is.null(name)) 
[09:31:30.236]                             next
[09:31:30.236]                           if (!grepl(pattern, name)) 
[09:31:30.236]                             next
[09:31:30.236]                           invokeRestart(restart)
[09:31:30.236]                           muffled <- TRUE
[09:31:30.236]                           break
[09:31:30.236]                         }
[09:31:30.236]                       }
[09:31:30.236]                     }
[09:31:30.236]                     invisible(muffled)
[09:31:30.236]                   }
[09:31:30.236]                   muffleCondition(cond)
[09:31:30.236]                 })
[09:31:30.236]             }))
[09:31:30.236]             future::FutureResult(value = ...future.value$value, 
[09:31:30.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.236]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.236]                     ...future.globalenv.names))
[09:31:30.236]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.236]         }, condition = base::local({
[09:31:30.236]             c <- base::c
[09:31:30.236]             inherits <- base::inherits
[09:31:30.236]             invokeRestart <- base::invokeRestart
[09:31:30.236]             length <- base::length
[09:31:30.236]             list <- base::list
[09:31:30.236]             seq.int <- base::seq.int
[09:31:30.236]             signalCondition <- base::signalCondition
[09:31:30.236]             sys.calls <- base::sys.calls
[09:31:30.236]             `[[` <- base::`[[`
[09:31:30.236]             `+` <- base::`+`
[09:31:30.236]             `<<-` <- base::`<<-`
[09:31:30.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.236]                   3L)]
[09:31:30.236]             }
[09:31:30.236]             function(cond) {
[09:31:30.236]                 is_error <- inherits(cond, "error")
[09:31:30.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.236]                   NULL)
[09:31:30.236]                 if (is_error) {
[09:31:30.236]                   sessionInformation <- function() {
[09:31:30.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.236]                       search = base::search(), system = base::Sys.info())
[09:31:30.236]                   }
[09:31:30.236]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.236]                     cond$call), session = sessionInformation(), 
[09:31:30.236]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.236]                   signalCondition(cond)
[09:31:30.236]                 }
[09:31:30.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.236]                 "immediateCondition"))) {
[09:31:30.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.236]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.236]                   if (TRUE && !signal) {
[09:31:30.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.236]                     {
[09:31:30.236]                       inherits <- base::inherits
[09:31:30.236]                       invokeRestart <- base::invokeRestart
[09:31:30.236]                       is.null <- base::is.null
[09:31:30.236]                       muffled <- FALSE
[09:31:30.236]                       if (inherits(cond, "message")) {
[09:31:30.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.236]                         if (muffled) 
[09:31:30.236]                           invokeRestart("muffleMessage")
[09:31:30.236]                       }
[09:31:30.236]                       else if (inherits(cond, "warning")) {
[09:31:30.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.236]                         if (muffled) 
[09:31:30.236]                           invokeRestart("muffleWarning")
[09:31:30.236]                       }
[09:31:30.236]                       else if (inherits(cond, "condition")) {
[09:31:30.236]                         if (!is.null(pattern)) {
[09:31:30.236]                           computeRestarts <- base::computeRestarts
[09:31:30.236]                           grepl <- base::grepl
[09:31:30.236]                           restarts <- computeRestarts(cond)
[09:31:30.236]                           for (restart in restarts) {
[09:31:30.236]                             name <- restart$name
[09:31:30.236]                             if (is.null(name)) 
[09:31:30.236]                               next
[09:31:30.236]                             if (!grepl(pattern, name)) 
[09:31:30.236]                               next
[09:31:30.236]                             invokeRestart(restart)
[09:31:30.236]                             muffled <- TRUE
[09:31:30.236]                             break
[09:31:30.236]                           }
[09:31:30.236]                         }
[09:31:30.236]                       }
[09:31:30.236]                       invisible(muffled)
[09:31:30.236]                     }
[09:31:30.236]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.236]                   }
[09:31:30.236]                 }
[09:31:30.236]                 else {
[09:31:30.236]                   if (TRUE) {
[09:31:30.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.236]                     {
[09:31:30.236]                       inherits <- base::inherits
[09:31:30.236]                       invokeRestart <- base::invokeRestart
[09:31:30.236]                       is.null <- base::is.null
[09:31:30.236]                       muffled <- FALSE
[09:31:30.236]                       if (inherits(cond, "message")) {
[09:31:30.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.236]                         if (muffled) 
[09:31:30.236]                           invokeRestart("muffleMessage")
[09:31:30.236]                       }
[09:31:30.236]                       else if (inherits(cond, "warning")) {
[09:31:30.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.236]                         if (muffled) 
[09:31:30.236]                           invokeRestart("muffleWarning")
[09:31:30.236]                       }
[09:31:30.236]                       else if (inherits(cond, "condition")) {
[09:31:30.236]                         if (!is.null(pattern)) {
[09:31:30.236]                           computeRestarts <- base::computeRestarts
[09:31:30.236]                           grepl <- base::grepl
[09:31:30.236]                           restarts <- computeRestarts(cond)
[09:31:30.236]                           for (restart in restarts) {
[09:31:30.236]                             name <- restart$name
[09:31:30.236]                             if (is.null(name)) 
[09:31:30.236]                               next
[09:31:30.236]                             if (!grepl(pattern, name)) 
[09:31:30.236]                               next
[09:31:30.236]                             invokeRestart(restart)
[09:31:30.236]                             muffled <- TRUE
[09:31:30.236]                             break
[09:31:30.236]                           }
[09:31:30.236]                         }
[09:31:30.236]                       }
[09:31:30.236]                       invisible(muffled)
[09:31:30.236]                     }
[09:31:30.236]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.236]                   }
[09:31:30.236]                 }
[09:31:30.236]             }
[09:31:30.236]         }))
[09:31:30.236]     }, error = function(ex) {
[09:31:30.236]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.236]                 ...future.rng), started = ...future.startTime, 
[09:31:30.236]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.236]             version = "1.8"), class = "FutureResult")
[09:31:30.236]     }, finally = {
[09:31:30.236]         if (!identical(...future.workdir, getwd())) 
[09:31:30.236]             setwd(...future.workdir)
[09:31:30.236]         {
[09:31:30.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.236]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.236]             }
[09:31:30.236]             base::options(...future.oldOptions)
[09:31:30.236]             if (.Platform$OS.type == "windows") {
[09:31:30.236]                 old_names <- names(...future.oldEnvVars)
[09:31:30.236]                 envs <- base::Sys.getenv()
[09:31:30.236]                 names <- names(envs)
[09:31:30.236]                 common <- intersect(names, old_names)
[09:31:30.236]                 added <- setdiff(names, old_names)
[09:31:30.236]                 removed <- setdiff(old_names, names)
[09:31:30.236]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.236]                   envs[common]]
[09:31:30.236]                 NAMES <- toupper(changed)
[09:31:30.236]                 args <- list()
[09:31:30.236]                 for (kk in seq_along(NAMES)) {
[09:31:30.236]                   name <- changed[[kk]]
[09:31:30.236]                   NAME <- NAMES[[kk]]
[09:31:30.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.236]                     next
[09:31:30.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.236]                 }
[09:31:30.236]                 NAMES <- toupper(added)
[09:31:30.236]                 for (kk in seq_along(NAMES)) {
[09:31:30.236]                   name <- added[[kk]]
[09:31:30.236]                   NAME <- NAMES[[kk]]
[09:31:30.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.236]                     next
[09:31:30.236]                   args[[name]] <- ""
[09:31:30.236]                 }
[09:31:30.236]                 NAMES <- toupper(removed)
[09:31:30.236]                 for (kk in seq_along(NAMES)) {
[09:31:30.236]                   name <- removed[[kk]]
[09:31:30.236]                   NAME <- NAMES[[kk]]
[09:31:30.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.236]                     next
[09:31:30.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.236]                 }
[09:31:30.236]                 if (length(args) > 0) 
[09:31:30.236]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.236]             }
[09:31:30.236]             else {
[09:31:30.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.236]             }
[09:31:30.236]             {
[09:31:30.236]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.236]                   0L) {
[09:31:30.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.236]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.236]                   base::options(opts)
[09:31:30.236]                 }
[09:31:30.236]                 {
[09:31:30.236]                   {
[09:31:30.236]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.236]                     NULL
[09:31:30.236]                   }
[09:31:30.236]                   options(future.plan = NULL)
[09:31:30.236]                   if (is.na(NA_character_)) 
[09:31:30.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.236]                     .init = FALSE)
[09:31:30.236]                 }
[09:31:30.236]             }
[09:31:30.236]         }
[09:31:30.236]     })
[09:31:30.236]     if (TRUE) {
[09:31:30.236]         base::sink(type = "output", split = FALSE)
[09:31:30.236]         if (TRUE) {
[09:31:30.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.236]         }
[09:31:30.236]         else {
[09:31:30.236]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.236]         }
[09:31:30.236]         base::close(...future.stdout)
[09:31:30.236]         ...future.stdout <- NULL
[09:31:30.236]     }
[09:31:30.236]     ...future.result$conditions <- ...future.conditions
[09:31:30.236]     ...future.result$finished <- base::Sys.time()
[09:31:30.236]     ...future.result
[09:31:30.236] }
[09:31:30.238] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.239] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.239] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.239] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.239] MultisessionFuture started
[09:31:30.240] - Launch lazy future ... done
[09:31:30.240] run() for ‘MultisessionFuture’ ... done
[09:31:30.240] result() for ClusterFuture ...
[09:31:30.240] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.240] - Validating connection of MultisessionFuture
[09:31:30.241] - received message: FutureResult
[09:31:30.241] - Received FutureResult
[09:31:30.241] - Erased future from FutureRegistry
[09:31:30.241] result() for ClusterFuture ...
[09:31:30.241] - result already collected: FutureResult
[09:31:30.241] result() for ClusterFuture ... done
[09:31:30.241] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.241] result() for ClusterFuture ... done
[09:31:30.242] result() for ClusterFuture ...
[09:31:30.242] - result already collected: FutureResult
[09:31:30.242] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.242] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.242] Searching for globals...
[09:31:30.244] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.244] Searching for globals ... DONE
[09:31:30.244] Resolving globals: TRUE
[09:31:30.244] Resolving any globals that are futures ...
[09:31:30.244] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.244] Resolving any globals that are futures ... DONE
[09:31:30.245] Resolving futures part of globals (recursively) ...
[09:31:30.245] resolve() on list ...
[09:31:30.245]  recursive: 99
[09:31:30.245]  length: 1
[09:31:30.245]  elements: ‘x’
[09:31:30.245]  length: 0 (resolved future 1)
[09:31:30.245] resolve() on list ... DONE
[09:31:30.246] - globals: [1] ‘x’
[09:31:30.246] Resolving futures part of globals (recursively) ... DONE
[09:31:30.246] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.246] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.246] - globals: [1] ‘x’
[09:31:30.246] 
[09:31:30.246] getGlobalsAndPackages() ... DONE
[09:31:30.247] run() for ‘Future’ ...
[09:31:30.247] - state: ‘created’
[09:31:30.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.261]   - Field: ‘node’
[09:31:30.261]   - Field: ‘label’
[09:31:30.261]   - Field: ‘local’
[09:31:30.261]   - Field: ‘owner’
[09:31:30.261]   - Field: ‘envir’
[09:31:30.261]   - Field: ‘workers’
[09:31:30.261]   - Field: ‘packages’
[09:31:30.261]   - Field: ‘gc’
[09:31:30.261]   - Field: ‘conditions’
[09:31:30.261]   - Field: ‘persistent’
[09:31:30.262]   - Field: ‘expr’
[09:31:30.262]   - Field: ‘uuid’
[09:31:30.262]   - Field: ‘seed’
[09:31:30.262]   - Field: ‘version’
[09:31:30.262]   - Field: ‘result’
[09:31:30.262]   - Field: ‘asynchronous’
[09:31:30.262]   - Field: ‘calls’
[09:31:30.262]   - Field: ‘globals’
[09:31:30.262]   - Field: ‘stdout’
[09:31:30.262]   - Field: ‘earlySignal’
[09:31:30.262]   - Field: ‘lazy’
[09:31:30.263]   - Field: ‘state’
[09:31:30.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.263] - Launch lazy future ...
[09:31:30.263] Packages needed by the future expression (n = 0): <none>
[09:31:30.263] Packages needed by future strategies (n = 0): <none>
[09:31:30.263] {
[09:31:30.263]     {
[09:31:30.263]         {
[09:31:30.263]             ...future.startTime <- base::Sys.time()
[09:31:30.263]             {
[09:31:30.263]                 {
[09:31:30.263]                   {
[09:31:30.263]                     {
[09:31:30.263]                       base::local({
[09:31:30.263]                         has_future <- base::requireNamespace("future", 
[09:31:30.263]                           quietly = TRUE)
[09:31:30.263]                         if (has_future) {
[09:31:30.263]                           ns <- base::getNamespace("future")
[09:31:30.263]                           version <- ns[[".package"]][["version"]]
[09:31:30.263]                           if (is.null(version)) 
[09:31:30.263]                             version <- utils::packageVersion("future")
[09:31:30.263]                         }
[09:31:30.263]                         else {
[09:31:30.263]                           version <- NULL
[09:31:30.263]                         }
[09:31:30.263]                         if (!has_future || version < "1.8.0") {
[09:31:30.263]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.263]                             "", base::R.version$version.string), 
[09:31:30.263]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.263]                               "release", "version")], collapse = " "), 
[09:31:30.263]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.263]                             info)
[09:31:30.263]                           info <- base::paste(info, collapse = "; ")
[09:31:30.263]                           if (!has_future) {
[09:31:30.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.263]                               info)
[09:31:30.263]                           }
[09:31:30.263]                           else {
[09:31:30.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.263]                               info, version)
[09:31:30.263]                           }
[09:31:30.263]                           base::stop(msg)
[09:31:30.263]                         }
[09:31:30.263]                       })
[09:31:30.263]                     }
[09:31:30.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.263]                     base::options(mc.cores = 1L)
[09:31:30.263]                   }
[09:31:30.263]                   ...future.strategy.old <- future::plan("list")
[09:31:30.263]                   options(future.plan = NULL)
[09:31:30.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.263]                 }
[09:31:30.263]                 ...future.workdir <- getwd()
[09:31:30.263]             }
[09:31:30.263]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.263]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.263]         }
[09:31:30.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.263]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.263]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.263]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.263]             base::names(...future.oldOptions))
[09:31:30.263]     }
[09:31:30.263]     if (FALSE) {
[09:31:30.263]     }
[09:31:30.263]     else {
[09:31:30.263]         if (TRUE) {
[09:31:30.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.263]                 open = "w")
[09:31:30.263]         }
[09:31:30.263]         else {
[09:31:30.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.263]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.263]         }
[09:31:30.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.263]             base::sink(type = "output", split = FALSE)
[09:31:30.263]             base::close(...future.stdout)
[09:31:30.263]         }, add = TRUE)
[09:31:30.263]     }
[09:31:30.263]     ...future.frame <- base::sys.nframe()
[09:31:30.263]     ...future.conditions <- base::list()
[09:31:30.263]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.263]     if (FALSE) {
[09:31:30.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.263]     }
[09:31:30.263]     ...future.result <- base::tryCatch({
[09:31:30.263]         base::withCallingHandlers({
[09:31:30.263]             ...future.value <- base::withVisible(base::local({
[09:31:30.263]                 ...future.makeSendCondition <- base::local({
[09:31:30.263]                   sendCondition <- NULL
[09:31:30.263]                   function(frame = 1L) {
[09:31:30.263]                     if (is.function(sendCondition)) 
[09:31:30.263]                       return(sendCondition)
[09:31:30.263]                     ns <- getNamespace("parallel")
[09:31:30.263]                     if (exists("sendData", mode = "function", 
[09:31:30.263]                       envir = ns)) {
[09:31:30.263]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.263]                         envir = ns)
[09:31:30.263]                       envir <- sys.frame(frame)
[09:31:30.263]                       master <- NULL
[09:31:30.263]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.263]                         !identical(envir, emptyenv())) {
[09:31:30.263]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.263]                           inherits = FALSE)) {
[09:31:30.263]                           master <- get("master", mode = "list", 
[09:31:30.263]                             envir = envir, inherits = FALSE)
[09:31:30.263]                           if (inherits(master, c("SOCKnode", 
[09:31:30.263]                             "SOCK0node"))) {
[09:31:30.263]                             sendCondition <<- function(cond) {
[09:31:30.263]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.263]                                 success = TRUE)
[09:31:30.263]                               parallel_sendData(master, data)
[09:31:30.263]                             }
[09:31:30.263]                             return(sendCondition)
[09:31:30.263]                           }
[09:31:30.263]                         }
[09:31:30.263]                         frame <- frame + 1L
[09:31:30.263]                         envir <- sys.frame(frame)
[09:31:30.263]                       }
[09:31:30.263]                     }
[09:31:30.263]                     sendCondition <<- function(cond) NULL
[09:31:30.263]                   }
[09:31:30.263]                 })
[09:31:30.263]                 withCallingHandlers({
[09:31:30.263]                   {
[09:31:30.263]                     x[["a"]] <- 1
[09:31:30.263]                     x
[09:31:30.263]                   }
[09:31:30.263]                 }, immediateCondition = function(cond) {
[09:31:30.263]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.263]                   sendCondition(cond)
[09:31:30.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.263]                   {
[09:31:30.263]                     inherits <- base::inherits
[09:31:30.263]                     invokeRestart <- base::invokeRestart
[09:31:30.263]                     is.null <- base::is.null
[09:31:30.263]                     muffled <- FALSE
[09:31:30.263]                     if (inherits(cond, "message")) {
[09:31:30.263]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.263]                       if (muffled) 
[09:31:30.263]                         invokeRestart("muffleMessage")
[09:31:30.263]                     }
[09:31:30.263]                     else if (inherits(cond, "warning")) {
[09:31:30.263]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.263]                       if (muffled) 
[09:31:30.263]                         invokeRestart("muffleWarning")
[09:31:30.263]                     }
[09:31:30.263]                     else if (inherits(cond, "condition")) {
[09:31:30.263]                       if (!is.null(pattern)) {
[09:31:30.263]                         computeRestarts <- base::computeRestarts
[09:31:30.263]                         grepl <- base::grepl
[09:31:30.263]                         restarts <- computeRestarts(cond)
[09:31:30.263]                         for (restart in restarts) {
[09:31:30.263]                           name <- restart$name
[09:31:30.263]                           if (is.null(name)) 
[09:31:30.263]                             next
[09:31:30.263]                           if (!grepl(pattern, name)) 
[09:31:30.263]                             next
[09:31:30.263]                           invokeRestart(restart)
[09:31:30.263]                           muffled <- TRUE
[09:31:30.263]                           break
[09:31:30.263]                         }
[09:31:30.263]                       }
[09:31:30.263]                     }
[09:31:30.263]                     invisible(muffled)
[09:31:30.263]                   }
[09:31:30.263]                   muffleCondition(cond)
[09:31:30.263]                 })
[09:31:30.263]             }))
[09:31:30.263]             future::FutureResult(value = ...future.value$value, 
[09:31:30.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.263]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.263]                     ...future.globalenv.names))
[09:31:30.263]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.263]         }, condition = base::local({
[09:31:30.263]             c <- base::c
[09:31:30.263]             inherits <- base::inherits
[09:31:30.263]             invokeRestart <- base::invokeRestart
[09:31:30.263]             length <- base::length
[09:31:30.263]             list <- base::list
[09:31:30.263]             seq.int <- base::seq.int
[09:31:30.263]             signalCondition <- base::signalCondition
[09:31:30.263]             sys.calls <- base::sys.calls
[09:31:30.263]             `[[` <- base::`[[`
[09:31:30.263]             `+` <- base::`+`
[09:31:30.263]             `<<-` <- base::`<<-`
[09:31:30.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.263]                   3L)]
[09:31:30.263]             }
[09:31:30.263]             function(cond) {
[09:31:30.263]                 is_error <- inherits(cond, "error")
[09:31:30.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.263]                   NULL)
[09:31:30.263]                 if (is_error) {
[09:31:30.263]                   sessionInformation <- function() {
[09:31:30.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.263]                       search = base::search(), system = base::Sys.info())
[09:31:30.263]                   }
[09:31:30.263]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.263]                     cond$call), session = sessionInformation(), 
[09:31:30.263]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.263]                   signalCondition(cond)
[09:31:30.263]                 }
[09:31:30.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.263]                 "immediateCondition"))) {
[09:31:30.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.263]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.263]                   if (TRUE && !signal) {
[09:31:30.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.263]                     {
[09:31:30.263]                       inherits <- base::inherits
[09:31:30.263]                       invokeRestart <- base::invokeRestart
[09:31:30.263]                       is.null <- base::is.null
[09:31:30.263]                       muffled <- FALSE
[09:31:30.263]                       if (inherits(cond, "message")) {
[09:31:30.263]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.263]                         if (muffled) 
[09:31:30.263]                           invokeRestart("muffleMessage")
[09:31:30.263]                       }
[09:31:30.263]                       else if (inherits(cond, "warning")) {
[09:31:30.263]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.263]                         if (muffled) 
[09:31:30.263]                           invokeRestart("muffleWarning")
[09:31:30.263]                       }
[09:31:30.263]                       else if (inherits(cond, "condition")) {
[09:31:30.263]                         if (!is.null(pattern)) {
[09:31:30.263]                           computeRestarts <- base::computeRestarts
[09:31:30.263]                           grepl <- base::grepl
[09:31:30.263]                           restarts <- computeRestarts(cond)
[09:31:30.263]                           for (restart in restarts) {
[09:31:30.263]                             name <- restart$name
[09:31:30.263]                             if (is.null(name)) 
[09:31:30.263]                               next
[09:31:30.263]                             if (!grepl(pattern, name)) 
[09:31:30.263]                               next
[09:31:30.263]                             invokeRestart(restart)
[09:31:30.263]                             muffled <- TRUE
[09:31:30.263]                             break
[09:31:30.263]                           }
[09:31:30.263]                         }
[09:31:30.263]                       }
[09:31:30.263]                       invisible(muffled)
[09:31:30.263]                     }
[09:31:30.263]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.263]                   }
[09:31:30.263]                 }
[09:31:30.263]                 else {
[09:31:30.263]                   if (TRUE) {
[09:31:30.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.263]                     {
[09:31:30.263]                       inherits <- base::inherits
[09:31:30.263]                       invokeRestart <- base::invokeRestart
[09:31:30.263]                       is.null <- base::is.null
[09:31:30.263]                       muffled <- FALSE
[09:31:30.263]                       if (inherits(cond, "message")) {
[09:31:30.263]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.263]                         if (muffled) 
[09:31:30.263]                           invokeRestart("muffleMessage")
[09:31:30.263]                       }
[09:31:30.263]                       else if (inherits(cond, "warning")) {
[09:31:30.263]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.263]                         if (muffled) 
[09:31:30.263]                           invokeRestart("muffleWarning")
[09:31:30.263]                       }
[09:31:30.263]                       else if (inherits(cond, "condition")) {
[09:31:30.263]                         if (!is.null(pattern)) {
[09:31:30.263]                           computeRestarts <- base::computeRestarts
[09:31:30.263]                           grepl <- base::grepl
[09:31:30.263]                           restarts <- computeRestarts(cond)
[09:31:30.263]                           for (restart in restarts) {
[09:31:30.263]                             name <- restart$name
[09:31:30.263]                             if (is.null(name)) 
[09:31:30.263]                               next
[09:31:30.263]                             if (!grepl(pattern, name)) 
[09:31:30.263]                               next
[09:31:30.263]                             invokeRestart(restart)
[09:31:30.263]                             muffled <- TRUE
[09:31:30.263]                             break
[09:31:30.263]                           }
[09:31:30.263]                         }
[09:31:30.263]                       }
[09:31:30.263]                       invisible(muffled)
[09:31:30.263]                     }
[09:31:30.263]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.263]                   }
[09:31:30.263]                 }
[09:31:30.263]             }
[09:31:30.263]         }))
[09:31:30.263]     }, error = function(ex) {
[09:31:30.263]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.263]                 ...future.rng), started = ...future.startTime, 
[09:31:30.263]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.263]             version = "1.8"), class = "FutureResult")
[09:31:30.263]     }, finally = {
[09:31:30.263]         if (!identical(...future.workdir, getwd())) 
[09:31:30.263]             setwd(...future.workdir)
[09:31:30.263]         {
[09:31:30.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.263]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.263]             }
[09:31:30.263]             base::options(...future.oldOptions)
[09:31:30.263]             if (.Platform$OS.type == "windows") {
[09:31:30.263]                 old_names <- names(...future.oldEnvVars)
[09:31:30.263]                 envs <- base::Sys.getenv()
[09:31:30.263]                 names <- names(envs)
[09:31:30.263]                 common <- intersect(names, old_names)
[09:31:30.263]                 added <- setdiff(names, old_names)
[09:31:30.263]                 removed <- setdiff(old_names, names)
[09:31:30.263]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.263]                   envs[common]]
[09:31:30.263]                 NAMES <- toupper(changed)
[09:31:30.263]                 args <- list()
[09:31:30.263]                 for (kk in seq_along(NAMES)) {
[09:31:30.263]                   name <- changed[[kk]]
[09:31:30.263]                   NAME <- NAMES[[kk]]
[09:31:30.263]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.263]                     next
[09:31:30.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.263]                 }
[09:31:30.263]                 NAMES <- toupper(added)
[09:31:30.263]                 for (kk in seq_along(NAMES)) {
[09:31:30.263]                   name <- added[[kk]]
[09:31:30.263]                   NAME <- NAMES[[kk]]
[09:31:30.263]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.263]                     next
[09:31:30.263]                   args[[name]] <- ""
[09:31:30.263]                 }
[09:31:30.263]                 NAMES <- toupper(removed)
[09:31:30.263]                 for (kk in seq_along(NAMES)) {
[09:31:30.263]                   name <- removed[[kk]]
[09:31:30.263]                   NAME <- NAMES[[kk]]
[09:31:30.263]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.263]                     next
[09:31:30.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.263]                 }
[09:31:30.263]                 if (length(args) > 0) 
[09:31:30.263]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.263]             }
[09:31:30.263]             else {
[09:31:30.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.263]             }
[09:31:30.263]             {
[09:31:30.263]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.263]                   0L) {
[09:31:30.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.263]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.263]                   base::options(opts)
[09:31:30.263]                 }
[09:31:30.263]                 {
[09:31:30.263]                   {
[09:31:30.263]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.263]                     NULL
[09:31:30.263]                   }
[09:31:30.263]                   options(future.plan = NULL)
[09:31:30.263]                   if (is.na(NA_character_)) 
[09:31:30.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.263]                     .init = FALSE)
[09:31:30.263]                 }
[09:31:30.263]             }
[09:31:30.263]         }
[09:31:30.263]     })
[09:31:30.263]     if (TRUE) {
[09:31:30.263]         base::sink(type = "output", split = FALSE)
[09:31:30.263]         if (TRUE) {
[09:31:30.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.263]         }
[09:31:30.263]         else {
[09:31:30.263]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.263]         }
[09:31:30.263]         base::close(...future.stdout)
[09:31:30.263]         ...future.stdout <- NULL
[09:31:30.263]     }
[09:31:30.263]     ...future.result$conditions <- ...future.conditions
[09:31:30.263]     ...future.result$finished <- base::Sys.time()
[09:31:30.263]     ...future.result
[09:31:30.263] }
[09:31:30.266] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.266] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.267] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.267] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.267] MultisessionFuture started
[09:31:30.267] - Launch lazy future ... done
[09:31:30.267] run() for ‘MultisessionFuture’ ... done
[09:31:30.268] result() for ClusterFuture ...
[09:31:30.268] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.268] - Validating connection of MultisessionFuture
[09:31:30.269] - received message: FutureResult
[09:31:30.269] - Received FutureResult
[09:31:30.269] - Erased future from FutureRegistry
[09:31:30.269] result() for ClusterFuture ...
[09:31:30.269] - result already collected: FutureResult
[09:31:30.269] result() for ClusterFuture ... done
[09:31:30.270] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.270] result() for ClusterFuture ... done
[09:31:30.270] result() for ClusterFuture ...
[09:31:30.270] - result already collected: FutureResult
[09:31:30.270] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.270] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.271] Searching for globals...
[09:31:30.272] - globals found: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.273] Searching for globals ... DONE
[09:31:30.273] Resolving globals: TRUE
[09:31:30.273] Resolving any globals that are futures ...
[09:31:30.273] - globals: [5] ‘{’, ‘x’, ‘<-’, ‘[[’, ‘[[<-’
[09:31:30.273] Resolving any globals that are futures ... DONE
[09:31:30.273] Resolving futures part of globals (recursively) ...
[09:31:30.274] resolve() on list ...
[09:31:30.274]  recursive: 99
[09:31:30.274]  length: 1
[09:31:30.274]  elements: ‘x’
[09:31:30.274]  length: 0 (resolved future 1)
[09:31:30.274] resolve() on list ... DONE
[09:31:30.274] - globals: [1] ‘x’
[09:31:30.274] Resolving futures part of globals (recursively) ... DONE
[09:31:30.274] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.275] The total size of the 1 globals exported for future expression (‘{; x[["a"]] <- 1; x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.275] - globals: [1] ‘x’
[09:31:30.275] 
[09:31:30.275] getGlobalsAndPackages() ... DONE
[09:31:30.279] run() for ‘Future’ ...
[09:31:30.280] - state: ‘created’
[09:31:30.280] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.293] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.293] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.293]   - Field: ‘node’
[09:31:30.293]   - Field: ‘label’
[09:31:30.294]   - Field: ‘local’
[09:31:30.294]   - Field: ‘owner’
[09:31:30.294]   - Field: ‘envir’
[09:31:30.294]   - Field: ‘workers’
[09:31:30.294]   - Field: ‘packages’
[09:31:30.294]   - Field: ‘gc’
[09:31:30.294]   - Field: ‘conditions’
[09:31:30.294]   - Field: ‘persistent’
[09:31:30.294]   - Field: ‘expr’
[09:31:30.294]   - Field: ‘uuid’
[09:31:30.294]   - Field: ‘seed’
[09:31:30.294]   - Field: ‘version’
[09:31:30.295]   - Field: ‘result’
[09:31:30.295]   - Field: ‘asynchronous’
[09:31:30.295]   - Field: ‘calls’
[09:31:30.295]   - Field: ‘globals’
[09:31:30.295]   - Field: ‘stdout’
[09:31:30.295]   - Field: ‘earlySignal’
[09:31:30.295]   - Field: ‘lazy’
[09:31:30.295]   - Field: ‘state’
[09:31:30.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.295] - Launch lazy future ...
[09:31:30.296] Packages needed by the future expression (n = 0): <none>
[09:31:30.296] Packages needed by future strategies (n = 0): <none>
[09:31:30.296] {
[09:31:30.296]     {
[09:31:30.296]         {
[09:31:30.296]             ...future.startTime <- base::Sys.time()
[09:31:30.296]             {
[09:31:30.296]                 {
[09:31:30.296]                   {
[09:31:30.296]                     {
[09:31:30.296]                       base::local({
[09:31:30.296]                         has_future <- base::requireNamespace("future", 
[09:31:30.296]                           quietly = TRUE)
[09:31:30.296]                         if (has_future) {
[09:31:30.296]                           ns <- base::getNamespace("future")
[09:31:30.296]                           version <- ns[[".package"]][["version"]]
[09:31:30.296]                           if (is.null(version)) 
[09:31:30.296]                             version <- utils::packageVersion("future")
[09:31:30.296]                         }
[09:31:30.296]                         else {
[09:31:30.296]                           version <- NULL
[09:31:30.296]                         }
[09:31:30.296]                         if (!has_future || version < "1.8.0") {
[09:31:30.296]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.296]                             "", base::R.version$version.string), 
[09:31:30.296]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.296]                               "release", "version")], collapse = " "), 
[09:31:30.296]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.296]                             info)
[09:31:30.296]                           info <- base::paste(info, collapse = "; ")
[09:31:30.296]                           if (!has_future) {
[09:31:30.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.296]                               info)
[09:31:30.296]                           }
[09:31:30.296]                           else {
[09:31:30.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.296]                               info, version)
[09:31:30.296]                           }
[09:31:30.296]                           base::stop(msg)
[09:31:30.296]                         }
[09:31:30.296]                       })
[09:31:30.296]                     }
[09:31:30.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.296]                     base::options(mc.cores = 1L)
[09:31:30.296]                   }
[09:31:30.296]                   ...future.strategy.old <- future::plan("list")
[09:31:30.296]                   options(future.plan = NULL)
[09:31:30.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.296]                 }
[09:31:30.296]                 ...future.workdir <- getwd()
[09:31:30.296]             }
[09:31:30.296]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.296]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.296]         }
[09:31:30.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.296]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.296]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.296]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.296]             base::names(...future.oldOptions))
[09:31:30.296]     }
[09:31:30.296]     if (FALSE) {
[09:31:30.296]     }
[09:31:30.296]     else {
[09:31:30.296]         if (TRUE) {
[09:31:30.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.296]                 open = "w")
[09:31:30.296]         }
[09:31:30.296]         else {
[09:31:30.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.296]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.296]         }
[09:31:30.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.296]             base::sink(type = "output", split = FALSE)
[09:31:30.296]             base::close(...future.stdout)
[09:31:30.296]         }, add = TRUE)
[09:31:30.296]     }
[09:31:30.296]     ...future.frame <- base::sys.nframe()
[09:31:30.296]     ...future.conditions <- base::list()
[09:31:30.296]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.296]     if (FALSE) {
[09:31:30.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.296]     }
[09:31:30.296]     ...future.result <- base::tryCatch({
[09:31:30.296]         base::withCallingHandlers({
[09:31:30.296]             ...future.value <- base::withVisible(base::local({
[09:31:30.296]                 ...future.makeSendCondition <- base::local({
[09:31:30.296]                   sendCondition <- NULL
[09:31:30.296]                   function(frame = 1L) {
[09:31:30.296]                     if (is.function(sendCondition)) 
[09:31:30.296]                       return(sendCondition)
[09:31:30.296]                     ns <- getNamespace("parallel")
[09:31:30.296]                     if (exists("sendData", mode = "function", 
[09:31:30.296]                       envir = ns)) {
[09:31:30.296]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.296]                         envir = ns)
[09:31:30.296]                       envir <- sys.frame(frame)
[09:31:30.296]                       master <- NULL
[09:31:30.296]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.296]                         !identical(envir, emptyenv())) {
[09:31:30.296]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.296]                           inherits = FALSE)) {
[09:31:30.296]                           master <- get("master", mode = "list", 
[09:31:30.296]                             envir = envir, inherits = FALSE)
[09:31:30.296]                           if (inherits(master, c("SOCKnode", 
[09:31:30.296]                             "SOCK0node"))) {
[09:31:30.296]                             sendCondition <<- function(cond) {
[09:31:30.296]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.296]                                 success = TRUE)
[09:31:30.296]                               parallel_sendData(master, data)
[09:31:30.296]                             }
[09:31:30.296]                             return(sendCondition)
[09:31:30.296]                           }
[09:31:30.296]                         }
[09:31:30.296]                         frame <- frame + 1L
[09:31:30.296]                         envir <- sys.frame(frame)
[09:31:30.296]                       }
[09:31:30.296]                     }
[09:31:30.296]                     sendCondition <<- function(cond) NULL
[09:31:30.296]                   }
[09:31:30.296]                 })
[09:31:30.296]                 withCallingHandlers({
[09:31:30.296]                   {
[09:31:30.296]                     x[["a"]] <- 1
[09:31:30.296]                     x
[09:31:30.296]                   }
[09:31:30.296]                 }, immediateCondition = function(cond) {
[09:31:30.296]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.296]                   sendCondition(cond)
[09:31:30.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.296]                   {
[09:31:30.296]                     inherits <- base::inherits
[09:31:30.296]                     invokeRestart <- base::invokeRestart
[09:31:30.296]                     is.null <- base::is.null
[09:31:30.296]                     muffled <- FALSE
[09:31:30.296]                     if (inherits(cond, "message")) {
[09:31:30.296]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.296]                       if (muffled) 
[09:31:30.296]                         invokeRestart("muffleMessage")
[09:31:30.296]                     }
[09:31:30.296]                     else if (inherits(cond, "warning")) {
[09:31:30.296]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.296]                       if (muffled) 
[09:31:30.296]                         invokeRestart("muffleWarning")
[09:31:30.296]                     }
[09:31:30.296]                     else if (inherits(cond, "condition")) {
[09:31:30.296]                       if (!is.null(pattern)) {
[09:31:30.296]                         computeRestarts <- base::computeRestarts
[09:31:30.296]                         grepl <- base::grepl
[09:31:30.296]                         restarts <- computeRestarts(cond)
[09:31:30.296]                         for (restart in restarts) {
[09:31:30.296]                           name <- restart$name
[09:31:30.296]                           if (is.null(name)) 
[09:31:30.296]                             next
[09:31:30.296]                           if (!grepl(pattern, name)) 
[09:31:30.296]                             next
[09:31:30.296]                           invokeRestart(restart)
[09:31:30.296]                           muffled <- TRUE
[09:31:30.296]                           break
[09:31:30.296]                         }
[09:31:30.296]                       }
[09:31:30.296]                     }
[09:31:30.296]                     invisible(muffled)
[09:31:30.296]                   }
[09:31:30.296]                   muffleCondition(cond)
[09:31:30.296]                 })
[09:31:30.296]             }))
[09:31:30.296]             future::FutureResult(value = ...future.value$value, 
[09:31:30.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.296]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.296]                     ...future.globalenv.names))
[09:31:30.296]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.296]         }, condition = base::local({
[09:31:30.296]             c <- base::c
[09:31:30.296]             inherits <- base::inherits
[09:31:30.296]             invokeRestart <- base::invokeRestart
[09:31:30.296]             length <- base::length
[09:31:30.296]             list <- base::list
[09:31:30.296]             seq.int <- base::seq.int
[09:31:30.296]             signalCondition <- base::signalCondition
[09:31:30.296]             sys.calls <- base::sys.calls
[09:31:30.296]             `[[` <- base::`[[`
[09:31:30.296]             `+` <- base::`+`
[09:31:30.296]             `<<-` <- base::`<<-`
[09:31:30.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.296]                   3L)]
[09:31:30.296]             }
[09:31:30.296]             function(cond) {
[09:31:30.296]                 is_error <- inherits(cond, "error")
[09:31:30.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.296]                   NULL)
[09:31:30.296]                 if (is_error) {
[09:31:30.296]                   sessionInformation <- function() {
[09:31:30.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.296]                       search = base::search(), system = base::Sys.info())
[09:31:30.296]                   }
[09:31:30.296]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.296]                     cond$call), session = sessionInformation(), 
[09:31:30.296]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.296]                   signalCondition(cond)
[09:31:30.296]                 }
[09:31:30.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.296]                 "immediateCondition"))) {
[09:31:30.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.296]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.296]                   if (TRUE && !signal) {
[09:31:30.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.296]                     {
[09:31:30.296]                       inherits <- base::inherits
[09:31:30.296]                       invokeRestart <- base::invokeRestart
[09:31:30.296]                       is.null <- base::is.null
[09:31:30.296]                       muffled <- FALSE
[09:31:30.296]                       if (inherits(cond, "message")) {
[09:31:30.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.296]                         if (muffled) 
[09:31:30.296]                           invokeRestart("muffleMessage")
[09:31:30.296]                       }
[09:31:30.296]                       else if (inherits(cond, "warning")) {
[09:31:30.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.296]                         if (muffled) 
[09:31:30.296]                           invokeRestart("muffleWarning")
[09:31:30.296]                       }
[09:31:30.296]                       else if (inherits(cond, "condition")) {
[09:31:30.296]                         if (!is.null(pattern)) {
[09:31:30.296]                           computeRestarts <- base::computeRestarts
[09:31:30.296]                           grepl <- base::grepl
[09:31:30.296]                           restarts <- computeRestarts(cond)
[09:31:30.296]                           for (restart in restarts) {
[09:31:30.296]                             name <- restart$name
[09:31:30.296]                             if (is.null(name)) 
[09:31:30.296]                               next
[09:31:30.296]                             if (!grepl(pattern, name)) 
[09:31:30.296]                               next
[09:31:30.296]                             invokeRestart(restart)
[09:31:30.296]                             muffled <- TRUE
[09:31:30.296]                             break
[09:31:30.296]                           }
[09:31:30.296]                         }
[09:31:30.296]                       }
[09:31:30.296]                       invisible(muffled)
[09:31:30.296]                     }
[09:31:30.296]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.296]                   }
[09:31:30.296]                 }
[09:31:30.296]                 else {
[09:31:30.296]                   if (TRUE) {
[09:31:30.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.296]                     {
[09:31:30.296]                       inherits <- base::inherits
[09:31:30.296]                       invokeRestart <- base::invokeRestart
[09:31:30.296]                       is.null <- base::is.null
[09:31:30.296]                       muffled <- FALSE
[09:31:30.296]                       if (inherits(cond, "message")) {
[09:31:30.296]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.296]                         if (muffled) 
[09:31:30.296]                           invokeRestart("muffleMessage")
[09:31:30.296]                       }
[09:31:30.296]                       else if (inherits(cond, "warning")) {
[09:31:30.296]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.296]                         if (muffled) 
[09:31:30.296]                           invokeRestart("muffleWarning")
[09:31:30.296]                       }
[09:31:30.296]                       else if (inherits(cond, "condition")) {
[09:31:30.296]                         if (!is.null(pattern)) {
[09:31:30.296]                           computeRestarts <- base::computeRestarts
[09:31:30.296]                           grepl <- base::grepl
[09:31:30.296]                           restarts <- computeRestarts(cond)
[09:31:30.296]                           for (restart in restarts) {
[09:31:30.296]                             name <- restart$name
[09:31:30.296]                             if (is.null(name)) 
[09:31:30.296]                               next
[09:31:30.296]                             if (!grepl(pattern, name)) 
[09:31:30.296]                               next
[09:31:30.296]                             invokeRestart(restart)
[09:31:30.296]                             muffled <- TRUE
[09:31:30.296]                             break
[09:31:30.296]                           }
[09:31:30.296]                         }
[09:31:30.296]                       }
[09:31:30.296]                       invisible(muffled)
[09:31:30.296]                     }
[09:31:30.296]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.296]                   }
[09:31:30.296]                 }
[09:31:30.296]             }
[09:31:30.296]         }))
[09:31:30.296]     }, error = function(ex) {
[09:31:30.296]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.296]                 ...future.rng), started = ...future.startTime, 
[09:31:30.296]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.296]             version = "1.8"), class = "FutureResult")
[09:31:30.296]     }, finally = {
[09:31:30.296]         if (!identical(...future.workdir, getwd())) 
[09:31:30.296]             setwd(...future.workdir)
[09:31:30.296]         {
[09:31:30.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.296]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.296]             }
[09:31:30.296]             base::options(...future.oldOptions)
[09:31:30.296]             if (.Platform$OS.type == "windows") {
[09:31:30.296]                 old_names <- names(...future.oldEnvVars)
[09:31:30.296]                 envs <- base::Sys.getenv()
[09:31:30.296]                 names <- names(envs)
[09:31:30.296]                 common <- intersect(names, old_names)
[09:31:30.296]                 added <- setdiff(names, old_names)
[09:31:30.296]                 removed <- setdiff(old_names, names)
[09:31:30.296]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.296]                   envs[common]]
[09:31:30.296]                 NAMES <- toupper(changed)
[09:31:30.296]                 args <- list()
[09:31:30.296]                 for (kk in seq_along(NAMES)) {
[09:31:30.296]                   name <- changed[[kk]]
[09:31:30.296]                   NAME <- NAMES[[kk]]
[09:31:30.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.296]                     next
[09:31:30.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.296]                 }
[09:31:30.296]                 NAMES <- toupper(added)
[09:31:30.296]                 for (kk in seq_along(NAMES)) {
[09:31:30.296]                   name <- added[[kk]]
[09:31:30.296]                   NAME <- NAMES[[kk]]
[09:31:30.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.296]                     next
[09:31:30.296]                   args[[name]] <- ""
[09:31:30.296]                 }
[09:31:30.296]                 NAMES <- toupper(removed)
[09:31:30.296]                 for (kk in seq_along(NAMES)) {
[09:31:30.296]                   name <- removed[[kk]]
[09:31:30.296]                   NAME <- NAMES[[kk]]
[09:31:30.296]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.296]                     next
[09:31:30.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.296]                 }
[09:31:30.296]                 if (length(args) > 0) 
[09:31:30.296]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.296]             }
[09:31:30.296]             else {
[09:31:30.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.296]             }
[09:31:30.296]             {
[09:31:30.296]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.296]                   0L) {
[09:31:30.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.296]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.296]                   base::options(opts)
[09:31:30.296]                 }
[09:31:30.296]                 {
[09:31:30.296]                   {
[09:31:30.296]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.296]                     NULL
[09:31:30.296]                   }
[09:31:30.296]                   options(future.plan = NULL)
[09:31:30.296]                   if (is.na(NA_character_)) 
[09:31:30.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.296]                     .init = FALSE)
[09:31:30.296]                 }
[09:31:30.296]             }
[09:31:30.296]         }
[09:31:30.296]     })
[09:31:30.296]     if (TRUE) {
[09:31:30.296]         base::sink(type = "output", split = FALSE)
[09:31:30.296]         if (TRUE) {
[09:31:30.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.296]         }
[09:31:30.296]         else {
[09:31:30.296]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.296]         }
[09:31:30.296]         base::close(...future.stdout)
[09:31:30.296]         ...future.stdout <- NULL
[09:31:30.296]     }
[09:31:30.296]     ...future.result$conditions <- ...future.conditions
[09:31:30.296]     ...future.result$finished <- base::Sys.time()
[09:31:30.296]     ...future.result
[09:31:30.296] }
[09:31:30.299] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.299] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.299] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.299] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.300] MultisessionFuture started
[09:31:30.300] - Launch lazy future ... done
[09:31:30.300] run() for ‘MultisessionFuture’ ... done
[09:31:30.300] result() for ClusterFuture ...
[09:31:30.300] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.300] - Validating connection of MultisessionFuture
[09:31:30.301] - received message: FutureResult
[09:31:30.301] - Received FutureResult
[09:31:30.301] - Erased future from FutureRegistry
[09:31:30.301] result() for ClusterFuture ...
[09:31:30.302] - result already collected: FutureResult
[09:31:30.302] result() for ClusterFuture ... done
[09:31:30.302] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.302] result() for ClusterFuture ... done
[09:31:30.302] result() for ClusterFuture ...
[09:31:30.302] - result already collected: FutureResult
[09:31:30.302] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.302] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.302] Searching for globals...
[09:31:30.304] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.305] Searching for globals ... DONE
[09:31:30.305] Resolving globals: TRUE
[09:31:30.305] Resolving any globals that are futures ...
[09:31:30.305] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.305] Resolving any globals that are futures ... DONE
[09:31:30.305] Resolving futures part of globals (recursively) ...
[09:31:30.306] resolve() on list ...
[09:31:30.306]  recursive: 99
[09:31:30.306]  length: 1
[09:31:30.306]  elements: ‘x’
[09:31:30.306]  length: 0 (resolved future 1)
[09:31:30.306] resolve() on list ... DONE
[09:31:30.306] - globals: [1] ‘x’
[09:31:30.306] Resolving futures part of globals (recursively) ... DONE
[09:31:30.306] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.307] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.307] - globals: [1] ‘x’
[09:31:30.307] 
[09:31:30.307] getGlobalsAndPackages() ... DONE
[09:31:30.307] run() for ‘Future’ ...
[09:31:30.307] - state: ‘created’
[09:31:30.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.320] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.321]   - Field: ‘node’
[09:31:30.321]   - Field: ‘label’
[09:31:30.321]   - Field: ‘local’
[09:31:30.321]   - Field: ‘owner’
[09:31:30.321]   - Field: ‘envir’
[09:31:30.321]   - Field: ‘workers’
[09:31:30.321]   - Field: ‘packages’
[09:31:30.321]   - Field: ‘gc’
[09:31:30.321]   - Field: ‘conditions’
[09:31:30.321]   - Field: ‘persistent’
[09:31:30.322]   - Field: ‘expr’
[09:31:30.322]   - Field: ‘uuid’
[09:31:30.322]   - Field: ‘seed’
[09:31:30.322]   - Field: ‘version’
[09:31:30.322]   - Field: ‘result’
[09:31:30.322]   - Field: ‘asynchronous’
[09:31:30.322]   - Field: ‘calls’
[09:31:30.322]   - Field: ‘globals’
[09:31:30.322]   - Field: ‘stdout’
[09:31:30.322]   - Field: ‘earlySignal’
[09:31:30.322]   - Field: ‘lazy’
[09:31:30.323]   - Field: ‘state’
[09:31:30.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.323] - Launch lazy future ...
[09:31:30.323] Packages needed by the future expression (n = 0): <none>
[09:31:30.323] Packages needed by future strategies (n = 0): <none>
[09:31:30.323] {
[09:31:30.323]     {
[09:31:30.323]         {
[09:31:30.323]             ...future.startTime <- base::Sys.time()
[09:31:30.323]             {
[09:31:30.323]                 {
[09:31:30.323]                   {
[09:31:30.323]                     {
[09:31:30.323]                       base::local({
[09:31:30.323]                         has_future <- base::requireNamespace("future", 
[09:31:30.323]                           quietly = TRUE)
[09:31:30.323]                         if (has_future) {
[09:31:30.323]                           ns <- base::getNamespace("future")
[09:31:30.323]                           version <- ns[[".package"]][["version"]]
[09:31:30.323]                           if (is.null(version)) 
[09:31:30.323]                             version <- utils::packageVersion("future")
[09:31:30.323]                         }
[09:31:30.323]                         else {
[09:31:30.323]                           version <- NULL
[09:31:30.323]                         }
[09:31:30.323]                         if (!has_future || version < "1.8.0") {
[09:31:30.323]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.323]                             "", base::R.version$version.string), 
[09:31:30.323]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.323]                               "release", "version")], collapse = " "), 
[09:31:30.323]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.323]                             info)
[09:31:30.323]                           info <- base::paste(info, collapse = "; ")
[09:31:30.323]                           if (!has_future) {
[09:31:30.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.323]                               info)
[09:31:30.323]                           }
[09:31:30.323]                           else {
[09:31:30.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.323]                               info, version)
[09:31:30.323]                           }
[09:31:30.323]                           base::stop(msg)
[09:31:30.323]                         }
[09:31:30.323]                       })
[09:31:30.323]                     }
[09:31:30.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.323]                     base::options(mc.cores = 1L)
[09:31:30.323]                   }
[09:31:30.323]                   ...future.strategy.old <- future::plan("list")
[09:31:30.323]                   options(future.plan = NULL)
[09:31:30.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.323]                 }
[09:31:30.323]                 ...future.workdir <- getwd()
[09:31:30.323]             }
[09:31:30.323]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.323]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.323]         }
[09:31:30.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.323]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.323]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.323]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.323]             base::names(...future.oldOptions))
[09:31:30.323]     }
[09:31:30.323]     if (FALSE) {
[09:31:30.323]     }
[09:31:30.323]     else {
[09:31:30.323]         if (TRUE) {
[09:31:30.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.323]                 open = "w")
[09:31:30.323]         }
[09:31:30.323]         else {
[09:31:30.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.323]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.323]         }
[09:31:30.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.323]             base::sink(type = "output", split = FALSE)
[09:31:30.323]             base::close(...future.stdout)
[09:31:30.323]         }, add = TRUE)
[09:31:30.323]     }
[09:31:30.323]     ...future.frame <- base::sys.nframe()
[09:31:30.323]     ...future.conditions <- base::list()
[09:31:30.323]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.323]     if (FALSE) {
[09:31:30.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.323]     }
[09:31:30.323]     ...future.result <- base::tryCatch({
[09:31:30.323]         base::withCallingHandlers({
[09:31:30.323]             ...future.value <- base::withVisible(base::local({
[09:31:30.323]                 ...future.makeSendCondition <- base::local({
[09:31:30.323]                   sendCondition <- NULL
[09:31:30.323]                   function(frame = 1L) {
[09:31:30.323]                     if (is.function(sendCondition)) 
[09:31:30.323]                       return(sendCondition)
[09:31:30.323]                     ns <- getNamespace("parallel")
[09:31:30.323]                     if (exists("sendData", mode = "function", 
[09:31:30.323]                       envir = ns)) {
[09:31:30.323]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.323]                         envir = ns)
[09:31:30.323]                       envir <- sys.frame(frame)
[09:31:30.323]                       master <- NULL
[09:31:30.323]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.323]                         !identical(envir, emptyenv())) {
[09:31:30.323]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.323]                           inherits = FALSE)) {
[09:31:30.323]                           master <- get("master", mode = "list", 
[09:31:30.323]                             envir = envir, inherits = FALSE)
[09:31:30.323]                           if (inherits(master, c("SOCKnode", 
[09:31:30.323]                             "SOCK0node"))) {
[09:31:30.323]                             sendCondition <<- function(cond) {
[09:31:30.323]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.323]                                 success = TRUE)
[09:31:30.323]                               parallel_sendData(master, data)
[09:31:30.323]                             }
[09:31:30.323]                             return(sendCondition)
[09:31:30.323]                           }
[09:31:30.323]                         }
[09:31:30.323]                         frame <- frame + 1L
[09:31:30.323]                         envir <- sys.frame(frame)
[09:31:30.323]                       }
[09:31:30.323]                     }
[09:31:30.323]                     sendCondition <<- function(cond) NULL
[09:31:30.323]                   }
[09:31:30.323]                 })
[09:31:30.323]                 withCallingHandlers({
[09:31:30.323]                   {
[09:31:30.323]                     x["a"] <- list(1)
[09:31:30.323]                     x
[09:31:30.323]                   }
[09:31:30.323]                 }, immediateCondition = function(cond) {
[09:31:30.323]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.323]                   sendCondition(cond)
[09:31:30.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.323]                   {
[09:31:30.323]                     inherits <- base::inherits
[09:31:30.323]                     invokeRestart <- base::invokeRestart
[09:31:30.323]                     is.null <- base::is.null
[09:31:30.323]                     muffled <- FALSE
[09:31:30.323]                     if (inherits(cond, "message")) {
[09:31:30.323]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.323]                       if (muffled) 
[09:31:30.323]                         invokeRestart("muffleMessage")
[09:31:30.323]                     }
[09:31:30.323]                     else if (inherits(cond, "warning")) {
[09:31:30.323]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.323]                       if (muffled) 
[09:31:30.323]                         invokeRestart("muffleWarning")
[09:31:30.323]                     }
[09:31:30.323]                     else if (inherits(cond, "condition")) {
[09:31:30.323]                       if (!is.null(pattern)) {
[09:31:30.323]                         computeRestarts <- base::computeRestarts
[09:31:30.323]                         grepl <- base::grepl
[09:31:30.323]                         restarts <- computeRestarts(cond)
[09:31:30.323]                         for (restart in restarts) {
[09:31:30.323]                           name <- restart$name
[09:31:30.323]                           if (is.null(name)) 
[09:31:30.323]                             next
[09:31:30.323]                           if (!grepl(pattern, name)) 
[09:31:30.323]                             next
[09:31:30.323]                           invokeRestart(restart)
[09:31:30.323]                           muffled <- TRUE
[09:31:30.323]                           break
[09:31:30.323]                         }
[09:31:30.323]                       }
[09:31:30.323]                     }
[09:31:30.323]                     invisible(muffled)
[09:31:30.323]                   }
[09:31:30.323]                   muffleCondition(cond)
[09:31:30.323]                 })
[09:31:30.323]             }))
[09:31:30.323]             future::FutureResult(value = ...future.value$value, 
[09:31:30.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.323]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.323]                     ...future.globalenv.names))
[09:31:30.323]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.323]         }, condition = base::local({
[09:31:30.323]             c <- base::c
[09:31:30.323]             inherits <- base::inherits
[09:31:30.323]             invokeRestart <- base::invokeRestart
[09:31:30.323]             length <- base::length
[09:31:30.323]             list <- base::list
[09:31:30.323]             seq.int <- base::seq.int
[09:31:30.323]             signalCondition <- base::signalCondition
[09:31:30.323]             sys.calls <- base::sys.calls
[09:31:30.323]             `[[` <- base::`[[`
[09:31:30.323]             `+` <- base::`+`
[09:31:30.323]             `<<-` <- base::`<<-`
[09:31:30.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.323]                   3L)]
[09:31:30.323]             }
[09:31:30.323]             function(cond) {
[09:31:30.323]                 is_error <- inherits(cond, "error")
[09:31:30.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.323]                   NULL)
[09:31:30.323]                 if (is_error) {
[09:31:30.323]                   sessionInformation <- function() {
[09:31:30.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.323]                       search = base::search(), system = base::Sys.info())
[09:31:30.323]                   }
[09:31:30.323]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.323]                     cond$call), session = sessionInformation(), 
[09:31:30.323]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.323]                   signalCondition(cond)
[09:31:30.323]                 }
[09:31:30.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.323]                 "immediateCondition"))) {
[09:31:30.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.323]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.323]                   if (TRUE && !signal) {
[09:31:30.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.323]                     {
[09:31:30.323]                       inherits <- base::inherits
[09:31:30.323]                       invokeRestart <- base::invokeRestart
[09:31:30.323]                       is.null <- base::is.null
[09:31:30.323]                       muffled <- FALSE
[09:31:30.323]                       if (inherits(cond, "message")) {
[09:31:30.323]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.323]                         if (muffled) 
[09:31:30.323]                           invokeRestart("muffleMessage")
[09:31:30.323]                       }
[09:31:30.323]                       else if (inherits(cond, "warning")) {
[09:31:30.323]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.323]                         if (muffled) 
[09:31:30.323]                           invokeRestart("muffleWarning")
[09:31:30.323]                       }
[09:31:30.323]                       else if (inherits(cond, "condition")) {
[09:31:30.323]                         if (!is.null(pattern)) {
[09:31:30.323]                           computeRestarts <- base::computeRestarts
[09:31:30.323]                           grepl <- base::grepl
[09:31:30.323]                           restarts <- computeRestarts(cond)
[09:31:30.323]                           for (restart in restarts) {
[09:31:30.323]                             name <- restart$name
[09:31:30.323]                             if (is.null(name)) 
[09:31:30.323]                               next
[09:31:30.323]                             if (!grepl(pattern, name)) 
[09:31:30.323]                               next
[09:31:30.323]                             invokeRestart(restart)
[09:31:30.323]                             muffled <- TRUE
[09:31:30.323]                             break
[09:31:30.323]                           }
[09:31:30.323]                         }
[09:31:30.323]                       }
[09:31:30.323]                       invisible(muffled)
[09:31:30.323]                     }
[09:31:30.323]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.323]                   }
[09:31:30.323]                 }
[09:31:30.323]                 else {
[09:31:30.323]                   if (TRUE) {
[09:31:30.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.323]                     {
[09:31:30.323]                       inherits <- base::inherits
[09:31:30.323]                       invokeRestart <- base::invokeRestart
[09:31:30.323]                       is.null <- base::is.null
[09:31:30.323]                       muffled <- FALSE
[09:31:30.323]                       if (inherits(cond, "message")) {
[09:31:30.323]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.323]                         if (muffled) 
[09:31:30.323]                           invokeRestart("muffleMessage")
[09:31:30.323]                       }
[09:31:30.323]                       else if (inherits(cond, "warning")) {
[09:31:30.323]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.323]                         if (muffled) 
[09:31:30.323]                           invokeRestart("muffleWarning")
[09:31:30.323]                       }
[09:31:30.323]                       else if (inherits(cond, "condition")) {
[09:31:30.323]                         if (!is.null(pattern)) {
[09:31:30.323]                           computeRestarts <- base::computeRestarts
[09:31:30.323]                           grepl <- base::grepl
[09:31:30.323]                           restarts <- computeRestarts(cond)
[09:31:30.323]                           for (restart in restarts) {
[09:31:30.323]                             name <- restart$name
[09:31:30.323]                             if (is.null(name)) 
[09:31:30.323]                               next
[09:31:30.323]                             if (!grepl(pattern, name)) 
[09:31:30.323]                               next
[09:31:30.323]                             invokeRestart(restart)
[09:31:30.323]                             muffled <- TRUE
[09:31:30.323]                             break
[09:31:30.323]                           }
[09:31:30.323]                         }
[09:31:30.323]                       }
[09:31:30.323]                       invisible(muffled)
[09:31:30.323]                     }
[09:31:30.323]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.323]                   }
[09:31:30.323]                 }
[09:31:30.323]             }
[09:31:30.323]         }))
[09:31:30.323]     }, error = function(ex) {
[09:31:30.323]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.323]                 ...future.rng), started = ...future.startTime, 
[09:31:30.323]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.323]             version = "1.8"), class = "FutureResult")
[09:31:30.323]     }, finally = {
[09:31:30.323]         if (!identical(...future.workdir, getwd())) 
[09:31:30.323]             setwd(...future.workdir)
[09:31:30.323]         {
[09:31:30.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.323]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.323]             }
[09:31:30.323]             base::options(...future.oldOptions)
[09:31:30.323]             if (.Platform$OS.type == "windows") {
[09:31:30.323]                 old_names <- names(...future.oldEnvVars)
[09:31:30.323]                 envs <- base::Sys.getenv()
[09:31:30.323]                 names <- names(envs)
[09:31:30.323]                 common <- intersect(names, old_names)
[09:31:30.323]                 added <- setdiff(names, old_names)
[09:31:30.323]                 removed <- setdiff(old_names, names)
[09:31:30.323]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.323]                   envs[common]]
[09:31:30.323]                 NAMES <- toupper(changed)
[09:31:30.323]                 args <- list()
[09:31:30.323]                 for (kk in seq_along(NAMES)) {
[09:31:30.323]                   name <- changed[[kk]]
[09:31:30.323]                   NAME <- NAMES[[kk]]
[09:31:30.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.323]                     next
[09:31:30.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.323]                 }
[09:31:30.323]                 NAMES <- toupper(added)
[09:31:30.323]                 for (kk in seq_along(NAMES)) {
[09:31:30.323]                   name <- added[[kk]]
[09:31:30.323]                   NAME <- NAMES[[kk]]
[09:31:30.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.323]                     next
[09:31:30.323]                   args[[name]] <- ""
[09:31:30.323]                 }
[09:31:30.323]                 NAMES <- toupper(removed)
[09:31:30.323]                 for (kk in seq_along(NAMES)) {
[09:31:30.323]                   name <- removed[[kk]]
[09:31:30.323]                   NAME <- NAMES[[kk]]
[09:31:30.323]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.323]                     next
[09:31:30.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.323]                 }
[09:31:30.323]                 if (length(args) > 0) 
[09:31:30.323]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.323]             }
[09:31:30.323]             else {
[09:31:30.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.323]             }
[09:31:30.323]             {
[09:31:30.323]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.323]                   0L) {
[09:31:30.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.323]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.323]                   base::options(opts)
[09:31:30.323]                 }
[09:31:30.323]                 {
[09:31:30.323]                   {
[09:31:30.323]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.323]                     NULL
[09:31:30.323]                   }
[09:31:30.323]                   options(future.plan = NULL)
[09:31:30.323]                   if (is.na(NA_character_)) 
[09:31:30.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.323]                     .init = FALSE)
[09:31:30.323]                 }
[09:31:30.323]             }
[09:31:30.323]         }
[09:31:30.323]     })
[09:31:30.323]     if (TRUE) {
[09:31:30.323]         base::sink(type = "output", split = FALSE)
[09:31:30.323]         if (TRUE) {
[09:31:30.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.323]         }
[09:31:30.323]         else {
[09:31:30.323]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.323]         }
[09:31:30.323]         base::close(...future.stdout)
[09:31:30.323]         ...future.stdout <- NULL
[09:31:30.323]     }
[09:31:30.323]     ...future.result$conditions <- ...future.conditions
[09:31:30.323]     ...future.result$finished <- base::Sys.time()
[09:31:30.323]     ...future.result
[09:31:30.323] }
[09:31:30.326] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.326] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.326] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.326] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.327] MultisessionFuture started
[09:31:30.327] - Launch lazy future ... done
[09:31:30.327] run() for ‘MultisessionFuture’ ... done
[09:31:30.327] result() for ClusterFuture ...
[09:31:30.328] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.328] - Validating connection of MultisessionFuture
[09:31:30.329] - received message: FutureResult
[09:31:30.329] - Received FutureResult
[09:31:30.329] - Erased future from FutureRegistry
[09:31:30.329] result() for ClusterFuture ...
[09:31:30.329] - result already collected: FutureResult
[09:31:30.329] result() for ClusterFuture ... done
[09:31:30.329] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.330] result() for ClusterFuture ... done
[09:31:30.330] result() for ClusterFuture ...
[09:31:30.330] - result already collected: FutureResult
[09:31:30.330] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.330] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.330] Searching for globals...
[09:31:30.332] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.332] Searching for globals ... DONE
[09:31:30.332] Resolving globals: TRUE
[09:31:30.333] Resolving any globals that are futures ...
[09:31:30.333] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.333] Resolving any globals that are futures ... DONE
[09:31:30.333] Resolving futures part of globals (recursively) ...
[09:31:30.333] resolve() on list ...
[09:31:30.333]  recursive: 99
[09:31:30.333]  length: 1
[09:31:30.334]  elements: ‘x’
[09:31:30.334]  length: 0 (resolved future 1)
[09:31:30.334] resolve() on list ... DONE
[09:31:30.334] - globals: [1] ‘x’
[09:31:30.334] Resolving futures part of globals (recursively) ... DONE
[09:31:30.334] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.334] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.335] - globals: [1] ‘x’
[09:31:30.335] 
[09:31:30.335] getGlobalsAndPackages() ... DONE
[09:31:30.335] run() for ‘Future’ ...
[09:31:30.335] - state: ‘created’
[09:31:30.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.348] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.349]   - Field: ‘node’
[09:31:30.349]   - Field: ‘label’
[09:31:30.349]   - Field: ‘local’
[09:31:30.349]   - Field: ‘owner’
[09:31:30.349]   - Field: ‘envir’
[09:31:30.349]   - Field: ‘workers’
[09:31:30.349]   - Field: ‘packages’
[09:31:30.349]   - Field: ‘gc’
[09:31:30.349]   - Field: ‘conditions’
[09:31:30.349]   - Field: ‘persistent’
[09:31:30.350]   - Field: ‘expr’
[09:31:30.350]   - Field: ‘uuid’
[09:31:30.350]   - Field: ‘seed’
[09:31:30.350]   - Field: ‘version’
[09:31:30.350]   - Field: ‘result’
[09:31:30.350]   - Field: ‘asynchronous’
[09:31:30.350]   - Field: ‘calls’
[09:31:30.350]   - Field: ‘globals’
[09:31:30.350]   - Field: ‘stdout’
[09:31:30.350]   - Field: ‘earlySignal’
[09:31:30.350]   - Field: ‘lazy’
[09:31:30.351]   - Field: ‘state’
[09:31:30.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.351] - Launch lazy future ...
[09:31:30.351] Packages needed by the future expression (n = 0): <none>
[09:31:30.351] Packages needed by future strategies (n = 0): <none>
[09:31:30.351] {
[09:31:30.351]     {
[09:31:30.351]         {
[09:31:30.351]             ...future.startTime <- base::Sys.time()
[09:31:30.351]             {
[09:31:30.351]                 {
[09:31:30.351]                   {
[09:31:30.351]                     {
[09:31:30.351]                       base::local({
[09:31:30.351]                         has_future <- base::requireNamespace("future", 
[09:31:30.351]                           quietly = TRUE)
[09:31:30.351]                         if (has_future) {
[09:31:30.351]                           ns <- base::getNamespace("future")
[09:31:30.351]                           version <- ns[[".package"]][["version"]]
[09:31:30.351]                           if (is.null(version)) 
[09:31:30.351]                             version <- utils::packageVersion("future")
[09:31:30.351]                         }
[09:31:30.351]                         else {
[09:31:30.351]                           version <- NULL
[09:31:30.351]                         }
[09:31:30.351]                         if (!has_future || version < "1.8.0") {
[09:31:30.351]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.351]                             "", base::R.version$version.string), 
[09:31:30.351]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.351]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.351]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.351]                               "release", "version")], collapse = " "), 
[09:31:30.351]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.351]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.351]                             info)
[09:31:30.351]                           info <- base::paste(info, collapse = "; ")
[09:31:30.351]                           if (!has_future) {
[09:31:30.351]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.351]                               info)
[09:31:30.351]                           }
[09:31:30.351]                           else {
[09:31:30.351]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.351]                               info, version)
[09:31:30.351]                           }
[09:31:30.351]                           base::stop(msg)
[09:31:30.351]                         }
[09:31:30.351]                       })
[09:31:30.351]                     }
[09:31:30.351]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.351]                     base::options(mc.cores = 1L)
[09:31:30.351]                   }
[09:31:30.351]                   ...future.strategy.old <- future::plan("list")
[09:31:30.351]                   options(future.plan = NULL)
[09:31:30.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.351]                 }
[09:31:30.351]                 ...future.workdir <- getwd()
[09:31:30.351]             }
[09:31:30.351]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.351]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.351]         }
[09:31:30.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.351]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.351]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.351]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.351]             base::names(...future.oldOptions))
[09:31:30.351]     }
[09:31:30.351]     if (FALSE) {
[09:31:30.351]     }
[09:31:30.351]     else {
[09:31:30.351]         if (TRUE) {
[09:31:30.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.351]                 open = "w")
[09:31:30.351]         }
[09:31:30.351]         else {
[09:31:30.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.351]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.351]         }
[09:31:30.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.351]             base::sink(type = "output", split = FALSE)
[09:31:30.351]             base::close(...future.stdout)
[09:31:30.351]         }, add = TRUE)
[09:31:30.351]     }
[09:31:30.351]     ...future.frame <- base::sys.nframe()
[09:31:30.351]     ...future.conditions <- base::list()
[09:31:30.351]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.351]     if (FALSE) {
[09:31:30.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.351]     }
[09:31:30.351]     ...future.result <- base::tryCatch({
[09:31:30.351]         base::withCallingHandlers({
[09:31:30.351]             ...future.value <- base::withVisible(base::local({
[09:31:30.351]                 ...future.makeSendCondition <- base::local({
[09:31:30.351]                   sendCondition <- NULL
[09:31:30.351]                   function(frame = 1L) {
[09:31:30.351]                     if (is.function(sendCondition)) 
[09:31:30.351]                       return(sendCondition)
[09:31:30.351]                     ns <- getNamespace("parallel")
[09:31:30.351]                     if (exists("sendData", mode = "function", 
[09:31:30.351]                       envir = ns)) {
[09:31:30.351]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.351]                         envir = ns)
[09:31:30.351]                       envir <- sys.frame(frame)
[09:31:30.351]                       master <- NULL
[09:31:30.351]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.351]                         !identical(envir, emptyenv())) {
[09:31:30.351]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.351]                           inherits = FALSE)) {
[09:31:30.351]                           master <- get("master", mode = "list", 
[09:31:30.351]                             envir = envir, inherits = FALSE)
[09:31:30.351]                           if (inherits(master, c("SOCKnode", 
[09:31:30.351]                             "SOCK0node"))) {
[09:31:30.351]                             sendCondition <<- function(cond) {
[09:31:30.351]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.351]                                 success = TRUE)
[09:31:30.351]                               parallel_sendData(master, data)
[09:31:30.351]                             }
[09:31:30.351]                             return(sendCondition)
[09:31:30.351]                           }
[09:31:30.351]                         }
[09:31:30.351]                         frame <- frame + 1L
[09:31:30.351]                         envir <- sys.frame(frame)
[09:31:30.351]                       }
[09:31:30.351]                     }
[09:31:30.351]                     sendCondition <<- function(cond) NULL
[09:31:30.351]                   }
[09:31:30.351]                 })
[09:31:30.351]                 withCallingHandlers({
[09:31:30.351]                   {
[09:31:30.351]                     x["a"] <- list(1)
[09:31:30.351]                     x
[09:31:30.351]                   }
[09:31:30.351]                 }, immediateCondition = function(cond) {
[09:31:30.351]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.351]                   sendCondition(cond)
[09:31:30.351]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.351]                   {
[09:31:30.351]                     inherits <- base::inherits
[09:31:30.351]                     invokeRestart <- base::invokeRestart
[09:31:30.351]                     is.null <- base::is.null
[09:31:30.351]                     muffled <- FALSE
[09:31:30.351]                     if (inherits(cond, "message")) {
[09:31:30.351]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.351]                       if (muffled) 
[09:31:30.351]                         invokeRestart("muffleMessage")
[09:31:30.351]                     }
[09:31:30.351]                     else if (inherits(cond, "warning")) {
[09:31:30.351]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.351]                       if (muffled) 
[09:31:30.351]                         invokeRestart("muffleWarning")
[09:31:30.351]                     }
[09:31:30.351]                     else if (inherits(cond, "condition")) {
[09:31:30.351]                       if (!is.null(pattern)) {
[09:31:30.351]                         computeRestarts <- base::computeRestarts
[09:31:30.351]                         grepl <- base::grepl
[09:31:30.351]                         restarts <- computeRestarts(cond)
[09:31:30.351]                         for (restart in restarts) {
[09:31:30.351]                           name <- restart$name
[09:31:30.351]                           if (is.null(name)) 
[09:31:30.351]                             next
[09:31:30.351]                           if (!grepl(pattern, name)) 
[09:31:30.351]                             next
[09:31:30.351]                           invokeRestart(restart)
[09:31:30.351]                           muffled <- TRUE
[09:31:30.351]                           break
[09:31:30.351]                         }
[09:31:30.351]                       }
[09:31:30.351]                     }
[09:31:30.351]                     invisible(muffled)
[09:31:30.351]                   }
[09:31:30.351]                   muffleCondition(cond)
[09:31:30.351]                 })
[09:31:30.351]             }))
[09:31:30.351]             future::FutureResult(value = ...future.value$value, 
[09:31:30.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.351]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.351]                     ...future.globalenv.names))
[09:31:30.351]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.351]         }, condition = base::local({
[09:31:30.351]             c <- base::c
[09:31:30.351]             inherits <- base::inherits
[09:31:30.351]             invokeRestart <- base::invokeRestart
[09:31:30.351]             length <- base::length
[09:31:30.351]             list <- base::list
[09:31:30.351]             seq.int <- base::seq.int
[09:31:30.351]             signalCondition <- base::signalCondition
[09:31:30.351]             sys.calls <- base::sys.calls
[09:31:30.351]             `[[` <- base::`[[`
[09:31:30.351]             `+` <- base::`+`
[09:31:30.351]             `<<-` <- base::`<<-`
[09:31:30.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.351]                   3L)]
[09:31:30.351]             }
[09:31:30.351]             function(cond) {
[09:31:30.351]                 is_error <- inherits(cond, "error")
[09:31:30.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.351]                   NULL)
[09:31:30.351]                 if (is_error) {
[09:31:30.351]                   sessionInformation <- function() {
[09:31:30.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.351]                       search = base::search(), system = base::Sys.info())
[09:31:30.351]                   }
[09:31:30.351]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.351]                     cond$call), session = sessionInformation(), 
[09:31:30.351]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.351]                   signalCondition(cond)
[09:31:30.351]                 }
[09:31:30.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.351]                 "immediateCondition"))) {
[09:31:30.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.351]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.351]                   if (TRUE && !signal) {
[09:31:30.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.351]                     {
[09:31:30.351]                       inherits <- base::inherits
[09:31:30.351]                       invokeRestart <- base::invokeRestart
[09:31:30.351]                       is.null <- base::is.null
[09:31:30.351]                       muffled <- FALSE
[09:31:30.351]                       if (inherits(cond, "message")) {
[09:31:30.351]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.351]                         if (muffled) 
[09:31:30.351]                           invokeRestart("muffleMessage")
[09:31:30.351]                       }
[09:31:30.351]                       else if (inherits(cond, "warning")) {
[09:31:30.351]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.351]                         if (muffled) 
[09:31:30.351]                           invokeRestart("muffleWarning")
[09:31:30.351]                       }
[09:31:30.351]                       else if (inherits(cond, "condition")) {
[09:31:30.351]                         if (!is.null(pattern)) {
[09:31:30.351]                           computeRestarts <- base::computeRestarts
[09:31:30.351]                           grepl <- base::grepl
[09:31:30.351]                           restarts <- computeRestarts(cond)
[09:31:30.351]                           for (restart in restarts) {
[09:31:30.351]                             name <- restart$name
[09:31:30.351]                             if (is.null(name)) 
[09:31:30.351]                               next
[09:31:30.351]                             if (!grepl(pattern, name)) 
[09:31:30.351]                               next
[09:31:30.351]                             invokeRestart(restart)
[09:31:30.351]                             muffled <- TRUE
[09:31:30.351]                             break
[09:31:30.351]                           }
[09:31:30.351]                         }
[09:31:30.351]                       }
[09:31:30.351]                       invisible(muffled)
[09:31:30.351]                     }
[09:31:30.351]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.351]                   }
[09:31:30.351]                 }
[09:31:30.351]                 else {
[09:31:30.351]                   if (TRUE) {
[09:31:30.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.351]                     {
[09:31:30.351]                       inherits <- base::inherits
[09:31:30.351]                       invokeRestart <- base::invokeRestart
[09:31:30.351]                       is.null <- base::is.null
[09:31:30.351]                       muffled <- FALSE
[09:31:30.351]                       if (inherits(cond, "message")) {
[09:31:30.351]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.351]                         if (muffled) 
[09:31:30.351]                           invokeRestart("muffleMessage")
[09:31:30.351]                       }
[09:31:30.351]                       else if (inherits(cond, "warning")) {
[09:31:30.351]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.351]                         if (muffled) 
[09:31:30.351]                           invokeRestart("muffleWarning")
[09:31:30.351]                       }
[09:31:30.351]                       else if (inherits(cond, "condition")) {
[09:31:30.351]                         if (!is.null(pattern)) {
[09:31:30.351]                           computeRestarts <- base::computeRestarts
[09:31:30.351]                           grepl <- base::grepl
[09:31:30.351]                           restarts <- computeRestarts(cond)
[09:31:30.351]                           for (restart in restarts) {
[09:31:30.351]                             name <- restart$name
[09:31:30.351]                             if (is.null(name)) 
[09:31:30.351]                               next
[09:31:30.351]                             if (!grepl(pattern, name)) 
[09:31:30.351]                               next
[09:31:30.351]                             invokeRestart(restart)
[09:31:30.351]                             muffled <- TRUE
[09:31:30.351]                             break
[09:31:30.351]                           }
[09:31:30.351]                         }
[09:31:30.351]                       }
[09:31:30.351]                       invisible(muffled)
[09:31:30.351]                     }
[09:31:30.351]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.351]                   }
[09:31:30.351]                 }
[09:31:30.351]             }
[09:31:30.351]         }))
[09:31:30.351]     }, error = function(ex) {
[09:31:30.351]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.351]                 ...future.rng), started = ...future.startTime, 
[09:31:30.351]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.351]             version = "1.8"), class = "FutureResult")
[09:31:30.351]     }, finally = {
[09:31:30.351]         if (!identical(...future.workdir, getwd())) 
[09:31:30.351]             setwd(...future.workdir)
[09:31:30.351]         {
[09:31:30.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.351]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.351]             }
[09:31:30.351]             base::options(...future.oldOptions)
[09:31:30.351]             if (.Platform$OS.type == "windows") {
[09:31:30.351]                 old_names <- names(...future.oldEnvVars)
[09:31:30.351]                 envs <- base::Sys.getenv()
[09:31:30.351]                 names <- names(envs)
[09:31:30.351]                 common <- intersect(names, old_names)
[09:31:30.351]                 added <- setdiff(names, old_names)
[09:31:30.351]                 removed <- setdiff(old_names, names)
[09:31:30.351]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.351]                   envs[common]]
[09:31:30.351]                 NAMES <- toupper(changed)
[09:31:30.351]                 args <- list()
[09:31:30.351]                 for (kk in seq_along(NAMES)) {
[09:31:30.351]                   name <- changed[[kk]]
[09:31:30.351]                   NAME <- NAMES[[kk]]
[09:31:30.351]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.351]                     next
[09:31:30.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.351]                 }
[09:31:30.351]                 NAMES <- toupper(added)
[09:31:30.351]                 for (kk in seq_along(NAMES)) {
[09:31:30.351]                   name <- added[[kk]]
[09:31:30.351]                   NAME <- NAMES[[kk]]
[09:31:30.351]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.351]                     next
[09:31:30.351]                   args[[name]] <- ""
[09:31:30.351]                 }
[09:31:30.351]                 NAMES <- toupper(removed)
[09:31:30.351]                 for (kk in seq_along(NAMES)) {
[09:31:30.351]                   name <- removed[[kk]]
[09:31:30.351]                   NAME <- NAMES[[kk]]
[09:31:30.351]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.351]                     next
[09:31:30.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.351]                 }
[09:31:30.351]                 if (length(args) > 0) 
[09:31:30.351]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.351]             }
[09:31:30.351]             else {
[09:31:30.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.351]             }
[09:31:30.351]             {
[09:31:30.351]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.351]                   0L) {
[09:31:30.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.351]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.351]                   base::options(opts)
[09:31:30.351]                 }
[09:31:30.351]                 {
[09:31:30.351]                   {
[09:31:30.351]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.351]                     NULL
[09:31:30.351]                   }
[09:31:30.351]                   options(future.plan = NULL)
[09:31:30.351]                   if (is.na(NA_character_)) 
[09:31:30.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.351]                     .init = FALSE)
[09:31:30.351]                 }
[09:31:30.351]             }
[09:31:30.351]         }
[09:31:30.351]     })
[09:31:30.351]     if (TRUE) {
[09:31:30.351]         base::sink(type = "output", split = FALSE)
[09:31:30.351]         if (TRUE) {
[09:31:30.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.351]         }
[09:31:30.351]         else {
[09:31:30.351]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.351]         }
[09:31:30.351]         base::close(...future.stdout)
[09:31:30.351]         ...future.stdout <- NULL
[09:31:30.351]     }
[09:31:30.351]     ...future.result$conditions <- ...future.conditions
[09:31:30.351]     ...future.result$finished <- base::Sys.time()
[09:31:30.351]     ...future.result
[09:31:30.351] }
[09:31:30.354] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.354] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.354] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.354] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.355] MultisessionFuture started
[09:31:30.355] - Launch lazy future ... done
[09:31:30.355] run() for ‘MultisessionFuture’ ... done
[09:31:30.355] result() for ClusterFuture ...
[09:31:30.355] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.355] - Validating connection of MultisessionFuture
[09:31:30.356] - received message: FutureResult
[09:31:30.356] - Received FutureResult
[09:31:30.356] - Erased future from FutureRegistry
[09:31:30.357] result() for ClusterFuture ...
[09:31:30.357] - result already collected: FutureResult
[09:31:30.357] result() for ClusterFuture ... done
[09:31:30.357] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.357] result() for ClusterFuture ... done
[09:31:30.357] result() for ClusterFuture ...
[09:31:30.357] - result already collected: FutureResult
[09:31:30.357] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.358] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.358] Searching for globals...
[09:31:30.360] - globals found: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.360] Searching for globals ... DONE
[09:31:30.360] Resolving globals: TRUE
[09:31:30.360] Resolving any globals that are futures ...
[09:31:30.360] - globals: [6] ‘{’, ‘x’, ‘<-’, ‘[’, ‘[<-’, ‘list’
[09:31:30.360] Resolving any globals that are futures ... DONE
[09:31:30.361] Resolving futures part of globals (recursively) ...
[09:31:30.361] resolve() on list ...
[09:31:30.361]  recursive: 99
[09:31:30.361]  length: 1
[09:31:30.361]  elements: ‘x’
[09:31:30.361]  length: 0 (resolved future 1)
[09:31:30.361] resolve() on list ... DONE
[09:31:30.361] - globals: [1] ‘x’
[09:31:30.361] Resolving futures part of globals (recursively) ... DONE
[09:31:30.362] The total size of the 1 globals is 0 bytes (0 bytes)
[09:31:30.362] The total size of the 1 globals exported for future expression (‘{; x["a"] <- list(1); x; }’) is 0 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (0 bytes of class ‘list’)
[09:31:30.362] - globals: [1] ‘x’
[09:31:30.362] 
[09:31:30.362] getGlobalsAndPackages() ... DONE
[09:31:30.362] run() for ‘Future’ ...
[09:31:30.363] - state: ‘created’
[09:31:30.363] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.376] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.376]   - Field: ‘node’
[09:31:30.376]   - Field: ‘label’
[09:31:30.376]   - Field: ‘local’
[09:31:30.376]   - Field: ‘owner’
[09:31:30.376]   - Field: ‘envir’
[09:31:30.377]   - Field: ‘workers’
[09:31:30.377]   - Field: ‘packages’
[09:31:30.377]   - Field: ‘gc’
[09:31:30.377]   - Field: ‘conditions’
[09:31:30.377]   - Field: ‘persistent’
[09:31:30.377]   - Field: ‘expr’
[09:31:30.377]   - Field: ‘uuid’
[09:31:30.377]   - Field: ‘seed’
[09:31:30.377]   - Field: ‘version’
[09:31:30.377]   - Field: ‘result’
[09:31:30.377]   - Field: ‘asynchronous’
[09:31:30.378]   - Field: ‘calls’
[09:31:30.378]   - Field: ‘globals’
[09:31:30.378]   - Field: ‘stdout’
[09:31:30.378]   - Field: ‘earlySignal’
[09:31:30.378]   - Field: ‘lazy’
[09:31:30.378]   - Field: ‘state’
[09:31:30.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.378] - Launch lazy future ...
[09:31:30.378] Packages needed by the future expression (n = 0): <none>
[09:31:30.379] Packages needed by future strategies (n = 0): <none>
[09:31:30.379] {
[09:31:30.379]     {
[09:31:30.379]         {
[09:31:30.379]             ...future.startTime <- base::Sys.time()
[09:31:30.379]             {
[09:31:30.379]                 {
[09:31:30.379]                   {
[09:31:30.379]                     {
[09:31:30.379]                       base::local({
[09:31:30.379]                         has_future <- base::requireNamespace("future", 
[09:31:30.379]                           quietly = TRUE)
[09:31:30.379]                         if (has_future) {
[09:31:30.379]                           ns <- base::getNamespace("future")
[09:31:30.379]                           version <- ns[[".package"]][["version"]]
[09:31:30.379]                           if (is.null(version)) 
[09:31:30.379]                             version <- utils::packageVersion("future")
[09:31:30.379]                         }
[09:31:30.379]                         else {
[09:31:30.379]                           version <- NULL
[09:31:30.379]                         }
[09:31:30.379]                         if (!has_future || version < "1.8.0") {
[09:31:30.379]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.379]                             "", base::R.version$version.string), 
[09:31:30.379]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.379]                               "release", "version")], collapse = " "), 
[09:31:30.379]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.379]                             info)
[09:31:30.379]                           info <- base::paste(info, collapse = "; ")
[09:31:30.379]                           if (!has_future) {
[09:31:30.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.379]                               info)
[09:31:30.379]                           }
[09:31:30.379]                           else {
[09:31:30.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.379]                               info, version)
[09:31:30.379]                           }
[09:31:30.379]                           base::stop(msg)
[09:31:30.379]                         }
[09:31:30.379]                       })
[09:31:30.379]                     }
[09:31:30.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.379]                     base::options(mc.cores = 1L)
[09:31:30.379]                   }
[09:31:30.379]                   ...future.strategy.old <- future::plan("list")
[09:31:30.379]                   options(future.plan = NULL)
[09:31:30.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.379]                 }
[09:31:30.379]                 ...future.workdir <- getwd()
[09:31:30.379]             }
[09:31:30.379]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.379]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.379]         }
[09:31:30.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.379]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.379]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.379]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.379]             base::names(...future.oldOptions))
[09:31:30.379]     }
[09:31:30.379]     if (FALSE) {
[09:31:30.379]     }
[09:31:30.379]     else {
[09:31:30.379]         if (TRUE) {
[09:31:30.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.379]                 open = "w")
[09:31:30.379]         }
[09:31:30.379]         else {
[09:31:30.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.379]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.379]         }
[09:31:30.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.379]             base::sink(type = "output", split = FALSE)
[09:31:30.379]             base::close(...future.stdout)
[09:31:30.379]         }, add = TRUE)
[09:31:30.379]     }
[09:31:30.379]     ...future.frame <- base::sys.nframe()
[09:31:30.379]     ...future.conditions <- base::list()
[09:31:30.379]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.379]     if (FALSE) {
[09:31:30.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.379]     }
[09:31:30.379]     ...future.result <- base::tryCatch({
[09:31:30.379]         base::withCallingHandlers({
[09:31:30.379]             ...future.value <- base::withVisible(base::local({
[09:31:30.379]                 ...future.makeSendCondition <- base::local({
[09:31:30.379]                   sendCondition <- NULL
[09:31:30.379]                   function(frame = 1L) {
[09:31:30.379]                     if (is.function(sendCondition)) 
[09:31:30.379]                       return(sendCondition)
[09:31:30.379]                     ns <- getNamespace("parallel")
[09:31:30.379]                     if (exists("sendData", mode = "function", 
[09:31:30.379]                       envir = ns)) {
[09:31:30.379]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.379]                         envir = ns)
[09:31:30.379]                       envir <- sys.frame(frame)
[09:31:30.379]                       master <- NULL
[09:31:30.379]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.379]                         !identical(envir, emptyenv())) {
[09:31:30.379]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.379]                           inherits = FALSE)) {
[09:31:30.379]                           master <- get("master", mode = "list", 
[09:31:30.379]                             envir = envir, inherits = FALSE)
[09:31:30.379]                           if (inherits(master, c("SOCKnode", 
[09:31:30.379]                             "SOCK0node"))) {
[09:31:30.379]                             sendCondition <<- function(cond) {
[09:31:30.379]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.379]                                 success = TRUE)
[09:31:30.379]                               parallel_sendData(master, data)
[09:31:30.379]                             }
[09:31:30.379]                             return(sendCondition)
[09:31:30.379]                           }
[09:31:30.379]                         }
[09:31:30.379]                         frame <- frame + 1L
[09:31:30.379]                         envir <- sys.frame(frame)
[09:31:30.379]                       }
[09:31:30.379]                     }
[09:31:30.379]                     sendCondition <<- function(cond) NULL
[09:31:30.379]                   }
[09:31:30.379]                 })
[09:31:30.379]                 withCallingHandlers({
[09:31:30.379]                   {
[09:31:30.379]                     x["a"] <- list(1)
[09:31:30.379]                     x
[09:31:30.379]                   }
[09:31:30.379]                 }, immediateCondition = function(cond) {
[09:31:30.379]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.379]                   sendCondition(cond)
[09:31:30.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.379]                   {
[09:31:30.379]                     inherits <- base::inherits
[09:31:30.379]                     invokeRestart <- base::invokeRestart
[09:31:30.379]                     is.null <- base::is.null
[09:31:30.379]                     muffled <- FALSE
[09:31:30.379]                     if (inherits(cond, "message")) {
[09:31:30.379]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.379]                       if (muffled) 
[09:31:30.379]                         invokeRestart("muffleMessage")
[09:31:30.379]                     }
[09:31:30.379]                     else if (inherits(cond, "warning")) {
[09:31:30.379]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.379]                       if (muffled) 
[09:31:30.379]                         invokeRestart("muffleWarning")
[09:31:30.379]                     }
[09:31:30.379]                     else if (inherits(cond, "condition")) {
[09:31:30.379]                       if (!is.null(pattern)) {
[09:31:30.379]                         computeRestarts <- base::computeRestarts
[09:31:30.379]                         grepl <- base::grepl
[09:31:30.379]                         restarts <- computeRestarts(cond)
[09:31:30.379]                         for (restart in restarts) {
[09:31:30.379]                           name <- restart$name
[09:31:30.379]                           if (is.null(name)) 
[09:31:30.379]                             next
[09:31:30.379]                           if (!grepl(pattern, name)) 
[09:31:30.379]                             next
[09:31:30.379]                           invokeRestart(restart)
[09:31:30.379]                           muffled <- TRUE
[09:31:30.379]                           break
[09:31:30.379]                         }
[09:31:30.379]                       }
[09:31:30.379]                     }
[09:31:30.379]                     invisible(muffled)
[09:31:30.379]                   }
[09:31:30.379]                   muffleCondition(cond)
[09:31:30.379]                 })
[09:31:30.379]             }))
[09:31:30.379]             future::FutureResult(value = ...future.value$value, 
[09:31:30.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.379]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.379]                     ...future.globalenv.names))
[09:31:30.379]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.379]         }, condition = base::local({
[09:31:30.379]             c <- base::c
[09:31:30.379]             inherits <- base::inherits
[09:31:30.379]             invokeRestart <- base::invokeRestart
[09:31:30.379]             length <- base::length
[09:31:30.379]             list <- base::list
[09:31:30.379]             seq.int <- base::seq.int
[09:31:30.379]             signalCondition <- base::signalCondition
[09:31:30.379]             sys.calls <- base::sys.calls
[09:31:30.379]             `[[` <- base::`[[`
[09:31:30.379]             `+` <- base::`+`
[09:31:30.379]             `<<-` <- base::`<<-`
[09:31:30.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.379]                   3L)]
[09:31:30.379]             }
[09:31:30.379]             function(cond) {
[09:31:30.379]                 is_error <- inherits(cond, "error")
[09:31:30.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.379]                   NULL)
[09:31:30.379]                 if (is_error) {
[09:31:30.379]                   sessionInformation <- function() {
[09:31:30.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.379]                       search = base::search(), system = base::Sys.info())
[09:31:30.379]                   }
[09:31:30.379]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.379]                     cond$call), session = sessionInformation(), 
[09:31:30.379]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.379]                   signalCondition(cond)
[09:31:30.379]                 }
[09:31:30.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.379]                 "immediateCondition"))) {
[09:31:30.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.379]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.379]                   if (TRUE && !signal) {
[09:31:30.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.379]                     {
[09:31:30.379]                       inherits <- base::inherits
[09:31:30.379]                       invokeRestart <- base::invokeRestart
[09:31:30.379]                       is.null <- base::is.null
[09:31:30.379]                       muffled <- FALSE
[09:31:30.379]                       if (inherits(cond, "message")) {
[09:31:30.379]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.379]                         if (muffled) 
[09:31:30.379]                           invokeRestart("muffleMessage")
[09:31:30.379]                       }
[09:31:30.379]                       else if (inherits(cond, "warning")) {
[09:31:30.379]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.379]                         if (muffled) 
[09:31:30.379]                           invokeRestart("muffleWarning")
[09:31:30.379]                       }
[09:31:30.379]                       else if (inherits(cond, "condition")) {
[09:31:30.379]                         if (!is.null(pattern)) {
[09:31:30.379]                           computeRestarts <- base::computeRestarts
[09:31:30.379]                           grepl <- base::grepl
[09:31:30.379]                           restarts <- computeRestarts(cond)
[09:31:30.379]                           for (restart in restarts) {
[09:31:30.379]                             name <- restart$name
[09:31:30.379]                             if (is.null(name)) 
[09:31:30.379]                               next
[09:31:30.379]                             if (!grepl(pattern, name)) 
[09:31:30.379]                               next
[09:31:30.379]                             invokeRestart(restart)
[09:31:30.379]                             muffled <- TRUE
[09:31:30.379]                             break
[09:31:30.379]                           }
[09:31:30.379]                         }
[09:31:30.379]                       }
[09:31:30.379]                       invisible(muffled)
[09:31:30.379]                     }
[09:31:30.379]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.379]                   }
[09:31:30.379]                 }
[09:31:30.379]                 else {
[09:31:30.379]                   if (TRUE) {
[09:31:30.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.379]                     {
[09:31:30.379]                       inherits <- base::inherits
[09:31:30.379]                       invokeRestart <- base::invokeRestart
[09:31:30.379]                       is.null <- base::is.null
[09:31:30.379]                       muffled <- FALSE
[09:31:30.379]                       if (inherits(cond, "message")) {
[09:31:30.379]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.379]                         if (muffled) 
[09:31:30.379]                           invokeRestart("muffleMessage")
[09:31:30.379]                       }
[09:31:30.379]                       else if (inherits(cond, "warning")) {
[09:31:30.379]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.379]                         if (muffled) 
[09:31:30.379]                           invokeRestart("muffleWarning")
[09:31:30.379]                       }
[09:31:30.379]                       else if (inherits(cond, "condition")) {
[09:31:30.379]                         if (!is.null(pattern)) {
[09:31:30.379]                           computeRestarts <- base::computeRestarts
[09:31:30.379]                           grepl <- base::grepl
[09:31:30.379]                           restarts <- computeRestarts(cond)
[09:31:30.379]                           for (restart in restarts) {
[09:31:30.379]                             name <- restart$name
[09:31:30.379]                             if (is.null(name)) 
[09:31:30.379]                               next
[09:31:30.379]                             if (!grepl(pattern, name)) 
[09:31:30.379]                               next
[09:31:30.379]                             invokeRestart(restart)
[09:31:30.379]                             muffled <- TRUE
[09:31:30.379]                             break
[09:31:30.379]                           }
[09:31:30.379]                         }
[09:31:30.379]                       }
[09:31:30.379]                       invisible(muffled)
[09:31:30.379]                     }
[09:31:30.379]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.379]                   }
[09:31:30.379]                 }
[09:31:30.379]             }
[09:31:30.379]         }))
[09:31:30.379]     }, error = function(ex) {
[09:31:30.379]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.379]                 ...future.rng), started = ...future.startTime, 
[09:31:30.379]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.379]             version = "1.8"), class = "FutureResult")
[09:31:30.379]     }, finally = {
[09:31:30.379]         if (!identical(...future.workdir, getwd())) 
[09:31:30.379]             setwd(...future.workdir)
[09:31:30.379]         {
[09:31:30.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.379]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.379]             }
[09:31:30.379]             base::options(...future.oldOptions)
[09:31:30.379]             if (.Platform$OS.type == "windows") {
[09:31:30.379]                 old_names <- names(...future.oldEnvVars)
[09:31:30.379]                 envs <- base::Sys.getenv()
[09:31:30.379]                 names <- names(envs)
[09:31:30.379]                 common <- intersect(names, old_names)
[09:31:30.379]                 added <- setdiff(names, old_names)
[09:31:30.379]                 removed <- setdiff(old_names, names)
[09:31:30.379]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.379]                   envs[common]]
[09:31:30.379]                 NAMES <- toupper(changed)
[09:31:30.379]                 args <- list()
[09:31:30.379]                 for (kk in seq_along(NAMES)) {
[09:31:30.379]                   name <- changed[[kk]]
[09:31:30.379]                   NAME <- NAMES[[kk]]
[09:31:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.379]                     next
[09:31:30.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.379]                 }
[09:31:30.379]                 NAMES <- toupper(added)
[09:31:30.379]                 for (kk in seq_along(NAMES)) {
[09:31:30.379]                   name <- added[[kk]]
[09:31:30.379]                   NAME <- NAMES[[kk]]
[09:31:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.379]                     next
[09:31:30.379]                   args[[name]] <- ""
[09:31:30.379]                 }
[09:31:30.379]                 NAMES <- toupper(removed)
[09:31:30.379]                 for (kk in seq_along(NAMES)) {
[09:31:30.379]                   name <- removed[[kk]]
[09:31:30.379]                   NAME <- NAMES[[kk]]
[09:31:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.379]                     next
[09:31:30.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.379]                 }
[09:31:30.379]                 if (length(args) > 0) 
[09:31:30.379]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.379]             }
[09:31:30.379]             else {
[09:31:30.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.379]             }
[09:31:30.379]             {
[09:31:30.379]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.379]                   0L) {
[09:31:30.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.379]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.379]                   base::options(opts)
[09:31:30.379]                 }
[09:31:30.379]                 {
[09:31:30.379]                   {
[09:31:30.379]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.379]                     NULL
[09:31:30.379]                   }
[09:31:30.379]                   options(future.plan = NULL)
[09:31:30.379]                   if (is.na(NA_character_)) 
[09:31:30.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.379]                     .init = FALSE)
[09:31:30.379]                 }
[09:31:30.379]             }
[09:31:30.379]         }
[09:31:30.379]     })
[09:31:30.379]     if (TRUE) {
[09:31:30.379]         base::sink(type = "output", split = FALSE)
[09:31:30.379]         if (TRUE) {
[09:31:30.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.379]         }
[09:31:30.379]         else {
[09:31:30.379]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.379]         }
[09:31:30.379]         base::close(...future.stdout)
[09:31:30.379]         ...future.stdout <- NULL
[09:31:30.379]     }
[09:31:30.379]     ...future.result$conditions <- ...future.conditions
[09:31:30.379]     ...future.result$finished <- base::Sys.time()
[09:31:30.379]     ...future.result
[09:31:30.379] }
[09:31:30.381] Exporting 1 global objects (0 bytes) to cluster node #1 ...
[09:31:30.381] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.382] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.382] Exporting 1 global objects (0 bytes) to cluster node #1 ... DONE
[09:31:30.382] MultisessionFuture started
[09:31:30.383] - Launch lazy future ... done
[09:31:30.383] run() for ‘MultisessionFuture’ ... done
[09:31:30.383] result() for ClusterFuture ...
[09:31:30.383] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.383] - Validating connection of MultisessionFuture
[09:31:30.384] - received message: FutureResult
[09:31:30.384] - Received FutureResult
[09:31:30.384] - Erased future from FutureRegistry
[09:31:30.385] result() for ClusterFuture ...
[09:31:30.385] - result already collected: FutureResult
[09:31:30.385] result() for ClusterFuture ... done
[09:31:30.385] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.385] result() for ClusterFuture ... done
[09:31:30.385] result() for ClusterFuture ...
[09:31:30.385] - result already collected: FutureResult
[09:31:30.385] result() for ClusterFuture ... done
$a
[1] 1

Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:30.386] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:30.386] Searching for globals...
[09:31:30.388] - globals found: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:30.388] Searching for globals ... DONE
[09:31:30.388] Resolving globals: TRUE
[09:31:30.388] Resolving any globals that are futures ...
[09:31:30.388] - globals: [7] ‘{’, ‘x’, ‘<-’, ‘[’, ‘name’, ‘[<-’, ‘list’
[09:31:30.388] Resolving any globals that are futures ... DONE
[09:31:30.389] Resolving futures part of globals (recursively) ...
[09:31:30.389] resolve() on list ...
[09:31:30.389]  recursive: 99
[09:31:30.389]  length: 2
[09:31:30.389]  elements: ‘x’, ‘name’
[09:31:30.389]  length: 1 (resolved future 1)
[09:31:30.389]  length: 0 (resolved future 2)
[09:31:30.389] resolve() on list ... DONE
[09:31:30.390] - globals: [2] ‘x’, ‘name’
[09:31:30.390] Resolving futures part of globals (recursively) ... DONE
[09:31:30.390] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:30.390] The total size of the 2 globals exported for future expression (‘{; x[name] <- list(1); x; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘name’ (112 bytes of class ‘character’) and ‘x’ (0 bytes of class ‘list’)
[09:31:30.390] - globals: [2] ‘x’, ‘name’
[09:31:30.390] 
[09:31:30.390] getGlobalsAndPackages() ... DONE
[09:31:30.391] run() for ‘Future’ ...
[09:31:30.391] - state: ‘created’
[09:31:30.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:30.404] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:30.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:30.404]   - Field: ‘node’
[09:31:30.404]   - Field: ‘label’
[09:31:30.405]   - Field: ‘local’
[09:31:30.405]   - Field: ‘owner’
[09:31:30.405]   - Field: ‘envir’
[09:31:30.405]   - Field: ‘workers’
[09:31:30.405]   - Field: ‘packages’
[09:31:30.405]   - Field: ‘gc’
[09:31:30.405]   - Field: ‘conditions’
[09:31:30.405]   - Field: ‘persistent’
[09:31:30.405]   - Field: ‘expr’
[09:31:30.405]   - Field: ‘uuid’
[09:31:30.405]   - Field: ‘seed’
[09:31:30.406]   - Field: ‘version’
[09:31:30.406]   - Field: ‘result’
[09:31:30.406]   - Field: ‘asynchronous’
[09:31:30.406]   - Field: ‘calls’
[09:31:30.406]   - Field: ‘globals’
[09:31:30.406]   - Field: ‘stdout’
[09:31:30.406]   - Field: ‘earlySignal’
[09:31:30.406]   - Field: ‘lazy’
[09:31:30.406]   - Field: ‘state’
[09:31:30.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:30.406] - Launch lazy future ...
[09:31:30.407] Packages needed by the future expression (n = 0): <none>
[09:31:30.407] Packages needed by future strategies (n = 0): <none>
[09:31:30.407] {
[09:31:30.407]     {
[09:31:30.407]         {
[09:31:30.407]             ...future.startTime <- base::Sys.time()
[09:31:30.407]             {
[09:31:30.407]                 {
[09:31:30.407]                   {
[09:31:30.407]                     {
[09:31:30.407]                       base::local({
[09:31:30.407]                         has_future <- base::requireNamespace("future", 
[09:31:30.407]                           quietly = TRUE)
[09:31:30.407]                         if (has_future) {
[09:31:30.407]                           ns <- base::getNamespace("future")
[09:31:30.407]                           version <- ns[[".package"]][["version"]]
[09:31:30.407]                           if (is.null(version)) 
[09:31:30.407]                             version <- utils::packageVersion("future")
[09:31:30.407]                         }
[09:31:30.407]                         else {
[09:31:30.407]                           version <- NULL
[09:31:30.407]                         }
[09:31:30.407]                         if (!has_future || version < "1.8.0") {
[09:31:30.407]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:30.407]                             "", base::R.version$version.string), 
[09:31:30.407]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:30.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:30.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:30.407]                               "release", "version")], collapse = " "), 
[09:31:30.407]                             hostname = base::Sys.info()[["nodename"]])
[09:31:30.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:30.407]                             info)
[09:31:30.407]                           info <- base::paste(info, collapse = "; ")
[09:31:30.407]                           if (!has_future) {
[09:31:30.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:30.407]                               info)
[09:31:30.407]                           }
[09:31:30.407]                           else {
[09:31:30.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:30.407]                               info, version)
[09:31:30.407]                           }
[09:31:30.407]                           base::stop(msg)
[09:31:30.407]                         }
[09:31:30.407]                       })
[09:31:30.407]                     }
[09:31:30.407]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:30.407]                     base::options(mc.cores = 1L)
[09:31:30.407]                   }
[09:31:30.407]                   ...future.strategy.old <- future::plan("list")
[09:31:30.407]                   options(future.plan = NULL)
[09:31:30.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:30.407]                 }
[09:31:30.407]                 ...future.workdir <- getwd()
[09:31:30.407]             }
[09:31:30.407]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:30.407]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:30.407]         }
[09:31:30.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:30.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:30.407]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:30.407]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:30.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:30.407]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:30.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:30.407]             base::names(...future.oldOptions))
[09:31:30.407]     }
[09:31:30.407]     if (FALSE) {
[09:31:30.407]     }
[09:31:30.407]     else {
[09:31:30.407]         if (TRUE) {
[09:31:30.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:30.407]                 open = "w")
[09:31:30.407]         }
[09:31:30.407]         else {
[09:31:30.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:30.407]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:30.407]         }
[09:31:30.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:30.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:30.407]             base::sink(type = "output", split = FALSE)
[09:31:30.407]             base::close(...future.stdout)
[09:31:30.407]         }, add = TRUE)
[09:31:30.407]     }
[09:31:30.407]     ...future.frame <- base::sys.nframe()
[09:31:30.407]     ...future.conditions <- base::list()
[09:31:30.407]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:30.407]     if (FALSE) {
[09:31:30.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:30.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:30.407]     }
[09:31:30.407]     ...future.result <- base::tryCatch({
[09:31:30.407]         base::withCallingHandlers({
[09:31:30.407]             ...future.value <- base::withVisible(base::local({
[09:31:30.407]                 ...future.makeSendCondition <- base::local({
[09:31:30.407]                   sendCondition <- NULL
[09:31:30.407]                   function(frame = 1L) {
[09:31:30.407]                     if (is.function(sendCondition)) 
[09:31:30.407]                       return(sendCondition)
[09:31:30.407]                     ns <- getNamespace("parallel")
[09:31:30.407]                     if (exists("sendData", mode = "function", 
[09:31:30.407]                       envir = ns)) {
[09:31:30.407]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:30.407]                         envir = ns)
[09:31:30.407]                       envir <- sys.frame(frame)
[09:31:30.407]                       master <- NULL
[09:31:30.407]                       while (!identical(envir, .GlobalEnv) && 
[09:31:30.407]                         !identical(envir, emptyenv())) {
[09:31:30.407]                         if (exists("master", mode = "list", envir = envir, 
[09:31:30.407]                           inherits = FALSE)) {
[09:31:30.407]                           master <- get("master", mode = "list", 
[09:31:30.407]                             envir = envir, inherits = FALSE)
[09:31:30.407]                           if (inherits(master, c("SOCKnode", 
[09:31:30.407]                             "SOCK0node"))) {
[09:31:30.407]                             sendCondition <<- function(cond) {
[09:31:30.407]                               data <- list(type = "VALUE", value = cond, 
[09:31:30.407]                                 success = TRUE)
[09:31:30.407]                               parallel_sendData(master, data)
[09:31:30.407]                             }
[09:31:30.407]                             return(sendCondition)
[09:31:30.407]                           }
[09:31:30.407]                         }
[09:31:30.407]                         frame <- frame + 1L
[09:31:30.407]                         envir <- sys.frame(frame)
[09:31:30.407]                       }
[09:31:30.407]                     }
[09:31:30.407]                     sendCondition <<- function(cond) NULL
[09:31:30.407]                   }
[09:31:30.407]                 })
[09:31:30.407]                 withCallingHandlers({
[09:31:30.407]                   {
[09:31:30.407]                     x[name] <- list(1)
[09:31:30.407]                     x
[09:31:30.407]                   }
[09:31:30.407]                 }, immediateCondition = function(cond) {
[09:31:30.407]                   sendCondition <- ...future.makeSendCondition()
[09:31:30.407]                   sendCondition(cond)
[09:31:30.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.407]                   {
[09:31:30.407]                     inherits <- base::inherits
[09:31:30.407]                     invokeRestart <- base::invokeRestart
[09:31:30.407]                     is.null <- base::is.null
[09:31:30.407]                     muffled <- FALSE
[09:31:30.407]                     if (inherits(cond, "message")) {
[09:31:30.407]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:30.407]                       if (muffled) 
[09:31:30.407]                         invokeRestart("muffleMessage")
[09:31:30.407]                     }
[09:31:30.407]                     else if (inherits(cond, "warning")) {
[09:31:30.407]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:30.407]                       if (muffled) 
[09:31:30.407]                         invokeRestart("muffleWarning")
[09:31:30.407]                     }
[09:31:30.407]                     else if (inherits(cond, "condition")) {
[09:31:30.407]                       if (!is.null(pattern)) {
[09:31:30.407]                         computeRestarts <- base::computeRestarts
[09:31:30.407]                         grepl <- base::grepl
[09:31:30.407]                         restarts <- computeRestarts(cond)
[09:31:30.407]                         for (restart in restarts) {
[09:31:30.407]                           name <- restart$name
[09:31:30.407]                           if (is.null(name)) 
[09:31:30.407]                             next
[09:31:30.407]                           if (!grepl(pattern, name)) 
[09:31:30.407]                             next
[09:31:30.407]                           invokeRestart(restart)
[09:31:30.407]                           muffled <- TRUE
[09:31:30.407]                           break
[09:31:30.407]                         }
[09:31:30.407]                       }
[09:31:30.407]                     }
[09:31:30.407]                     invisible(muffled)
[09:31:30.407]                   }
[09:31:30.407]                   muffleCondition(cond)
[09:31:30.407]                 })
[09:31:30.407]             }))
[09:31:30.407]             future::FutureResult(value = ...future.value$value, 
[09:31:30.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.407]                   ...future.rng), globalenv = if (FALSE) 
[09:31:30.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:30.407]                     ...future.globalenv.names))
[09:31:30.407]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:30.407]         }, condition = base::local({
[09:31:30.407]             c <- base::c
[09:31:30.407]             inherits <- base::inherits
[09:31:30.407]             invokeRestart <- base::invokeRestart
[09:31:30.407]             length <- base::length
[09:31:30.407]             list <- base::list
[09:31:30.407]             seq.int <- base::seq.int
[09:31:30.407]             signalCondition <- base::signalCondition
[09:31:30.407]             sys.calls <- base::sys.calls
[09:31:30.407]             `[[` <- base::`[[`
[09:31:30.407]             `+` <- base::`+`
[09:31:30.407]             `<<-` <- base::`<<-`
[09:31:30.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:30.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:30.407]                   3L)]
[09:31:30.407]             }
[09:31:30.407]             function(cond) {
[09:31:30.407]                 is_error <- inherits(cond, "error")
[09:31:30.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:30.407]                   NULL)
[09:31:30.407]                 if (is_error) {
[09:31:30.407]                   sessionInformation <- function() {
[09:31:30.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:30.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:30.407]                       search = base::search(), system = base::Sys.info())
[09:31:30.407]                   }
[09:31:30.407]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:30.407]                     cond$call), session = sessionInformation(), 
[09:31:30.407]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:30.407]                   signalCondition(cond)
[09:31:30.407]                 }
[09:31:30.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:30.407]                 "immediateCondition"))) {
[09:31:30.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:30.407]                   ...future.conditions[[length(...future.conditions) + 
[09:31:30.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:30.407]                   if (TRUE && !signal) {
[09:31:30.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.407]                     {
[09:31:30.407]                       inherits <- base::inherits
[09:31:30.407]                       invokeRestart <- base::invokeRestart
[09:31:30.407]                       is.null <- base::is.null
[09:31:30.407]                       muffled <- FALSE
[09:31:30.407]                       if (inherits(cond, "message")) {
[09:31:30.407]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.407]                         if (muffled) 
[09:31:30.407]                           invokeRestart("muffleMessage")
[09:31:30.407]                       }
[09:31:30.407]                       else if (inherits(cond, "warning")) {
[09:31:30.407]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.407]                         if (muffled) 
[09:31:30.407]                           invokeRestart("muffleWarning")
[09:31:30.407]                       }
[09:31:30.407]                       else if (inherits(cond, "condition")) {
[09:31:30.407]                         if (!is.null(pattern)) {
[09:31:30.407]                           computeRestarts <- base::computeRestarts
[09:31:30.407]                           grepl <- base::grepl
[09:31:30.407]                           restarts <- computeRestarts(cond)
[09:31:30.407]                           for (restart in restarts) {
[09:31:30.407]                             name <- restart$name
[09:31:30.407]                             if (is.null(name)) 
[09:31:30.407]                               next
[09:31:30.407]                             if (!grepl(pattern, name)) 
[09:31:30.407]                               next
[09:31:30.407]                             invokeRestart(restart)
[09:31:30.407]                             muffled <- TRUE
[09:31:30.407]                             break
[09:31:30.407]                           }
[09:31:30.407]                         }
[09:31:30.407]                       }
[09:31:30.407]                       invisible(muffled)
[09:31:30.407]                     }
[09:31:30.407]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.407]                   }
[09:31:30.407]                 }
[09:31:30.407]                 else {
[09:31:30.407]                   if (TRUE) {
[09:31:30.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:30.407]                     {
[09:31:30.407]                       inherits <- base::inherits
[09:31:30.407]                       invokeRestart <- base::invokeRestart
[09:31:30.407]                       is.null <- base::is.null
[09:31:30.407]                       muffled <- FALSE
[09:31:30.407]                       if (inherits(cond, "message")) {
[09:31:30.407]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:30.407]                         if (muffled) 
[09:31:30.407]                           invokeRestart("muffleMessage")
[09:31:30.407]                       }
[09:31:30.407]                       else if (inherits(cond, "warning")) {
[09:31:30.407]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:30.407]                         if (muffled) 
[09:31:30.407]                           invokeRestart("muffleWarning")
[09:31:30.407]                       }
[09:31:30.407]                       else if (inherits(cond, "condition")) {
[09:31:30.407]                         if (!is.null(pattern)) {
[09:31:30.407]                           computeRestarts <- base::computeRestarts
[09:31:30.407]                           grepl <- base::grepl
[09:31:30.407]                           restarts <- computeRestarts(cond)
[09:31:30.407]                           for (restart in restarts) {
[09:31:30.407]                             name <- restart$name
[09:31:30.407]                             if (is.null(name)) 
[09:31:30.407]                               next
[09:31:30.407]                             if (!grepl(pattern, name)) 
[09:31:30.407]                               next
[09:31:30.407]                             invokeRestart(restart)
[09:31:30.407]                             muffled <- TRUE
[09:31:30.407]                             break
[09:31:30.407]                           }
[09:31:30.407]                         }
[09:31:30.407]                       }
[09:31:30.407]                       invisible(muffled)
[09:31:30.407]                     }
[09:31:30.407]                     muffleCondition(cond, pattern = "^muffle")
[09:31:30.407]                   }
[09:31:30.407]                 }
[09:31:30.407]             }
[09:31:30.407]         }))
[09:31:30.407]     }, error = function(ex) {
[09:31:30.407]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:30.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:30.407]                 ...future.rng), started = ...future.startTime, 
[09:31:30.407]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:30.407]             version = "1.8"), class = "FutureResult")
[09:31:30.407]     }, finally = {
[09:31:30.407]         if (!identical(...future.workdir, getwd())) 
[09:31:30.407]             setwd(...future.workdir)
[09:31:30.407]         {
[09:31:30.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:30.407]                 ...future.oldOptions$nwarnings <- NULL
[09:31:30.407]             }
[09:31:30.407]             base::options(...future.oldOptions)
[09:31:30.407]             if (.Platform$OS.type == "windows") {
[09:31:30.407]                 old_names <- names(...future.oldEnvVars)
[09:31:30.407]                 envs <- base::Sys.getenv()
[09:31:30.407]                 names <- names(envs)
[09:31:30.407]                 common <- intersect(names, old_names)
[09:31:30.407]                 added <- setdiff(names, old_names)
[09:31:30.407]                 removed <- setdiff(old_names, names)
[09:31:30.407]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:30.407]                   envs[common]]
[09:31:30.407]                 NAMES <- toupper(changed)
[09:31:30.407]                 args <- list()
[09:31:30.407]                 for (kk in seq_along(NAMES)) {
[09:31:30.407]                   name <- changed[[kk]]
[09:31:30.407]                   NAME <- NAMES[[kk]]
[09:31:30.407]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.407]                     next
[09:31:30.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.407]                 }
[09:31:30.407]                 NAMES <- toupper(added)
[09:31:30.407]                 for (kk in seq_along(NAMES)) {
[09:31:30.407]                   name <- added[[kk]]
[09:31:30.407]                   NAME <- NAMES[[kk]]
[09:31:30.407]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.407]                     next
[09:31:30.407]                   args[[name]] <- ""
[09:31:30.407]                 }
[09:31:30.407]                 NAMES <- toupper(removed)
[09:31:30.407]                 for (kk in seq_along(NAMES)) {
[09:31:30.407]                   name <- removed[[kk]]
[09:31:30.407]                   NAME <- NAMES[[kk]]
[09:31:30.407]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:30.407]                     next
[09:31:30.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:30.407]                 }
[09:31:30.407]                 if (length(args) > 0) 
[09:31:30.407]                   base::do.call(base::Sys.setenv, args = args)
[09:31:30.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:30.407]             }
[09:31:30.407]             else {
[09:31:30.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:30.407]             }
[09:31:30.407]             {
[09:31:30.407]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:30.407]                   0L) {
[09:31:30.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:30.407]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:30.407]                   base::options(opts)
[09:31:30.407]                 }
[09:31:30.407]                 {
[09:31:30.407]                   {
[09:31:30.407]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:30.407]                     NULL
[09:31:30.407]                   }
[09:31:30.407]                   options(future.plan = NULL)
[09:31:30.407]                   if (is.na(NA_character_)) 
[09:31:30.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:30.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:30.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:30.407]                     .init = FALSE)
[09:31:30.407]                 }
[09:31:30.407]             }
[09:31:30.407]         }
[09:31:30.407]     })
[09:31:30.407]     if (TRUE) {
[09:31:30.407]         base::sink(type = "output", split = FALSE)
[09:31:30.407]         if (TRUE) {
[09:31:30.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:30.407]         }
[09:31:30.407]         else {
[09:31:30.407]             ...future.result["stdout"] <- base::list(NULL)
[09:31:30.407]         }
[09:31:30.407]         base::close(...future.stdout)
[09:31:30.407]         ...future.stdout <- NULL
[09:31:30.407]     }
[09:31:30.407]     ...future.result$conditions <- ...future.conditions
[09:31:30.407]     ...future.result$finished <- base::Sys.time()
[09:31:30.407]     ...future.result
[09:31:30.407] }
[09:31:30.410] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[09:31:30.410] Exporting ‘x’ (0 bytes) to cluster node #1 ...
[09:31:30.410] Exporting ‘x’ (0 bytes) to cluster node #1 ... DONE
[09:31:30.410] Exporting ‘name’ (112 bytes) to cluster node #1 ...
[09:31:30.411] Exporting ‘name’ (112 bytes) to cluster node #1 ... DONE
[09:31:30.411] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[09:31:30.411] MultisessionFuture started
[09:31:30.411] - Launch lazy future ... done
[09:31:30.411] run() for ‘MultisessionFuture’ ... done
[09:31:30.411] result() for ClusterFuture ...
[09:31:30.412] receiveMessageFromWorker() for ClusterFuture ...
[09:31:30.412] - Validating connection of MultisessionFuture
[09:31:30.412] - received message: FutureResult
[09:31:30.413] - Received FutureResult
[09:31:30.413] - Erased future from FutureRegistry
[09:31:30.413] result() for ClusterFuture ...
[09:31:30.413] - result already collected: FutureResult
[09:31:30.413] result() for ClusterFuture ... done
[09:31:30.413] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:30.413] result() for ClusterFuture ... done
[09:31:30.413] result() for ClusterFuture ...
[09:31:30.413] - result already collected: FutureResult
[09:31:30.413] result() for ClusterFuture ... done
$a
[1] 1

Testing with 2 cores ... DONE
> 
> message("*** Globals - subassignments w/ x$a <- value ... DONE")
*** Globals - subassignments w/ x$a <- value ... DONE
> 
> message("*** Globals - subassignments ... DONE")
*** Globals - subassignments ... DONE
> 
> source("incl/end.R")
[09:31:30.416] plan(): Setting new future strategy stack:
[09:31:30.416] List of future strategies:
[09:31:30.416] 1. FutureStrategy:
[09:31:30.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:30.416]    - tweaked: FALSE
[09:31:30.416]    - call: future::plan(oplan)
[09:31:30.417] plan(): nbrOfWorkers() = 1
> 
